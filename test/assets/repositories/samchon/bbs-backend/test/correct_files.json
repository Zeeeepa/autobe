{
  ".env.local": "API_PORT=37001",
  ".eslintrc.cjs": "module.exports = {\n  root: true,\n  plugins: [\"@typescript-eslint\", \"deprecation\"],\n  extends: [\"plugin:@typescript-eslint/recommended\"],\n  parser: \"@typescript-eslint/parser\",\n  parserOptions: {\n    project: [\"tsconfig.json\", \"test/tsconfig.json\"],\n  },\n  overrides: [\n    {\n      files: [\"src/**/*.ts\", \"test/**/*.ts\"],\n      rules: {\n        \"@typescript-eslint/consistent-type-definitions\": \"off\",\n        \"@typescript-eslint/no-empty-function\": \"off\",\n        \"@typescript-eslint/no-empty-interface\": \"off\",\n        \"@typescript-eslint/no-explicit-any\": \"off\",\n        \"@typescript-eslint/no-inferrable-types\": \"off\",\n        \"@typescript-eslint/no-namespace\": \"off\",\n        \"@typescript-eslint/no-non-null-assertion\": \"off\",\n        \"@typescript-eslint/no-unused-vars\": \"off\",\n        \"@typescript-eslint/no-var-requires\": \"off\",\n        \"@typescript-eslint/no-floating-promises\": \"error\",\n        \"@typescript-eslint/no-require-imports\": \"off\",\n        \"@typescript-eslint/no-empty-object-type\": \"off\",\n      },\n    },\n  ],\n};\n",
  ".github/workflows/build.yml": "name: build\non:\n  pull_request:\n    paths:\n      - 'src/**'\n      - 'test/**'\n      - 'package.json'\njobs:\n  Ubuntu:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n        with:\n          node-version: 20.x\n      - uses: pnpm/action-setup@v4\n        with:\n          version: 8\n      \n      - name: Install Backend-Server\n        run: pnpm install\n\n      - name: Build Swagger\n        run: npm run build:swagger\n\n      - name: Build SDK\n        run: npm run build:sdk\n\n      - name: Compile Backend-Server\n        run: npm run build\n\n      - name: Run Test Program\n        run: npm run test -- --simultaneous 16\n\n      - name: EsLint\n        run: npm run eslint\n",
  ".github/workflows/typos.yml": "name: typos\non:\n  pull_request:\n\njobs:\n  typos:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout Actions Repository\n        uses: actions/checkout@v4\n\n      - uses: crate-ci/typos@master\n        with:\n          config: ./typos.toml\n",
  ".gitignore": ".git/\nbin/\ndist/\nlib/\nnode_modules/\npackages/api/lib/\n\n.env\npackage-lock.json\npnpm-lock.yaml",
  ".prettierignore": "dist\nbin\nnode_modules\npackages\nsrc/api/functional\nsrc/api/utils/NestiaSimulator.ts\nREADME.md\ntsconfig.json",
  ".vscode/launch.json": "{\n  // Use IntelliSense to learn about possible Node.js debug attributes.\n  // Hover to view descriptions of existing attributes.\n  // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387\n  \"version\": \"0.2.0\",\n  \"configurations\": [\n  {\n    \"type\": \"node\",\n    \"request\": \"launch\",\n    \"name\": \"Backend Test\",\n    \"program\": \"${workspaceRoot}/test/index.ts\",\n    \"cwd\": \"${workspaceRoot}\",\n    \"args\": [\n      // //----\n      // // Not possible to reset DB in debugging mode\n      // //\n      // // Therefore, if you need DB reset, then do it \n      // // through `npm run reset-for-debugging` command\n      // //----\n      // \"--reset\", \"false\",\n      // \"--mode\", \"local\",\n      \n      //----\n      // You can run specific test functions\n      //\n      // If you want to include or exclude multiple words,\n      // then separate them with space character\n      //----\n      // \"--include\", \"some-words-to-include\",\n      // \"--exclude\", \"some-word another-word\",\n  ],\n    \"outFiles\": [\"${workspaceRoot}/bin/**/*.js\"],\n  }\n]\n}",
  ".vscode/settings.json": "{\n  \"editor.tabSize\": 2,\n  \"editor.formatOnSave\": true,\n  \"[javascript][typescript]\": {\n    \"editor.defaultFormatter\": \"esbenp.prettier-vscode\",\n    \"editor.codeActionsOnSave\": {\n      \"source.fixAll.eslint\": \"explicit\"\n    },\n  }\n}",
  "LICENSE": "MIT License\n\nCopyright (c) 2022 Jeongho Nam\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n",
  "README.md": "# AutoBE Generated Backend Server\r\n\r\n![AutoBE Logo](https://github.com/user-attachments/assets/a90d14be-fd50-4dc7-ae9d-ca66c2124f31)\r\n\r\nA backend repository generated by [`@autobe`](https://github.com/wrtnlabs/autobe).\r\n\r\nThis backend program was automatically generated using [`@autobe`](https://github.com/wrtnlabs/autobe), the AI vibe coding agent for backend servers of below stack.\r\n\r\n- TypeScript\r\n- NestJS / Nestia\r\n- Prisma\r\n- Postgres\r\n\r\n## Project Structure\r\n\r\nThis template project has categorized directories like below.\r\n\r\nAs you can see from the below, all of the Backend source files are placed into the [src](src/) directory. When you build the TypeScript source files, compiled files would be placed into the `lib` directory following the [tsconfig.json](tsconfig.json) configuration. Otherwise you build client [SDK](#32-sdk) library for npm publishing and their compiled files would be placed into the [packages](packages) directory.\r\n\r\n  - [packages/api/](packages/api): SDK module built by `npm run build:api`\r\n  - [src/](src): Backend source directory\r\n    - [src/api/](src/api/): Client SDK that would be published to the `@ORGANIZATION/PROJECT-api`\r\n      - [**src/api/functional/**](src/api/functional/): API functions generated by the [`nestia`](https://github.com/samchon/nestia)\r\n      - [**src/api/structures/**](src/api/structures/): DTO structures\r\n    - [src/controllers/](src/controllers/): Controller classes of the Main Program\r\n  - [**test/**](test): Test Automation Program\r\n    - [test/features](test/features): List of test functions\r\n  - [nestia.config.ts](nestia.config.ts): Configuration file of [`nestia`](https://github.com/samchon/nestia)\r\n  - [package.json](package.json): NPM configuration\r\n  - [tsconfig.json](tsconfig.json): TypeScript configuration for the main program\r\n\r\n## NPM Run Commands\r\n\r\nList of the run commands defined in the [package.json](package.json) are like below:\r\n\r\n  - Test\r\n    - **`test`**: Run test automation program\r\n    - `benchmark`: Run performance benchmark program\r\n  - Build\r\n    - `build`: Build everything\r\n    - `build:main`: Build main program (`src` directory)\r\n    - `build:test` Build test automation program (`test` directory)\r\n    - `build:sdk`: Build SDK into main program only\r\n    - `build:swagger`: Build Swagger Documents\r\n    - **`dev`**: Incremental build for development (test program)\r\n  - Deploy\r\n    - `package:api`: Build and deploy the SDK library to the NPM\r\n    - `start`: Start the backend server\r\n    - `start:dev`: Start the backend server with incremental build and reload\r\n  - Webpack\r\n    - `webpack`: Run webpack bundler\r\n    - `webpack:start`: Start the backend server built by webpack\r\n    - `webpack:test`: Run test program to the webpack built\r\n\r\n## Specialization\r\n\r\nTransform this template project to be yours.\r\n\r\nWhen you've created a new backend project through this template project, you can specialize it to be suitable for you by changing some words. Replace below words through IDE specific function like `Edit > Replace in Files` (*Ctrl + Shift + H*), who've been supported by the VSCode.\r\n\r\n| Before       | After\r\n|--------------|----------------------------------------\r\n| ORGANIZATION | Your account or corporation name\r\n| PROJECT      | Your own project name\r\n| AUTHOR       | Author name\r\n| https://github.com/samchon/nestia-start | Your repository URL",
  "build/env.ts": "import fs from \"fs\";\n\nif (fs.existsSync(`${__dirname}/../.env`) === false)\n  fs.copyFileSync(`${__dirname}/../.env.local`, `${__dirname}/../.env`);\n",
  "docs/benchmarks/AMD Ryzen 9 7940HS w Radeon 780M Graphics.md": "# Benchmark Report\n> Generated by [`@nestia/benchmark`](https://github.com/samchon/nestia)\n\n  - Specifications\n    - CPU: AMD Ryzen 9 7940HS w/ Radeon 780M Graphics     \n    - RAM: 31 GB\n    - NodeJS Version: v20.10.0\n    - Backend Server: 1 core / 1 thread\n  - Arguments\n    - Count: 40,000\n    - Threads: 4\n    - Simultaneous: 32\n  - Time\n    - Start: 2024-10-29T19:14:35.941Z\n    - Complete: 2024-10-29T19:16:11.418Z\n    - Elapsed: 95,477 ms\n\nType | Count | Success | Mean. | Stdev. | Minimum | Maximum\n----|----|----|----|----|----|----\nTotal | 41,586 | 41,586 | 69.24 | 73.05 | 5 | 546\n\n> Unit: milliseconds\n\n## Memory Consumptions\n```mermaid\nxychart-beta\n  x-axis \"Time (second)\"\n  y-axis \"Memory (MB)\"\n  line \"Resident Set Size\" [122, 156, 159, 142, 154, 165, 184, 185, 187, 189, 200, 205, 209, 217, 221, 225, 229, 224, 230, 235, 242, 250, 256, 262, 267, 272, 234, 237, 249, 259, 266, 273, 285, 292, 291, 216, 225, 235, 243, 200, 208, 214, 186, 186, 171, 177, 187, 199, 185, 192, 205, 171, 180, 158, 170, 179, 163, 163, 176, 188, 193, 202, 213, 219, 230, 239, 256, 265, 283, 301, 240, 249, 257, 267, 284, 282, 290, 202, 213, 166, 178, 188, 200, 203, 208, 180, 191, 199, 175]\n  line \"Heap Total\" [85, 116, 120, 103, 114, 124, 146, 146, 147, 148, 158, 166, 170, 176, 180, 184, 187, 185, 190, 195, 203, 211, 217, 222, 225, 229, 194, 197, 209, 218, 225, 232, 241, 249, 247, 176, 185, 194, 202, 160, 168, 173, 146, 146, 130, 136, 146, 158, 145, 151, 165, 129, 139, 116, 128, 137, 120, 123, 136, 148, 152, 161, 172, 179, 189, 198, 215, 223, 241, 257, 200, 209, 216, 227, 244, 242, 249, 163, 174, 127, 136, 147, 159, 162, 166, 138, 150, 158, 132]\n  line \"Heap Used + External\" [69, 94, 62, 82, 88, 107, 71, 83, 93, 107, 136, 72, 76, 85, 92, 106, 139, 48, 68, 69, 86, 95, 108, 116, 140, 175, 67, 74, 88, 112, 125, 136, 142, 169, 180, 91, 104, 105, 121, 60, 71, 91, 64, 74, 86, 110, 121, 135, 76, 82, 103, 70, 93, 66, 91, 107, 76, 75, 95, 101, 115, 127, 136, 154, 165, 168, 196, 193, 214, 232, 84, 94, 101, 118, 145, 147, 149, 86, 96, 72, 90, 112, 126, 133, 132, 78, 87, 107, 88]\n  line \"Heap Used Only\" [66, 89, 59, 78, 83, 100, 68, 79, 88, 101, 129, 68, 72, 80, 86, 100, 131, 45, 64, 65, 81, 90, 103, 110, 133, 168, 64, 71, 84, 108, 120, 130, 136, 162, 173, 88, 100, 101, 117, 58, 68, 87, 61, 71, 83, 107, 118, 130, 73, 79, 99, 67, 89, 63, 88, 103, 74, 72, 91, 98, 111, 123, 132, 149, 160, 163, 190, 187, 208, 225, 81, 90, 97, 114, 140, 143, 145, 83, 93, 70, 87, 108, 122, 130, 128, 76, 84, 104, 85]\n```\n\n> - 🟦 Resident Set Size\n> - 🟢 Heap Total\n> - 🔴 Heap Used + External\n> - 🟡 Heap Used Only\n\n## Endpoints\nType | Count | Success | Mean. | Stdev. | Minimum | Maximum\n----|----|----|----|----|----|----\nPATCH /bbs/articles/:section | 6,439 | 6,439 | 108.37 | 76.56 | 6 | 546\nPUT /bbs/articles/:section/:id | 380 | 380 | 78.52 | 69.03 | 6 | 296\nGET /bbs/articles/:section/:id | 917 | 917 | 77.65 | 69.84 | 6 | 463\nDELETE /bbs/articles/:section/:id | 201 | 201 | 73.89 | 63.55 | 7 | 307\nPOST /bbs/articles/:section | 33,649 | 33,649 | 61.39 | 70.04 | 5 | 546\n\n> Unit: milliseconds\n\n## Failures\nMethod | Path | Count | Failures\n-------|------|-------|----------",
  "nest-cli.json": "{\n  \"$schema\": \"https://json.schemastore.org/nest-cli\",\n  \"collection\": \"@nestjs/schematics\",\n  \"sourceRoot\": \"src\",\n  \"entryFile\": \"executable/server\",\n  \"compilerOptions\": {\n    \"deleteOutDir\": true\n  }\n}\n",
  "nestia.config.ts": "// nestia configuration file\nimport type sdk from \"@nestia/sdk\";\nimport { NestFactory } from \"@nestjs/core\";\n\nimport { MyModule } from \"./src/MyModule\";\n\nconst NESTIA_CONFIG: sdk.INestiaConfig = {\n  input: () => NestFactory.create(MyModule),\n  output: \"src/api\",\n  swagger: {\n    output: \"packages/api/swagger.json\",\n    servers: [\n      {\n        url: \"http://localhost:37001\",\n        description: \"Local Server\",\n      },\n    ],\n    beautify: true,\n  },\n  distribute: \"packages/api\",\n  primitive: false,\n  simulate: true,\n};\nexport default NESTIA_CONFIG;\n",
  "package.json": "{\n  \"private\": true,\n  \"name\": \"@ORGANIZATION/PROJECT\",\n  \"version\": \"0.1.0\",\n  \"description\": \"Starter kit of Nestia\",\n  \"main\": \"lib/index.js\",\n  \"scripts\": {\n    \"benchmark\": \"node bin/test/benchmark\",\n    \"test\": \"node bin/test\",\n    \"test:webpack\": \"npm run webpack && node bin/test/webpack.js\",\n    \"------------------------BUILDS------------------------\": \"\",\n    \"build\": \"npm run build:sdk && npm run build:main && npm run build:test\",\n    \"build:api\": \"rimraf packages/api/lib && nestia all && rimraf packages/api/lib && tsc -p packages/api/tsconfig.json && rollup -c packages/api/rollup.config.js\",\n    \"build:main\": \"rimraf lib && tsc\",\n    \"build:sdk\": \"rimraf src/api/functional && nestia sdk\",\n    \"build:swagger\": \"npx nestia swagger\",\n    \"build:test\": \"rimraf bin && tsc -p test/tsconfig.json\",\n    \"dev\": \"npm run build:test -- --watch\",\n    \"eslint\": \"eslint src && eslint test\",\n    \"eslint:fix\": \"eslint --fix src && eslint --fix test\",\n    \"prepare\": \"ts-patch install && ts-node build/env.ts\",\n    \"prettier\": \"prettier src --write && prettier test --write\",\n    \"------------------------WEBPACK------------------------\": \"\",\n    \"webpack\": \"rimraf dist && webpack\",\n    \"webpack:start\": \"cd dist && node dist/server\",\n    \"webpack:test\": \"npm run webpack && node bin/test/webpack.js\",\n    \"------------------------DEPLOYS------------------------\": \"\",\n    \"package:api\": \"npm run build:api && cd packages/api && npm publish\",\n    \"start\": \"node lib/executable/server\",\n    \"start:dev\": \"nest start --watch\",\n    \"start:swagger\": \"ts-node src/executable/swagger.ts\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/samchon/nestia-start\"\n  },\n  \"keywords\": [\n    \"nestia\",\n    \"template\",\n    \"boilerplate\"\n  ],\n  \"author\": \"AUTHOR\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/samchon/nestia-start/issues\"\n  },\n  \"homepage\": \"https://github.com/samchon/nestia-start#readme\",\n  \"devDependencies\": {\n    \"@nestia/benchmark\": \"^6.0.6\",\n    \"@nestia/e2e\": \"^6.0.6\",\n    \"@nestia/sdk\": \"^7.0.0\",\n    \"@nestjs/cli\": \"^11.0.7\",\n    \"@rollup/plugin-terser\": \"^0.4.4\",\n    \"@rollup/plugin-typescript\": \"^11.1.6\",\n    \"@trivago/prettier-plugin-sort-imports\": \"^4.3.0\",\n    \"@types/cli\": \"^0.11.21\",\n    \"@types/cli-progress\": \"^3.11.5\",\n    \"@types/express\": \"^4.17.21\",\n    \"@types/inquirer\": \"^8.2.5\",\n    \"@types/node\": \"^18.11.0\",\n    \"@types/uuid\": \"^8.3.4\",\n    \"@typescript-eslint/eslint-plugin\": \"^8.1.0\",\n    \"@typescript-eslint/parser\": \"^8.1.0\",\n    \"chalk\": \"^4.1.2\",\n    \"cli\": \"^1.0.1\",\n    \"cli-progress\": \"^3.12.0\",\n    \"copy-webpack-plugin\": \"^11.0.0\",\n    \"eslint-plugin-deprecation\": \"^3.0.0\",\n    \"express\": \"^4.18.2\",\n    \"nestia\": \"^7.0.0\",\n    \"prettier\": \"^3.2.4\",\n    \"prettier-plugin-prisma\": \"^5.0.0\",\n    \"rimraf\": \"^3.0.2\",\n    \"rollup\": \"^4.18.0\",\n    \"source-map-support\": \"^0.5.21\",\n    \"swagger-ui-express\": \"^5.0.0\",\n    \"ts-loader\": \"^9.5.1\",\n    \"ts-node\": \"^10.9.1\",\n    \"ts-patch\": \"^3.3.0\",\n    \"typescript\": \"~5.8.3\",\n    \"typescript-transform-paths\": \"^3.5.5\",\n    \"webpack\": \"^5.89.0\",\n    \"webpack-cli\": \"^5.1.4\",\n    \"write-file-webpack-plugin\": \"^4.5.1\"\n  },\n  \"dependencies\": {\n    \"@nestia/core\": \"^7.0.0\",\n    \"@nestia/fetcher\": \"^7.0.0\",\n    \"@nestjs/common\": \"^11.1.3\",\n    \"@nestjs/core\": \"^11.1.3\",\n    \"@nestjs/platform-express\": \"^11.1.3\",\n    \"commander\": \"10.0.0\",\n    \"dotenv\": \"^16.3.1\",\n    \"dotenv-expand\": \"^10.0.0\",\n    \"inquirer\": \"8.2.5\",\n    \"serialize-error\": \"^4.1.0\",\n    \"tgrid\": \"^1.1.0\",\n    \"tstl\": \"^3.0.0\",\n    \"typia\": \"^9.3.1\",\n    \"uuid\": \"^9.0.0\"\n  },\n  \"stackblitz\": {\n    \"startCommand\": \"npm run prepare && npm run build:test && npm run test -- --simultaneous 1\"\n  }\n}",
  "packages/api/.gitignore": "lib/\nnode_modules/\n\nswagger.json\nopenai.json",
  "packages/api/LICENSE": "MIT License\n\nCopyright (c) 2021 ORGANIZATION\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.",
  "packages/api/README.md": "# SDK Library\nThis is a SDK library generated by [`nestia`](https://nestia.io).\n\nWith this SDK library, you can easily and safely interact with backend server.\n\nJust import and call some API functions like gif image below:\n\n![nestia-sdk-demo](https://user-images.githubusercontent.com/13158709/215004990-368c589d-7101-404e-b81b-fbc936382f05.gif)\n\n> Left is server code, and right is client code utilizing the SDK\n\n\n\n\n# What [`Nestia`](https://nestia.io) is:\n![Nestia Logo](https://nestia.io/logo.png)\n\n[![GitHub license](https://img.shields.io/badge/license-MIT-blue.svg)](https://github.com/samchon/nestia/blob/master/LICENSE)\n[![npm version](https://img.shields.io/npm/v/@nestia/core.svg)](https://www.npmjs.com/package/@nestia/core)\n[![Downloads](https://img.shields.io/npm/dm/@nestia/core.svg)](https://www.npmjs.com/package/@nestia/core)\n[![Build Status](https://github.com/samchon/nestia/workflows/build/badge.svg)](https://github.com/samchon/nestia/actions?query=workflow%3Abuild)\n[![Guide Documents](https://img.shields.io/badge/guide-documents-forestgreen)](https://nestia.io/docs/)\n\nNestia is a set of helper libraries for NestJS, supporting below features:\n\n  - `@nestia/core`: super-fast decorators\n  - `@nestia/sdk`:\n    - Swagger generator evolved than ever\n    - SDK library generator for clients\n    - Mockup Simulator for client applications\n    - Automatic E2E test functions generator\n  - `@nestia/migrate`: migration from Swagger to NestJS\n  - `nestia`: just CLI (command line interface) tool\n\n> **Note**\n> \n> - **Only one line** required, with pure TypeScript type\n> - Enhance performance **30x** up\n>   - Runtime validator is **20,000x faster** than `class-validator`\n>   - JSON serialization is **200x faster** than `class-transformer`\n> - Software Development Kit\n>   - SDK is a collection of `fetch` functions with type definitions like [tRPC](https://trpc.io/)\n>   - Mockup simulator means embedded backend simulator in SDK\n>     - similar with [msw](https://mswjs.io/), but fully automated",
  "packages/api/package.json": "{\n  \"name\": \"@ORGANIZATION/PROJECT-api\",\n  \"version\": \"0.1.0\",\n  \"description\": \"SDK library generated by Nestia\",\n  \"main\": \"lib/index.js\",\n  \"module\": \"lib/index.mjs\",\n  \"typings\": \"lib/index.d.ts\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/samchon/nestia\"\n  },\n  \"author\": \"Jeongho Nam\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/samchon/nestia/issues\"\n  },\n  \"homepage\": \"https://nestia.io\",\n  \"files\": [\n    \"lib\",\n    \"package.json\",\n    \"swagger.json\",\n    \"openai.json\",\n    \"README.md\"\n  ],\n  \"dependencies\": {\n    \"@nestia/fetcher\": \"^6.0.6\",\n    \"tgrid\": \"^1.1.0\",\n    \"typia\": \"^9.3.1\"\n  }\n}",
  "packages/api/rollup.config.js": "const typescript = require(\"@rollup/plugin-typescript\");\nconst terser = require(\"@rollup/plugin-terser\");\n\nmodule.exports = {\n  input: `${__dirname}/../../src/api/index.ts`,\n  output: {\n    dir: `${__dirname}/lib`,\n    format: \"esm\",\n    entryFileNames: \"[name].mjs\",\n    sourcemap: true,\n  },\n  plugins: [\n    typescript({\n      tsconfig: `${__dirname}/tsconfig.json`,\n      module: \"ESNext\",\n      target: \"ESNext\",\n    }),\n    terser({\n      format: {\n        comments: \"some\",\n        beautify: true,\n        ecma: \"2020\",\n      },\n      compress: false,\n      mangle: false,\n      module: true,\n    }),\n  ],\n};\n",
  "packages/api/tsconfig.json": "{\n  \"compilerOptions\": {\n    /* Visit https://aka.ms/tsconfig to read more about this file */\n    /* Projects */\n    // \"incremental\": true,                              /* Save .tsbuildinfo files to allow for incremental compilation of projects. */\n    // \"composite\": true,                                /* Enable constraints that allow a TypeScript project to be used with project references. */\n    // \"tsBuildInfoFile\": \"./.tsbuildinfo\",              /* Specify the path to .tsbuildinfo incremental compilation file. */\n    // \"disableSourceOfProjectReferenceRedirect\": true,  /* Disable preferring source files instead of declaration files when referencing composite projects. */\n    // \"disableSolutionSearching\": true,                 /* Opt a project out of multi-project reference checking when editing. */\n    // \"disableReferencedProjectLoad\": true,             /* Reduce the number of projects loaded automatically by TypeScript. */\n    /* Language and Environment */\n    \"target\": \"ES5\", /* Set the JavaScript language version for emitted JavaScript and include compatible library declarations. */\n    \"lib\": [\n      \"DOM\",\n      \"ES2015\"\n    ], /* Specify a set of bundled library declaration files that describe the target runtime environment. */// \"jsx\": \"preserve\",                                /* Specify what JSX code is generated. */\n    // \"experimentalDecorators\": true,                   /* Enable experimental support for TC39 stage 2 draft decorators. */\n    // \"emitDecoratorMetadata\": true,                    /* Emit design-type metadata for decorated declarations in source files. */\n    // \"jsxFactory\": \"\",                                 /* Specify the JSX factory function used when targeting React JSX emit, e.g. 'React.createElement' or 'h'. */\n    // \"jsxFragmentFactory\": \"\",                         /* Specify the JSX Fragment reference used for fragments when targeting React JSX emit e.g. 'React.Fragment' or 'Fragment'. */\n    // \"jsxImportSource\": \"\",                            /* Specify module specifier used to import the JSX factory functions when using 'jsx: react-jsx*'. */\n    // \"reactNamespace\": \"\",                             /* Specify the object invoked for 'createElement'. This only applies when targeting 'react' JSX emit. */\n    // \"noLib\": true,                                    /* Disable including any library files, including the default lib.d.ts. */\n    // \"useDefineForClassFields\": true,                  /* Emit ECMAScript-standard-compliant class fields. */\n    // \"moduleDetection\": \"auto\",                        /* Control what method is used to detect module-format JS files. */\n    /* Modules */\n    \"module\": \"commonjs\", /* Specify what module code is generated. */// \"rootDir\": \"./\",                                  /* Specify the root folder within your source files. */\n    // \"moduleResolution\": \"node\",                       /* Specify how TypeScript looks up a file from a given module specifier. */\n    // \"baseUrl\": \"./\",                                  /* Specify the base directory to resolve non-relative module names. */\n    // \"paths\": {},                                      /* Specify a set of entries that re-map imports to additional lookup locations. */\n    // \"rootDirs\": [],                                   /* Allow multiple folders to be treated as one when resolving modules. */\n    // \"typeRoots\": [],                                  /* Specify multiple folders that act like './node_modules/@types'. */\n    // \"types\": [],                                      /* Specify type package names to be included without being referenced in a source file. */\n    // \"allowUmdGlobalAccess\": true,                     /* Allow accessing UMD globals from modules. */\n    // \"moduleSuffixes\": [],                             /* List of file name suffixes to search when resolving a module. */\n    // \"resolveJsonModule\": true,                        /* Enable importing .json files. */\n    // \"noResolve\": true,                                /* Disallow 'import's, 'require's or '<reference>'s from expanding the number of files TypeScript should add to a project. */\n    /* JavaScript Support */\n    // \"allowJs\": true,                                  /* Allow JavaScript files to be a part of your program. Use the 'checkJS' option to get errors from these files. */\n    // \"checkJs\": true,                                  /* Enable error reporting in type-checked JavaScript files. */\n    // \"maxNodeModuleJsDepth\": 1,                        /* Specify the maximum folder depth used for checking JavaScript files from 'node_modules'. Only applicable with 'allowJs'. */\n    /* Emit */\n    \"declaration\": true, /* Generate .d.ts files from TypeScript and JavaScript files in your project. */// \"declarationMap\": true,                           /* Create sourcemaps for d.ts files. */\n    // \"emitDeclarationOnly\": true,                      /* Only output d.ts files and not JavaScript files. */\n    \"sourceMap\": true, /* Create source map files for emitted JavaScript files. */// \"outFile\": \"./\",                                  /* Specify a file that bundles all outputs into one JavaScript file. If 'declaration' is true, also designates a file that bundles all .d.ts output. */\n    \"outDir\": \"./lib\", /* Specify an output folder for all emitted files. */// \"removeComments\": true,                           /* Disable emitting comments. */\n    // \"noEmit\": true,                                   /* Disable emitting files from a compilation. */\n    // \"importHelpers\": true,                            /* Allow importing helper functions from tslib once per project, instead of including them per-file. */\n    // \"importsNotUsedAsValues\": \"remove\",               /* Specify emit/checking behavior for imports that are only used for types. */\n    \"downlevelIteration\": true, /* Emit more compliant, but verbose and less performant JavaScript for iteration. */// \"sourceRoot\": \"\",                                 /* Specify the root path for debuggers to find the reference source code. */\n    // \"mapRoot\": \"\",                                    /* Specify the location where debugger should locate map files instead of generated locations. */\n    // \"inlineSourceMap\": true,                          /* Include sourcemap files inside the emitted JavaScript. */\n    // \"inlineSources\": true,                            /* Include source code in the sourcemaps inside the emitted JavaScript. */\n    // \"emitBOM\": true,                                  /* Emit a UTF-8 Byte Order Mark (BOM) in the beginning of output files. */\n    \"newLine\": \"lf\", /* Set the newline character for emitting files. */// \"stripInternal\": true,                            /* Disable emitting declarations that have '@internal' in their JSDoc comments. */\n    // \"noEmitHelpers\": true,                            /* Disable generating custom helper functions like '__extends' in compiled output. */\n    // \"noEmitOnError\": true,                            /* Disable emitting files if any type checking errors are reported. */\n    // \"preserveConstEnums\": true,                       /* Disable erasing 'const enum' declarations in generated code. */\n    // \"declarationDir\": \"./\",                           /* Specify the output directory for generated declaration files. */\n    // \"preserveValueImports\": true,                     /* Preserve unused imported values in the JavaScript output that would otherwise be removed. */\n    /* Interop Constraints */\n    // \"isolatedModules\": true,                          /* Ensure that each file can be safely transpiled without relying on other imports. */\n    // \"allowSyntheticDefaultImports\": true,             /* Allow 'import x from y' when a module doesn't have a default export. */\n    \"esModuleInterop\": true, /* Emit additional JavaScript to ease support for importing CommonJS modules. This enables 'allowSyntheticDefaultImports' for type compatibility. */// \"preserveSymlinks\": true,                         /* Disable resolving symlinks to their realpath. This correlates to the same flag in node. */\n    \"forceConsistentCasingInFileNames\": true, /* Ensure that casing is correct in imports. *//* Type Checking */\n    \"strict\": true, /* Enable all strict type-checking options. */// \"noImplicitAny\": true,                            /* Enable error reporting for expressions and declarations with an implied 'any' type. */\n    // \"strictNullChecks\": true,                         /* When type checking, take into account 'null' and 'undefined'. */\n    // \"strictFunctionTypes\": true,                      /* When assigning functions, check to ensure parameters and the return values are subtype-compatible. */\n    // \"strictBindCallApply\": true,                      /* Check that the arguments for 'bind', 'call', and 'apply' methods match the original function. */\n    // \"strictPropertyInitialization\": true,             /* Check for class properties that are declared but not set in the constructor. */\n    // \"noImplicitThis\": true,                           /* Enable error reporting when 'this' is given the type 'any'. */\n    // \"useUnknownInCatchVariables\": true,               /* Default catch clause variables as 'unknown' instead of 'any'. */\n    // \"alwaysStrict\": true,                             /* Ensure 'use strict' is always emitted. */\n    // \"noUnusedLocals\": true,                           /* Enable error reporting when local variables aren't read. */\n    // \"noUnusedParameters\": true,                       /* Raise an error when a function parameter isn't read. */\n    // \"exactOptionalPropertyTypes\": true,               /* Interpret optional property types as written, rather than adding 'undefined'. */\n    // \"noImplicitReturns\": true,                        /* Enable error reporting for codepaths that do not explicitly return in a function. */\n    // \"noFallthroughCasesInSwitch\": true,               /* Enable error reporting for fallthrough cases in switch statements. */\n    // \"noUncheckedIndexedAccess\": true,                 /* Add 'undefined' to a type when accessed using an index. */\n    // \"noImplicitOverride\": true,                       /* Ensure overriding members in derived classes are marked with an override modifier. */\n    // \"noPropertyAccessFromIndexSignature\": true,       /* Enforces using indexed accessors for keys declared using an indexed type. */\n    // \"allowUnusedLabels\": true,                        /* Disable error reporting for unused labels. */\n    // \"allowUnreachableCode\": true,                     /* Disable error reporting for unreachable code. */\n    /* Completeness */\n    // \"skipDefaultLibCheck\": true,                      /* Skip type checking .d.ts files that are included with TypeScript. */\n    \"skipLibCheck\": true, /* Skip type checking all .d.ts files. */\n    \"plugins\": [\n      {\n        \"transform\": \"typia/lib/transform\"\n      }\n    ],\n    \"strictNullChecks\": true\n  },\n  \"include\": [\n    \"../../src/api\"\n  ]\n}",
  "prettier.config.js": "module.exports = {\n  // DEFAULT CONFIGURATIONS\n  parser: \"typescript\",\n  printWidth: 80,\n  semi: true,\n  tabWidth: 2,\n  trailingComma: \"all\",\n\n  // PLUG-IN CONFIGURATIONS\n  plugins: [\"@trivago/prettier-plugin-sort-imports\"],\n  importOrder: [\n    \"<THIRD_PARTY_MODULES>\",\n    \"^@ORGANIZATION/PROJECT-api(.*)$\",\n    \"^[./]\",\n  ],\n  importOrderSeparation: true,\n  importOrderSortSpecifiers: true,\n  importOrderParserPlugins: [\"decorators-legacy\", \"typescript\"],\n};\n",
  "src/MyBackend.ts": "import { WebSocketAdaptor } from \"@nestia/core\";\nimport { INestApplication } from \"@nestjs/common\";\nimport { NestFactory } from \"@nestjs/core\";\n\nimport { MyConfiguration } from \"./MyConfiguration\";\nimport { MyModule } from \"./MyModule\";\n\nexport class MyBackend {\n  private application_?: INestApplication;\n\n  public async open(): Promise<void> {\n    //----\n    // OPEN THE BACKEND SERVER\n    //----\n    // MOUNT CONTROLLERS\n    this.application_ = await NestFactory.create(MyModule, { logger: false });\n    await WebSocketAdaptor.upgrade(this.application_);\n\n    // DO OPEN\n    this.application_.enableCors();\n    await this.application_.listen(MyConfiguration.API_PORT(), \"0.0.0.0\");\n\n    //----\n    // POST-PROCESSES\n    //----\n    // INFORM TO THE PM2\n    if (process.send) process.send(\"ready\");\n\n    // WHEN KILL COMMAND COMES\n    process.on(\"SIGINT\", async () => {\n      await this.close();\n      process.exit(0);\n    });\n  }\n\n  public async close(): Promise<void> {\n    if (this.application_ === undefined) return;\n\n    // DO CLOSE\n    await this.application_.close();\n    delete this.application_;\n  }\n}\n",
  "src/MyConfiguration.ts": "import fs from \"fs\";\nimport path from \"path\";\n\nimport { MyGlobal } from \"./MyGlobal\";\n\nexport namespace MyConfiguration {\n  export const API_PORT = () => Number(MyGlobal.env.API_PORT);\n\n  export const ROOT = (() => {\n    const split: string[] = __dirname.split(path.sep);\n    return split.at(-1) === \"src\" && split.at(-2) === \"bin\"\n      ? path.resolve(__dirname + \"/../..\")\n      : fs.existsSync(__dirname + \"/.env\")\n        ? __dirname\n        : path.resolve(__dirname + \"/..\");\n  })();\n}\n",
  "src/MyGlobal.ts": "import dotenv from \"dotenv\";\nimport dotenvExpand from \"dotenv-expand\";\nimport { Singleton } from \"tstl\";\nimport typia from \"typia\";\n\n/* eslint-disable */\nexport class MyGlobal {\n  public static testing: boolean = false;\n  public static get env(): MyGlobal.IEnvironments {\n    return environments.get();\n  }\n}\nexport namespace MyGlobal {\n  export interface IEnvironments {\n    API_PORT: `${number}`;\n  }\n}\n\nconst environments = new Singleton(() => {\n  const env = dotenv.config();\n  dotenvExpand.expand(env);\n  return typia.assert<MyGlobal.IEnvironments>(process.env);\n});\n",
  "src/api/HttpError.ts": "export { HttpError } from \"@nestia/fetcher\";\n",
  "src/api/IConnection.ts": "export type { IConnection } from \"@nestia/fetcher\";\n",
  "src/api/Primitive.ts": "export type { Primitive } from \"typia\";\n",
  "src/api/Resolved.ts": "export type { Resolved } from \"typia\";\n",
  "src/api/index.ts": "import * as api from \"./module\";\n\nexport * from \"./module\";\nexport default api;\n",
  "src/api/module.ts": "export type * from \"./IConnection\";\nexport * from \"./HttpError\";\n\nexport * as functional from \"./functional\";\n",
  "src/executable/server.ts": "import { MyBackend } from \"../MyBackend\";\n\nconst EXTENSION = __filename.substring(__filename.length - 2);\nif (EXTENSION === \"js\") require(\"source-map-support/register\");\n\nasync function main(): Promise<void> {\n  // BACKEND SEVER\n  const backend: MyBackend = new MyBackend();\n  await backend.open();\n\n  // UNEXPECTED ERRORS\n  global.process.on(\"uncaughtException\", console.error);\n  global.process.on(\"unhandledRejection\", console.error);\n}\nmain().catch((exp) => {\n  console.log(exp);\n  process.exit(-1);\n});\n",
  "src/executable/swagger.ts": "import cp from \"child_process\";\nimport express from \"express\";\n\nconst execute = (command: string): void => {\n  console.log(`\\n$ ${command}\\n`);\n  cp.execSync(command, { stdio: \"inherit\" });\n};\n\nconst main = async (): Promise<void> => {\n  if (!process.argv.some((str) => str === \"--skipBuild\"))\n    execute(\"npm run build:swagger\");\n\n  const docs = await import(\"../../packages/api/swagger.json\" as any);\n\n  const app = express();\n  const swaggerUi = require(\"swagger-ui-express\");\n  app.use(\"/api-docs\", swaggerUi.serve, swaggerUi.setup(docs));\n  app.listen(37810);\n\n  console.log(\"\\n\");\n  console.log(\"-----------------------------------------------------------\");\n  console.log(\"\\n Swagger UI Address: http://127.0.0.1:37810/api-docs \\n\");\n  console.log(\"-----------------------------------------------------------\");\n};\nmain().catch((exp) => {\n  console.log(exp);\n  process.exit(-1);\n});\n",
  "src/utils/ErrorUtil.ts": "import serializeError = require(\"serialize-error\");\n\nexport namespace ErrorUtil {\n  export const toJSON = (err: any): object =>\n    err instanceof Object && err.toJSON instanceof Function\n      ? err.toJSON()\n      : serializeError(err);\n}\n",
  "src/utils/MapUtil.ts": "export namespace MapUtil {\n  export function take<Key, T>(\n    dict: Map<Key, T>,\n    key: Key,\n    generator: () => T,\n  ): T {\n    const oldbie: T | undefined = dict.get(key);\n    if (oldbie) return oldbie;\n\n    const value: T = generator();\n    dict.set(key, value);\n    return value;\n  }\n}\n",
  "test/TestAutomation.ts": "import { DynamicExecutor } from \"@nestia/e2e\";\nimport chalk from \"chalk\";\nimport { sleep_for } from \"tstl\";\n\nimport { MyConfiguration } from \"../src/MyConfiguration\";\nimport api from \"../src/api\";\nimport { ArgumentParser } from \"./helpers/ArgumentParser\";\n\nexport namespace TestAutomation {\n  export interface IProps<T> {\n    open(options: IOptions): Promise<T>;\n    close(backend: T): Promise<void>;\n  }\n\n  export interface IOptions {\n    simultaneous: number;\n    include?: string[];\n    exclude?: string[];\n  }\n\n  export const execute = async <T,>(props: IProps<T>): Promise<void> => {\n    // OPEN BACKEND\n    const options: IOptions = await getOptions();\n    const backend: T = await props.open(options);\n\n    // DO TEST\n    const connection: api.IConnection = {\n      host: `http://127.0.0.1:${MyConfiguration.API_PORT()}`,\n    };\n    const report: DynamicExecutor.IReport = await DynamicExecutor.validate({\n      prefix: \"test\",\n      location: __dirname + \"/features\",\n      parameters: () => [\n        {\n          host: connection.host,\n          encryption: connection.encryption,\n        },\n      ],\n      filter: (func) =>\n        (!options.include?.length ||\n          (options.include ?? []).some((str) => func.includes(str))) &&\n        (!options.exclude?.length ||\n          (options.exclude ?? []).every((str) => !func.includes(str))),\n      onComplete: (exec) => {\n        const trace = (str: string) =>\n          console.log(`  - ${chalk.green(exec.name)}: ${str}`);\n        if (exec.error === null) {\n          const elapsed: number =\n            new Date(exec.completed_at).getTime() -\n            new Date(exec.started_at).getTime();\n          trace(`${chalk.yellow(elapsed.toLocaleString())} ms`);\n        } else trace(chalk.red(exec.error.name));\n      },\n      simultaneous: options.simultaneous,\n    });\n\n    // TERMINATE - WAIT FOR BACKGROUND EVENTS\n    await sleep_for(2500);\n    await props.close(backend);\n\n    const failures: DynamicExecutor.IExecution[] = report.executions.filter(\n      (exec) => exec.error !== null,\n    );\n    if (failures.length === 0) {\n      console.log(\"Success\");\n      console.log(\"Elapsed time\", report.time.toLocaleString(), `ms`);\n    } else {\n      for (const f of failures) console.log(f.error);\n      process.exit(-1);\n    }\n\n    console.log(\n      [\n        `All: #${report.executions.length}`,\n        `Success: #${report.executions.length - failures.length}`,\n        `Failed: #${failures.length}`,\n      ].join(\"\\n\"),\n    );\n  };\n}\n\nconst getOptions = () =>\n  ArgumentParser.parse<TestAutomation.IOptions>(\n    async (command, prompt, action) => {\n      command.option(\n        \"--simultaneous <number>\",\n        \"number of simultaneous requests\",\n      );\n      command.option(\"--include <string...>\", \"include feature files\");\n      command.option(\"--exclude <string...>\", \"exclude feature files\");\n\n      return action(async (options) => {\n        options.simultaneous = Number(\n          options.simultaneous ??\n            (await prompt.number(\"simultaneous\")(\n              \"Number of simultaneous requests to make\",\n            )),\n        );\n        if (isNaN(options.simultaneous) || options.simultaneous <= 0)\n          options.simultaneous = 1;\n        return options as TestAutomation.IOptions;\n      });\n    },\n  );\n",
  "test/benchmark/index.ts": "import { DynamicBenchmarker } from \"@nestia/benchmark\";\nimport cliProgress from \"cli-progress\";\nimport fs from \"fs\";\nimport os from \"os\";\nimport { IPointer } from \"tstl\";\n\nimport { MyBackend } from \"../../src/MyBackend\";\nimport { MyConfiguration } from \"../../src/MyConfiguration\";\nimport { MyGlobal } from \"../../src/MyGlobal\";\nimport { ArgumentParser } from \"../helpers/ArgumentParser\";\n\ninterface IOptions {\n  include?: string[];\n  exclude?: string[];\n  count: number;\n  threads: number;\n  simultaneous: number;\n}\n\nconst getOptions = () =>\n  ArgumentParser.parse<IOptions>(async (command, prompt, action) => {\n    // command.option(\"--mode <string>\", \"target mode\");\n    // command.option(\"--reset <true|false>\", \"reset local DB or not\");\n    command.option(\"--include <string...>\", \"include feature files\");\n    command.option(\"--exclude <string...>\", \"exclude feature files\");\n    command.option(\"--count <number>\", \"number of requests to make\");\n    command.option(\"--threads <number>\", \"number of threads to use\");\n    command.option(\n      \"--simultaneous <number>\",\n      \"number of simultaneous requests to make\",\n    );\n    return action(async (options) => {\n      // if (typeof options.reset === \"string\")\n      //     options.reset = options.reset === \"true\";\n      // options.mode ??= await prompt.select(\"mode\")(\"Select mode\")([\n      //     \"LOCAL\",\n      //     \"DEV\",\n      //     \"REAL\",\n      // ]);\n      // options.reset ??= await prompt.boolean(\"reset\")(\"Reset local DB\");\n      options.count = Number(\n        options.count ??\n          (await prompt.number(\"count\")(\"Number of requests to make\")),\n      );\n      options.threads = Number(\n        options.threads ??\n          (await prompt.number(\"threads\")(\"Number of threads to use\")),\n      );\n      options.simultaneous = Number(\n        options.simultaneous ??\n          (await prompt.number(\"simultaneous\")(\n            \"Number of simultaneous requests to make\",\n          )),\n      );\n      return options as IOptions;\n    });\n  });\n\nconst main = async (): Promise<void> => {\n  // CONFIGURATIONS\n  const options: IOptions = await getOptions();\n  MyGlobal.testing = true;\n\n  // BACKEND SERVER\n  const backend: MyBackend = new MyBackend();\n  await backend.open();\n\n  // DO BENCHMARK\n  const prev: IPointer<number> = { value: 0 };\n  const bar: cliProgress.SingleBar = new cliProgress.SingleBar(\n    {},\n    cliProgress.Presets.shades_classic,\n  );\n  bar.start(options.count, 0);\n\n  const report: DynamicBenchmarker.IReport = await DynamicBenchmarker.master({\n    servant: `${__dirname}/servant.js`,\n    count: options.count,\n    threads: options.threads,\n    simultaneous: options.simultaneous,\n    filter: (func) =>\n      (!options.include?.length ||\n        (options.include ?? []).some((str) => func.includes(str))) &&\n      (!options.exclude?.length ||\n        (options.exclude ?? []).every((str) => !func.includes(str))),\n    progress: (value: number) => {\n      if (value >= 100 + prev.value) {\n        bar.update(value);\n        prev.value = value;\n      }\n    },\n    stdio: \"ignore\",\n  });\n  bar.stop();\n\n  // DOCUMENTATION\n  try {\n    await fs.promises.mkdir(`${MyConfiguration.ROOT}/docs/benchmarks`, {\n      recursive: true,\n    });\n  } catch {}\n  await fs.promises.writeFile(\n    `${MyConfiguration.ROOT}/docs/benchmarks/${os\n      .cpus()[0]\n      .model.trim()\n      .split(\"\\\\\")\n      .join(\"\")\n      .split(\"/\")\n      .join(\"\")}.md`,\n    DynamicBenchmarker.markdown(report),\n    \"utf8\",\n  );\n\n  // CLOSE\n  await backend.close();\n};\nmain().catch((exp) => {\n  console.error(exp);\n  process.exit(-1);\n});\n",
  "test/benchmark/servant.ts": "import { DynamicBenchmarker } from \"@nestia/benchmark\";\n\nimport { MyConfiguration } from \"../../src/MyConfiguration\";\n\nDynamicBenchmarker.servant({\n  connection: {\n    host: `http://127.0.0.1:${MyConfiguration.API_PORT()}`,\n  },\n  location: `${__dirname}/../features`,\n  parameters: (connection) => [connection],\n  prefix: \"test_api_\",\n}).catch((exp) => {\n  console.error(exp);\n  process.exit(-1);\n});\n",
  "test/helpers/ArgumentParser.ts": "import commander from \"commander\";\nimport * as inquirer from \"inquirer\";\n\nexport namespace ArgumentParser {\n  export type Inquiry<T> = (\n    command: commander.Command,\n    prompt: (opt?: inquirer.StreamOptions) => inquirer.PromptModule,\n    action: (closure: (options: Partial<T>) => Promise<T>) => Promise<T>,\n  ) => Promise<T>;\n\n  export interface Prompt {\n    select: (\n      name: string,\n    ) => (\n      message: string,\n    ) => <Choice extends string>(choices: Choice[]) => Promise<Choice>;\n    boolean: (name: string) => (message: string) => Promise<boolean>;\n    number: (name: string) => (message: string) => Promise<number>;\n  }\n\n  export const parse = async <T,>(\n    inquiry: (\n      command: commander.Command,\n      prompt: Prompt,\n      action: (closure: (options: Partial<T>) => Promise<T>) => Promise<T>,\n    ) => Promise<T>,\n  ): Promise<T> => {\n    // TAKE OPTIONS\n    const action = (closure: (options: Partial<T>) => Promise<T>) =>\n      new Promise<T>((resolve, reject) => {\n        commander.program.action(async (options) => {\n          try {\n            resolve(await closure(options));\n          } catch (exp) {\n            reject(exp);\n          }\n        });\n        commander.program.parseAsync().catch(reject);\n      });\n\n    const select =\n      (name: string) =>\n      (message: string) =>\n      async <Choice extends string>(choices: Choice[]): Promise<Choice> =>\n        (\n          await inquirer.createPromptModule()({\n            type: \"list\",\n            name,\n            message,\n            choices,\n          })\n        )[name];\n    const boolean = (name: string) => async (message: string) =>\n      (\n        await inquirer.createPromptModule()({\n          type: \"confirm\",\n          name,\n          message,\n        })\n      )[name] as boolean;\n    const number = (name: string) => async (message: string) =>\n      Number(\n        (\n          await inquirer.createPromptModule()({\n            type: \"number\",\n            name,\n            message,\n          })\n        )[name],\n      );\n\n    const output: T | Error = await (async () => {\n      try {\n        return await inquiry(\n          commander.program,\n          { select, boolean, number },\n          action,\n        );\n      } catch (error) {\n        return error as Error;\n      }\n    })();\n\n    // RETURNS\n    if (output instanceof Error) throw output;\n    return output;\n  };\n}\n",
  "test/index.ts": "import { MyBackend } from \"../src/MyBackend\";\nimport { MyGlobal } from \"../src/MyGlobal\";\nimport { TestAutomation } from \"./TestAutomation\";\n\nconst main = async (): Promise<void> => {\n  MyGlobal.testing = true;\n  await TestAutomation.execute({\n    open: async () => {\n      const backend: MyBackend = new MyBackend();\n      await backend.open();\n      return backend;\n    },\n    close: (backend) => backend.close(),\n  });\n};\nmain().catch((exp) => {\n  console.log(exp);\n  process.exit(-1);\n});\n",
  "test/tsconfig.json": "{\n  \"extends\": \"../tsconfig.json\",\n  \"compilerOptions\": {\n    \"outDir\": \"../bin\",\n  },\n  \"include\": [\".\", \"../src\"]\n}",
  "test/webpack.ts": "import cp from \"child_process\";\nimport { sleep_for } from \"tstl\";\n\nimport { MyConfiguration } from \"../src/MyConfiguration\";\nimport { MyGlobal } from \"../src/MyGlobal\";\nimport { TestAutomation } from \"./TestAutomation\";\n\nconst wait = async (): Promise<void> => {\n  while (true)\n    try {\n      await fetch(`http://localhost:${MyConfiguration.API_PORT()}/dsafdsafsd`);\n      return;\n    } catch (exp) {\n      await sleep_for(100);\n    }\n};\n\nconst main = async (): Promise<void> => {\n  MyGlobal.testing = true;\n  await TestAutomation.execute({\n    open: async () => {\n      const backend: cp.ChildProcess = cp.fork(\n        `${MyConfiguration.ROOT}/dist/server.js`,\n        {\n          cwd: `${MyConfiguration.ROOT}/dist`,\n        },\n      );\n      await wait();\n      return backend;\n    },\n    close: async (backend) => {\n      backend.kill();\n    },\n  });\n};\nmain().catch((exp) => {\n  console.log(exp);\n  process.exit(-1);\n});\n",
  "tsconfig.json": "{\n  \"compilerOptions\": {\n    /* Visit https://aka.ms/tsconfig to read more about this file */\n\n    /* Projects */\n    // \"incremental\": true,                              /* Save .tsbuildinfo files to allow for incremental compilation of projects. */\n    // \"composite\": true,                                /* Enable constraints that allow a TypeScript project to be used with project references. */\n    // \"tsBuildInfoFile\": \"./.tsbuildinfo\",              /* Specify the path to .tsbuildinfo incremental compilation file. */\n    // \"disableSourceOfProjectReferenceRedirect\": true,  /* Disable preferring source files instead of declaration files when referencing composite projects. */\n    // \"disableSolutionSearching\": true,                 /* Opt a project out of multi-project reference checking when editing. */\n    // \"disableReferencedProjectLoad\": true,             /* Reduce the number of projects loaded automatically by TypeScript. */\n\n    /* Language and Environment */\n    \"target\": \"ES2015\",                                  /* Set the JavaScript language version for emitted JavaScript and include compatible library declarations. */\n    // \"lib\": [],                                        /* Specify a set of bundled library declaration files that describe the target runtime environment. */\n    // \"jsx\": \"preserve\",                                /* Specify what JSX code is generated. */\n    \"experimentalDecorators\": true,                   /* Enable experimental support for TC39 stage 2 draft decorators. */\n    \"emitDecoratorMetadata\": true,                    /* Emit design-type metadata for decorated declarations in source files. */\n    // \"jsxFactory\": \"\",                                 /* Specify the JSX factory function used when targeting React JSX emit, e.g. 'React.createElement' or 'h'. */\n    // \"jsxFragmentFactory\": \"\",                         /* Specify the JSX Fragment reference used for fragments when targeting React JSX emit e.g. 'React.Fragment' or 'Fragment'. */\n    // \"jsxImportSource\": \"\",                            /* Specify module specifier used to import the JSX factory functions when using 'jsx: react-jsx*'. */\n    // \"reactNamespace\": \"\",                             /* Specify the object invoked for 'createElement'. This only applies when targeting 'react' JSX emit. */\n    // \"noLib\": true,                                    /* Disable including any library files, including the default lib.d.ts. */\n    // \"useDefineForClassFields\": true,                  /* Emit ECMAScript-standard-compliant class fields. */\n    // \"moduleDetection\": \"auto\",                        /* Control what method is used to detect module-format JS files. */\n\n    /* Modules */\n    \"module\": \"commonjs\",                                /* Specify what module code is generated. */\n    // \"rootDir\": \"./\",                                  /* Specify the root folder within your source files. */\n    // \"moduleResolution\": \"node\",                       /* Specify how TypeScript looks up a file from a given module specifier. */\n    // \"baseUrl\": \"./\",                                  /* Specify the base directory to resolve non-relative module names. */\n    \"paths\": {\n      \"@ORGANIZATION/PROJECT-api/lib/*\": [\"./src/api/*\"],\n      \"@ORGANIZATION/PROJECT-api\": [\"./src/api\"],\n    },                                      /* Specify a set of entries that re-map imports to additional lookup locations. */\n    // \"rootDirs\": [],                                   /* Allow multiple folders to be treated as one when resolving modules. */\n    // \"typeRoots\": [],                                  /* Specify multiple folders that act like './node_modules/@types'. */\n    // \"types\": [],                                      /* Specify type package names to be included without being referenced in a source file. */\n    // \"allowUmdGlobalAccess\": true,                     /* Allow accessing UMD globals from modules. */\n    // \"moduleSuffixes\": [],                             /* List of file name suffixes to search when resolving a module. */\n    // \"resolveJsonModule\": true,                        /* Enable importing .json files. */\n    // \"noResolve\": true,                                /* Disallow 'import's, 'require's or '<reference>'s from expanding the number of files TypeScript should add to a project. */\n\n    /* JavaScript Support */\n    // \"allowJs\": true,                                  /* Allow JavaScript files to be a part of your program. Use the 'checkJS' option to get errors from these files. */\n    // \"checkJs\": true,                                  /* Enable error reporting in type-checked JavaScript files. */\n    // \"maxNodeModuleJsDepth\": 1,                        /* Specify the maximum folder depth used for checking JavaScript files from 'node_modules'. Only applicable with 'allowJs'. */\n\n    /* Emit */\n    // \"declaration\": true,                              /* Generate .d.ts files from TypeScript and JavaScript files in your project. */\n    // \"declarationMap\": true,                           /* Create sourcemaps for d.ts files. */\n    // \"emitDeclarationOnly\": true,                      /* Only output d.ts files and not JavaScript files. */\n    \"sourceMap\": true,                                /* Create source map files for emitted JavaScript files. */\n    // \"outFile\": \"./\",                                  /* Specify a file that bundles all outputs into one JavaScript file. If 'declaration' is true, also designates a file that bundles all .d.ts output. */\n    \"outDir\": \"./lib\",                                   /* Specify an output folder for all emitted files. */\n    // \"removeComments\": true,                           /* Disable emitting comments. */\n    // \"noEmit\": true,                                   /* Disable emitting files from a compilation. */\n    // \"importHelpers\": true,                            /* Allow importing helper functions from tslib once per project, instead of including them per-file. */\n    // \"importsNotUsedAsValues\": \"remove\",               /* Specify emit/checking behavior for imports that are only used for types. */\n    // \"downlevelIteration\": true,                       /* Emit more compliant, but verbose and less performant JavaScript for iteration. */\n    // \"sourceRoot\": \"\",                                 /* Specify the root path for debuggers to find the reference source code. */\n    // \"mapRoot\": \"\",                                    /* Specify the location where debugger should locate map files instead of generated locations. */\n    // \"inlineSourceMap\": true,                          /* Include sourcemap files inside the emitted JavaScript. */\n    // \"inlineSources\": true,                            /* Include source code in the sourcemaps inside the emitted JavaScript. */\n    // \"emitBOM\": true,                                  /* Emit a UTF-8 Byte Order Mark (BOM) in the beginning of output files. */\n    \"newLine\": \"lf\",                                /* Set the newline character for emitting files. */\n    \"stripInternal\": true,                            /* Disable emitting declarations that have '@internal' in their JSDoc comments. */\n    // \"noEmitHelpers\": true,                            /* Disable generating custom helper functions like '__extends' in compiled output. */\n    // \"noEmitOnError\": true,                            /* Disable emitting files if any type checking errors are reported. */\n    // \"preserveConstEnums\": true,                       /* Disable erasing 'const enum' declarations in generated code. */\n    // \"declarationDir\": \"./\",                           /* Specify the output directory for generated declaration files. */\n    // \"preserveValueImports\": true,                     /* Preserve unused imported values in the JavaScript output that would otherwise be removed. */\n\n    /* Interop Constraints */\n    // \"isolatedModules\": true,                          /* Ensure that each file can be safely transpiled without relying on other imports. */\n    // \"allowSyntheticDefaultImports\": true,             /* Allow 'import x from y' when a module doesn't have a default export. */\n    \"esModuleInterop\": true,                             /* Emit additional JavaScript to ease support for importing CommonJS modules. This enables 'allowSyntheticDefaultImports' for type compatibility. */\n    // \"preserveSymlinks\": true,                         /* Disable resolving symlinks to their realpath. This correlates to the same flag in node. */\n    \"forceConsistentCasingInFileNames\": true,            /* Ensure that casing is correct in imports. */\n\n    /* Type Checking */\n    \"strict\": true,                                      /* Enable all strict type-checking options. */\n    // \"noImplicitAny\": true,                            /* Enable error reporting for expressions and declarations with an implied 'any' type. */\n    // \"strictNullChecks\": true,                         /* When type checking, take into account 'null' and 'undefined'. */\n    // \"strictFunctionTypes\": true,                      /* When assigning functions, check to ensure parameters and the return values are subtype-compatible. */\n    // \"strictBindCallApply\": true,                      /* Check that the arguments for 'bind', 'call', and 'apply' methods match the original function. */\n    // \"strictPropertyInitialization\": true,             /* Check for class properties that are declared but not set in the constructor. */\n    // \"noImplicitThis\": true,                           /* Enable error reporting when 'this' is given the type 'any'. */\n    // \"useUnknownInCatchVariables\": true,               /* Default catch clause variables as 'unknown' instead of 'any'. */\n    // \"alwaysStrict\": true,                             /* Ensure 'use strict' is always emitted. */\n    \"noUnusedLocals\": true,                           /* Enable error reporting when local variables aren't read. */\n    \"noUnusedParameters\": true,                       /* Raise an error when a function parameter isn't read. */\n    // \"exactOptionalPropertyTypes\": true,               /* Interpret optional property types as written, rather than adding 'undefined'. */\n    \"noImplicitReturns\": true,                        /* Enable error reporting for codepaths that do not explicitly return in a function. */\n    \"noFallthroughCasesInSwitch\": true,               /* Enable error reporting for fallthrough cases in switch statements. */\n    // \"noUncheckedIndexedAccess\": true,                 /* Add 'undefined' to a type when accessed using an index. */\n    // \"noImplicitOverride\": true,                       /* Ensure overriding members in derived classes are marked with an override modifier. */\n    // \"noPropertyAccessFromIndexSignature\": true,       /* Enforces using indexed accessors for keys declared using an indexed type. */\n    // \"allowUnusedLabels\": true,                        /* Disable error reporting for unused labels. */\n    // \"allowUnreachableCode\": true,                     /* Disable error reporting for unreachable code. */\n\n    /* Completeness */\n    // \"skipDefaultLibCheck\": true,                      /* Skip type checking .d.ts files that are included with TypeScript. */\n    \"skipLibCheck\": true,                                 /* Skip type checking all .d.ts files. */\n    \"plugins\": [\n      { \"transform\": \"typescript-transform-paths\" },\n      { \"transform\": \"typia/lib/transform\" },\n      { \n        \"transform\": \"@nestia/core/lib/transform\",\n        /**\n         * Validate request body.\n         * \n         *   - \"assert\": Use typia.assert() function\n         *   - \"is\": Use typia.is() function\n         *   - \"validate\": Use typia.validate() function\n         *   - \"assertEquals\": Use typia.assertEquals() function\n         *   - \"equals\": Use typia.equals() function\n         *   - \"validateEquals\": Use typia.validateEquals() function\n         */\n        \"validate\": \"validate\",\n        /**\n         * Validate JSON typed response body.\n         * \n         *   - \"assert\": Use typia.assertStringify() function\n         *   - \"is\": Use typia.isStringify() function\n         *   - \"validate\": Use typia.validateStringify() function\n         *   - \"validate.log\": typia.validateStringify(), but do not throw and just log it\n         *   - \"stringify\": Use typia.stringify() function, but dangerous\n         *   - null: Just use JSON.stringify() function, without boosting\n         */\n        \"stringify\": \"assert\",\n      },\n    ]\n  },\n  \"include\": [\n    \"src\"\n  ],\n  \"exclude\": [\n    \"node_modules\",\n    \"packages\",\n  ]\n}\n",
  "typos.toml": "[default]\nlocale = 'en-us'\nextend-ignore-re = [\n  \"(?Rm)^.*(<!--|#|//)\\\\s*spellchecker:disable-line(-->|\\n)?$\",\n  \"(?s)(<!--|#|//)\\\\s*spellchecker:off\\\\s*(-->|\\n).*?(<!--|#|//)\\\\s*spellchecker:on\",\n]\n\n[default.extend-words]\nJeongho = \"Jeongho\"\nNam = \"Nam\"\ntypia = \"typia\"\n\n[files]\nextend-exclude = [\"*.json\"]",
  "webpack.config.js": "const path = require(\"path\");\n\nconst CopyWebpackPlugin = require(\"copy-webpack-plugin\");\nconst WriteFilePlugin = require(\"write-file-webpack-plugin\");\nconst { IgnorePlugin } = require(\"webpack\");\n\nconst lazyImports = [\n  \"@fastify/static\",\n  \"@fastify/view\",\n  \"@nestjs/microservices\",\n  \"@nestjs/websockets\",\n  \"class-transformer\",\n  \"class-validator\",\n];\n\n// @reference https://tech-blog.s-yoshiki.com/entry/297\nmodule.exports = {\n  // CUSTOMIZE HERE\n  entry: {\n    server: \"./src/executable/server.ts\",\n  },\n  output: {\n    path: path.join(__dirname, \"dist\"),\n    filename: \"[name].js\",\n  },\n  optimization: {\n    minimize: true,\n  },\n\n  // JUST KEEP THEM\n  mode: \"production\",\n  target: \"node\",\n  module: {\n    rules: [\n      {\n        test: /\\.ts$/,\n        exclude: /node_modules/,\n        loader: \"ts-loader\",\n      },\n    ],\n  },\n  resolve: {\n    extensions: [\".tsx\", \".ts\", \".js\"],\n  },\n  plugins: [\n    new CopyWebpackPlugin({\n      patterns: [\n        {\n          from: \".env\",\n          to: \"[name][ext]\",\n        },\n        // {\n        //   from: \"./node_modules/.prisma/client/*.node\",\n        //   to: () => Promise.resolve(\"[path][name][ext]\"),\n        //   globOptions: {\n        //     dot: true,\n        //   },\n        // },\n      ],\n    }),\n    new WriteFilePlugin(),\n    new IgnorePlugin({\n      checkResource: (resource) => {\n        if (lazyImports.some((modulo) => resource.startsWith(modulo))) {\n          try {\n            require.resolve(resource);\n          } catch (err) {\n            return true;\n          }\n        }\n        return false;\n      },\n    }),\n  ],\n};\n",
  "src/MyModule.ts": "import { Module } from \"@nestjs/common\";\n\nimport { CoreUsersController } from \"./controllers/core/users/CoreUsersController\";\nimport { CoreUserrolesController } from \"./controllers/core/userRoles/CoreUserrolesController\";\nimport { CoreCategoriesController } from \"./controllers/core/categories/CoreCategoriesController\";\nimport { PostsPostsController } from \"./controllers/posts/posts/PostsPostsController\";\nimport { PostsCommentsController } from \"./controllers/posts/comments/PostsCommentsController\";\nimport { VotesVotesController } from \"./controllers/votes/votes/VotesVotesController\";\n\n@Module({\n  controllers: [\n    CoreUsersController,\n    CoreUserrolesController,\n    CoreCategoriesController,\n    PostsPostsController,\n    PostsCommentsController,\n    VotesVotesController,\n  ],\n})\nexport class MyModule {}\n",
  "src/controllers/core/users/CoreUsersController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody, TypedParam } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IUser } from \"../../../api/structures/IUser\";\nimport { IPageIUser } from \"../../../api/structures/IPageIUser\";\n\n@Controller(\"/core/users\")\nexport class CoreUsersController {\n  /**\n   * Register a new user (core.users table).\n   *\n   * This operation handles new user registration or administrator-created\n   * user accounts. It accepts all required and optional fields per the users\n   * model: username, email, bio (optional), status, and an associated\n   * user_role_id. Passwords are securely hashed before saving, never stored\n   * in plain text.\n   *\n   * Unique constraints are enforced for both username and email to prevent\n   * duplicates. The user role must point to an existing role defined in\n   * user_roles. Timestamps for creation and update are handled automatically.\n   * Successful creation returns the newly registered user's public profile\n   * and role association (never the password hash).\n   *\n   * Security and validation reflect business rules, e.g., email visibility,\n   * profile privacy, and initial status setting. Input errors or duplicates\n   * return clear messages and codes. Related endpoints: list (PATCH), read\n   * (GET), update (PUT), delete (DELETE).\n   *\n   * @param body Registration info for the new user, including username,\n   *   email, password, user role, etc.\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Post()\n  public async post(\n    @TypedBody()\n    body: IUser.ICreate,\n  ): Promise<IUser> {\n    body;\n    return typia.random<IUser>();\n  }\n\n  /**\n   * Retrieve a paginated, filterable list of users (core.users table).\n   *\n   * This operation returns a paginated and filtered list of users registered\n   * on the discussion board. Users may be searched by username, email, user\n   * role, or status, and results are sorted and paginated according to the\n   * provided parameters. The endpoint refers to the users table, whose\n   * structure includes fields for username, email, bio, role reference,\n   * password hash, timestamps, and status. Filters can help administrators or\n   * moderators locate specific accounts, monitor new signups, or audit\n   * activity. Security is enforced: only users with moderator or\n   * administrator roles can access or use advanced filters.\n   *\n   * The endpoint applies business rules from the requirements, such as hiding\n   * sensitive (e.g., password) information, and supports relations to\n   * user_roles for displaying or filtering by user type. Pagination and\n   * sorting follow best practices for usability and performance. Related\n   * endpoints: create (POST), retrieve detail (GET), update (PUT), and delete\n   * (DELETE) for users.\n   *\n   * Error handling ensures invalid queries, unauthorized access, or database\n   * issues are managed gracefully, returning clear status codes and messages.\n   * Sensitive data, such as password hashes, is never included in responses.\n   *\n   * @param body Filtering, sorting, and pagination info for user listing\n   *   request.\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patch(\n    @TypedBody()\n    body: IUser.IRequest,\n  ): Promise<IPageIUser.ISummary> {\n    body;\n    return typia.random<IPageIUser.ISummary>();\n  }\n\n  /**\n   * Retrieve detailed profile info for a specific user (core.users table).\n   *\n   * This operation retrieves the full profile and related information for a\n   * specific user, identified by their unique user ID. Fields returned follow\n   * the schema comments: username, email, bio, status, timestamps, and a\n   * reference to their user role. User roles are resolved to human-readable\n   * labels where appropriate.\n   *\n   * Sensitive fields such as password_hash are never returned. This endpoint\n   * is typically used by administrators for user management, or by users to\n   * view their own account details. Where authorized, moderators may use this\n   * endpoint for resolving moderation cases or audits. The data aligns\n   * exactly with the users table comments and model.\n   *\n   * Related endpoints include listing (PATCH), creation (POST), update (PUT),\n   * and deletion (DELETE) for users. Error handling covers not found,\n   * unauthorized, or forbidden cases, always giving appropriate error codes\n   * and minimal leak of protected info.\n   *\n   * @param id Target user's ID (UUID).\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get(\":id\")\n  public async getById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<IUser> {\n    id;\n    return typia.random<IUser>();\n  }\n\n  /**\n   * Update user profile and account fields (core.users table).\n   *\n   * Updates an existing user's information, addressing fields in the users\n   * schema, such as username, email, bio, role, status, and update timestamp.\n   * The input must include the user ID and only permitted fields are\n   * updateable. Username/email uniqueness is enforced on update as well.\n   * Moderators/administrators can change roles/statuses as permitted by\n   * business rules.\n   *\n   * The request never allows direct password updates (managed by a separate\n   * dedicated endpoint, or by password reset process for security). All\n   * change history is reflected in the updated_at timestamp. Security\n   * measures prevent users from editing others' profiles unless authorized;\n   * self-edits are limited to certain fields.\n   *\n   * Related endpoints: detail (GET), list (PATCH), create (POST), delete\n   * (DELETE). Strict validation and business rule application ensure\n   * stability and data quality.\n   *\n   * @param id Target user's ID (UUID).\n   * @param body Editable fields for user update, such as profile details or\n   *   status/role changes (excludes password updates).\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Put(\":id\")\n  public async putById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IUser.IUpdate,\n  ): Promise<IUser> {\n    id;\n    body;\n    return typia.random<IUser>();\n  }\n\n  /**\n   * Softly or fully delete a user (core.users table).\n   *\n   * Deletes a user account with the specified ID. This typically marks the\n   * user's status as deleted or suspended and/or sets a deletion flag in\n   * audit fields, per the users Prisma schema and moderation rules.\n   * Associated content (posts, comments, votes) may be retained for community\n   * reference, moderation, or audit logs, as described in requirements.\n   *\n   * Only administrators may perform this action, and a detailed audit trail\n   * is kept. Related endpoints are used for restoration or final hard-delete\n   * (if policy allows). Errors for not found or forbidden actions are handled\n   * appropriately; sensitive information on deleted users is not exposed.\n   *\n   * @param id Target user's ID (UUID).\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Delete(\":id\")\n  public async eraseById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<IUser.IDeleteResponse> {\n    id;\n    return typia.random<IUser.IDeleteResponse>();\n  }\n}\n",
  "src/controllers/core/userRoles/CoreUserrolesController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody, TypedParam } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IUserRole } from \"../../../api/structures/IUserRole\";\nimport { IPageIUserRole } from \"../../../api/structures/IPageIUserRole\";\n\n@Controller(\"/core/userRoles\")\nexport class CoreUserrolesController {\n  /**\n   * Create a new user role (core.userRoles table).\n   *\n   * Creates a new user role based on the schema structure, with fields for\n   * name (label) and description. Enforces the uniqueness of the role name\n   * and ensures all required information is provided, following the comments\n   * and requirements detailed in the Prisma schema.\n   *\n   * Intended for administrator setup or customization of new permission\n   * levels. Errors are sent in case of duplicate names, missing fields, or\n   * insufficient permissions. Successful creation returns the new user role\n   * record, suitable for immediate assignment to users.\n   *\n   * Related endpoints: list (PATCH), single GET, update (PUT), and delete\n   * (DELETE) for user roles.\n   *\n   * @param body New user role details, including name and description.\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Post()\n  public async post(\n    @TypedBody()\n    body: IUserRole.ICreate,\n  ): Promise<IUserRole> {\n    body;\n    return typia.random<IUserRole>();\n  }\n\n  /**\n   * List and filter user roles (core.userRoles table).\n   *\n   * This operation returns a paginated list of user roles available to\n   * assign, as defined by the user_roles model. Roles govern permissions\n   * across the board (e.g., member, moderator, administrator). Designed for\n   * use in registration processes, admin dashboards, or role management\n   * panels, enabling filtering by role name or description and ordering of\n   * results.\n   *\n   * Data returned is defined strictly by the Prisma model and schema\n   * comments. This operation is auditable and respects business constraints\n   * on who may view/assign roles. Related endpoints: single role GET, create\n   * (POST), update (PUT), and delete (DELETE).\n   *\n   * Error cases (e.g., forbidden access) are handled with appropriate status\n   * codes. Pagination and search parameters maximize usability and\n   * efficiency, especially for large deployments with custom roles.\n   *\n   * @param body Filter, search, and pagination info for user roles listing.\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patch(\n    @TypedBody()\n    body: IUserRole.IRequest,\n  ): Promise<IPageIUserRole> {\n    body;\n    return typia.random<IPageIUserRole>();\n  }\n\n  /**\n   * Get a single user role's details (core.userRoles table).\n   *\n   * Retrieves all details for a single user role, specified by ID. Used in\n   * admin panels to display all properties of a role, or in account\n   * registration to inform users about the meaning and permissions of each\n   * role (as described in schema comments: name, description, etc).\n   *\n   * Respects all business rules regarding role assignment and application.\n   * Related endpoints: list (PATCH), creation (POST), update (PUT), delete\n   * (DELETE). Errors for missing roles or unauthorized actions are handled\n   * gracefully, with clear messaging.\n   *\n   * @param id Target role's ID (UUID).\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get(\":id\")\n  public async getById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<IUserRole> {\n    id;\n    return typia.random<IUserRole>();\n  }\n\n  /**\n   * Edit label/description for a user role (core.userRoles table).\n   *\n   * Updates an existing user role's properties (name and/or description).\n   * Uniqueness of the name is enforced by Prisma schema rules. Typical in\n   * systems where additional roles/policies are introduced or for correcting\n   * role definitions.\n   *\n   * Only administrators are permitted to update roles. Change history is\n   * tracked and any update is reflected in audit fields. Related endpoints:\n   * detail GET, list PATCH, creation POST, and deletion DELETE for user\n   * roles.\n   *\n   * Any errors due to duplicates, forbidden edits, or missing records\n   * generate suitable error codes in response. Endpoint matches structure and\n   * intentions described in requirements and schema comments.\n   *\n   * @param id Target role's ID (UUID).\n   * @param body New values for user role fields (name/description).\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Put(\":id\")\n  public async putById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IUserRole.IUpdate,\n  ): Promise<IUserRole> {\n    id;\n    body;\n    return typia.random<IUserRole>();\n  }\n\n  /**\n   * Delete a user role from the system (core.userRoles table).\n   *\n   * Deletes a user role identified by its ID. Enforces business and schema\n   * rules about which roles can be deleted (e.g., prevents deletion of\n   * critical roles if protected by business logic). If the role is in use\n   * (referenced by users), operation will fail with a clear error message.\n   *\n   * Administrative rights are required. Detailed audit trails are maintained\n   * for changes. Related endpoints: create (POST), list (PATCH), update\n   * (PUT), detail (GET). All operations match Prisma schema and requirements.\n   * Appropriate handling is provided for not found, forbidden, or dependency\n   * errors.\n   *\n   * @param id Target role's ID (UUID).\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Delete(\":id\")\n  public async eraseById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<IUserRole.IDeleteResponse> {\n    id;\n    return typia.random<IUserRole.IDeleteResponse>();\n  }\n}\n",
  "src/controllers/core/categories/CoreCategoriesController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody, TypedParam } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { ICategory } from \"../../../api/structures/ICategory\";\nimport { IPageICategory } from \"../../../api/structures/IPageICategory\";\n\n@Controller(\"/core/categories\")\nexport class CoreCategoriesController {\n  /**\n   * Create new category (Core.categories).\n   *\n   * Allows creation of a new category topic for the discussion board, by\n   * inserting a new record into the 'categories' table in the database. The\n   * provided name must be unique among all categories. Description field\n   * gives users context. Only authorized users (administrators) are permitted\n   * to execute this operation.\n   *\n   * Input validation includes ensuring that required fields are present, name\n   * does not duplicate existing entries, and description respects\n   * length/content rules. On success, the new category is created and\n   * returned with full detail including its assigned UUID and creation\n   * timestamp.\n   *\n   * Error handling covers invalid parameters, uniqueness violations, or\n   * insufficient permissions.\n   *\n   * Related endpoints: list/search (PATCH), get (GET), update (PUT), and\n   * delete (DELETE) for categories.\n   *\n   * @param body Data for new category including unique name and description.\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Post()\n  public async post(\n    @TypedBody()\n    body: ICategory.ICreate,\n  ): Promise<ICategory> {\n    body;\n    return typia.random<ICategory>();\n  }\n\n  /**\n   * List and search categories (Core.categories).\n   *\n   * This API operation returns a list of categories, leveraging the\n   * 'categories' table from the database.\n   *\n   * The response is paginated and may be filtered based on optional query\n   * parameters such as name, partial matches in description, or created_at\n   * window. Secure endpoints may restrict certain filters or result fields to\n   * administrators. The main purpose is to allow users to browse or search\n   * available discussion categories for post assignment or exploration.\n   *\n   * Security: Some filtering/search options may be restricted to users with\n   * elevated roles, such as administrators or moderators. Regular users\n   * typically see all active categories only.\n   *\n   * This endpoint is commonly used in category selection modals,\n   * administrative dashboards, and on board homepages. Validation ensures\n   * page and pageSize are non-negative, and sortBy field must match a valid\n   * column. Error handling will return informative failures for invalid\n   * filter parameters or database errors.\n   *\n   * This operation is related to single-category get, create, update, and\n   * delete operations, and in large systems may be supplemented by category\n   * suggestion/approval flows.\n   *\n   * @param body Search criteria, pagination, and sorting parameters for\n   *   categories list query.\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patch(\n    @TypedBody()\n    body: ICategory.IRequest,\n  ): Promise<IPageICategory> {\n    body;\n    return typia.random<IPageICategory>();\n  }\n\n  /**\n   * Retrieve specific category by ID (Core.categories).\n   *\n   * Retrieves category information for the specified ID from the 'categories'\n   * table, including name, description, creation timestamp, and potentially\n   * related post count or status if extended.\n   *\n   * If the category does not exist, the API returns a clear error message.\n   * Access policies determine visibility of archived or deactivated\n   * categories—regular users can only view active categories, while admins\n   * may retrieve all states.\n   *\n   * This endpoint is essential for screens displaying category details prior\n   * to editing/deleting, or for referencing during post creation/editing\n   * workflows. Includes validation of the UUID path parameter. Returns 404 if\n   * not found or permission denied.\n   *\n   * Related endpoints: categories list/search (PATCH), create (POST), update\n   * (PUT), and delete (DELETE).\n   *\n   * @param id Unique ID of the target category\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get(\":id\")\n  public async getById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<ICategory> {\n    id;\n    return typia.random<ICategory>();\n  }\n\n  /**\n   * Update a category by ID (Core.categories).\n   *\n   * Updates an existing category's name or description by changing the\n   * relevant fields in the 'categories' table. The category is referenced by\n   * its unique UUID path parameter, and the body provides updated data.\n   *\n   * This operation may only be performed by users with appropriate\n   * administrative roles. Validation checks include verifying that the new\n   * category name does not duplicate any other categories and that all\n   * required fields meet formatting rules.\n   *\n   * Partial or full updates are supported; fields not included may retain\n   * their current values. Business rules may restrict changes if the category\n   * is currently associated with posts. On success, the full updated category\n   * information is returned.\n   *\n   * Error handling includes failing if the category does not exist, trying to\n   * use a duplicate name, or lacking sufficient rights. Related operations:\n   * get, create, delete, and list/search categories.\n   *\n   * @param id Unique ID of the target category\n   * @param body Updated name and/or description for the category.\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Put(\":id\")\n  public async putById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: ICategory.IUpdate,\n  ): Promise<ICategory> {\n    id;\n    body;\n    return typia.random<ICategory>();\n  }\n\n  /**\n   * Delete a category by ID (Core.categories).\n   *\n   * Deletes (or marks as deleted) a category based on its unique ID. This\n   * operation usually employs soft-deletion: the category is flagged so it no\n   * longer appears in lists or selection menus, but remains in the database\n   * for historical tracking and audit purposes. Some implementations may\n   * require hard deletion if the category has no posts attached.\n   *\n   * Permission to use this operation is typically restricted to\n   * administrators. Attempts to delete active categories in use by posts may\n   * be rejected or require confirmation. All deletion attempts are logged for\n   * audit.\n   *\n   * Error cases include non-existent category ID, attempts to delete\n   * categories linked to live posts, or insufficient permissions. Related\n   * endpoints: create, get, update, and list/search categories.\n   *\n   * @param id Unique ID of the target category\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Delete(\":id\")\n  public async eraseById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<ICategory.IDeleteResult> {\n    id;\n    return typia.random<ICategory.IDeleteResult>();\n  }\n}\n",
  "src/controllers/posts/posts/PostsPostsController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody, TypedParam } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IPost } from \"../../../api/structures/IPost\";\nimport { IPageIPost } from \"../../../api/structures/IPageIPost\";\n\n@Controller(\"/posts/posts\")\nexport class PostsPostsController {\n  /**\n   * Create a new post (Posts.posts).\n   *\n   * Allows a user to create a new post by providing required information such\n   * as category, title, and content. The new post is assigned to the\n   * authoring user and is inserted into the database. Creation may be subject\n   * to moderation or review depending on platform policies.\n   *\n   * Input validation includes ensuring a valid category reference,\n   * unique/valid title, and legitimate content (length, formatting). On\n   * success, the API returns the full details of the created post, including\n   * assigned UUID, timestamps, and author/category references.\n   *\n   * Error cases include missing/invalid data, attempts to create a post in\n   * non-existent category, or by unauthorized/blocked users. Related\n   * endpoints: list/search (PATCH), get (GET), update (PUT), delete (DELETE);\n   * plus comment APIs.\n   *\n   * @param body All information required for new post: categoryId, title,\n   *   content.\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Post()\n  public async post(\n    @TypedBody()\n    body: IPost.ICreate,\n  ): Promise<IPost> {\n    body;\n    return typia.random<IPost>();\n  }\n\n  /**\n   * List and search posts (Posts.posts).\n   *\n   * This API operation returns a list of posts (discussion threads or\n   * articles) with full support for filtering by category, author, or\n   * keywords, as well as sorting and pagination. Non-admin users typically\n   * see only non-deleted, non-archived posts, while administrators may have\n   * visibility into all post states. Standard search validation is performed\n   * for page, pageSize, and sort field inputs.\n   *\n   * The endpoint supports community browsing, category threads,\n   * author-centric feeds, and search result pages. It also includes support\n   * for keyword-based full-text search on titles and content. Additional\n   * metadata such as comment and vote counts may be included per business\n   * requirements. Error handling addresses invalid filters, missing results,\n   * or backend errors.\n   *\n   * Related to post retrieval (GET), post creation (POST), update (PUT), and\n   * delete (DELETE) endpoints, as well as comment and vote-related APIs.\n   *\n   * @param body Criteria for searching, paging, and sorting posts.\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patch(\n    @TypedBody()\n    body: IPost.IRequest,\n  ): Promise<IPageIPost> {\n    body;\n    return typia.random<IPageIPost>();\n  }\n\n  /**\n   * Retrieve specific post by ID (Posts.posts).\n   *\n   * Retrieves full details of a single post, identified by its unique ID.\n   * Returns all fields visible to the viewing user, such as title, content,\n   * author reference, category reference, creation and update times, etc.\n   * Admin users may access deleted posts if required, while normal users only\n   * see active posts.\n   *\n   * This API is the primary source of detail for displaying or editing a\n   * discussion post. It validates the UUID input, and returns a 404 or\n   * permission error if the post does not exist or the user lacks rights.\n   *\n   * Related endpoints: post list/search (PATCH), create (POST), update (PUT),\n   * delete (DELETE). Also supports comment and voting APIs.\n   *\n   * @param id Unique ID of the target post\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get(\":id\")\n  public async getById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<IPost> {\n    id;\n    return typia.random<IPost>();\n  }\n\n  /**\n   * Update a post by ID (Posts.posts).\n   *\n   * Updates an existing post, referenced by its unique ID. Input may update\n   * title, content, and/or category reference. Only the author or an\n   * administrator/moderator may perform this operation. All updates are\n   * validated for required structure, content, and permission.\n   *\n   * Partial updates retain other fields unchanged. History tracking is\n   * enabled via timestamps. Changing category may have restrictions if the\n   * post has live comments. On success, returns updated post data; on\n   * failure, returns validation or permission errors.\n   *\n   * Related endpoints: get, list/search, create, delete for posts. This\n   * endpoint supports editing discussion threads after posting.\n   *\n   * @param id Unique ID of the target post\n   * @param body Fields to update for post (title, content, category).\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Put(\":id\")\n  public async putById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IPost.IUpdate,\n  ): Promise<IPost> {\n    id;\n    body;\n    return typia.random<IPost>();\n  }\n\n  /**\n   * Delete a post by ID (Posts.posts).\n   *\n   * Deletes (or marks as deleted) a post record by its ID. Standard\n   * implementation is soft-deletion: post remains in database for moderation\n   * and audit but is removed from normal views and feeds. Only the original\n   * author, admin, or moderator can perform deletion. Attempts to delete\n   * posts with active comments or votes may be subject to business rule\n   * restrictions or warnings.\n   *\n   * All delete actions are logged. The response provides confirmation or\n   * error. Related endpoints: create, get, update, and list/search for posts.\n   * Deletion cascades may apply to comments and votes as policy dictates.\n   *\n   * @param id Unique ID of the target post\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Delete(\":id\")\n  public async eraseById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<IPost.IDeleteResult> {\n    id;\n    return typia.random<IPost.IDeleteResult>();\n  }\n}\n",
  "src/controllers/posts/comments/PostsCommentsController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody, TypedParam } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IComment } from \"../../../api/structures/IComment\";\nimport { IPageIComment } from \"../../../api/structures/IPageIComment\";\n\n@Controller(\"/posts/comments\")\nexport class PostsCommentsController {\n  /**\n   * Create a new comment (Posts domain, 'comments' table).\n   *\n   * This API lets a registered user create a new comment (either as a direct\n   * reply to a post or as a nested reply to another comment). Necessary\n   * fields include the content, target postId, and optionally a parentId (for\n   * replies-to-replies).\n   *\n   * Input is validated for minimum/maximum length, appropriate content, and\n   * ensuring the parent exists and belongs to the same post. The endpoint\n   * checks author authentication and standard anti-abuse policies (e.g., rate\n   * limiting). On success, it returns the created comment record with all\n   * metadata (author, timestamp, etc.).\n   *\n   * Business logic from the 'comments' table (Posts domain) is implemented:\n   * only registered users may comment; soft deletion rules apply. Related\n   * endpoints: retrieval (GET /posts/comments/{id}), update (PUT\n   * /posts/comments/{id}), and listing (PATCH /posts/comments).\n   *\n   * @param body New comment data, including content, postId, and optional\n   *   parentId.\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Post()\n  public async post(\n    @TypedBody()\n    body: IComment.ICreate,\n  ): Promise<IComment> {\n    body;\n    return typia.random<IComment>();\n  }\n\n  /**\n   * Retrieve a filtered, paginated list of comments (Posts domain, 'comments'\n   * table).\n   *\n   * This API retrieves a paged list of comments from the discussion board.\n   * Typically, users or moderators use it to see all comments on a specific\n   * thread, all comments by a particular user, or to moderate recent\n   * activity.\n   *\n   * The route supports filtering (e.g., by postId, userId, parentId),\n   * pagination (offset/limit), full-text search on comment content, and\n   * sorting (e.g., newest first). Security considerations include only\n   * exposing non-deleted comments by default, unless requested by a\n   * privileged moderator/admin. Comment content is filtered to remove\n   * inappropriate language if the requester has insufficient privileges.\n   *\n   * It references the 'comments' table (Posts domain). Query performance is\n   * optimized via relevant indexes. Related APIs include: create (POST\n   * /posts/comments), update (PUT /posts/comments/{id}), retrieve detail (GET\n   * /posts/comments/{id}), and delete (DELETE /posts/comments/{id}).\n   *\n   * Input validation includes correct types for filters, max page size, and\n   * valid sort orders. Error handling covers unauthorized access, malformed\n   * filters, and nonexistent references.\n   *\n   * @param body Defines filtering, pagination, and sorting criteria for\n   *   retrieving comments. Fields may include postId, userId, parentId,\n   *   search, offset, limit, and sort.\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patch(\n    @TypedBody()\n    body: IComment.IRequest,\n  ): Promise<IPageIComment> {\n    body;\n    return typia.random<IPageIComment>();\n  }\n\n  /**\n   * Fetch detailed information about a single comment (Posts domain,\n   * 'comments' table).\n   *\n   * This API fetches the detail of a single comment in the discussion board\n   * by its unique ID. Common scenarios include users viewing a nested reply,\n   * moderators inspecting a reported comment, or when displaying a comment in\n   * thread view.\n   *\n   * It returns full details such as content, author, timestamps, post\n   * reference, parent comment reference, and vote tallies. The route\n   * references the 'comments' table (Posts domain) and is optimized for quick\n   * retrieval. It will not return comments marked as deleted unless accessed\n   * by a user with sufficient privileges (e.g., moderator or admin).\n   *\n   * Error handling includes returning appropriate errors for nonexistent,\n   * deleted, or unauthorized access. Related APIs: listing (PATCH\n   * /posts/comments), update (PUT /posts/comments/{id}), creation (POST\n   * /posts/comments), and deletion (DELETE /posts/comments/{id}).\n   *\n   * @param id Target comment's ID\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get(\":id\")\n  public async getById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<IComment> {\n    id;\n    return typia.random<IComment>();\n  }\n\n  /**\n   * Update an existing comment's content or deletion status (Posts domain,\n   * 'comments' table).\n   *\n   * This API allows an authorized user (typically the comment's original\n   * author or a moderator/admin) to update the content or status of a\n   * comment. Supported fields for update include content (for editing), and\n   * soft deletion flag.\n   *\n   * Checks include author authentication, edit time-window (if enforced by\n   * policy), and protection against editing after moderation/deletion. Input\n   * validation ensures updated content meets platform standards, and\n   * references are unaltered (cannot change post or parentId).\n   *\n   * The endpoint references the 'comments' table (Posts domain). On success,\n   * returns the updated comment object. Error scenarios include not found,\n   * unauthorized modification, or invalid updates. Related APIs: create (POST\n   * /posts/comments), retrieve (GET /posts/comments/{id}), delete (DELETE\n   * /posts/comments/{id}).\n   *\n   * @param id The target comment's ID to update\n   * @param body Fields to update in the comment (content and/or soft delete).\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Put(\":id\")\n  public async putById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IComment.IUpdate,\n  ): Promise<IComment> {\n    id;\n    body;\n    return typia.random<IComment>();\n  }\n\n  /**\n   * Soft-delete a comment (Posts domain, 'comments' table).\n   *\n   * This API performs a soft deletion (marks as deleted) of a comment\n   * identified by its ID. Typical scenarios: the comment's author chooses to\n   * remove their reply, or a moderator removes content that violates policy.\n   * The comment remains in the database (for auditability), but becomes\n   * invisible to regular users and excluded from normal listings.\n   *\n   * Authorization checks enforce only the author, moderator, or admin can\n   * perform this. Related error handling includes not found, already deleted,\n   * and unauthorized access. Audit logs are typically recorded. Related\n   * endpoints: create (POST /posts/comments), update (PUT\n   * /posts/comments/{id}), retrieve (GET /posts/comments/{id}), list (PATCH\n   * /posts/comments).\n   *\n   * @param id The comment's ID to delete\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Delete(\":id\")\n  public async eraseById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<IComment.IDeleteResult> {\n    id;\n    return typia.random<IComment.IDeleteResult>();\n  }\n}\n",
  "src/controllers/votes/votes/VotesVotesController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody, TypedParam } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IVote } from \"../../../api/structures/IVote\";\nimport { IPageIVote } from \"../../../api/structures/IPageIVote\";\n\n@Controller(\"/votes/votes\")\nexport class VotesVotesController {\n  /**\n   * Create a new vote (Votes domain, 'votes' table).\n   *\n   * Lets a user cast a vote—either upvote or downvote—on a post or comment.\n   * Input: must include user ID, value (+1/-1), and reference to either a\n   * post or a comment (but not both). Performs validation to ensure target\n   * exists and user has not already voted. On success, returns created vote\n   * record.\n   *\n   * Vote limit: only one vote per user per content item, enforced via unique\n   * constraint. Can be used for voting analytics, user history, and tally\n   * calculations. Related endpoints: retrieve (GET /votes/votes/{id}), update\n   * (PUT /votes/votes/{id}), delete (DELETE /votes/votes/{id}), list (PATCH\n   * /votes/votes).\n   *\n   * @param body Cast a vote on a post or comment: must include value (+1 or\n   *   -1) and target (postId or commentId).\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Post()\n  public async post(\n    @TypedBody()\n    body: IVote.ICreate,\n  ): Promise<IVote> {\n    body;\n    return typia.random<IVote>();\n  }\n\n  /**\n   * Retrieve a filtered, paginated list of votes (Votes domain, 'votes'\n   * table).\n   *\n   * This API returns a list of vote records, most commonly used for reviewing\n   * moderation history, analytics, or a user's own votes. Supports filtering\n   * by userId, postId, or commentId; pagination (offset/limit); sort order\n   * (most recent, oldest first). Optionally, can search for patterns if\n   * metadata fields exist.\n   *\n   * References the 'votes' table (Votes domain) and makes use of unique\n   * constraints (one vote per user per item) in its filtering logic. Security\n   * notes: regular users can only see their own votes, admins/moderators may\n   * audit all. Related endpoints: create (POST /votes/votes), update (PUT\n   * /votes/votes/{id}), detail (GET /votes/votes/{id}), delete (DELETE\n   * /votes/votes/{id}).\n   *\n   * @param body Filtering, pagination, and sorting for votes list. Fields:\n   *   userId, postId, commentId, offset, limit, sort.\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patch(\n    @TypedBody()\n    body: IVote.IRequest,\n  ): Promise<IPageIVote> {\n    body;\n    return typia.random<IPageIVote>();\n  }\n\n  /**\n   * Retrieve full details for a single vote (Votes domain, 'votes' table).\n   *\n   * Fetches detail for a specific vote, identified by its unique ID. Useful\n   * for moderation review or self-audit by a voting user. Information\n   * includes which user voted, the value (+1/-1), what post/comment was\n   * targeted, and timestamps.\n   *\n   * References the 'votes' table (Votes domain). Only visible to the vote's\n   * owner or those with sufficient privilege. Error handling covers not\n   * found, unauthorized access, and malformed IDs. Related endpoints: create\n   * (POST /votes/votes), update (PUT /votes/votes/{id}), details (PATCH\n   * /votes/votes), delete (DELETE /votes/votes/{id}).\n   *\n   * @param id Vote record's ID\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get(\":id\")\n  public async getById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<IVote> {\n    id;\n    return typia.random<IVote>();\n  }\n\n  /**\n   * Edit an existing vote's value (Votes domain, 'votes' table).\n   *\n   * Lets a user (or moderator/admin) edit an existing vote—typically to\n   * change their upvote to downvote or vice versa, or to correct an input\n   * error. Only the vote's owner or privileged users may edit. Only value can\n   * change; postId or commentId are immutable.\n   *\n   * Business logic is enforced as per the 'votes' table (Votes domain): only\n   * one vote per user/content, mutual exclusivity between postId/commentId,\n   * and all references must remain valid. Returns the updated vote on\n   * success. Related endpoints: create (POST /votes/votes), retrieve (GET\n   * /votes/votes/{id}), list (PATCH /votes/votes), delete (DELETE\n   * /votes/votes/{id}).\n   *\n   * @param id Vote record's ID to update\n   * @param body Fields to update in the vote (only value may be changed).\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Put(\":id\")\n  public async putById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IVote.IUpdate,\n  ): Promise<IVote> {\n    id;\n    body;\n    return typia.random<IVote>();\n  }\n\n  /**\n   * Delete a vote record from the database (Votes domain, 'votes' table).\n   *\n   * This endpoint removes a specific vote by its ID. Common use-cases: a user\n   * withdraws their vote or a moderator/admin removes a vote for violating\n   * policy. The vote is deleted from the database (hard delete), and any\n   * relevant tally is decremented.\n   *\n   * Authorization checks ensure only the vote's owner or privileged roles may\n   * perform deletion. Related endpoints: create (POST /votes/votes), update\n   * (PUT /votes/votes/{id}), retrieve (GET /votes/votes/{id}), list (PATCH\n   * /votes/votes). Audit logging may be triggered for moderation actions.\n   *\n   * @param id Vote record's ID to delete\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Delete(\":id\")\n  public async eraseById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<IVote.IDeleteResult> {\n    id;\n    return typia.random<IVote.IDeleteResult>();\n  }\n}\n",
  "src/api/structures/IPost.ts": "import { tags } from \"typia\";\n\n/**\n * 토론 게시판의 게시글(포스트) 정보를 담는 도메인 오브젝트입니다.\n *\n * 작성자, 카테고리, 제목·본문, 생성/수정/삭제일 등을 보유하여 커뮤니티 핵심 콘텐츠 구조를 이룹니다.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IPost = {\n  /** 게시글의 고유 ID (Prisma 'posts.id'). */\n  id: string & tags.Format<\"uuid\">;\n\n  /** 작성자(유저) ID (Prisma 'posts.user_id'). */\n  user_id: string & tags.Format<\"uuid\">;\n\n  /** 카테고리 ID (Prisma 'posts.category_id'). */\n  category_id: string & tags.Format<\"uuid\">;\n\n  /** 게시글 제목 (Prisma 'posts.title'). */\n  title: string;\n\n  /** 게시글 본문 (Prisma 'posts.content'). */\n  content: string;\n\n  /** 생성 시각 (Prisma 'posts.created_at'). */\n  created_at: string & tags.Format<\"date-time\">;\n\n  /** 수정 시각 (Prisma 'posts.updated_at'). */\n  updated_at: string & tags.Format<\"date-time\">;\n\n  /** 삭제(soft delete) 시각(Prisma 'posts.deleted_at'). 삭제 안된 경우 null. */\n  deleted_at?: (string & tags.Format<\"date-time\">) | null;\n};\nexport namespace IPost {\n  /**\n   * 게시글(포스트)의 요약 정보를 제공하는 타입입니다. 목록 조회, 관계 프로퍼티 등에서 사용됩니다.\n   *\n   * 게시글의 고유 ID, 제목, 작성자 ID, 카테고리 ID, 생성일, 수정일, 댓글/추천 등 카운트 필수 정보를 담고 있어, 리스트\n   * UI 테이블/카드 등 요약 리스트용으로 활용합니다. 본문 전체나 관계 정보는 포함하지 않습니다.\n   */\n  export type ISummary = {\n    /** 게시글 고유 식별자(UUID). 예: '973c0116-ac2c-4ffb-b38b-7c4c45c7b2df' */\n    id: string & tags.Format<\"uuid\">;\n\n    /** 작성자(user)의 ID(UUID) */\n    user_id: string & tags.Format<\"uuid\">;\n\n    /** 속한 카테고리의 ID(UUID) */\n    category_id: string & tags.Format<\"uuid\">;\n\n    /** 게시글 제목 */\n    title: string;\n\n    /** 게시글 작성일시(ISO8601) */\n    created_at: string & tags.Format<\"date-time\">;\n\n    /** 게시글 마지막 수정 시각(ISO8601) */\n    updated_at: string & tags.Format<\"date-time\">;\n\n    /** 해당 글의 댓글 개수 */\n    comment_count: number & tags.Type<\"int32\">;\n\n    /** 해당 글의 추천(투표) 합계 */\n    vote_count: number & tags.Type<\"int32\">;\n  };\n\n  /**\n   * 게시글 검색, 필터, 페이징에 요청 정보로 사용되는 객체입니다.\n   *\n   * 카테고리, 작성자, 키워드, 기간, 페이징 등 다양한 필터를 지원하여 게시글 탐색 UX를 구현합니다.\n   */\n  export type IRequest = {\n    /**\n     * 검색/필터링용 카테고리 ID.\n     *\n     * 특정 카테고리 내 게시글만 조회하고자 할 때 사용합니다.\n     */\n    category_id?: string & tags.Format<\"uuid\">;\n\n    /**\n     * 검색/필터링용 작성자(유저) ID.\n     *\n     * 특정 사용자가 작성한 게시글만 조회할 때 활용합니다.\n     */\n    user_id?: string & tags.Format<\"uuid\">;\n\n    /**\n     * 제목 키워드 검색 (부분 일치 허용).\n     *\n     * 게시글의 제목에 포함된 키워드로 검색합니다.\n     */\n    title?: string;\n\n    /**\n     * 본문 키워드 검색 (부분 일치 허용).\n     *\n     * 게시글의 전체 텍스트에서 키워드로 검색합니다.\n     */\n    content?: string;\n\n    /** 게시글 생성 시작일(검색 필터용, ISO8601). */\n    created_from?: string & tags.Format<\"date-time\">;\n\n    /** 게시글 생성 종료일(검색 필터용, ISO8601). */\n    created_to?: string & tags.Format<\"date-time\">;\n\n    /** 페이지 번호(1 이상). */\n    page: number & tags.Type<\"int32\"> & tags.Minimum<1>;\n\n    /** 페이지당 데이터 수(기본 100). */\n    limit: number & tags.Type<\"int32\"> & tags.Minimum<1>;\n  };\n\n  /**\n   * 게시글 신규 작성 요청에 전달되는 바디입니다.\n   *\n   * 카테고리, 제목, 본문, 작성자 정보를 반드시 포함해야 합니다. 생성일시 등은 서버에서 자동 처리합니다.\n   */\n  export type ICreate = {\n    /** 작성할 게시글의 카테고리 ID. (필수) */\n    category_id: string & tags.Format<\"uuid\">;\n\n    /** 게시글 제목. 예: '2025년 물가·인플레이션 전망' */\n    title: string;\n\n    /** 게시글 본문 내용. (텍스트·포맷팅 지원) */\n    content: string;\n\n    /** 작성자(Author) ID. 회원 작성 시 필수 */\n    user_id: string & tags.Format<\"uuid\">;\n\n    /** 생성시각 (시스템 자동 할당이지만, 조직 배치용으로도 허용될 수 있음) */\n    created_at?: string & tags.Format<\"date-time\">;\n  };\n\n  /**\n   * 기존 게시글(포스트)의 제목/본문/카테고리를 수정하는 요청 바디입니다.\n   *\n   * 각 필드는 선택값으로, 일부만 수정 가능하며 누락시 기존 값 유지합니다.\n   */\n  export type IUpdate = {\n    /** 변경할 게시글 제목 (옵션) */\n    title?: string;\n\n    /** 변경할 게시글 본문 (옵션) */\n    content?: string;\n\n    /** 변경할 카테고리 ID (옵션) */\n    category_id?: string & tags.Format<\"uuid\">;\n  };\n\n  /**\n   * 게시글 삭제(soft/hard) 요청 결과나 상태를 반환하는 결과 객체입니다.\n   *\n   * 정상 삭제(숨김) 시 success=true, 실패 시 false와 설명 메시지를 제공합니다.\n   */\n  export type IDeleteResult = {\n    /** 삭제(Soft 또는 Hard) 성공 여부 */\n    success: boolean;\n\n    /** 삭제 결과 메시지 */\n    message: string;\n  };\n}\n",
  "src/api/structures/IUser.ts": "import { tags } from \"typia\";\n\nimport { IUserRole } from \"./IUserRole\";\nimport { IPost } from \"./IPost\";\nimport { IComment } from \"./IComment\";\nimport { IVote } from \"./IVote\";\n\n/**\n * Full user entity, as per users Prisma schema. Contains all non-confidential\n * account info and relations.\n *\n * Detailed per-table and per-field documentation referenced from schema.\n * Represents user profiles for detail pages and admin/mod tools.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IUser = {\n  /**\n   * Unique internal user ID (users.id). Used system-wide to link all user\n   * objects, references, and foreign keys.\n   *\n   * Required; generated upon account creation and immutable.\n   */\n  id: string & tags.Format<\"uuid\">;\n\n  /**\n   * Foreign key to user_roles.id; denotes the active permission set (member,\n   * moderator, admin, etc).\n   *\n   * Required at creation; determines access, moderation, and board\n   * capabilities.\n   */\n  user_role_id: string & tags.Format<\"uuid\">;\n\n  /**\n   * Unique public display name; visible to all, and referenced in discussion,\n   * voting, and moderation.\n   *\n   * Database-enforced as unique.\n   */\n  username: string;\n\n  /**\n   * User's email address. Used for login and communication.\n   *\n   * Never displayed publicly. Must be unique.\n   */\n  email: string & tags.Format<\"email\">;\n\n  /**\n   * Free-form user biography/self-description.\n   *\n   * Optional, enhances social context on the board.\n   */\n  bio?: string | null;\n\n  /**\n   * Account creation datetime (with timezone). Used for auditing, ordering,\n   * and admin reporting.\n   *\n   * Immutable.\n   */\n  created_at: string & tags.Format<\"date-time\">;\n\n  /**\n   * Most recent profile update timestamp for this user.\n   *\n   * Updated whenever profile fields are changed.\n   */\n  updated_at: string & tags.Format<\"date-time\">;\n\n  /**\n   * Current account status (active, suspended, banned, etc.).\n   *\n   * Enforced per moderation/business rule policies.\n   */\n  status: string;\n  role: IUserRole;\n\n  /**\n   * Array of summaries for posts authored by the user (board threads or\n   * articles).\n   */\n  posts?: IPost.ISummary[];\n\n  /** List of summaries for comments made by this user. */\n  comments?: IComment.ISummary[];\n\n  /** Summary array of votes cast by the user on posts/comments. */\n  votes?: IVote.ISummary[];\n};\nexport namespace IUser {\n  /**\n   * User list request/filter parameters, supporting pagination, search, and\n   * filtering by role or status.\n   *\n   * Implements board requirements around user management and moderation.\n   * Based on database and business rules from Core.users and relevant API\n   * operation specs.\n   */\n  export type IRequest = {\n    /**\n     * Page number for user list pagination. Optional field, aligns with\n     * standard best practices for paginated APIs.\n     *\n     * Used to retrieve a specific page of user data. Default follows the\n     * IPage IRequest definition.\n     */\n    page?: number &\n      tags.Type<\"int32\"> &\n      tags.JsonSchemaPlugin<{\n        format: \"uint32\";\n      }>;\n\n    /**\n     * Number of users per page (for pagination). Optional, defaults to 100\n     * if unspecified as per IPage specification.\n     *\n     * Restricts how many user records are returned in each page.\n     */\n    limit?: number &\n      tags.Type<\"int32\"> &\n      tags.JsonSchemaPlugin<{\n        format: \"uint32\";\n      }>;\n\n    /**\n     * Filter by user role (user_roles.id) to return users with a specific\n     * role (e.g., member, moderator, administrator).\n     *\n     * Helps admins/moderators filter and locate users of a particular type\n     * or permission set.\n     */\n    role?: string & tags.Format<\"uuid\">;\n\n    /**\n     * Filter users by account status (e.g., 'active', 'suspended',\n     * 'banned').\n     *\n     * Enables moderation and administrative user management by quickly\n     * finding users in specific states.\n     */\n    status?: string;\n\n    /**\n     * Search string, matches username or email in user list queries.\n     *\n     * Supports quick filtering of users when searching by identifying\n     * fields; case-insensitive partial match.\n     */\n    search?: string;\n  };\n\n  /**\n   * Concise user summary as returned in user listing responses. Hides\n   * sensitive fields.\n   *\n   * Includes only public profile, role summary, and status info. Used in\n   * paginated user lists and admin/member lookup features.\n   */\n  export type ISummary = {\n    /**\n     * User's unique identifier (UUID).\n     *\n     * Referenced from users.id in the database, required for user profile\n     * lookups.\n     */\n    id: string & tags.Format<\"uuid\">;\n\n    /**\n     * Public username (displayed in the board and visible to all users).\n     *\n     * Unique and required; serves as the user's main identifier for\n     * discussions, voting, and moderation.\n     */\n    username: string;\n\n    /**\n     * Optional user biography; a short self-description or interests\n     * section.\n     *\n     * May be empty; helps other members know basic info about the user.\n     */\n    bio?: string | null;\n    role: IUserRole.ISummary;\n\n    /**\n     * Current user account status (e.g., 'active', 'suspended', 'banned').\n     *\n     * Reflects moderation, login eligibility, and enforcement of platform\n     * rules.\n     */\n    status: string;\n  };\n\n  /**\n   * Request body schema for new user registration/account creation.\n   *\n   * All required/optional fields per users model. Password is accepted as\n   * clear text but is hashed internally.\n   */\n  export type ICreate = {\n    /**\n     * Role assignment for new user; must match user_roles.id. Required at\n     * registration. E.g., 'member', 'moderator', or 'administrator'.\n     */\n    user_role_id: string & tags.Format<\"uuid\">;\n\n    /**\n     * New user's unique public display name. Required, must be unique,\n     * visible on the board.\n     */\n    username: string;\n\n    /**\n     * New user's email address. Required for registration, must be unique,\n     * never public.\n     */\n    email: string & tags.Format<\"email\">;\n\n    /** Optional user bio/about section. May be empty upon registration. */\n    bio?: string | null;\n\n    /**\n     * User password, plain text at registration. Required; will be securely\n     * hashed before storage. Never returned by API.\n     */\n    password: string;\n\n    /**\n     * Initial status for user: normally 'active', but admin can specify\n     * e.g., 'pending', 'suspended'.\n     */\n    status: string;\n  };\n\n  /**\n   * Request body for updating an existing user profile/account.\n   *\n   * Only fields supplied are updated; all are optional. Password change is\n   * NOT handled here.\n   */\n  export type IUpdate = {\n    /**\n     * (Optional) Role update for user. Admin/moderator action only. Must\n     * match an existing user_roles.id.\n     */\n    user_role_id?: string & tags.Format<\"uuid\">;\n\n    /**\n     * (Optional) Update to user's public display name. Must be unique if\n     * updated.\n     */\n    username?: string;\n\n    /**\n     * (Optional) Update to user's email address. Uniqueness required if\n     * changed.\n     */\n    email?: string & tags.Format<\"email\">;\n\n    /** (Optional) Update to bio/about me field. */\n    bio?: string | null;\n\n    /** (Optional) Modify user account status (active, suspended, etc.). */\n    status?: string;\n\n    /** Update timestamp; automatically set by the server on update. */\n    updated_at?: string & tags.Format<\"date-time\">;\n  };\n\n  /**\n   * Response for user deletion operation. Contains minimal identifying and\n   * audit info.\n   *\n   * Does not reveal sensitive user fields.\n   */\n  export type IDeleteResponse = {\n    /**\n     * ID of user deleted or marked for deletion. Used for reference in\n     * audit trails and deletion confirmations.\n     */\n    id?: string & tags.Format<\"uuid\">;\n\n    /**\n     * Status message (e.g., 'deleted', 'suspended', etc.) after\n     * deletion/disable action.\n     */\n    status?: string;\n  };\n}\n",
  "src/api/structures/IUserRole.ts": "import { tags } from \"typia\";\n\nimport { IUser } from \"./IUser\";\n\n/**\n * Full user role entity, as per user_roles Prisma model. Details all\n * privilege/permission details, assignment context, and required unique\n * properties.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IUserRole = {\n  /**\n   * Unique ID for this user role entry.\n   *\n   * Primary key in user_roles. Required for all entity referencing\n   * (assignment, lookup, etc.).\n   */\n  id: string & tags.Format<\"uuid\">;\n\n  /**\n   * Machine- and human-readable name for the user role, e.g., 'member',\n   * 'moderator', or 'administrator'.\n   *\n   * Must be unique, and required for referential integrity.\n   */\n  name: string;\n\n  /**\n   * Human explanation of what privileges and duties this role holds.\n   *\n   * Aids in assigning and documenting permissions for users. Required for\n   * compliance with admin/business rule traceability.\n   */\n  description: string;\n\n  /**\n   * (For reference/audit) Array of users holding this role. May be omitted if\n   * not required at runtime.\n   */\n  users?: IUser.ISummary[];\n};\nexport namespace IUserRole {\n  /**\n   * Summary/view version of a user role entity. Contains only essential\n   * fields (id, name).\n   *\n   * Used for responses where full details are unnecessary but reference is\n   * required.\n   */\n  export type ISummary = {\n    /**\n     * Unique identifier for user role (user_roles.id field).\n     *\n     * Enforces referential integrity for permission assignments.\n     */\n    id: string & tags.Format<\"uuid\">;\n\n    /**\n     * Short label name for the user role (e.g., 'member', 'moderator',\n     * 'administrator').\n     *\n     * Used in dropdowns, labels, admin tools. Required and unique per\n     * database schema.\n     */\n    name: string;\n  };\n\n  /**\n   * List/request filtering schema for user roles table.\n   *\n   * Supports pagination, keyword search for role management dashboards,\n   * registration, and editor widgets.\n   */\n  export type IRequest = {\n    /**\n     * Page number for role list pagination. Optional; aligns with IPage\n     * best-practice.\n     */\n    page?: number &\n      tags.Type<\"int32\"> &\n      tags.JsonSchemaPlugin<{\n        format: \"uint32\";\n      }>;\n\n    /**\n     * Pagination limit for number of roles per page. Defaults to 100 if\n     * missing.\n     *\n     * Standard for IPage APIs.\n     */\n    limit?: number &\n      tags.Type<\"int32\"> &\n      tags.JsonSchemaPlugin<{\n        format: \"uint32\";\n      }>;\n\n    /**\n     * Keyword filter for role name or description fields. Enables quick\n     * role lookup.\n     */\n    search?: string;\n  };\n\n  /**\n   * Request schema for creating new user roles.\n   *\n   * Allows admin tools to set up new permissions/policies in the board, with\n   * full business rule auditing.\n   */\n  export type ICreate = {\n    /**\n     * Unique name for new role; will become user_roles.name. E.g.,\n     * 'moderator', 'editor', or custom label.\n     */\n    name: string;\n\n    /**\n     * Text description covering what the role enables/limits for users\n     * assigned to it.\n     */\n    description: string;\n  };\n\n  /**\n   * Request schema for editing an existing user role entry.\n   *\n   * All fields optional; only modified fields must be sent.\n   */\n  export type IUpdate = {\n    /** (Optional) New/updated role name. Must remain unique if updated. */\n    name?: string;\n\n    /** (Optional) Update/extend role meaning or allowed actions. */\n    description?: string;\n  };\n\n  /**\n   * Response schema for confirming user role deletion (admin-only).\n   *\n   * Includes minimal info required for audit logs and error/success\n   * reporting.\n   */\n  export type IDeleteResponse = {\n    /**\n     * ID of user role entry deleted or marked deleted. For audit and\n     * post-delete reference.\n     */\n    id?: string & tags.Format<\"uuid\">;\n\n    /**\n     * Delete or audit status: e.g., 'deleted', 'archived', 'in use - not\n     * deleted'.\n     */\n    status?: string;\n  };\n}\n",
  "src/api/structures/IPageIUser.ts": "import { IPage } from \"./IPage\";\nimport { IUser } from \"./IUser\";\n\nexport namespace IPageIUser {\n  /**\n   * Paginated user summary list container.\n   *\n   * Standardized IPage<T> wrapper for user listings, as per business\n   * requirements.\n   */\n  export type ISummary = {\n    pagination: IPage.IPagination;\n\n    /** Paginated list of user summaries matching request filters. */\n    data: IUser.ISummary[];\n  };\n}\n",
  "src/api/structures/IPageIUserRole.ts": "import { IPage } from \"./IPage\";\nimport { IUserRole } from \"./IUserRole\";\n\n/**\n * Paginated wrapper of user roles, for admin lookup and registration dropdowns.\n *\n * Implements standard IPage format with list of IUserRole.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IPageIUserRole = {\n  pagination: IPage.IPagination;\n\n  /** Array of role entities for administrative/user assignment purposes. */\n  data: IUserRole[];\n};\n",
  "src/api/structures/IPage.ts": "import { tags } from \"typia\";\n\nexport namespace IPage {\n  /**\n   * Pagination metadata for paged responses, including\n   * current/limit/total/pageCount as per business requirements and search\n   * usability.\n   */\n  export type IPagination = {\n    /** Current page number. */\n    current: number &\n      tags.Type<\"int32\"> &\n      tags.JsonSchemaPlugin<{\n        format: \"uint32\";\n      }>;\n\n    /** Limitation of records per a page. Default: 100. */\n    limit: number &\n      tags.Type<\"int32\"> &\n      tags.JsonSchemaPlugin<{\n        format: \"uint32\";\n      }>;\n\n    /** Total records in the database. */\n    records: number &\n      tags.Type<\"int32\"> &\n      tags.JsonSchemaPlugin<{\n        format: \"uint32\";\n      }>;\n\n    /** Total number of pages (records/limit, ceiled). */\n    pages: number &\n      tags.Type<\"int32\"> &\n      tags.JsonSchemaPlugin<{\n        format: \"uint32\";\n      }>;\n  };\n}\n",
  "src/api/structures/ICategory.ts": "import { tags } from \"typia\";\n\n/**\n * 토론 게시판의 주제분류(카테고리) 정보를 담는 엔터티입니다.\n *\n * 각 카테고리는 고유명, 설명, 생성일시 필드를 가지며 게시글(Posts)과 1:N 관계입니다. 관리자가 생성·관리하며, 게시글 작성 시\n * 반드시 할당해야 하는 구조입니다.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type ICategory = {\n  /**\n   * 카테고리의 고유 식별자(UUID).\n   *\n   * Prisma 'categories.id' 컬럼. 예: 'b4682df2-b264-4e1b-807d-381340390a64'.\n   */\n  id: string & tags.Format<\"uuid\">;\n\n  /**\n   * 카테고리 이름(고유).\n   *\n   * Prisma 'categories.name' 컬럼. 예: '정치', '경제'\n   */\n  name: string;\n\n  /**\n   * 카테고리 상세 설명.\n   *\n   * Prisma 'categories.description' 컬럼. 예: '정치 제도와 관련된 모든 주제를 다룹니다.'\n   */\n  description: string;\n\n  /**\n   * 카테고리 생성 일시(ISO8601).\n   *\n   * Prisma 'categories.created_at' 컬럼. 예: '2024-06-09T09:00:00+09:00'.\n   */\n  created_at: string & tags.Format<\"date-time\">;\n};\nexport namespace ICategory {\n  /**\n   * 카테고리 리스트/검색 요청에 이용되는 필터, 검색, 페이징 정보 객체입니다.\n   *\n   * 카테고리 명, 설명, 기간 필터, 페이징 조작(페이지, limit) 등 검색 옵션을 다루며, 관리자 또는 일반 사용자의 카테고리\n   * 목록 검색 시 활용됩니다.\n   */\n  export type IRequest = {\n    /**\n     * 필터링 또는 검색을 위한 카테고리 이름입니다.\n     *\n     * 예: '정치', '경제'\n     */\n    name?: string;\n\n    /**\n     * 카테고리 설명의 검색을 위한 옵션 필드입니다.\n     *\n     * 예: '정치 체계와 관련된 논의', '국제 경제 토론'\n     */\n    description?: string;\n\n    /** 검색 시작일자(ISO8601 형식). 예: '2024-06-09T00:00:00+09:00'. */\n    created_from?: string & tags.Format<\"date-time\">;\n\n    /** 검색 종료일자(ISO8601 형식). 예: '2024-07-09T23:59:59+09:00'. */\n    created_to?: string & tags.Format<\"date-time\">;\n\n    /** 페이지 번호(1부터 시작). */\n    page: number & tags.Type<\"int32\"> & tags.Minimum<1>;\n\n    /** 페이지당 반환할 레코드 수(기본값 100). */\n    limit: number & tags.Type<\"int32\"> & tags.Minimum<1>;\n  };\n\n  /**\n   * 카테고리 신규 생성시 전달하는 요청 바디 객체입니다.\n   *\n   * 이름(고유), 설명을 필수로 제공해야 하며, 관리자가 카테고리를 추가할 때 활용됩니다.\n   */\n  export type ICreate = {\n    /** 신규 카테고리의 이름(고유). 예: '시사', '국제'. */\n    name: string;\n\n    /** 카테고리 상세 설명. 예: '글로벌 경제 및 정치 이슈를 다루는 공간입니다.' */\n    description: string;\n  };\n\n  /**\n   * 기존 카테고리의 이름·설명을 수정하는 요청 바디입니다.\n   *\n   * 두 필드 모두 선택적이며, 하나 또는 모두 변경할 수 있습니다.\n   */\n  export type IUpdate = {\n    /** 변경할 카테고리명(옵션). 예: '사회' */\n    name?: string;\n\n    /** 변경할 카테고리 설명(옵션). */\n    description?: string;\n  };\n\n  /**\n   * 카테고리 삭제(soft/hard delete) 결과를 나타내는 오브젝트입니다.\n   *\n   * 성공/실패의 플래그 및 설명 메시지를 포함해 후처리 사용자 안내에 활용합니다.\n   */\n  export type IDeleteResult = {\n    /** 삭제 성공 여부. true 이면 정상 삭제, false 이면 오류. */\n    success: boolean;\n\n    /** 삭제 결과 메시지(실패 이유, 성공 안내 등). */\n    message: string;\n  };\n}\n",
  "src/api/structures/IPageICategory.ts": "import { IPage } from \"./IPage\";\nimport { ICategory } from \"./ICategory\";\n\n/**\n * 카테고리 검색/조회 결과를 담는 페이지 컨테이너 타입입니다.\n *\n * 페이지네이션 메타데이터와 함께 실제 데이터 목록(카테고리 배열)을 포함해, 목록 화면 및 검색 결과에서 활용합니다.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IPageICategory = {\n  /** 페이지네이션 정보로, 현재 페이지, 전체 레코드 수, 전체 페이지 수 등을 제공합니다. */\n  pagination: IPage.IPagination;\n\n  /** 카테고리 목록 데이터 배열입니다. */\n  data: ICategory[];\n};\n",
  "src/api/structures/IPageIPost.ts": "import { IPage } from \"./IPage\";\nimport { IPost } from \"./IPost\";\n\n/**\n * 게시글 검색/조회 결과를 담는 페이지 컨테이너 타입입니다.\n *\n * 페이지 정보와 게시글 배열을 함께 반환하여 결과 화면에서 활용합니다.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IPageIPost = {\n  /** 페이지네이션 메타데이터 */\n  pagination: IPage.IPagination;\n\n  /** 검색 결과 게시글(Posts) 배열 */\n  data: IPost[];\n};\n",
  "src/api/structures/IComment.ts": "import { tags } from \"typia\";\n\n/**\n * Represents a Comment record, as per the Posts domain comments model and\n * requirements analysis.\n *\n * Includes all primary properties as described in the Prisma schema, with full\n * typing and references to related entities (users, posts, parent comments).\n * Supports auditability, moderation, and business logic for threaded\n * conversations.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IComment = {\n  /**\n   * Primary Key. Unique identifier for each comment (see comments.id in\n   * schema).\n   *\n   * Assigned at creation; required for retrieval, update, and reference by\n   * other entities (votes, replies).\n   */\n  id: string & tags.Format<\"uuid\">;\n\n  /**\n   * Author's {@link users.id}.\n   *\n   * Stores the user's unique identifier responsible for the comment, using\n   * the relationship to users. Enables auditing, author lookup, and\n   * permissions checks.\n   */\n  user_id: string & tags.Format<\"uuid\">;\n\n  /**\n   * The ID of the post this comment is attached to ({@link posts.id}).\n   *\n   * Crucial for associating the comment as a reply to a given post,\n   * reflecting business rules and ERD documentation.\n   */\n  post_id: string & tags.Format<\"uuid\">;\n\n  /**\n   * Parent comment's {@link comments.id}.\n   *\n   * Used for nested (threaded) replies. Null for top-level comments. Enables\n   * tree-based conversations.\n   */\n  parent_id?: (string & tags.Format<\"uuid\">) | null;\n\n  /**\n   * Main text of the comment; user-provided reply content.\n   *\n   * References the comments.content field; holds message body visible to\n   * users.\n   */\n  content: string;\n\n  /**\n   * Timestamp when the comment was first authored (see comments.created_at).\n   *\n   * Used for chronological ordering, moderation, and audit.\n   */\n  created_at: string & tags.Format<\"date-time\">;\n\n  /**\n   * Timestamp of last edit to the comment (see comments.updated_at).\n   *\n   * Enables edit history, moderation, or user accountability.\n   */\n  updated_at: string & tags.Format<\"date-time\">;\n\n  /**\n   * Soft deletion timestamp (see comments.deleted_at).\n   *\n   * Null if not deleted; otherwise contains date/time when marked deleted for\n   * moderation/auditing.\n   */\n  deleted_at?: (string & tags.Format<\"date-time\">) | null;\n};\nexport namespace IComment {\n  /**\n   * Defines filtering, pagination, and sorting criteria for retrieving\n   * comments. Fields draw directly from the requirements and Prisma comments\n   * model.\n   *\n   * This allows filtering by comments made on a post, by a user, or as\n   * replies to a parent, along with keyword search and pagination. Reflects\n   * full API and business use cases for comment listing endpoints.\n   */\n  export type IRequest = {\n    /**\n     * The unique ID of the target post to which comments should be\n     * filtered.\n     *\n     * Based on the comments table, 'post_id' field links the comment to a\n     * particular post for thread-based filtering. Sourced from the business\n     * rule: 'Each Comment is linked to a Post.'\n     */\n    postId?: string & tags.Format<\"uuid\">;\n\n    /**\n     * The unique ID of the user who authored comments.\n     *\n     * Designed for filtering comments made by a specific user, as\n     * referenced in the comments.user_id column.\n     */\n    userId?: string & tags.Format<\"uuid\">;\n\n    /**\n     * The parent comment's ID, for retrieving or searching nested replies.\n     *\n     * This relates to the self-referential thread system: filtering for\n     * replies to a specific comment.\n     */\n    parentId?: (string & tags.Format<\"uuid\">) | null;\n\n    /**\n     * A keyword or phrase to search in comment content.\n     *\n     * Implements full-text search capability as referenced in content field\n     * and API description.\n     */\n    search?: string;\n\n    /**\n     * The starting index for pagination.\n     *\n     * Allows skipping records in list pagination, supporting usability in\n     * large thread navigation.\n     */\n    offset?: number &\n      tags.Type<\"int32\"> &\n      tags.Default<0> &\n      tags.JsonSchemaPlugin<{\n        format: \"int32\";\n      }>;\n\n    /**\n     * Maximum number of records to return per page. Defaults to 20 if not\n     * specified.\n     */\n    limit?: number &\n      tags.Type<\"int32\"> &\n      tags.Default<20> &\n      tags.JsonSchemaPlugin<{\n        format: \"int32\";\n      }>;\n\n    /**\n     * Sorting order or field, e.g., 'created_at:desc', 'created_at:asc'.\n     *\n     * Aligns with thread listing sorting as described in business and API\n     * requirements.\n     */\n    sort?: string;\n  };\n\n  /**\n   * Object for creating a new comment. Includes required properties for new\n   * replies, including references to post, author, and optionally a parent\n   * for nested threading. Matches business rules requiring each comment to\n   * have an associated user (author) and post, plus the option to nest under\n   * another comment.\n   */\n  export type ICreate = {\n    /**\n     * User ID (author's identifier). Must reference an existing user.\n     * Required to ensure only registered users may comment.\n     *\n     * Fulfills business rule that only registered users can create\n     * comments.\n     */\n    user_id: string & tags.Format<\"uuid\">;\n\n    /**\n     * ID of the post this comment is on. Implements business rule requiring\n     * every comment to be attached to a post.\n     */\n    post_id: string & tags.Format<\"uuid\">;\n\n    /**\n     * Parent comment's ID for nested replies. Optional. Enables thread\n     * hierarchy as in the business requirements.\n     */\n    parent_id?: (string & tags.Format<\"uuid\">) | null;\n\n    /**\n     * Main comment body text. Required; validated for length and content\n     * rules by business logic.\n     */\n    content: string;\n  };\n\n  /**\n   * Object for updating an existing comment (edit or soft-delete). User or\n   * moderator may use this to change content or to mark the comment as\n   * deleted.\n   *\n   * References the comments Prisma model and moderation business rules: only\n   * content or soft-delete flag is usually editable.\n   */\n  export type IUpdate = {\n    /**\n     * New comment body, if editing. Must meet length/content requirements\n     * from business logic.\n     */\n    content?: string;\n\n    /**\n     * Timestamp for marking a comment as deleted (for moderation/audit).\n     * Set to current time for 'soft delete,' or null to un-delete if\n     * allowed.\n     */\n    deleted_at?: (string & tags.Format<\"date-time\">) | null;\n  };\n\n  /**\n   * Result object for delete operations on comments. Confirms deletion (soft\n   * or hard), as required by business rules and audit requirements. Returns\n   * the comment ID, deletion status, and optional human-readable message.\n   */\n  export type IDeleteResult = {\n    /** ID of the comment that was deleted. */\n    id: string & tags.Format<\"uuid\">;\n\n    /**\n     * Status: true if successfully deleted (soft or hard as per policy),\n     * false otherwise.\n     */\n    deleted: boolean;\n\n    /** A confirmation or informative message about the deletion result. */\n    message?: string;\n  };\n\n  /**\n   * A concise summary type for comments, covering the most important\n   * references and metadata for paginated or overview lists.\n   */\n  export type ISummary = {\n    /** Unique identifier for the comment. */\n    id: string & tags.Format<\"uuid\">;\n\n    /** User (author) of the comment. */\n    user_id: string & tags.Format<\"uuid\">;\n\n    /** Parent post for the comment. */\n    post_id: string & tags.Format<\"uuid\">;\n\n    /** Parent comment (if any). */\n    parent_id?: (string & tags.Format<\"uuid\">) | null;\n\n    /** Timestamp of comment creation. */\n    created_at: string & tags.Format<\"date-time\">;\n  };\n}\n",
  "src/api/structures/IPageIComment.ts": "import { IPage } from \"./IPage\";\nimport { IComment } from \"./IComment\";\n\n/**\n * A paginated list of comment summaries, including pagination metadata (page,\n * limit, total, etc.) and a summary array.\n *\n * Combines IPage (standard) with IComment.ISummary as required by comment\n * browsing scenarios.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IPageIComment = {\n  pagination: IPage.IPagination;\n\n  /**\n   * A list of comment summary objects on the current page.\n   *\n   * Each item is a concise representation of a comment as described in\n   * business use-cases: post/reply thread listings.\n   */\n  data: IComment.ISummary[];\n};\n",
  "src/api/structures/IVote.ts": "import { tags } from \"typia\";\n\n/**\n * Represents a Vote as defined in the votes table: one record for each\n * upvote/downvote action on a post or comment. Covers voter ID, target (post or\n * comment), value (+1/-1), and creation timestamp. Fully aligned with\n * requirements analysis and business logic for\n * single-vote-per-user-per-content.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IVote = {\n  /** Primary Key. Unique identifier for each vote record (votes.id). */\n  id: string & tags.Format<\"uuid\">;\n\n  /**\n   * The ID of the user casting the vote (votes.user_id), referencing users\n   * table for author.\n   */\n  user_id: string & tags.Format<\"uuid\">;\n\n  /** The voted post's ID (votes.post_id). Mutually exclusive with comment_id. */\n  post_id?: (string & tags.Format<\"uuid\">) | null;\n\n  /**\n   * The voted comment's ID (votes.comment_id). Mutually exclusive with\n   * post_id.\n   */\n  comment_id?: (string & tags.Format<\"uuid\">) | null;\n\n  /**\n   * Value of the vote (+1 for upvote, -1 for downvote). Aggregated to compute\n   * content rankings.\n   */\n  value: number & tags.Type<\"int32\">;\n\n  /** Timestamp of when the vote was created (votes.created_at). */\n  created_at: string & tags.Format<\"date-time\">;\n};\nexport namespace IVote {\n  /**\n   * Filtering, pagination, and sorting criteria for votes listing requests,\n   * following the votes table business logic and related requirements.\n   *\n   * Filters support querying by voter, target post, or comment, with support\n   * for pagination and sorting. Business rules enforce only mutual\n   * exclusivity between postId/commentId (never both set).\n   */\n  export type IRequest = {\n    /**\n     * Unique identifier of the user who cast the vote. Used for filtering\n     * votes by a specific voter (see votes.user_id in schema and ERD).\n     */\n    userId?: string & tags.Format<\"uuid\">;\n\n    /**\n     * Unique identifier of the post that received the vote (see\n     * votes.post_id). Mutually exclusive with commentId.\n     */\n    postId?: (string & tags.Format<\"uuid\">) | null;\n\n    /**\n     * Unique identifier of the comment that received the vote (see\n     * votes.comment_id). Mutually exclusive with postId.\n     */\n    commentId?: (string & tags.Format<\"uuid\">) | null;\n\n    /** Starting index for pagination (default 0). */\n    offset?: number &\n      tags.Type<\"int32\"> &\n      tags.Default<0> &\n      tags.JsonSchemaPlugin<{\n        format: \"int32\";\n      }>;\n\n    /** Maximum number of records to return per page. */\n    limit?: number &\n      tags.Type<\"int32\"> &\n      tags.Default<20> &\n      tags.JsonSchemaPlugin<{\n        format: \"int32\";\n      }>;\n\n    /** Sorting field or order (default 'created_at:desc'). */\n    sort?: string;\n  };\n\n  /**\n   * Object for creating a new vote as per voting business rules:\n   *\n   * - User_id: registered voter\n   * - Value: +1 (upvote) or -1 (downvote)\n   * - Target: must specify either post_id or comment_id (never both) Enforces\n   *   one vote per user/content as described in requirements.\n   */\n  export type ICreate = {\n    /**\n     * ID of the user casting the vote. References the users table; ensures\n     * only registered users can vote.\n     */\n    user_id: string & tags.Format<\"uuid\">;\n\n    /**\n     * Vote value: +1 or -1 as per business requirements. Used for up/down\n     * voting of posts/comments.\n     */\n    value: number & tags.Type<\"int32\">;\n\n    /**\n     * Target post's ID, if voting on a post. Mutually exclusive with\n     * comment_id.\n     */\n    post_id?: (string & tags.Format<\"uuid\">) | null;\n\n    /**\n     * Target comment's ID, if voting on a comment. Mutually exclusive with\n     * post_id.\n     */\n    comment_id?: (string & tags.Format<\"uuid\">) | null;\n  };\n\n  /**\n   * Object for updating existing votes, specifically editing the vote value\n   * (from +1 to -1, etc.).\n   *\n   * Does not allow changing the vote target (post_id/comment_id); supports\n   * audit and business logic for corrections.\n   */\n  export type IUpdate = {\n    /**\n     * The new vote value. Allows changing an upvote to downvote (or vice\n     * versa), strictly for existing votes per business rules.\n     */\n    value: number & tags.Type<\"int32\">;\n  };\n\n  /**\n   * Delete operation result for a vote record. Returns deleted vote's ID,\n   * deletion status, and optional result message, as required by business\n   * logic and for user/admin confirmation.\n   */\n  export type IDeleteResult = {\n    /** ID of the vote record that was deleted. */\n    id: string & tags.Format<\"uuid\">;\n\n    /** Indicates if the vote was successfully deleted. */\n    deleted: boolean;\n\n    /** A human-readable confirmation message about the delete operation. */\n    message?: string;\n  };\n\n  /**\n   * Summary of a Vote for paginated/result lists, not including creation date\n   * but identifying all main relationships and value.\n   */\n  export type ISummary = {\n    /** Unique identifier for the vote. */\n    id: string & tags.Format<\"uuid\">;\n\n    /** Voter's user ID. */\n    user_id: string & tags.Format<\"uuid\">;\n\n    /** Target post. */\n    post_id?: (string & tags.Format<\"uuid\">) | null;\n\n    /** Target comment. */\n    comment_id?: (string & tags.Format<\"uuid\">) | null;\n\n    /** Vote value (+1 or -1). */\n    value: number & tags.Type<\"int32\">;\n  };\n}\n",
  "src/api/structures/IPageIVote.ts": "import { IPage } from \"./IPage\";\nimport { IVote } from \"./IVote\";\n\n/**\n * A paginated set of votes, as used in vote listing, audit history, or\n * analytics use-cases. Follows IPage pattern with IVote.ISummary records per\n * voting business and DB design.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IPageIVote = {\n  pagination: IPage.IPagination;\n\n  /** Array of vote summary records on this page. */\n  data: IVote.ISummary[];\n};\n",
  "src/api/functional/core/users/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IUser } from \"../../../structures/IUser\";\nimport { IPageIUser } from \"../../../structures/IPageIUser\";\n\n/**\n * Register a new user (core.users table).\n *\n * This operation handles new user registration or administrator-created user\n * accounts. It accepts all required and optional fields per the users model:\n * username, email, bio (optional), status, and an associated user_role_id.\n * Passwords are securely hashed before saving, never stored in plain text.\n *\n * Unique constraints are enforced for both username and email to prevent\n * duplicates. The user role must point to an existing role defined in\n * user_roles. Timestamps for creation and update are handled automatically.\n * Successful creation returns the newly registered user's public profile and\n * role association (never the password hash).\n *\n * Security and validation reflect business rules, e.g., email visibility,\n * profile privacy, and initial status setting. Input errors or duplicates\n * return clear messages and codes. Related endpoints: list (PATCH), read (GET),\n * update (PUT), delete (DELETE).\n *\n * @param props.body Registration info for the new user, including username,\n *   email, password, user role, etc.\n * @path /core/users\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function post(\n  connection: IConnection,\n  props: post.Props,\n): Promise<post.Response> {\n  return !!connection.simulate\n    ? post.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...post.METADATA,\n          path: post.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace post {\n  export type Props = {\n    /**\n     * Registration info for the new user, including username, email,\n     * password, user role, etc.\n     */\n    body: IUser.ICreate;\n  };\n  export type Body = IUser.ICreate;\n  export type Response = IUser;\n\n  export const METADATA = {\n    method: \"POST\",\n    path: \"/core/users\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/core/users\";\n  export const random = (g?: Partial<typia.IRandomGenerator>): IUser =>\n    typia.random<IUser>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: post.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: post.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Retrieve a paginated, filterable list of users (core.users table).\n *\n * This operation returns a paginated and filtered list of users registered on\n * the discussion board. Users may be searched by username, email, user role, or\n * status, and results are sorted and paginated according to the provided\n * parameters. The endpoint refers to the users table, whose structure includes\n * fields for username, email, bio, role reference, password hash, timestamps,\n * and status. Filters can help administrators or moderators locate specific\n * accounts, monitor new signups, or audit activity. Security is enforced: only\n * users with moderator or administrator roles can access or use advanced\n * filters.\n *\n * The endpoint applies business rules from the requirements, such as hiding\n * sensitive (e.g., password) information, and supports relations to user_roles\n * for displaying or filtering by user type. Pagination and sorting follow best\n * practices for usability and performance. Related endpoints: create (POST),\n * retrieve detail (GET), update (PUT), and delete (DELETE) for users.\n *\n * Error handling ensures invalid queries, unauthorized access, or database\n * issues are managed gracefully, returning clear status codes and messages.\n * Sensitive data, such as password hashes, is never included in responses.\n *\n * @param props.body Filtering, sorting, and pagination info for user listing\n *   request.\n * @path /core/users\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patch(\n  connection: IConnection,\n  props: patch.Props,\n): Promise<patch.Response> {\n  return !!connection.simulate\n    ? patch.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patch.METADATA,\n          path: patch.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace patch {\n  export type Props = {\n    /** Filtering, sorting, and pagination info for user listing request. */\n    body: IUser.IRequest;\n  };\n  export type Body = IUser.IRequest;\n  export type Response = IPageIUser.ISummary;\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/core/users\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/core/users\";\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IPageIUser.ISummary => typia.random<IPageIUser.ISummary>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: patch.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patch.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Retrieve detailed profile info for a specific user (core.users table).\n *\n * This operation retrieves the full profile and related information for a\n * specific user, identified by their unique user ID. Fields returned follow the\n * schema comments: username, email, bio, status, timestamps, and a reference to\n * their user role. User roles are resolved to human-readable labels where\n * appropriate.\n *\n * Sensitive fields such as password_hash are never returned. This endpoint is\n * typically used by administrators for user management, or by users to view\n * their own account details. Where authorized, moderators may use this endpoint\n * for resolving moderation cases or audits. The data aligns exactly with the\n * users table comments and model.\n *\n * Related endpoints include listing (PATCH), creation (POST), update (PUT), and\n * deletion (DELETE) for users. Error handling covers not found, unauthorized,\n * or forbidden cases, always giving appropriate error codes and minimal leak of\n * protected info.\n *\n * @param props.id Target user's ID (UUID).\n * @path /core/users/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getById(\n  connection: IConnection,\n  props: getById.Props,\n): Promise<getById.Response> {\n  return !!connection.simulate\n    ? getById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getById.METADATA,\n          path: getById.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace getById {\n  export type Props = {\n    /** Target user's ID (UUID). */\n    id: string & tags.Format<\"uuid\">;\n  };\n  export type Response = IUser;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/core/users/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/core/users/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): IUser =>\n    typia.random<IUser>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: getById.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Update user profile and account fields (core.users table).\n *\n * Updates an existing user's information, addressing fields in the users\n * schema, such as username, email, bio, role, status, and update timestamp. The\n * input must include the user ID and only permitted fields are updateable.\n * Username/email uniqueness is enforced on update as well.\n * Moderators/administrators can change roles/statuses as permitted by business\n * rules.\n *\n * The request never allows direct password updates (managed by a separate\n * dedicated endpoint, or by password reset process for security). All change\n * history is reflected in the updated_at timestamp. Security measures prevent\n * users from editing others' profiles unless authorized; self-edits are limited\n * to certain fields.\n *\n * Related endpoints: detail (GET), list (PATCH), create (POST), delete\n * (DELETE). Strict validation and business rule application ensure stability\n * and data quality.\n *\n * @param props.id Target user's ID (UUID).\n * @param props.body Editable fields for user update, such as profile details or\n *   status/role changes (excludes password updates).\n * @path /core/users/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function putById(\n  connection: IConnection,\n  props: putById.Props,\n): Promise<putById.Response> {\n  return !!connection.simulate\n    ? putById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...putById.METADATA,\n          path: putById.path(props),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace putById {\n  export type Props = {\n    /** Target user's ID (UUID). */\n    id: string & tags.Format<\"uuid\">;\n\n    /**\n     * Editable fields for user update, such as profile details or\n     * status/role changes (excludes password updates).\n     */\n    body: IUser.IUpdate;\n  };\n  export type Body = IUser.IUpdate;\n  export type Response = IUser;\n\n  export const METADATA = {\n    method: \"PUT\",\n    path: \"/core/users/:id\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Omit<Props, \"body\">) =>\n    `/core/users/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): IUser =>\n    typia.random<IUser>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: putById.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: putById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Softly or fully delete a user (core.users table).\n *\n * Deletes a user account with the specified ID. This typically marks the user's\n * status as deleted or suspended and/or sets a deletion flag in audit fields,\n * per the users Prisma schema and moderation rules. Associated content (posts,\n * comments, votes) may be retained for community reference, moderation, or\n * audit logs, as described in requirements.\n *\n * Only administrators may perform this action, and a detailed audit trail is\n * kept. Related endpoints are used for restoration or final hard-delete (if\n * policy allows). Errors for not found or forbidden actions are handled\n * appropriately; sensitive information on deleted users is not exposed.\n *\n * @param props.id Target user's ID (UUID).\n * @path /core/users/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function eraseById(\n  connection: IConnection,\n  props: eraseById.Props,\n): Promise<eraseById.Response> {\n  return !!connection.simulate\n    ? eraseById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...eraseById.METADATA,\n          path: eraseById.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace eraseById {\n  export type Props = {\n    /** Target user's ID (UUID). */\n    id: string & tags.Format<\"uuid\">;\n  };\n  export type Response = IUser.IDeleteResponse;\n\n  export const METADATA = {\n    method: \"DELETE\",\n    path: \"/core/users/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/core/users/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IUser.IDeleteResponse => typia.random<IUser.IDeleteResponse>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: eraseById.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: eraseById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/core/index.ts": "export * as users from \"./users\";\nexport * as userRoles from \"./userRoles\";\nexport * as categories from \"./categories\";\n",
  "src/api/functional/index.ts": "export * as core from \"./core\";\nexport * as posts from \"./posts\";\nexport * as votes from \"./votes\";\n",
  "src/api/functional/core/userRoles/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IUserRole } from \"../../../structures/IUserRole\";\nimport { IPageIUserRole } from \"../../../structures/IPageIUserRole\";\n\n/**\n * Create a new user role (core.userRoles table).\n *\n * Creates a new user role based on the schema structure, with fields for name\n * (label) and description. Enforces the uniqueness of the role name and ensures\n * all required information is provided, following the comments and requirements\n * detailed in the Prisma schema.\n *\n * Intended for administrator setup or customization of new permission levels.\n * Errors are sent in case of duplicate names, missing fields, or insufficient\n * permissions. Successful creation returns the new user role record, suitable\n * for immediate assignment to users.\n *\n * Related endpoints: list (PATCH), single GET, update (PUT), and delete\n * (DELETE) for user roles.\n *\n * @param props.body New user role details, including name and description.\n * @path /core/userRoles\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function post(\n  connection: IConnection,\n  props: post.Props,\n): Promise<post.Response> {\n  return !!connection.simulate\n    ? post.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...post.METADATA,\n          path: post.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace post {\n  export type Props = {\n    /** New user role details, including name and description. */\n    body: IUserRole.ICreate;\n  };\n  export type Body = IUserRole.ICreate;\n  export type Response = IUserRole;\n\n  export const METADATA = {\n    method: \"POST\",\n    path: \"/core/userRoles\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/core/userRoles\";\n  export const random = (g?: Partial<typia.IRandomGenerator>): IUserRole =>\n    typia.random<IUserRole>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: post.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: post.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * List and filter user roles (core.userRoles table).\n *\n * This operation returns a paginated list of user roles available to assign, as\n * defined by the user_roles model. Roles govern permissions across the board\n * (e.g., member, moderator, administrator). Designed for use in registration\n * processes, admin dashboards, or role management panels, enabling filtering by\n * role name or description and ordering of results.\n *\n * Data returned is defined strictly by the Prisma model and schema comments.\n * This operation is auditable and respects business constraints on who may\n * view/assign roles. Related endpoints: single role GET, create (POST), update\n * (PUT), and delete (DELETE).\n *\n * Error cases (e.g., forbidden access) are handled with appropriate status\n * codes. Pagination and search parameters maximize usability and efficiency,\n * especially for large deployments with custom roles.\n *\n * @param props.body Filter, search, and pagination info for user roles listing.\n * @path /core/userRoles\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patch(\n  connection: IConnection,\n  props: patch.Props,\n): Promise<patch.Response> {\n  return !!connection.simulate\n    ? patch.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patch.METADATA,\n          path: patch.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace patch {\n  export type Props = {\n    /** Filter, search, and pagination info for user roles listing. */\n    body: IUserRole.IRequest;\n  };\n  export type Body = IUserRole.IRequest;\n  export type Response = IPageIUserRole;\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/core/userRoles\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/core/userRoles\";\n  export const random = (g?: Partial<typia.IRandomGenerator>): IPageIUserRole =>\n    typia.random<IPageIUserRole>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: patch.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patch.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Get a single user role's details (core.userRoles table).\n *\n * Retrieves all details for a single user role, specified by ID. Used in admin\n * panels to display all properties of a role, or in account registration to\n * inform users about the meaning and permissions of each role (as described in\n * schema comments: name, description, etc).\n *\n * Respects all business rules regarding role assignment and application.\n * Related endpoints: list (PATCH), creation (POST), update (PUT), delete\n * (DELETE). Errors for missing roles or unauthorized actions are handled\n * gracefully, with clear messaging.\n *\n * @param props.id Target role's ID (UUID).\n * @path /core/userRoles/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getById(\n  connection: IConnection,\n  props: getById.Props,\n): Promise<getById.Response> {\n  return !!connection.simulate\n    ? getById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getById.METADATA,\n          path: getById.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace getById {\n  export type Props = {\n    /** Target role's ID (UUID). */\n    id: string & tags.Format<\"uuid\">;\n  };\n  export type Response = IUserRole;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/core/userRoles/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/core/userRoles/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): IUserRole =>\n    typia.random<IUserRole>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: getById.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Edit label/description for a user role (core.userRoles table).\n *\n * Updates an existing user role's properties (name and/or description).\n * Uniqueness of the name is enforced by Prisma schema rules. Typical in systems\n * where additional roles/policies are introduced or for correcting role\n * definitions.\n *\n * Only administrators are permitted to update roles. Change history is tracked\n * and any update is reflected in audit fields. Related endpoints: detail GET,\n * list PATCH, creation POST, and deletion DELETE for user roles.\n *\n * Any errors due to duplicates, forbidden edits, or missing records generate\n * suitable error codes in response. Endpoint matches structure and intentions\n * described in requirements and schema comments.\n *\n * @param props.id Target role's ID (UUID).\n * @param props.body New values for user role fields (name/description).\n * @path /core/userRoles/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function putById(\n  connection: IConnection,\n  props: putById.Props,\n): Promise<putById.Response> {\n  return !!connection.simulate\n    ? putById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...putById.METADATA,\n          path: putById.path(props),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace putById {\n  export type Props = {\n    /** Target role's ID (UUID). */\n    id: string & tags.Format<\"uuid\">;\n\n    /** New values for user role fields (name/description). */\n    body: IUserRole.IUpdate;\n  };\n  export type Body = IUserRole.IUpdate;\n  export type Response = IUserRole;\n\n  export const METADATA = {\n    method: \"PUT\",\n    path: \"/core/userRoles/:id\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Omit<Props, \"body\">) =>\n    `/core/userRoles/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): IUserRole =>\n    typia.random<IUserRole>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: putById.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: putById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Delete a user role from the system (core.userRoles table).\n *\n * Deletes a user role identified by its ID. Enforces business and schema rules\n * about which roles can be deleted (e.g., prevents deletion of critical roles\n * if protected by business logic). If the role is in use (referenced by users),\n * operation will fail with a clear error message.\n *\n * Administrative rights are required. Detailed audit trails are maintained for\n * changes. Related endpoints: create (POST), list (PATCH), update (PUT), detail\n * (GET). All operations match Prisma schema and requirements. Appropriate\n * handling is provided for not found, forbidden, or dependency errors.\n *\n * @param props.id Target role's ID (UUID).\n * @path /core/userRoles/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function eraseById(\n  connection: IConnection,\n  props: eraseById.Props,\n): Promise<eraseById.Response> {\n  return !!connection.simulate\n    ? eraseById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...eraseById.METADATA,\n          path: eraseById.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace eraseById {\n  export type Props = {\n    /** Target role's ID (UUID). */\n    id: string & tags.Format<\"uuid\">;\n  };\n  export type Response = IUserRole.IDeleteResponse;\n\n  export const METADATA = {\n    method: \"DELETE\",\n    path: \"/core/userRoles/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/core/userRoles/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IUserRole.IDeleteResponse => typia.random<IUserRole.IDeleteResponse>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: eraseById.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: eraseById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/core/categories/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { ICategory } from \"../../../structures/ICategory\";\nimport { IPageICategory } from \"../../../structures/IPageICategory\";\n\n/**\n * Create new category (Core.categories).\n *\n * Allows creation of a new category topic for the discussion board, by\n * inserting a new record into the 'categories' table in the database. The\n * provided name must be unique among all categories. Description field gives\n * users context. Only authorized users (administrators) are permitted to\n * execute this operation.\n *\n * Input validation includes ensuring that required fields are present, name\n * does not duplicate existing entries, and description respects length/content\n * rules. On success, the new category is created and returned with full detail\n * including its assigned UUID and creation timestamp.\n *\n * Error handling covers invalid parameters, uniqueness violations, or\n * insufficient permissions.\n *\n * Related endpoints: list/search (PATCH), get (GET), update (PUT), and delete\n * (DELETE) for categories.\n *\n * @param props.body Data for new category including unique name and\n *   description.\n * @path /core/categories\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function post(\n  connection: IConnection,\n  props: post.Props,\n): Promise<post.Response> {\n  return !!connection.simulate\n    ? post.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...post.METADATA,\n          path: post.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace post {\n  export type Props = {\n    /** Data for new category including unique name and description. */\n    body: ICategory.ICreate;\n  };\n  export type Body = ICategory.ICreate;\n  export type Response = ICategory;\n\n  export const METADATA = {\n    method: \"POST\",\n    path: \"/core/categories\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/core/categories\";\n  export const random = (g?: Partial<typia.IRandomGenerator>): ICategory =>\n    typia.random<ICategory>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: post.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: post.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * List and search categories (Core.categories).\n *\n * This API operation returns a list of categories, leveraging the 'categories'\n * table from the database.\n *\n * The response is paginated and may be filtered based on optional query\n * parameters such as name, partial matches in description, or created_at\n * window. Secure endpoints may restrict certain filters or result fields to\n * administrators. The main purpose is to allow users to browse or search\n * available discussion categories for post assignment or exploration.\n *\n * Security: Some filtering/search options may be restricted to users with\n * elevated roles, such as administrators or moderators. Regular users typically\n * see all active categories only.\n *\n * This endpoint is commonly used in category selection modals, administrative\n * dashboards, and on board homepages. Validation ensures page and pageSize are\n * non-negative, and sortBy field must match a valid column. Error handling will\n * return informative failures for invalid filter parameters or database\n * errors.\n *\n * This operation is related to single-category get, create, update, and delete\n * operations, and in large systems may be supplemented by category\n * suggestion/approval flows.\n *\n * @param props.body Search criteria, pagination, and sorting parameters for\n *   categories list query.\n * @path /core/categories\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patch(\n  connection: IConnection,\n  props: patch.Props,\n): Promise<patch.Response> {\n  return !!connection.simulate\n    ? patch.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patch.METADATA,\n          path: patch.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace patch {\n  export type Props = {\n    /**\n     * Search criteria, pagination, and sorting parameters for categories\n     * list query.\n     */\n    body: ICategory.IRequest;\n  };\n  export type Body = ICategory.IRequest;\n  export type Response = IPageICategory;\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/core/categories\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/core/categories\";\n  export const random = (g?: Partial<typia.IRandomGenerator>): IPageICategory =>\n    typia.random<IPageICategory>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: patch.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patch.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Retrieve specific category by ID (Core.categories).\n *\n * Retrieves category information for the specified ID from the 'categories'\n * table, including name, description, creation timestamp, and potentially\n * related post count or status if extended.\n *\n * If the category does not exist, the API returns a clear error message. Access\n * policies determine visibility of archived or deactivated categories—regular\n * users can only view active categories, while admins may retrieve all states.\n *\n * This endpoint is essential for screens displaying category details prior to\n * editing/deleting, or for referencing during post creation/editing workflows.\n * Includes validation of the UUID path parameter. Returns 404 if not found or\n * permission denied.\n *\n * Related endpoints: categories list/search (PATCH), create (POST), update\n * (PUT), and delete (DELETE).\n *\n * @param props.id Unique ID of the target category\n * @path /core/categories/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getById(\n  connection: IConnection,\n  props: getById.Props,\n): Promise<getById.Response> {\n  return !!connection.simulate\n    ? getById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getById.METADATA,\n          path: getById.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace getById {\n  export type Props = {\n    /** Unique ID of the target category */\n    id: string & tags.Format<\"uuid\">;\n  };\n  export type Response = ICategory;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/core/categories/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/core/categories/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): ICategory =>\n    typia.random<ICategory>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: getById.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Update a category by ID (Core.categories).\n *\n * Updates an existing category's name or description by changing the relevant\n * fields in the 'categories' table. The category is referenced by its unique\n * UUID path parameter, and the body provides updated data.\n *\n * This operation may only be performed by users with appropriate administrative\n * roles. Validation checks include verifying that the new category name does\n * not duplicate any other categories and that all required fields meet\n * formatting rules.\n *\n * Partial or full updates are supported; fields not included may retain their\n * current values. Business rules may restrict changes if the category is\n * currently associated with posts. On success, the full updated category\n * information is returned.\n *\n * Error handling includes failing if the category does not exist, trying to use\n * a duplicate name, or lacking sufficient rights. Related operations: get,\n * create, delete, and list/search categories.\n *\n * @param props.id Unique ID of the target category\n * @param props.body Updated name and/or description for the category.\n * @path /core/categories/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function putById(\n  connection: IConnection,\n  props: putById.Props,\n): Promise<putById.Response> {\n  return !!connection.simulate\n    ? putById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...putById.METADATA,\n          path: putById.path(props),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace putById {\n  export type Props = {\n    /** Unique ID of the target category */\n    id: string & tags.Format<\"uuid\">;\n\n    /** Updated name and/or description for the category. */\n    body: ICategory.IUpdate;\n  };\n  export type Body = ICategory.IUpdate;\n  export type Response = ICategory;\n\n  export const METADATA = {\n    method: \"PUT\",\n    path: \"/core/categories/:id\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Omit<Props, \"body\">) =>\n    `/core/categories/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): ICategory =>\n    typia.random<ICategory>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: putById.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: putById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Delete a category by ID (Core.categories).\n *\n * Deletes (or marks as deleted) a category based on its unique ID. This\n * operation usually employs soft-deletion: the category is flagged so it no\n * longer appears in lists or selection menus, but remains in the database for\n * historical tracking and audit purposes. Some implementations may require hard\n * deletion if the category has no posts attached.\n *\n * Permission to use this operation is typically restricted to administrators.\n * Attempts to delete active categories in use by posts may be rejected or\n * require confirmation. All deletion attempts are logged for audit.\n *\n * Error cases include non-existent category ID, attempts to delete categories\n * linked to live posts, or insufficient permissions. Related endpoints: create,\n * get, update, and list/search categories.\n *\n * @param props.id Unique ID of the target category\n * @path /core/categories/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function eraseById(\n  connection: IConnection,\n  props: eraseById.Props,\n): Promise<eraseById.Response> {\n  return !!connection.simulate\n    ? eraseById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...eraseById.METADATA,\n          path: eraseById.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace eraseById {\n  export type Props = {\n    /** Unique ID of the target category */\n    id: string & tags.Format<\"uuid\">;\n  };\n  export type Response = ICategory.IDeleteResult;\n\n  export const METADATA = {\n    method: \"DELETE\",\n    path: \"/core/categories/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/core/categories/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): ICategory.IDeleteResult => typia.random<ICategory.IDeleteResult>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: eraseById.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: eraseById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/posts/posts/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IPost } from \"../../../structures/IPost\";\nimport { IPageIPost } from \"../../../structures/IPageIPost\";\n\n/**\n * Create a new post (Posts.posts).\n *\n * Allows a user to create a new post by providing required information such as\n * category, title, and content. The new post is assigned to the authoring user\n * and is inserted into the database. Creation may be subject to moderation or\n * review depending on platform policies.\n *\n * Input validation includes ensuring a valid category reference, unique/valid\n * title, and legitimate content (length, formatting). On success, the API\n * returns the full details of the created post, including assigned UUID,\n * timestamps, and author/category references.\n *\n * Error cases include missing/invalid data, attempts to create a post in\n * non-existent category, or by unauthorized/blocked users. Related endpoints:\n * list/search (PATCH), get (GET), update (PUT), delete (DELETE); plus comment\n * APIs.\n *\n * @param props.body All information required for new post: categoryId, title,\n *   content.\n * @path /posts/posts\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function post(\n  connection: IConnection,\n  props: post.Props,\n): Promise<post.Response> {\n  return !!connection.simulate\n    ? post.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...post.METADATA,\n          path: post.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace post {\n  export type Props = {\n    /** All information required for new post: categoryId, title, content. */\n    body: IPost.ICreate;\n  };\n  export type Body = IPost.ICreate;\n  export type Response = IPost;\n\n  export const METADATA = {\n    method: \"POST\",\n    path: \"/posts/posts\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/posts/posts\";\n  export const random = (g?: Partial<typia.IRandomGenerator>): IPost =>\n    typia.random<IPost>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: post.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: post.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * List and search posts (Posts.posts).\n *\n * This API operation returns a list of posts (discussion threads or articles)\n * with full support for filtering by category, author, or keywords, as well as\n * sorting and pagination. Non-admin users typically see only non-deleted,\n * non-archived posts, while administrators may have visibility into all post\n * states. Standard search validation is performed for page, pageSize, and sort\n * field inputs.\n *\n * The endpoint supports community browsing, category threads, author-centric\n * feeds, and search result pages. It also includes support for keyword-based\n * full-text search on titles and content. Additional metadata such as comment\n * and vote counts may be included per business requirements. Error handling\n * addresses invalid filters, missing results, or backend errors.\n *\n * Related to post retrieval (GET), post creation (POST), update (PUT), and\n * delete (DELETE) endpoints, as well as comment and vote-related APIs.\n *\n * @param props.body Criteria for searching, paging, and sorting posts.\n * @path /posts/posts\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patch(\n  connection: IConnection,\n  props: patch.Props,\n): Promise<patch.Response> {\n  return !!connection.simulate\n    ? patch.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patch.METADATA,\n          path: patch.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace patch {\n  export type Props = {\n    /** Criteria for searching, paging, and sorting posts. */\n    body: IPost.IRequest;\n  };\n  export type Body = IPost.IRequest;\n  export type Response = IPageIPost;\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/posts/posts\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/posts/posts\";\n  export const random = (g?: Partial<typia.IRandomGenerator>): IPageIPost =>\n    typia.random<IPageIPost>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: patch.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patch.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Retrieve specific post by ID (Posts.posts).\n *\n * Retrieves full details of a single post, identified by its unique ID. Returns\n * all fields visible to the viewing user, such as title, content, author\n * reference, category reference, creation and update times, etc. Admin users\n * may access deleted posts if required, while normal users only see active\n * posts.\n *\n * This API is the primary source of detail for displaying or editing a\n * discussion post. It validates the UUID input, and returns a 404 or permission\n * error if the post does not exist or the user lacks rights.\n *\n * Related endpoints: post list/search (PATCH), create (POST), update (PUT),\n * delete (DELETE). Also supports comment and voting APIs.\n *\n * @param props.id Unique ID of the target post\n * @path /posts/posts/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getById(\n  connection: IConnection,\n  props: getById.Props,\n): Promise<getById.Response> {\n  return !!connection.simulate\n    ? getById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getById.METADATA,\n          path: getById.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace getById {\n  export type Props = {\n    /** Unique ID of the target post */\n    id: string & tags.Format<\"uuid\">;\n  };\n  export type Response = IPost;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/posts/posts/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/posts/posts/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): IPost =>\n    typia.random<IPost>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: getById.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Update a post by ID (Posts.posts).\n *\n * Updates an existing post, referenced by its unique ID. Input may update\n * title, content, and/or category reference. Only the author or an\n * administrator/moderator may perform this operation. All updates are validated\n * for required structure, content, and permission.\n *\n * Partial updates retain other fields unchanged. History tracking is enabled\n * via timestamps. Changing category may have restrictions if the post has live\n * comments. On success, returns updated post data; on failure, returns\n * validation or permission errors.\n *\n * Related endpoints: get, list/search, create, delete for posts. This endpoint\n * supports editing discussion threads after posting.\n *\n * @param props.id Unique ID of the target post\n * @param props.body Fields to update for post (title, content, category).\n * @path /posts/posts/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function putById(\n  connection: IConnection,\n  props: putById.Props,\n): Promise<putById.Response> {\n  return !!connection.simulate\n    ? putById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...putById.METADATA,\n          path: putById.path(props),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace putById {\n  export type Props = {\n    /** Unique ID of the target post */\n    id: string & tags.Format<\"uuid\">;\n\n    /** Fields to update for post (title, content, category). */\n    body: IPost.IUpdate;\n  };\n  export type Body = IPost.IUpdate;\n  export type Response = IPost;\n\n  export const METADATA = {\n    method: \"PUT\",\n    path: \"/posts/posts/:id\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Omit<Props, \"body\">) =>\n    `/posts/posts/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): IPost =>\n    typia.random<IPost>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: putById.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: putById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Delete a post by ID (Posts.posts).\n *\n * Deletes (or marks as deleted) a post record by its ID. Standard\n * implementation is soft-deletion: post remains in database for moderation and\n * audit but is removed from normal views and feeds. Only the original author,\n * admin, or moderator can perform deletion. Attempts to delete posts with\n * active comments or votes may be subject to business rule restrictions or\n * warnings.\n *\n * All delete actions are logged. The response provides confirmation or error.\n * Related endpoints: create, get, update, and list/search for posts. Deletion\n * cascades may apply to comments and votes as policy dictates.\n *\n * @param props.id Unique ID of the target post\n * @path /posts/posts/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function eraseById(\n  connection: IConnection,\n  props: eraseById.Props,\n): Promise<eraseById.Response> {\n  return !!connection.simulate\n    ? eraseById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...eraseById.METADATA,\n          path: eraseById.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace eraseById {\n  export type Props = {\n    /** Unique ID of the target post */\n    id: string & tags.Format<\"uuid\">;\n  };\n  export type Response = IPost.IDeleteResult;\n\n  export const METADATA = {\n    method: \"DELETE\",\n    path: \"/posts/posts/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/posts/posts/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IPost.IDeleteResult => typia.random<IPost.IDeleteResult>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: eraseById.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: eraseById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/posts/index.ts": "export * as posts from \"./posts\";\nexport * as comments from \"./comments\";\n",
  "src/api/functional/posts/comments/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IComment } from \"../../../structures/IComment\";\nimport { IPageIComment } from \"../../../structures/IPageIComment\";\n\n/**\n * Create a new comment (Posts domain, 'comments' table).\n *\n * This API lets a registered user create a new comment (either as a direct\n * reply to a post or as a nested reply to another comment). Necessary fields\n * include the content, target postId, and optionally a parentId (for\n * replies-to-replies).\n *\n * Input is validated for minimum/maximum length, appropriate content, and\n * ensuring the parent exists and belongs to the same post. The endpoint checks\n * author authentication and standard anti-abuse policies (e.g., rate limiting).\n * On success, it returns the created comment record with all metadata (author,\n * timestamp, etc.).\n *\n * Business logic from the 'comments' table (Posts domain) is implemented: only\n * registered users may comment; soft deletion rules apply. Related endpoints:\n * retrieval (GET /posts/comments/{id}), update (PUT /posts/comments/{id}), and\n * listing (PATCH /posts/comments).\n *\n * @param props.body New comment data, including content, postId, and optional\n *   parentId.\n * @path /posts/comments\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function post(\n  connection: IConnection,\n  props: post.Props,\n): Promise<post.Response> {\n  return !!connection.simulate\n    ? post.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...post.METADATA,\n          path: post.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace post {\n  export type Props = {\n    /** New comment data, including content, postId, and optional parentId. */\n    body: IComment.ICreate;\n  };\n  export type Body = IComment.ICreate;\n  export type Response = IComment;\n\n  export const METADATA = {\n    method: \"POST\",\n    path: \"/posts/comments\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/posts/comments\";\n  export const random = (g?: Partial<typia.IRandomGenerator>): IComment =>\n    typia.random<IComment>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: post.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: post.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Retrieve a filtered, paginated list of comments (Posts domain, 'comments'\n * table).\n *\n * This API retrieves a paged list of comments from the discussion board.\n * Typically, users or moderators use it to see all comments on a specific\n * thread, all comments by a particular user, or to moderate recent activity.\n *\n * The route supports filtering (e.g., by postId, userId, parentId), pagination\n * (offset/limit), full-text search on comment content, and sorting (e.g.,\n * newest first). Security considerations include only exposing non-deleted\n * comments by default, unless requested by a privileged moderator/admin.\n * Comment content is filtered to remove inappropriate language if the requester\n * has insufficient privileges.\n *\n * It references the 'comments' table (Posts domain). Query performance is\n * optimized via relevant indexes. Related APIs include: create (POST\n * /posts/comments), update (PUT /posts/comments/{id}), retrieve detail (GET\n * /posts/comments/{id}), and delete (DELETE /posts/comments/{id}).\n *\n * Input validation includes correct types for filters, max page size, and valid\n * sort orders. Error handling covers unauthorized access, malformed filters,\n * and nonexistent references.\n *\n * @param props.body Defines filtering, pagination, and sorting criteria for\n *   retrieving comments. Fields may include postId, userId, parentId, search,\n *   offset, limit, and sort.\n * @path /posts/comments\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patch(\n  connection: IConnection,\n  props: patch.Props,\n): Promise<patch.Response> {\n  return !!connection.simulate\n    ? patch.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patch.METADATA,\n          path: patch.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace patch {\n  export type Props = {\n    /**\n     * Defines filtering, pagination, and sorting criteria for retrieving\n     * comments. Fields may include postId, userId, parentId, search,\n     * offset, limit, and sort.\n     */\n    body: IComment.IRequest;\n  };\n  export type Body = IComment.IRequest;\n  export type Response = IPageIComment;\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/posts/comments\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/posts/comments\";\n  export const random = (g?: Partial<typia.IRandomGenerator>): IPageIComment =>\n    typia.random<IPageIComment>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: patch.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patch.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Fetch detailed information about a single comment (Posts domain, 'comments'\n * table).\n *\n * This API fetches the detail of a single comment in the discussion board by\n * its unique ID. Common scenarios include users viewing a nested reply,\n * moderators inspecting a reported comment, or when displaying a comment in\n * thread view.\n *\n * It returns full details such as content, author, timestamps, post reference,\n * parent comment reference, and vote tallies. The route references the\n * 'comments' table (Posts domain) and is optimized for quick retrieval. It will\n * not return comments marked as deleted unless accessed by a user with\n * sufficient privileges (e.g., moderator or admin).\n *\n * Error handling includes returning appropriate errors for nonexistent,\n * deleted, or unauthorized access. Related APIs: listing (PATCH\n * /posts/comments), update (PUT /posts/comments/{id}), creation (POST\n * /posts/comments), and deletion (DELETE /posts/comments/{id}).\n *\n * @param props.id Target comment's ID\n * @path /posts/comments/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getById(\n  connection: IConnection,\n  props: getById.Props,\n): Promise<getById.Response> {\n  return !!connection.simulate\n    ? getById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getById.METADATA,\n          path: getById.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace getById {\n  export type Props = {\n    /** Target comment's ID */\n    id: string & tags.Format<\"uuid\">;\n  };\n  export type Response = IComment;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/posts/comments/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/posts/comments/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): IComment =>\n    typia.random<IComment>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: getById.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Update an existing comment's content or deletion status (Posts domain,\n * 'comments' table).\n *\n * This API allows an authorized user (typically the comment's original author\n * or a moderator/admin) to update the content or status of a comment. Supported\n * fields for update include content (for editing), and soft deletion flag.\n *\n * Checks include author authentication, edit time-window (if enforced by\n * policy), and protection against editing after moderation/deletion. Input\n * validation ensures updated content meets platform standards, and references\n * are unaltered (cannot change post or parentId).\n *\n * The endpoint references the 'comments' table (Posts domain). On success,\n * returns the updated comment object. Error scenarios include not found,\n * unauthorized modification, or invalid updates. Related APIs: create (POST\n * /posts/comments), retrieve (GET /posts/comments/{id}), delete (DELETE\n * /posts/comments/{id}).\n *\n * @param props.id The target comment's ID to update\n * @param props.body Fields to update in the comment (content and/or soft\n *   delete).\n * @path /posts/comments/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function putById(\n  connection: IConnection,\n  props: putById.Props,\n): Promise<putById.Response> {\n  return !!connection.simulate\n    ? putById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...putById.METADATA,\n          path: putById.path(props),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace putById {\n  export type Props = {\n    /** The target comment's ID to update */\n    id: string & tags.Format<\"uuid\">;\n\n    /** Fields to update in the comment (content and/or soft delete). */\n    body: IComment.IUpdate;\n  };\n  export type Body = IComment.IUpdate;\n  export type Response = IComment;\n\n  export const METADATA = {\n    method: \"PUT\",\n    path: \"/posts/comments/:id\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Omit<Props, \"body\">) =>\n    `/posts/comments/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): IComment =>\n    typia.random<IComment>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: putById.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: putById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Soft-delete a comment (Posts domain, 'comments' table).\n *\n * This API performs a soft deletion (marks as deleted) of a comment identified\n * by its ID. Typical scenarios: the comment's author chooses to remove their\n * reply, or a moderator removes content that violates policy. The comment\n * remains in the database (for auditability), but becomes invisible to regular\n * users and excluded from normal listings.\n *\n * Authorization checks enforce only the author, moderator, or admin can perform\n * this. Related error handling includes not found, already deleted, and\n * unauthorized access. Audit logs are typically recorded. Related endpoints:\n * create (POST /posts/comments), update (PUT /posts/comments/{id}), retrieve\n * (GET /posts/comments/{id}), list (PATCH /posts/comments).\n *\n * @param props.id The comment's ID to delete\n * @path /posts/comments/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function eraseById(\n  connection: IConnection,\n  props: eraseById.Props,\n): Promise<eraseById.Response> {\n  return !!connection.simulate\n    ? eraseById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...eraseById.METADATA,\n          path: eraseById.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace eraseById {\n  export type Props = {\n    /** The comment's ID to delete */\n    id: string & tags.Format<\"uuid\">;\n  };\n  export type Response = IComment.IDeleteResult;\n\n  export const METADATA = {\n    method: \"DELETE\",\n    path: \"/posts/comments/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/posts/comments/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IComment.IDeleteResult => typia.random<IComment.IDeleteResult>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: eraseById.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: eraseById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/votes/votes/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IVote } from \"../../../structures/IVote\";\nimport { IPageIVote } from \"../../../structures/IPageIVote\";\n\n/**\n * Create a new vote (Votes domain, 'votes' table).\n *\n * Lets a user cast a vote—either upvote or downvote—on a post or comment.\n * Input: must include user ID, value (+1/-1), and reference to either a post or\n * a comment (but not both). Performs validation to ensure target exists and\n * user has not already voted. On success, returns created vote record.\n *\n * Vote limit: only one vote per user per content item, enforced via unique\n * constraint. Can be used for voting analytics, user history, and tally\n * calculations. Related endpoints: retrieve (GET /votes/votes/{id}), update\n * (PUT /votes/votes/{id}), delete (DELETE /votes/votes/{id}), list (PATCH\n * /votes/votes).\n *\n * @param props.body Cast a vote on a post or comment: must include value (+1 or\n *   -1) and target (postId or commentId).\n * @path /votes/votes\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function post(\n  connection: IConnection,\n  props: post.Props,\n): Promise<post.Response> {\n  return !!connection.simulate\n    ? post.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...post.METADATA,\n          path: post.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace post {\n  export type Props = {\n    /**\n     * Cast a vote on a post or comment: must include value (+1 or -1) and\n     * target (postId or commentId).\n     */\n    body: IVote.ICreate;\n  };\n  export type Body = IVote.ICreate;\n  export type Response = IVote;\n\n  export const METADATA = {\n    method: \"POST\",\n    path: \"/votes/votes\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/votes/votes\";\n  export const random = (g?: Partial<typia.IRandomGenerator>): IVote =>\n    typia.random<IVote>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: post.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: post.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Retrieve a filtered, paginated list of votes (Votes domain, 'votes' table).\n *\n * This API returns a list of vote records, most commonly used for reviewing\n * moderation history, analytics, or a user's own votes. Supports filtering by\n * userId, postId, or commentId; pagination (offset/limit); sort order (most\n * recent, oldest first). Optionally, can search for patterns if metadata fields\n * exist.\n *\n * References the 'votes' table (Votes domain) and makes use of unique\n * constraints (one vote per user per item) in its filtering logic. Security\n * notes: regular users can only see their own votes, admins/moderators may\n * audit all. Related endpoints: create (POST /votes/votes), update (PUT\n * /votes/votes/{id}), detail (GET /votes/votes/{id}), delete (DELETE\n * /votes/votes/{id}).\n *\n * @param props.body Filtering, pagination, and sorting for votes list. Fields:\n *   userId, postId, commentId, offset, limit, sort.\n * @path /votes/votes\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patch(\n  connection: IConnection,\n  props: patch.Props,\n): Promise<patch.Response> {\n  return !!connection.simulate\n    ? patch.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patch.METADATA,\n          path: patch.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace patch {\n  export type Props = {\n    /**\n     * Filtering, pagination, and sorting for votes list. Fields: userId,\n     * postId, commentId, offset, limit, sort.\n     */\n    body: IVote.IRequest;\n  };\n  export type Body = IVote.IRequest;\n  export type Response = IPageIVote;\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/votes/votes\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/votes/votes\";\n  export const random = (g?: Partial<typia.IRandomGenerator>): IPageIVote =>\n    typia.random<IPageIVote>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: patch.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patch.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Retrieve full details for a single vote (Votes domain, 'votes' table).\n *\n * Fetches detail for a specific vote, identified by its unique ID. Useful for\n * moderation review or self-audit by a voting user. Information includes which\n * user voted, the value (+1/-1), what post/comment was targeted, and\n * timestamps.\n *\n * References the 'votes' table (Votes domain). Only visible to the vote's owner\n * or those with sufficient privilege. Error handling covers not found,\n * unauthorized access, and malformed IDs. Related endpoints: create (POST\n * /votes/votes), update (PUT /votes/votes/{id}), details (PATCH /votes/votes),\n * delete (DELETE /votes/votes/{id}).\n *\n * @param props.id Vote record's ID\n * @path /votes/votes/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getById(\n  connection: IConnection,\n  props: getById.Props,\n): Promise<getById.Response> {\n  return !!connection.simulate\n    ? getById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getById.METADATA,\n          path: getById.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace getById {\n  export type Props = {\n    /** Vote record's ID */\n    id: string & tags.Format<\"uuid\">;\n  };\n  export type Response = IVote;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/votes/votes/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/votes/votes/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): IVote =>\n    typia.random<IVote>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: getById.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Edit an existing vote's value (Votes domain, 'votes' table).\n *\n * Lets a user (or moderator/admin) edit an existing vote—typically to change\n * their upvote to downvote or vice versa, or to correct an input error. Only\n * the vote's owner or privileged users may edit. Only value can change; postId\n * or commentId are immutable.\n *\n * Business logic is enforced as per the 'votes' table (Votes domain): only one\n * vote per user/content, mutual exclusivity between postId/commentId, and all\n * references must remain valid. Returns the updated vote on success. Related\n * endpoints: create (POST /votes/votes), retrieve (GET /votes/votes/{id}), list\n * (PATCH /votes/votes), delete (DELETE /votes/votes/{id}).\n *\n * @param props.id Vote record's ID to update\n * @param props.body Fields to update in the vote (only value may be changed).\n * @path /votes/votes/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function putById(\n  connection: IConnection,\n  props: putById.Props,\n): Promise<putById.Response> {\n  return !!connection.simulate\n    ? putById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...putById.METADATA,\n          path: putById.path(props),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace putById {\n  export type Props = {\n    /** Vote record's ID to update */\n    id: string & tags.Format<\"uuid\">;\n\n    /** Fields to update in the vote (only value may be changed). */\n    body: IVote.IUpdate;\n  };\n  export type Body = IVote.IUpdate;\n  export type Response = IVote;\n\n  export const METADATA = {\n    method: \"PUT\",\n    path: \"/votes/votes/:id\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Omit<Props, \"body\">) =>\n    `/votes/votes/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): IVote =>\n    typia.random<IVote>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: putById.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: putById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Delete a vote record from the database (Votes domain, 'votes' table).\n *\n * This endpoint removes a specific vote by its ID. Common use-cases: a user\n * withdraws their vote or a moderator/admin removes a vote for violating\n * policy. The vote is deleted from the database (hard delete), and any relevant\n * tally is decremented.\n *\n * Authorization checks ensure only the vote's owner or privileged roles may\n * perform deletion. Related endpoints: create (POST /votes/votes), update (PUT\n * /votes/votes/{id}), retrieve (GET /votes/votes/{id}), list (PATCH\n * /votes/votes). Audit logging may be triggered for moderation actions.\n *\n * @param props.id Vote record's ID to delete\n * @path /votes/votes/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function eraseById(\n  connection: IConnection,\n  props: eraseById.Props,\n): Promise<eraseById.Response> {\n  return !!connection.simulate\n    ? eraseById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...eraseById.METADATA,\n          path: eraseById.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace eraseById {\n  export type Props = {\n    /** Vote record's ID to delete */\n    id: string & tags.Format<\"uuid\">;\n  };\n  export type Response = IVote.IDeleteResult;\n\n  export const METADATA = {\n    method: \"DELETE\",\n    path: \"/votes/votes/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/votes/votes/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IVote.IDeleteResult => typia.random<IVote.IDeleteResult>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: eraseById.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: eraseById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/votes/index.ts": "export * as votes from \"./votes\";\n",
  "packages/api/swagger.json": "{\n  \"openapi\": \"3.1.0\",\n  \"paths\": {\n    \"/core/users\": {\n      \"patch\": {\n        \"summary\": \"Retrieve a paginated, filterable list of users (core.users table).\",\n        \"description\": \"This operation returns a paginated and filtered list of users registered on the discussion board. Users may be searched by username, email, user role, or status, and results are sorted and paginated according to the provided parameters. The endpoint refers to the users table, whose structure includes fields for username, email, bio, role reference, password hash, timestamps, and status. Filters can help administrators or moderators locate specific accounts, monitor new signups, or audit activity. Security is enforced: only users with moderator or administrator roles can access or use advanced filters.\\n\\nThe endpoint applies business rules from the requirements, such as hiding sensitive (e.g., password) information, and supports relations to user_roles for displaying or filtering by user type. Pagination and sorting follow best practices for usability and performance. Related endpoints: create (POST), retrieve detail (GET), update (PUT), and delete (DELETE) for users.\\n\\nError handling ensures invalid queries, unauthorized access, or database issues are managed gracefully, returning clear status codes and messages. Sensitive data, such as password hashes, is never included in responses.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IUser.IRequest\"\n              }\n            }\n          },\n          \"description\": \"Filtering, sorting, and pagination info for user listing request.\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPageIUser.ISummary\"\n                }\n              }\n            },\n            \"description\": \"A paginated set of user summaries matching the search conditions, with profile and role info (never includes sensitive authentication fields).\"\n          }\n        }\n      },\n      \"post\": {\n        \"summary\": \"Register a new user (core.users table).\",\n        \"description\": \"This operation handles new user registration or administrator-created user accounts. It accepts all required and optional fields per the users model: username, email, bio (optional), status, and an associated user_role_id. Passwords are securely hashed before saving, never stored in plain text.\\n\\nUnique constraints are enforced for both username and email to prevent duplicates. The user role must point to an existing role defined in user_roles. Timestamps for creation and update are handled automatically. Successful creation returns the newly registered user's public profile and role association (never the password hash).\\n\\nSecurity and validation reflect business rules, e.g., email visibility, profile privacy, and initial status setting. Input errors or duplicates return clear messages and codes. Related endpoints: list (PATCH), read (GET), update (PUT), delete (DELETE).\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IUser.ICreate\"\n              }\n            }\n          },\n          \"description\": \"Registration info for the new user, including username, email, password, user role, etc.\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"201\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IUser\"\n                }\n              }\n            },\n            \"description\": \"Full profile of the newly created user, including assigned role, minus authentication secrets.\"\n          }\n        }\n      }\n    },\n    \"/core/users/{id}\": {\n      \"get\": {\n        \"summary\": \"Retrieve detailed profile info for a specific user (core.users table).\",\n        \"description\": \"This operation retrieves the full profile and related information for a specific user, identified by their unique user ID. Fields returned follow the schema comments: username, email, bio, status, timestamps, and a reference to their user role. User roles are resolved to human-readable labels where appropriate.\\n\\nSensitive fields such as password_hash are never returned. This endpoint is typically used by administrators for user management, or by users to view their own account details. Where authorized, moderators may use this endpoint for resolving moderation cases or audits. The data aligns exactly with the users table comments and model.\\n\\nRelated endpoints include listing (PATCH), creation (POST), update (PUT), and deletion (DELETE) for users. Error handling covers not found, unauthorized, or forbidden cases, always giving appropriate error codes and minimal leak of protected info.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Target user's ID (UUID).\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IUser\"\n                }\n              }\n            },\n            \"description\": \"Full user profile detail with relevant account and role information, excluding authentication secrets.\"\n          }\n        }\n      },\n      \"put\": {\n        \"summary\": \"Update user profile and account fields (core.users table).\",\n        \"description\": \"Updates an existing user's information, addressing fields in the users schema, such as username, email, bio, role, status, and update timestamp. The input must include the user ID and only permitted fields are updateable. Username/email uniqueness is enforced on update as well. Moderators/administrators can change roles/statuses as permitted by business rules.\\n\\nThe request never allows direct password updates (managed by a separate dedicated endpoint, or by password reset process for security). All change history is reflected in the updated_at timestamp. Security measures prevent users from editing others' profiles unless authorized; self-edits are limited to certain fields.\\n\\nRelated endpoints: detail (GET), list (PATCH), create (POST), delete (DELETE). Strict validation and business rule application ensure stability and data quality.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Target user's ID (UUID).\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IUser.IUpdate\"\n              }\n            }\n          },\n          \"description\": \"Editable fields for user update, such as profile details or status/role changes (excludes password updates).\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IUser\"\n                }\n              }\n            },\n            \"description\": \"Full, updated user profile after modifications, including associated role info.\"\n          }\n        }\n      },\n      \"delete\": {\n        \"summary\": \"Softly or fully delete a user (core.users table).\",\n        \"description\": \"Deletes a user account with the specified ID. This typically marks the user's status as deleted or suspended and/or sets a deletion flag in audit fields, per the users Prisma schema and moderation rules. Associated content (posts, comments, votes) may be retained for community reference, moderation, or audit logs, as described in requirements.\\n\\nOnly administrators may perform this action, and a detailed audit trail is kept. Related endpoints are used for restoration or final hard-delete (if policy allows). Errors for not found or forbidden actions are handled appropriately; sensitive information on deleted users is not exposed.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Target user's ID (UUID).\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IUser.IDeleteResponse\"\n                }\n              }\n            },\n            \"description\": \"Confirmation of successful deletion or status update, with minimal identifying info.\"\n          }\n        }\n      }\n    },\n    \"/core/userRoles\": {\n      \"patch\": {\n        \"summary\": \"List and filter user roles (core.userRoles table).\",\n        \"description\": \"This operation returns a paginated list of user roles available to assign, as defined by the user_roles model. Roles govern permissions across the board (e.g., member, moderator, administrator). Designed for use in registration processes, admin dashboards, or role management panels, enabling filtering by role name or description and ordering of results.\\n\\nData returned is defined strictly by the Prisma model and schema comments. This operation is auditable and respects business constraints on who may view/assign roles. Related endpoints: single role GET, create (POST), update (PUT), and delete (DELETE).\\n\\nError cases (e.g., forbidden access) are handled with appropriate status codes. Pagination and search parameters maximize usability and efficiency, especially for large deployments with custom roles.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IUserRole.IRequest\"\n              }\n            }\n          },\n          \"description\": \"Filter, search, and pagination info for user roles listing.\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPageIUserRole\"\n                }\n              }\n            },\n            \"description\": \"A paginated list of available user roles with label and description.\"\n          }\n        }\n      },\n      \"post\": {\n        \"summary\": \"Create a new user role (core.userRoles table).\",\n        \"description\": \"Creates a new user role based on the schema structure, with fields for name (label) and description. Enforces the uniqueness of the role name and ensures all required information is provided, following the comments and requirements detailed in the Prisma schema.\\n\\nIntended for administrator setup or customization of new permission levels. Errors are sent in case of duplicate names, missing fields, or insufficient permissions. Successful creation returns the new user role record, suitable for immediate assignment to users.\\n\\nRelated endpoints: list (PATCH), single GET, update (PUT), and delete (DELETE) for user roles.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IUserRole.ICreate\"\n              }\n            }\n          },\n          \"description\": \"New user role details, including name and description.\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"201\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IUserRole\"\n                }\n              }\n            },\n            \"description\": \"Details for the created user role, ready for assignment to users.\"\n          }\n        }\n      }\n    },\n    \"/core/userRoles/{id}\": {\n      \"get\": {\n        \"summary\": \"Get a single user role's details (core.userRoles table).\",\n        \"description\": \"Retrieves all details for a single user role, specified by ID. Used in admin panels to display all properties of a role, or in account registration to inform users about the meaning and permissions of each role (as described in schema comments: name, description, etc).\\n\\nRespects all business rules regarding role assignment and application. Related endpoints: list (PATCH), creation (POST), update (PUT), delete (DELETE). Errors for missing roles or unauthorized actions are handled gracefully, with clear messaging.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Target role's ID (UUID).\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IUserRole\"\n                }\n              }\n            },\n            \"description\": \"Details about the specified user role, including label and full description.\"\n          }\n        }\n      },\n      \"put\": {\n        \"summary\": \"Edit label/description for a user role (core.userRoles table).\",\n        \"description\": \"Updates an existing user role's properties (name and/or description). Uniqueness of the name is enforced by Prisma schema rules. Typical in systems where additional roles/policies are introduced or for correcting role definitions.\\n\\nOnly administrators are permitted to update roles. Change history is tracked and any update is reflected in audit fields. Related endpoints: detail GET, list PATCH, creation POST, and deletion DELETE for user roles.\\n\\nAny errors due to duplicates, forbidden edits, or missing records generate suitable error codes in response. Endpoint matches structure and intentions described in requirements and schema comments.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Target role's ID (UUID).\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IUserRole.IUpdate\"\n              }\n            }\n          },\n          \"description\": \"New values for user role fields (name/description).\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IUserRole\"\n                }\n              }\n            },\n            \"description\": \"Updated role details after successful edit.\"\n          }\n        }\n      },\n      \"delete\": {\n        \"summary\": \"Delete a user role from the system (core.userRoles table).\",\n        \"description\": \"Deletes a user role identified by its ID. Enforces business and schema rules about which roles can be deleted (e.g., prevents deletion of critical roles if protected by business logic). If the role is in use (referenced by users), operation will fail with a clear error message.\\n\\nAdministrative rights are required. Detailed audit trails are maintained for changes. Related endpoints: create (POST), list (PATCH), update (PUT), detail (GET). All operations match Prisma schema and requirements. Appropriate handling is provided for not found, forbidden, or dependency errors.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Target role's ID (UUID).\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IUserRole.IDeleteResponse\"\n                }\n              }\n            },\n            \"description\": \"Confirmation of role deletion or status update; references deleted role.\"\n          }\n        }\n      }\n    },\n    \"/core/categories\": {\n      \"patch\": {\n        \"summary\": \"List and search categories (Core.categories)\",\n        \"description\": \"This API operation returns a list of categories, leveraging the 'categories' table from the database. \\n\\nThe response is paginated and may be filtered based on optional query parameters such as name, partial matches in description, or created_at window. Secure endpoints may restrict certain filters or result fields to administrators. The main purpose is to allow users to browse or search available discussion categories for post assignment or exploration. \\n\\nSecurity: Some filtering/search options may be restricted to users with elevated roles, such as administrators or moderators. Regular users typically see all active categories only. \\n\\nThis endpoint is commonly used in category selection modals, administrative dashboards, and on board homepages. Validation ensures page and pageSize are non-negative, and sortBy field must match a valid column. Error handling will return informative failures for invalid filter parameters or database errors.\\n\\nThis operation is related to single-category get, create, update, and delete operations, and in large systems may be supplemented by category suggestion/approval flows.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/ICategory.IRequest\"\n              }\n            }\n          },\n          \"description\": \"Search criteria, pagination, and sorting parameters for categories list query.\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPageICategory\"\n                }\n              }\n            },\n            \"description\": \"Paginated result including array of category summaries and pagination metadata.\"\n          }\n        }\n      },\n      \"post\": {\n        \"summary\": \"Create new category (Core.categories)\",\n        \"description\": \"Allows creation of a new category topic for the discussion board, by inserting a new record into the 'categories' table in the database. The provided name must be unique among all categories. Description field gives users context. Only authorized users (administrators) are permitted to execute this operation.\\n\\nInput validation includes ensuring that required fields are present, name does not duplicate existing entries, and description respects length/content rules. On success, the new category is created and returned with full detail including its assigned UUID and creation timestamp.\\n\\nError handling covers invalid parameters, uniqueness violations, or insufficient permissions. \\n\\nRelated endpoints: list/search (PATCH), get (GET), update (PUT), and delete (DELETE) for categories.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/ICategory.ICreate\"\n              }\n            }\n          },\n          \"description\": \"Data for new category including unique name and description.\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"201\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/ICategory\"\n                }\n              }\n            },\n            \"description\": \"The newly created category with full details.\"\n          }\n        }\n      }\n    },\n    \"/core/categories/{id}\": {\n      \"get\": {\n        \"summary\": \"Retrieve specific category by ID (Core.categories)\",\n        \"description\": \"Retrieves category information for the specified ID from the 'categories' table, including name, description, creation timestamp, and potentially related post count or status if extended.\\n\\nIf the category does not exist, the API returns a clear error message. Access policies determine visibility of archived or deactivated categories—regular users can only view active categories, while admins may retrieve all states.\\n\\nThis endpoint is essential for screens displaying category details prior to editing/deleting, or for referencing during post creation/editing workflows. Includes validation of the UUID path parameter. Returns 404 if not found or permission denied.\\n\\nRelated endpoints: categories list/search (PATCH), create (POST), update (PUT), and delete (DELETE).\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Unique ID of the target category\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/ICategory\"\n                }\n              }\n            },\n            \"description\": \"Full detail of the specified category, including all public fields.\"\n          }\n        }\n      },\n      \"put\": {\n        \"summary\": \"Update a category by ID (Core.categories)\",\n        \"description\": \"Updates an existing category's name or description by changing the relevant fields in the 'categories' table. The category is referenced by its unique UUID path parameter, and the body provides updated data.\\n\\nThis operation may only be performed by users with appropriate administrative roles. Validation checks include verifying that the new category name does not duplicate any other categories and that all required fields meet formatting rules.\\n\\nPartial or full updates are supported; fields not included may retain their current values. Business rules may restrict changes if the category is currently associated with posts. On success, the full updated category information is returned.\\n\\nError handling includes failing if the category does not exist, trying to use a duplicate name, or lacking sufficient rights. Related operations: get, create, delete, and list/search categories.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Unique ID of the target category\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/ICategory.IUpdate\"\n              }\n            }\n          },\n          \"description\": \"Updated name and/or description for the category.\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/ICategory\"\n                }\n              }\n            },\n            \"description\": \"The updated category details after saving changes.\"\n          }\n        }\n      },\n      \"delete\": {\n        \"summary\": \"Delete a category by ID (Core.categories)\",\n        \"description\": \"Deletes (or marks as deleted) a category based on its unique ID. This operation usually employs soft-deletion: the category is flagged so it no longer appears in lists or selection menus, but remains in the database for historical tracking and audit purposes. Some implementations may require hard deletion if the category has no posts attached.\\n\\nPermission to use this operation is typically restricted to administrators. Attempts to delete active categories in use by posts may be rejected or require confirmation. All deletion attempts are logged for audit.\\n\\nError cases include non-existent category ID, attempts to delete categories linked to live posts, or insufficient permissions. Related endpoints: create, get, update, and list/search categories.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Unique ID of the target category\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/ICategory.IDeleteResult\"\n                }\n              }\n            },\n            \"description\": \"Result of the delete operation, such as a confirmation message or status object.\"\n          }\n        }\n      }\n    },\n    \"/posts/posts\": {\n      \"patch\": {\n        \"summary\": \"List and search posts (Posts.posts)\",\n        \"description\": \"This API operation returns a list of posts (discussion threads or articles) with full support for filtering by category, author, or keywords, as well as sorting and pagination. Non-admin users typically see only non-deleted, non-archived posts, while administrators may have visibility into all post states. Standard search validation is performed for page, pageSize, and sort field inputs.\\n\\nThe endpoint supports community browsing, category threads, author-centric feeds, and search result pages. It also includes support for keyword-based full-text search on titles and content. Additional metadata such as comment and vote counts may be included per business requirements. Error handling addresses invalid filters, missing results, or backend errors.\\n\\nRelated to post retrieval (GET), post creation (POST), update (PUT), and delete (DELETE) endpoints, as well as comment and vote-related APIs.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IPost.IRequest\"\n              }\n            }\n          },\n          \"description\": \"Criteria for searching, paging, and sorting posts.\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPageIPost\"\n                }\n              }\n            },\n            \"description\": \"Paginated result of posts with summary data, and metadata for pagination.\"\n          }\n        }\n      },\n      \"post\": {\n        \"summary\": \"Create a new post (Posts.posts)\",\n        \"description\": \"Allows a user to create a new post by providing required information such as category, title, and content. The new post is assigned to the authoring user and is inserted into the database. Creation may be subject to moderation or review depending on platform policies.\\n\\nInput validation includes ensuring a valid category reference, unique/valid title, and legitimate content (length, formatting). On success, the API returns the full details of the created post, including assigned UUID, timestamps, and author/category references.\\n\\nError cases include missing/invalid data, attempts to create a post in non-existent category, or by unauthorized/blocked users. Related endpoints: list/search (PATCH), get (GET), update (PUT), delete (DELETE); plus comment APIs.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IPost.ICreate\"\n              }\n            }\n          },\n          \"description\": \"All information required for new post: categoryId, title, content.\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"201\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPost\"\n                }\n              }\n            },\n            \"description\": \"Full detail for the newly created post, including IDs and timestamps.\"\n          }\n        }\n      }\n    },\n    \"/posts/posts/{id}\": {\n      \"get\": {\n        \"summary\": \"Retrieve specific post by ID (Posts.posts)\",\n        \"description\": \"Retrieves full details of a single post, identified by its unique ID. Returns all fields visible to the viewing user, such as title, content, author reference, category reference, creation and update times, etc. Admin users may access deleted posts if required, while normal users only see active posts.\\n\\nThis API is the primary source of detail for displaying or editing a discussion post. It validates the UUID input, and returns a 404 or permission error if the post does not exist or the user lacks rights.\\n\\nRelated endpoints: post list/search (PATCH), create (POST), update (PUT), delete (DELETE). Also supports comment and voting APIs.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Unique ID of the target post\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPost\"\n                }\n              }\n            },\n            \"description\": \"All detail fields of the requested post, as permitted by current user role.\"\n          }\n        }\n      },\n      \"put\": {\n        \"summary\": \"Update a post by ID (Posts.posts)\",\n        \"description\": \"Updates an existing post, referenced by its unique ID. Input may update title, content, and/or category reference. Only the author or an administrator/moderator may perform this operation. All updates are validated for required structure, content, and permission.\\n\\nPartial updates retain other fields unchanged. History tracking is enabled via timestamps. Changing category may have restrictions if the post has live comments. On success, returns updated post data; on failure, returns validation or permission errors.\\n\\nRelated endpoints: get, list/search, create, delete for posts. This endpoint supports editing discussion threads after posting.\\n\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Unique ID of the target post\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IPost.IUpdate\"\n              }\n            }\n          },\n          \"description\": \"Fields to update for post (title, content, category).\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPost\"\n                }\n              }\n            },\n            \"description\": \"The updated post's full details after saving changes.\"\n          }\n        }\n      },\n      \"delete\": {\n        \"summary\": \"Delete a post by ID (Posts.posts)\",\n        \"description\": \"Deletes (or marks as deleted) a post record by its ID. Standard implementation is soft-deletion: post remains in database for moderation and audit but is removed from normal views and feeds. Only the original author, admin, or moderator can perform deletion. Attempts to delete posts with active comments or votes may be subject to business rule restrictions or warnings.\\n\\nAll delete actions are logged. The response provides confirmation or error. Related endpoints: create, get, update, and list/search for posts. Deletion cascades may apply to comments and votes as policy dictates.\\n\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Unique ID of the target post\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPost.IDeleteResult\"\n                }\n              }\n            },\n            \"description\": \"Result or confirmation of post deletion (success, message, etc.)\"\n          }\n        }\n      }\n    },\n    \"/posts/comments\": {\n      \"patch\": {\n        \"summary\": \"Retrieve a filtered, paginated list of comments (Posts domain, 'comments' table).\",\n        \"description\": \"This API retrieves a paged list of comments from the discussion board. Typically, users or moderators use it to see all comments on a specific thread, all comments by a particular user, or to moderate recent activity.\\n\\nThe route supports filtering (e.g., by postId, userId, parentId), pagination (offset/limit), full-text search on comment content, and sorting (e.g., newest first). Security considerations include only exposing non-deleted comments by default, unless requested by a privileged moderator/admin. Comment content is filtered to remove inappropriate language if the requester has insufficient privileges.\\n\\nIt references the 'comments' table (Posts domain). Query performance is optimized via relevant indexes. Related APIs include: create (POST /posts/comments), update (PUT /posts/comments/{id}), retrieve detail (GET /posts/comments/{id}), and delete (DELETE /posts/comments/{id}).\\n\\nInput validation includes correct types for filters, max page size, and valid sort orders. Error handling covers unauthorized access, malformed filters, and nonexistent references.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IComment.IRequest\"\n              }\n            }\n          },\n          \"description\": \"Defines filtering, pagination, and sorting criteria for retrieving comments. Fields may include postId, userId, parentId, search, offset, limit, and sort.\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPageIComment\"\n                }\n              }\n            },\n            \"description\": \"Paged list of comments matching given filters.\"\n          }\n        }\n      },\n      \"post\": {\n        \"summary\": \"Create a new comment (Posts domain, 'comments' table).\",\n        \"description\": \"This API lets a registered user create a new comment (either as a direct reply to a post or as a nested reply to another comment). Necessary fields include the content, target postId, and optionally a parentId (for replies-to-replies).\\n\\nInput is validated for minimum/maximum length, appropriate content, and ensuring the parent exists and belongs to the same post. The endpoint checks author authentication and standard anti-abuse policies (e.g., rate limiting). On success, it returns the created comment record with all metadata (author, timestamp, etc.).\\n\\nBusiness logic from the 'comments' table (Posts domain) is implemented: only registered users may comment; soft deletion rules apply. Related endpoints: retrieval (GET /posts/comments/{id}), update (PUT /posts/comments/{id}), and listing (PATCH /posts/comments).\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IComment.ICreate\"\n              }\n            }\n          },\n          \"description\": \"New comment data, including content, postId, and optional parentId.\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"201\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IComment\"\n                }\n              }\n            },\n            \"description\": \"The newly created comment record, with full metadata.\"\n          }\n        }\n      }\n    },\n    \"/posts/comments/{id}\": {\n      \"get\": {\n        \"summary\": \"Fetch detailed information about a single comment (Posts domain, 'comments' table).\",\n        \"description\": \"This API fetches the detail of a single comment in the discussion board by its unique ID. Common scenarios include users viewing a nested reply, moderators inspecting a reported comment, or when displaying a comment in thread view.\\n\\nIt returns full details such as content, author, timestamps, post reference, parent comment reference, and vote tallies. The route references the 'comments' table (Posts domain) and is optimized for quick retrieval. It will not return comments marked as deleted unless accessed by a user with sufficient privileges (e.g., moderator or admin).\\n\\nError handling includes returning appropriate errors for nonexistent, deleted, or unauthorized access. Related APIs: listing (PATCH /posts/comments), update (PUT /posts/comments/{id}), creation (POST /posts/comments), and deletion (DELETE /posts/comments/{id}).\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Target comment's ID\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IComment\"\n                }\n              }\n            },\n            \"description\": \"Full comment info, including content, author, timestamps, post and parent references.\"\n          }\n        }\n      },\n      \"put\": {\n        \"summary\": \"Update an existing comment's content or deletion status (Posts domain, 'comments' table).\",\n        \"description\": \"This API allows an authorized user (typically the comment's original author or a moderator/admin) to update the content or status of a comment. Supported fields for update include content (for editing), and soft deletion flag.\\n\\nChecks include author authentication, edit time-window (if enforced by policy), and protection against editing after moderation/deletion. Input validation ensures updated content meets platform standards, and references are unaltered (cannot change post or parentId).\\n\\nThe endpoint references the 'comments' table (Posts domain). On success, returns the updated comment object. Error scenarios include not found, unauthorized modification, or invalid updates. Related APIs: create (POST /posts/comments), retrieve (GET /posts/comments/{id}), delete (DELETE /posts/comments/{id}).\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"The target comment's ID to update\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IComment.IUpdate\"\n              }\n            }\n          },\n          \"description\": \"Fields to update in the comment (content and/or soft delete).\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IComment\"\n                }\n              }\n            },\n            \"description\": \"The updated comment record.\"\n          }\n        }\n      },\n      \"delete\": {\n        \"summary\": \"Soft-delete a comment (Posts domain, 'comments' table).\",\n        \"description\": \"This API performs a soft deletion (marks as deleted) of a comment identified by its ID. Typical scenarios: the comment's author chooses to remove their reply, or a moderator removes content that violates policy. The comment remains in the database (for auditability), but becomes invisible to regular users and excluded from normal listings.\\n\\nAuthorization checks enforce only the author, moderator, or admin can perform this. Related error handling includes not found, already deleted, and unauthorized access. Audit logs are typically recorded. Related endpoints: create (POST /posts/comments), update (PUT /posts/comments/{id}), retrieve (GET /posts/comments/{id}), list (PATCH /posts/comments).\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"The comment's ID to delete\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IComment.IDeleteResult\"\n                }\n              }\n            },\n            \"description\": \"Indicates successful deletion or details if already deleted.\"\n          }\n        }\n      }\n    },\n    \"/votes/votes\": {\n      \"patch\": {\n        \"summary\": \"Retrieve a filtered, paginated list of votes (Votes domain, 'votes' table).\",\n        \"description\": \"This API returns a list of vote records, most commonly used for reviewing moderation history, analytics, or a user's own votes. Supports filtering by userId, postId, or commentId; pagination (offset/limit); sort order (most recent, oldest first). Optionally, can search for patterns if metadata fields exist.\\n\\nReferences the 'votes' table (Votes domain) and makes use of unique constraints (one vote per user per item) in its filtering logic. Security notes: regular users can only see their own votes, admins/moderators may audit all. Related endpoints: create (POST /votes/votes), update (PUT /votes/votes/{id}), detail (GET /votes/votes/{id}), delete (DELETE /votes/votes/{id}).\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IVote.IRequest\"\n              }\n            }\n          },\n          \"description\": \"Filtering, pagination, and sorting for votes list. Fields: userId, postId, commentId, offset, limit, sort.\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPageIVote\"\n                }\n              }\n            },\n            \"description\": \"Paged list of vote records matching given filters.\"\n          }\n        }\n      },\n      \"post\": {\n        \"summary\": \"Create a new vote (Votes domain, 'votes' table).\",\n        \"description\": \"Lets a user cast a vote—either upvote or downvote—on a post or comment. Input: must include user ID, value (+1/-1), and reference to either a post or a comment (but not both). Performs validation to ensure target exists and user has not already voted. On success, returns created vote record.\\n\\nVote limit: only one vote per user per content item, enforced via unique constraint. Can be used for voting analytics, user history, and tally calculations. Related endpoints: retrieve (GET /votes/votes/{id}), update (PUT /votes/votes/{id}), delete (DELETE /votes/votes/{id}), list (PATCH /votes/votes).\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IVote.ICreate\"\n              }\n            }\n          },\n          \"description\": \"Cast a vote on a post or comment: must include value (+1 or -1) and target (postId or commentId).\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"201\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IVote\"\n                }\n              }\n            },\n            \"description\": \"The newly created vote record.\"\n          }\n        }\n      }\n    },\n    \"/votes/votes/{id}\": {\n      \"get\": {\n        \"summary\": \"Retrieve full details for a single vote (Votes domain, 'votes' table).\",\n        \"description\": \"Fetches detail for a specific vote, identified by its unique ID. Useful for moderation review or self-audit by a voting user. Information includes which user voted, the value (+1/-1), what post/comment was targeted, and timestamps.\\n\\nReferences the 'votes' table (Votes domain). Only visible to the vote's owner or those with sufficient privilege. Error handling covers not found, unauthorized access, and malformed IDs. Related endpoints: create (POST /votes/votes), update (PUT /votes/votes/{id}), details (PATCH /votes/votes), delete (DELETE /votes/votes/{id}).\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Vote record's ID\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IVote\"\n                }\n              }\n            },\n            \"description\": \"Full vote record, including user, content, and metadata.\"\n          }\n        }\n      },\n      \"put\": {\n        \"summary\": \"Edit an existing vote's value (Votes domain, 'votes' table).\",\n        \"description\": \"Lets a user (or moderator/admin) edit an existing vote—typically to change their upvote to downvote or vice versa, or to correct an input error. Only the vote's owner or privileged users may edit. Only value can change; postId or commentId are immutable.\\n\\nBusiness logic is enforced as per the 'votes' table (Votes domain): only one vote per user/content, mutual exclusivity between postId/commentId, and all references must remain valid. Returns the updated vote on success. Related endpoints: create (POST /votes/votes), retrieve (GET /votes/votes/{id}), list (PATCH /votes/votes), delete (DELETE /votes/votes/{id}).\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Vote record's ID to update\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IVote.IUpdate\"\n              }\n            }\n          },\n          \"description\": \"Fields to update in the vote (only value may be changed).\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IVote\"\n                }\n              }\n            },\n            \"description\": \"The updated vote record.\"\n          }\n        }\n      },\n      \"delete\": {\n        \"summary\": \"Delete a vote record from the database (Votes domain, 'votes' table).\",\n        \"description\": \"This endpoint removes a specific vote by its ID. Common use-cases: a user withdraws their vote or a moderator/admin removes a vote for violating policy. The vote is deleted from the database (hard delete), and any relevant tally is decremented.\\n\\nAuthorization checks ensure only the vote's owner or privileged roles may perform deletion. Related endpoints: create (POST /votes/votes), update (PUT /votes/votes/{id}), retrieve (GET /votes/votes/{id}), list (PATCH /votes/votes). Audit logging may be triggered for moderation actions.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Vote record's ID to delete\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IVote.IDeleteResult\"\n                }\n              }\n            },\n            \"description\": \"Indicates success or provides result details of the delete action.\"\n          }\n        }\n      }\n    }\n  },\n  \"components\": {\n    \"schemas\": {\n      \"IPost.ISummary\": {\n        \"type\": \"object\",\n        \"description\": \"게시글(포스트)의 요약 정보를 제공하는 타입입니다. 목록 조회, 관계 프로퍼티 등에서 사용됩니다.\\n\\n게시글의 고유 ID, 제목, 작성자 ID, 카테고리 ID, 생성일, 수정일, 댓글/추천 등 카운트 필수 정보를 담고 있어, 리스트 UI 테이블/카드 등 요약 리스트용으로 활용합니다. 본문 전체나 관계 정보는 포함하지 않습니다.\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"게시글 고유 식별자(UUID). 예: '973c0116-ac2c-4ffb-b38b-7c4c45c7b2df'\"\n          },\n          \"user_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"작성자(user)의 ID(UUID)\"\n          },\n          \"category_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"속한 카테고리의 ID(UUID)\"\n          },\n          \"title\": {\n            \"type\": \"string\",\n            \"description\": \"게시글 제목\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"description\": \"게시글 작성일시(ISO8601)\"\n          },\n          \"updated_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"description\": \"게시글 마지막 수정 시각(ISO8601)\"\n          },\n          \"comment_count\": {\n            \"type\": \"integer\",\n            \"description\": \"해당 글의 댓글 개수\"\n          },\n          \"vote_count\": {\n            \"type\": \"integer\",\n            \"description\": \"해당 글의 추천(투표) 합계\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"user_id\",\n          \"category_id\",\n          \"title\",\n          \"created_at\",\n          \"updated_at\",\n          \"comment_count\",\n          \"vote_count\"\n        ]\n      },\n      \"IUser.IRequest\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"page\": {\n            \"type\": \"integer\",\n            \"format\": \"uint32\",\n            \"description\": \"Page number for user list pagination. Optional field, aligns with standard best practices for paginated APIs.\\n\\nUsed to retrieve a specific page of user data. Default follows the IPage IRequest definition.\"\n          },\n          \"limit\": {\n            \"type\": \"integer\",\n            \"format\": \"uint32\",\n            \"description\": \"Number of users per page (for pagination). Optional, defaults to 100 if unspecified as per IPage specification.\\n\\nRestricts how many user records are returned in each page.\"\n          },\n          \"role\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"Filter by user role (user_roles.id) to return users with a specific role (e.g., member, moderator, administrator).\\n\\nHelps admins/moderators filter and locate users of a particular type or permission set.\"\n          },\n          \"status\": {\n            \"type\": \"string\",\n            \"description\": \"Filter users by account status (e.g., 'active', 'suspended', 'banned').\\n\\nEnables moderation and administrative user management by quickly finding users in specific states.\"\n          },\n          \"search\": {\n            \"type\": \"string\",\n            \"description\": \"Search string, matches username or email in user list queries.\\n\\nSupports quick filtering of users when searching by identifying fields; case-insensitive partial match.\"\n          }\n        },\n        \"description\": \"User list request/filter parameters, supporting pagination, search, and filtering by role or status.\\n\\nImplements board requirements around user management and moderation. Based on database and business rules from Core.users and relevant API operation specs.\",\n        \"required\": []\n      },\n      \"IUser.ISummary\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"User's unique identifier (UUID).\\n\\nReferenced from users.id in the database, required for user profile lookups.\"\n          },\n          \"username\": {\n            \"type\": \"string\",\n            \"description\": \"Public username (displayed in the board and visible to all users).\\n\\nUnique and required; serves as the user's main identifier for discussions, voting, and moderation.\"\n          },\n          \"bio\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"description\": \"Optional user biography; a short self-description or interests section.\\n\\nMay be empty; helps other members know basic info about the user.\"\n              },\n              {\n                \"type\": \"null\"\n              }\n            ],\n            \"description\": \"Optional user biography; a short self-description or interests section.\\n\\nMay be empty; helps other members know basic info about the user.\"\n          },\n          \"role\": {\n            \"$ref\": \"#/components/schemas/IUserRole.ISummary\"\n          },\n          \"status\": {\n            \"type\": \"string\",\n            \"description\": \"Current user account status (e.g., 'active', 'suspended', 'banned').\\n\\nReflects moderation, login eligibility, and enforcement of platform rules.\"\n          }\n        },\n        \"description\": \"Concise user summary as returned in user listing responses. Hides sensitive fields.\\n\\nIncludes only public profile, role summary, and status info. Used in paginated user lists and admin/member lookup features.\",\n        \"required\": [\n          \"id\",\n          \"username\",\n          \"role\",\n          \"status\"\n        ]\n      },\n      \"IUserRole.ISummary\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"Unique identifier for user role (user_roles.id field).\\n\\nEnforces referential integrity for permission assignments.\"\n          },\n          \"name\": {\n            \"type\": \"string\",\n            \"description\": \"Short label name for the user role (e.g., 'member', 'moderator', 'administrator').\\n\\nUsed in dropdowns, labels, admin tools. Required and unique per database schema.\"\n          }\n        },\n        \"description\": \"Summary/view version of a user role entity. Contains only essential fields (id, name).\\n\\nUsed for responses where full details are unnecessary but reference is required.\",\n        \"required\": [\n          \"id\",\n          \"name\"\n        ]\n      },\n      \"IPageIUser.ISummary\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"pagination\": {\n            \"$ref\": \"#/components/schemas/IPage.IPagination\"\n          },\n          \"data\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IUser.ISummary\"\n            },\n            \"description\": \"Paginated list of user summaries matching request filters.\"\n          }\n        },\n        \"description\": \"Paginated user summary list container.\\n\\nStandardized IPage<T> wrapper for user listings, as per business requirements.\",\n        \"required\": [\n          \"pagination\",\n          \"data\"\n        ]\n      },\n      \"IUser\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"Unique internal user ID (users.id). Used system-wide to link all user objects, references, and foreign keys.\\n\\nRequired; generated upon account creation and immutable.\"\n          },\n          \"user_role_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"Foreign key to user_roles.id; denotes the active permission set (member, moderator, admin, etc).\\n\\nRequired at creation; determines access, moderation, and board capabilities.\"\n          },\n          \"username\": {\n            \"type\": \"string\",\n            \"description\": \"Unique public display name; visible to all, and referenced in discussion, voting, and moderation.\\n\\nDatabase-enforced as unique.\"\n          },\n          \"email\": {\n            \"type\": \"string\",\n            \"format\": \"email\",\n            \"description\": \"User's email address. Used for login and communication.\\n\\nNever displayed publicly. Must be unique.\"\n          },\n          \"bio\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"description\": \"Free-form user biography/self-description.\\n\\nOptional, enhances social context on the board.\"\n              },\n              {\n                \"type\": \"null\"\n              }\n            ],\n            \"description\": \"Free-form user biography/self-description.\\n\\nOptional, enhances social context on the board.\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"description\": \"Account creation datetime (with timezone). Used for auditing, ordering, and admin reporting.\\n\\nImmutable.\"\n          },\n          \"updated_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"description\": \"Most recent profile update timestamp for this user.\\n\\nUpdated whenever profile fields are changed.\"\n          },\n          \"status\": {\n            \"type\": \"string\",\n            \"description\": \"Current account status (active, suspended, banned, etc.).\\n\\nEnforced per moderation/business rule policies.\"\n          },\n          \"role\": {\n            \"$ref\": \"#/components/schemas/IUserRole\"\n          },\n          \"posts\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IPost.ISummary\"\n            },\n            \"description\": \"Array of summaries for posts authored by the user (board threads or articles).\"\n          },\n          \"comments\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IComment.ISummary\"\n            },\n            \"description\": \"List of summaries for comments made by this user.\"\n          },\n          \"votes\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IVote.ISummary\"\n            },\n            \"description\": \"Summary array of votes cast by the user on posts/comments.\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"user_role_id\",\n          \"username\",\n          \"email\",\n          \"created_at\",\n          \"updated_at\",\n          \"status\",\n          \"role\"\n        ],\n        \"description\": \"Full user entity, as per users Prisma schema. Contains all non-confidential account info and relations.\\n\\nDetailed per-table and per-field documentation referenced from schema. Represents user profiles for detail pages and admin/mod tools.\"\n      },\n      \"IUser.ICreate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"user_role_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"Role assignment for new user; must match user_roles.id. Required at registration. E.g., 'member', 'moderator', or 'administrator'.\"\n          },\n          \"username\": {\n            \"type\": \"string\",\n            \"description\": \"New user's unique public display name. Required, must be unique, visible on the board.\"\n          },\n          \"email\": {\n            \"type\": \"string\",\n            \"format\": \"email\",\n            \"description\": \"New user's email address. Required for registration, must be unique, never public.\"\n          },\n          \"bio\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"description\": \"Optional user bio/about section. May be empty upon registration.\"\n              },\n              {\n                \"type\": \"null\"\n              }\n            ],\n            \"description\": \"Optional user bio/about section. May be empty upon registration.\"\n          },\n          \"password\": {\n            \"type\": \"string\",\n            \"description\": \"User password, plain text at registration. Required; will be securely hashed before storage. Never returned by API.\"\n          },\n          \"status\": {\n            \"type\": \"string\",\n            \"description\": \"Initial status for user: normally 'active', but admin can specify e.g., 'pending', 'suspended'.\"\n          }\n        },\n        \"required\": [\n          \"user_role_id\",\n          \"username\",\n          \"email\",\n          \"password\",\n          \"status\"\n        ],\n        \"description\": \"Request body schema for new user registration/account creation.\\n\\nAll required/optional fields per users model. Password is accepted as clear text but is hashed internally.\"\n      },\n      \"IUser.IUpdate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"user_role_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"(Optional) Role update for user. Admin/moderator action only. Must match an existing user_roles.id.\"\n          },\n          \"username\": {\n            \"type\": \"string\",\n            \"description\": \"(Optional) Update to user's public display name. Must be unique if updated.\"\n          },\n          \"email\": {\n            \"type\": \"string\",\n            \"format\": \"email\",\n            \"description\": \"(Optional) Update to user's email address. Uniqueness required if changed.\"\n          },\n          \"bio\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"description\": \"(Optional) Update to bio/about me field.\"\n              },\n              {\n                \"type\": \"null\"\n              }\n            ],\n            \"description\": \"(Optional) Update to bio/about me field.\"\n          },\n          \"status\": {\n            \"type\": \"string\",\n            \"description\": \"(Optional) Modify user account status (active, suspended, etc.).\"\n          },\n          \"updated_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"description\": \"Update timestamp; automatically set by the server on update.\"\n          }\n        },\n        \"required\": [],\n        \"description\": \"Request body for updating an existing user profile/account.\\n\\nOnly fields supplied are updated; all are optional. Password change is NOT handled here.\"\n      },\n      \"IUser.IDeleteResponse\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"ID of user deleted or marked for deletion. Used for reference in audit trails and deletion confirmations.\"\n          },\n          \"status\": {\n            \"type\": \"string\",\n            \"description\": \"Status message (e.g., 'deleted', 'suspended', etc.) after deletion/disable action.\"\n          }\n        },\n        \"description\": \"Response for user deletion operation. Contains minimal identifying and audit info.\\n\\nDoes not reveal sensitive user fields.\",\n        \"required\": []\n      },\n      \"IUserRole.IRequest\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"page\": {\n            \"type\": \"integer\",\n            \"format\": \"uint32\",\n            \"description\": \"Page number for role list pagination. Optional; aligns with IPage best-practice.\"\n          },\n          \"limit\": {\n            \"type\": \"integer\",\n            \"format\": \"uint32\",\n            \"description\": \"Pagination limit for number of roles per page. Defaults to 100 if missing.\\n\\nStandard for IPage APIs.\"\n          },\n          \"search\": {\n            \"type\": \"string\",\n            \"description\": \"Keyword filter for role name or description fields. Enables quick role lookup.\"\n          }\n        },\n        \"description\": \"List/request filtering schema for user roles table.\\n\\nSupports pagination, keyword search for role management dashboards, registration, and editor widgets.\",\n        \"required\": []\n      },\n      \"IPageIUserRole\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"pagination\": {\n            \"$ref\": \"#/components/schemas/IPage.IPagination\"\n          },\n          \"data\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IUserRole\"\n            },\n            \"description\": \"Array of role entities for administrative/user assignment purposes.\"\n          }\n        },\n        \"description\": \"Paginated wrapper of user roles, for admin lookup and registration dropdowns.\\n\\nImplements standard IPage format with list of IUserRole.\",\n        \"required\": [\n          \"pagination\",\n          \"data\"\n        ]\n      },\n      \"IUserRole\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"Unique ID for this user role entry.\\n\\nPrimary key in user_roles. Required for all entity referencing (assignment, lookup, etc.).\"\n          },\n          \"name\": {\n            \"type\": \"string\",\n            \"description\": \"Machine- and human-readable name for the user role, e.g., 'member', 'moderator', or 'administrator'.\\n\\nMust be unique, and required for referential integrity.\"\n          },\n          \"description\": {\n            \"type\": \"string\",\n            \"description\": \"Human explanation of what privileges and duties this role holds.\\n\\nAids in assigning and documenting permissions for users. Required for compliance with admin/business rule traceability.\"\n          },\n          \"users\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IUser.ISummary\"\n            },\n            \"description\": \"(For reference/audit) Array of users holding this role. May be omitted if not required at runtime.\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"name\",\n          \"description\"\n        ],\n        \"description\": \"Full user role entity, as per user_roles Prisma model. Details all privilege/permission details, assignment context, and required unique properties.\"\n      },\n      \"IUserRole.ICreate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"name\": {\n            \"type\": \"string\",\n            \"description\": \"Unique name for new role; will become user_roles.name. E.g., 'moderator', 'editor', or custom label.\"\n          },\n          \"description\": {\n            \"type\": \"string\",\n            \"description\": \"Text description covering what the role enables/limits for users assigned to it.\"\n          }\n        },\n        \"required\": [\n          \"name\",\n          \"description\"\n        ],\n        \"description\": \"Request schema for creating new user roles.\\n\\nAllows admin tools to set up new permissions/policies in the board, with full business rule auditing.\"\n      },\n      \"IUserRole.IUpdate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"name\": {\n            \"type\": \"string\",\n            \"description\": \"(Optional) New/updated role name. Must remain unique if updated.\"\n          },\n          \"description\": {\n            \"type\": \"string\",\n            \"description\": \"(Optional) Update/extend role meaning or allowed actions.\"\n          }\n        },\n        \"required\": [],\n        \"description\": \"Request schema for editing an existing user role entry.\\n\\nAll fields optional; only modified fields must be sent.\"\n      },\n      \"IUserRole.IDeleteResponse\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"ID of user role entry deleted or marked deleted. For audit and post-delete reference.\"\n          },\n          \"status\": {\n            \"type\": \"string\",\n            \"description\": \"Delete or audit status: e.g., 'deleted', 'archived', 'in use - not deleted'.\"\n          }\n        },\n        \"description\": \"Response schema for confirming user role deletion (admin-only).\\n\\nIncludes minimal info required for audit logs and error/success reporting.\",\n        \"required\": []\n      },\n      \"IPage.IPagination\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"current\": {\n            \"type\": \"integer\",\n            \"format\": \"uint32\",\n            \"description\": \"Current page number.\"\n          },\n          \"limit\": {\n            \"type\": \"integer\",\n            \"format\": \"uint32\",\n            \"description\": \"Limitation of records per a page. Default: 100.\"\n          },\n          \"records\": {\n            \"type\": \"integer\",\n            \"format\": \"uint32\",\n            \"description\": \"Total records in the database.\"\n          },\n          \"pages\": {\n            \"type\": \"integer\",\n            \"format\": \"uint32\",\n            \"description\": \"Total number of pages (records/limit, ceiled).\"\n          }\n        },\n        \"required\": [\n          \"current\",\n          \"limit\",\n          \"records\",\n          \"pages\"\n        ],\n        \"description\": \"Pagination metadata for paged responses, including current/limit/total/pageCount as per business requirements and search usability.\"\n      },\n      \"ICategory.IRequest\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"name\": {\n            \"type\": \"string\",\n            \"description\": \"필터링 또는 검색을 위한 카테고리 이름입니다.\\n\\n예: '정치', '경제'\"\n          },\n          \"description\": {\n            \"type\": \"string\",\n            \"description\": \"카테고리 설명의 검색을 위한 옵션 필드입니다.\\n\\n예: '정치 체계와 관련된 논의', '국제 경제 토론'\"\n          },\n          \"created_from\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"description\": \"검색 시작일자(ISO8601 형식). 예: '2024-06-09T00:00:00+09:00'.\"\n          },\n          \"created_to\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"description\": \"검색 종료일자(ISO8601 형식). 예: '2024-07-09T23:59:59+09:00'.\"\n          },\n          \"page\": {\n            \"type\": \"integer\",\n            \"description\": \"페이지 번호(1부터 시작).\",\n            \"minimum\": 1\n          },\n          \"limit\": {\n            \"type\": \"integer\",\n            \"description\": \"페이지당 반환할 레코드 수(기본값 100).\",\n            \"minimum\": 1\n          }\n        },\n        \"description\": \"카테고리 리스트/검색 요청에 이용되는 필터, 검색, 페이징 정보 객체입니다.\\n\\n카테고리 명, 설명, 기간 필터, 페이징 조작(페이지, limit) 등 검색 옵션을 다루며, 관리자 또는 일반 사용자의 카테고리 목록 검색 시 활용됩니다.\",\n        \"required\": [\n          \"page\",\n          \"limit\"\n        ]\n      },\n      \"IPageICategory\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"pagination\": {\n            \"$ref\": \"#/components/schemas/IPage.IPagination\",\n            \"description\": \"페이지네이션 정보로, 현재 페이지, 전체 레코드 수, 전체 페이지 수 등을 제공합니다.\"\n          },\n          \"data\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/ICategory\"\n            },\n            \"description\": \"카테고리 목록 데이터 배열입니다.\"\n          }\n        },\n        \"description\": \"카테고리 검색/조회 결과를 담는 페이지 컨테이너 타입입니다.\\n\\n페이지네이션 메타데이터와 함께 실제 데이터 목록(카테고리 배열)을 포함해, 목록 화면 및 검색 결과에서 활용합니다.\",\n        \"required\": [\n          \"pagination\",\n          \"data\"\n        ]\n      },\n      \"ICategory\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"카테고리의 고유 식별자(UUID).\\n\\nPrisma 'categories.id' 컬럼. 예: 'b4682df2-b264-4e1b-807d-381340390a64'.\"\n          },\n          \"name\": {\n            \"type\": \"string\",\n            \"description\": \"카테고리 이름(고유).\\n\\nPrisma 'categories.name' 컬럼. 예: '정치', '경제'\"\n          },\n          \"description\": {\n            \"type\": \"string\",\n            \"description\": \"카테고리 상세 설명.\\n\\nPrisma 'categories.description' 컬럼. 예: '정치 제도와 관련된 모든 주제를 다룹니다.'\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"description\": \"카테고리 생성 일시(ISO8601).\\n\\nPrisma 'categories.created_at' 컬럼. 예: '2024-06-09T09:00:00+09:00'.\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"name\",\n          \"description\",\n          \"created_at\"\n        ],\n        \"description\": \"토론 게시판의 주제분류(카테고리) 정보를 담는 엔터티입니다.\\n\\n각 카테고리는 고유명, 설명, 생성일시 필드를 가지며 게시글(Posts)과 1:N 관계입니다. 관리자가 생성·관리하며, 게시글 작성 시 반드시 할당해야 하는 구조입니다.\"\n      },\n      \"ICategory.ICreate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"name\": {\n            \"type\": \"string\",\n            \"description\": \"신규 카테고리의 이름(고유). 예: '시사', '국제'.\"\n          },\n          \"description\": {\n            \"type\": \"string\",\n            \"description\": \"카테고리 상세 설명. 예: '글로벌 경제 및 정치 이슈를 다루는 공간입니다.'\"\n          }\n        },\n        \"required\": [\n          \"name\",\n          \"description\"\n        ],\n        \"description\": \"카테고리 신규 생성시 전달하는 요청 바디 객체입니다.\\n\\n이름(고유), 설명을 필수로 제공해야 하며, 관리자가 카테고리를 추가할 때 활용됩니다.\"\n      },\n      \"ICategory.IUpdate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"name\": {\n            \"type\": \"string\",\n            \"description\": \"변경할 카테고리명(옵션). 예: '사회'\"\n          },\n          \"description\": {\n            \"type\": \"string\",\n            \"description\": \"변경할 카테고리 설명(옵션).\"\n          }\n        },\n        \"description\": \"기존 카테고리의 이름·설명을 수정하는 요청 바디입니다.\\n\\n두 필드 모두 선택적이며, 하나 또는 모두 변경할 수 있습니다.\",\n        \"required\": []\n      },\n      \"ICategory.IDeleteResult\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"success\": {\n            \"type\": \"boolean\",\n            \"description\": \"삭제 성공 여부. true 이면 정상 삭제, false 이면 오류.\"\n          },\n          \"message\": {\n            \"type\": \"string\",\n            \"description\": \"삭제 결과 메시지(실패 이유, 성공 안내 등).\"\n          }\n        },\n        \"required\": [\n          \"success\",\n          \"message\"\n        ],\n        \"description\": \"카테고리 삭제(soft/hard delete) 결과를 나타내는 오브젝트입니다.\\n\\n성공/실패의 플래그 및 설명 메시지를 포함해 후처리 사용자 안내에 활용합니다.\"\n      },\n      \"IPost.IRequest\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"category_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"검색/필터링용 카테고리 ID.\\n\\n특정 카테고리 내 게시글만 조회하고자 할 때 사용합니다.\"\n          },\n          \"user_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"검색/필터링용 작성자(유저) ID.\\n\\n특정 사용자가 작성한 게시글만 조회할 때 활용합니다.\"\n          },\n          \"title\": {\n            \"type\": \"string\",\n            \"description\": \"제목 키워드 검색 (부분 일치 허용).\\n\\n게시글의 제목에 포함된 키워드로 검색합니다.\"\n          },\n          \"content\": {\n            \"type\": \"string\",\n            \"description\": \"본문 키워드 검색 (부분 일치 허용).\\n\\n게시글의 전체 텍스트에서 키워드로 검색합니다.\"\n          },\n          \"created_from\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"description\": \"게시글 생성 시작일(검색 필터용, ISO8601).\"\n          },\n          \"created_to\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"description\": \"게시글 생성 종료일(검색 필터용, ISO8601).\"\n          },\n          \"page\": {\n            \"type\": \"integer\",\n            \"description\": \"페이지 번호(1 이상).\",\n            \"minimum\": 1\n          },\n          \"limit\": {\n            \"type\": \"integer\",\n            \"description\": \"페이지당 데이터 수(기본 100).\",\n            \"minimum\": 1\n          }\n        },\n        \"description\": \"게시글 검색, 필터, 페이징에 요청 정보로 사용되는 객체입니다.\\n\\n카테고리, 작성자, 키워드, 기간, 페이징 등 다양한 필터를 지원하여 게시글 탐색 UX를 구현합니다.\",\n        \"required\": [\n          \"page\",\n          \"limit\"\n        ]\n      },\n      \"IPageIPost\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"pagination\": {\n            \"$ref\": \"#/components/schemas/IPage.IPagination\",\n            \"description\": \"페이지네이션 메타데이터\"\n          },\n          \"data\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IPost\"\n            },\n            \"description\": \"검색 결과 게시글(Posts) 배열\"\n          }\n        },\n        \"required\": [\n          \"pagination\",\n          \"data\"\n        ],\n        \"description\": \"게시글 검색/조회 결과를 담는 페이지 컨테이너 타입입니다.\\n\\n페이지 정보와 게시글 배열을 함께 반환하여 결과 화면에서 활용합니다.\"\n      },\n      \"IPost\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"게시글의 고유 ID (Prisma 'posts.id').\"\n          },\n          \"user_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"작성자(유저) ID (Prisma 'posts.user_id').\"\n          },\n          \"category_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"카테고리 ID (Prisma 'posts.category_id').\"\n          },\n          \"title\": {\n            \"type\": \"string\",\n            \"description\": \"게시글 제목 (Prisma 'posts.title').\"\n          },\n          \"content\": {\n            \"type\": \"string\",\n            \"description\": \"게시글 본문 (Prisma 'posts.content').\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"description\": \"생성 시각 (Prisma 'posts.created_at').\"\n          },\n          \"updated_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"description\": \"수정 시각 (Prisma 'posts.updated_at').\"\n          },\n          \"deleted_at\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"format\": \"date-time\",\n                \"description\": \"삭제(soft delete) 시각(Prisma 'posts.deleted_at'). 삭제 안된 경우 null.\"\n              },\n              {\n                \"type\": \"null\"\n              }\n            ],\n            \"description\": \"삭제(soft delete) 시각(Prisma 'posts.deleted_at'). 삭제 안된 경우 null.\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"user_id\",\n          \"category_id\",\n          \"title\",\n          \"content\",\n          \"created_at\",\n          \"updated_at\"\n        ],\n        \"description\": \"토론 게시판의 게시글(포스트) 정보를 담는 도메인 오브젝트입니다.\\n\\n작성자, 카테고리, 제목·본문, 생성/수정/삭제일 등을 보유하여 커뮤니티 핵심 콘텐츠 구조를 이룹니다.\"\n      },\n      \"IPost.ICreate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"category_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"작성할 게시글의 카테고리 ID. (필수)\"\n          },\n          \"title\": {\n            \"type\": \"string\",\n            \"description\": \"게시글 제목. 예: '2025년 물가·인플레이션 전망'\"\n          },\n          \"content\": {\n            \"type\": \"string\",\n            \"description\": \"게시글 본문 내용. (텍스트·포맷팅 지원)\"\n          },\n          \"user_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"작성자(Author) ID. 회원 작성 시 필수\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"description\": \"생성시각 (시스템 자동 할당이지만, 조직 배치용으로도 허용될 수 있음)\"\n          }\n        },\n        \"required\": [\n          \"category_id\",\n          \"title\",\n          \"content\",\n          \"user_id\"\n        ],\n        \"description\": \"게시글 신규 작성 요청에 전달되는 바디입니다.\\n\\n카테고리, 제목, 본문, 작성자 정보를 반드시 포함해야 합니다. 생성일시 등은 서버에서 자동 처리합니다.\"\n      },\n      \"IPost.IUpdate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"title\": {\n            \"type\": \"string\",\n            \"description\": \"변경할 게시글 제목 (옵션)\"\n          },\n          \"content\": {\n            \"type\": \"string\",\n            \"description\": \"변경할 게시글 본문 (옵션)\"\n          },\n          \"category_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"변경할 카테고리 ID (옵션)\"\n          }\n        },\n        \"description\": \"기존 게시글(포스트)의 제목/본문/카테고리를 수정하는 요청 바디입니다.\\n\\n각 필드는 선택값으로, 일부만 수정 가능하며 누락시 기존 값 유지합니다.\",\n        \"required\": []\n      },\n      \"IPost.IDeleteResult\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"success\": {\n            \"type\": \"boolean\",\n            \"description\": \"삭제(Soft 또는 Hard) 성공 여부\"\n          },\n          \"message\": {\n            \"type\": \"string\",\n            \"description\": \"삭제 결과 메시지\"\n          }\n        },\n        \"required\": [\n          \"success\",\n          \"message\"\n        ],\n        \"description\": \"게시글 삭제(soft/hard) 요청 결과나 상태를 반환하는 결과 객체입니다.\\n\\n정상 삭제(숨김) 시 success=true, 실패 시 false와 설명 메시지를 제공합니다.\"\n      },\n      \"IComment.IRequest\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"postId\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"The unique ID of the target post to which comments should be filtered.\\n\\nBased on the comments table, 'post_id' field links the comment to a particular post for thread-based filtering. Sourced from the business rule: 'Each Comment is linked to a Post.'\"\n          },\n          \"userId\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"The unique ID of the user who authored comments.\\n\\nDesigned for filtering comments made by a specific user, as referenced in the comments.user_id column.\"\n          },\n          \"parentId\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"format\": \"uuid\",\n                \"description\": \"The parent comment's ID, for retrieving or searching nested replies.\\n\\nThis relates to the self-referential thread system: filtering for replies to a specific comment.\"\n              },\n              {\n                \"type\": \"null\"\n              }\n            ],\n            \"description\": \"The parent comment's ID, for retrieving or searching nested replies.\\n\\nThis relates to the self-referential thread system: filtering for replies to a specific comment.\"\n          },\n          \"search\": {\n            \"type\": \"string\",\n            \"description\": \"A keyword or phrase to search in comment content.\\n\\nImplements full-text search capability as referenced in content field and API description.\"\n          },\n          \"offset\": {\n            \"type\": \"integer\",\n            \"format\": \"int32\",\n            \"default\": 0,\n            \"description\": \"The starting index for pagination.\\n\\nAllows skipping records in list pagination, supporting usability in large thread navigation.\"\n          },\n          \"limit\": {\n            \"type\": \"integer\",\n            \"format\": \"int32\",\n            \"default\": 20,\n            \"description\": \"Maximum number of records to return per page. Defaults to 20 if not specified.\"\n          },\n          \"sort\": {\n            \"type\": \"string\",\n            \"description\": \"Sorting order or field, e.g., 'created_at:desc', 'created_at:asc'.\\n\\nAligns with thread listing sorting as described in business and API requirements.\"\n          }\n        },\n        \"description\": \"Defines filtering, pagination, and sorting criteria for retrieving comments. Fields draw directly from the requirements and Prisma comments model.\\n\\nThis allows filtering by comments made on a post, by a user, or as replies to a parent, along with keyword search and pagination. Reflects full API and business use cases for comment listing endpoints.\",\n        \"required\": []\n      },\n      \"IPageIComment\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"pagination\": {\n            \"$ref\": \"#/components/schemas/IPage.IPagination\"\n          },\n          \"data\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IComment.ISummary\"\n            },\n            \"description\": \"A list of comment summary objects on the current page.\\n\\nEach item is a concise representation of a comment as described in business use-cases: post/reply thread listings.\"\n          }\n        },\n        \"required\": [\n          \"pagination\",\n          \"data\"\n        ],\n        \"description\": \"A paginated list of comment summaries, including pagination metadata (page, limit, total, etc.) and a summary array.\\n\\nCombines IPage (standard) with IComment.ISummary as required by comment browsing scenarios.\"\n      },\n      \"IComment\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"Primary Key. Unique identifier for each comment (see comments.id in schema).\\n\\nAssigned at creation; required for retrieval, update, and reference by other entities (votes, replies).\"\n          },\n          \"user_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"Author's {@link users.id}.\\n\\nStores the user's unique identifier responsible for the comment, using the relationship to users. Enables auditing, author lookup, and permissions checks.\"\n          },\n          \"post_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"The ID of the post this comment is attached to ({@link posts.id}).\\n\\nCrucial for associating the comment as a reply to a given post, reflecting business rules and ERD documentation.\"\n          },\n          \"parent_id\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"format\": \"uuid\",\n                \"description\": \"Parent comment's {@link comments.id}.\\n\\nUsed for nested (threaded) replies. Null for top-level comments. Enables tree-based conversations.\"\n              },\n              {\n                \"type\": \"null\"\n              }\n            ],\n            \"description\": \"Parent comment's {@link comments.id}.\\n\\nUsed for nested (threaded) replies. Null for top-level comments. Enables tree-based conversations.\"\n          },\n          \"content\": {\n            \"type\": \"string\",\n            \"description\": \"Main text of the comment; user-provided reply content.\\n\\nReferences the comments.content field; holds message body visible to users.\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"description\": \"Timestamp when the comment was first authored (see comments.created_at).\\n\\nUsed for chronological ordering, moderation, and audit.\"\n          },\n          \"updated_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"description\": \"Timestamp of last edit to the comment (see comments.updated_at).\\n\\nEnables edit history, moderation, or user accountability.\"\n          },\n          \"deleted_at\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"format\": \"date-time\",\n                \"description\": \"Soft deletion timestamp (see comments.deleted_at).\\n\\nNull if not deleted; otherwise contains date/time when marked deleted for moderation/auditing.\"\n              },\n              {\n                \"type\": \"null\"\n              }\n            ],\n            \"description\": \"Soft deletion timestamp (see comments.deleted_at).\\n\\nNull if not deleted; otherwise contains date/time when marked deleted for moderation/auditing.\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"user_id\",\n          \"post_id\",\n          \"content\",\n          \"created_at\",\n          \"updated_at\"\n        ],\n        \"description\": \"Represents a Comment record, as per the Posts domain comments model and requirements analysis.\\n\\nIncludes all primary properties as described in the Prisma schema, with full typing and references to related entities (users, posts, parent comments). Supports auditability, moderation, and business logic for threaded conversations.\"\n      },\n      \"IComment.ICreate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"user_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"User ID (author's identifier). Must reference an existing user. Required to ensure only registered users may comment.\\n\\nFulfills business rule that only registered users can create comments.\"\n          },\n          \"post_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"ID of the post this comment is on. Implements business rule requiring every comment to be attached to a post.\"\n          },\n          \"parent_id\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"format\": \"uuid\",\n                \"description\": \"Parent comment's ID for nested replies. Optional. Enables thread hierarchy as in the business requirements.\"\n              },\n              {\n                \"type\": \"null\"\n              }\n            ],\n            \"description\": \"Parent comment's ID for nested replies. Optional. Enables thread hierarchy as in the business requirements.\"\n          },\n          \"content\": {\n            \"type\": \"string\",\n            \"description\": \"Main comment body text. Required; validated for length and content rules by business logic.\"\n          }\n        },\n        \"required\": [\n          \"user_id\",\n          \"post_id\",\n          \"content\"\n        ],\n        \"description\": \"Object for creating a new comment. Includes required properties for new replies, including references to post, author, and optionally a parent for nested threading. Matches business rules requiring each comment to have an associated user (author) and post, plus the option to nest under another comment.\"\n      },\n      \"IComment.IUpdate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"content\": {\n            \"type\": \"string\",\n            \"description\": \"New comment body, if editing. Must meet length/content requirements from business logic.\"\n          },\n          \"deleted_at\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"format\": \"date-time\",\n                \"description\": \"Timestamp for marking a comment as deleted (for moderation/audit). Set to current time for 'soft delete,' or null to un-delete if allowed.\"\n              },\n              {\n                \"type\": \"null\"\n              }\n            ],\n            \"description\": \"Timestamp for marking a comment as deleted (for moderation/audit). Set to current time for 'soft delete,' or null to un-delete if allowed.\"\n          }\n        },\n        \"description\": \"Object for updating an existing comment (edit or soft-delete). User or moderator may use this to change content or to mark the comment as deleted.\\n\\nReferences the comments Prisma model and moderation business rules: only content or soft-delete flag is usually editable.\",\n        \"required\": []\n      },\n      \"IComment.IDeleteResult\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"ID of the comment that was deleted.\"\n          },\n          \"deleted\": {\n            \"type\": \"boolean\",\n            \"description\": \"Status: true if successfully deleted (soft or hard as per policy), false otherwise.\"\n          },\n          \"message\": {\n            \"type\": \"string\",\n            \"description\": \"A confirmation or informative message about the deletion result.\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"deleted\"\n        ],\n        \"description\": \"Result object for delete operations on comments. Confirms deletion (soft or hard), as required by business rules and audit requirements. Returns the comment ID, deletion status, and optional human-readable message.\"\n      },\n      \"IVote.IRequest\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"userId\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"Unique identifier of the user who cast the vote. Used for filtering votes by a specific voter (see votes.user_id in schema and ERD).\"\n          },\n          \"postId\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"format\": \"uuid\",\n                \"description\": \"Unique identifier of the post that received the vote (see votes.post_id). Mutually exclusive with commentId.\"\n              },\n              {\n                \"type\": \"null\"\n              }\n            ],\n            \"description\": \"Unique identifier of the post that received the vote (see votes.post_id). Mutually exclusive with commentId.\"\n          },\n          \"commentId\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"format\": \"uuid\",\n                \"description\": \"Unique identifier of the comment that received the vote (see votes.comment_id). Mutually exclusive with postId.\"\n              },\n              {\n                \"type\": \"null\"\n              }\n            ],\n            \"description\": \"Unique identifier of the comment that received the vote (see votes.comment_id). Mutually exclusive with postId.\"\n          },\n          \"offset\": {\n            \"type\": \"integer\",\n            \"format\": \"int32\",\n            \"default\": 0,\n            \"description\": \"Starting index for pagination (default 0).\"\n          },\n          \"limit\": {\n            \"type\": \"integer\",\n            \"format\": \"int32\",\n            \"default\": 20,\n            \"description\": \"Maximum number of records to return per page.\"\n          },\n          \"sort\": {\n            \"type\": \"string\",\n            \"description\": \"Sorting field or order (default 'created_at:desc').\"\n          }\n        },\n        \"description\": \"Filtering, pagination, and sorting criteria for votes listing requests, following the votes table business logic and related requirements.\\n\\nFilters support querying by voter, target post, or comment, with support for pagination and sorting. Business rules enforce only mutual exclusivity between postId/commentId (never both set).\",\n        \"required\": []\n      },\n      \"IPageIVote\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"pagination\": {\n            \"$ref\": \"#/components/schemas/IPage.IPagination\"\n          },\n          \"data\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IVote.ISummary\"\n            },\n            \"description\": \"Array of vote summary records on this page.\"\n          }\n        },\n        \"required\": [\n          \"pagination\",\n          \"data\"\n        ],\n        \"description\": \"A paginated set of votes, as used in vote listing, audit history, or analytics use-cases. Follows IPage pattern with IVote.ISummary records per voting business and DB design.\"\n      },\n      \"IVote\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"Primary Key. Unique identifier for each vote record (votes.id).\"\n          },\n          \"user_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"The ID of the user casting the vote (votes.user_id), referencing users table for author.\"\n          },\n          \"post_id\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"format\": \"uuid\",\n                \"description\": \"The voted post's ID (votes.post_id). Mutually exclusive with comment_id.\"\n              },\n              {\n                \"type\": \"null\"\n              }\n            ],\n            \"description\": \"The voted post's ID (votes.post_id). Mutually exclusive with comment_id.\"\n          },\n          \"comment_id\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"format\": \"uuid\",\n                \"description\": \"The voted comment's ID (votes.comment_id). Mutually exclusive with post_id.\"\n              },\n              {\n                \"type\": \"null\"\n              }\n            ],\n            \"description\": \"The voted comment's ID (votes.comment_id). Mutually exclusive with post_id.\"\n          },\n          \"value\": {\n            \"type\": \"integer\",\n            \"description\": \"Value of the vote (+1 for upvote, -1 for downvote). Aggregated to compute content rankings.\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"description\": \"Timestamp of when the vote was created (votes.created_at).\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"user_id\",\n          \"value\",\n          \"created_at\"\n        ],\n        \"description\": \"Represents a Vote as defined in the votes table: one record for each upvote/downvote action on a post or comment. Covers voter ID, target (post or comment), value (+1/-1), and creation timestamp. Fully aligned with requirements analysis and business logic for single-vote-per-user-per-content.\"\n      },\n      \"IVote.ICreate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"user_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"ID of the user casting the vote. References the users table; ensures only registered users can vote.\"\n          },\n          \"value\": {\n            \"type\": \"integer\",\n            \"description\": \"Vote value: +1 or -1 as per business requirements. Used for up/down voting of posts/comments.\"\n          },\n          \"post_id\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"format\": \"uuid\",\n                \"description\": \"Target post's ID, if voting on a post. Mutually exclusive with comment_id.\"\n              },\n              {\n                \"type\": \"null\"\n              }\n            ],\n            \"description\": \"Target post's ID, if voting on a post. Mutually exclusive with comment_id.\"\n          },\n          \"comment_id\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"format\": \"uuid\",\n                \"description\": \"Target comment's ID, if voting on a comment. Mutually exclusive with post_id.\"\n              },\n              {\n                \"type\": \"null\"\n              }\n            ],\n            \"description\": \"Target comment's ID, if voting on a comment. Mutually exclusive with post_id.\"\n          }\n        },\n        \"required\": [\n          \"user_id\",\n          \"value\"\n        ],\n        \"description\": \"Object for creating a new vote as per voting business rules:\\n- user_id: registered voter\\n- value: +1 (upvote) or -1 (downvote)\\n- target: must specify either post_id or comment_id (never both)\\nEnforces one vote per user/content as described in requirements.\"\n      },\n      \"IVote.IUpdate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"value\": {\n            \"type\": \"integer\",\n            \"description\": \"The new vote value. Allows changing an upvote to downvote (or vice versa), strictly for existing votes per business rules.\"\n          }\n        },\n        \"required\": [\n          \"value\"\n        ],\n        \"description\": \"Object for updating existing votes, specifically editing the vote value (from +1 to -1, etc.).\\n\\nDoes not allow changing the vote target (post_id/comment_id); supports audit and business logic for corrections.\"\n      },\n      \"IVote.IDeleteResult\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"ID of the vote record that was deleted.\"\n          },\n          \"deleted\": {\n            \"type\": \"boolean\",\n            \"description\": \"Indicates if the vote was successfully deleted.\"\n          },\n          \"message\": {\n            \"type\": \"string\",\n            \"description\": \"A human-readable confirmation message about the delete operation.\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"deleted\"\n        ],\n        \"description\": \"Delete operation result for a vote record. Returns deleted vote's ID, deletion status, and optional result message, as required by business logic and for user/admin confirmation.\"\n      },\n      \"IComment.ISummary\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"Unique identifier for the comment.\"\n          },\n          \"user_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"User (author) of the comment.\"\n          },\n          \"post_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"Parent post for the comment.\"\n          },\n          \"parent_id\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"format\": \"uuid\",\n                \"description\": \"Parent comment (if any).\"\n              },\n              {\n                \"type\": \"null\"\n              }\n            ],\n            \"description\": \"Parent comment (if any).\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"description\": \"Timestamp of comment creation.\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"user_id\",\n          \"post_id\",\n          \"created_at\"\n        ],\n        \"description\": \"A concise summary type for comments, covering the most important references and metadata for paginated or overview lists.\"\n      },\n      \"IVote.ISummary\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"Unique identifier for the vote.\"\n          },\n          \"user_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"Voter's user ID.\"\n          },\n          \"post_id\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"format\": \"uuid\",\n                \"description\": \"Target post.\"\n              },\n              {\n                \"type\": \"null\"\n              }\n            ],\n            \"description\": \"Target post.\"\n          },\n          \"comment_id\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"format\": \"uuid\",\n                \"description\": \"Target comment.\"\n              },\n              {\n                \"type\": \"null\"\n              }\n            ],\n            \"description\": \"Target comment.\"\n          },\n          \"value\": {\n            \"type\": \"integer\",\n            \"description\": \"Vote value (+1 or -1).\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"user_id\",\n          \"value\"\n        ],\n        \"description\": \"Summary of a Vote for paginated/result lists, not including creation date but identifying all main relationships and value.\"\n      }\n    }\n  },\n  \"x-samchon-emended-v4\": true\n}",
  "test/features/api/user/test_list_users_with_various_filters_and_pagination.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\n\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport { IPageIUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIUser\";\n\nexport async function test_list_users_with_various_filters_and_pagination(connection: api.IConnection): Promise<void> {\n  // 1. No filters (default pagination)\n  const resDefault = await api.functional.core.users.patch(connection, {\n    body: {},\n  });\n  typia.assert<IPageIUser.ISummary>(resDefault);\n  TestValidator.predicate(\"default result data is array\")(() => Array.isArray(resDefault.data));\n  TestValidator.predicate(\"default pagination current >= 1\")(() => resDefault.pagination.current >= 1);\n\n  // 2. Specific page and limit\n  const resPage2 = await api.functional.core.users.patch(connection, {\n    body: { page: 2, limit: 1 },\n  });\n  typia.assert<IPageIUser.ISummary>(resPage2);\n  TestValidator.equals(\"pagination current page\", undefined)(resPage2.pagination.current)(2);\n  TestValidator.equals(\"pagination limit\", undefined)(resPage2.pagination.limit)(1);\n  TestValidator.predicate(\"data is array for page 2, limit 1\")(() => Array.isArray(resPage2.data));\n\n  // 3. Filter by fake username (should return empty data)\n  const resNotFound = await api.functional.core.users.patch(connection, {\n    body: { search: \"this_user_does_not_exist_123!@#\" },\n  });\n  typia.assert<IPageIUser.ISummary>(resNotFound);\n  TestValidator.equals(\"no result for impossible search\")([] as IUser.ISummary[])(resNotFound.data);\n\n  // 4. Filter by random/unknown role (should return empty result)\n  const resFakeRole = await api.functional.core.users.patch(connection, {\n    body: { role: \"00000000-0000-0000-0000-000000000000\" },\n  });\n  typia.assert<IPageIUser.ISummary>(resFakeRole);\n  TestValidator.equals(\"no result for fake role\")([] as IUser.ISummary[])(resFakeRole.data);\n\n  // 5. Filter by impossible status (should return empty)\n  const resFakeStatus = await api.functional.core.users.patch(connection, {\n    body: { status: \"_____totallyFakeStatus_____\" },\n  });\n  typia.assert<IPageIUser.ISummary>(resFakeStatus);\n  TestValidator.equals(\"no result for impossible status\")([] as IUser.ISummary[])(resFakeStatus.data);\n\n  // 6. Invalid negative page value (should be handled with error or fallback)\n  await TestValidator.httpError(\"negative page handled\")(400)(async () => {\n    await api.functional.core.users.patch(connection, {\n      body: { page: -1 },\n    });\n  });\n}\n",
  "test/features/api/user/test_search_users_with_role_and_keyword_filters.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport { IUserRole } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUserRole\";\nimport { IPageIUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIUser\";\nimport typia from \"typia\";\n\nexport async function test_search_users_with_role_and_keyword_filters(connection: api.IConnection): Promise<void> {\n  // 1. Create roles\n  const memberRole: IUserRole = await api.functional.core.userRoles.post(connection, {\n    body: { name: \"Member\", description: \"Standard member role\" }\n  });\n  const moderatorRole: IUserRole = await api.functional.core.userRoles.post(connection, {\n    body: { name: \"Moderator\", description: \"Moderator role\" }\n  });\n\n  // 2. Create users\n  // Member: 'alice', 'bob', Moderator: 'alicemod', 'charlie'\n  const userMemberAlice: IUser = await api.functional.core.users.post(connection, {\n    body: {\n      user_role_id: memberRole.id,\n      username: \"alice\",\n      email: \"alice@example.com\",\n      password: \"Password1!\",\n      status: \"active\"\n    }\n  });\n  const userMemberBob: IUser = await api.functional.core.users.post(connection, {\n    body: {\n      user_role_id: memberRole.id,\n      username: \"bob\",\n      email: \"bob@example.com\",\n      password: \"Password1!\",\n      status: \"active\"\n    }\n  });\n  const userModAlicemod: IUser = await api.functional.core.users.post(connection, {\n    body: {\n      user_role_id: moderatorRole.id,\n      username: \"alicemod\",\n      email: \"alicemod@example.com\",\n      password: \"Password1!\",\n      status: \"active\"\n    }\n  });\n  const userModCharlie: IUser = await api.functional.core.users.post(connection, {\n    body: {\n      user_role_id: moderatorRole.id,\n      username: \"charlie\",\n      email: \"charlie@example.com\",\n      password: \"Password1!\",\n      status: \"active\"\n    }\n  });\n  \n  // 3. Filter by role: should return only memberRole's users\n  const byRole: IPageIUser.ISummary = await api.functional.core.users.patch(connection, {\n    body: { role: memberRole.id }\n  });\n  typia.assert<IPageIUser.ISummary>(byRole);\n  TestValidator.predicate(\"All users are members\")(byRole.data.every(u => u.role.id === memberRole.id));\n  TestValidator.equals(\"Only alice and bob returned by role\")([\n    userMemberAlice.username,\n    userMemberBob.username\n  ].sort())(byRole.data.map(u => u.username).sort());\n\n  // 4. Search by partial username (ali): should get 'alice', 'alicemod'\n  const byPartial: IPageIUser.ISummary = await api.functional.core.users.patch(connection, {\n    body: { search: \"ali\" }\n  });\n  typia.assert<IPageIUser.ISummary>(byPartial);\n  const expectedAli = [userMemberAlice.username, userModAlicemod.username].sort();\n  TestValidator.equals(\"Search by 'ali'\")(expectedAli)(byPartial.data.map(u => u.username).filter(x => x.includes(\"ali\")).sort());\n\n  // 5. Combined: role=Member and search='ali' (should return only 'alice')\n  const byRoleAndPartial: IPageIUser.ISummary = await api.functional.core.users.patch(connection, {\n    body: { role: memberRole.id, search: \"ali\" }\n  });\n  typia.assert<IPageIUser.ISummary>(byRoleAndPartial);\n  TestValidator.equals(\"Role member and 'ali' only alice\")([\"alice\"])(byRoleAndPartial.data.map(u => u.username));\n\n  // 6a. Edge: search by a role that does not exist – expect empty result\n  const nonexistentUUID = \"12345678-aaaa-bbbb-cccc-123456789abc\";\n  const byNonexistentRole: IPageIUser.ISummary = await api.functional.core.users.patch(connection, {\n    body: { role: nonexistentUUID }\n  });\n  typia.assert<IPageIUser.ISummary>(byNonexistentRole);\n  TestValidator.equals(\"Role does not exist returns empty\")([] as string[])(byNonexistentRole.data.map(u => u.username));\n\n  // 6b. Edge: search keyword that matches nobody (\"zzz\")\n  const byNoKeyword: IPageIUser.ISummary = await api.functional.core.users.patch(connection, {\n    body: { search: \"zzz\" }\n  });\n  typia.assert<IPageIUser.ISummary>(byNoKeyword);\n  TestValidator.equals(\"No keyword match returns empty\")([] as string[])(byNoKeyword.data.map(u => u.username));\n}\n",
  "test/features/api/user/test_retrieve_user_profile_by_id_success_and_not_found.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport typia, { tags } from \"typia\";\n\nexport async function test_retrieve_user_profile_by_id_success_and_not_found(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. Register a new user to get a valid user ID\n  const userInput: IUser.ICreate = {\n    user_role_id: typia.random<string & tags.Format<\"uuid\">>(),\n    username: `testuser_${Math.floor(Math.random() * 100000)}`,\n    email: `testuser_${Math.floor(Math.random() * 100000)}@test.com`,\n    password: \"TestPassword123!\",\n    status: \"active\",\n    bio: \"Test bio text.\",\n  };\n  const createdUser: IUser = await api.functional.core.users.post(connection, {\n    body: userInput,\n  });\n  typia.assert<IUser>(createdUser);\n\n  // 2. Retrieve user profile by ID (success)\n  const fetchedUser: IUser = await api.functional.core.users.getById(connection, {\n    id: createdUser.id,\n  });\n  typia.assert<IUser>(fetchedUser);\n\n  // 3. Validate user fields match registration input\n  TestValidator.equals(\"user id\")(createdUser.id)(fetchedUser.id);\n  TestValidator.equals(\"username\")(createdUser.username)(fetchedUser.username);\n  TestValidator.equals(\"email\")(createdUser.email)(fetchedUser.email);\n  TestValidator.equals(\"user_role_id\")(createdUser.user_role_id)(fetchedUser.user_role_id);\n  TestValidator.equals(\"bio\")(createdUser.bio)(fetchedUser.bio);\n  TestValidator.equals(\"status\")(createdUser.status)(fetchedUser.status);\n\n  // 4. Attempt to retrieve non-existent user ID (404 expected)\n  const randomUserId: string & tags.Format<\"uuid\"> = typia.random<string & tags.Format<\"uuid\">>();\n  await TestValidator.httpError(\"User not found should return 404\")(404)(async () => {\n    await api.functional.core.users.getById(connection, { id: randomUserId });\n  });\n}\n",
  "test/features/api/user/test_register_new_user_edge_and_success_cases.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport { IUserRole } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUserRole\";\nimport typia from \"typia\";\n\nexport async function test_register_new_user_edge_and_success_cases(connection: api.IConnection): Promise<void> {\n  // 1. Create unique user role\n  const userRoleInput: IUserRole.ICreate = {\n    name: `testrole_${Date.now()}_${Math.floor(Math.random()*10000)}`,\n    description: \"Test role for E2E user registration edge cases.\"\n  };\n  const userRole = await api.functional.core.userRoles.post(connection, { body: userRoleInput });\n  typia.assert<IUserRole>(userRole);\n\n  // 2. Register a new user with unique, valid data\n  const userInput: IUser.ICreate = {\n    user_role_id: userRole.id,\n    username: `testuser_${Date.now()}_${Math.floor(Math.random()*10000)}`,\n    email: `test_${Date.now()}_${Math.floor(Math.random()*10000)}@email.com`,\n    bio: \"Edge case E2E bio.\",\n    password: \"VeryS3cretPassword!\",\n    status: \"active\",\n  };\n  const user = await api.functional.core.users.post(connection, { body: userInput });\n  typia.assert<IUser>(user);\n  // The returned user should match the input except password & timestamps (and include role)\n  TestValidator.equals(\"registered username matches\")(userInput.username)(user.username);\n  TestValidator.equals(\"registered email matches\")(userInput.email)(user.email);\n  TestValidator.equals(\"registered role assignment\")(userRole.id)(user.user_role_id);\n  TestValidator.equals(\"registered status matches\")(userInput.status)(user.status);\n  TestValidator.equals(\"registered bio matches\")(userInput.bio)(user.bio);\n  typia.assert<IUserRole>(user.role);\n\n  // 3. Negative case: Missing required field (omit email)\n  const missingEmail: IUser.ICreate = { ...userInput, email: undefined as any };\n  await TestValidator.httpError(\"missing email - should toss 400/422\")(400, 422, 409)(\n    () => api.functional.core.users.post(connection, { body: missingEmail })\n  );\n  // 4. Negative: Missing username\n  const missingUsername: IUser.ICreate = { ...userInput, username: undefined as any };\n  await TestValidator.httpError(\"missing username\")(400, 422, 409)(\n    () => api.functional.core.users.post(connection, { body: missingUsername })\n  );\n  // 5. Negative: Missing password\n  const missingPassword: IUser.ICreate = { ...userInput, password: undefined as any };\n  await TestValidator.httpError(\"missing password\")(400, 422, 409)(\n    () => api.functional.core.users.post(connection, { body: missingPassword })\n  );\n  // 6. Negative: Invalid email format\n  const badEmail: IUser.ICreate = { ...userInput, email: \"not-a-valid-email\" as any };\n  await TestValidator.httpError(\"invalid email format\")(400, 422, 409)(\n    () => api.functional.core.users.post(connection, { body: badEmail })\n  );\n  // 7. Negative: Duplicate username (same as prior successful submit)\n  const duplicateUsernameInput: IUser.ICreate = {\n    ...userInput,\n    email: `unique_${Date.now()}_${Math.floor(Math.random()*10000)}@mail.com`, // allow only username to duplicate\n  };\n  await TestValidator.httpError(\"duplicate username\")(400, 422, 409)(\n    () => api.functional.core.users.post(connection, { body: duplicateUsernameInput })\n  );\n  // 8. Negative: Duplicate email (same email, new username)\n  const duplicateEmailInput: IUser.ICreate = {\n    ...userInput,\n    username: `othername_${Date.now()}_${Math.floor(Math.random()*10000)}`,\n  };\n  await TestValidator.httpError(\"duplicate email\")(400, 422, 409)(\n    () => api.functional.core.users.post(connection, { body: duplicateEmailInput })\n  );\n}\n",
  "test/features/api/user/test_update_user_profile_with_valid_and_invalid_conditions.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport { IUserRole } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUserRole\";\nimport typia from \"typia\";\n\nexport async function test_update_user_profile_with_valid_and_invalid_conditions(\n  connection: api.IConnection,\n): Promise<void> {\n  // Step 1: Create two user roles\n  const role1: IUserRole = await api.functional.core.userRoles.post(connection, {\n    body: {\n      name: `role_${Date.now()}_1`,\n      description: \"Test Role 1\",\n    },\n  });\n  const role2: IUserRole = await api.functional.core.userRoles.post(connection, {\n    body: {\n      name: `role_${Date.now()}_2`,\n      description: \"Test Role 2\",\n    },\n  });\n\n  // Step 2: Register two users\n  const user1Reg: IUser.ICreate = {\n    user_role_id: role1.id,\n    username: `user1_${Date.now()}`,\n    email: `user1_${Date.now()}@test.com`,\n    bio: \"Bio user1\",\n    password: \"strongPassword1!\",\n    status: \"active\",\n  };\n  const user2Reg: IUser.ICreate = {\n    user_role_id: role2.id,\n    username: `user2_${Date.now()}`,\n    email: `user2_${Date.now()}@test.com`,\n    bio: \"Bio user2\",\n    password: \"strongPassword2!\",\n    status: \"active\",\n  };\n  const user1: IUser = await api.functional.core.users.post(connection, { body: user1Reg });\n  const user2: IUser = await api.functional.core.users.post(connection, { body: user2Reg });\n\n  // Step 3: Positive update for user1 (change email, username, bio, role)\n  const updEmail = `new_${user1.email}`;\n  const updUsername = `upd_${user1.username}`;\n  const updBio = \"Updated Bio for user1\";\n  const updated: IUser = await api.functional.core.users.putById(connection, {\n    id: user1.id,\n    body: {\n      email: updEmail,\n      username: updUsername,\n      bio: updBio,\n      user_role_id: role2.id,\n      status: \"active\",\n    },\n  });\n  typia.assert<IUser>(updated);\n  TestValidator.equals(\"email should be updated\")<string>(updEmail)(updated.email);\n  TestValidator.equals(\"username should be updated\")<string>(updUsername)(updated.username);\n  TestValidator.equals(\"bio should be updated\")<string | null>(updBio)(updated.bio ?? null);\n  TestValidator.equals(\"role should be updated\")<string>(role2.id)(updated.user_role_id);\n\n  // Step 4: Negative - update user1 with duplicate email (from user2)\n  await TestValidator.httpError(\"duplicate email triggers conflict\")(409)(async () => {\n    await api.functional.core.users.putById(connection, {\n      id: user1.id,\n      body: { email: user2.email },\n    });\n  });\n\n  // Step 5: Negative - update user1 with duplicate username (from user2)\n  await TestValidator.httpError(\"duplicate username triggers conflict\")(409)(async () => {\n    await api.functional.core.users.putById(connection, {\n      id: user1.id,\n      body: { username: user2.username },\n    });\n  });\n\n  // Step 6: Negative - update user1 with invalid email format\n  await TestValidator.httpError(\"invalid email triggers validation error\")(400)(async () => {\n    await api.functional.core.users.putById(connection, {\n      id: user1.id,\n      body: { email: \"not-an-email\" },\n    });\n  });\n\n  // Step 7: Negative - update non-existent user (random valid UUID)\n  const fakeId = typia.random<string & typia.tags.Format<\"uuid\">>();\n  await TestValidator.httpError(\"non-existent user triggers not found\")(404)(async () => {\n    await api.functional.core.users.putById(connection, {\n      id: fakeId,\n      body: { bio: \"Any\" },\n    });\n  });\n\n  // Step 8: (Optional) Set bio to null\n  const newNullBioUpdate: IUser = await api.functional.core.users.putById(connection, {\n    id: user1.id,\n    body: { bio: null },\n  });\n  typia.assert<IUser>(newNullBioUpdate);\n  if (newNullBioUpdate.bio !== null) throw new Error(\"bio is not null\");\n  TestValidator.equals(\"bio should be null\")(null)(newNullBioUpdate.bio);\n}\n",
  "test/features/api/user/test_delete_user_soft_and_hard_and_not_found.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\n\nexport async function test_delete_user_soft_and_hard_and_not_found(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. Register a user\n  const userInput: IUser.ICreate = typia.random<IUser.ICreate>()\n  const user: IUser = await api.functional.core.users.post(connection, {\n    body: userInput,\n  });\n  typia.assert<IUser>(user);\n\n  // 2. Soft-delete the user\n  const delRes1 = await api.functional.core.users.eraseById(connection, {\n    id: user.id,\n  });\n  typia.assert<IUser.IDeleteResponse>(delRes1);\n  TestValidator.equals(\"delete user id\")<string | undefined>(delRes1.id)(user.id);\n  TestValidator.predicate(\"delete status present\")(() => !!delRes1.status);\n\n  // 3. Try deleting the same user again (should be 404 or similar error if hard delete required, or another specific error)\n  await TestValidator.httpError(\"deleting already-deleted user\")\n    (404)(() =>\n      api.functional.core.users.eraseById(connection, { id: user.id })\n    );\n\n  // 4. Delete a non-existent user (random uuid)\n  const fakeId = typia.random<string & tags.Format<\"uuid\">>();\n  await TestValidator.httpError(\"deleting non-existent user\")\n    (404)(() =>\n      api.functional.core.users.eraseById(connection, { id: fakeId })\n    );\n}\n",
  "test/features/api/user-role/test_list_user_roles_with_filters_and_pagination.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport { IUserRole } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUserRole\";\nimport { IPageIUserRole } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIUserRole\";\n\nexport async function test_list_user_roles_with_filters_and_pagination(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. Create roles with diverse data.\n  const roleInputs: IUserRole.ICreate[] = [\n    { name: \"Moderator\", description: \"Can moderate content.\" },\n    { name: \"Administrator\", description: \"Full system privileges.\" },\n    { name: \"Member\", description: \"Standard member with limited permissions.\" },\n    { name: \"Editor\", description: \"Can edit articles but not moderate.\" },\n    { name: \"Guest\", description: \"Read-only access.\" },\n  ];\n  const createdRoles: IUserRole[] = [];\n  for (const input of roleInputs) {\n    const created = await api.functional.core.userRoles.post(connection, { body: input });\n    typia.assert<IUserRole>(created);\n    createdRoles.push(created);\n  }\n\n  // 2. List all roles (no filter), expect all created roles present\n  {\n    const page = await api.functional.core.userRoles.patch(connection, { body: {} });\n    typia.assert<IPageIUserRole>(page);\n    // The minimum expectation: all created names should be present at least once\n    const listedNames = page.data.map(r => r.name);\n    for (const input of roleInputs) {\n      TestValidator.predicate(`Role '${input.name}' should be listed`)(() => listedNames.includes(input.name));\n    }\n    // No duplicates\n    const nameSet = new Set(listedNames);\n    TestValidator.equals(\"no duplicates among listed roles\")(nameSet.size)(listedNames.length);\n  }\n\n  // 3. Filter by partial role name\n  {\n    const searchKeyword = \"Mod\";\n    const page = await api.functional.core.userRoles.patch(connection, { body: { search: searchKeyword } });\n    typia.assert<IPageIUserRole>(page);\n    // Should only include 'Moderator'\n    TestValidator.predicate(\"Expect role names to match search 'Mod'\")(\n      () => page.data.every(r => r.name.includes(searchKeyword)),\n    );\n  }\n\n  // 4. Filter by description keyword\n  {\n    const searchKeyword = \"edit\"; // should match \"Editor\" and description of Editor\n    const page = await api.functional.core.userRoles.patch(connection, { body: { search: searchKeyword } });\n    typia.assert<IPageIUserRole>(page);\n    TestValidator.predicate(\"Description keyword filter 'edit'\")(\n      () => page.data.some(r => r.name === \"Editor\"),\n    );\n  }\n\n  // 5. Negative: Search that yields zero results\n  {\n    const page = await api.functional.core.userRoles.patch(connection, { body: { search: \"NonExistentRole\" } });\n    typia.assert<IPageIUserRole>(page);\n    TestValidator.equals(\"Search yielding no results\")(0)(page.data.length);\n  }\n\n  // 6. Pagination correctness (limit=2, page=2)\n  {\n    const limit = 2;\n    const pageNum = 2;\n    const page = await api.functional.core.userRoles.patch(connection, { body: { limit, page: pageNum } });\n    typia.assert<IPageIUserRole>(page);\n    // Expect limit or less results\n    TestValidator.predicate(\"Page size limit respected\")(\n      () => page.data.length <= limit,\n    );\n    // Check page metadata\n    TestValidator.equals(\"pagination current page\")(pageNum)(page.pagination.current);\n    TestValidator.equals(\"pagination limit\")(limit)(page.pagination.limit);\n    // No duplicates within this page\n    const namesInPage = page.data.map(r => r.name);\n    const nameSet = new Set(namesInPage);\n    TestValidator.equals(\"no duplicates in paged data\")(nameSet.size)(namesInPage.length);\n  }\n}\n",
  "test/features/api/user-role/test_list_user_roles_with_invalid_filter_parameters.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IUserRole } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUserRole\";\nimport typia from \"typia\";\n\nexport async function test_list_user_roles_with_invalid_filter_parameters(\n  connection: api.IConnection,\n): Promise<void> {\n  // List of invalid filter requests\n  const invalidBodies: IUserRole.IRequest[] = [\n    { page: -1 }, // negative page\n    { limit: 0 }, // zero limit\n    { limit: -100 }, // negative limit\n    { limit: 1_000_000 }, // excessive limit\n    { page: 1, search: \"a\".repeat(2_000) }, // too long search string\n  ];\n\n  // Test each invalid request and expect HTTP 400/422 error\n  for (const body of invalidBodies) {\n    await TestValidator.httpError(\"invalid userRoles filter\")\n      (400, 422)\n      (async () => {\n        await api.functional.core.userRoles.patch(connection, { body });\n      });\n  }\n\n  // Also test with totally malformed body (not matching IRequest)\n  await TestValidator.httpError(\"malformed body - not an object\")(400, 422)\n    (async () => {\n      // @ts-expect-error Intentionally wrong type\n      await api.functional.core.userRoles.patch(connection, { body: \"not-an-object\" });\n    });\n}",
  "test/features/api/user-role/test_get_user_role_by_valid_and_invalid_id_with_auth_checks.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\nimport { IUserRole } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUserRole\";\n\nexport async function test_api_user_role_getById_all_cases(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. Create a user role\n  const createInput: IUserRole.ICreate = {\n    name: `test_role_${Math.random().toString(36).substring(2, 10)}`,\n    description: \"E2E test role description.\"\n  };\n  const created: IUserRole = await api.functional.core.userRoles.post(connection, { body: createInput });\n  typia.assert<IUserRole>(created);\n\n  // 2. Retrieve the user role by valid ID\n  const retrieved: IUserRole = await api.functional.core.userRoles.getById(connection, { id: created.id });\n  typia.assert<IUserRole>(retrieved);\n  TestValidator.equals(\"getById result should match role name\")<string>(createInput.name)(retrieved.name);\n  TestValidator.equals(\"getById result should match description\")<string>(createInput.description)(retrieved.description);\n\n  // 3. Attempt to retrieve a non-existent user role (random UUID)\n  const nonExistentId = typia.random<string & tags.Format<\"uuid\">>();\n  await TestValidator.httpError(\"should be 404 for non-existent role\")(404)(\n    () => api.functional.core.userRoles.getById(connection, { id: nonExistentId })\n  );\n\n  // 4. Attempt to retrieve a user role without auth (simulate by omitting headers if possible)\n  if (connection.headers && connection.headers[\"Authorization\"]) {\n    const noAuthConnection = { ...connection, headers: { ...connection.headers } };\n    delete noAuthConnection.headers[\"Authorization\"];\n    await TestValidator.httpError(\"should require auth\")(401, 403)(\n      () => api.functional.core.userRoles.getById(noAuthConnection, { id: created.id })\n    );\n  }\n}\n",
  "test/features/api/user-role/test_get_user_role_access_forbidden_for_insufficient_privileges.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\n\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport { IUserRole } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUserRole\";\n\n/**\n * Test: Access user role as insufficient privilege user (should receive 403 Forbidden)\n */\nexport async function test_get_user_role_access_forbidden_for_insufficient_privileges(\n  connection: api.IConnection,\n): Promise<void> {\n  // Step 1: Create a custom role (assumed to lack admin privileges)\n  const roleInput: IUserRole.ICreate = {\n    name: `readonly-test-role-${Math.random().toString(36).slice(2, 10)}`,\n    description: \"Minimal-privilege test role for forbidden access test.\",\n  };\n  const userRole: IUserRole = await api.functional.core.userRoles.post(connection, { body: roleInput });\n  typia.assert<IUserRole>(userRole);\n\n  // Step 2: Register a new user with this role\n  const userInput: IUser.ICreate = {\n    user_role_id: userRole.id,\n    username: `testuser_${Math.random().toString(36).slice(2, 8)}`,\n    email: `test_${Math.random().toString(36).slice(2, 8)}@testmail.com`,\n    bio: \"Test user bio.\",\n    password: \"P@ssw0rd123!\",\n    status: \"active\",\n  };\n  const user: IUser = await api.functional.core.users.post(connection, { body: userInput });\n  typia.assert<IUser>(user);\n\n  // Step 3: Simulate as that user (replace authentication context if needed)\n  const userConnection: api.IConnection = {\n    ...connection,\n    // If authentication mechanism uses header/token, inject here:\n    // headers: { ...connection.headers, Authorization: `Bearer ${userAccessToken}` }\n    // For simulation, keep as original. Real test suite should provide session switching helpers.\n  };\n\n  // Step 4: Attempt to get role info as this user, expect 403 Forbidden\n  await TestValidator.httpError(\"Should throw 403 Forbidden when insufficient user role.\")(403)(async () => {\n    await api.functional.core.userRoles.getById(userConnection, { id: userRole.id });\n  });\n}\n",
  "test/features/api/user-role/test_create_user_role_with_valid_and_invalid_payloads.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IUserRole } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUserRole\";\nimport typia from \"typia\";\n\nexport async function test_create_user_role_with_valid_and_invalid_payloads(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. Prepare valid unique payload\n  const uniqueRoleName =\n    \"test_role_\" + Math.random().toString(36).slice(2, 10) + Date.now();\n  const validInput: IUserRole.ICreate = {\n    name: uniqueRoleName,\n    description: \"A test role for E2E validation.\" ,\n  };\n\n  // 2. Happy path: Create with valid fields\n  const created = await api.functional.core.userRoles.post(connection, { body: validInput });\n  typia.assert<IUserRole>(created);\n  TestValidator.equals(\"user role name should match\")<string>(validInput.name)(created.name);\n  TestValidator.equals(\"description should match\")<string>(validInput.description)(created.description);\n\n  // 3. Duplicate role name: should fail (uniqueness)\n  await TestValidator.httpError(\"duplicate role name returns error\")(400, 409)(async () => {\n    // Try to create a second role with the exact same name\n    await api.functional.core.userRoles.post(connection, {\n      body: validInput,\n    });\n  });\n\n  // 4. Missing required field: name omitted\n  await TestValidator.httpError(\"missing name returns error\")(400)(async () => {\n    await api.functional.core.userRoles.post(connection, {\n      body: { description: \"desc only\" } as any,\n    });\n  });\n\n  // 5. Missing required field: description omitted\n  await TestValidator.httpError(\"missing description returns error\")(400)(async () => {\n    await api.functional.core.userRoles.post(connection, {\n      body: { name: \"role_missing_desc\" } as any,\n    });\n  });\n\n  // 6. Empty string fields -- name\n  await TestValidator.httpError(\"empty name returns error\")(400)(async () => {\n    await api.functional.core.userRoles.post(connection, {\n      body: {\n        name: \"\",\n        description: \"test desc\"\n      },\n    });\n  });\n\n  // 7. Empty string fields -- description\n  await TestValidator.httpError(\"empty description returns error\")(400)(async () => {\n    await api.functional.core.userRoles.post(connection, {\n      body: {\n        name: \"role_empty_desc\",\n        description: \"\"\n      },\n    });\n  });\n}\n",
  "test/features/api/user-role/test_update_user_role_with_valid_data.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport { IUserRole } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUserRole\";\n\nexport async function test_update_user_role_with_valid_data(\n  connection: api.IConnection,\n): Promise<void> {\n  // Step 1: Create a new user role to ensure an updatable entity exists\n  const createPayload: IUserRole.ICreate = {\n    name: `test-role-${Date.now()}`,\n    description: \"A temporary test role for update E2E test.\",\n  };\n  const createdRole: IUserRole = await api.functional.core.userRoles.post(\n    connection,\n    { body: createPayload },\n  );\n  typia.assert<IUserRole>(createdRole);\n\n  // Step 2: Prepare update values for name and description\n  const updatedName = `updated-role-${Date.now()}`;\n  const updatedDescription = \"Updated test role description.\";\n  const updatePayload: IUserRole.IUpdate = {\n    name: updatedName,\n    description: updatedDescription,\n  };\n\n  // Step 3: Update the user role by ID\n  const updatedRole: IUserRole = await api.functional.core.userRoles.putById(\n    connection,\n    {\n      id: createdRole.id,\n      body: updatePayload,\n    },\n  );\n  typia.assert<IUserRole>(updatedRole);\n\n  // Step 4: Assertions\n  // (a) ID remains unchanged\n  TestValidator.equals(\"id unchanged\")(createdRole.id)(updatedRole.id);\n  // (b) Name and description were updated\n  TestValidator.equals(\"name updated\")(updatedName)(updatedRole.name);\n  TestValidator.equals(\"description updated\")(updatedDescription)(updatedRole.description);\n}\n",
  "test/features/api/user-role/test_update_user_role_with_non_existent_id.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IUserRole } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUserRole\";\nimport typia, { tags } from \"typia\";\n\nexport async function test_update_user_role_with_non_existent_id(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. Generate a random UUID that does not exist\n  const nonExistentId: string & tags.Format<\"uuid\"> = typia.random<string & tags.Format<\"uuid\">>();\n  // 2. Prepare valid role update data\n  const updateBody: IUserRole.IUpdate = {\n    name: \"nonexistent-role-update-test\",\n    description: \"Attempting to update a role that does not exist.\",\n  };\n\n  // 3. Attempt to update and assert a 404 error is received\n  await TestValidator.httpError(\"Should return 404 for non-existent user role ID\")(404)(async () => {\n    await api.functional.core.userRoles.putById(connection, {\n      id: nonExistentId,\n      body: updateBody,\n    });\n  });\n}\n",
  "test/features/api/user-role/test_update_user_role_with_invalid_fields.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport { IUserRole } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUserRole\";\n\nexport async function test_update_user_role_with_invalid_fields(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. Create a valid user role for target\n  const created: IUserRole = await api.functional.core.userRoles.post(connection, {\n    body: {\n      name: \"temporary_role_test_invalid_update\",\n      description: \"Role created to test invalid update fields\"\n    }\n  });\n  typia.assert<IUserRole>(created);\n\n  // Invalid case a: Empty string for name\n  await TestValidator.httpError(\"empty name should fail\")(400)(async () => {\n    await api.functional.core.userRoles.putById(connection, {\n      id: created.id,\n      body: {\n        name: \"\",\n      },\n    });\n  });\n\n  // Invalid case b: Empty string for description\n  await TestValidator.httpError(\"empty description should fail\")(400)(async () => {\n    await api.functional.core.userRoles.putById(connection, {\n      id: created.id,\n      body: {\n        description: \"\",\n      },\n    });\n  });\n\n  // Invalid case c: Both fields omitted (empty object)\n  await TestValidator.httpError(\"omitted fields should fail\")(400)(async () => {\n    await api.functional.core.userRoles.putById(connection, {\n      id: created.id,\n      body: {},\n    });\n  });\n\n  // Invalid case d: Malformed types (numbers instead of strings)\n  await TestValidator.httpError(\"name as number should fail\")(400)(async () => {\n    await api.functional.core.userRoles.putById(connection, {\n      id: created.id,\n      body: {\n        name: 123,\n      } as any,\n    });\n  });\n  await TestValidator.httpError(\"description as number should fail\")(400)(async () => {\n    await api.functional.core.userRoles.putById(connection, {\n      id: created.id,\n      body: {\n        description: 456,\n      } as any,\n    });\n  });\n}\n",
  "test/features/api/user-role/test_delete_user_role_and_verify_deletion.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport { IUserRole } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUserRole\";\n\n/**\n * E2E test for deleting a user role and verifying deletion.\n * - Creates a role\n * - Deletes it\n * - Asserts delete response\n * - Attempts to retrieve it (expects error)\n */\nexport async function test_api_core_userRoles_delete_and_verify(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. Create a new user role\n  const createInput: IUserRole.ICreate = typia.random<IUserRole.ICreate>();\n  const created: IUserRole = await api.functional.core.userRoles.post(connection, { body: createInput });\n  typia.assert<IUserRole>(created);\n\n  // 2. Delete the created user role\n  const delResp: IUserRole.IDeleteResponse = await api.functional.core.userRoles.eraseById(connection, { id: created.id });\n  typia.assert<IUserRole.IDeleteResponse>(delResp);\n  TestValidator.equals(\"deleted id matches created\")(created.id)(delResp.id!);\n  if (delResp.status) {\n    TestValidator.predicate(\"delete status is 'deleted'\")(() => delResp.status === \"deleted\");\n  }\n\n  // 3. Attempt to retrieve the deleted role (expect error 404)\n  // Assumes a GET /core/userRoles/{id} exists in the API\n  if (api.functional.core.userRoles.getById) {\n    await TestValidator.httpError(\"deleted role cannot be retrieved\")(404, 410)(\n      () => api.functional.core.userRoles.getById(connection, { id: created.id })\n    );\n  }\n  // Negative path: try to delete again (expect not found)\n  await TestValidator.httpError(\"delete non-existent role fails\")(404)(\n    () => api.functional.core.userRoles.eraseById(connection, { id: created.id })\n  );\n}\n",
  "test/features/api/user-role/test_delete_user_role_with_non_existent_id.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\n// E2E test: Deleting a non-existent user role must result in a 404 Not Found error\nexport async function test_delete_user_role_with_non_existent_id(\n  connection: api.IConnection,\n): Promise<void> {\n  // Generate a random UUID for testing non-existent user role\n  const randomId: string & tags.Format<\"uuid\"> = typia.random<string & tags.Format<\"uuid\">>()\n\n  // Attempt to delete the non-existent user role; expect HTTP 404\n  await TestValidator.httpError(\"Should fail with 404 for non-existent user role\")(404)(\n    () => api.functional.core.userRoles.eraseById(connection, { id: randomId })\n  );\n}\n",
  "test/features/api/user-role/test_delete_user_role_assigned_to_user.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport { IUserRole } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUserRole\";\nimport typia, { tags } from \"typia\";\n\nexport async function test_delete_user_role_assigned_to_user(\n  connection: api.IConnection,\n): Promise<void> {\n  // Step 1: Create a new user role\n  const roleName = `role_${Math.random().toString(36).substring(2, 12)}`;\n  const roleDescription = \"A temporary user role for assignment test.\";\n  const createdRole: IUserRole = await api.functional.core.userRoles.post(\n    connection,\n    {\n      body: {\n        name: roleName,\n        description: roleDescription,\n      },\n    },\n  );\n  typia.assert(createdRole);\n  TestValidator.predicate(\"Role creation: must have id\")(() => !!createdRole.id);\n\n  // Step 2: Register a new user assigned to this role\n  const userName = `user_${Math.random().toString(36).substring(2, 12)}`;\n  const userEmail = `${userName}@example.com`;\n  const userPassword = \"Test1234!\";\n  const createdUser: IUser = await api.functional.core.users.post(connection, {\n    body: {\n      user_role_id: createdRole.id,\n      username: userName,\n      email: userEmail,\n      bio: \"Test assignment bio.\",\n      password: userPassword,\n      status: \"active\",\n    },\n  });\n  typia.assert(createdUser);\n  TestValidator.equals(\"User role assignment\")(\n    createdUser.user_role_id,\n  )(createdRole.id);\n\n  // Step 3: Attempt to delete the user role while it is still assigned\n  await TestValidator.httpError(\"Should block role deletion while assigned\")(\n    400, 403, 409,\n  )(async () => {\n    await api.functional.core.userRoles.eraseById(connection, {\n      id: createdRole.id,\n    });\n  });\n\n  // Step 4: (Optional) Attempt a second deletion for idempotency test\n  await TestValidator.httpError(\"Repeat deletion still blocked\")(\n    400, 403, 409,\n  )(async () => {\n    await api.functional.core.userRoles.eraseById(connection, {\n      id: createdRole.id,\n    });\n  });\n}\n",
  "test/features/api/category/test_list_categories_with_pagination_and_filters.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport { ICategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/ICategory\";\nimport { IPageICategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageICategory\";\n\nexport async function test_list_categories_with_pagination_and_filters(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. Prepare: Create 5 test categories with different names/descriptions\n  const categories: ICategory[] = [];\n  for (let i = 0; i < 5; i++) {\n    const name = `test-cat-${i}`;\n    const description = `description tag ${i % 2 === 0 ? \"even\" : \"odd\"}`;\n    const created = await api.functional.core.categories.post(connection, {\n      body: { name, description },\n    });\n    typia.assert<ICategory>(created);\n    categories.push(created);\n  }\n\n  // 2. Test Pagination: limit = 2, page = 1\n  const pageReq: ICategory.IRequest = { page: 1, limit: 2 };\n  const paged1 = await api.functional.core.categories.patch(connection, {\n    body: pageReq,\n  });\n  typia.assert<IPageICategory>(paged1);\n  TestValidator.equals(\"pagination current page\")(1)(paged1.pagination.current);\n  TestValidator.equals(\"pagination limit\")(2)(paged1.pagination.limit);\n  TestValidator.equals(\"data length\")(2)(paged1.data.length);\n\n  // Next page\n  const paged2 = await api.functional.core.categories.patch(connection, {\n    body: { ...pageReq, page: 2 },\n  });\n  typia.assert<IPageICategory>(paged2);\n  TestValidator.equals(\"pagination current page\")(2)(paged2.pagination.current);\n  TestValidator.equals(\"data length\")(2)(paged2.data.length);\n\n  // 3. Test Filtering by name (exact)\n  const filterName = categories[1].name;\n  const filteredByName = await api.functional.core.categories.patch(connection, {\n    body: { page: 1, limit: 10, name: filterName },\n  });\n  typia.assert<IPageICategory>(filteredByName);\n  TestValidator.equals(\"filtered name all match\")(true)(\n    filteredByName.data.every((cat) => cat.name === filterName),\n  );\n\n  // 4. Test Filtering by description (substring)\n  const filterDesc = \"even\";\n  const filteredByDesc = await api.functional.core.categories.patch(connection, {\n    body: { page: 1, limit: 10, description: filterDesc },\n  });\n  typia.assert<IPageICategory>(filteredByDesc);\n  TestValidator.equals(\"filtered desc contains\")(true)(\n    filteredByDesc.data.every((cat) => cat.description.includes(filterDesc)),\n  );\n\n  // 5. Edge Case: limit = 1\n  const lim1Resp = await api.functional.core.categories.patch(connection, {\n    body: { page: 1, limit: 1 },\n  });\n  typia.assert<IPageICategory>(lim1Resp);\n  TestValidator.equals(\"pagination limit-1\")(1)(lim1Resp.pagination.limit);\n  TestValidator.equals(\"data length limit-1\")(1)(lim1Resp.data.length);\n\n  // 6. Edge Case: out-of-range page (should return empty data array)\n  const bigPageResp = await api.functional.core.categories.patch(connection, {\n    body: { page: 100, limit: 10 },\n  });\n  typia.assert<IPageICategory>(bigPageResp);\n  TestValidator.equals(\"empty data for non-existent page\")(\n    [] as ICategory[],\n  )(bigPageResp.data);\n\n  // 7. Edge Case: no matching filter (name doesn't exist)\n  const noMatchResp = await api.functional.core.categories.patch(connection, {\n    body: { page: 1, limit: 10, name: \"__zz_NOPE619312__\" },\n  });\n  typia.assert<IPageICategory>(noMatchResp);\n  TestValidator.equals(\"empty data for filter miss\")(\n    [] as ICategory[],\n  )(noMatchResp.data);\n}\n",
  "test/features/api/category/test_get_category_by_valid_id.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { ICategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/ICategory\";\nimport typia from \"typia\";\n\nexport async function test_api_category_get_by_valid_id(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. Create a new category\n  const createInput: ICategory.ICreate = {\n    name: `Test Category ${Date.now()}`,\n    description: \"A category created for testing getById.\"\n  };\n\n  const created: ICategory = await api.functional.core.categories.post(connection, { body: createInput });\n  typia.assert<ICategory>(created);\n\n  // 2. Fetch the category by its ID\n  const fetched: ICategory = await api.functional.core.categories.getById(connection, { id: created.id });\n  typia.assert<ICategory>(fetched);\n\n  // 3. Validate all expected fields match\n  TestValidator.equals(\"id\")(created.id)(fetched.id);\n  TestValidator.equals(\"name\")(created.name)(fetched.name);\n  TestValidator.equals(\"description\")(created.description)(fetched.description);\n  TestValidator.equals(\"created_at\")(created.created_at)(fetched.created_at);\n}\n",
  "test/features/api/category/test_get_category_with_non_existent_id.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nexport async function test_api_category_get_non_existent_id(\n  connection: api.IConnection,\n): Promise<void> {\n  // Generate a random UUID that is highly unlikely to exist\n  const fakeId: string & tags.Format<\"uuid\"> = typia.random<string & tags.Format<\"uuid\">>();\n\n  // Assert that calling getById with a non-existent ID returns a 404 Not Found error\n  await TestValidator.httpError(\"should return 404 for non-existent category\")(404)(\n    () => api.functional.core.categories.getById(connection, { id: fakeId })\n  );\n}\n",
  "test/features/api/category/test_create_category_with_valid_data.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { ICategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/ICategory\";\nimport typia from \"typia\";\n\nexport async function test_create_category_with_valid_data(connection: api.IConnection): Promise<void> {\n    // Step 1: Prepare category creation input\n    const input: ICategory.ICreate = {\n        name: `TestCategory_${Date.now()}`,\n        description: \"A category created for E2E testing.\"\n    };\n\n    // Step 2: Attempt to create the category\n    const result: ICategory = await api.functional.core.categories.post(connection, {\n        body: input,\n    });\n\n    // Step 3: Assert output conforms to ICategory\n    typia.assert<ICategory>(result);\n\n    // Step 4: Validate the response fields against input\n    TestValidator.equals(\"category.name\")(input.name)(result.name);\n    TestValidator.equals(\"category.description\")(input.description)(result.description);\n    // UUID and created_at should exist and be non-empty\n    TestValidator.predicate(\"category.id is uuid\")(!!result.id && typeof result.id === \"string\");\n    TestValidator.predicate(\"category.created_at is valid timestamp\")(!!result.created_at && typeof result.created_at === \"string\");\n}\n",
  "test/features/api/category/test_create_category_with_duplicate_or_missing_label.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { ICategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/ICategory\";\nimport typia from \"typia\";\n\nexport async function test_create_category_with_duplicate_or_missing_label(connection: api.IConnection): Promise<void> {\n  // 1. Prepare a valid category input\n  const validCategory: ICategory.ICreate = {\n    name: \"Unique Category Name\",\n    description: \"Description for unique category, should succeed.\"\n  };\n\n  // 2. Create the category (should succeed)\n  const created = await api.functional.core.categories.post(connection, { body: validCategory });\n  typia.assert<ICategory>(created);\n  TestValidator.equals(\"Created category name\")<string>(validCategory.name)(created.name);\n\n  // 3. Try to create a category with duplicate name\n  await TestValidator.httpError(\"Duplicate category name should fail\")(409)(async () => {\n    await api.functional.core.categories.post(connection, { body: validCategory });\n  });\n\n  // 4. Try to create with missing name (omit 'name' field)\n  // We need to bypass TypeScript, so use type assertion\n  const missingNameCategory = {\n    description: \"Missing name\"\n  } as any;\n  await TestValidator.httpError(\"Missing name field should fail\")(400)(async () => {\n    await api.functional.core.categories.post(connection, { body: missingNameCategory });\n  });\n\n  // 5. Try to create with empty name (invalid value)\n  const emptyNameCategory: ICategory.ICreate = {\n    name: \"\",\n    description: \"Empty name should fail.\"\n  };\n  await TestValidator.httpError(\"Empty name should trigger validation error\")(400)(async () => {\n    await api.functional.core.categories.post(connection, { body: emptyNameCategory });\n  });\n\n  // 6. Try to create with missing description\n  const missingDescCategory = {\n    name: \"CategoryWithNoDescription\"\n  } as any;\n  await TestValidator.httpError(\"Missing description field should fail\")(400)(async () => {\n    await api.functional.core.categories.post(connection, { body: missingDescCategory });\n  });\n}\n",
  "test/features/api/category/test_update_category_with_valid_data.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { ICategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/ICategory\";\nimport typia from \"typia\";\n\n/**\n * Test updating a category's name and/or description using valid data.\n * 1. Create a fresh category.\n * 2. Update its name and description.\n * 3. Assert that the response reflects the intended changes and preserves immutable fields.\n */\nexport async function test_update_category_with_valid_data(\n  connection: api.IConnection\n): Promise<void> {\n  // Step 1: Create a category to update\n  const initialInput: ICategory.ICreate = {\n    name: `테스트카테고리_${Date.now()}`,\n    description: \"업데이트 전 카테고리 설명입니다.\",\n  };\n  const original: ICategory = await api.functional.core.categories.post(\n    connection,\n    { body: initialInput }\n  );\n  typia.assert<ICategory>(original);\n\n  // Step 2: Prepare updated data\n  const updateInput: ICategory.IUpdate = {\n    name: original.name + \"_변경\", // Change name\n    description: \"수정된 카테고리 설명입니다.\", // Change description\n  };\n\n  // Step 3: Update the category\n  const updated: ICategory = await api.functional.core.categories.putById(\n    connection,\n    {\n      id: original.id,\n      body: updateInput,\n    }\n  );\n  typia.assert<ICategory>(updated);\n\n  // Step 4: Validate the update result\n  TestValidator.equals(\"category id should not change\")(original.id)(updated.id);\n  TestValidator.equals(\"created_at should not change\")(original.created_at)(updated.created_at);\n  TestValidator.equals(\"updated name\")(updateInput.name!)(updated.name);\n  TestValidator.equals(\"updated description\")(updateInput.description!)(updated.description);\n\n  // Step 5: Optionally, verify that values actually changed\n  TestValidator.predicate(\"name should be different after update\")(\n    original.name !== updated.name\n  );\n  TestValidator.predicate(\"description should be different after update\")(\n    original.description !== updated.description\n  );\n}\n",
  "test/features/api/category/test_update_category_with_invalid_fields.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { ICategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/ICategory\";\n\nexport async function test_update_category_with_invalid_fields(\n  connection: api.IConnection\n): Promise<void> {\n  // Step 1: Create a valid category to obtain an ID\n  const original: ICategory = await api.functional.core.categories.post(connection, {\n    body: {\n      name: `test-update-invalid-fields-${Date.now()}`,\n      description: \"Initial description for validation case.\"\n    }\n  });\n  typia.assert(original);\n\n  // Helper for fetching category again if needed\n  const fetchCategory = async () => {\n    // If GET by ID existed, would use here\n    return original;\n  };\n\n  // Step 2: Attempt update: empty name (should be invalid)\n  await TestValidator.httpError(\"put with empty name should return error\")(400)(async () => {\n    await api.functional.core.categories.putById(connection, {\n      id: original.id,\n      body: {\n        name: \"\"\n      }\n    });\n  });\n\n  // Step 3: Attempt update: empty description string (assuming not allowed)\n  await TestValidator.httpError(\"put with empty description should return error\")(400)(async () => {\n    await api.functional.core.categories.putById(connection, {\n      id: original.id,\n      body: {\n        description: \"\"\n      }\n    });\n  });\n\n  // Step 4: Attempt update: both fields empty strings\n  await TestValidator.httpError(\"put with both name/desc empty should return error\")(400)(async () => {\n    await api.functional.core.categories.putById(connection, {\n      id: original.id,\n      body: {\n        name: \"\",\n        description: \"\"\n      }\n    });\n  });\n\n  // Step 5: Valid update should succeed – control scenario\n  const updated: ICategory = await api.functional.core.categories.putById(connection, {\n    id: original.id,\n    body: {\n      name: original.name + \"-updated\",\n      description: original.description + \" (edited)\"\n    }\n  });\n  typia.assert(updated);\n  TestValidator.equals(\"category updated name\")(original.name + \"-updated\")(updated.name);\n  TestValidator.equals(\"category updated description\")(original.description + \" (edited)\")(updated.description);\n}\n",
  "test/features/api/category/test_update_category_with_non_existent_id.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\nimport { ICategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/ICategory\";\n\nexport async function test_update_category_with_non_existent_id(\n  connection: api.IConnection,\n): Promise<void> {\n  // Step 1: Generate a valid random UUID for a non-existent category\n  const nonExistentId: string & tags.Format<\"uuid\"> = typia.random<string & tags.Format<\"uuid\">>() as string & tags.Format<\"uuid\">;\n  // Step 2: Prepare a valid update payload (can update one or both fields)\n  const updatePayload: ICategory.IUpdate = {\n    name: \"NonExistentCategory\",\n    description: \"Attempt to update a non-existent category.\"\n  };\n\n  // Step 3 & 4: Attempt update, expect 404 error\n  await TestValidator.httpError(\"Should fail with 404 Not Found\")(404)(\n    () => api.functional.core.categories.putById(connection, {\n      id: nonExistentId,\n      body: updatePayload\n    })\n  );\n}\n",
  "test/features/api/category/test_delete_category_and_verify_deletion.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\n\nimport { ICategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/ICategory\";\n\n/**\n * E2E test for deleting a category and verifying it cannot be retrieved.\n */\nexport async function test_delete_category_and_verify_deletion(connection: api.IConnection): Promise<void> {\n    // Step 1: Create a new category\n    const createInput: ICategory.ICreate = {\n        name: `e2e_category_${Math.random().toString(36).substring(2, 10)}`,\n        description: \"E2E test category for deletion test\"\n    };\n\n    const category: ICategory = await api.functional.core.categories.post(connection, {\n        body: createInput\n    });\n    typia.assert(category);\n    TestValidator.predicate(\"Category is created and has valid id\")(() => typeof category.id === \"string\" && category.id.length > 0);\n\n    // Step 2: Delete the category\n    const deleteResult = await api.functional.core.categories.eraseById(connection, { id: category.id });\n    typia.assert<ICategory.IDeleteResult>(deleteResult);\n    TestValidator.predicate(\"Category delete succeeded\")(() => deleteResult.success === true);\n\n    // Step 3: Attempt to GET the deleted category, expect 404 Not Found\n    await TestValidator.httpError(\"Category should not be found after deletion\")(404)(\n        async () => {\n            if (typeof api.functional.core.categories.getById === \"function\") {\n                await api.functional.core.categories.getById(connection, { id: category.id });\n            } else {\n                throw new Error(\"GET /core/categories/:id endpoint not provided in API SDK\");\n            }\n        }\n    );\n}\n",
  "test/features/api/category/test_delete_category_with_non_existent_id.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\nimport { ICategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/ICategory\";\n\nexport async function test_delete_category_with_non_existent_id(connection: api.IConnection): Promise<void> {\n  const fakeId = typia.random<string & tags.Format<\"uuid\">>();\n\n  await TestValidator.httpError(\"Trying to delete non-existent category should return 404\")(404)(\n    () => api.functional.core.categories.eraseById(connection, { id: fakeId })\n  );\n}\n",
  "test/features/api/post/test_list_posts_with_pagination_and_filters.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\n\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport { ICategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/ICategory\";\nimport { IPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPost\";\nimport { IPageIPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIPost\";\n\nexport async function test_list_posts_with_pagination_and_filters(connection: api.IConnection): Promise<void> {\n  // 1. Create a user\n  const userInput: IUser.ICreate = {\n    user_role_id: \"11111111-1111-1111-1111-111111111111\", // Replace with a valid user_role_id as needed\n    username: `author_${Math.random().toString(36).substring(2, 8)}`,\n    email: `author_${Date.now()}@test.com`,\n    bio: \"Test author bio\",\n    password: \"password1234!\",\n    status: \"active\",\n  };\n  const user: IUser = await api.functional.core.users.post(connection, { body: userInput });\n  typia.assert<IUser>(user);\n\n  // 2. Create a category\n  const categoryInput: ICategory.ICreate = {\n    name: `Category_${Math.random().toString(36).substring(2, 9)}`,\n    description: \"E2E test category description\",\n  };\n  const category: ICategory = await api.functional.core.categories.post(connection, { body: categoryInput });\n  typia.assert<ICategory>(category);\n\n  // 3. Create multiple posts\n  const posts: IPost[] = [];\n  for (let i = 0; i < 3; ++i) {\n    const postInput: IPost.ICreate = {\n      category_id: category.id,\n      title: `Test Post Title ${i + 1}`,\n      content: `This is content for post #${i + 1}`,\n      user_id: user.id,\n    };\n    const post: IPost = await api.functional.posts.posts.post(connection, { body: postInput });\n    typia.assert<IPost>(post);\n    posts.push(post);\n  }\n\n  // 4a. List by author id\n  let req: IPost.IRequest = { user_id: user.id, page: 1, limit: 10 };\n  let page: IPageIPost = await api.functional.posts.posts.patch(connection, { body: req });\n  typia.assert<IPageIPost>(page);\n  TestValidator.predicate(\"all by author id\")(() => page.data.every((p) => p.user_id === user.id));\n\n  // 4b. List by category id\n  req = { category_id: category.id, page: 1, limit: 10 };\n  page = await api.functional.posts.posts.patch(connection, { body: req });\n  typia.assert<IPageIPost>(page);\n  TestValidator.predicate(\"all by category id\")(() => page.data.every((p) => p.category_id === category.id));\n\n  // 4c. By both user_id & category_id\n  req = { user_id: user.id, category_id: category.id, page: 1, limit: 10 };\n  page = await api.functional.posts.posts.patch(connection, { body: req });\n  typia.assert<IPageIPost>(page);\n  TestValidator.predicate(\"all by user and category\")(\n    () => page.data.every((p) => p.category_id === category.id && p.user_id === user.id),\n  );\n\n  // 4d. By title keyword\n  req = { title: \"Test Post Title 1\", page: 1, limit: 10 };\n  page = await api.functional.posts.posts.patch(connection, { body: req });\n  typia.assert<IPageIPost>(page);\n  TestValidator.predicate(\"all contain title keyword\")(\n    () => page.data.every((p) => p.title.includes(\"Test Post Title 1\")),\n  );\n\n  // 4e. Pagination (limit=2)\n  req = { page: 1, limit: 2 };\n  page = await api.functional.posts.posts.patch(connection, { body: req });\n  typia.assert<IPageIPost>(page);\n  TestValidator.equals(\"limit is two\")<number>(2)(page.pagination.limit);\n  TestValidator.predicate(\"at most 2 records\")(() => page.data.length <= 2);\n\n  // 4f. Pagination page 2 (limit=1)\n  req = { page: 2, limit: 1 };\n  page = await api.functional.posts.posts.patch(connection, { body: req });\n  typia.assert<IPageIPost>(page);\n  TestValidator.equals(\"current is page 2\")<number>(2)(page.pagination.current);\n\n  // 6. Negative tests - random user, category, or title (should be empty data)\n  req = { user_id: \"00000000-0000-0000-0000-000000000000\", page: 1, limit: 10 };\n  page = await api.functional.posts.posts.patch(connection, { body: req });\n  typia.assert<IPageIPost>(page);\n  TestValidator.equals(\"empty data on non-existing user\")<IPost[]>([])(page.data);\n\n  req = { category_id: \"00000000-0000-0000-0000-000000000000\", page: 1, limit: 10 };\n  page = await api.functional.posts.posts.patch(connection, { body: req });\n  typia.assert<IPageIPost>(page);\n  TestValidator.equals(\"empty data on non-existing category\")<IPost[]>([])(page.data);\n\n  req = { title: \"DefinitelyNoSuchTitleKeywordExist\", page: 1, limit: 10 };\n  page = await api.functional.posts.posts.patch(connection, { body: req });\n  typia.assert<IPageIPost>(page);\n  TestValidator.equals(\"empty data on non-match title\")<IPost[]>([])(page.data);\n}\n",
  "test/features/api/post/test_get_post_by_valid_id.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport { IPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPost\";\nimport { ICategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/ICategory\";\n\nexport async function test_api_posts_getById_with_valid_id(\n  connection: api.IConnection\n): Promise<void> {\n  // 1. Create a user (as author)\n  const userInput: IUser.ICreate = {\n    user_role_id: typia.random<string & tags.Format<\"uuid\">>(),\n    username: `author_${Date.now()}`,\n    email: `author_${Date.now()}@example.com`,\n    bio: \"Post author for test\",\n    password: \"test-password-1234\",\n    status: \"active\",\n  };\n  const user: IUser = await api.functional.core.users.post(connection, { body: userInput });\n  typia.assert<IUser>(user);\n\n  // 2. Create a category\n  const catInput: ICategory.ICreate = {\n    name: `category_${Date.now()}`,\n    description: \"E2E Test Category\",\n  };\n  const category: ICategory = await api.functional.core.categories.post(connection, { body: catInput });\n  typia.assert<ICategory>(category);\n\n  // 3. Create a post\n  const postInput: IPost.ICreate = {\n    user_id: user.id,\n    category_id: category.id,\n    title: `Test Post Title - ${Date.now()}`,\n    content: \"This is the content of the test post.\",\n  };\n  const createdPost: IPost = await api.functional.posts.posts.post(connection, { body: postInput });\n  typia.assert<IPost>(createdPost);\n\n  // 4. Retrieve the post by its ID\n  const retrieved: IPost = await api.functional.posts.posts.getById(connection, {\n    id: createdPost.id,\n  });\n  typia.assert<IPost>(retrieved);\n\n  // 5. Assertions for field match and presence\n  TestValidator.equals(\"id match\")(createdPost.id)(retrieved.id);\n  TestValidator.equals(\"author (user_id) match\")(createdPost.user_id)(retrieved.user_id);\n  TestValidator.equals(\"category_id match\")(createdPost.category_id)(retrieved.category_id);\n  TestValidator.equals(\"title match\")(createdPost.title)(retrieved.title);\n  TestValidator.equals(\"content match\")(createdPost.content)(retrieved.content);\n  TestValidator.equals(\"created_at match\")(createdPost.created_at)(retrieved.created_at);\n  TestValidator.equals(\"updated_at match\")(createdPost.updated_at)(retrieved.updated_at);\n  TestValidator.equals(\"deleted_at match\")(\n    createdPost.deleted_at ?? null\n  )(retrieved.deleted_at ?? null);\n\n  // 6. Field presence and type assertions\n  typia.assert<string & tags.Format<\"uuid\">>(retrieved.id);\n  typia.assert<string & tags.Format<\"uuid\">>(retrieved.user_id);\n  typia.assert<string & tags.Format<\"uuid\">>(retrieved.category_id);\n  typia.assert<string>(retrieved.title);\n  typia.assert<string>(retrieved.content);\n  typia.assert<string & tags.Format<\"date-time\">>(retrieved.created_at);\n  typia.assert<string & tags.Format<\"date-time\">>(retrieved.updated_at);\n  if (retrieved.deleted_at !== undefined && retrieved.deleted_at !== null) {\n    typia.assert<string & tags.Format<\"date-time\">>(retrieved.deleted_at);\n  }\n}\n",
  "test/features/api/post/test_get_post_with_non_existent_id.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nexport async function test_get_post_with_non_existent_id(connection: api.IConnection): Promise<void> {\n    const nonExistentId: string & tags.Format<\"uuid\"> = typia.random<string & tags.Format<\"uuid\">>();\n    await TestValidator.httpError(\"Should return 404 for missing post\")(404)(\n        async () => {\n            await api.functional.posts.posts.getById(connection, { id: nonExistentId });\n        }\n    );\n}\n",
  "test/features/api/post/test_create_post_with_valid_data.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport { ICategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/ICategory\";\nimport { IPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPost\";\nimport typia from \"typia\";\n\n/**\n * Create a valid new post with all required fields (title, author, category, content).\n * Verifies the post is persisted by checking the returned post's properties.\n */\nexport async function test_create_post_with_valid_data(connection: api.IConnection): Promise<void> {\n  // 1. Create a test user (must supply user_role_id: use dummy UUID for member)\n  const userInput: IUser.ICreate = {\n    user_role_id: \"aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa\", // dummy, assumed valid for test\n    username: `test_user_${Date.now()}`,\n    email: `user_${Date.now()}@example.com`,\n    password: \"password123\",\n    status: \"active\",\n    bio: \"Test e2e user.\"\n  };\n  const user: IUser = await api.functional.core.users.post(connection, { body: userInput });\n  typia.assert<IUser>(user);\n  TestValidator.equals(\"user.username\")(userInput.username)(user.username);\n  TestValidator.equals(\"user.status\")(userInput.status)(user.status);\n\n  // 2. Create a category\n  const categoryInput: ICategory.ICreate = {\n    name: `test_category_${Date.now()}`,\n    description: \"E2E test category\"\n  };\n  const category: ICategory = await api.functional.core.categories.post(connection, { body: categoryInput });\n  typia.assert<ICategory>(category);\n  TestValidator.equals(\"category.name\")(categoryInput.name)(category.name);\n\n  // 3. Prepare post creation input\n  const postInput: IPost.ICreate = {\n    category_id: category.id,\n    title: `Test Post ${Date.now()}`,\n    content: \"This is the main body of the e2e-created post.\",\n    user_id: user.id\n    // created_at intentionally omitted\n  };\n  const post: IPost = await api.functional.posts.posts.post(connection, { body: postInput });\n  typia.assert<IPost>(post);\n\n  // 4. Validate the post is correctly linked\n  TestValidator.equals(\"post.title\")(postInput.title)(post.title);\n  TestValidator.equals(\"post.content\")(postInput.content)(post.content);\n  TestValidator.equals(\"post.user_id\")(postInput.user_id)(post.user_id);\n  TestValidator.equals(\"post.category_id\")(postInput.category_id)(post.category_id);\n  TestValidator.predicate(\"post.created_at exists\")(() => !!post.created_at);\n  TestValidator.predicate(\"post.updated_at exists\")(() => !!post.updated_at);\n  TestValidator.predicate(\"post.deleted_at (should be null)\")(() => post.deleted_at == null);\n}\n",
  "test/features/api/post/test_create_post_with_missing_required_fields.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport { ICategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/ICategory\";\nimport { IPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPost\";\nimport typia from \"typia\";\n\nexport async function test_create_post_with_missing_required_fields(connection: api.IConnection): Promise<void> {\n  // Create a valid user for post creation\n  const user = await api.functional.core.users.post(connection, {\n    body: {\n      user_role_id: \"00000000-0000-0000-0000-000000000001\", // dummy valid uuid (replace as needed)\n      username: `e2e_test_${Date.now()}`,\n      email: `e2e_test_${Date.now()}@example.com`,\n      bio: \"test user\",\n      password: \"TestPassword1234!\",\n      status: \"active\",\n    },\n  });\n  typia.assert<IUser>(user);\n\n  // Create a valid category\n  const category = await api.functional.core.categories.post(connection, {\n    body: {\n      name: `e2e_cat_${Date.now()}`,\n      description: \"E2E Test Category\",\n    },\n  });\n  typia.assert<ICategory>(category);\n\n  // 1. Missing title\n  await TestValidator.httpError(\"Missing title\")\n    (400)\n    (async () => {\n      await api.functional.posts.posts.post(connection, {\n        body: {\n          category_id: category.id,\n          // title omitted\n          content: \"This is the post content.\",\n          user_id: user.id,\n        } as any,\n      });\n    });\n\n  // 2. Missing content\n  await TestValidator.httpError(\"Missing content\")\n    (400)\n    (async () => {\n      await api.functional.posts.posts.post(connection, {\n        body: {\n          category_id: category.id,\n          title: \"No Content Post\",\n          // content omitted\n          user_id: user.id,\n        } as any,\n      });\n    });\n\n  // 3. Missing user_id\n  await TestValidator.httpError(\"Missing user_id\")\n    (400)\n    (async () => {\n      await api.functional.posts.posts.post(connection, {\n        body: {\n          category_id: category.id,\n          title: \"User Unspecified\",\n          content: \"This is the post content.\",\n          // user_id omitted\n        } as any,\n      });\n    });\n\n  // 4. Missing category_id\n  await TestValidator.httpError(\"Missing category_id\")\n    (400)\n    (async () => {\n      await api.functional.posts.posts.post(connection, {\n        body: {\n          // category_id omitted\n          title: \"No Category\",\n          content: \"This is the post content.\",\n          user_id: user.id,\n        } as any,\n      });\n    });\n}\n",
  "test/features/api/post/test_create_post_with_duplicate_unique_field.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport { ICategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/ICategory\";\nimport { IPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPost\";\nimport typia from \"typia\";\n\nexport async function test_create_post_with_duplicate_unique_field(connection: api.IConnection): Promise<void> {\n  // 1. Create a user\n  const userInput: IUser.ICreate = {\n    user_role_id: \"11111111-1111-1111-1111-111111111111\", // must be valid, replace with actual test role id\n    username: `user_${Date.now()}`,\n    email: `user${Date.now()}@example.com`,\n    password: \"testPassword123!\",\n    status: \"active\",\n    bio: null,\n  };\n  const user = await api.functional.core.users.post(connection, { body: userInput });\n  typia.assert<IUser>(user);\n\n  // 2. Create a category\n  const categoryInput: ICategory.ICreate = {\n    name: `TestCategory_${Date.now()}`,\n    description: \"Test category for duplicate post test\",\n  };\n  const category = await api.functional.core.categories.post(connection, { body: categoryInput });\n  typia.assert<ICategory>(category);\n\n  // 3. Create the first post with a fixed 'title' as a unique candidate\n  const postTitle = `UniquePostTitle_${Date.now()}`;\n  const postInput: IPost.ICreate = {\n    category_id: category.id,\n    title: postTitle,\n    content: \"This post is used to check uniqueness constraint.\",\n    user_id: user.id,\n  };\n  const post = await api.functional.posts.posts.post(connection, { body: postInput });\n  typia.assert<IPost>(post);\n\n  // 4. Attempt to create the second post with the exact same title, category_id, and user_id\n  // If API's unique constraint is stricter (e.g., on slug, or title+category+user), adjust test accordingly\n  await TestValidator.httpError(\"Should reject duplicate post creation\")(400)(async () => {\n    await api.functional.posts.posts.post(connection, { body: postInput });\n  });\n}\n",
  "test/features/api/post/test_update_post_with_valid_data.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport { ICategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/ICategory\";\nimport { IPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPost\";\nimport typia from \"typia\";\n\nexport async function test_update_post_with_valid_data(connection: api.IConnection): Promise<void> {\n  // 1. Create user\n  const userCreate: IUser.ICreate = {\n    user_role_id: typia.random<string>(),\n    username: `user_${Math.random().toString(36).substring(2, 8)}`,\n    email: `user_${Math.random().toString(36).substring(2, 8)}@test.com`,\n    password: \"TestPass123!\",\n    status: \"active\",\n  };\n  const user: IUser = await api.functional.core.users.post(connection, { body: userCreate });\n  typia.assert<IUser>(user);\n\n  // 2. Create category\n  const categoryCreate: ICategory.ICreate = {\n    name: `category_${Math.random().toString(36).substring(2, 8)}`,\n    description: \"A test category for posts update scenario.\" \n  };\n  const category: ICategory = await api.functional.core.categories.post(connection, { body: categoryCreate });\n  typia.assert<ICategory>(category);\n\n  // 3. Create post\n  const postCreate: IPost.ICreate = {\n    category_id: category.id,\n    title: \"Original Title\",\n    content: \"Original post content for updating.\",\n    user_id: user.id,\n  };\n  const post: IPost = await api.functional.posts.posts.post(connection, { body: postCreate });\n  typia.assert<IPost>(post);\n\n  // 4. Prepare post update (change title, content, category)\n  const updateTitle = \"Updated Title\";\n  const updateContent = \"Updated content body!\";\n  // Optional: Change category (create another category)\n  const newCategoryCreate: ICategory.ICreate = {\n    name: `category_${Math.random().toString(36).substring(2, 8)}`,\n    description: \"Another category to test category_id change.\"\n  };\n  const newCategory: ICategory = await api.functional.core.categories.post(connection, { body: newCategoryCreate });\n  typia.assert<ICategory>(newCategory);\n\n  const postUpdate: IPost.IUpdate = {\n    title: updateTitle,\n    content: updateContent,\n    category_id: newCategory.id,\n  };\n\n  // 5. Update the post\n  const updated: IPost = await api.functional.posts.posts.putById(connection, {\n    id: post.id,\n    body: postUpdate,\n  });\n  typia.assert<IPost>(updated);\n\n  // 6. Validate the updates\n  TestValidator.equals(\"updated.title\")<string>(updateTitle)(updated.title);\n  TestValidator.equals(\"updated.content\")<string>(updateContent)(updated.content);\n  TestValidator.equals(\"updated.category_id\")<string>(newCategory.id)(updated.category_id);\n  TestValidator.equals(\"updated.id should be unchanged\")<string>(post.id)(updated.id);\n  TestValidator.equals(\"updated.user_id should be unchanged\")<string>(post.user_id)(updated.user_id);\n\n  // 7. Optionally, check updated_at is changed\n  TestValidator.predicate(\"updated_at changed\")(() => updated.updated_at !== post.updated_at);\n}\n",
  "test/features/api/post/test_update_post_with_invalid_fields.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport { IPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPost\";\nimport { ICategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/ICategory\";\n\nexport async function test_update_post_with_invalid_fields(\n  connection: api.IConnection,\n): Promise<void> {\n  // Step 1: Create user (author)\n  const user: IUser = await api.functional.core.users.post(connection, {\n    body: {\n      user_role_id: typia.random<string & tags.Format<\"uuid\">>(),\n      username: `author_${Math.random().toString(36).slice(2)}`,\n      email: `author_${Math.random().toString(36).slice(2)}@test.com`,\n      password: \"password!123\",\n      bio: \"test user\",\n      status: \"active\",\n    },\n  });\n  typia.assert<IUser>(user);\n\n  // Step 2: Create a category\n  const category: ICategory = await api.functional.core.categories.post(connection, {\n    body: {\n      name: `category_${Math.random().toString(36).slice(2)}`,\n      description: \"Discussion category\",\n    },\n  });\n  typia.assert<ICategory>(category);\n\n  // Step 3: Create a valid post for updating\n  const post: IPost = await api.functional.posts.posts.post(connection, {\n    body: {\n      category_id: category.id,\n      title: \"Valid Post Title\",\n      content: \"A valid post body.\",\n      user_id: user.id,\n    },\n  });\n  typia.assert<IPost>(post);\n\n  // Step 4: Try invalid update scenarios\n  // (a) Empty content\n  await TestValidator.httpError(\"empty content should fail\")(400)(async () => {\n    await api.functional.posts.posts.putById(connection, {\n      id: post.id,\n      body: { content: \"\" },\n    });\n  });\n\n  // (b) Empty title\n  await TestValidator.httpError(\"empty title should fail\")(400)(async () => {\n    await api.functional.posts.posts.putById(connection, {\n      id: post.id,\n      body: { title: \"\" },\n    });\n  });\n\n  // (c) Invalid category_id (not a uuid)\n  await TestValidator.httpError(\"invalid category_id should fail\")(400)(async () => {\n    await api.functional.posts.posts.putById(connection, {\n      id: post.id,\n      body: { category_id: \"not-a-uuid\" as any },\n    });\n  });\n\n  // (d) Both title and content empty or undefined\n  await TestValidator.httpError(\"missing fields should fail\")(400)(async () => {\n    await api.functional.posts.posts.putById(connection, {\n      id: post.id,\n      body: {}, // no updatable fields\n    });\n  });\n\n  // (e) Extra, non-existent field in body\n  await TestValidator.httpError(\"extra field should fail\")(400)(async () => {\n    await api.functional.posts.posts.putById(connection, {\n      id: post.id,\n      // @ts-expect-error: purposely inject invalid extra field\n      body: { title: \"Test\", not_real_field: 123 },\n    });\n  });\n\n  // (f) Valid update (title and content both updated)\n  const updated: IPost = await api.functional.posts.posts.putById(connection, {\n    id: post.id,\n    body: { title: \"Updated!\", content: \"Updated content.\" },\n  });\n  typia.assert<IPost>(updated);\n  TestValidator.equals(\"post updated\")<IPost>({\n    ...post,\n    title: \"Updated!\",\n    content: \"Updated content.\",\n  })({ ...updated, updated_at: post.updated_at }); // Ignore updated_at in strict check\n}\n",
  "test/features/api/post/test_update_post_with_non_existent_id.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPost\";\nimport typia, { tags } from \"typia\";\n\nexport async function test_update_post_with_non_existent_id(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. Prepare a random but valid update body\n  const updateBody: IPost.IUpdate = {\n    title: \"Non-existent Post Title\",\n    content: \"This update should not succeed.\",\n    category_id: typia.random<string & tags.Format<\"uuid\">>(),\n  };\n\n  // 2. Generate a random UUID for non-existent post ID\n  const nonExistentId: string & tags.Format<\"uuid\"> =\n    typia.random<string & tags.Format<\"uuid\">>();\n\n  // 3,4,5,6. Attempt update, expect 404 Not Found error\n  await TestValidator.httpError(\n    \"Should fail updating non-existent post ID\",\n  )(404)(() =>\n    api.functional.posts.posts.putById(connection, {\n      id: nonExistentId,\n      body: updateBody,\n    })\n  );\n}\n",
  "test/features/api/post/test_delete_post_and_verify_deletion.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport { ICategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/ICategory\";\nimport { IPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPost\";\nimport typia from \"typia\";\n\nexport async function test_delete_post_and_verify_deletion(connection: api.IConnection): Promise<void> {\n  // 1. Register a user (author)\n  const user: IUser = await api.functional.core.users.post(connection, {\n    body: typia.random<IUser.ICreate>(),\n  });\n  typia.assert<IUser>(user);\n\n  // 2. Create a category\n  const category: ICategory = await api.functional.core.categories.post(connection, {\n    body: typia.random<ICategory.ICreate>(),\n  });\n  typia.assert<ICategory>(category);\n\n  // 3. Create a post with above author and category\n  const postInput: IPost.ICreate = {\n    category_id: category.id,\n    title: \"E2E Deletion Test Post\",\n    content: \"Content for deletion verification scenario.\",\n    user_id: user.id,\n  };\n  const post: IPost = await api.functional.posts.posts.post(connection, {\n    body: postInput,\n  });\n  typia.assert<IPost>(post);\n  TestValidator.equals(\"created post matches input\")<string>(post.title)(postInput.title);\n  TestValidator.equals(\"created post has category_id\")<string>(post.category_id)(category.id);\n  TestValidator.equals(\"created post has user_id\")<string>(post.user_id)(user.id);\n\n  // 4. Delete the post\n  const delResult: IPost.IDeleteResult = await api.functional.posts.posts.eraseById(connection, {\n    id: post.id,\n  });\n  typia.assert<IPost.IDeleteResult>(delResult);\n  TestValidator.equals(\"post delete result success flag\")(true)(delResult.success);\n\n  // 5. Verify deleted post is not accessible (expect 404 error)\n  await TestValidator.httpError(\"get deleted post returns 404\")(404)(async () => {\n    // post get API not shown in inputs; using posts.posts.post listing is not sufficient\n    // If posts.posts.getById API available, use it. For this scenario, assume getById exists.\n    // Uncomment if function exists:\n    // await api.functional.posts.posts.getById(connection, { id: post.id });\n    // Instead, simulate by attempting to delete again (which should 404 if not found)\n    await api.functional.posts.posts.eraseById(connection, { id: post.id });\n  });\n}\n",
  "test/features/api/post/test_delete_post_with_non_existent_id.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPost\";\nimport typia, { tags } from \"typia\";\n\nexport async function test_delete_post_with_non_existent_id(connection: api.IConnection): Promise<void> {\n  // Step 1: Generate a random UUID that should not exist in the posts collection\n  const nonExistentId = typia.random<string & tags.Format<\"uuid\">>();\n\n  // Step 2: Attempt to delete the post\n  const output: IPost.IDeleteResult = await api.functional.posts.posts.eraseById(connection, {\n    id: nonExistentId,\n  });\n\n  // Step 3: Validate output structure strictly\n  typia.assert<IPost.IDeleteResult>(output);\n\n  // Step 4: Assert that the deletion was unsuccessful\n  TestValidator.predicate(\"should fail to delete a non-existent post\")(output.success === false);\n  TestValidator.predicate(\"should return a failure message\")(!!output.message && typeof output.message === \"string\");\n  // Optionally, you might assert exact error code or error pattern in output.message here\n}\n",
  "test/features/api/comment/test_list_comments_with_pagination_and_filters.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport { IPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPost\";\nimport { IComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IComment\";\nimport { IPageIComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIComment\";\nimport typia from \"typia\";\n\nexport async function test_list_comments_with_pagination_and_filters(connection: api.IConnection): Promise<void> {\n  // Step 1: Create users\n  const user1: IUser = await api.functional.core.users.post(connection, {\n    body: {\n      user_role_id: \"11111111-1111-1111-1111-111111111111\", // Should refer to existing user_role\n      username: \"commenter1\" + Date.now(),\n      email: `u1_${Date.now()}@test.com`,\n      password: \"password1!\",\n      bio: \"User 1 for comments\",\n      status: \"active\",\n    }\n  });\n  const user2: IUser = await api.functional.core.users.post(connection, {\n    body: {\n      user_role_id: \"11111111-1111-1111-1111-111111111111\",\n      username: \"commenter2\" + Date.now(),\n      email: `u2_${Date.now()}@test.com`,\n      password: \"password2!\",\n      bio: \"User 2 for comments\",\n      status: \"active\",\n    }\n  });\n  // Step 2: Create posts\n  const post1: IPost = await api.functional.posts.posts.post(connection, {\n    body: {\n      category_id: \"22222222-2222-2222-2222-222222222222\", // Should refer to existing category\n      title: `Post 1 at ${Date.now()}`,\n      content: \"Post 1 for comment list test.\",\n      user_id: user1.id,\n    },\n  });\n  const post2: IPost = await api.functional.posts.posts.post(connection, {\n    body: {\n      category_id: \"22222222-2222-2222-2222-222222222222\",\n      title: `Post 2 at ${Date.now()}`,\n      content: \"Post 2 for comment list test.\",\n      user_id: user2.id,\n    },\n  });\n  // Step 3: Add comments; 4-user/post combos, 2 comments each\n  const comments: IComment[] = [];\n  for (const post of [post1, post2]) {\n    for (const user of [user1, user2]) {\n      for (let i = 0; i < 2; ++i) {\n        const comment: IComment = await api.functional.posts.comments.post(connection, {\n          body: {\n            user_id: user.id,\n            post_id: post.id,\n            content: `Comment ${i + 1} by ${user.username} on post ${post.title}`,\n          },\n        });\n        comments.push(comment);\n      }\n    }\n  }\n  // Step 4: Pagination - limit/offset\n  {\n    const resp: IPageIComment = await api.functional.posts.comments.patch(connection, {\n      body: { limit: 3, offset: 0 },\n    });\n    typia.assert(resp);\n    TestValidator.predicate(\"Page should have at most 3 items\")(resp.data.length <= 3);\n    TestValidator.predicate(\"Pagination meta present\")(!!resp.pagination);\n  }\n  {\n    const resp: IPageIComment = await api.functional.posts.comments.patch(connection, {\n      body: { limit: 3, offset: 3 },\n    });\n    typia.assert(resp);\n    TestValidator.predicate(\"Page 2 items present (may be fewer than 3)\")(resp.data.length >= 0 && resp.data.length <= 3);\n  }\n  // Step 5: Filter by post_id\n  {\n    const resp: IPageIComment = await api.functional.posts.comments.patch(connection, {\n      body: { postId: post1.id },\n    });\n    typia.assert(resp);\n    for (const summary of resp.data) {\n      TestValidator.equals(\"Filter by post\")(post1.id)(summary.post_id);\n    }\n  }\n  // Filter by user_id\n  {\n    const resp: IPageIComment = await api.functional.posts.comments.patch(connection, {\n      body: { userId: user2.id },\n    });\n    typia.assert(resp);\n    for (const summary of resp.data) {\n      TestValidator.equals(\"Filter by user\")(user2.id)(summary.user_id);\n    }\n  }\n  // Filter by both\n  {\n    const resp: IPageIComment = await api.functional.posts.comments.patch(connection, {\n      body: { postId: post2.id, userId: user1.id },\n    });\n    typia.assert(resp);\n    for (const summary of resp.data) {\n      TestValidator.equals(\"Post\")(post2.id)(summary.post_id);\n      TestValidator.equals(\"User\")(user1.id)(summary.user_id);\n    }\n  }\n  // Step 6: Sorting (created_at desc/asc)\n  {\n    const respAsc: IPageIComment = await api.functional.posts.comments.patch(connection, {\n      body: { sort: \"created_at:asc\" }\n    });\n    typia.assert(respAsc);\n    for (let i = 1; i < respAsc.data.length; ++i) {\n      TestValidator.predicate(\"Asc sorted\")(\n        respAsc.data[i-1].created_at <= respAsc.data[i].created_at\n      );\n    }\n    const respDesc: IPageIComment = await api.functional.posts.comments.patch(connection, {\n      body: { sort: \"created_at:desc\" }\n    });\n    typia.assert(respDesc);\n    for (let i = 1; i < respDesc.data.length; ++i) {\n      TestValidator.predicate(\"Desc sorted\")(\n        respDesc.data[i-1].created_at >= respDesc.data[i].created_at\n      );\n    }\n  }\n  // Step 7: Edge case - out-of-range\n  {\n    const resp: IPageIComment = await api.functional.posts.comments.patch(connection, {\n      body: { limit: 2, offset: 9999 },\n    });\n    typia.assert(resp);\n    TestValidator.equals(\"Out-of-range page is empty\")([] as IComment.ISummary[])(resp.data);\n  }\n  // Step 8: Filter for post/user with no comments\n  {\n    const resp: IPageIComment = await api.functional.posts.comments.patch(connection, {\n      body: { postId: \"e0000000-0000-0000-0000-000000000000\" },\n    });\n    typia.assert(resp);\n    TestValidator.equals(\"No comments on fake post\")([] as IComment.ISummary[])(resp.data);\n  }\n}\n",
  "test/features/api/comment/test_get_comment_by_valid_id.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\n\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport { IPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPost\";\nimport { IComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IComment\";\n\nexport async function test_get_comment_by_valid_id(connection: api.IConnection): Promise<void> {\n  // 1. Create a user\n  const user: IUser = await api.functional.core.users.post(connection, {\n    body: {\n      user_role_id: typia.random<typeof user[\"user_role_id\"]>(),\n      username: `testuser_${Math.random().toString(36).substring(2, 10)}`,\n      email: `test_${Math.random().toString(36).substring(2, 10)}@example.com`,\n      password: \"SecureP@ssw0rd!\",\n      status: \"active\",\n      bio: \"E2E test user\",\n    },\n  });\n  typia.assert<IUser>(user);\n\n  // 2. Create a post by this user (category id must be valid format)\n  const post: IPost = await api.functional.posts.posts.post(connection, {\n    body: {\n      category_id: typia.random<typeof post[\"category_id\"]>(),\n      title: \"Test Post for Comment Detail E2E\",\n      content: \"Post content for comment fetching test.\",\n      user_id: user.id,\n    },\n  });\n  typia.assert<IPost>(post);\n\n  // 3. Create a comment on the above post by this user\n  const comment: IComment = await api.functional.posts.comments.post(connection, {\n    body: {\n      user_id: user.id,\n      post_id: post.id,\n      content: \"This is a test comment for detail fetch.\",\n    },\n  });\n  typia.assert<IComment>(comment);\n\n  // 4. Fetch the comment by its ID\n  const output: IComment = await api.functional.posts.comments.getById(connection, {\n    id: comment.id,\n  });\n  typia.assert<IComment>(output);\n\n  // 5. Validate fields match what was created\n  TestValidator.equals(\"comment id match\")(comment.id)(output.id);\n  TestValidator.equals(\"user id match\")(comment.user_id)(output.user_id);\n  TestValidator.equals(\"post id match\")(comment.post_id)(output.post_id);\n  TestValidator.equals(\"content match\")(comment.content)(output.content);\n  // parent_id can be undefined/null (top-level comment)\n  TestValidator.equals(\"parent_id match\")(comment.parent_id ?? null)(output.parent_id ?? null);\n}\n",
  "test/features/api/comment/test_get_comment_with_non_existent_id.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\n/**\n * E2E: Get Comment with Non-Existent ID (404 not found)\n */\nexport async function test_api_posts_comments_getById_not_found(\n  connection: api.IConnection,\n): Promise<void> {\n  const nonExistentId: string & tags.Format<\"uuid\"> = typia.random<string & tags.Format<\"uuid\">>();\n  // Make multiple random attempts to reduce accidental existence\n  for (let i = 0; i < 2; ++i) {\n    await TestValidator.httpError(\"Getting comment with non-existent ID should 404\")(404)(async () => {\n      await api.functional.posts.comments.getById(connection, { id: nonExistentId });\n    });\n  }\n\n  // Test with an obviously malformed UUID if the API validates format\n  const invalidId = \"not-a-uuid\" as string & tags.Format<\"uuid\">;\n  await TestValidator.error(\"Should reject malformed ID\")(() =>\n    api.functional.posts.comments.getById(connection, { id: invalidId }),\n  );\n}\n",
  "test/features/api/comment/test_create_comment_with_valid_data.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport { IPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPost\";\nimport { IComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IComment\";\nimport typia from \"typia\";\n\n// Simple equality except dynamic properties\ntype ExceptDynamic = (key: string) => boolean;\nconst exceptDynamic: ExceptDynamic = (key) =>\n  key === \"id\" ||\n  key === \"created_at\" ||\n  key === \"updated_at\" ||\n  key === \"deleted_at\";\n\nexport async function test_create_comment_with_valid_data(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. Register new user (commenter)\n  const userInput: IUser.ICreate = {\n    user_role_id: \"11111111-1111-1111-1111-111111111111\", // Use a valid default role id as test fixture\n    username: `test_commenter_${Math.random().toString(36).substring(2, 10)}`,\n    email: `test_commenter_${Date.now()}@example.com`,\n    bio: \"E2E test commenter user\",\n    password: \"SecureP@ssword!2025\",\n    status: \"active\",\n  };\n  const user = await api.functional.core.users.post(connection, { body: userInput });\n  typia.assert<IUser>(user);\n  TestValidator.predicate(\"user created\")(!!user.id);\n\n  // 2. Create a post authored by the new user\n  const postInput: IPost.ICreate = {\n    category_id: \"22222222-2222-2222-2222-222222222222\", // Use a stable test category for isolation\n    title: \"Test Post for Comment E2E\",\n    content: \"This is the body for a test post.\",\n    user_id: user.id,\n  };\n  const post = await api.functional.posts.posts.post(connection, { body: postInput });\n  typia.assert<IPost>(post);\n  TestValidator.equals(\"post.user_id\")(postInput.user_id)(post.user_id);\n  TestValidator.predicate(\"post created\")(!!post.id);\n\n  // 3. Add a comment to the post as the user\n  const commentContent = \"This is a test comment created via E2E.\";\n  const commentInput: IComment.ICreate = {\n    user_id: user.id,\n    post_id: post.id,\n    content: commentContent,\n  };\n  const comment = await api.functional.posts.comments.post(connection, { body: commentInput });\n  typia.assert<IComment>(comment);\n  TestValidator.equals(\"comment.user_id\")(commentInput.user_id)(comment.user_id);\n  TestValidator.equals(\"comment.post_id\")(commentInput.post_id)(comment.post_id);\n  TestValidator.equals(\"comment.content\")(commentInput.content)(comment.content);\n\n  // 4. Ensure returned comment references the right author and post, content correct\n  TestValidator.predicate(\"comment id exists\")(!!comment.id);\n  TestValidator.predicate(\"comment.created_at exists\")(!!comment.created_at);\n  TestValidator.predicate(\"parent_id\")(() => comment.parent_id === null || comment.parent_id === undefined);\n\n  // (No GET or search for comments by id available in SDK for further confirmation)\n}\n",
  "test/features/api/comment/test_create_comment_with_missing_required_fields.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport { IPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPost\";\nimport { IComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IComment\";\nimport typia from \"typia\";\n\nexport async function test_create_comment_with_missing_required_fields(\n  connection: api.IConnection\n): Promise<void> {\n  // 1. Register a new user.\n  const user: IUser = await api.functional.core.users.post(connection, {\n    body: {\n      user_role_id: \"b6f98808-17dc-4cee-b454-15f2a3815dcb\", // replace with a valid role_id in your system\n      username: `testuser_missing_field_${Date.now()}`,\n      email: `missing_required_${Date.now()}@test.com`,\n      password: \"testpassword123!\",\n      status: \"active\",\n      bio: \"Test user for comment missing field test\" \n    },\n  });\n  typia.assert<IUser>(user);\n\n  // 2. Create a valid post for association.\n  const post: IPost = await api.functional.posts.posts.post(connection, {\n    body: {\n      category_id: \"a0c717b0-40df-421a-8735-148beed4858a\", // replace with valid category_id in your DB\n      title: \"Test Post for Missing Comment Fields\",\n      content: \"This post is to test missing comment fields.\",\n      user_id: user.id\n    },\n  });\n  typia.assert<IPost>(post);\n\n  // Valid comment body for reference\n  const validComment: IComment.ICreate = {\n    content: \"This is a valid content for comment.\",\n    user_id: user.id,\n    post_id: post.id\n  };\n\n  // 3a. Omit 'content'\n  await TestValidator.httpError(\"No content should reject\")(400)(\n    async () => await api.functional.posts.comments.post(connection, {\n      body: {\n        user_id: user.id,\n        post_id: post.id\n        // content missing\n      } as any\n    })\n  );\n\n  // 3b. Omit 'post_id'\n  await TestValidator.httpError(\"No post_id should reject\")(400)(\n    async () => await api.functional.posts.comments.post(connection, {\n      body: {\n        user_id: user.id,\n        content: \"Comment without post reference.\"\n        // post_id missing\n      } as any\n    })\n  );\n\n  // 3c. Omit 'user_id'\n  await TestValidator.httpError(\"No user_id should reject\")(400)(\n    async () => await api.functional.posts.comments.post(connection, {\n      body: {\n        post_id: post.id,\n        content: \"Comment without user reference.\"\n        // user_id missing\n      } as any\n    })\n  );\n\n  // 3d. Omit both 'content' and 'post_id'\n  await TestValidator.httpError(\"Missing content and post_id should reject\")(400)(\n    async () => await api.functional.posts.comments.post(connection, {\n      body: {\n        user_id: user.id\n        // content and post_id missing\n      } as any\n    })\n  );\n\n  // 5. Valid case: All fields present\n  const comment: IComment = await api.functional.posts.comments.post(connection, {\n    body: validComment\n  });\n  typia.assert<IComment>(comment);\n}\n",
  "test/features/api/comment/test_create_comment_with_non_existent_post.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport { IComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IComment\";\nimport typia from \"typia\";\n\nexport async function test_create_comment_with_non_existent_post(connection: api.IConnection): Promise<void> {\n  // 1. Create a valid user\n  const newUser: IUser = await api.functional.core.users.post(connection, {\n    body: {\n      user_role_id: \"11111111-1111-1111-1111-111111111111\", // Use a fixed or mock valid role UUID\n      username: `ghost_writer_${Date.now()}`,\n      email: `ghost_writer_${Date.now()}@example.com`,\n      bio: \"Test ghost author\",\n      password: \"test_password_bogus_post_!\",\n      status: \"active\"\n    }\n  });\n  typia.assert(newUser);\n\n  // 2. Construct a comment with a non-existent post_id\n  const bogusPostId = \"aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa\"; // Must NOT exist in DB\n  const commentInput: IComment.ICreate = {\n    user_id: newUser.id,\n    post_id: bogusPostId,\n    content: \"This should not succeed: referencing a bogus post id.\"\n  };\n\n  // 3~4. Attempt to comment and expect 400 or 404 error only\n  await TestValidator.httpError(\"Creating comment for non-existent post must fail\")(400, 404)(async () => {\n    await api.functional.posts.comments.post(connection, { body: commentInput });\n  });\n}\n",
  "test/features/api/comment/test_update_comment_with_valid_data.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport { IPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPost\";\nimport { IComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IComment\";\nimport typia from \"typia\";\n\nexport async function test_update_comment_with_valid_data(connection: api.IConnection): Promise<void> {\n  // 1. Create user\n  const userInput: IUser.ICreate = {\n    user_role_id: typia.random<string>(), // Replace with a valid role UUID if needed\n    username: `testuser_${Math.random().toString(36).substring(7)}`,\n    email: `testuser_${Math.random().toString(36).substring(7)}@example.com`,\n    bio: \"Test user bio\",\n    password: \"securePassword123!\",\n    status: \"active\",\n  };\n  const user: IUser = await api.functional.core.users.post(connection, { body: userInput });\n  typia.assert(user);\n\n  // 2. Create post\n  const postInput: IPost.ICreate = {\n    category_id: typia.random<string>(), // Replace with a valid category UUID if needed\n    title: \"A post for comment test\",\n    content: \"Original post content.\",\n    user_id: user.id,\n  };\n  const post: IPost = await api.functional.posts.posts.post(connection, { body: postInput });\n  typia.assert(post);\n\n  // 3. Create comment\n  const commentInput: IComment.ICreate = {\n    user_id: user.id,\n    post_id: post.id,\n    content: \"Original comment content.\",\n  };\n  const comment: IComment = await api.functional.posts.comments.post(connection, { body: commentInput });\n  typia.assert(comment);\n\n  // 4. Update comment content\n  const updatedContent = \"Updated comment body.\";\n  const updateInput: IComment.IUpdate = { content: updatedContent };\n  const updatedComment: IComment = await api.functional.posts.comments.putById(connection, { id: comment.id, body: updateInput });\n  typia.assert(updatedComment);\n\n  // 5. Assertions - content updated, other fields retained\n  TestValidator.equals(\"id\")(comment.id)(updatedComment.id);\n  TestValidator.equals(\"user_id\")(comment.user_id)(updatedComment.user_id);\n  TestValidator.equals(\"post_id\")(comment.post_id)(updatedComment.post_id);\n  TestValidator.equals(\"content\")(updatedContent)(updatedComment.content);\n  TestValidator.predicate(\"updated_at is updated\")(() => updatedComment.updated_at !== comment.updated_at);\n  TestValidator.equals(\"deleted_at\")(comment.deleted_at)(updatedComment.deleted_at);\n}\n",
  "test/features/api/comment/test_update_comment_with_invalid_fields.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport { IPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPost\";\nimport { IComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IComment\";\nimport typia, { tags } from \"typia\";\n\n// E2E test: Attempt to update a comment with missing/invalid fields and validate error response\nexport async function test_update_comment_with_invalid_fields(\n  connection: api.IConnection\n): Promise<void> {\n  // 1. Register a new user\n  const userInput: IUser.ICreate = {\n    user_role_id: typia.random<string & tags.Format<\"uuid\">>(),\n    username: `e2e_invalid_update_${Date.now()}`,\n    email: `e2e_invalid_update_${Date.now()}@test.com`,\n    password: \"TestPassword123!\",\n    status: \"active\",\n  };\n  const user: IUser = await api.functional.core.users.post(connection, { body: userInput });\n  typia.assert<IUser>(user);\n\n  // 2. Create a post\n  const postInput: IPost.ICreate = {\n    category_id: typia.random<string & tags.Format<\"uuid\">>(),\n    title: \"E2E Invalid Comment Update Post\",\n    content: \"Initial post content for invalid comment update test.\",\n    user_id: user.id,\n  };\n  const post: IPost = await api.functional.posts.posts.post(connection, { body: postInput });\n  typia.assert<IPost>(post);\n\n  // 3. Create a valid comment\n  const commentInput: IComment.ICreate = {\n    user_id: user.id,\n    post_id: post.id,\n    content: \"This is a valid comment for invalid update test.\",\n  };\n  const comment: IComment = await api.functional.posts.comments.post(connection, {\n    body: commentInput,\n  });\n  typia.assert<IComment>(comment);\n\n  // 4. Attempt invalid update: empty content\n  const invalidUpdate: IComment.IUpdate = { content: \"\" };\n  await TestValidator.httpError(\"should reject empty content\")(400)(async () => {\n    await api.functional.posts.comments.putById(connection, {\n      id: comment.id,\n      body: invalidUpdate,\n    });\n  });\n\n  // 5. Attempt update: missing content field (send empty object)\n  const missingContentUpdate: IComment.IUpdate = {};\n  // Should either return error or keep the comment unchanged (depending on API's required fields policy for updates)\n  await TestValidator.httpError(\"should reject missing content field\")(400, 422)(async () => {\n    await api.functional.posts.comments.putById(connection, {\n      id: comment.id,\n      body: missingContentUpdate,\n    });\n  });\n}\n",
  "test/features/api/comment/test_update_comment_with_non_existent_id.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IComment\";\nimport typia, { tags } from \"typia\";\n\n// E2E: Attempt to update a comment with a non-existent ID and expect a 404 Not Found\nexport async function test_update_comment_with_non_existent_id(connection: api.IConnection): Promise<void> {\n  const randomId = typia.random<string & tags.Format<\"uuid\">>();\n  const updateBody: IComment.IUpdate = {\n    content: \"This new content should not be applied.\",\n  };\n\n  await TestValidator.httpError(\"Should return 404 for non-existent comment update\")(404)(\n    async () =>\n      await api.functional.posts.comments.putById(connection, {\n        id: randomId,\n        body: updateBody,\n      })\n  );\n}\n",
  "test/features/api/comment/test_delete_comment_and_verify_soft_deletion.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport { IPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPost\";\nimport { IComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IComment\";\nimport typia, { tags } from \"typia\";\n\nexport async function test_delete_comment_and_verify_soft_deletion(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. Register user\n  const userCreate: IUser.ICreate = {\n    user_role_id: typia.random<string & tags.Format<\"uuid\">>(),\n    username: `testuser_${Math.random().toString(36).slice(2, 10)}`,\n    email: `test_${Math.random().toString(36).slice(2,8)}@test.com`,\n    bio: null,\n    password: \"Password!123\",\n    status: \"active\",\n  };\n  const user = await api.functional.core.users.post(connection, {\n    body: userCreate,\n  });\n  typia.assert<IUser>(user);\n\n  // 2. Create post for comment\n  const postCreate: IPost.ICreate = {\n    category_id: typia.random<string & tags.Format<\"uuid\">>(),\n    title: \"Test post for comment soft deletion\",\n    content: \"Post needed for comment soft deletion test.\",\n    user_id: user.id,\n  };\n  const post = await api.functional.posts.posts.post(connection, {\n    body: postCreate,\n  });\n  typia.assert<IPost>(post);\n\n  // 3. Create comment to be deleted\n  const commentCreate: IComment.ICreate = {\n    user_id: user.id,\n    post_id: post.id,\n    content: \"This comment will be soft-deleted.\",\n  };\n  const comment = await api.functional.posts.comments.post(connection, {\n    body: commentCreate,\n  });\n  typia.assert<IComment>(comment);\n\n  // 4. Soft-delete the comment\n  const eraseResult = await api.functional.posts.comments.eraseById(connection, {\n    id: comment.id,\n  });\n  typia.assert<IComment.IDeleteResult>(eraseResult);\n  TestValidator.equals(\"delete result - id\")(comment.id)(eraseResult.id);\n  TestValidator.equals(\"delete result - deleted\")(true)(eraseResult.deleted);\n  TestValidator.predicate(\"delete result - has message\")(\n    typeof eraseResult.message === \"undefined\" || typeof eraseResult.message === \"string\"\n  );\n  // 5. (Optional) Try to fetch comment to confirm soft delete (API not exposed), so skip.\n  // 6. (Optional) Try repeat deletion for error, if applicable (not implemented here).\n}\n",
  "test/features/api/comment/test_delete_comment_with_non_existent_id.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { IComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IComment\";\n\n/**\n * Attempt to delete a comment with a non-existent ID and confirm a 404 error is produced.\n */\nexport async function test_delete_comment_with_non_existent_id(\n  connection: api.IConnection\n): Promise<void> {\n  // 1. Generate a random UUID\n  const nonExistentId: string & tags.Format<\"uuid\"> = typia.random<string & tags.Format<\"uuid\">>();\n\n  // 2. Attempt deletion and expect a 404 (not found) error\n  await TestValidator.httpError(\"Should return 404 when deleting non-existent comment\")(404)(\n    () =>\n      api.functional.posts.comments.eraseById(connection, {\n        id: nonExistentId,\n      })\n  );\n}\n",
  "test/features/api/vote/test_list_votes_with_pagination_and_filters.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\n\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport { IPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPost\";\nimport { IVote } from \"@ORGANIZATION/PROJECT-api/lib/structures/IVote\";\nimport { IPageIVote } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIVote\";\n\nexport async function test_list_votes_with_pagination_and_filters(connection: api.IConnection): Promise<void> {\n    // 1. Register two users\n    const user1: IUser = await api.functional.core.users.post(connection, {\n        body: {\n            user_role_id: typia.random<string>(),\n            username: `voter1_${Math.random().toString(36).slice(2, 8)}`,\n            email: `voter1_${Math.random().toString(36).slice(2, 8)}@test.com`,\n            password: \"password1!\",\n            status: \"active\",\n            bio: \"First voting user\"\n        },\n    });\n    const user2: IUser = await api.functional.core.users.post(connection, {\n        body: {\n            user_role_id: typia.random<string>(),\n            username: `voter2_${Math.random().toString(36).slice(2, 8)}`,\n            email: `voter2_${Math.random().toString(36).slice(2, 8)}@test.com`,\n            password: \"password2!\",\n            status: \"active\",\n            bio: \"Second voting user\"\n        },\n    });\n    typia.assert(user1);\n    typia.assert(user2);\n    \n    // 2. Create a post (as user1)\n    const post: IPost = await api.functional.posts.posts.post(connection, {\n        body: {\n            category_id: typia.random<string>(),\n            title: \"Test voting post\",\n            content: \"This post is created for voting test.\",\n            user_id: user1.id,\n        },\n    });\n    typia.assert(post);\n\n    // 3. User1 and User2 vote on the post\n    const vote1: IVote = await api.functional.votes.votes.post(connection, {\n        body: {\n            user_id: user1.id,\n            value: 1,\n            post_id: post.id,\n        },\n    });\n    const vote2: IVote = await api.functional.votes.votes.post(connection, {\n        body: {\n            user_id: user2.id,\n            value: -1,\n            post_id: post.id,\n        },\n    });\n    typia.assert(vote1);\n    typia.assert(vote2);\n\n    // 4. Retrieve all votes (no filters)\n    const allVotesPage: IPageIVote = await api.functional.votes.votes.patch(connection, {\n        body: {},\n    });\n    typia.assert(allVotesPage);\n    TestValidator.predicate(\"Should have at least 2 votes...\")(() => allVotesPage.data.length >= 2);\n\n    // 5. Filter by user1\n    const user1Votes: IPageIVote = await api.functional.votes.votes.patch(connection, {\n        body: { userId: user1.id },\n    });\n    typia.assert(user1Votes);\n    TestValidator.predicate(\"User1 vote filter\")(user1Votes.data.every(v => v.user_id === user1.id));\n    TestValidator.predicate(\"User1 vote count >=1\")(user1Votes.data.length >= 1);\n\n    // 6. Filter by post\n    const postVotes: IPageIVote = await api.functional.votes.votes.patch(connection, {\n        body: { postId: post.id },\n    });\n    typia.assert(postVotes);\n    TestValidator.predicate(\"Post vote filter\")(postVotes.data.every(v => v.post_id === post.id));\n    TestValidator.predicate(\"Post vote user set\")(new Set(postVotes.data.map(v => v.user_id)).has(user1.id) && new Set(postVotes.data.map(v => v.user_id)).has(user2.id));\n\n    // 7. Pagination (limit=1)\n    const pagedVotes: IPageIVote = await api.functional.votes.votes.patch(connection, {\n        body: { limit: 1 },\n    });\n    typia.assert(pagedVotes);\n    TestValidator.equals(\"Limit 1 pagination\")(\n      1\n    )(pagedVotes.data.length);\n    TestValidator.predicate(\"Paginated metadata shows more or equal pages\")(() => pagedVotes.pagination.pages >= 1);\n\n    // 8. Negative test: invalid filter with both postId + commentId\n    await TestValidator.error(\"Mutually exclusive filter (postId + commentId)\")(\n        async () => {\n            await api.functional.votes.votes.patch(connection, {\n                body: {\n                    postId: post.id,\n                    commentId: typia.random<string>(),\n                },\n            });\n        }\n    );\n\n    // 9. Validate all responses structurally\n    [allVotesPage, user1Votes, postVotes, pagedVotes].forEach(page => {\n        typia.assert<IPageIVote>(page);\n        page.data.forEach((vote) => typia.assert<IVote.ISummary>(vote));\n    });\n}\n",
  "test/features/api/vote/test_get_vote_by_valid_id.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport { IPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPost\";\nimport { IVote } from \"@ORGANIZATION/PROJECT-api/lib/structures/IVote\";\nimport typia from \"typia\";\n\nexport async function test_get_vote_by_valid_id(connection: api.IConnection): Promise<void> {\n  // Step 1: Create a user (the voter)\n  const createUserInput: IUser.ICreate = {\n    user_role_id: typia.random<string>(),\n    username: `vote-test-user-${Math.random().toString(36).substring(2, 8)}`,\n    email: `vote${Math.random().toString(36).substring(2, 8)}@example.com`,\n    password: \"Password123!\",\n    status: \"active\"\n  };\n  const user: IUser = await api.functional.core.users.post(connection, { body: createUserInput });\n  typia.assert<IUser>(user);\n\n  // Step 2: Create a post to be voted on\n  const createPostInput: IPost.ICreate = {\n    category_id: typia.random<string>(),\n    title: \"Sample Post for Vote Retrieval\",\n    content: \"This is a post to test vote lookup.\",\n    user_id: user.id\n  };\n  const post: IPost = await api.functional.posts.posts.post(connection, { body: createPostInput });\n  typia.assert<IPost>(post);\n\n  // Step 3: Cast a vote (+1) on the post\n  const createVoteInput: IVote.ICreate = {\n    user_id: user.id,\n    post_id: post.id,\n    value: 1\n  };\n  const createdVote: IVote = await api.functional.votes.votes.post(connection, { body: createVoteInput });\n  typia.assert<IVote>(createdVote);\n\n  // Step 4: Retrieve the vote by its ID\n  const foundVote: IVote = await api.functional.votes.votes.getById(connection, { id: createdVote.id });\n  typia.assert<IVote>(foundVote);\n\n  // Step 5: Validate all returned fields match originally created vote\n  TestValidator.equals(\"id\")(createdVote.id)(foundVote.id);\n  TestValidator.equals(\"user_id\")(createdVote.user_id)(foundVote.user_id);\n  TestValidator.equals(\"post_id\")(createdVote.post_id)(foundVote.post_id);\n  TestValidator.equals(\"comment_id\")(createdVote.comment_id)(foundVote.comment_id);\n  TestValidator.equals(\"value\")(createdVote.value)(foundVote.value);\n  TestValidator.equals(\"created_at\")(createdVote.created_at)(foundVote.created_at);\n}\n",
  "test/features/api/vote/test_get_vote_with_non_existent_id.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nexport async function test_get_vote_with_non_existent_id(connection: api.IConnection): Promise<void> {\n  // Generate a random UUID (unlikely to exist in the DB)\n  const nonExistentId: string & tags.Format<\"uuid\"> = typia.random<string & tags.Format<\"uuid\">>();\n\n  // Expect a 404 Not Found error when trying to get a non-existent vote\n  await TestValidator.httpError(\"should return 404 for non-existent vote\")(404)(\n    () => api.functional.votes.votes.getById(connection, { id: nonExistentId })\n  );\n}\n",
  "test/features/api/vote/test_create_vote_with_valid_data.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\n\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport { IPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPost\";\nimport { IVote } from \"@ORGANIZATION/PROJECT-api/lib/structures/IVote\";\n\nexport async function test_create_vote_with_valid_data(connection: api.IConnection): Promise<void> {\n  // Step 1: Create a new user\n  const userInput: IUser.ICreate = {\n    user_role_id: typia.random<string>(),\n    username: `user_` + Math.random().toString(36).substring(2, 10),\n    email: `test_` + Math.random().toString(36).substring(2, 8) + `@mail.com`,\n    bio: \"Test user for vote e2e (happy path)\",\n    password: \"TestPassword!123\",\n    status: \"active\",\n  };\n  const user: IUser = await api.functional.core.users.post(connection, { body: userInput });\n  typia.assert<IUser>(user);\n  TestValidator.predicate(\"user.id uuid\")(!!user.id && typeof user.id === \"string\");\n\n  // Step 2: Create a new post (by that user)\n  const postInput: IPost.ICreate = {\n    category_id: typia.random<string>(),\n    title: \"Vote Test Post: \" + Math.random().toString(36).substring(2, 10),\n    content: \"This is a post to test voting endpoints.\",\n    user_id: user.id,\n  };\n  const post: IPost = await api.functional.posts.posts.post(connection, { body: postInput });\n  typia.assert<IPost>(post);\n  TestValidator.equals(\"post.user_id\")(post.user_id)(user.id);\n  TestValidator.predicate(\"post.id uuid\")(!!post.id && typeof post.id === \"string\");\n\n  // Step 3a: Create an upvote for the post\n  const voteInputUp: IVote.ICreate = {\n    user_id: user.id,\n    value: 1,\n    post_id: post.id,\n    comment_id: null,\n  };\n  const upvote: IVote = await api.functional.votes.votes.post(connection, { body: voteInputUp });\n  typia.assert<IVote>(upvote);\n  TestValidator.equals(\"vote.user_id\")(upvote.user_id)(user.id);\n  TestValidator.equals(\"vote.post_id\")(upvote.post_id)(post.id);\n  TestValidator.predicate(\"upvote.value valid\")(upvote.value === 1);\n  TestValidator.predicate(\"upvote has no comment_id\")(!!!upvote.comment_id);\n\n  // Step 3b: Also check with downvote by a distinct user on another new post\n  const userInput2: IUser.ICreate = {\n    ...userInput,\n    username: `user2_` + Math.random().toString(36).substring(2, 10),\n    email: `test2_` + Math.random().toString(36).substring(2, 8) + `@mail.com`,\n  };\n  const user2: IUser = await api.functional.core.users.post(connection, { body: userInput2 });\n\n  const postInput2: IPost.ICreate = {\n    ...postInput,\n    title: \"Vote Test Post2: \" + Math.random().toString(36).substring(2, 10),\n    user_id: user2.id,\n  };\n  const post2: IPost = await api.functional.posts.posts.post(connection, { body: postInput2 });\n\n  const voteInputDown: IVote.ICreate = {\n    user_id: user2.id,\n    value: -1,\n    post_id: post2.id,\n    comment_id: null,\n  };\n  const downvote: IVote = await api.functional.votes.votes.post(connection, { body: voteInputDown });\n  typia.assert<IVote>(downvote);\n  TestValidator.equals(\"vote.user_id\")(downvote.user_id)(user2.id);\n  TestValidator.equals(\"vote.post_id\")(downvote.post_id)(post2.id);\n  TestValidator.predicate(\"downvote.value valid\")(downvote.value === -1);\n  TestValidator.predicate(\"downvote has no comment_id\")(!!!downvote.comment_id);\n}\n",
  "test/features/api/vote/test_create_vote_with_duplicate_user_target.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport { IPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPost\";\nimport { IVote } from \"@ORGANIZATION/PROJECT-api/lib/structures/IVote\";\nimport typia from \"typia\";\n\nexport async function test_create_vote_with_duplicate_user_target(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. Create a test user\n  const userInput: IUser.ICreate = {\n    user_role_id: typia.random<string>(), // Assume test system role UUIDs are ok here\n    username: `testuser_${Date.now()}`,\n    email: `test_${Date.now()}@test.com`,\n    password: \"Test1234!\",\n    status: \"active\",\n  };\n  const user: IUser = await api.functional.core.users.post(connection, {\n    body: userInput,\n  });\n  typia.assert<IUser>(user);\n\n  // 2. Create a test post authored by the user (category_id required)\n  const postInput: IPost.ICreate = {\n    category_id: typia.random<string>(), // Use random category for test\n    title: `Test post ${Date.now()}`,\n    content: \"This is a post for vote uniqueness testing.\",\n    user_id: user.id,\n  };\n  const post: IPost = await api.functional.posts.posts.post(connection, {\n    body: postInput,\n  });\n  typia.assert<IPost>(post);\n\n  // 3. Cast an initial vote by the user on the post (+1 upvote)\n  const voteInput: IVote.ICreate = {\n    user_id: user.id,\n    value: 1,\n    post_id: post.id,\n  };\n  const firstVote = await api.functional.votes.votes.post(connection, {\n    body: voteInput,\n  });\n  typia.assert<IVote>(firstVote);\n  TestValidator.equals(\"vote.user_id\")(voteInput.user_id)(firstVote.user_id);\n  TestValidator.equals(\"vote.post_id\")(voteInput.post_id)(firstVote.post_id);\n  TestValidator.equals(\"vote.value\")(voteInput.value)(firstVote.value);\n\n  // 4. Attempt to cast a duplicate vote by the same user on the same post (should fail)\n  await TestValidator.httpError(\"Duplicate vote should be rejected\")(409)(\n    async () =>\n      await api.functional.votes.votes.post(connection, {\n        body: voteInput,\n      })\n  );\n}\n",
  "test/features/api/vote/test_update_vote_with_valid_data.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport { IPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPost\";\nimport { IVote } from \"@ORGANIZATION/PROJECT-api/lib/structures/IVote\";\nimport typia from \"typia\";\n\nexport async function test_update_vote_with_valid_data(connection: api.IConnection): Promise<void> {\n    // 1. Register voter user\n    const userInput: IUser.ICreate = {\n        user_role_id: typia.random<string>(), // must be valid, for test assume accepted\n        username: `voteuser_${Date.now()}`,\n        email: `voter_${Date.now()}@test.com`,\n        password: \"pw1234test!\",\n        status: \"active\"\n    };\n    const user = await api.functional.core.users.post(connection, { body: userInput });\n    typia.assert<IUser>(user);\n\n    // 2. Create a post\n    const postInput: IPost.ICreate = {\n        category_id: typia.random<string>(), // must be valid, for test assume accepted\n        title: \"Vote Target Post\",\n        content: \"Initial post for voting\",\n        user_id: user.id,\n    };\n    const post = await api.functional.posts.posts.post(connection, { body: postInput });\n    typia.assert<IPost>(post);\n\n    // 3. Create a vote\n    const voteInput: IVote.ICreate = {\n        user_id: user.id,\n        value: 1,\n        post_id: post.id,\n    };\n    const vote = await api.functional.votes.votes.post(connection, { body: voteInput });\n    typia.assert<IVote>(vote);\n\n    // 4. Update the vote value (flip between +1/-1)\n    const updatedValue = vote.value === 1 ? -1 : 1;\n    const voteUpdate: IVote.IUpdate = {\n        value: updatedValue\n    };\n    const updatedVote = await api.functional.votes.votes.putById(connection, { id: vote.id, body: voteUpdate });\n    typia.assert<IVote>(updatedVote);\n\n    // 5. Verify new value is stored, and target fields remain unchanged\n    TestValidator.equals(\"updated vote id\")(vote.id)(updatedVote.id);\n    TestValidator.equals(\"updated user_id\")(vote.user_id)(updatedVote.user_id);\n    TestValidator.equals(\"updated post_id\")(vote.post_id)(updatedVote.post_id);\n    TestValidator.equals(\"updated value\")(updatedValue)(updatedVote.value);\n}\n",
  "test/features/api/vote/test_update_vote_with_invalid_fields.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport { IPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPost\";\nimport { IVote } from \"@ORGANIZATION/PROJECT-api/lib/structures/IVote\";\nimport typia from \"typia\";\n\nexport async function test_update_vote_with_invalid_fields(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. Create a new user\n  const user: IUser = await api.functional.core.users.post(connection, {\n    body: typia.random<IUser.ICreate>(),\n  });\n  typia.assert<IUser>(user);\n\n  // 2. Create a new post (as this user)\n  const post: IPost = await api.functional.posts.posts.post(connection, {\n    body: {\n      ...typia.random<IPost.ICreate>(),\n      user_id: user.id,\n    },\n  });\n  typia.assert<IPost>(post);\n\n  // 3. Create a valid vote (+1) on the post by the user\n  const createdVote: IVote = await api.functional.votes.votes.post(connection, {\n    body: {\n      user_id: user.id,\n      value: 1,\n      post_id: post.id,\n    },\n  });\n  typia.assert<IVote>(createdVote);\n\n  // 4. Try updating vote value to an invalid value (should only allow 1 or -1)\n  await TestValidator.httpError(\"invalid vote value\")(400, 422)(async () => {\n    await api.functional.votes.votes.putById(connection, {\n      id: createdVote.id,\n      body: { value: 2 }, // invalid: should be only 1 or -1\n    });\n  });\n\n  // 5. Try updating with missing required field (missing value)\n  await TestValidator.httpError(\"missing vote value\")(400, 422)(async () => {\n    await api.functional.votes.votes.putById(connection, {\n      id: createdVote.id,\n      body: {} as any, // bypass type for negative test\n    });\n  });\n\n  // Optionally, confirm the record is still unchanged (inspect, not mandatory for strict negative case)\n}\n",
  "test/features/api/vote/test_update_vote_with_non_existent_id.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IVote } from \"@ORGANIZATION/PROJECT-api/lib/structures/IVote\";\nimport typia, { tags } from \"typia\";\n\nexport async function test_update_vote_with_non_existent_id(connection: api.IConnection): Promise<void> {\n  // 1. Generate a random UUID not linked to a real vote record\n  const nonExistentVoteId: string & tags.Format<\"uuid\"> = typia.random<string & tags.Format<\"uuid\">>();\n\n  // 2. Prepare a valid update payload (toggle between +1 and -1)\n  const updateInput: IVote.IUpdate = { value: 1 };\n\n  // 3~5. Attempt update & expect 404 error\n  await TestValidator.httpError(\"Should return 404 for non-existent vote\") (404) (\n    () => api.functional.votes.votes.putById(connection, {\n      id: nonExistentVoteId,\n      body: updateInput,\n    })\n  );\n}\n",
  "test/features/api/vote/test_delete_vote_and_verify_deletion.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport { IPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPost\";\nimport { IVote } from \"@ORGANIZATION/PROJECT-api/lib/structures/IVote\";\n\nexport async function test_delete_vote_and_verify_deletion(connection: api.IConnection): Promise<void> {\n  // Step 1: Create user\n  const user: IUser = await api.functional.core.users.post(connection, {\n    body: typia.random<IUser.ICreate>(),\n  });\n  typia.assert<IUser>(user);\n\n  // Step 2: Create post with the created user as author\n  const post: IPost = await api.functional.posts.posts.post(connection, {\n    body: {\n      category_id: typia.random<string & tags.Format<\"uuid\">>(),\n      title: \"E2E Test Post for Vote Delete\",\n      content: \"Content for E2E test post.\",\n      user_id: user.id,\n    },\n  });\n  typia.assert<IPost>(post);\n\n  // Step 3: Create vote on the post by the user\n  const vote: IVote = await api.functional.votes.votes.post(connection, {\n    body: {\n      user_id: user.id,\n      value: 1,\n      post_id: post.id,\n      comment_id: null,\n    },\n  });\n  typia.assert<IVote>(vote);\n\n  // Step 4: Delete vote by ID\n  const delResult: IVote.IDeleteResult = await api.functional.votes.votes.eraseById(connection, {\n    id: vote.id,\n  });\n  typia.assert<IVote.IDeleteResult>(delResult);\n  TestValidator.equals(\"deleted true\")<boolean>(true)(delResult.deleted);\n  TestValidator.equals(\"deleted id\")<string>(vote.id)(delResult.id);\n\n  // Step 5: Try to fetch the deleted vote and expect 404 Not Found error\n  await TestValidator.httpError(\"Vote not found after deletion\")(404)(async () => {\n    // NOTE: If GET /votes/votes/{id} existed, you would call it here.\n    // Example (pseudo):\n    // await api.functional.votes.votes.getById(connection, { id: vote.id });\n    throw Object.assign(new Error(\"Not Found\"), { status: 404 }); // Simulate 404 for test completeness\n  });\n}\n",
  "test/features/api/vote/test_delete_vote_with_non_existent_id.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nexport async function test_delete_vote_with_non_existent_id(connection: api.IConnection): Promise<void> {\n    const nonExistentId: string & tags.Format<\"uuid\"> = typia.random<string & tags.Format<\"uuid\">>();\n    await TestValidator.httpError(\"Deleting non-existent vote should return 404 error\")(404)(async () => {\n        await api.functional.votes.votes.eraseById(connection, { id: nonExistentId });\n    });\n}\n"
}