[
  {
    "type": "testWrite",
    "created_at": "2025-06-24T07:35:30.957Z",
    "filename": "test/features/apiuser/test_list_users_with_pagination_and_filtering.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\n\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport { IPageIUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIUser\";\n\n/**\n * Test retrieving a paginated list of users, filtering by role or email.\n *\n * This test covers:\n * - Basic pagination (changing page/limit)\n * - Filtering by role and email, including empty filters (returns all users)\n * - Invalid filter criteria (non-existent role)\n * - First/last page edge cases\n * - Unauthorized access check\n *\n * Steps:\n * 1. Request users with no filters (should return all, first page)\n * 2. Request with explicit page/limit pagination, check pagination structure\n * 3. Fetch full user list, select a real role/email, then filter by role and email separately and together\n * 4. Apply an invalid role UUID (should return 0 results)\n * 5. Attempt to fetch a non-existent (high) page (should return empty data or last page result)\n * 6. Check edge cases: first page, last page, page after last\n * 7. Simulate unauthorized (no session/invalid) access and verify access denial\n */\nexport async function test_api_user_list_with_pagination_and_filtering(connection: api.IConnection): Promise<void> {\n  // 1. No filter, default paging: should retrieve first page of all users\n  const allDefault: IPageIUser.ISummary = await api.functional.core.users.patch(connection, {\n    body: {},\n  });\n  typia.assert(allDefault);\n  TestValidator.equals(\"current page (default)\")(1)(allDefault.pagination.current);\n  TestValidator.equals(\"limit (default)\")(100)(allDefault.pagination.limit);\n  TestValidator.equals(\"data count <= limit\")(\n    true,\n  )(allDefault.data.length <= allDefault.pagination.limit);\n\n  // 2. Explicit page/limit\n  const paged: IPageIUser.ISummary = await api.functional.core.users.patch(connection, {\n    body: { page: 2, limit: 3 },\n  });\n  typia.assert(paged);\n  TestValidator.equals(\"correct page number\")(2)(paged.pagination.current);\n  TestValidator.equals(\"limit\")(3)(paged.pagination.limit);\n\n  // 3. Find role & email from default-set user, then filter by role, then by search (email or username)\n  if (allDefault.data.length > 0) {\n    const firstUser = allDefault.data[0];\n    // Filter by role\n    const roleFiltered = await api.functional.core.users.patch(connection, {\n      body: { role: firstUser.role.id },\n    });\n    typia.assert(roleFiltered);\n    for (const user of roleFiltered.data) {\n      TestValidator.equals(\"all users have filtered role\")(firstUser.role.id)(user.role.id);\n    }\n    // Filter by search (email or username)\n    const emailFragment = firstUser.username.slice(0, 3);\n    const searchFiltered = await api.functional.core.users.patch(connection, {\n      body: { search: emailFragment },\n    });\n    typia.assert(searchFiltered);\n    TestValidator.equals(\n      \"search results contain fragment\"\n    )(\n      true\n    )(\n      searchFiltered.data.some((u) => u.username.includes(emailFragment))\n    );\n    // Combined filter\n    const combined = await api.functional.core.users.patch(connection, {\n      body: { role: firstUser.role.id, search: emailFragment },\n    });\n    typia.assert(combined);\n    for (const user of combined.data) {\n      TestValidator.equals(\"role matches\")(firstUser.role.id)(user.role.id);\n      TestValidator.equals(\n        \"search matches\"\n      )(\n        true\n      )(user.username.includes(emailFragment));\n    }\n  }\n\n  // 4. Invalid role UUID (random)\n  const invalidRole = \"00000000-0000-4000-8000-ffffffffffff\";\n  const invalidRoleResult = await api.functional.core.users.patch(connection, {\n    body: { role: invalidRole },\n  });\n  typia.assert(invalidRoleResult);\n  TestValidator.equals(\"no user with invalid role\")(0)(invalidRoleResult.data.length);\n\n  // 5. Request last page (calculated from first call)\n  const lastPageNumber = allDefault.pagination.pages;\n  const lastPage = await api.functional.core.users.patch(connection, {\n    body: { page: lastPageNumber },\n  });\n  typia.assert(lastPage);\n  TestValidator.equals(\"last page #\")(lastPageNumber)(lastPage.pagination.current);\n  // May be empty (if total count % limit === 0), but should not error\n  TestValidator.equals(\"last page <= limit\")(\n    true\n  )(lastPage.data.length <= lastPage.pagination.limit);\n\n  // 6. Page after last\n  const afterLast = await api.functional.core.users.patch(connection, {\n    body: { page: lastPageNumber + 1 },\n  });\n  typia.assert(afterLast);\n  TestValidator.equals(\"after last is empty or same as last\")(\n    true\n  )(\n    afterLast.data.length === 0 || afterLast.pagination.current === lastPageNumber + 1\n  );\n\n  // 7. [Optional] Unauthorized check -- skip if SDK/session always authorized\n  // await TestValidator.httpError(\"unauthorized user list fetch\")(401)(() =>\n  //   api.functional.core.users.patch({ ...connection, headers: {} }, { body: {} })\n  // );\n}\n",
    "completed": 24,
    "total": 30,
    "step": 0
  },
  {
    "type": "testWrite",
    "created_at": "2025-06-24T07:35:30.957Z",
    "filename": "test/features/apiuser/test_get_user_profile_by_id_with_success_and_failure_cases.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\n\n/**\n * E2E test for detailed user profile retrieval by ID, including validation for both success and error conditions.\n *\n * Scenario background:\n * Retrieves the detailed profile of an existing user by their unique ID and confirms all expected fields are present and correctly typed. Also validates error handling for non-existent user IDs and insufficient permissions.\n *\n * Steps:\n * 1. Create a new user using the POST /core/users endpoint to ensure a valid user ID for test.\n * 2. Retrieve the created user's detailed profile by ID using GET /core/users/{id}.\n * 3. Assert all expected fields are present and types match IUser spec.\n * 4. Attempt to retrieve a non-existent user ID and verify a 404 response.\n * 5. Simulate insufficient permission scenario (for example, as an unauthenticated/unauthorized connection) and confirm access is denied.\n */\nexport async function test_api_user_profile_getById_with_success_and_failure_cases(connection: api.IConnection): Promise<void> {\n  // 1. Create a new user\n  const user: IUser = await api.functional.core.users.post(connection, {\n    body: {\n      user_role_id: typia.random<string & tags.Format<\"uuid\">>(),\n      username: `testuser_${Date.now()}`,\n      email: `test_${Date.now()}@test.com`,\n      password: \"StrongP@ssw0rd\",\n      status: \"active\",\n      bio: \"Test user profile\",\n    } satisfies IUser.ICreate,\n  });\n  typia.assert(user);\n\n  // 2. Retrieve the created user's profile by ID\n  const output: IUser = await api.functional.core.users.getById(connection, {\n    id: user.id,\n  });\n  typia.assert(output);\n  TestValidator.equals(\"user.id\")(user.id)(output.id);\n  TestValidator.equals(\"user.username\")(user.username)(output.username);\n  TestValidator.equals(\"user.email\")(user.email)(output.email);\n\n  // 3. Attempt to retrieve a non-existent user ID (random UUID)\n  await TestValidator.httpError(\"non-existent user\")(404)(() =>\n    api.functional.core.users.getById(connection, {\n      id: typia.random<string & tags.Format<\"uuid\">>(),\n    })\n  );\n\n  // 4. Attempt to retrieve user details without sufficient permissions\n  // - This typically requires a connection without admin/owner permissions or unauthenticated.\n  // - Here we simulate as a guest (remove authentication headers if possible).\n  if (connection.headers) {\n    const guestConnection = { ...connection, headers: {} };\n    await TestValidator.httpError(\"insufficient permissions\")(403)(() =>\n      api.functional.core.users.getById(guestConnection, {\n        id: user.id,\n      })\n    );\n  }\n}\n",
    "completed": 27,
    "total": 30,
    "step": 0
  },
  {
    "type": "testWrite",
    "created_at": "2025-06-24T07:35:30.957Z",
    "filename": "test/features/apiuser/test_register_user_valid_duplicate_and_invalid_cases.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\n\n/**\n * Test user registration API (/core/users)\n *\n * Scenario:\n * 1. Register a new user with valid information and expect success.\n * 2. Attempt registration with existing email/username and expect uniqueness violation.\n * 3. Try registering with missing required fields (e.g. password/email) and expect validation errors.\n *\n * This validates both successful and failure user registration flows, ensuring unique constraints and field requirements.\n */\nexport async function test_api_user_register_user_valid_duplicate_and_invalid_cases(\n  connection: api.IConnection,\n): Promise<void> {\n  // Prepare valid registration data\n  const baseUser = {\n    user_role_id: typia.random<string>(), // Should be a valid/existing role UUID\n    username: `testuser_${Date.now()}`,\n    email: `testuser_${Date.now()}@e2e.com`,\n    password: \"TestPassword!123\",\n    status: \"active\",\n  } satisfies Omit<IUser.ICreate, \"bio\"> & Partial<Pick<IUser.ICreate, \"bio\">>;\n\n  // 1. Register a new user with valid info\n  const user: IUser = await api.functional.core.users.post(connection, {\n    body: baseUser as IUser.ICreate,\n  });\n  typia.assert(user);\n  TestValidator.equals(\"username\")(baseUser.username)(user.username);\n  TestValidator.equals(\"email\")(baseUser.email)(user.email);\n  TestValidator.equals(\"status\")(baseUser.status)(user.status);\n\n  // 2. Attempt registration with existing email (should fail)\n  await TestValidator.httpError(\"duplicate email/user\")([400, 409])(() =>\n    api.functional.core.users.post(connection, {\n      body: { ...baseUser, username: baseUser.username + \"_dupe\" },\n    }),\n  );\n  await TestValidator.httpError(\"duplicate username/email\")([400, 409])(() =>\n    api.functional.core.users.post(connection, {\n      body: { ...baseUser, email: \"dupe2_\" + baseUser.email },\n    }),\n  );\n\n  // 3. Missing required fields\n  await TestValidator.httpError(\"missing password\")([400, 422])(() =>\n    api.functional.core.users.post(connection, {\n      body: {\n        ...baseUser,\n        password: undefined as any,\n      },\n    }),\n  );\n\n  await TestValidator.httpError(\"missing email\")([400, 422])(() =>\n    api.functional.core.users.post(connection, {\n      body: {\n        ...baseUser,\n        email: undefined as any,\n      },\n    }),\n  );\n\n  await TestValidator.httpError(\"missing username\")([400, 422])(() =>\n    api.functional.core.users.post(connection, {\n      body: {\n        ...baseUser,\n        username: undefined as any,\n      },\n    }),\n  );\n\n  // Also missing user_role_id\n  await TestValidator.httpError(\"missing user_role_id\")([400, 422])(() =>\n    api.functional.core.users.post(connection, {\n      body: {\n        ...baseUser,\n        user_role_id: undefined as any,\n      },\n    }),\n  );\n}\n",
    "completed": 20,
    "total": 30,
    "step": 0
  },
  {
    "type": "testWrite",
    "created_at": "2025-06-24T07:35:30.957Z",
    "filename": "test/features/apiuser/test_update_user_profile_various_scenarios.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\n\n/**\n * E2E test for user profile update and edge cases.\n *\n * Scenario:\n * Successfully update profile fields for an existing user. Attempt to update with fields violating business logic (e.g. set email to an existing email), and expect an error. Attempt to update a non-existent user and expect a 404 error. Try without sufficient permissions and confirm access denied.\n *\n * Steps:\n * 1. Create a new user (User A) via the registration endpoint.\n * 2. Create another user (User B) to be used for duplication conflict tests.\n * 3. Update User A profile with new valid profile values (username, bio, status, etc.), expect success and updated values in response.\n * 4. Attempt to update User A's email to User B's existing email; expect validation/business logic error (usually HTTP 409 or 400).\n * 5. Attempt to update a non-existent user's profile; expect 404 not found error.\n * 6. Use a connection/session that lacks modification privilege, attempt to update User A's profile; expect forbidden or unauthorized error (401/403).\n */\nexport async function test_api_user_update_profile_various_scenarios(connection: api.IConnection): Promise<void> {\n  // 1. Create User A\n  const userA: IUser = await api.functional.core.users.post(connection, {\n    body: {\n      user_role_id: typia.random<string & tags.Format<\"uuid\">>(),\n      username: `userA_${Date.now()}`,\n      email: `userA_${Date.now()}@example.com`,\n      bio: \"User A original bio\",\n      password: \"Password123!\",\n      status: \"active\",\n    } satisfies IUser.ICreate,\n  });\n  typia.assert(userA);\n\n  // 2. Create User B (for duplicate email tests)\n  const userB: IUser = await api.functional.core.users.post(connection, {\n    body: {\n      user_role_id: typia.random<string & tags.Format<\"uuid\">>(),\n      username: `userB_${Date.now()}`,\n      email: `userB_${Date.now()}@example.com`,\n      bio: \"User B original bio\",\n      password: \"Password123!\",\n      status: \"active\",\n    } satisfies IUser.ICreate,\n  });\n  typia.assert(userB);\n\n  // 3. Update profile fields for User A\n  const updatedUsername = `userA_edited_${Date.now()}`;\n  const updatedBio = \"Updated User A bio\";\n  const updatedStatus = \"suspended\";\n  const updated: IUser = await api.functional.core.users.putById(connection, {\n    id: userA.id,\n    body: {\n      username: updatedUsername,\n      bio: updatedBio,\n      status: updatedStatus,\n    } satisfies IUser.IUpdate,\n  });\n  typia.assert(updated);\n  TestValidator.equals(\"username updated\")(updatedUsername)(updated.username);\n  TestValidator.equals(\"bio updated\")(updatedBio)(updated.bio);\n  TestValidator.equals(\"status updated\")(updatedStatus)(updated.status);\n\n  // 4. Attempt to update User A's email to User B's email (expect error)\n  await TestValidator.error(\"duplicate email\")(async () =>\n    api.functional.core.users.putById(connection, {\n      id: userA.id,\n      body: {\n        email: userB.email,\n      } satisfies IUser.IUpdate,\n    })\n  );\n\n  // 5. Attempt to update non-existent user (expect 404)\n  await TestValidator.httpError(\"non-existent user\")(404)(() =>\n    api.functional.core.users.putById(connection, {\n      id: typia.random<string & tags.Format<\"uuid\">>(), // almost guaranteed not to exist\n      body: { username: \"ghost_user\" } satisfies IUser.IUpdate,\n    })\n  );\n\n  // 6. (Simulated) Try with insufficient permissions – here we'll just demonstrate invocation\n  // In a real system, you'd use a connection for a user without rights;\n  // We'll simulate by replicating a connection with missing/invalid auth token\n  if (connection.simulate === undefined) {\n    const forbiddenConnection = { ...connection, headers: { ...connection.headers, Authorization: \"Bearer invalid-token\" } };\n    await TestValidator.httpError(\"forbidden update\")(403)(() =>\n      api.functional.core.users.putById(forbiddenConnection, {\n        id: userA.id,\n        body: { bio: \"Should not update\" } satisfies IUser.IUpdate,\n      })\n    );\n  }\n}\n",
    "completed": 22,
    "total": 30,
    "step": 0
  },
  {
    "type": "testWrite",
    "created_at": "2025-06-24T07:35:30.957Z",
    "filename": "test/features/apiuser/test_delete_user_soft_and_hard_and_invalid_cases.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\n\n/**\n * Validate user deletion operations (soft/hard delete and error cases).\n *\n * This test function verifies correct behavior of the DELETE /core/users/{id} endpoint in three scenarios:\n *   - Soft deletion (e.g., status marked as deleted, not full removal)\n *   - Hard deletion (full removal where possible — depends on API policy)\n *   - Error responses for invalid or unauthorized deletion attempts\n *\n * Steps:\n * 1. Create a new user via POST /core/users (required for deletion)\n * 2. Soft delete the user by calling DELETE /core/users/{id} and verify response (status is changed or id returned)\n * 3. Attempt to delete a non-existent user (expect a 404 Not Found error)\n * 4. Attempt to delete a user without proper authorization (simulate forbidden and expect failure)\n *\n * Implementation Notes:\n * - Ensures both API deletion flows are handled\n * - Explicitly tests error path for missing user ID and permission\n * - Performs type assertions and error validations\n */\nexport async function test_api_user_deletion_soft_and_hard_and_invalid_cases(connection: api.IConnection): Promise<void> {\n  // 1. Create a new user (to be deleted)\n  const created: IUser = await api.functional.core.users.post(connection, {\n    body: {\n      username: `test-user-${Date.now()}`,\n      email: `test-user-${Date.now()}@example.com`,\n      password: \"testPassword#123\",\n      user_role_id: \"00000000-0000-0000-0000-000000000001\", // Typical member role UUID; adapt if needed\n      status: \"active\",\n      bio: \"Temporary test user\",\n    } satisfies IUser.ICreate,\n  });\n  typia.assert(created);\n\n  // 2. Soft delete (status change or otherwise) the user\n  const deleted: IUser.IDeleteResponse = await api.functional.core.users.eraseById(connection, {\n    id: created.id,\n  });\n  typia.assert(deleted);\n  TestValidator.equals(\"delete id matches\")(created.id)(deleted.id ?? \"\");\n  // Optionally, check status is updated to \"deleted\", \"disabled\", etc., if returned\n  if (deleted.status) {\n    TestValidator.equals(\"deleted status\")([\"deleted\", \"suspended\", \"disabled\"].includes(deleted.status))(true);\n  }\n\n  // 3. Attempt to delete a non-existent user\n  const notExistId = \"aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa\"; // Unlikely to exist\n  await TestValidator.httpError(\"deleting non-existent user, expect 404\")(404)(() =>\n    api.functional.core.users.eraseById(connection, {\n      id: notExistId as string & tags.Format<\"uuid\">,\n    }),\n  );\n\n  // 4. Attempt to delete a user without proper authorization\n  // Simulate: usually by using a connection context with insufficient privileges\n  // (Here, we'll simulate by removing/overwriting an admin token if possible)\n  // The following block assumes connection manipulation for test\n  if (connection.headers?.Authorization) {\n    const fakeConnection = {\n      ...connection,\n      headers: { ...connection.headers, Authorization: \"Bearer fake-or-non-admin-token\" },\n    };\n    await TestValidator.httpError(\"delete user unauthorized\")(403)(() =>\n      api.functional.core.users.eraseById(fakeConnection, { id: created.id }),\n    );\n  }\n}\n",
    "completed": 26,
    "total": 30,
    "step": 0
  },
  {
    "type": "testWrite",
    "created_at": "2025-06-24T07:35:30.957Z",
    "filename": "test/features/apiuser-role/test_list_user_roles_with_and_without_filtering_and_permission_control.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport { IPageIUserRole } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIUserRole\";\nimport { IUserRole } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUserRole\";\n\n/**\n * List user roles with and without filtering, validate pagination and filter logic,\n * and confirm access control enforcement for non-admin users.\n *\n * This test validates the listing of user roles via the /core/userRoles PATCH API.\n * 1. List all user roles without any filter (default, admin user)\n * 2. List user roles with filtering by keyword ('member', 'admin', and gibberish)\n * 3. Validate pagination (page/limit)\n * 4. Attempt access with a non-admin (read-only) user and expect access denied\n */\nexport async function test_api_user_role_list_with_and_without_filtering_and_permission_control(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. List all roles without filter (admin account)\n  const outputAll: IPageIUserRole = await api.functional.core.userRoles.patch(\n    connection,\n    {\n      body: {},\n    },\n  );\n  typia.assert(outputAll);\n  TestValidator.equals(\"all roles exist\")(true)(Array.isArray(outputAll.data) && outputAll.data.length >= 1);\n\n  // Save a known role for search\n  const sampleRole: IUserRole | undefined = outputAll.data[0];\n  if (!sampleRole)\n    throw new Error(\"No user roles found for keyword filtering test.\");\n\n  // 2. Filter by keyword (name from existing role)\n  const outKeyword: IPageIUserRole = await api.functional.core.userRoles.patch(\n    connection,\n    {\n      body: { search: sampleRole.name },\n    },\n  );\n  typia.assert(outKeyword);\n  TestValidator.equals(\"keyword filter includes known role\")(\n    true,\n  )(!!outKeyword.data.find((r) => r.id === sampleRole.id));\n\n  // 2b. Filter by non-existent keyword (should return zero results)\n  const noneKeyword: IPageIUserRole = await api.functional.core.userRoles.patch(\n    connection,\n    {\n      body: { search: \"_NEVER_FIND_THIS_TEST_VALUE_\" },\n    },\n  );\n  typia.assert(noneKeyword);\n  TestValidator.equals(\"no roles for gibberish keyword\")(0)(noneKeyword.data.length);\n\n  // 3. Pagination edge case (page=1, limit=1)\n  const paged: IPageIUserRole = await api.functional.core.userRoles.patch(\n    connection,\n    {\n      body: { page: 1, limit: 1 },\n    },\n  );\n  typia.assert(paged);\n  TestValidator.equals(\"limit=1 applied\")(1)(paged.data.length);\n  TestValidator.equals(\"pagination.limit\")(1)(paged.pagination.limit);\n  TestValidator.equals(\"pagination.current\")(1)(paged.pagination.current);\n\n  // 4. Try as a non-admin user (should be forbidden or empty, depending on policy)\n  // Simulate account switch to non-admin (this connection must not have admin rights)\n  const nonAdminConnection = { ...connection, headers: { ...connection.headers, authorization: \"Bearer NON_ADMIN_TOKEN\" } };\n  await TestValidator.error(\"non-admin cannot list user roles\")(() =>\n    api.functional.core.userRoles.patch(nonAdminConnection, { body: {} }),\n  );\n}\n",
    "completed": 7,
    "total": 30,
    "step": 0
  },
  {
    "type": "testWrite",
    "created_at": "2025-06-24T07:35:30.957Z",
    "filename": "test/features/apiuser-role/test_get_user_role_details_success_and_nonexistent.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IUserRole } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUserRole\";\nimport typia, { tags } from \"typia\";\n\n/**\n * Validate fetching details for a user role by ID, covering both normal and error scenarios.\n *\n * This test covers both successful detail fetch for a valid user role ID and\n * proper error response for a non-existent ID.\n *\n * 1. Create a fresh user role via POST (to guarantee a valid ID)\n * 2. Fetch the details for that ID using GET /core/userRoles/:id\n *  └ Validate all required properties (id, name, description, users?)\n * 3. Try to fetch a user role with a random (non-existent) UUID\n *  └ Confirm 404 error or not found response\n */\nexport async function test_api_user_role_get_details_success_and_nonexistent(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. Create a new role so we have a valid, fresh role ID\n  const created: IUserRole = await api.functional.core.userRoles.post(connection, {\n    body: {\n      name: `role_${Date.now()}`,\n      description: \"Role created in E2E test for fetch details scenario.\",\n    } satisfies IUserRole.ICreate,\n  });\n  typia.assert(created);\n\n  // 2. Fetch its details using GET by id\n  const fetched: IUserRole = await api.functional.core.userRoles.getById(connection, {\n    id: created.id,\n  });\n  typia.assert(fetched);\n  // Validate fields\n  TestValidator.equals(\"id\")(created.id)(fetched.id);\n  TestValidator.equals(\"name\")(created.name)(fetched.name);\n  TestValidator.equals(\"description\")(created.description)(fetched.description);\n\n  // 3. Attempt to fetch with a non-existent role ID (should fail)\n  const fakeId = typia.random<string & tags.Format<\"uuid\">>() as string;\n  // Ensure we don't use the real one!\n  if (fakeId === created.id) throw new Error(\"RNG generated duplicate UUID\");\n  await TestValidator.httpError(\"fetch non-existing user role should 404\")\n    (404)\n    (() => api.functional.core.userRoles.getById(connection, { id: fakeId }));\n}\n",
    "completed": 3,
    "total": 30,
    "step": 0
  },
  {
    "type": "testWrite",
    "created_at": "2025-06-24T07:35:30.957Z",
    "filename": "test/features/apiuser-role/test_create_user_role_valid_duplicate_and_invalid_cases.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport { IUserRole } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUserRole\";\n\n/**\n * E2E test for creation of user roles.\n *\n * This test covers both successful creation with valid data,\n * failure when attempting to create a duplicate with same name,\n * and required-field validation for incomplete input.\n *\n * 1. Create a new user role with valid data and verify response structure.\n * 2. Attempt to create a user role with the same name (should fail due to uniqueness).\n * 3. Attempt to create a user role with missing required fields (should fail validation).\n */\nexport async function test_api_user_role_create_valid_duplicate_and_invalid_cases(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. Create a user role with valid data\n  const roleInput: IUserRole.ICreate = {\n    name: `moderator_${Date.now()}`,\n    description: \"Moderator role with privileges to moderate content.\",\n  };\n  const userRole: IUserRole = await api.functional.core.userRoles.post(connection, { body: roleInput });\n  typia.assert(userRole);\n  TestValidator.equals(\"role name\")<string>(roleInput.name)(userRole.name);\n  TestValidator.equals(\"role description\")<string>(roleInput.description)(userRole.description);\n\n  // 2. Attempt to create a role with the same name (should fail)\n  await TestValidator.httpError(\"duplicate role name should fail uniqueness constraint\")(409)(() =>\n    api.functional.core.userRoles.post(connection, { body: roleInput }),\n  );\n\n  // 3. Attempt incomplete role creation\n  await TestValidator.httpError(\"missing required name\") (400)(() =>\n    api.functional.core.userRoles.post(connection, {\n      body: {\n        description: \"Role description only\"\n        // name is missing\n      } as any,\n    })\n  );\n  await TestValidator.httpError(\"missing required description\") (400)(() =>\n    api.functional.core.userRoles.post(connection, {\n      body: {\n        name: `unique_${Date.now()}`,\n        // description is missing\n      } as any,\n    })\n  );\n}\n",
    "completed": 4,
    "total": 30,
    "step": 0
  },
  {
    "type": "testWrite",
    "created_at": "2025-06-24T07:35:30.957Z",
    "filename": "test/features/apiuser-role/test_update_user_role_label_and_description_with_uniqueness_checks.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { IUserRole } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUserRole\";\n\n/**\n * Edit the label and description of an existing user role, and validate edge cases.\n *\n * This test covers:\n * 1. Create two user roles for testing update and uniqueness validation.\n * 2. Update the label and description of the first user role and confirm changes.\n * 3. Attempt to update a non-existent role ID, expecting a 404 error.\n * 4. Attempt to update the second role's name to the first's name, expecting a uniqueness/duplicate error.\n *\n * Full scenario ensures proper field updating, proper error signaling on not-found roles,\n * and correct enforcement of uniqueness for the role label across all roles.\n */\nexport async function test_api_user_role_update_label_and_description_with_uniqueness_checks(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. Create two user roles\n  const roleA: IUserRole = await api.functional.core.userRoles.post(connection, {\n    body: {\n      name: \"moderator\",\n      description: \"Moderator can manage posts and handle reports.\",\n    } satisfies IUserRole.ICreate,\n  });\n  typia.assert(roleA);\n\n  const roleB: IUserRole = await api.functional.core.userRoles.post(connection, {\n    body: {\n      name: \"editor\",\n      description: \"Editor can modify content.\",\n    } satisfies IUserRole.ICreate,\n  });\n  typia.assert(roleB);\n\n  // 2. Update roleA's name & description\n  const updatedName = \"community-moderator\";\n  const updatedDescription = \"Community moderators have additional privileges.\";\n  const updated: IUserRole = await api.functional.core.userRoles.putById(connection, {\n    id: roleA.id,\n    body: {\n      name: updatedName,\n      description: updatedDescription,\n    } satisfies IUserRole.IUpdate,\n  });\n  typia.assert(updated);\n  TestValidator.equals(\"name updated\")(updated.name)(updatedName);\n  TestValidator.equals(\"description updated\")(updated.description)(updatedDescription);\n  TestValidator.equals(\"id invariant\")(updated.id)(roleA.id);\n\n  // 3. Attempt to update a non-existent user role, expect 404\n  const nonExistentId = \"00000000-0000-0000-0000-000000000000\" as string & tags.Format<\"uuid\">;\n  await TestValidator.httpError(\"update non-existent user role should 404\")(404)(() =>\n    api.functional.core.userRoles.putById(connection, {\n      id: nonExistentId,\n      body: { name: \"ghost\", description: \"Ghost role.\" },\n    })\n  );\n\n  // 4. Attempt to set roleB's name to updated roleA's name, expect uniqueness/duplicate error\n  await TestValidator.error(\"role name must be unique\")(() =>\n    api.functional.core.userRoles.putById(connection, {\n      id: roleB.id,\n      body: { name: updatedName },\n    })\n  );\n}\n",
    "completed": 6,
    "total": 30,
    "step": 0
  },
  {
    "type": "testWrite",
    "created_at": "2025-06-24T07:35:30.957Z",
    "filename": "test/features/apiuser-role/test_delete_user_role_simple_and_constraint_violation.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IUserRole } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUserRole\";\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport typia, { tags } from \"typia\";\n\n/**\n * Validate user role deletion logic: success, not-found, in-use (constraint violation).\n *\n * This test covers deletion of user roles including normal, not-found, and constraint scenarios:\n *\n * 1. Create a user role to be deleted later.\n * 2. Delete the newly created user role (should succeed).\n * 3. Attempt to delete a non-existent role (should fail with 404).\n * 4. Create another user role.\n * 5. Create a user and assign to this new user role.\n * 6. Attempt to delete the role now in use (should fail with constraint-violation).\n */\nexport async function test_api_user_role_delete_constraint_and_edge_cases(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. Create a user role to be deleted later\n  const roleToDelete: IUserRole = await api.functional.core.userRoles.post(connection, {\n    body: {\n      name: `role-to-delete-${Date.now()}`,\n      description: \"Temp role for deletion test\",\n    } satisfies IUserRole.ICreate,\n  });\n  typia.assert(roleToDelete);\n\n  // 2. Delete the newly created user role\n  const deleteResp: IUserRole.IDeleteResponse = await api.functional.core.userRoles.eraseById(connection, {\n    id: roleToDelete.id,\n  });\n  typia.assert(deleteResp);\n  TestValidator.equals(\"deleted role id\")(roleToDelete.id)(deleteResp.id);\n  TestValidator.equals(\"delete response status\")(\"deleted\")(deleteResp.status);\n\n  // 3. Attempt to delete a non-existent role (expect 404)\n  const fakeRoleId = typia.random<string & tags.Format<\"uuid\">>();\n  await TestValidator.httpError(\"delete non-existent user role\")(404)(() =>\n    api.functional.core.userRoles.eraseById(connection, { id: fakeRoleId })\n  );\n\n  // 4. Create another user role\n  const roleInUse: IUserRole = await api.functional.core.userRoles.post(connection, {\n    body: {\n      name: `role-in-use-${Date.now()}`,\n      description: \"Role to test constraint deletion\",\n    } satisfies IUserRole.ICreate,\n  });\n  typia.assert(roleInUse);\n\n  // 5. Create a user and assign to this new role\n  const user: IUser = await api.functional.core.users.post(connection, {\n    body: {\n      user_role_id: roleInUse.id,\n      username: `deleteroletestuser_${Date.now()}`,\n      email: `deleteroletestuser_${Date.now()}@wrtn.io`,\n      password: \"testpassword1234!\",\n      bio: null,\n      status: \"active\",\n    } satisfies IUser.ICreate,\n  });\n  typia.assert(user);\n  TestValidator.equals(\"created user's role\")(roleInUse.id)(user.user_role_id);\n\n  // 6. Attempt to delete the in-use user role (should fail due to constraint)\n  await TestValidator.error(\"delete user role in use should fail\")(() =>\n    api.functional.core.userRoles.eraseById(connection, { id: roleInUse.id })\n  );\n}\n",
    "completed": 21,
    "total": 30,
    "step": 0
  },
  {
    "type": "testWrite",
    "created_at": "2025-06-24T07:35:30.957Z",
    "filename": "test/features/apicategory/test_list_categories_with_various_filters_and_empty_state.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { ICategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/ICategory\";\nimport { IPageICategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageICategory\";\nimport typia from \"typia\";\n\n/**\n * 카테고리 목록을 다양한 필터(이름, 설명, 생성일 등)와 페이징 옵션으로 조회한다.\n * 권한 제한(예: 비관리자 일부 필터 제한) 및 카테고리 데이터가 없을 때의 빈 상태 처리까지 확인한다.\n *\n * 1. 카테고리가 아무것도 없을 때 page=1, limit=10 으로 요청해 빈 배열과 정상 메타 데이터 반환 확인\n * 2. 여러 카테고리(A/B/C) 더미 등록(사전 등록 API가 없다면 DB mocking/fixture 또는 사전 데이터 필요)\n * 3. 이름, 설명, 생성일로 각기 다른 필터 조합/paging입력으로 여러 번 목록 조회\n * 4. 각 필터 결과에 맞게 반환 데이터와 pagination 정보가 올바른지 체크\n * 5. 권한이 필요한 필터(설정된 경우)로 일반 권한 계정에서 접근 시 에러(예: 403) 체크\n */\nexport async function test_api_category_list_with_various_filters_and_empty_state(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. 카테고리 없을 때 조회\n  const emptyReq = { page: 1, limit: 10 } satisfies ICategory.IRequest;\n  const emptyList: IPageICategory = await api.functional.core.categories.patch(\n    connection,\n    { body: emptyReq },\n  );\n  typia.assert(emptyList);\n  TestValidator.equals(\"empty data\")(emptyList.data)([]);\n  TestValidator.equals(\"pagination record count\")(emptyList.pagination.records)(0);\n\n  // 2. (전제) 카테고리 다수(A/B/C 등 사전 준비 필요, fixture 등 활용 또는 관리자로 사전 생성)\n  // 여기에 카테고리 생성 사전 작업이 필요합니다. (생략: 실제 환경에 맞게 별도 준비할 것)\n\n  // 3. 여러 조건으로 조회 (이름, 설명, 기간)\n  const filterByName: IPageICategory = await api.functional.core.categories.patch(\n    connection,\n    {\n      body: {\n        page: 1,\n        limit: 5,\n        name: \"정치\",\n      },\n    },\n  );\n  typia.assert(filterByName);\n  for (const cat of filterByName.data) TestValidator.equals(\"name filter\")(\"정치\")(cat.name);\n\n  const filterByDesc: IPageICategory = await api.functional.core.categories.patch(\n    connection,\n    {\n      body: {\n        page: 1,\n        limit: 5,\n        description: \"경제\",\n      },\n    },\n  );\n  typia.assert(filterByDesc);\n  for (const cat of filterByDesc.data) TestValidator.equals(\"desc filter\")(true)(cat.description.includes(\"경제\"));\n\n  // 생성일 범위 조회 (예: 2024-01-01 ~ 2025-01-01)\n  const filterByDate: IPageICategory = await api.functional.core.categories.patch(\n    connection,\n    {\n      body: {\n        page: 1,\n        limit: 5,\n        created_from: \"2024-01-01T00:00:00+09:00\",\n        created_to: \"2025-01-01T00:00:00+09:00\",\n      },\n    },\n  );\n  typia.assert(filterByDate);\n  for (const cat of filterByDate.data) {\n    TestValidator.equals(\"created from filter\")(\n      true,\n    )(\n      cat.created_at >= \"2024-01-01T00:00:00+09:00\" &&\n        cat.created_at <= \"2025-01-01T00:00:00+09:00\",\n    );\n  }\n\n  // 4. 페이징/전체 건수도 올바른지 체크\n  TestValidator.equals(\"limit 체크\")(filterByName.data.length <= 5)(true);\n  TestValidator.equals(\"페이지네이션 structure\")(typeof filterByName.pagination.pages === \"number\")(true);\n\n  // 5. (Optional) 권한이 필요한 필터/필드에 대해, 비관리자 접근 시 http error 판단: 403\n  // (실제로 적용되는 권한 정책/엔드포인트 구현 시에만 활성화. 미구현 시 생략 가능)\n  // await TestValidator.httpError(\"필터 권한 제한\")(403)(() =>\n  //   api.functional.core.categories.patch(\n  //     일반권한의 connection, { body: { ...권한필요필터... } },\n  //   ),\n  // );\n}\n",
    "completed": 18,
    "total": 30,
    "step": 0
  },
  {
    "type": "testWrite",
    "created_at": "2025-06-24T07:35:30.957Z",
    "filename": "test/features/apicategory/test_get_category_by_id_success_and_not_found.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { ICategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/ICategory\";\nimport typia, { tags } from \"typia\";\n\n/**\n * Retrieve a category by ID and verify details, then attempt with non-existent ID for 404.\n *\n * - First, a new category is created and its response is validated.\n * - Then, category is fetched by ID and all fields are compared for equality.\n * - Lastly, a GET with a random UUID is performed and should return 404.\n *\n * Steps:\n * 1. Create category via POST /core/categories\n * 2. Retrieve it using GET /core/categories/{id} and match response fields\n * 3. Attempt to get using a random UUID, expect 404 error\n */\nexport async function test_api_category_getById_success_and_not_found(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. Create a new category\n  const categoryCreate: ICategory.ICreate = {\n    name: `테스트카테고리_${Date.now()}`,\n    description: \"E2E 단일 조회 테스트용 카테고리입니다.\",\n  };\n  const created: ICategory = await api.functional.core.categories.post(connection, {\n    body: categoryCreate,\n  });\n  typia.assert(created);\n\n  // 2. Retrieve the created category by ID\n  const fetched: ICategory = await api.functional.core.categories.getById(connection, {\n    id: created.id,\n  });\n  typia.assert(fetched);\n  TestValidator.equals(\"id\")(created.id)(fetched.id);\n  TestValidator.equals(\"name\")(created.name)(fetched.name);\n  TestValidator.equals(\"description\")(created.description)(fetched.description);\n  // created_at is ISO 8601 string - just check it's a valid date string\n  TestValidator.equals(\"created_at not empty\")(true)(!!fetched.created_at);\n\n  // 3. Attempt to retrieve non-existent/random category ID -> expect 404\n  const randomId: string & tags.Format<\"uuid\"> = typia.random<string & tags.Format<\"uuid\">>();\n  await TestValidator.httpError(\"category not found should return 404\")(404)(() =>\n    api.functional.core.categories.getById(connection, { id: randomId })\n  );\n}\n",
    "completed": 1,
    "total": 30,
    "step": 0
  },
  {
    "type": "testWrite",
    "created_at": "2025-06-24T07:35:30.957Z",
    "filename": "test/features/apicategory/test_create_category_with_valid_uniqueness_and_validation_cases.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { ICategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/ICategory\";\nimport typia from \"typia\";\n\n/**\n * E2E 테스트: 카테고리 신규 생성 및 중복/유효성 에러 처리 검증\n *\n * 이 테스트는 관리자가 토론 게시판의 카테고리를 생성할 때 정상적으로 신규 카테고리가 생성되는지,\n * 고유 name/slug 중복 시 유니크 제약 에러가 발생하는지, 필수 입력값이 없을 때 유효성 에러가 반환되는지를 검증합니다.\n *\n * 1. 정상 입력값으로 카테고리를 생성한다 (성공 확인)\n * 2. 동일 name/slug로 한 번 더 생성 시도 → 유니크 에러 확인\n * 3. name, description이 누락된 요청(각각 개별 케이스) → 유효성(validation) 에러 확인\n */\nexport async function test_api_category_create_with_valid_and_error_cases(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. 정상 등록 (성공)\n  const validInput: ICategory.ICreate = {\n    name: `이슈-${Math.random().toString(36).slice(2, 7)}`,\n    description: \"최신 이슈를 다루는 공간입니다.\",\n  };\n  const category: ICategory = await api.functional.core.categories.post(\n    connection,\n    { body: validInput }\n  );\n  typia.assert(category);\n  TestValidator.equals(\"이름 일치\")(validInput.name)(category.name);\n  TestValidator.equals(\"설명 일치\")(validInput.description)(category.description);\n\n  // 2. 동일 name/slug로 한 번 더 생성 → 유니크 오류 확인\n  await TestValidator.httpError(\"카테고리명 중복 생성시 409 에러\")(409)(() =>\n    api.functional.core.categories.post(connection, { body: validInput }),\n  );\n\n  // 3-1. name 누락 (description만)\n  await TestValidator.httpError(\"카테고리명 누락 validation 실패\")(400)(() =>\n    api.functional.core.categories.post(connection, {\n      body: { description: \"설명만 있음\" } as any,\n    }),\n  );\n\n  // 3-2. description 누락 (name만)\n  await TestValidator.httpError(\"카테고리 설명 누락 validation 실패\")(400)(() =>\n    api.functional.core.categories.post(connection, {\n      body: { name: \"only-name\" } as any,\n    }),\n  );\n}\n",
    "completed": 19,
    "total": 30,
    "step": 0
  },
  {
    "type": "testWrite",
    "created_at": "2025-06-24T07:35:30.957Z",
    "filename": "test/features/apicategory/test_update_category_fields_and_uniqueness.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { ICategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/ICategory\";\n\n/**\n * Update category fields and validate uniqueness constraint and 404 errors.\n *\n * This test validates the category update logic for name and description fields, \n * as well as the enforcement of name uniqueness and handling of non-existent IDs.\n *\n * 1. Create two distinct categories (to check normal update and uniqueness failure)\n * 2. Update the first category's name and description (should succeed)\n * 3. Attempt to update the first category's name to that of the second (should fail with unique error)\n * 4. Attempt to update a non-existent category ID (should fail with 404)\n */\nexport async function test_api_category_update_fields_and_uniqueness(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. Create two categories for test\n  const categoryA: ICategory = await api.functional.core.categories.post(connection, {\n    body: {\n      name: `정치-${Date.now()}`,\n      description: `정치 관련 토론 카테고리입니다. (${Date.now()})`,\n    } satisfies ICategory.ICreate,\n  });\n  typia.assert(categoryA);\n\n  const categoryB: ICategory = await api.functional.core.categories.post(connection, {\n    body: {\n      name: `사회-${Date.now()}`,\n      description: `사회 이슈 다루는 공간. (${Date.now()})`,\n    } satisfies ICategory.ICreate,\n  });\n  typia.assert(categoryB);\n\n  // 2. Update categoryA's name and description\n  const updatedA: ICategory = await api.functional.core.categories.putById(connection, {\n    id: categoryA.id,\n    body: {\n      name: `${categoryA.name}-수정`,\n      description: `${categoryA.description} (설명 수정)`\n    } satisfies ICategory.IUpdate,\n  });\n  typia.assert(updatedA);\n  TestValidator.equals(\"id 동일\")(categoryA.id)(updatedA.id);\n  TestValidator.equals(\"이름 반영됨\")(updatedA.name)(`${categoryA.name}-수정`);\n  TestValidator.equals(\"설명 반영됨\")(updatedA.description)(`${categoryA.description} (설명 수정)`);\n\n  // 3. Try to update to a duplicate name (should fail)\n  await TestValidator.httpError(\"중복 이름 에러\")(409)(() =>\n    api.functional.core.categories.putById(connection, {\n      id: categoryA.id,\n      body: {\n        name: categoryB.name,\n      } satisfies ICategory.IUpdate,\n    })\n  );\n\n  // 4. Attempt to update a non-existent category (should 404)\n  await TestValidator.httpError(\"존재하지 않는 ID\")(404)(() =>\n    api.functional.core.categories.putById(connection, {\n      id: \"00000000-0000-4000-8000-000000000404\" as string & tags.Format<\"uuid\">,\n      body: { name: \"없는카테고리\" } satisfies ICategory.IUpdate,\n    })\n  );\n}\n",
    "completed": 15,
    "total": 30,
    "step": 0
  },
  {
    "type": "testWrite",
    "created_at": "2025-06-24T07:35:30.957Z",
    "filename": "test/features/apicategory/test_delete_category_simple_and_constraint_violation.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { ICategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/ICategory\";\nimport { IPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPost\";\nimport typia, { tags } from \"typia\";\n\n/**\n * 카테고리 삭제 동작 및 제약 조건 검증 테스트.\n *\n * - 정상적으로 생성한 카테고리를 삭제 요청할 수 있다.\n * - 존재하지 않는 카테고리 삭제 요청 시 404 오류를 반환한다.\n * - 게시글이 할당된 카테고리 삭제 시 제약조건에 의해 실패(에러 응답 또는 실패 플래그)를 반환한다.\n *\n * [테스트 절차]\n * 1. 삭제용 카테고리 생성\n * 2. 해당 카테고리 정상 삭제 및 성공 여부/메시지 검증\n * 3. 임의(랜덤) UUID로 삭제 요청시 404 오류 검증\n * 4. 새 카테고리 및 해당 카테고리에 게시글 생성\n * 5. 해당 카테고리 삭제 시도 → 제약조건 위반(실패 응답 또는 에러 코드/메시지) 검증\n */\nexport async function test_api_category_delete_simple_and_constraint_violation(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. 삭제용 카테고리 생성\n  const category: ICategory = await api.functional.core.categories.post(\n    connection,\n    {\n      body: {\n        name: `삭제테스트카테고리-${Math.random().toString(36).slice(2)}`,\n        description: \"삭제를 검증하는 테스트 카테고리입니다.\",\n      } satisfies ICategory.ICreate,\n    }\n  );\n  typia.assert(category);\n\n  // 2. 해당 카테고리 정상 삭제\n  const deleteResult: ICategory.IDeleteResult = await api.functional.core.categories.eraseById(connection, {\n    id: category.id,\n  });\n  typia.assert(deleteResult);\n  TestValidator.equals(\"delete success flag\")(true)(deleteResult.success);\n\n  // 3. 존재하지 않는 랜덤 UUID 카테고리 삭제 → 404 오류 검증\n  const nonExistentId = typia.random<string & tags.Format<\"uuid\">>();\n  await TestValidator.httpError(\"non-existent category delete should fail: 404\")(404)(() =>\n    api.functional.core.categories.eraseById(connection, {\n      id: nonExistentId,\n    })\n  );\n\n  // 4. 게시글 할당 용 카테고리 및 게시글 생성\n  const usedCategory: ICategory = await api.functional.core.categories.post(\n    connection, {\n      body: {\n        name: `사용중카테고리-${Math.random().toString(36).slice(2)}`,\n        description: \"게시글이 할당된 카테고리 삭제 제약 검증.\",\n      } satisfies ICategory.ICreate,\n    }\n  );\n  typia.assert(usedCategory);\n\n  // 테스트용 가상 유저, 게시글 생성\n  const testUserId = typia.random<string & tags.Format<\"uuid\">>();\n  const post: IPost = await api.functional.posts.posts.post(connection, {\n    body: {\n      category_id: usedCategory.id,\n      title: \"카테고리 제약 테스트 게시글\",\n      content: \"이 카테고리가 삭제 제약 조건에 걸리는지 검사합니다.\",\n      user_id: testUserId,\n    } satisfies IPost.ICreate,\n  });\n  typia.assert(post);\n\n  // 5. 게시글이 할당된 카테고리 삭제 → 제약조건 에러/실패 검증\n  // 실패 유형(에러·실패플래그) 모두 허용. 에러시 httpError, 그렇지 않으면 success=false 체크\n  try {\n    const constraintDelete = await api.functional.core.categories.eraseById(connection, {\n      id: usedCategory.id,\n    });\n    typia.assert(constraintDelete);\n    TestValidator.equals(\"constraint delete failure flag\")(false)(constraintDelete.success);\n  } catch (err: any) {\n    // 시스템 제약 위반의 경우 HTTP 4xx/5xx 에러를 반환할 수도 있음.\n    await TestValidator.error(\"constraint violation error\")(err);\n  }\n}\n",
    "completed": 12,
    "total": 30,
    "step": 0
  },
  {
    "type": "testWrite",
    "created_at": "2025-06-24T07:35:30.957Z",
    "filename": "test/features/apipost/test_list_posts_paginated_and_filtered_with_permission_checks.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\n\nimport { IPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPost\";\nimport { IPageIPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIPost\";\n\n/**\n * 게시글 목록 조회 및 필터, 페이징 및 권한별 처리 검증 테스트.\n *\n * 다양한 필터(작성자, 카테고리, 날짜)에 따른 게시글 목록 조회와 페이징 처리를 검증한다.\n * 또한, 필터 조합별 응답의 정합성, 포스트 미존재 시 빈 결과/에러 처리,\n * 그리고 비작성자/작성자/관리자별 권한 처리도 함께 확인한다.\n *\n * 1. 여러 게시글을 생성 (서로 다른 카테고리, 작성자, 날짜)\n * 2. 카테고리별, 작성자별, 날짜 구간별, 키워드별 필터 요청\n * 3. 필터 조합(카테고리+작성자, 작성자+기간 등)으로도 요청\n * 4. 페이지네이션(1페이지/여러 페이지/마지막 페이지) 결과 검증\n * 5. 필터에 아무 것도 안맞는 케이스(빈 결과/정상 처리)\n * 6. 작성자가 아닌 계정, 관리자 계정 등 권한 별로도 목록을 조회 (삭제 포함/제외 여부 등 차이)\n */\nexport async function test_api_post_list_paginated_and_filtered_with_permission_checks(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. 여러 개의 게시글을 생성합니다. (여러 카테고리, 작성자, 날짜 분포)\n  // (assume: 관리자/일반 유저 로그인 승인된 connection 및 post 생성 API 활용 가능)\n  \n  // ...생성 로직/권한별 계정 로그인 스텝 생략: 본 테스트 가정(주입 데이터 or 사전 생성)\n  // 이하 필터/페이징/권한별 목록 조회 자체에 집중\n\n  // 2. 카테고리별 필터링 테스트\n  const byCategory: IPageIPost = await api.functional.posts.posts.patch(connection, {\n    body: {\n      category_id: \"category-uuid-1\",\n      page: 1,\n      limit: 10,\n    } satisfies IPost.IRequest\n  });\n  typia.assert(byCategory);\n  byCategory.data.forEach(post => TestValidator.equals(\"category_id\")(post.category_id)(\"category-uuid-1\"));\n\n  // 3. 작성자별 필터링 테스트\n  const byUser: IPageIPost = await api.functional.posts.posts.patch(connection, {\n    body: {\n      user_id: \"user-uuid-1\",\n      page: 1,\n      limit: 10,\n    } satisfies IPost.IRequest\n  });\n  typia.assert(byUser);\n  byUser.data.forEach(post => TestValidator.equals(\"user_id\")(post.user_id)(\"user-uuid-1\"));\n\n  // 4. 날짜 구간별(기간) 필터링 테스트\n  const byDate: IPageIPost = await api.functional.posts.posts.patch(connection, {\n    body: {\n      created_from: \"2024-05-01T00:00:00.000Z\",\n      created_to: \"2024-05-31T23:59:59.999Z\",\n      page: 1,\n      limit: 10,\n    } satisfies IPost.IRequest\n  });\n  typia.assert(byDate);\n  byDate.data.forEach(post => {\n    TestValidator.greater_equal(\"created_at lower bound\")(post.created_at)(\"2024-05-01T00:00:00.000Z\");\n    TestValidator.less_equal(\"created_at upper bound\")(post.created_at)(\"2024-05-31T23:59:59.999Z\");\n  });\n\n  // 5. 키워드(제목/내용) 별 필터링 테스트\n  const byTitle: IPageIPost = await api.functional.posts.posts.patch(connection, {\n    body: {\n      title: \"테스트\",\n      page: 1,\n      limit: 10,\n    } satisfies IPost.IRequest\n  });\n  typia.assert(byTitle);\n  byTitle.data.forEach(post => TestValidator.contains(\"title\")(post.title)(\"테스트\"));\n\n  const byContent: IPageIPost = await api.functional.posts.posts.patch(connection, {\n    body: {\n      content: \"본문키워드\",\n      page: 1,\n      limit: 10,\n    } satisfies IPost.IRequest\n  });\n  typia.assert(byContent);\n  byContent.data.forEach(post => TestValidator.contains(\"content\")(post.content)(\"본문키워드\"));\n\n  // 6. 필터 조합 테스트 (카테고리+작성자)\n  const byCategoryAndUser: IPageIPost = await api.functional.posts.posts.patch(connection, {\n    body: {\n      category_id: \"category-uuid-1\",\n      user_id: \"user-uuid-1\",\n      page: 1,\n      limit: 10\n    } satisfies IPost.IRequest\n  });\n  typia.assert(byCategoryAndUser);\n  byCategoryAndUser.data.forEach(post => {\n    TestValidator.equals(\"category_id\")(post.category_id)(\"category-uuid-1\");\n    TestValidator.equals(\"user_id\")(post.user_id)(\"user-uuid-1\");\n  });\n\n  // 7. 페이지네이션 검증(1/여러페이지/끝)\n  const page1: IPageIPost = await api.functional.posts.posts.patch(connection, {\n    body: {\n      page: 1,\n      limit: 1\n    } satisfies IPost.IRequest\n  });\n  typia.assert(page1);\n  TestValidator.equals(\"current page 1\")(page1.pagination.current)(1);\n  TestValidator.equals(\"limit 1\")(page1.pagination.limit)(1);\n\n  if(page1.pagination.pages > 1) {\n    const page2: IPageIPost = await api.functional.posts.posts.patch(connection, {\n      body: {\n        page: 2,\n        limit: 1\n      } satisfies IPost.IRequest\n    });\n    typia.assert(page2);\n    TestValidator.equals(\"current page 2\")(page2.pagination.current)(2);\n  }\n\n  // 마지막 페이지 요청(빈 배열/정상)\n  const lastPage: IPageIPost = await api.functional.posts.posts.patch(connection, {\n    body: {\n      page: 100,\n      limit: 100\n    } satisfies IPost.IRequest\n  });\n  typia.assert(lastPage);\n  TestValidator.equals(\"empty result when over-paging\")(lastPage.data.length)(0);\n\n  // 8. 매칭 안 되는 필터(빈 결과)\n  const noMatch: IPageIPost = await api.functional.posts.posts.patch(connection, {\n    body: {\n      title: \"__존재하지않는키워드__\",\n      page: 1,\n      limit: 10\n    } satisfies IPost.IRequest\n  });\n  typia.assert(noMatch);\n  TestValidator.equals(\"empty result for unmatched title\")(noMatch.data.length)(0);\n\n  // 9. 권한 체크: 비작성자(guest)/작성자/관리자 계정 별 개시글 목록 노출 범위/삭제포함 검증\n  // (아래는 일반 예시, 실제 권한별 connection/session, 삭제글 여부는 별도 추가 구현 필요)\n  // 예: 작성자 계정으로도 테스트\n\n  // 예시: 작성자 본인 계정\n  // await api.functional.auth.loginAs({ ...작성자1정보 });\n  // const ownPosts = await api.functional.posts.posts.patch(작성자1connection, { ... });\n  // ownPosts.data.forEach(post => TestValidator.equals(post.user_id)(작성자1));\n  \n  // 예시: 관리자 계정 테스트 (삭제된 글 포함 조회 등)\n  // await api.functional.auth.loginAs({ ...관리자 });\n  // const adminPosts = await api.functional.posts.posts.patch(관리자커넥션, { ... });\n  // adminPosts.data.forEach(post => { ... });\n}\n",
    "completed": 30,
    "total": 30,
    "step": 0
  },
  {
    "type": "testWrite",
    "created_at": "2025-06-24T07:35:30.957Z",
    "filename": "test/features/apipost/test_get_post_by_id_success_not_found_and_permission_check.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPost\";\nimport typia, { tags } from \"typia\";\n\n/**\n * E2E test: Retrieve post details and verify error cases.\n *\n * 1. Create a post with valid category_id, title, content, and user_id.\n * 2. Retrieve created post by ID; check all fields.\n * 3. Attempt to fetch a non-existent post (expect 404).\n * 4. (If applicable) Attempt to fetch as unauthorized user (expect permission error).\n */\nexport async function test_api_post_get_post_by_id_success_not_found_and_permission_check(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. Create a post for detail retrieval\n  const postCreate: IPost.ICreate = {\n    category_id: typia.random<string & tags.Format<\"uuid\">>(),\n    title: \"E2E Test: Post Detail\",\n    content: \"This is a full e2e test post.\",\n    user_id: typia.random<string & tags.Format<\"uuid\">>(),\n  };\n  const created: IPost = await api.functional.posts.posts.post(connection, {\n    body: postCreate,\n  });\n  typia.assert(created);\n  TestValidator.equals(\"title\")(postCreate.title)(created.title);\n  TestValidator.equals(\"content\")(postCreate.content)(created.content);\n  TestValidator.equals(\"category_id\")(postCreate.category_id)(created.category_id);\n  TestValidator.equals(\"user_id\")(postCreate.user_id)(created.user_id);\n  TestValidator.equals(\"deleted_at\")(null)(created.deleted_at ?? null);\n\n  // 2. Retrieve created post by ID\n  const found: IPost = await api.functional.posts.posts.getById(connection, {\n    id: created.id,\n  });\n  typia.assert(found);\n  TestValidator.equals(\"id\")(created.id)(found.id);\n  TestValidator.equals(\"title\")(created.title)(found.title);\n  TestValidator.equals(\"content\")(created.content)(found.content);\n  TestValidator.equals(\"category_id\")(created.category_id)(found.category_id);\n  TestValidator.equals(\"user_id\")(created.user_id)(found.user_id);\n\n  // 3. Try fetch non-existent post\n  await TestValidator.httpError(\"not found\")(404)(() =>\n    api.functional.posts.posts.getById(connection, {\n      id: \"00000000-0000-0000-0000-000000000000\" as string & tags.Format<\"uuid\">,\n    }),\n  );\n\n  // 4. (Optional, if API supports) Attempt unauthorized access\n  // For illustration, simulate as 'guest' or with missing headers, or duplicate connection and clear auth if API depends on it.\n  // If no auth layer, skip this part.\n  //\n  // Example:\n  // const unauthorizedConnection = { ...connection, headers: { ...connection.headers, authorization: undefined } };\n  // await TestValidator.httpError(\"unauthorized\")(401)(() =>\n  //   api.functional.posts.posts.getById(unauthorizedConnection, { id: created.id }),\n  // );\n}\n",
    "completed": 23,
    "total": 30,
    "step": 0
  },
  {
    "type": "testWrite",
    "created_at": "2025-06-24T07:35:30.957Z",
    "filename": "test/features/apipost/test_create_post_success_validation_and_uniqueness.ts",
    "content": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport { TestValidator } from \"@nestia/e2e\";\nimport { IPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPost\";\n\n/**\n * Create a post with various validation scenarios.\n *\n * This test validates the post creation API by checking:\n * 1. Success with all valid required fields.\n * 2. Failure when required fields are missing (validation error expected).\n * 3. Failure when attempting to create a post with a duplicate title (uniqueness error expected).\n *\n * Steps:\n * 1. Prepare valid category/user IDs (these should be existing/allowed values) and post data.\n * 2. Create a valid post and expect success.\n * 3. Try to create a post with missing required fields (e.g., missing title/content/category_id/user_id) and expect a 400 error.\n * 4. Attempt to create another post with the same title as before, and expect a 409 (conflict/unique constraint error).\n */\nexport async function test_api_post_create_validation_and_uniqueness(connection: api.IConnection): Promise<void> {\n  // 1. Prepare valid data\n  const category_id = typia.random<string & typia.tags.Format<\"uuid\">>();\n  const user_id = typia.random<string & typia.tags.Format<\"uuid\">>();\n  const title = `Test Post Title ${Date.now()}`;\n  const content = \"This is the content for a valid test post.\";\n\n  // 2. Create the valid post\n  const post: IPost = await api.functional.posts.posts.post(connection, {\n    body: {\n      category_id,\n      user_id,\n      title,\n      content\n    } satisfies IPost.ICreate\n  });\n  typia.assert(post);\n\n  // 3. Attempt missing required fields (category_id)\n  await TestValidator.httpError(\"missing category_id\")(400)(() =>\n    api.functional.posts.posts.post(connection, {\n      body: {\n        user_id,\n        title: \"No Category\",\n        content\n      } as any\n    })\n  );\n\n  // 3-2. Attempt missing required fields (user_id)\n  await TestValidator.httpError(\"missing user_id\")(400)(() =>\n    api.functional.posts.posts.post(connection, {\n      body: {\n        category_id,\n        title: \"No User\",\n        content\n      } as any\n    })\n  );\n\n  // 3-3. Attempt missing required fields (title)\n  await TestValidator.httpError(\"missing title\")(400)(() =>\n    api.functional.posts.posts.post(connection, {\n      body: {\n        category_id,\n        user_id,\n        content\n      } as any\n    })\n  );\n\n  // 3-4. Attempt missing required fields (content)\n  await TestValidator.httpError(\"missing content\")(400)(() =>\n    api.functional.posts.posts.post(connection, {\n      body: {\n        category_id,\n        user_id,\n        title\n      } as any\n    })\n  );\n\n  // 4. Attempt to create a post with duplicate title (same title, category, user)\n  await TestValidator.httpError(\"duplicate post title\")(409)(() =>\n    api.functional.posts.posts.post(connection, {\n      body: {\n        category_id,\n        user_id,\n        title,\n        content: \"This is another post with the same title.\"\n      } satisfies IPost.ICreate\n    })\n  );\n}\n",
    "completed": 8,
    "total": 30,
    "step": 0
  },
  {
    "type": "testWrite",
    "created_at": "2025-06-24T07:35:30.957Z",
    "filename": "test/features/apipost/test_update_post_fields_and_permission_and_uniqueness.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\n\nimport { IPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPost\";\n\n/**\n * Test post update: fields, uniqueness, permission, not-found.\n *\n * - Checks full update and field changes\n * - Validates error on updating to a duplicate title (uniqueness)\n * - Ensures updating a non-existent post returns 404\n * - Permission enforcement: only author can update\n *\n * Steps:\n * 1. Create post1 and post2 with different titles\n * 2. Update post1's title/content/category\n * 3. Attempt to update post2's title to be the same as post1 (should fail)\n * 4. Attempt to update a made-up (non-existent) postId (should 404)\n * 5. Simulate permission: attempt to update as a different user\n */\nexport async function test_api_post_update_fields_and_permission_and_uniqueness(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. Create post1 (as user1)\n  const post1Body: IPost.ICreate = {\n    user_id: typia.random<string>(),\n    category_id: typia.random<string>(),\n    title: \"Unique Title 1\" + Date.now(),\n    content: \"Content A\",\n  };\n  const post1: IPost = await api.functional.posts.posts.post(connection, { body: post1Body });\n  typia.assert(post1);\n\n  // 1. Create post2 (as user1, same user, different title)\n  const post2Body: IPost.ICreate = {\n    ...post1Body,\n    title: \"Unique Title 2\" + Date.now(),\n    content: \"Content B\",\n  };\n  const post2: IPost = await api.functional.posts.posts.post(connection, { body: post2Body });\n  typia.assert(post2);\n\n  // 2. Update post1's fields\n  const updatePayload: IPost.IUpdate = {\n    title: \"New Title X\" + Math.random(),\n    content: \"Edited content \" + Math.random(),\n    category_id: typia.random<string>(),\n  };\n  const updated: IPost = await api.functional.posts.posts.putById(connection, {\n    id: post1.id,\n    body: updatePayload,\n  });\n  typia.assert(updated);\n  TestValidator.equals(\"updated title\")(updatePayload.title)(updated.title);\n  TestValidator.equals(\"updated content\")(updatePayload.content)(updated.content);\n  TestValidator.equals(\"updated category\")(updatePayload.category_id)(updated.category_id);\n\n  // 3. Attempt to update post2's title to post1's updated title (should fail: uniqueness)\n  await TestValidator.error(\"duplicate title should be error\")(() =>\n    api.functional.posts.posts.putById(connection, {\n      id: post2.id,\n      body: { title: updatePayload.title },\n    }),\n  );\n\n  // 4. Try to update a non-existent post\n  const fakeId = typia.random<string>();\n  await TestValidator.httpError(\"not found error\")(404)(() =>\n    api.functional.posts.posts.putById(connection, {\n      id: fakeId,\n      body: { title: \"should-not-exist\" },\n    }),\n  );\n\n  // 5. (Optional/Ideal) Try updating as a different user (simulate by making a post with different author)\n  // Here, simulate as if another user (diff user_id) tries to update post1\n  const user2Id = typia.random<string>();\n  // Post by user2 for permission check (if enforced; otherwise skip)\n  await TestValidator.error(\"permission enforcement\")(() =>\n    api.functional.posts.posts.putById(connection, {\n      id: post1.id,\n      body: { title: \"illegal write attempt\" },\n      // in reality, would need session/connection for user2;\n      // here we show intended logic only\n    }),\n  );\n}\n",
    "completed": 25,
    "total": 30,
    "step": 0
  },
  {
    "type": "testWrite",
    "created_at": "2025-06-24T07:35:30.957Z",
    "filename": "test/features/apipost/test_delete_post_normal_permission_and_not_found.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\nimport { IPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPost\";\n\n/**\n * 게시글 삭제 기능에 대한 일반 및 예외 시나리오 E2E 테스트\n *\n * 1. 정상적으로 자신이 작성한 게시글을 삭제할 수 있다.\n * 2. 존재하지 않는 게시글을 삭제 시도할 경우 404 에러가 발생해야 한다.\n * 3. 타인이 작성한 게시글을 삭제 시도할 경우 권한 실패(403/401 등)이 발생해야 한다.\n *\n * 테스트 플로우:\n *   1) 테스트용 유저 A로 게시글 작성\n *   2) 해당 게시글 정상 삭제 시도 → 삭제 성공 확인\n *   3) 무작위(존재하지 않는) UUID로 삭제 시도 → 404 NotFound 확인\n *   4) 다른 유저 B가 유저 A의 게시글 삭제 시도 → 권한 거부(실패) 확인\n */\nexport async function test_delete_post_normal_permission_and_not_found(connection: api.IConnection): Promise<void> {\n  // 1. 테스트용 유저 A 로그인/가입(가정 혹은 세션 사용)\n  //    실제 환경에서 필요한 경우 테스트 계정 세션/쿠키/토큰 발급 필요\n  // (여기서는 connection이 이미 유저A 인증 세션을 갖고 있다고 가정)\n\n  // 2. 게시글 생성 (for normal delete)\n  const postCreateInput: IPost.ICreate = {\n    category_id: typia.random<string & tags.Format<\"uuid\">>(),\n    title: \"테스트용 삭제 대상 게시글\",\n    content: \"삭제 정상 동작 확인용 본문입니다.\",\n    user_id: typia.random<string & tags.Format<\"uuid\">>()\n  };\n  const createdPost: IPost = await api.functional.posts.posts.post(connection, {\n    body: postCreateInput\n  });\n  typia.assert(createdPost);\n\n  // 3. 자신이 작성한 게시글 정상 삭제\n  const deleteResult: IPost.IDeleteResult = await api.functional.posts.posts.eraseById(connection, {\n    id: createdPost.id\n  });\n  typia.assert(deleteResult);\n  TestValidator.equals(\"정상 삭제 결과 success=true\")(true)(deleteResult.success);\n\n  // 4. 존재하지 않는 게시글 삭제 시도 → 404 Not Found\n  await TestValidator.httpError(\"존재하지 않는 게시글 삭제시 404\")(404)(() =>\n    api.functional.posts.posts.eraseById(connection, {\n      id: typia.random<string & tags.Format<\"uuid\">>() // 무작위 uuid로 존재하지 않는 id 생성\n    })\n  );\n\n  // 5. 타인(B)이 A의 게시글(이미 삭제됨)을 다시 한 번 삭제 시도 (권한 거부 또는 이미 삭제됨)\n  //    * 실제로는 실패 응답 코드(403/404) 중 정책에 따라 달라질 수 있음.\n  //    * connectionB: 유저B 인증 세션으로 교체 필요 (여기서는 session/connection 분리 가정)\n  const connectionB = { ...connection, headers: { ...connection.headers, \"x-user-id\": typia.random<string & tags.Format<\"uuid\">>() }};\n  await TestValidator.error(\"타인이 삭제 시도시 권한 실패\")(async () => {\n    await api.functional.posts.posts.eraseById(connectionB, {\n      id: createdPost.id  // 이미 삭제됨\n    });\n  });\n}\n",
    "completed": 9,
    "total": 30,
    "step": 0
  },
  {
    "type": "testWrite",
    "created_at": "2025-06-24T07:35:30.957Z",
    "filename": "test/features/apicomment/test_list_comments_paginated_filtered_and_permissions.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\n\nimport { IComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IComment\";\nimport { IPageIComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIComment\";\n\n/**\n * Validate paginated and filtered retrieval of comments, including edge cases and permissions.\n *\n * This E2E test checks that the comments list API correctly applies filtering by post, author, and parent,\n * supports pagination and keyword searching, returns appropriate results for empty filters and page overflows,\n * and properly enforces permissions (e.g., no access to deleted/private/forbidden comments).\n *\n * Steps:\n * 1. Create two distinct posts and users with comments (simulate at least two authors and two threads)\n * 2. List comments filtered by a specific postId (should return only comments for that post)\n * 3. List comments filtered by author (userId)\n * 4. List replies using parentId filter\n * 5. Perform full-text search with expected keyword\n * 6. Request a page with offset/limit on a dataset larger than limit; verify correct slice\n * 7. Fetch a page where no comments match (empty result)\n * 8. Fetch page far beyond data boundaries (page overflow; should return empty data)\n * 9. (Optional if permissions supported) Try to list with unauthorized session or on deleted/forbidden comments – should fail or return filtered results\n */\nexport async function test_api_comment_list_paginated_filtered_and_permissions(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. (Bootstrapping) Create test data for two posts, two users, and nested comments/replies\n  // These would use pre-existing e2e helper APIs or dedicated creation API endpoints.\n  // -- For illustration: Assume two posts (postIdA, postIdB), two users (userA, userB) and establish context.\n  // Here we assume the existence of such posts and users, replace with creation/fixture logic as needed.\n  const postIdA = \"fake-post-uuid-a\" as string; // Replace with actual test postId\n  const postIdB = \"fake-post-uuid-b\" as string;\n  const userA = \"fake-user-uuid-a\" as string;\n  const userB = \"fake-user-uuid-b\" as string;\n\n  // 2. List by postId (should return only comments for that post)\n  let result: IPageIComment = await api.functional.posts.comments.patch(connection, {\n    body: {\n      postId: postIdA,\n    } satisfies IComment.IRequest,\n  });\n  typia.assert(result);\n  for (const c of result.data) {\n    TestValidator.equals(\"postId filter\")(postIdA)(c.post_id);\n  }\n\n  // 3. List by author (userId)\n  result = await api.functional.posts.comments.patch(connection, {\n    body: {\n      userId: userB,\n    } satisfies IComment.IRequest,\n  });\n  typia.assert(result);\n  for (const c of result.data) {\n    TestValidator.equals(\"userId filter\")(userB)(c.user_id);\n  }\n\n  // 4. Filter for replies to a parent comment\n  // (Assuming at least one reply exists with a parent_id set; otherwise, skip or inject reply during data setup)\n  const withParent = result.data.find(c => c.parent_id);\n  if (withParent && withParent.parent_id) {\n    const parentId = withParent.parent_id;\n    const replies = await api.functional.posts.comments.patch(connection, {\n      body: {\n        parentId,\n      } satisfies IComment.IRequest,\n    });\n    typia.assert(replies);\n    for (const r of replies.data) {\n      TestValidator.equals(\"parentId filter\")(parentId)(r.parent_id);\n    }\n  }\n\n  // 5. Perform keyword search (simulate keyword known in content; in real test, you would create comments with distinct text)\n  const searchTerm = \"est\";\n  result = await api.functional.posts.comments.patch(connection, {\n    body: {\n      search: searchTerm,\n      limit: 100,\n    } satisfies IComment.IRequest,\n  });\n  typia.assert(result);\n  // Cannot automatically determine if all \"data\" match the search (depends on test data), so just validate structure\n\n  // 6. Pagination slice: Create enough comments (or use preloaded fixture), fetch a slice\n  result = await api.functional.posts.comments.patch(connection, {\n    body: {\n      offset: 0,\n      limit: 1,\n      postId: postIdA,\n    } satisfies IComment.IRequest,\n  });\n  typia.assert(result);\n  TestValidator.equals(\"pagination limit\")(Math.min(result.pagination.records, 1))(result.data.length);\n\n  // 7. Fetch where no comments match (e.g., by invalid userId)\n  result = await api.functional.posts.comments.patch(connection, {\n    body: {\n      userId: \"00000000-0000-0000-0000-000000000000\",\n    } satisfies IComment.IRequest,\n  });\n  typia.assert(result);\n  TestValidator.equals(\"no comments match\")(0)(result.data.length);\n\n  // 8. Page well out of range\n  result = await api.functional.posts.comments.patch(connection, {\n    body: {\n      postId: postIdA,\n      offset: 5000,\n      limit: 10,\n    } satisfies IComment.IRequest,\n  });\n  typia.assert(result);\n  TestValidator.equals(\"out-of-range page\")(0)(result.data.length);\n\n  // 9. Permission: try with forbidden/deleted resource or restricted context\n  // This is framework-specific. Optionally: simulate with a restricted or guest account/session, or with deleted comment IDs\n  // (Usually should return empty or 403/401 as per permission rules.)\n  // Example:\n  // await TestValidator.httpError(\"permission enforcement\")(403)(() =>\n  //   api.functional.posts.comments.patch(connection, {\n  //     body: { postId: postIdB },\n  //   })\n  // );\n}\n",
    "completed": 29,
    "total": 30,
    "step": 0
  },
  {
    "type": "testWrite",
    "created_at": "2025-06-24T07:35:30.957Z",
    "filename": "test/features/apicomment/test_get_comment_by_id_success_deleted_not_found_permission.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IComment\";\nimport typia from \"typia\";\n\n/**\n * Validate retrieving comment details and access control.\n *\n * 1. Create a comment as a registered user.\n * 2. Retrieve the comment by ID—expect success for valid ID.\n * 3. Attempt to retrieve a deleted or non-existent comment—expect 404 error.\n * 4. (If available) Check that only authorized users can view comments marked deleted/hidden.\n *\n * This test ensures the Comment GET endpoint enforces existence and permission rules, and returns proper errors for missing or unauthorized access.\n */\nexport async function test_api_comment_get_detail_permission(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. Create a comment\n  const createInput: IComment.ICreate = {\n    user_id: typia.random<string>(), // Assume a valid user uuid is used in real tests\n    post_id: typia.random<string>(), // Assume a valid post uuid is used in real tests\n    content: \"Test comment content\",\n  };\n  const comment: IComment = await api.functional.posts.comments.post(connection, {\n    body: createInput,\n  });\n  typia.assert(comment);\n\n  // 2. Retrieve the comment by ID—should succeed\n  const found: IComment = await api.functional.posts.comments.getById(connection, {\n    id: comment.id,\n  });\n  typia.assert(found);\n\n  // 3. Attempt to retrieve a non-existent comment (random UUID)—should 404\n  await TestValidator.httpError(\"non-existent comment not found\")(404)(() =>\n    api.functional.posts.comments.getById(connection, {\n      id: typia.random<string>(), // random uuid not corresponding to any comment\n    })\n  );\n\n  // (Optional) 4. Attempt to retrieve a deleted comment as a normal user (simulate soft delete if possible)\n  // NOTE: This step would require a delete API and possibly user session logic—pseudo-code only:\n  // await api.functional.posts.comments.delete(connection, { id: comment.id });\n  // await TestValidator.httpError(\"deleted comment hidden\")(404)(() =>\n  //   api.functional.posts.comments.getById(connection, { id: comment.id })\n  // );\n  // // (If system supports privilege elevation:) Attempt as moderator/admin...\n}\n",
    "completed": 2,
    "total": 30,
    "step": 0
  },
  {
    "type": "testWrite",
    "created_at": "2025-06-24T07:35:30.957Z",
    "filename": "test/features/apicomment/test_create_comment_valid_invalid_and_foreign_key_cases.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\n\nimport { IComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IComment\";\nimport { IPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPost\";\n\n/**\n * Create a new comment with valid and invalid cases (content length, required fields, foreign key constraints).\n *\n * This E2E test verifies that comment creation works properly for valid data, and fails gracefully with validation or foreign key errors for:\n *  - Too short/too long content\n *  - Missing required fields\n *  - Invalid post_id or user_id\n *\n * Steps:\n * 1. Create a valid post (prerequisite for comment attachment).\n * 2. Create a comment with valid data attached to that post.\n * 3. Attempt to create a comment with too short content.\n * 4. Attempt to create a comment with too long content.\n * 5. Attempt to create a comment missing required fields (content, user_id, post_id).\n * 6. Attempt to create a comment referencing a non-existent post_id.\n * 7. Attempt to create a comment referencing a non-existent user_id.\n */\nexport async function test_api_comment_create_valid_invalid_and_foreign_key_cases(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. Create a valid post\n  const post: IPost = await api.functional.posts.posts.post(connection, {\n    body: {\n      category_id: \"00000000-0000-0000-0000-000000001111\", // Assumed valid UUID\n      title: \"Test post for comments\",\n      content: \"This is a post intended to accept comments.\",\n      user_id: \"00000000-0000-0000-0000-000000002222\", // Assumed valid user UUID\n    } satisfies IPost.ICreate,\n  });\n  typia.assert(post);\n\n  // 2. Create a comment with valid data\n  const validComment: IComment = await api.functional.posts.comments.post(\n    connection,\n    {\n      body: {\n        user_id: post.user_id,\n        post_id: post.id,\n        content: \"This is a valid comment created by E2E test.\",\n      } satisfies IComment.ICreate,\n    }\n  );\n  typia.assert(validComment);\n  TestValidator.equals(\"comment.post_id\")(post.id)(validComment.post_id);\n  TestValidator.equals(\"comment.user_id\")(post.user_id)(validComment.user_id);\n\n  // 3. Attempt with too short content\n  await TestValidator.httpError(\"validate too short content\")(400)(() =>\n    api.functional.posts.comments.post(connection, {\n      body: {\n        user_id: post.user_id,\n        post_id: post.id,\n        content: \"\",\n      } satisfies IComment.ICreate,\n    })\n  );\n\n  // 4. Attempt with too long content\n  await TestValidator.httpError(\"validate too long content\")(400)(() =>\n    api.functional.posts.comments.post(connection, {\n      body: {\n        user_id: post.user_id,\n        post_id: post.id,\n        content: \"a\".repeat(10_000), // Exceeds expected max for test\n      } satisfies IComment.ICreate,\n    })\n  );\n\n  // 5a. Missing content\n  await TestValidator.httpError(\"missing content\")(400)(() =>\n    api.functional.posts.comments.post(connection, {\n      body: {\n        user_id: post.user_id,\n        post_id: post.id,\n        // content omitted\n      } as any,\n    })\n  );\n\n  // 5b. Missing user_id\n  await TestValidator.httpError(\"missing user_id\")(400)(() =>\n    api.functional.posts.comments.post(connection, {\n      body: {\n        // user_id omitted\n        post_id: post.id,\n        content: \"Missing user_id field.\",\n      } as any,\n    })\n  );\n\n  // 5c. Missing post_id\n  await TestValidator.httpError(\"missing post_id\")(400)(() =>\n    api.functional.posts.comments.post(connection, {\n      body: {\n        user_id: post.user_id,\n        // post_id omitted\n        content: \"Missing post_id field.\",\n      } as any,\n    })\n  );\n\n  // 6. Non-existent post_id\n  await TestValidator.httpError(\"non-existent post_id\")(404)(() =>\n    api.functional.posts.comments.post(connection, {\n      body: {\n        user_id: post.user_id,\n        post_id: \"00000000-0000-0000-0000-111111112222\", // Not in DB\n        content: \"Foreign key post test.\",\n      } satisfies IComment.ICreate,\n    })\n  );\n\n  // 7. Non-existent user_id\n  await TestValidator.httpError(\"non-existent user_id\")(404)(() =>\n    api.functional.posts.comments.post(connection, {\n      body: {\n        user_id: \"00000000-0000-0000-0000-999999991111\", // Not in DB\n        post_id: post.id,\n        content: \"Foreign key user test.\",\n      } satisfies IComment.ICreate,\n    })\n  );\n}\n",
    "completed": 16,
    "total": 30,
    "step": 0
  },
  {
    "type": "testWrite",
    "created_at": "2025-06-24T07:35:30.957Z",
    "filename": "test/features/apicomment/test_update_comment_content_and_permissions.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport { IComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IComment\";\n\n/**\n * Test updating a comment's content and all permission/error scenarios.\n *\n * This verifies:\n * 1. Only the comment owner or admin can update a comment.\n * 2. Updating the content works for normal valid cases.\n * 3. Attempting to update with too short/long content fails by validation error.\n * 4. Attempting to update a non-existent comment results in 404 error.\n *\n * Steps:\n * 1. Create two users: userA (owner) and userB (non-owner).\n * 2. UserA creates a post (assumed or mocked if posts not implemented here).\n * 3. UserA comments on the post (fetch created comment for ID).\n * 4. UserA updates their own comment successfully with valid content.\n * 5. UserB attempts to update UserA's comment (expect 403/401 error).\n * 6. Attempt to update the comment with invalid content (empty, too long).\n * 7. Attempt to update a random (non-existent) comment ID (expect 404).\n * 8. (Optionally) If admin context exists, verify admin can update any comment.\n */\nexport async function test_api_comment_update_content_and_permissions(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. Create two users: userA and userB & login as userA\n  // (Assume user API, otherwise mock context -- pseudo, not implemented here)\n  const userA_id = \"00000000-0000-4000-8000-000000000001\";\n  const userB_id = \"00000000-0000-4000-8000-000000000002\";\n\n  // 2. Assume a post\n  const post_id = \"00000000-0000-4000-8000-000000001111\";\n\n  // 3. UserA creates a comment\n  const comment: IComment = await api.functional.posts.comments.post(\n    connection,\n    {\n      body: {\n        user_id: userA_id,\n        post_id: post_id,\n        content: \"Good comment!\",\n      },\n    },\n  );\n  typia.assert(comment);\n\n  // 4. UserA updates their own comment with valid content\n  const updated: IComment = await api.functional.posts.comments.putById(\n    connection,\n    {\n      id: comment.id,\n      body: {\n        content: \"Updated by owner.\",\n      },\n    },\n  );\n  typia.assert(updated);\n  TestValidator.equals(\"content changed\")(\"Updated by owner.\")(updated.content);\n\n  // 5. UserB tries to update the comment (should fail: forbidden or unauthorized)\n  // Simulate as if connection/user_id is now userB (if supported)\n  await TestValidator.httpError(\"Non-owner forbidden\")(403)(() =>\n    api.functional.posts.comments.putById(connection, {\n      id: comment.id,\n      body: {\n        content: \"Non-owner not allowed.\",\n      },\n    }),\n  );\n\n  // 6. Owner tries invalid contents: empty & too long\n  // (Assume 1 is too short; 3001+ too long if max is 3000 chars)\n  await TestValidator.httpError(\"Empty content\")(400)(() =>\n    api.functional.posts.comments.putById(connection, {\n      id: comment.id,\n      body: { content: \"\" },\n    }),\n  );\n  await TestValidator.httpError(\"Too long\")(400)(() =>\n    api.functional.posts.comments.putById(connection, {\n      id: comment.id,\n      body: { content: \"x\".repeat(4000) },\n    }),\n  );\n\n  // 7. Random non-existent comment id\n  await TestValidator.httpError(\"Not found\")(404)(() =>\n    api.functional.posts.comments.putById(connection, {\n      id: \"ffffffff-ffff-4fff-8fff-ffffffffffff\",\n      body: { content: \"Should not exist.\" },\n    }),\n  );\n}\n",
    "completed": 13,
    "total": 30,
    "step": 0
  },
  {
    "type": "testWrite",
    "created_at": "2025-06-24T07:35:30.957Z",
    "filename": "test/features/apicomment/test_delete_comment_soft_and_permission_errors.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\nimport { IComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IComment\";\n\n/**\n * E2E test for comment soft-delete, 404 error and permission check.\n *\n * - Verifies business logic for soft-deleting a comment (logical deletion, checks the deleted flag/timestamp)\n * - Attempts deletion of a non-existent comment and expects 404 error\n * - Attempts to delete a comment without sufficient permissions and expects authorization error\n * This covers the main scenarios relevant to /posts/comments/:id DELETE\n *\n * 1. Create a comment (as authorized user)\n * 2. Soft-delete the created comment (expect deleted: true and deleted_at set)\n * 3. Attempt to delete a non-existent comment (expect 404 error)\n * 4. Attempt to delete another user's comment (as unauthorized user, expect 403/401 error)\n */\nexport async function test_api_comment_erase_soft_delete_and_permission_errors(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. Create a comment as user A\n  const userAId = typia.random<string & tags.Format<\"uuid\">>();\n  const postId = typia.random<string & tags.Format<\"uuid\">>();\n  const comment: IComment = await api.functional.posts.comments.post(\n    connection,\n    {\n      body: {\n        user_id: userAId,\n        post_id: postId,\n        content: \"Initial test comment.\",\n      } satisfies IComment.ICreate,\n    },\n  );\n  typia.assert(comment);\n\n  // 2. Soft-delete the created comment as user A (expect success)\n  const deleteResult: IComment.IDeleteResult = await api.functional.posts.comments.eraseById(\n    connection,\n    { id: comment.id },\n  );\n  typia.assert(deleteResult);\n  TestValidator.equals(\"deleted comment id\")(comment.id)(deleteResult.id);\n  TestValidator.equals(\"soft-delete status\")(true)(deleteResult.deleted);\n\n  // For deeper check, (if a fetch-by-id exists, we might re-fetch and check deleted_at)\n  // But these functions are not specified here, so we focus on contract.\n\n  // 3. Attempt to delete a non-existent comment (expect 404 Not Found error)\n  const notFoundId = typia.random<string & tags.Format<\"uuid\">>();\n  await TestValidator.httpError(\"delete non-existent comment\")(404)(() =>\n    api.functional.posts.comments.eraseById(connection, { id: notFoundId })\n  );\n\n  // 4. Attempt to delete another user's comment (user B tries to delete user A's comment)\n  // Assume that 'connection' can represent a session; simulate by changing user_id for this test\n  // (Full authentication context switching is assumed to be possible; otherwise would mock)\n  const userBId = typia.random<string & tags.Format<\"uuid\">>();\n  const commentOfA: IComment = await api.functional.posts.comments.post(\n    connection,\n    {\n      body: {\n        user_id: userAId,\n        post_id: postId,\n        content: \"Comment owned by A\",\n      } satisfies IComment.ICreate,\n    },\n  );\n  typia.assert(commentOfA);\n\n  // Suppose connection for user B is made, or we try to pass B's id (real-world: session/cookies)\n  // Here, we just demonstrate intent as SDK interface does not provide account context\n  await TestValidator.error(\"unauthorized delete by non-owner\")(() =>\n    api.functional.posts.comments.eraseById(connection, { id: commentOfA.id })\n  );\n}\n",
    "completed": 28,
    "total": 30,
    "step": 0
  },
  {
    "type": "testWrite",
    "created_at": "2025-06-24T07:35:30.957Z",
    "filename": "test/features/apivote/test_list_votes_paginated_filtered_and_permission_restrictions.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IVote } from \"@ORGANIZATION/PROJECT-api/lib/structures/IVote\";\nimport { IPageIVote } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIVote\";\nimport typia from \"typia\";\n\n/**\n * List votes, paginated and filterable, verifying filter logic, pagination, and permissions.\n *\n * This test validates the votes list endpoint with the following scenario:\n * 1. (Preconditioned) Multiple votes exist, cast by different users on various posts and comments.\n * 2. Filter votes by userId and verify that only votes belonging to this user are returned.\n * 3. Filter votes by postId to ensure only votes for a particular post are returned.\n * 4. Filter votes by commentId to ensure only votes for a particular comment are returned.\n * 5. Test pagination by requesting a limited subset (limit/offset) and verify boundaries.\n * 6. Test default sorting (created_at:desc) and custom sort if supported.\n * 7. Test that normal users only see their own votes, but admin can see all.\n */\nexport async function test_api_vote_list_paginated_filtered_and_permission_restrictions(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. Simulate as admin: list ALL votes\n  const allVotes: IPageIVote = await api.functional.votes.votes.patch(connection, {\n    body: {\n      limit: 50,\n      offset: 0,\n    } satisfies IVote.IRequest,\n  });\n  typia.assert(allVotes);\n  TestValidator.equals(\"no more than limit\")(\n    true,\n  )(allVotes.data.length <= 50);\n\n  if (allVotes.data.length === 0) return; // Cannot proceed if no data in DB\n\n  // Pick a vote record (to extract user_id, post_id, comment_id for further testing)\n  const sample = allVotes.data[0];\n  const { user_id, post_id, comment_id } = sample;\n\n  // 2. Filter by userId: ensure only votes by this user\n  const byUser: IPageIVote = await api.functional.votes.votes.patch(connection, {\n    body: {\n      userId: user_id,\n      limit: 10,\n    },\n  });\n  typia.assert(byUser);\n  byUser.data.forEach((vote) =>\n    TestValidator.equals(\"votes: by user id\")(user_id)(vote.user_id),\n  );\n\n  // 3. Filter by postId (if present)\n  if (post_id) {\n    const byPost: IPageIVote = await api.functional.votes.votes.patch(connection, {\n      body: {\n        postId: post_id,\n        limit: 10,\n      },\n    });\n    typia.assert(byPost);\n    byPost.data.forEach((vote) => {\n      TestValidator.equals(\"votes: by post id\")(post_id)(vote.post_id);\n      TestValidator.equals(\"votes: should not have comment_id\")(\n        null,\n      )(vote.comment_id ?? null);\n    });\n  }\n\n  // 4. Filter by commentId (if present)\n  if (comment_id) {\n    const byComment: IPageIVote = await api.functional.votes.votes.patch(connection, {\n      body: {\n        commentId: comment_id,\n        limit: 10,\n      },\n    });\n    typia.assert(byComment);\n    byComment.data.forEach((vote) => {\n      TestValidator.equals(\"votes: by comment id\")(comment_id)(vote.comment_id);\n      TestValidator.equals(\"votes: should not have post_id\")(\n        null,\n      )(vote.post_id ?? null);\n    });\n  }\n\n  // 5. Pagination boundary: skip the first, fetch next page and assert no overlap\n  if (allVotes.data.length > 1) {\n    const page1: IPageIVote = await api.functional.votes.votes.patch(connection, {\n      body: {\n        offset: 0,\n        limit: 1,\n      },\n    });\n    const page2: IPageIVote = await api.functional.votes.votes.patch(connection, {\n      body: {\n        offset: 1,\n        limit: 1,\n      },\n    });\n    typia.assert(page1);\n    typia.assert(page2);\n    if (page1.data.length && page2.data.length) {\n      TestValidator.equals(\"pagination: no overlap\")(\n        false,\n      )(page1.data[0].id === page2.data[0].id);\n    }\n  }\n\n  // 6. Permissions check: simulate as normal user (should only see their votes)\n  // For the test, must re-authenticate as the user in 'user_id' (assume connection switching supported)\n  // This block is conceptually correct, adjust depending on test infra\n  if (connection.switchUser) {\n    await connection.switchUser(user_id);\n    const ownVotes: IPageIVote = await api.functional.votes.votes.patch(connection, {\n      body: { userId: user_id },\n    });\n    typia.assert(ownVotes);\n    ownVotes.data.forEach((vote) =>\n      TestValidator.equals(\"user should only see own votes\")(user_id)(vote.user_id),\n    );\n  }\n}\n",
    "completed": 10,
    "total": 30,
    "step": 0
  },
  {
    "type": "testWrite",
    "created_at": "2025-06-24T07:35:30.957Z",
    "filename": "test/features/apivote/test_get_vote_by_id_success_not_found_and_permission.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport { IVote } from \"@ORGANIZATION/PROJECT-api/lib/structures/IVote\";\n\n/**\n * Validate full retrieval and error handling for vote details by ID.\n *\n * Test the following scenarios:\n * 1. Create a vote as a user using POST /votes/votes.\n * 2. Retrieve the created vote using GET /votes/votes/{id} and verify the returned data matches creation.\n * 3. Attempt to retrieve a vote using a non-existent UUID, expect 404 Not Found.\n * 4. (Optional) Simulate retrieval as a different user to check permission (expect 403 Forbidden or appropriate error if enforced).\n */\nexport async function test_api_vote_get_vote_by_id_success_not_found_and_permission(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. Create a vote as a random user\n  const voteInput: IVote.ICreate = {\n    user_id: typia.random<string & typia.tags.Format<\"uuid\">>(),\n    value: 1,\n    post_id: typia.random<string & typia.tags.Format<\"uuid\">>(),\n    comment_id: null,\n  };\n  const created: IVote = await api.functional.votes.votes.post(connection, {\n    body: voteInput,\n  });\n  typia.assert(created);\n  \n  // 2. Retrieve the created vote by ID\n  const retrieved: IVote = await api.functional.votes.votes.getById(connection, {\n    id: created.id,\n  });\n  typia.assert(retrieved);\n  TestValidator.equals(\"vote id matches\")(created.id)(retrieved.id);\n  TestValidator.equals(\"user id matches\")(created.user_id)(retrieved.user_id);\n  TestValidator.equals(\"value matches\")(created.value)(retrieved.value);\n\n  // 3. Attempt to retrieve vote with non-existent UUID\n  const fakeId = typia.random<string & typia.tags.Format<\"uuid\">>()\n    .replace(/[0-9]/g, v => (+(v)+1)%10) // mutate so it's almost certain to not exist\n    ;\n  await TestValidator.httpError(\"vote not found should yield 404\")(404)(() =>\n    api.functional.votes.votes.getById(connection, { id: fakeId })\n  );\n\n  // 4. (Optional) Permission test: simulate as different user if API restricts access\n  // This assumes the connection context allows switching user identity.\n  // Please implement session switching here if your auth system supports it, such as:\n  //   await loginAsOtherUser(connection);\n  //   await TestValidator.httpError(\"forbidden for non-owner\")(403)(() =>\n  //     api.functional.votes.votes.getById(connection, { id: created.id })\n  //   );\n}\n",
    "completed": 5,
    "total": 30,
    "step": 0
  },
  {
    "type": "testWrite",
    "created_at": "2025-06-24T07:35:30.957Z",
    "filename": "test/features/apivote/test_create_vote_valid_duplicate_and_invalid_refs.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport { IVote } from \"@ORGANIZATION/PROJECT-api/lib/structures/IVote\";\n\n/**\n * E2E Test for vote creation API - covers valid vote creation, duplicate voting (conflict), and invalid reference errors.\n *\n * 1. Prepare a valid user and a valid post (we assume their IDs are available or would be set up using other APIs).\n * 2. Create a vote with valid user and post (success expected).\n * 3. Attempt to create a duplicate vote with the same user and post (expect a conflict/unique violation error).\n * 4. Attempt to create a vote with a non-existent user_id (expect validation or foreign key error).\n * 5. Attempt to create a vote with a non-existent post_id (expect validation or foreign key error).\n * 6. Attempt to create a vote with both post_id and comment_id (expect validation error).\n * 7. Attempt to create a vote with neither post_id nor comment_id (expect validation error).\n */\nexport async function test_api_vote_create_valid_duplicate_and_invalid_refs(connection: api.IConnection): Promise<void> {\n  // --- Test Preparation: prepare valid user and post IDs (replace with real E2E fixtures/setups in real environment)\n  const validUserId = \"00000000-0000-4000-8000-000000000001\"; // Use UUID from fixture or user creation\n  const validPostId = \"11111111-1111-4000-8000-111111111111\"; // Use UUID from fixture or post creation\n  const otherNonExistUuid = \"cccccccc-cccc-4000-8000-cccccccccccc\";\n\n  // 1. Create a vote referencing valid user and post (success)\n  const voteBody: IVote.ICreate = {\n    user_id: validUserId,\n    value: 1,\n    post_id: validPostId,\n  };\n  const vote = await api.functional.votes.votes.post(connection, { body: voteBody });\n  typia.assert(vote);\n  TestValidator.equals(\"user_id\")(voteBody.user_id)(vote.user_id);\n  TestValidator.equals(\"post_id\")(voteBody.post_id)(vote.post_id);\n  TestValidator.equals(\"value\")(voteBody.value)(vote.value);\n\n  // 2. Attempt to create a duplicate vote (same user_id/post_id, should fail)\n  await TestValidator.httpError(\"duplicate vote conflict\")(409)(() =>\n    api.functional.votes.votes.post(connection, { body: voteBody })\n  );\n\n  // 3. Create with non-existent user_id (should fail foreign key or validation)\n  await TestValidator.httpError(\"non-existent user_id\")(422)(() =>\n    api.functional.votes.votes.post(connection, {\n      body: { ...voteBody, user_id: otherNonExistUuid },\n    })\n  );\n\n  // 4. Create with non-existent post_id\n  await TestValidator.httpError(\"non-existent post_id\")(422)(() =>\n    api.functional.votes.votes.post(connection, {\n      body: { ...voteBody, post_id: otherNonExistUuid },\n    })\n  );\n\n  // 5. Both post_id and comment_id present - should fail validation\n  await TestValidator.httpError(\"both post_id/comment_id present\")(400)(() =>\n    api.functional.votes.votes.post(connection, {\n      body: { ...voteBody, comment_id: validPostId },\n    })\n  );\n\n  // 6. Neither post_id nor comment_id present - should fail validation\n  await TestValidator.httpError(\"no post_id nor comment_id\")(400)(() =>\n    api.functional.votes.votes.post(connection, {\n      body: { user_id: validUserId, value: 1 },\n    })\n  );\n}\n",
    "completed": 17,
    "total": 30,
    "step": 0
  },
  {
    "type": "testWrite",
    "created_at": "2025-06-24T07:35:30.957Z",
    "filename": "test/features/apivote/test_update_vote_value_and_permission_enforcement.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport { IVote } from \"@ORGANIZATION/PROJECT-api/lib/structures/IVote\";\n\n/**\n * Validate updating the value of an existing vote, permission constraints, and error handling on not found.\n *\n * - Only the vote creator can change vote value.\n * - Attempting to update a non-existent vote returns 404.\n * Steps:\n * 1. Create a vote as userA\n * 2. Update that vote as userA (should succeed)\n * 3. Try updating that vote as a different user (should fail - 403/401 depending on auth)\n * 4. Try updating a non-existent vote (expect 404 Not Found)\n */\nexport async function test_api_vote_update_value_and_permission_enforcement(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. Create a vote as userA\n  const userA = { id: typia.random<string>(), email: \"userA@example.com\" };\n  // Create a vote\n  const created: IVote = await api.functional.votes.votes.post(connection, {\n    body: {\n      user_id: userA.id,\n      value: 1,\n      post_id: typia.random<string>(),\n      comment_id: null,\n    } satisfies IVote.ICreate,\n  });\n  typia.assert(created);\n\n  // 2. Update that vote as userA (should succeed)\n  const updated: IVote = await api.functional.votes.votes.putById(connection, {\n    id: created.id,\n    body: { value: -1 } satisfies IVote.IUpdate,\n  });\n  typia.assert(updated);\n  TestValidator.equals(\"updated value\")(-1)(updated.value);\n  TestValidator.equals(\"vote id\")(created.id)(updated.id);\n\n  // 3. Try updating that vote as a different user (should fail - 403/401)\n  // This test assumes authentication, but if system checks user_id in body, try changing it\n  // However, by business rules, only value can be updated, user_id cannot be changed. So, ideally, we need to change the authentication session.\n  // Here, just a note: in a real E2E, impersonate userB. We'll simulate as anonymous.\n  await TestValidator.httpError(\"only vote creator can update vote\")(403)(\n    async () =>\n      await api.functional.votes.votes.putById(connection, {\n        id: created.id,\n        body: { value: 1 } satisfies IVote.IUpdate,\n      })\n  );\n\n  // 4. Try updating a non-existent vote (expect 404 Not Found)\n  await TestValidator.httpError(\"update non-existent vote\")(404)(\n    async () =>\n      await api.functional.votes.votes.putById(connection, {\n        id: typia.random<string>(),\n        body: { value: 1 } satisfies IVote.IUpdate,\n      })\n  );\n}\n",
    "completed": 14,
    "total": 30,
    "step": 0
  },
  {
    "type": "testWrite",
    "created_at": "2025-06-24T07:35:30.957Z",
    "filename": "test/features/apivote/test_delete_vote_success_not_found_and_permission.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport { IVote } from \"@ORGANIZATION/PROJECT-api/lib/structures/IVote\";\n\n/**\n * E2E Test: Vote deletion (success, not found, and permission enforcement)\n *\n * Scenario:\n * 1. User A creates a vote (upvote on a post or comment)\n * 2. User A deletes their vote (should succeed)\n * 3. User A attempts to delete the same vote again (should fail: 404 not found)\n * 4. User B creates a vote\n * 5. User A attempts to delete User B's vote (should fail: only owner can delete)\n *\n * This test confirms vote deletion, not-found error, and owner-only deletion policy.\n */\nexport async function test_api_vote_delete_success_not_found_and_permission(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. User A creates a vote\n  const userAId = typia.random<string>();\n  const voteA: IVote = await api.functional.votes.votes.post(connection, {\n    body: {\n      user_id: userAId,\n      value: 1,\n      post_id: typia.random<string>(),\n    } satisfies IVote.ICreate,\n  });\n  typia.assert(voteA);\n\n  // 2. User A deletes their own vote (should succeed)\n  const deleteResult1 = await api.functional.votes.votes.eraseById(connection, {\n    id: voteA.id,\n  });\n  typia.assert(deleteResult1);\n  TestValidator.equals(\"user A's vote deleted\")(deleteResult1.deleted)(true);\n\n  // 3. User A tries to delete again (should fail with 404)\n  await TestValidator.httpError(\"delete already deleted vote - not found\")(404)(() =>\n    api.functional.votes.votes.eraseById(connection, { id: voteA.id }),\n  );\n\n  // 4. User B creates a vote\n  const userBId = typia.random<string>();\n  const voteB: IVote = await api.functional.votes.votes.post(connection, {\n    body: {\n      user_id: userBId,\n      value: -1,\n      comment_id: typia.random<string>(),\n    } satisfies IVote.ICreate,\n  });\n  typia.assert(voteB);\n\n  // 5. User A attempts to delete User B's vote (should fail with forbidden/403)\n  await TestValidator.httpError(\"not owner cannot delete vote\")(403)(() =>\n    api.functional.votes.votes.eraseById(connection, { id: voteB.id }),\n  );\n}\n",
    "completed": 11,
    "total": 30,
    "step": 0
  }
]