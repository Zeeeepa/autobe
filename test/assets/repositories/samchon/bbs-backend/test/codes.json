[
  {
    "type": "testProgress",
    "created_at": "2025-06-24T04:34:11.053Z",
    "filename": "user/test_list_users_with_various_filters_and_pagination.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport { IPageIUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIUser\";\nimport typia from \"typia\";\n\nexport async function test_list_users_with_various_filters_and_pagination(connection: api.IConnection): Promise<void> {\n  // 1. Default request (no filter)\n  const resultDefault = await api.functional.core.users.patch(connection, { body: {} });\n  typia.assert<IPageIUser.ISummary>(resultDefault);\n  TestValidator.predicate(\"default result is non-empty\")(() => resultDefault.data.length >= 0);\n  TestValidator.predicate(\"pagination correctness\")(\n    () => resultDefault.pagination.current === 1 || typeof resultDefault.pagination.current === \"number\"\n  );\n\n  // 2. Pagination (custom page/limit)\n  const pagReq: IUser.IRequest = { page: 2, limit: 3 };\n  const resultPage = await api.functional.core.users.patch(connection, { body: pagReq });\n  typia.assert<IPageIUser.ISummary>(resultPage);\n  TestValidator.equals(\"requested page number\")<number>(pagReq.page!)(resultPage.pagination.current);\n  TestValidator.equals(\"requested limit\")<number>(pagReq.limit!)(resultPage.pagination.limit);\n\n  // 3. Try to fetch a known invalid page (e.g., page far beyond pageCount)\n  const invalidPage = 99999;\n  const resultInvalidPage = await api.functional.core.users.patch(connection, { body: { page: invalidPage } });\n  typia.assert<IPageIUser.ISummary>(resultInvalidPage);\n  TestValidator.equals(\"empty on unavailable page\")<number>(0)(resultInvalidPage.data.length);\n\n  // 4. Search filter (use a clearly gibberish string for empty result)\n  const gibberishSearch = \"no-user-in-db-xyz123\";\n  const resultEmpty = await api.functional.core.users.patch(connection, { body: { search: gibberishSearch } });\n  typia.assert<IPageIUser.ISummary>(resultEmpty);\n  TestValidator.equals(\"no results on gibberish search\")<number>(0)(resultEmpty.data.length);\n\n  // 5. If any users exist, pick a role and status from data and filter by them\n  const firstUser = resultDefault.data[0];\n  if (firstUser) {\n    const byRole = await api.functional.core.users.patch(connection, {\n      body: { role: firstUser.role.id },\n    });\n    typia.assert<IPageIUser.ISummary>(byRole);\n    TestValidator.predicate(\"all users have matching role\")(() => byRole.data.every(u => u.role.id === firstUser.role.id));\n\n    const byStatus = await api.functional.core.users.patch(connection, {\n      body: { status: firstUser.status },\n    });\n    typia.assert<IPageIUser.ISummary>(byStatus);\n    TestValidator.predicate(\"all users have matching status\")(() => byStatus.data.every(u => u.status === firstUser.status));\n\n    // Search by username (partial, case-insensitive)\n    const usernameFragment = firstUser.username.slice(0, Math.max(1, Math.floor(firstUser.username.length / 2)));\n    const bySearch = await api.functional.core.users.patch(connection, {\n      body: { search: usernameFragment },\n    });\n    typia.assert<IPageIUser.ISummary>(bySearch);\n    TestValidator.predicate(\"some users match username search\")(() => bySearch.data.some(u => u.username.includes(usernameFragment)));\n  }\n\n  // 6. Invalid pagination (negative page/limit)\n  await TestValidator.httpError(\"negative page\") (400)(async () => {\n    await api.functional.core.users.patch(connection, { body: { page: -1 } });\n  });\n  await TestValidator.httpError(\"negative limit\") (400)(async () => {\n    await api.functional.core.users.patch(connection, { body: { limit: -5 } });\n  });\n}\n",
    "completed": 46,
    "total": 59,
    "step": 0,
    "scenario": {
      "method": "patch",
      "path": "/core/users",
      "draft": "Test retrieving users with different filter conditions and pagination settings. Validate that pages, limits, and filter parameters correctly influence the returned user list. Also verify behavior when the filter returns no results and validate handling of invalid pagination parameters (e.g., negative page number).",
      "functionName": "test_list_users_with_various_filters_and_pagination",
      "dependsOn": []
    }
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-24T04:34:11.053Z",
    "filename": "user/test_search_users_with_role_and_keyword_filters.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport { IUserRole } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUserRole\";\nimport { IPageIUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIUser\";\nimport typia from \"typia\";\n\nexport async function test_search_users_with_role_and_keyword_filters(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. Preparation: Create two user roles\n  const roleA = await api.functional.core.userRoles.post(connection, {\n    body: { name: \"RoleA\", description: \"Test Role A\" },\n  });\n  typia.assert<IUserRole>(roleA);\n  const roleB = await api.functional.core.userRoles.post(connection, {\n    body: { name: \"RoleB\", description: \"Test Role B\" },\n  });\n  typia.assert<IUserRole>(roleB);\n\n  // 2. Preparation: Create three users with above roles.\n  const user1 = await api.functional.core.users.post(connection, {\n    body: {\n      user_role_id: roleA.id,\n      username: \"alice_test\",\n      email: `alice_${Math.random().toString(36).substring(2, 6)}@example.com`,\n      bio: null,\n      password: \"Password123!\",\n      status: \"active\",\n    },\n  });\n  typia.assert<IUser>(user1);\n\n  const user2 = await api.functional.core.users.post(connection, {\n    body: {\n      user_role_id: roleB.id,\n      username: \"bob_admin\",\n      email: `bob_${Math.random().toString(36).substring(2, 6)}@example.com`,\n      bio: null,\n      password: \"Password123!\",\n      status: \"active\",\n    },\n  });\n  typia.assert<IUser>(user2);\n\n  const user3 = await api.functional.core.users.post(connection, {\n    body: {\n      user_role_id: roleA.id,\n      username: \"carol_test\",\n      email: `carol_${Math.random().toString(36).substring(2, 6)}@example.com`,\n      bio: null,\n      password: \"Password123!\",\n      status: \"active\",\n    },\n  });\n  typia.assert<IUser>(user3);\n\n  // Helper for easy mapping to summary objects\n  const toSummary = (u: IUser): IUser.ISummary => ({\n    id: u.id,\n    username: u.username,\n    bio: u.bio,\n    role: { id: u.role.id, name: u.role.name },\n    status: u.status,\n  });\n\n  // 3. Test search by role only (RoleA)\n  const byRoleA = await api.functional.core.users.patch(connection, {\n    body: { role: roleA.id },\n  });\n  typia.assert<IPageIUser.ISummary>(byRoleA);\n  // should include user1 and user3\n  TestValidator.predicate(\"RoleA filter contains correct users\")(\n    () => byRoleA.data.some(u => u.id === user1.id) && byRoleA.data.some(u => u.id === user3.id) &&\n    byRoleA.data.every(u => u.role.id === roleA.id)\n  );\n\n  // 4. Test search by partial username ('test')\n  const byTest = await api.functional.core.users.patch(connection, {\n    body: { search: \"test\" },\n  });\n  typia.assert<IPageIUser.ISummary>(byTest);\n  // Usernames with \"test\" => user1 and user3\n  TestValidator.equals(\"Partial username filter\")(\n    [toSummary(user1), toSummary(user3)]\n  )(\n    byTest.data.filter(u => u.username.endsWith(\"_test\") || u.username.startsWith(\"carol\"))\n  );\n\n  // 5. Search with both role and username filter (roleA + 'carol')\n  const byRoleAAndCarol = await api.functional.core.users.patch(connection, {\n    body: { role: roleA.id, search: \"carol\" },\n  });\n  typia.assert<IPageIUser.ISummary>(byRoleAAndCarol);\n  TestValidator.equals(\"RoleA+carol filter\")(\n    [toSummary(user3)]\n  )(\n    byRoleAAndCarol.data.filter(u => u.username === \"carol_test\")\n  );\n\n  // 6. Edge: Non-existent role id\n  const byFakeRole = await api.functional.core.users.patch(connection, {\n    body: { role: \"11111111-1111-1111-1111-111111111111\" },\n  });\n  typia.assert<IPageIUser.ISummary>(byFakeRole);\n  TestValidator.equals(\"Fake role returns no results\")(\n    [] as IUser.ISummary[]\n  )(byFakeRole.data);\n\n  // 7. Edge: Non-existent search string\n  const byNonsense = await api.functional.core.users.patch(connection, {\n    body: { search: \"zzzzzzzz_wrong\" },\n  });\n  typia.assert<IPageIUser.ISummary>(byNonsense);\n  TestValidator.equals(\"Nonsense search returns no results\")(\n    [] as IUser.ISummary[]\n  )(byNonsense.data);\n}\n",
    "completed": 48,
    "total": 59,
    "step": 0,
    "scenario": {
      "method": "patch",
      "path": "/core/users",
      "draft": "Verify that searching for users using a role filter or partial username returns only appropriate users. Confirm edge cases such as searching for non-existent roles or keywords.",
      "functionName": "test_search_users_with_role_and_keyword_filters",
      "dependsOn": [
        {
          "method": "post",
          "path": "/core/userRoles",
          "purpose": "Create a role to later filter users by this role in the test."
        },
        {
          "method": "post",
          "path": "/core/users",
          "purpose": "Create users assigned to different roles and usernames to set up filtering scenarios."
        }
      ]
    }
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-24T04:34:11.053Z",
    "filename": "user/test_retrieve_user_profile_by_id_success_and_not_found.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\n\nexport async function test_retrieve_user_profile_by_id_success_and_not_found(connection: api.IConnection): Promise<void> {\n  // Step 1: Register a new user\n  const userInput: IUser.ICreate = {\n    user_role_id: typia.random<string & tags.Format<\"uuid\">>(),\n    username: `testuser_${Math.random().toString(36).slice(2)}`,\n    email: `testuser_${Math.random().toString(36).slice(2)}@example.com`,\n    bio: \"Test user for retrieval\",\n    password: \"StrongPassword123!\",\n    status: \"active\",\n  };\n  const created: IUser = await api.functional.core.users.post(connection, {\n    body: userInput,\n  });\n  typia.assert<IUser>(created);\n  TestValidator.equals(\"username matches\")(userInput.username)(created.username);\n  TestValidator.equals(\"email matches\")(userInput.email)(created.email);\n  TestValidator.equals(\"user_role_id matches\")(userInput.user_role_id)(created.user_role_id);\n\n  // Step 2: Retrieve the newly created user by ID (should succeed)\n  const retrieved: IUser = await api.functional.core.users.getById(connection, {\n    id: created.id,\n  });\n  typia.assert<IUser>(retrieved);\n  TestValidator.equals(\"user id matches\")(created.id)(retrieved.id);\n  TestValidator.equals(\"username matches\")(created.username)(retrieved.username);\n  TestValidator.equals(\"email matches\")(created.email)(retrieved.email);\n\n  // Step 3: Attempt to retrieve a user by an invalid/deleted ID (should 404)\n  const bogusUserId = typia.random<string & tags.Format<\"uuid\">>();\n  await TestValidator.httpError(\"should be 404 when user not found\")(404)(async () => {\n    await api.functional.core.users.getById(connection, { id: bogusUserId });\n  });\n}\n",
    "completed": 33,
    "total": 59,
    "step": 0,
    "scenario": {
      "method": "get",
      "path": "/core/users/{id}",
      "draft": "Test retrieving a user profile by a valid user ID and expect correct profile data. Also attempt to retrieve using an invalid or deleted user ID and expect a 404 error.",
      "functionName": "test_retrieve_user_profile_by_id_success_and_not_found",
      "dependsOn": [
        {
          "method": "post",
          "path": "/core/users",
          "purpose": "Register a user to ensure a valid user ID exists for retrieval."
        }
      ]
    }
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-24T04:34:11.053Z",
    "filename": "user/test_register_new_user_edge_and_success_cases.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport { IUserRole } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUserRole\";\nimport typia from \"typia\";\n\nexport async function test_register_new_user_edge_and_success_cases(connection: api.IConnection): Promise<void> {\n  // Step 1: Create a user role for registration\n  const userRoleInput: IUserRole.ICreate = {\n    name: `member_${Date.now()}`,\n    description: \"Basic member role for testing user registration.\"\n  };\n\n  const role = await api.functional.core.userRoles.post(connection, { body: userRoleInput });\n  typia.assert<IUserRole>(role);\n\n  // Step 2: Register a new user with all valid fields\n  const validUser: IUser.ICreate = {\n    user_role_id: role.id,\n    username: `user_${Date.now()}`,\n    email: `user_${Date.now()}@test.com`,\n    bio: \"Test user bio.\",\n    password: \"super-secret-password\",\n    status: \"active\"\n  };\n  const user = await api.functional.core.users.post(connection, { body: validUser });\n  typia.assert<IUser>(user);\n  TestValidator.equals(\"New user username matches input\")<string>(validUser.username)(user.username);\n  TestValidator.equals(\"User role matches input\")<string>(validUser.user_role_id)(user.user_role_id);\n  TestValidator.equals(\"User status is active\")<string>(\"active\")(user.status);\n  TestValidator.equals(\"User email matches input\")<string>(validUser.email)(user.email);\n  // Email is returned for the user (not hidden)\n\n  // Step 3a: Missing required field (username)\n  const missingUsername: IUser.ICreate = {\n    user_role_id: role.id,\n    username: \"\",\n    email: `otheruser_${Date.now()}@test.com`,\n    password: \"pw1\",\n    status: \"active\"\n  };\n  await TestValidator.httpError(\"Missing username gives 400\") (400)(async () =>\n    api.functional.core.users.post(connection, { body: missingUsername })\n  );\n\n  // Step 3b: Missing required field (email)\n  const missingEmail: IUser.ICreate = {\n    user_role_id: role.id,\n    username: `missingEmail_${Date.now()}`,\n    email: \"\",\n    password: \"pw1\",\n    status: \"active\"\n  };\n  await TestValidator.httpError(\"Missing email gives 400\") (400)(async () =>\n    api.functional.core.users.post(connection, { body: missingEmail })\n  );\n\n  // Step 3c: Missing required field (password)\n  const missingPassword: IUser.ICreate = {\n    user_role_id: role.id,\n    username: `missingPassword_${Date.now()}`,\n    email: `missingpw_${Date.now()}@test.com`,\n    password: \"\",\n    status: \"active\"\n  };\n  await TestValidator.httpError(\"Missing password gives 400\") (400)(async () =>\n    api.functional.core.users.post(connection, { body: missingPassword })\n  );\n\n  // Step 4: Invalid email format\n  const invalidEmail: IUser.ICreate = {\n    user_role_id: role.id,\n    username: `invalidEmail_${Date.now()}`,\n    email: \"notanemail\",\n    password: \"pw1\",\n    status: \"active\"\n  };\n  await TestValidator.httpError(\"Invalid email rejected\") (400)(async () =>\n    api.functional.core.users.post(connection, { body: invalidEmail })\n  );\n\n  // Step 5: Duplicate registration (username and email)\n  const duplicateUser: IUser.ICreate = {\n    ...validUser,\n    username: validUser.username, // same username\n    email: validUser.email,       // same email\n  };\n  await TestValidator.httpError(\"Duplicate username/email gives 409/400\") (409, 400)(async () =>\n    api.functional.core.users.post(connection, { body: duplicateUser })\n  );\n\n  // Step 6: Partial duplicate (same username, diff email)\n  const partialDup1: IUser.ICreate = {\n    ...validUser,\n    email: `unique_${Date.now()}@test.com`,\n  };\n  await TestValidator.httpError(\"Duplicate username (diff email)\")(409,400)(async () =>\n    api.functional.core.users.post(connection, { body: partialDup1 })\n  );\n\n  // Step 7: Partial duplicate (same email, diff username)\n  const partialDup2: IUser.ICreate = {\n    ...validUser,\n    username: `diffuser_${Date.now()}`,\n  };\n  await TestValidator.httpError(\"Duplicate email (diff username)\")(409,400)(async () =>\n    api.functional.core.users.post(connection, { body: partialDup2 })\n  );\n}\n",
    "completed": 45,
    "total": 59,
    "step": 0,
    "scenario": {
      "method": "post",
      "path": "/core/users",
      "draft": "Test registering a new user with all valid fields and expect successful creation. Verify behavior when attempting to register with missing required fields, invalid email format, or a username that already exists. Attempt duplicate registration to test uniqueness constraints.",
      "functionName": "test_register_new_user_edge_and_success_cases",
      "dependsOn": [
        {
          "method": "post",
          "path": "/core/userRoles",
          "purpose": "Create a user role in advance so it can be linked to the new user."
        }
      ]
    }
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-24T04:34:11.053Z",
    "filename": "user/test_update_user_profile_with_valid_and_invalid_conditions.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport { IUserRole } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUserRole\";\nimport typia, { tags } from \"typia\";\n\nexport async function test_update_user_profile_with_valid_and_invalid_conditions(connection: api.IConnection): Promise<void> {\n  // Step 1: Create two distinct user roles\n  const roleA: IUserRole = await api.functional.core.userRoles.post(connection, {\n    body: { name: \"memberA_\" + Date.now(), description: \"Standard member role A\" },\n  });\n  typia.assert(roleA);\n  const roleB: IUserRole = await api.functional.core.userRoles.post(connection, {\n    body: { name: \"memberB_\" + Date.now(), description: \"Standard member role B\" },\n  });\n  typia.assert(roleB);\n\n  // Step 2: Register two users with distinct emails and usernames\n  const password = \"Passw0rd!\";\n  const userAInput: IUser.ICreate = {\n    user_role_id: roleA.id,\n    username: \"user_a_\" + Date.now(),\n    email: \"usera_\" + Date.now() + \"@test.com\",\n    bio: \"User A bio\",\n    password,\n    status: \"active\",\n  };\n  const userBInput: IUser.ICreate = {\n    user_role_id: roleB.id,\n    username: \"user_b_\" + Date.now(),\n    email: \"userb_\" + Date.now() + \"@test.com\",\n    bio: \"User B bio\",\n    password,\n    status: \"active\",\n  };\n  const userA: IUser = await api.functional.core.users.post(connection, { body: userAInput });\n  typia.assert(userA);\n  const userB: IUser = await api.functional.core.users.post(connection, { body: userBInput });\n  typia.assert(userB);\n\n  // Step 3: Update userA's profile\n  const newEmail = \"updated_\" + Date.now() + \"@example.com\";\n  const newUsername = \"updated_user_a_\" + Date.now();\n  const newBio = \"Updated bio for user A\";\n  const newStatus = \"suspended\";\n  const updateBody: IUser.IUpdate = {\n    email: newEmail,\n    username: newUsername,\n    user_role_id: roleB.id,\n    bio: newBio,\n    status: newStatus,\n  };\n  const updatedUserA: IUser = await api.functional.core.users.putById(connection, {\n    id: userA.id,\n    body: updateBody,\n  });\n  typia.assert(updatedUserA);\n  // Validate updates persisted\n  TestValidator.equals(\"updated email\")(newEmail)(updatedUserA.email);\n  TestValidator.equals(\"updated username\")(newUsername)(updatedUserA.username);\n  TestValidator.equals(\"updated role\")(roleB.id)(updatedUserA.user_role_id);\n  TestValidator.equals(\"updated bio\")(newBio)(updatedUserA.bio);\n  TestValidator.equals(\"updated status\")(newStatus)(updatedUserA.status);\n\n  // Step 4: Attempt to update userA's email to userB's email (should fail/conflict)\n  await TestValidator.httpError(\"duplicate email\")(409)(async () => {\n    await api.functional.core.users.putById(connection, {\n      id: userA.id,\n      body: { email: userB.email },\n    });\n  });\n\n  // Step 5: Attempt to update userA's username to userB's username (should fail/conflict)\n  await TestValidator.httpError(\"duplicate username\")(409)(async () => {\n    await api.functional.core.users.putById(connection, {\n      id: userA.id,\n      body: { username: userB.username },\n    });\n  });\n\n  // Step 6: Update non-existent user (random UUID)\n  const randomNonexistentId = typia.random<string & tags.Format<\"uuid\">>();\n  await TestValidator.httpError(\"not found or deleted user\")(404)(async () => {\n    await api.functional.core.users.putById(connection, {\n      id: randomNonexistentId,\n      body: { email: \"nonexistent_\" + Date.now() + \"@test.com\" },\n    });\n  });\n\n  // Step 7: Invalid email format\n  await TestValidator.httpError(\"email format invalid\")(400)(async () => {\n    await api.functional.core.users.putById(connection, {\n      id: userA.id,\n      body: { email: \"not-an-email\" },\n    });\n  });\n}\n",
    "completed": 52,
    "total": 59,
    "step": 0,
    "scenario": {
      "method": "put",
      "path": "/core/users/{id}",
      "draft": "Test updating a user’s profile data (such as email, username, or role). Validate that updates persist and business rules are enforced (e.g., email format, unique username). Attempt updating a non-existent or deleted user and expect a 404. Attempt setting a duplicate email/username to trigger a conflict error.",
      "functionName": "test_update_user_profile_with_valid_and_invalid_conditions",
      "dependsOn": [
        {
          "method": "post",
          "path": "/core/userRoles",
          "purpose": "Create multiple roles to assign or reassign to the user."
        },
        {
          "method": "post",
          "path": "/core/users",
          "purpose": "Register at least two users to enable scenarios for duplicate and update tests."
        }
      ]
    }
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-24T04:34:11.053Z",
    "filename": "user/test_delete_user_soft_and_hard_and_not_found.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport typia, { tags } from \"typia\";\n\nexport async function test_delete_user_soft_and_hard_and_not_found(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. Register a user\n  const userInput: IUser.ICreate = typia.random<IUser.ICreate>();\n  const createdUser: IUser = await api.functional.core.users.post(connection, {\n    body: userInput,\n  });\n  typia.assert<IUser>(createdUser);\n\n  // 2. Soft-delete the user\n  const deleteResp: IUser.IDeleteResponse = await api.functional.core.users.eraseById(connection, {\n    id: createdUser.id,\n  });\n  typia.assert<IUser.IDeleteResponse>(deleteResp);\n  TestValidator.equals(\"delete response user id\")<string>(createdUser.id)(deleteResp.id!);\n  TestValidator.predicate(\"delete response status string\")(typeof deleteResp.status === \"string\");\n\n  // 3. Try deleting same user again (should get 404)\n  await TestValidator.httpError(\"delete already deleted user should 404\")(404)(async () => {\n    await api.functional.core.users.eraseById(connection, {\n      id: createdUser.id,\n    });\n  });\n\n  // 4. Try deleting a non-existent user (should get 404)\n  const randomUuid: string & tags.Format<\"uuid\"> = typia.random<string & tags.Format<\"uuid\">>();\n  await TestValidator.httpError(\"delete non-existent user should 404\")(404)(async () => {\n    await api.functional.core.users.eraseById(connection, {\n      id: randomUuid,\n    });\n  });\n}\n",
    "completed": 37,
    "total": 59,
    "step": 0,
    "scenario": {
      "method": "delete",
      "path": "/core/users/{id}",
      "draft": "Test soft-deleting a user and verify their profile is no longer returned in user list endpoints, but remains in the database in a soft-deleted state (if applicable). Then, test a hard delete and confirm the user is fully removed. Try deleting an already deleted or non-existent user and expect a 404 error.",
      "functionName": "test_delete_user_soft_and_hard_and_not_found",
      "dependsOn": [
        {
          "method": "post",
          "path": "/core/users",
          "purpose": "Register a user to delete."
        }
      ]
    }
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-24T04:34:11.053Z",
    "filename": "userRole/test_list_user_roles_with_filters_and_pagination.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport { IUserRole } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUserRole\";\nimport { IPageIUserRole } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIUserRole\";\n\nexport async function test_list_user_roles_with_filters_and_pagination(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. Create diverse user roles\n  const rolesToCreate: IUserRole.ICreate[] = [\n    { name: \"member\", description: \"Basic board member who can post and comment\" },\n    { name: \"moderator\", description: \"Can moderate content and manage users\" },\n    { name: \"editor\", description: \"Edits content but no moderation rights\" },\n    { name: \"guest\", description: \"Read-only access, cannot post\" },\n    { name: \"superadmin\", description: \"All board privileges and system settings\" },\n  ];\n  const createdRoles: IUserRole[] = [];\n  for (const roleInput of rolesToCreate) {\n    const created = await api.functional.core.userRoles.post(connection, { body: roleInput });\n    typia.assert<IUserRole>(created);\n    createdRoles.push(created);\n  }\n\n  // 2. List all roles, confirm all created present\n  const allListResp = await api.functional.core.userRoles.patch(connection, { body: {} });\n  typia.assert<IPageIUserRole>(allListResp);\n  const allIds = createdRoles.map(r => r.id);\n  const listedIds = allListResp.data.map(r => r.id);\n  // All created IDs should be present\n  for (const id of allIds) {\n    TestValidator.predicate(`ID ${id} listed`)(() => listedIds.includes(id));\n  }\n  TestValidator.predicate(\"pagination count >= created count\")(\n    () => allListResp.pagination.records >= createdRoles.length,\n  );\n\n  // 3. Filter by specific role name\n  const targetName = createdRoles[2].name; // 'editor'\n  const filterByNameResp = await api.functional.core.userRoles.patch(connection, {\n    body: { search: targetName },\n  });\n  typia.assert<IPageIUserRole>(filterByNameResp);\n  // Every result must have the target name substring, in name or description\n  for (const role of filterByNameResp.data) {\n    TestValidator.predicate(\"role matches name filter\")(\n      () => role.name.includes(targetName) || role.description.includes(targetName),\n    );\n  }\n  // Should include at least the specifically named one\n  TestValidator.predicate(\"name filter returns at least one match\")(\n    () => filterByNameResp.data.length > 0,\n  );\n\n  // 4. Filter by description substring\n  const descSearch = \"moderate\";\n  const filterByDescResp = await api.functional.core.userRoles.patch(connection, {\n    body: { search: descSearch },\n  });\n  typia.assert<IPageIUserRole>(filterByDescResp);\n  for (const role of filterByDescResp.data) {\n    TestValidator.predicate(\"role matches desc filter\")(\n      () => role.name.includes(descSearch) || role.description.includes(descSearch),\n    );\n  }\n  TestValidator.predicate(\"desc filter returns >=1 match\")(\n    () => filterByDescResp.data.length > 0,\n  );\n\n  // 5. Test pagination (limit=2, page=1; page=2)\n  const limit = 2;\n  const page1Resp = await api.functional.core.userRoles.patch(connection, {\n    body: { limit, page: 1 },\n  });\n  typia.assert<IPageIUserRole>(page1Resp);\n  TestValidator.predicate(\"page 1 limit matches\")(\n    () => page1Resp.data.length <= limit,\n  );\n  TestValidator.equals(\"page 1 current page\")<number>(1)(page1Resp.pagination.current);\n  // Page 2\n  const page2Resp = await api.functional.core.userRoles.patch(connection, {\n    body: { limit, page: 2 },\n  });\n  typia.assert<IPageIUserRole>(page2Resp);\n  TestValidator.predicate(\"page 2 limit matches\")(\n    () => page2Resp.data.length <= limit,\n  );\n  TestValidator.equals(\"page 2 current page\")<number>(2)(page2Resp.pagination.current);\n  // Make sure different IDs between pages if enough records\n  if (page1Resp.data.length && page2Resp.data.length) {\n    const ids1 = page1Resp.data.map(r => r.id);\n    const ids2 = page2Resp.data.map(r => r.id);\n    TestValidator.predicate(\"page 1 and 2 data differ\")(() => ids1.some(id => !ids2.includes(id)));\n  }\n\n  // 6. Negative: search for non-existent\n  const nonExistent = \"no_such_role_\" + Date.now();\n  const negativeResp = await api.functional.core.userRoles.patch(connection, {\n    body: { search: nonExistent },\n  });\n  typia.assert<IPageIUserRole>(negativeResp);\n  TestValidator.equals(\"negative search yields empty array\")<IUserRole[]>([])(negativeResp.data);\n  TestValidator.equals(\"pagination zero records\")<number>(0)(negativeResp.pagination.records);\n}\n",
    "completed": 58,
    "total": 59,
    "step": 0,
    "scenario": {
      "method": "patch",
      "path": "/core/userRoles",
      "draft": "Test listing user roles with various filters (e.g., role name, description). Validate that pagination works, and verify response when filtering by a non-existent role.",
      "functionName": "test_list_user_roles_with_filters_and_pagination",
      "dependsOn": [
        {
          "method": "post",
          "path": "/core/userRoles",
          "purpose": "Create roles with diverse names and descriptions for filter tests."
        }
      ]
    }
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-24T04:34:11.053Z",
    "filename": "user-role/test_list_user_roles_with_invalid_filter_parameters.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport { IUserRole } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUserRole\";\nimport { IPageIUserRole } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIUserRole\";\n\nexport async function test_list_user_roles_with_invalid_filter_parameters(\n  connection: api.IConnection\n): Promise<void> {\n  // Array of invalid input cases\n  const invalidInputs: IUserRole.IRequest[] = [\n    { page: -1 },                // Negative page\n    { page: 1.5 },               // Non-integer page\n    { page: \"a\" as any },        // String instead of number\n    { page: null as any },       // Null page\n    { limit: 0 },                // Zero limit\n    { limit: -10 },              // Negative limit\n    { limit: \"hundred\" as any }, // String limit\n    { limit: 99999999 },         // Excessively large limit\n    { search: 12345 as any },    // Non-string search\n    { search: \"x\".repeat(10001) } // Overly long search query\n  ];\n\n  for (const invalidBody of invalidInputs) {\n    await TestValidator.httpError(\"invalid user role filter should fail\")(400, 422)(\n      async () => {\n        await api.functional.core.userRoles.patch(connection, { body: invalidBody });\n      }\n    );\n  }\n\n  // Confirming a valid request still works\n  const validBody: IUserRole.IRequest = { page: 1, limit: 5, search: \"admin\" };\n  const result = await api.functional.core.userRoles.patch(connection, { body: validBody });\n  typia.assert<IPageIUserRole>(result);\n}\n",
    "completed": 31,
    "total": 59,
    "step": 0,
    "scenario": {
      "method": "patch",
      "path": "/core/userRoles",
      "draft": "Attempt to retrieve user roles with invalid filter parameters and confirm appropriate error handling and response format.",
      "functionName": "test_list_user_roles_with_invalid_filter_parameters",
      "dependsOn": []
    }
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-24T04:34:11.053Z",
    "filename": "user-role/test_get_user_role_by_valid_and_invalid_id_with_auth_checks.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IUserRole } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUserRole\";\nimport typia, { tags } from \"typia\";\n\nexport async function test_get_user_role_by_valid_and_invalid_id_with_auth_checks(connection: api.IConnection): Promise<void> {\n  // 1. Create a new user role for positive retrieval test\n  const roleInput: IUserRole.ICreate = {\n    name: `test-role-${Date.now()}`,\n    description: \"E2E test role for GET /core/userRoles/{id} retrieval scenario.\"\n  };\n  const createdRole: IUserRole = await api.functional.core.userRoles.post(connection, { body: roleInput });\n  typia.assert<IUserRole>(createdRole);\n\n  // 2. Retrieve the created user role by valid ID\n  const fetchedRole: IUserRole = await api.functional.core.userRoles.getById(connection, { id: createdRole.id });\n  typia.assert<IUserRole>(fetchedRole);\n  TestValidator.equals(\"Role ID matches\")(createdRole.id)(fetchedRole.id);\n  TestValidator.equals(\"Role name matches\")(createdRole.name)(fetchedRole.name);\n  TestValidator.equals(\"Role description matches\")(createdRole.description)(fetchedRole.description);\n\n  // 3. Attempt to GET by non-existent/random UUID (expect 404)\n  const nonExistentId: string & tags.Format<\"uuid\"> = typia.random<string & tags.Format<\"uuid\">>();\n  // Ensure we do not accidentally use the just-created ID\n  if (nonExistentId === createdRole.id) {\n    // Regenerate once more if by chance matched (extremely unlikely)\n    nonExistentId = typia.random<string & tags.Format<\"uuid\">>();\n  }\n  await TestValidator.httpError(\"Non-existent user role produces 404\")(404)(\n    () => api.functional.core.userRoles.getById(connection, { id: nonExistentId })\n  );\n\n  // 4. Attempt to GET without authentication (remove auth header, expect 401 or 403)\n  const noAuthConnection = { ...connection, headers: { ...connection.headers } };\n  // Remove standard auth-related headers if present\n  // (Assume typical 'Authorization' header, but project may differ)\n  if (noAuthConnection.headers) {\n    delete noAuthConnection.headers[\"Authorization\"];\n    delete noAuthConnection.headers[\"authorization\"];\n  }\n  await TestValidator.httpError(\"Request without authentication is rejected\")(401, 403)(\n    () => api.functional.core.userRoles.getById(noAuthConnection, { id: createdRole.id })\n  );\n}\n",
    "completed": 43,
    "total": 59,
    "step": 0,
    "scenario": {
      "method": "get",
      "path": "/core/userRoles/{id}",
      "draft": "Attempt to retrieve an existing user role by valid ID and verify that all role details are returned correctly. Also, attempt with a non-existent ID and expect a 404 error. Ensure that requests without proper authentication are rejected with an appropriate error.",
      "functionName": "test_get_user_role_by_valid_and_invalid_id_with_auth_checks",
      "dependsOn": [
        {
          "method": "post",
          "path": "/core/userRoles",
          "purpose": "Create a user role for use in successful retrieval test cases."
        }
      ]
    }
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-24T04:34:11.053Z",
    "filename": "user-role/test_get_user_role_access_forbidden_for_insufficient_privileges.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IUserRole } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUserRole\";\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport typia from \"typia\";\n\n/**\n * Test permission: non-privileged users should receive 403 Forbidden when accessing user role details.\n */\nexport async function test_get_user_role_access_forbidden_for_insufficient_privileges(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. Create a custom role (not admin)\n  const testRoleInput: IUserRole.ICreate = {\n    name: `custom-role-${Math.random().toString(36).slice(2,8)}`,\n    description: \"A custom test role with minimum permissions.\",\n  };\n  const testRole = await api.functional.core.userRoles.post(connection, { body: testRoleInput });\n  typia.assert<IUserRole>(testRole);\n\n  // 2. Create a user in the above role (should not have privilege to view roles)\n  const basicUserInput: IUser.ICreate = {\n    user_role_id: testRole.id,\n    username: `testuser_${Math.random().toString(36).slice(2,8)}`,\n    email: `testuser_${Math.random().toString(36).slice(2,8)}@test.com`,\n    password: \"TestPassword123!\",\n    status: \"active\",\n  };\n  const basicUser = await api.functional.core.users.post(connection, { body: basicUserInput });\n  typia.assert<IUser>(basicUser);\n\n  // 3. Simulate connection as this low-privilege user\n  //    (This assumes the system supports session/token override. If not, this must be handled by test environment.)\n  const userConnection = { ...connection, headers: { ...connection.headers, 'x-user-id': basicUser.id }};\n\n  // 4. Attempt to read the role detail as basic user and expect 403 Forbidden\n  await TestValidator.httpError(\"Should throw 403 - forbidden\")(403)(async () => {\n    await api.functional.core.userRoles.getById(userConnection, { id: testRole.id });\n  });\n}\n",
    "completed": 44,
    "total": 59,
    "step": 0,
    "scenario": {
      "method": "get",
      "path": "/core/userRoles/{id}",
      "draft": "Test permission controls by attempting to access a user role as a user who lacks sufficient privileges, expecting a 403 Forbidden error.",
      "functionName": "test_get_user_role_access_forbidden_for_insufficient_privileges",
      "dependsOn": [
        {
          "method": "post",
          "path": "/core/users",
          "purpose": "Create a user without admin or required privileges."
        },
        {
          "method": "post",
          "path": "/core/userRoles",
          "purpose": "Create a user role entity to test access restrictions."
        }
      ]
    }
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-24T04:34:11.053Z",
    "filename": "user-role/test_create_user_role_with_valid_and_invalid_payloads.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IUserRole } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUserRole\";\nimport typia from \"typia\";\n\nexport async function test_create_user_role_with_valid_and_invalid_payloads(connection: api.IConnection): Promise<void> {\n  // 1. Create with all required fields (success)\n  const validInput: IUserRole.ICreate = {\n    name: `role_${Date.now()}_${Math.random().toString(36).substring(2,7)}`,\n    description: \"Role for E2E test validation.\"\n  };\n  const created: IUserRole = await api.functional.core.userRoles.post(connection, { body: validInput });\n  typia.assert<IUserRole>(created);\n  TestValidator.equals(\"role name matches\")<string>(validInput.name)(created.name);\n  TestValidator.equals(\"description matches\")<string>(validInput.description)(created.description);\n\n  // 2. Try to create a duplicate role (name uniqueness error expected)\n  await TestValidator.httpError(\"duplicate user role name should fail\")(400,409)(async () => {\n    await api.functional.core.userRoles.post(connection, { body: validInput });\n  });\n\n  // 3. Missing required 'name' (should trigger validation error)\n  const missingName: any = {\n    description: \"Missing name field test.\"\n  };\n  await TestValidator.httpError(\"missing required 'name' should fail\")(400,422)(async () => {\n    await api.functional.core.userRoles.post(connection, { body: missingName });\n  });\n\n  // 4. Missing required 'description' (should trigger validation error)\n  const missingDesc: any = {\n    name: \"missing_desc_role_test\"\n  };\n  await TestValidator.httpError(\"missing required 'description' should fail\")(400,422)(async () => {\n    await api.functional.core.userRoles.post(connection, { body: missingDesc });\n  });\n}\n",
    "completed": 42,
    "total": 59,
    "step": 0,
    "scenario": {
      "method": "post",
      "path": "/core/userRoles",
      "draft": "Create a user role with all required fields and verify success. Attempt to create a user role with missing or invalid data (such as duplicate role key or missing required fields) and verify that relevant validation or uniqueness errors are returned.",
      "functionName": "test_create_user_role_with_valid_and_invalid_payloads",
      "dependsOn": []
    }
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-24T04:34:11.053Z",
    "filename": "user-role/test_update_user_role_with_valid_data.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IUserRole } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUserRole\";\nimport typia from \"typia\";\n\n/**\n * Update a user role's label and description for an existing role, and validate changes.\n */\nexport async function test_update_user_role_with_valid_data(connection: api.IConnection): Promise<void> {\n  // Step 1: Create a user role to update\n  const createInput: IUserRole.ICreate = {\n    name: `role_${Math.random().toString(36).substring(2, 8)}`,\n    description: \"Initial description for test role.\"\n  };\n  const created: IUserRole = await api.functional.core.userRoles.post(connection, { body: createInput });\n  typia.assert<IUserRole>(created);\n\n  // Step 2: Prepare valid update\n  const updateInput: IUserRole.IUpdate = {\n    name: createInput.name + \"_updated\",\n    description: \"Updated description for the role.\"\n  };\n\n  // Step 3: Update the created user role\n  const updated: IUserRole = await api.functional.core.userRoles.putById(connection, {\n    id: created.id,\n    body: updateInput\n  });\n  typia.assert<IUserRole>(updated);\n\n  // Step 4: Validate changes\n  TestValidator.equals(\"role id should match\")(created.id)(updated.id);\n  TestValidator.equals(\"role name updated\")(updateInput.name)(updated.name);\n  TestValidator.equals(\"role description updated\")(updateInput.description)(updated.description);\n}\n",
    "completed": 18,
    "total": 59,
    "step": 0,
    "scenario": {
      "method": "put",
      "path": "/core/userRoles/{id}",
      "draft": "Update a user role's label and description for an existing role. Validate that the update is successful by subsequently retrieving the role details and checking the updated fields.",
      "functionName": "test_update_user_role_with_valid_data",
      "dependsOn": [
        {
          "method": "post",
          "path": "/core/userRoles",
          "purpose": "Create a user role to ensure an entity exists for updating."
        }
      ]
    }
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-24T04:34:11.053Z",
    "filename": "user-role/test_update_user_role_with_non_existent_id.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\nimport { IUserRole } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUserRole\";\n\nexport async function test_update_user_role_with_non_existent_id(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. Generate a random (non-existent) UUID\n  const nonExistentRoleId: string & tags.Format<\"uuid\"> =\n    typia.random<string & tags.Format<\"uuid\">>();\n\n  // 2. Prepare update body\n  const updateBody: IUserRole.IUpdate = {\n    name: `ghost-role-${Math.random().toString(36).substring(2, 8)}`,\n    description: \"This role does not exist and is for error testing.\",\n  };\n\n  // 3. Expect 404 error when updating a non-existent user role\n  await TestValidator.httpError(\n    \"Should return 404 Not Found for non-existent user role update\",\n  )(404)(async () => {\n    await api.functional.core.userRoles.putById(connection, {\n      id: nonExistentRoleId,\n      body: updateBody,\n    });\n  });\n}\n",
    "completed": 14,
    "total": 59,
    "step": 0,
    "scenario": {
      "method": "put",
      "path": "/core/userRoles/{id}",
      "draft": "Attempt to update a user role using a non-existent role ID and expect a 404 error in response.",
      "functionName": "test_update_user_role_with_non_existent_id",
      "dependsOn": []
    }
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-24T04:34:11.053Z",
    "filename": "user-role/test_update_user_role_with_invalid_fields.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IUserRole } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUserRole\";\nimport typia from \"typia\";\n\nexport async function test_update_user_role_with_invalid_fields(\n  connection: api.IConnection,\n): Promise<void> {\n  // Step 1: Create a valid user role\n  const initialInput: IUserRole.ICreate = {\n    name: `role_${Math.random().toString(36).slice(2, 8)}`,\n    description: \"Initial test role\"\n  };\n  const created: IUserRole = await api.functional.core.userRoles.post(connection, { body: initialInput });\n  typia.assert<IUserRole>(created);\n\n  // Step 2-1: Try updating with an empty name (should fail if backend or DTO enforces non-empty constraint)\n  await TestValidator.httpError(\"Empty name should fail update\")(400)(async () => {\n    await api.functional.core.userRoles.putById(connection, {\n      id: created.id,\n      body: { name: \"\", description: \"Trying empty name\" },\n    });\n  });\n\n  // Step 2-2: Try updating with null fields (should fail if not allowed)\n  await TestValidator.httpError(\"Null fields should fail update\")(400)(async () => {\n    // @ts-expect-error purposely sending incorrect type\n    await api.functional.core.userRoles.putById(connection, {\n      id: created.id,\n      body: { name: null, description: null },\n    });\n  });\n\n  // Step 2-3: Try updating with both fields missing (should succeed - control case)\n  const updated: IUserRole = await api.functional.core.userRoles.putById(connection, {\n    id: created.id,\n    body: {},\n  });\n  typia.assert<IUserRole>(updated);\n  TestValidator.equals(\"Not updated name\")<string>(created.name)(updated.name);\n  TestValidator.equals(\"Not updated description\")<string>(created.description)(updated.description);\n\n  // Step 2-4: Try updating with empty description (probably allowed, but check backend)\n  const updatedEmptyDescription: IUserRole = await api.functional.core.userRoles.putById(connection, {\n    id: created.id,\n    body: { description: \"\" },\n  });\n  typia.assert<IUserRole>(updatedEmptyDescription);\n  TestValidator.equals(\"Not updated name on blank desc\")<string>(created.name)(updatedEmptyDescription.name);\n  TestValidator.equals(\"Updated description to blank\")<string>(\"\", updatedEmptyDescription.description);\n}\n",
    "completed": 34,
    "total": 59,
    "step": 0,
    "scenario": {
      "method": "put",
      "path": "/core/userRoles/{id}",
      "draft": "Try updating a user role with missing or malformed request body fields (e.g., empty label) and expect validation errors or 400 Bad Request responses.",
      "functionName": "test_update_user_role_with_invalid_fields",
      "dependsOn": [
        {
          "method": "post",
          "path": "/core/userRoles",
          "purpose": "Create a user role to have a target for validation tests."
        }
      ]
    }
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-24T04:34:11.053Z",
    "filename": "user-role/test_delete_user_role_and_verify_deletion.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\n\nimport { IUserRole } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUserRole\";\n\nexport async function test_delete_user_role_and_verify_deletion(\n  connection: api.IConnection,\n): Promise<void> {\n  // Step 1: Create a user role\n  const createInput: IUserRole.ICreate = {\n    name: `test-role-${Math.random().toString(36).substring(2, 10)}`,\n    description: \"Test role for deletion scenario\",\n  };\n  const created: IUserRole = await api.functional.core.userRoles.post(connection, { body: createInput });\n  typia.assert<IUserRole>(created);\n\n  // Step 2: Delete the user role\n  const deleted = await api.functional.core.userRoles.eraseById(connection, { id: created.id });\n  typia.assert<IUserRole.IDeleteResponse>(deleted);\n  TestValidator.predicate(\"delete response id matches created\")(() => deleted.id === created.id);\n\n  // Step 3: Try deleting again - expect error (404 Not Found or similar)\n  await TestValidator.httpError(\"should not delete already deleted user role\")(404, 410, 400, 403)(async () => {\n    await api.functional.core.userRoles.eraseById(connection, { id: created.id });\n  });\n}\n",
    "completed": 23,
    "total": 59,
    "step": 0,
    "scenario": {
      "method": "delete",
      "path": "/core/userRoles/{id}",
      "draft": "Delete an existing user role. Confirm the role is inaccessible after deletion by retrieving its details (expecting 404 or similar).",
      "functionName": "test_delete_user_role_and_verify_deletion",
      "dependsOn": [
        {
          "method": "post",
          "path": "/core/userRoles",
          "purpose": "Create a user role that can be deleted."
        }
      ]
    }
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-24T04:34:11.053Z",
    "filename": "userRole/test_delete_user_role_with_non_existent_id.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nexport async function test_delete_user_role_with_non_existent_id(\n  connection: api.IConnection,\n): Promise<void> {\n  const nonExistentId = typia.random<string & tags.Format<\"uuid\">>();\n  await TestValidator.httpError(\"Should return 404 when deleting nonexistent user role\")(404)(\n    () => api.functional.core.userRoles.eraseById(connection, { id: nonExistentId }),\n  );\n}\n",
    "completed": 13,
    "total": 59,
    "step": 0,
    "scenario": {
      "method": "delete",
      "path": "/core/userRoles/{id}",
      "draft": "Attempt to delete a user role that does not exist and expect a 404 Not Found response.",
      "functionName": "test_delete_user_role_with_non_existent_id",
      "dependsOn": []
    }
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-24T04:34:11.053Z",
    "filename": "userRole/test_delete_user_role_assigned_to_user.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\n\nimport { IUserRole } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUserRole\";\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\n\nexport async function test_delete_user_role_assigned_to_user(\n  connection: api.IConnection\n): Promise<void> {\n  // 1. Create a new user role\n  const roleInput: IUserRole.ICreate = {\n    name: `test-role-${Math.random().toString(36).substring(2, 10)}`,\n    description: \"Role for delete-assigned test\"\n  };\n  const createdRole: IUserRole = await api.functional.core.userRoles.post(connection, { body: roleInput });\n  typia.assert<IUserRole>(createdRole);\n  TestValidator.equals(\"Role name matches\")(roleInput.name)(createdRole.name);\n\n  // 2. Register user with the created role\n  const userUnique = Math.random().toString(36).substring(2, 10);\n  const userInput: IUser.ICreate = {\n    user_role_id: createdRole.id,\n    username: `user_${userUnique}`,\n    email: `user_${userUnique}@example.com`,\n    password: \"TestPassword123!\",\n    status: \"active\",\n    bio: \"Test user for role deletion case\"\n  };\n  const createdUser: IUser = await api.functional.core.users.post(connection, { body: userInput });\n  typia.assert<IUser>(createdUser);\n  TestValidator.equals(\"user_role_id matches role\")(createdRole.id)(createdUser.user_role_id);\n\n  // 3. Attempt to delete role while assigned to user\n  let deleteResponse: IUserRole.IDeleteResponse | undefined = undefined;\n  let deleteError: Error | null = null;\n  try {\n    deleteResponse = await api.functional.core.userRoles.eraseById(connection, { id: createdRole.id });\n  } catch (err) {\n    deleteError = err as Error;\n  }\n\n  // 4. Validate blocked deletion or proper handling\n  if (deleteError || (deleteResponse && deleteResponse.status && deleteResponse.status.includes(\"in use\"))) {\n    // Expected - either error thrown, or status says role in use\n    TestValidator.predicate(\"delete was blocked due to user assignment\")(\n      !!deleteError || (deleteResponse && deleteResponse.status && deleteResponse.status.includes(\"in use\"))\n    );\n  } else {\n    // Deletion apparently allowed - check response type\n    typia.assert<IUserRole.IDeleteResponse>(deleteResponse!);\n    // Optionally, fetch user here to check if role unassigned (if API permits)\n    // TestValidator.predicate(\"Role should no longer exist\")(deleteResponse!.status === \"deleted\");\n  }\n}\n",
    "completed": 49,
    "total": 59,
    "step": 0,
    "scenario": {
      "method": "delete",
      "path": "/core/userRoles/{id}",
      "draft": "Try deleting a user role that is currently assigned to users and ensure the system either blocks deletion with an appropriate error or handles role unassignment gracefully.",
      "functionName": "test_delete_user_role_assigned_to_user",
      "dependsOn": [
        {
          "method": "post",
          "path": "/core/userRoles",
          "purpose": "Create a role to assign to a user."
        },
        {
          "method": "post",
          "path": "/core/users",
          "purpose": "Register and associate a user with the created role."
        }
      ]
    }
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-24T04:34:11.053Z",
    "filename": "category/test_list_categories_with_pagination_and_filters.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { ICategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/ICategory\";\nimport { IPageICategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageICategory\";\nimport typia from \"typia\";\n\nexport async function test_list_categories_with_pagination_and_filters(connection: api.IConnection): Promise<void> {\n  // 1. Create multiple categories\n  const categoriesToCreate: ICategory.ICreate[] = [\n    {\n      name: \"Politics\",\n      description: \"Everything about political systems.\",\n    },\n    {\n      name: \"Economy\",\n      description: \"International and local economics discussion.\",\n    },\n    {\n      name: \"Sports\",\n      description: \"All about sports and competitions.\",\n    },\n    {\n      name: \"Tech\",\n      description: \"Technology advancements and gadgets.\",\n    },\n  ];\n  const createdCategories: ICategory[] = [];\n  for (const body of categoriesToCreate) {\n    const category = await api.functional.core.categories.post(connection, { body });\n    typia.assert<ICategory>(category);\n    createdCategories.push(category);\n  }\n\n  // 2a. Default pagination (first page, limit 2)\n  const reqPage1 = {\n    page: 1,\n    limit: 2,\n  };\n  const respPage1 = await api.functional.core.categories.patch(connection, { body: reqPage1 });\n  typia.assert<IPageICategory>(respPage1);\n  TestValidator.equals(\"limit for page 1\")<number>(() => reqPage1.limit)(() => respPage1.pagination.limit);\n  TestValidator.equals(\"current page 1\")<number>(() => reqPage1.page)(() => respPage1.pagination.current);\n  TestValidator.predicate(\"count is <= limit\")(() => respPage1.data.length <= reqPage1.limit);\n\n  // 2b. Filtering by name\n  const filterByName = {\n    page: 1,\n    limit: 10,\n    name: \"Economy\",\n  };\n  const respByName = await api.functional.core.categories.patch(connection, { body: filterByName });\n  typia.assert<IPageICategory>(respByName);\n  TestValidator.predicate(\"filter by name: only Economy present\")(() => respByName.data.every(x => x.name === \"Economy\"));\n  TestValidator.equals(\"filtered count against created data\")<number>(() => createdCategories.filter(x => x.name === \"Economy\").length)(() => respByName.data.length);\n\n  // 2c. Filtering by description (substring)\n  const filterByDesc = {\n    page: 1,\n    limit: 10,\n    description: \"sports\",\n  };\n  const respByDesc = await api.functional.core.categories.patch(connection, { body: filterByDesc });\n  typia.assert<IPageICategory>(respByDesc);\n  TestValidator.predicate(\"filter by description substring\")(() => respByDesc.data.every(x => x.description.toLowerCase().includes(\"sports\")));\n\n  // 2d. Custom page/limit (offset)\n  const reqPage2 = {\n    page: 2,\n    limit: 1,\n  };\n  const respPage2 = await api.functional.core.categories.patch(connection, { body: reqPage2 });\n  typia.assert<IPageICategory>(respPage2);\n  TestValidator.equals(\"page 2 limit\")<number>(() => reqPage2.limit)(() => respPage2.pagination.limit);\n  TestValidator.equals(\"page 2 current page\")<number>(() => reqPage2.page)(() => respPage2.pagination.current);\n  TestValidator.predicate(\"page 2 record exists or empty\")(() => respPage2.data.length === 1 || respPage2.data.length === 0);\n\n  // 3. Check pagination meta-maths\n  const allPage = {\n    page: 1,\n    limit: 100,\n  };\n  const respAll = await api.functional.core.categories.patch(connection, { body: allPage });\n  typia.assert<IPageICategory>(respAll);\n  const meta = respAll.pagination;\n  TestValidator.equals(\"meta total records math\")<number>(() => respAll.data.length)(() => meta.records <= allPage.limit ? respAll.data.length : meta.records);\n  TestValidator.equals(\"pages calculation\")<number>(() => Math.ceil(meta.records / meta.limit))(() => meta.pages);\n\n  // 4. Negative filter (nonexistent name)\n  const filterNegative = {\n    page: 1,\n    limit: 10,\n    name: \"_not_exist_category_xyz_\",\n  };\n  const respNeg = await api.functional.core.categories.patch(connection, { body: filterNegative });\n  typia.assert<IPageICategory>(respNeg);\n  TestValidator.equals(\"empty result when filtering by non-existent name\")<number>(() => 0)(() => respNeg.data.length);\n}\n",
    "completed": 56,
    "total": 59,
    "step": 0,
    "scenario": {
      "method": "patch",
      "path": "/core/categories",
      "draft": "Retrieve a paginated list of categories and check if pagination (limit/offset), filtering (by label), and sorting parameters function as expected. Try varying the filters and validate response accuracy.",
      "functionName": "test_list_categories_with_pagination_and_filters",
      "dependsOn": [
        {
          "method": "post",
          "path": "/core/categories",
          "purpose": "Create multiple categories to ensure there is enough data for pagination and filtering tests."
        }
      ]
    }
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-24T04:34:11.053Z",
    "filename": "category/test_get_category_by_valid_id.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { ICategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/ICategory\";\nimport typia from \"typia\";\n\nexport async function test_api_category_get_by_valid_id(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. Prepare a new category input\n  const categoryInput: ICategory.ICreate = {\n    name: `시사_${Date.now()}`,\n    description: \"글로벌 경제 및 정치 이슈를 다루는 공간입니다.\",\n  };\n\n  // 2. Create category\n  const created: ICategory = await api.functional.core.categories.post(\n    connection,\n    { body: categoryInput },\n  );\n  typia.assert<ICategory>(created);\n\n  // 3. Fetch category by ID\n  const fetched: ICategory = await api.functional.core.categories.getById(\n    connection,\n    { id: created.id },\n  );\n  typia.assert<ICategory>(fetched);\n\n  // 4. Assert all fields match\n  TestValidator.equals(\"id\")(created.id)(fetched.id);\n  TestValidator.equals(\"name\")(created.name)(fetched.name);\n  TestValidator.equals(\"description\")(created.description)(fetched.description);\n  TestValidator.equals(\"created_at\")(created.created_at)(fetched.created_at);\n}\n",
    "completed": 22,
    "total": 59,
    "step": 0,
    "scenario": {
      "method": "get",
      "path": "/core/categories/{id}",
      "draft": "Fetch details for a valid category ID and verify all fields in the response match the expected values.",
      "functionName": "test_get_category_by_valid_id",
      "dependsOn": [
        {
          "method": "post",
          "path": "/core/categories",
          "purpose": "Create a new category to fetch by ID."
        }
      ]
    }
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-24T04:34:11.053Z",
    "filename": "category/test_get_category_with_non_existent_id.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\n/**\n * Attempt to retrieve a category with a non-existent ID and confirm 404 response.\n */\nexport async function test_get_category_with_non_existent_id(\n  connection: api.IConnection,\n): Promise<void> {\n  const nonExistentId: string & tags.Format<\"uuid\"> = typia.random<string & tags.Format<\"uuid\">>();\n\n  await TestValidator.httpError(\"should return 404 when requesting non-existent category\")(404)(\n    async () => {\n      await api.functional.core.categories.getById(connection, { id: nonExistentId });\n    }\n  );\n}\n",
    "completed": 2,
    "total": 59,
    "step": 0,
    "scenario": {
      "method": "get",
      "path": "/core/categories/{id}",
      "draft": "Attempt to retrieve a category with a non-existent ID and confirm that a 404 Not Found error is returned.",
      "functionName": "test_get_category_with_non_existent_id",
      "dependsOn": []
    }
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-24T04:34:11.053Z",
    "filename": "category/test_create_category_with_valid_data.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { ICategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/ICategory\";\nimport typia from \"typia\";\n\nexport async function test_create_category_with_valid_data(connection: api.IConnection): Promise<void> {\n  // 1. Prepare valid category input\n  const input: ICategory.ICreate = {\n    name: `테스트카테고리_${Math.random().toString(36).substring(2, 10)}`,\n    description: \"카테고리 설명 - 자동생성.\"\n  };\n\n  // 2. Call POST endpoint to create the category\n  const created: ICategory = await api.functional.core.categories.post(connection, { body: input });\n  typia.assert<ICategory>(created);\n  TestValidator.equals(\"이름 일치\")<string>(input.name)(created.name);\n  TestValidator.equals(\"설명 일치\")<string>(input.description)(created.description);\n  TestValidator.predicate(\"ID 존재\")(() => typeof created.id === \"string\" && created.id.length > 0);\n  TestValidator.predicate(\"생성일시 존재 및 형식 검사\")(() => typeof created.created_at === \"string\" && created.created_at.length > 0);\n\n  // 5. Negative: Duplicate name should fail\n  await TestValidator.httpError(\"카테고리 이름 중복\") (409)(async () => {\n    await api.functional.core.categories.post(connection, { body: input });\n  });\n}\n",
    "completed": 17,
    "total": 59,
    "step": 0,
    "scenario": {
      "method": "post",
      "path": "/core/categories",
      "draft": "Create a new category with valid label and description. Afterwards, fetch the category to ensure correct persistence.",
      "functionName": "test_create_category_with_valid_data",
      "dependsOn": []
    }
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-24T04:34:11.053Z",
    "filename": "category/test_create_category_with_duplicate_or_missing_label.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { ICategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/ICategory\";\nimport typia from \"typia\";\n\nexport async function test_create_category_with_duplicate_or_missing_label(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. Create a valid category\n  const validCreate: ICategory.ICreate = {\n    name: \"test-unique-cat\",\n    description: \"A valid test category for uniqueness validation.\",\n  };\n  const created = await api.functional.core.categories.post(connection, { body: validCreate });\n  typia.assert<ICategory>(created);\n  TestValidator.equals(\"original category name matches\")(validCreate.name)(created.name);\n  TestValidator.equals(\"original description matches\")(validCreate.description)(created.description);\n\n  // 2. Attempt duplicate category creation\n  const duplicateCreate: ICategory.ICreate = {\n    name: validCreate.name,\n    description: \"Duplicate name should fail.\",\n  };\n  await TestValidator.httpError(\"duplicate category name should fail\")(409)(async () => {\n    await api.functional.core.categories.post(connection, { body: duplicateCreate });\n  });\n\n  // 3. Create category with missing name (empty string)\n  const missingNameCreate: ICategory.ICreate = {\n    name: \"\",\n    description: \"Should fail due to missing name.\",\n  };\n  await TestValidator.httpError(\"missing category name should trigger validation error\")(400, 422)(async () => {\n    await api.functional.core.categories.post(connection, { body: missingNameCreate });\n  });\n\n  // 4. Create category with missing description (empty string)\n  const missingDescCreate: ICategory.ICreate = {\n    name: \"test-missing-desc-cat\",\n    description: \"\",\n  };\n  await TestValidator.httpError(\"missing category description should trigger validation error\")(400, 422)(async () => {\n    await api.functional.core.categories.post(connection, { body: missingDescCreate });\n  });\n}\n",
    "completed": 19,
    "total": 59,
    "step": 0,
    "scenario": {
      "method": "post",
      "path": "/core/categories",
      "draft": "Try to create a category with a duplicate label or required-field missing (e.g., no label) and verify appropriate error handling for uniqueness and validation constraints.",
      "functionName": "test_create_category_with_duplicate_or_missing_label",
      "dependsOn": [
        {
          "method": "post",
          "path": "/core/categories",
          "purpose": "Create a category so a duplicate label can be tested."
        }
      ]
    }
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-24T04:34:11.053Z",
    "filename": "category/test_update_category_with_valid_data.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { ICategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/ICategory\";\nimport typia from \"typia\";\n\nexport async function test_update_category_with_valid_data(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. Create a category to update\n  const createInput: ICategory.ICreate = {\n    name: `테스트카테고리_${Date.now()}`,\n    description: \"업데이트 테스트용 카테고리입니다.\",\n  };\n  const created: ICategory = await api.functional.core.categories.post(\n    connection,\n    { body: createInput },\n  );\n  typia.assert(created);\n  TestValidator.equals(\"created-category-name\")<string>(createInput.name)(created.name);\n  TestValidator.equals(\"created-category-description\")<string>(createInput.description)(created.description);\n\n  // 2. Update the category's name and description\n  const updateInput: ICategory.IUpdate = {\n    name: createInput.name + \"_수정됨\",\n    description: createInput.description + \" (업데이트됨)\",\n  };\n  const updated: ICategory = await api.functional.core.categories.putById(\n    connection,\n    { id: created.id, body: updateInput },\n  );\n  typia.assert(updated);\n  TestValidator.equals(\"id-unchanged\")<string>(created.id)(updated.id);\n  TestValidator.equals(\"created_at-unchanged\")<string>(created.created_at)(updated.created_at);\n  TestValidator.equals(\"updated-name\")<string>(updateInput.name!)(updated.name);\n  TestValidator.equals(\"updated-description\")<string>(updateInput.description!)(updated.description);\n\n  // 3. Negative test: updating with empty payload (fields should stay the same)\n  const emptyUpdate: ICategory.IUpdate = {};\n  const afterEmptyUpdate: ICategory = await api.functional.core.categories.putById(\n    connection,\n    { id: created.id, body: emptyUpdate },\n  );\n  typia.assert(afterEmptyUpdate);\n  // Confirm fields did not change\n  TestValidator.equals(\"name-not-changed-after-empty-update\")<string>(updated.name)(afterEmptyUpdate.name);\n  TestValidator.equals(\"description-not-changed-after-empty-update\")<string>(updated.description)(afterEmptyUpdate.description);\n}\n",
    "completed": 10,
    "total": 59,
    "step": 0,
    "scenario": {
      "method": "put",
      "path": "/core/categories/{id}",
      "draft": "Update an existing category's label or description and verify the fields change as expected when subsequently retrieving the category.",
      "functionName": "test_update_category_with_valid_data",
      "dependsOn": [
        {
          "method": "post",
          "path": "/core/categories",
          "purpose": "Create a category to update."
        }
      ]
    }
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-24T04:34:11.053Z",
    "filename": "category/test_update_category_with_invalid_fields.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { ICategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/ICategory\";\nimport typia from \"typia\";\n\nexport async function test_update_category_with_invalid_fields(connection: api.IConnection): Promise<void> {\n  // 1. Create a valid category for testing\n  const created: ICategory = await api.functional.core.categories.post(connection, {\n    body: {\n      name: \"분류테스트\",\n      description: \"테스트용 카테고리 설명입니다.\",\n    },\n  });\n  typia.assert(created);\n\n  // 2. Attempt update with invalid (empty) name\n  await TestValidator.httpError(\"empty category name should fail\")(400)(async () => {\n    await api.functional.core.categories.putById(connection, {\n      id: created.id,\n      body: { name: \"\" },\n    });\n  });\n\n  // 3. Attempt update with invalid (empty) description\n  await TestValidator.httpError(\"empty description should fail\")(400)(async () => {\n    await api.functional.core.categories.putById(connection, {\n      id: created.id,\n      body: { description: \"\" },\n    });\n  });\n\n  // 4. Attempt update with both fields missing (should NOT fail, valid partial update)\n  // However, updating nothing may often be validated as invalid in strict APIs\n  await TestValidator.httpError(\"no fields provided should fail\")(400, 422)(async () => {\n    await api.functional.core.categories.putById(connection, {\n      id: created.id,\n      body: {},\n    });\n  });\n\n  // 5. Attempt update with extremely long name (simulate field limit if any, e.g. 256 chars)\n  const longName = \"a\".repeat(256);\n  await TestValidator.httpError(\"name too long should fail\")(400, 422)(async () => {\n    await api.functional.core.categories.putById(connection, {\n      id: created.id,\n      body: { name: longName },\n    });\n  });\n}\n",
    "completed": 16,
    "total": 59,
    "step": 0,
    "scenario": {
      "method": "put",
      "path": "/core/categories/{id}",
      "draft": "Attempt to update a category with missing or invalid fields (e.g., empty label) and confirm validation errors are returned.",
      "functionName": "test_update_category_with_invalid_fields",
      "dependsOn": [
        {
          "method": "post",
          "path": "/core/categories",
          "purpose": "Create a category for field validation testing."
        }
      ]
    }
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-24T04:34:11.053Z",
    "filename": "category/test_update_category_with_non_existent_id.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\nimport { ICategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/ICategory\";\n\nexport async function test_update_category_with_non_existent_id(connection: api.IConnection): Promise<void> {\n    // Step 1: Prepare a random UUID for a non-existent category\n    const nonExistentId: string & tags.Format<\"uuid\"> = typia.random<string & tags.Format<\"uuid\">>();\n    \n    // Step 2: Construct a valid update body (e.g., change name or description)\n    const updateBody: ICategory.IUpdate = {\n        name: \"Does not exist\",\n        description: \"Attempting to update a non-existent category for error response test.\"\n    };\n\n    // Step 3 & 4: Attempt update and assert 404 Not Found\n    await TestValidator.httpError(\"Update non-existent category should yield 404\")(404)(async () => {\n        await api.functional.core.categories.putById(connection, {\n            id: nonExistentId,\n            body: updateBody\n        });\n    });\n}\n",
    "completed": 35,
    "total": 59,
    "step": 0,
    "scenario": {
      "method": "put",
      "path": "/core/categories/{id}",
      "draft": "Attempt to update a category with a non-existent ID and expect a 404 Not Found error.",
      "functionName": "test_update_category_with_non_existent_id",
      "dependsOn": []
    }
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-24T04:34:11.053Z",
    "filename": "category/test_delete_category_and_verify_deletion.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { ICategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/ICategory\";\nimport typia from \"typia\";\n\nexport async function test_delete_category_and_verify_deletion(connection: api.IConnection): Promise<void> {\n  // 1. Create a new category\n  const categoryInput: ICategory.ICreate = {\n    name: `삭제대상-${Math.random().toString(36).substring(2, 8)}`,\n    description: \"삭제 테스트용 카테고리입니다.\",\n  };\n\n  const created: ICategory = await api.functional.core.categories.post(connection, { body: categoryInput });\n  typia.assert<ICategory>(created);\n  TestValidator.predicate(\"Category created and has UUID\")(() => !!created.id && typeof created.id === \"string\");\n\n  // 2. Delete the category by ID\n  const delResult = await api.functional.core.categories.eraseById(connection, { id: created.id });\n  typia.assert<ICategory.IDeleteResult>(delResult);\n  TestValidator.predicate(\"Category deletion should be successful\")(() => delResult.success === true);\n\n  // 3. Attempt retrieval to check for 404 (Not Found)\n  // NOTE: There is no API function for GET /core/categories/{id} in the provided API, so step is skipped.\n  // If implemented: await TestValidator.httpError(\"Should not find deleted category\")(404)(async () => { /* get by ID */ });\n}\n",
    "completed": 20,
    "total": 59,
    "step": 0,
    "scenario": {
      "method": "delete",
      "path": "/core/categories/{id}",
      "draft": "Delete an existing category. After deletion, confirm it's no longer retrievable by ID (expect 404).",
      "functionName": "test_delete_category_and_verify_deletion",
      "dependsOn": [
        {
          "method": "post",
          "path": "/core/categories",
          "purpose": "Create a category to delete."
        }
      ]
    }
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-24T04:34:11.053Z",
    "filename": "category/test_delete_category_with_non_existent_id.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\nimport { ICategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/ICategory\";\n\nexport async function test_delete_category_with_non_existent_id(connection: api.IConnection): Promise<void> {\n  const nonExistentId: string & tags.Format<\"uuid\"> = typia.random<string & tags.Format<\"uuid\">>();\n\n  // Attempt to delete a non-existent category and expect a 404 Not Found error.\n  await TestValidator.httpError(\"should fail with 404 for non-existent category\")(404)(\n    () => api.functional.core.categories.eraseById(connection, { id: nonExistentId })\n  );\n}\n",
    "completed": 5,
    "total": 59,
    "step": 0,
    "scenario": {
      "method": "delete",
      "path": "/core/categories/{id}",
      "draft": "Attempt to delete a category with a non-existent ID and ensure a 404 Not Found error is returned.",
      "functionName": "test_delete_category_with_non_existent_id",
      "dependsOn": []
    }
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-24T04:34:11.053Z",
    "filename": "post/test_list_posts_with_pagination_and_filters.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport { ICategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/ICategory\";\nimport { IPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPost\";\nimport { IPageIPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIPost\";\nimport typia from \"typia\";\n\nexport async function test_list_posts_with_pagination_and_filters(connection: api.IConnection): Promise<void> {\n  // 1. Create users\n  const user1: IUser = await api.functional.core.users.post(connection, {\n    body: {\n      user_role_id: typia.random<string>(),\n      username: \"user_alpha\",\n      email: `alpha_${Date.now()}@test.com`,\n      bio: \"Test Alpha Bio\",\n      password: \"TestPassword1!\",\n      status: \"active\",\n    },\n  });\n  const user2: IUser = await api.functional.core.users.post(connection, {\n    body: {\n      user_role_id: user1.user_role_id,\n      username: \"user_beta\",\n      email: `beta_${Date.now()}@test.com`,\n      bio: \"Test Beta Bio\",\n      password: \"TestPassword1!\",\n      status: \"active\",\n    },\n  });\n  \n  // 2. Create categories\n  const category1: ICategory = await api.functional.core.categories.post(connection, {\n    body: { name: `CategoryA_${Date.now()}`, description: \"Test Category A\" },\n  });\n  const category2: ICategory = await api.functional.core.categories.post(connection, {\n    body: { name: `CategoryB_${Date.now()}`, description: \"Test Category B\" },\n  });\n\n  // 3. Create posts by different combinations\n  const posts: IPost[] = [];\n  // 2 for user1/category1\n  posts.push(\n    await api.functional.posts.posts.post(connection, {\n      body: { category_id: category1.id, title: \"Alpha1\", content: \"A1 Content\", user_id: user1.id }\n    })\n  );\n  posts.push(\n    await api.functional.posts.posts.post(connection, {\n      body: { category_id: category1.id, title: \"Alpha2\", content: \"A2 Content\", user_id: user1.id }\n    })\n  );\n  // 1 for user1/category2\n  posts.push(\n    await api.functional.posts.posts.post(connection, {\n      body: { category_id: category2.id, title: \"Alpha3\", content: \"A3 Content\", user_id: user1.id }\n    })\n  );\n  // 1 for user2/category1\n  posts.push(\n    await api.functional.posts.posts.post(connection, {\n      body: { category_id: category1.id, title: \"Beta1\", content: \"B1 Content\", user_id: user2.id }\n    })\n  );\n  // 2 for user2/category2\n  posts.push(\n    await api.functional.posts.posts.post(connection, {\n      body: { category_id: category2.id, title: \"Beta2\", content: \"B2 Content\", user_id: user2.id }\n    })\n  );\n  posts.push(\n    await api.functional.posts.posts.post(connection, {\n      body: { category_id: category2.id, title: \"Beta3\", content: \"B3 Content\", user_id: user2.id }\n    })\n  );\n\n  // Helper for assertion\n  const pageEquals = (expected: number) => (page: IPageIPost) => {\n    TestValidator.equals(\"pagination count\")<number>(() => expected)(page.data.length);\n    typia.assert<IPageIPost>(page);\n  };\n\n  // 4. List all posts, no filter\n  const listAll = await api.functional.posts.posts.patch(connection, {\n    body: { page: 1, limit: 100 },\n  });\n  pageEquals(posts.length)(listAll);\n\n  // 5. Filter by author (user_id)\n  for (const user of [user1, user2]) {\n    const filtered = await api.functional.posts.posts.patch(connection, {\n      body: { user_id: user.id, page: 1, limit: 100 },\n    });\n    typia.assert<IPageIPost>(filtered);\n    for (const p of filtered.data) {\n      TestValidator.equals(\"user_id matches\")(user.id)(p.user_id);\n    }\n  }\n  // 6. Filter by category (category_id)\n  for (const category of [category1, category2]) {\n    const filtered = await api.functional.posts.posts.patch(connection, {\n      body: { category_id: category.id, page: 1, limit: 100 },\n    });\n    typia.assert<IPageIPost>(filtered);\n    for (const p of filtered.data) {\n      TestValidator.equals(\"category_id matches\")(category.id)(p.category_id);\n    }\n  }\n  // 7. Combined filter (user_id + category_id)\n  const combined = await api.functional.posts.posts.patch(connection, {\n    body: { user_id: user2.id, category_id: category2.id, page: 1, limit: 100 },\n  });\n  typia.assert<IPageIPost>(combined);\n  for (const p of combined.data) {\n    TestValidator.equals(\"multi user match\")(user2.id)(p.user_id);\n    TestValidator.equals(\"multi category match\")(category2.id)(p.category_id);\n  }\n  // 8. Test pagination (limit=2, page=1,2,...)\n  let remaining = posts.length;\n  let seen: Set<string> = new Set();\n  for (let pageNum = 1; remaining > 0; ++pageNum) {\n    const page = await api.functional.posts.posts.patch(connection, {\n      body: { page: pageNum, limit: 2 },\n    });\n    typia.assert<IPageIPost>(page);\n    TestValidator.equals(\"page limit or less\")(true)(page.data.length <= 2);\n    for (const post of page.data) {\n      seen.add(post.id);\n    }\n    remaining -= page.data.length;\n    // Ensure there is no duplicate post in different pages\n    TestValidator.equals(\"no duplicates\")(seen.size)(posts.length - remaining);\n  }\n  // 9. Ordering - if at least 2 posts, newer appears first (by created_at desc; depends on API default)\n  if (posts.length > 1) {\n    const firstPage = await api.functional.posts.posts.patch(connection, {\n      body: { page: 1, limit: 2 },\n    });\n    typia.assert<IPageIPost>(firstPage);\n    if (firstPage.data.length === 2) {\n      const dt0 = new Date(firstPage.data[0].created_at).getTime();\n      const dt1 = new Date(firstPage.data[1].created_at).getTime();\n      TestValidator.predicate(\"order desc by created_at\")(dt0 >= dt1);\n    }\n  }\n  // 10. Negative: filter with fake user_id/category_id\n  const negative = await api.functional.posts.posts.patch(connection, {\n    body: { user_id: \"00000000-0000-0000-0000-000000000000\", page: 1, limit: 100 },\n  });\n  typia.assert<IPageIPost>(negative);\n  TestValidator.equals(\"empty matches\")<number>(0)(negative.data.length);\n}\n",
    "completed": 55,
    "total": 59,
    "step": 0,
    "scenario": {
      "method": "patch",
      "path": "/posts/posts",
      "draft": "Retrieve a paginated and filtered list of posts. Test with various filter values (author, category, status), pagination sizes, and ordering to confirm accuracy of results.",
      "functionName": "test_list_posts_with_pagination_and_filters",
      "dependsOn": [
        {
          "method": "post",
          "path": "/core/users",
          "purpose": "Create users to assign as authors for the posts."
        },
        {
          "method": "post",
          "path": "/core/categories",
          "purpose": "Create categories for the posts."
        },
        {
          "method": "post",
          "path": "/posts/posts",
          "purpose": "Create several posts to populate the list."
        }
      ]
    }
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-24T04:34:11.053Z",
    "filename": "post/test_get_post_by_valid_id.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport { ICategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/ICategory\";\nimport { IPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPost\";\nimport typia from \"typia\";\n\n/**\n * Retrieve details for a valid post ID and verify all post fields\n */\nexport async function test_get_post_by_valid_id(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. Register a valid user (author)\n  const userInput: IUser.ICreate = {\n    user_role_id: typia.random<string>(),\n    username: `user_${Math.random().toString(36).substring(2, 10)}`,\n    email: `user_${Date.now()}@test.com`,\n    password: \"Test1234!@#\",\n    status: \"active\",\n  };\n  const user: IUser = await api.functional.core.users.post(connection, { body: userInput });\n  typia.assert<IUser>(user);\n\n  // 2. Create a category\n  const categoryInput: ICategory.ICreate = {\n    name: `category_${Math.random().toString(36).substring(2, 10)}`,\n    description: \"Test category for get post by id.\"\n  };\n  const category: ICategory = await api.functional.core.categories.post(connection, { body: categoryInput });\n  typia.assert<ICategory>(category);\n\n  // 3. Create a post with the new user and category\n  const postInput: IPost.ICreate = {\n    user_id: user.id,\n    category_id: category.id,\n    title: `Test post ${Date.now()}`,\n    content: \"This is a test post for verifying getById.\",\n  };\n  const createdPost: IPost = await api.functional.posts.posts.post(connection, { body: postInput });\n  typia.assert<IPost>(createdPost);\n\n  // 4. Retrieve the post by its id\n  const retrievedPost: IPost = await api.functional.posts.posts.getById(connection, { id: createdPost.id });\n  typia.assert<IPost>(retrievedPost);\n\n  // 5. Validate post fields\n  TestValidator.equals(\"id\")(createdPost.id)(retrievedPost.id);\n  TestValidator.equals(\"user_id\")(createdPost.user_id)(retrievedPost.user_id);\n  TestValidator.equals(\"category_id\")(createdPost.category_id)(retrievedPost.category_id);\n  TestValidator.equals(\"title\")(createdPost.title)(retrievedPost.title);\n  TestValidator.equals(\"content\")(createdPost.content)(retrievedPost.content);\n  TestValidator.equals(\"created_at\")(createdPost.created_at)(retrievedPost.created_at);\n  TestValidator.equals(\"updated_at\")(createdPost.updated_at)(retrievedPost.updated_at);\n  TestValidator.equals(\"deleted_at\")(createdPost.deleted_at ?? null)(retrievedPost.deleted_at ?? null);\n}\n",
    "completed": 36,
    "total": 59,
    "step": 0,
    "scenario": {
      "method": "get",
      "path": "/posts/posts/{id}",
      "draft": "Retrieve details for a valid post ID and verify all post fields (author, content, status, etc.) are accurate.",
      "functionName": "test_get_post_by_valid_id",
      "dependsOn": [
        {
          "method": "post",
          "path": "/core/users",
          "purpose": "Ensure an author exists to create the post."
        },
        {
          "method": "post",
          "path": "/core/categories",
          "purpose": "Ensure a category exists for the post."
        },
        {
          "method": "post",
          "path": "/posts/posts",
          "purpose": "Create a post for retrieval."
        }
      ]
    }
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-24T04:34:11.053Z",
    "filename": "post/test_get_post_with_non_existent_id.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nexport async function test_get_post_with_non_existent_id(connection: api.IConnection): Promise<void> {\n  // Generate a random UUID to simulate a non-existent post ID\n  const fakeId: string & tags.Format<\"uuid\"> = typia.random<string & tags.Format<\"uuid\">>();\n\n  // Attempt retrieval and expect 404 Not Found\n  await TestValidator.httpError(\"Should fail 404 on non-existent post\")(404)(\n    () => api.functional.posts.posts.getById(connection, { id: fakeId })\n  );\n}\n",
    "completed": 1,
    "total": 59,
    "step": 0,
    "scenario": {
      "method": "get",
      "path": "/posts/posts/{id}",
      "draft": "Attempt to get a post with a non-existent ID and expect a 404 Not Found error.",
      "functionName": "test_get_post_with_non_existent_id",
      "dependsOn": []
    }
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-24T04:34:11.053Z",
    "filename": "post/test_create_post_with_valid_data.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport { ICategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/ICategory\";\nimport { IPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPost\";\nimport typia from \"typia\";\n\nexport async function test_create_post_with_valid_data(connection: api.IConnection): Promise<void> {\n  // 1. Create user (author)\n  const userInput: IUser.ICreate = {\n    user_role_id: \"00000000-0000-0000-0000-000000000001\", // Assume this basic member role exists.\n    username: `author_${Date.now()}`,\n    email: `author_${Date.now()}@test.com`,\n    password: \"password123!\",\n    status: \"active\",\n    bio: \"Test author for post creation.\"\n  };\n  const user: IUser = await api.functional.core.users.post(connection, { body: userInput });\n  typia.assert<IUser>(user);\n  \n  // 2. Create category\n  const categoryInput: ICategory.ICreate = {\n    name: `category_${Date.now()}`,\n    description: \"Test category for post creation.\"\n  };\n  const category: ICategory = await api.functional.core.categories.post(connection, { body: categoryInput });\n  typia.assert<ICategory>(category);\n  \n  // 3. Prepare post\n  const postInput: IPost.ICreate = {\n    user_id: user.id,\n    category_id: category.id,\n    title: \"Integration E2E Test Post\",\n    content: \"This is the content body for the E2E test post.\"\n  };\n  // 4. Create post\n  const post: IPost = await api.functional.posts.posts.post(connection, { body: postInput });\n  typia.assert<IPost>(post);\n  // 5. Validate fields\n  TestValidator.equals(\"user_id\")(postInput.user_id)(post.user_id);\n  TestValidator.equals(\"category_id\")(postInput.category_id)(post.category_id);\n  TestValidator.equals(\"title\")(postInput.title)(post.title);\n  TestValidator.equals(\"content\")(postInput.content)(post.content);\n  // Validate id, created_at, updated_at assigned\n  TestValidator.predicate(\"id must be uuid\")(() => typeof post.id === \"string\" && post.id.length > 0);\n  TestValidator.predicate(\"created_at must exist\")(() => typeof post.created_at === \"string\" && post.created_at.length > 0);\n  TestValidator.predicate(\"updated_at must exist\")(() => typeof post.updated_at === \"string\" && post.updated_at.length > 0);\n}\n",
    "completed": 30,
    "total": 59,
    "step": 0,
    "scenario": {
      "method": "post",
      "path": "/posts/posts",
      "draft": "Create a valid new post with all required fields (title, author, category, content). Verify post is persisted by immediately retrieving the created post.",
      "functionName": "test_create_post_with_valid_data",
      "dependsOn": [
        {
          "method": "post",
          "path": "/core/users",
          "purpose": "Create a user to act as the author."
        },
        {
          "method": "post",
          "path": "/core/categories",
          "purpose": "Create a category for the new post."
        }
      ]
    }
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-24T04:34:11.053Z",
    "filename": "post/test_create_post_with_missing_required_fields.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\n\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport { ICategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/ICategory\";\nimport { IPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPost\";\n\nexport async function test_create_post_with_missing_required_fields(connection: api.IConnection): Promise<void> {\n  // 1. Prerequisite: create a valid user\n  const userInput: IUser.ICreate = {\n    user_role_id: \"d7f0c57a-6b76-4fde-b2c7-4e652a34b68e\", // Example UUID; adjust if needed\n    username: `testuser_${Math.random().toString(36).substring(2, 10)}`,\n    email: `testuser_${Date.now()}@example.com`,\n    password: \"secureP@ssword1\",\n    status: \"active\"\n  };\n  const user: IUser = await api.functional.core.users.post(connection, { body: userInput });\n  typia.assert<IUser>(user);\n\n  // 2. Prerequisite: create a valid category\n  const categoryInput: ICategory.ICreate = {\n    name: `TestCategory_${Math.random().toString(36).substring(2, 10)}`,\n    description: \"Test category for validation.\"\n  };\n  const category: ICategory = await api.functional.core.categories.post(connection, { body: categoryInput });\n  typia.assert<ICategory>(category);\n\n  // 3. Attempt to create a post missing the 'title' field\n  const postMissingTitle: Partial<IPost.ICreate> = {\n    category_id: category.id,\n    content: \"Post without a title should fail.\",\n    user_id: user.id\n  };\n  await TestValidator.httpError(\"Missing title should fail\")(400, 422)(\n    () =>\n      api.functional.posts.posts.post(connection, {\n        body: postMissingTitle as IPost.ICreate,\n      })\n  );\n\n  // 4. Attempt to create a post missing the 'user_id' (author) field\n  const postMissingUser: Partial<IPost.ICreate> = {\n    category_id: category.id,\n    title: \"Title Exists\",\n    content: \"Post without user_id should fail.\"\n    // user_id omitted\n  };\n  await TestValidator.httpError(\"Missing user_id should fail\")(400, 422)(\n    () =>\n      api.functional.posts.posts.post(connection, {\n        body: postMissingUser as IPost.ICreate,\n      })\n  );\n}\n",
    "completed": 12,
    "total": 59,
    "step": 0,
    "scenario": {
      "method": "post",
      "path": "/posts/posts",
      "draft": "Attempt to create a post with missing required fields (e.g., no title or author) to ensure validation errors are returned.",
      "functionName": "test_create_post_with_missing_required_fields",
      "dependsOn": [
        {
          "method": "post",
          "path": "/core/users",
          "purpose": "Ensure a user is present for validation."
        },
        {
          "method": "post",
          "path": "/core/categories",
          "purpose": "Ensure a category is present for validation."
        }
      ]
    }
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-24T04:34:11.053Z",
    "filename": "post/test_create_post_with_duplicate_unique_field.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport { ICategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/ICategory\";\nimport { IPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPost\";\nimport typia from \"typia\";\n\nexport async function test_create_post_with_duplicate_unique_field(connection: api.IConnection): Promise<void> {\n  // 1. Register a user\n  const userInput: IUser.ICreate = {\n    user_role_id: \"11111111-1111-1111-1111-111111111111\", // should be valid role\n    username: `dupe_test_user_${Math.random().toString(36).substring(2, 10)}`,\n    email: `dupe_post${Math.random().toString(36).substring(2, 10)}@test.com`,\n    bio: \"Duplicate post uniqueness test account\",\n    password: \"Test123!asdfgh\",\n    status: \"active\",\n  };\n  const user: IUser = await api.functional.core.users.post(connection, { body: userInput });\n  typia.assert<IUser>(user);\n\n  // 2. Create a category\n  const categoryInput: ICategory.ICreate = {\n    name: `TestCategory_${Math.random().toString(36).substring(2,7)}`,\n    description: \"Test category for uniqueness check\",\n  };\n  const category: ICategory = await api.functional.core.categories.post(connection, { body: categoryInput });\n  typia.assert<ICategory>(category);\n\n  // 3. Create the initial post\n  const postTitle = `UniqueTitle_${Math.random().toString(36).substring(2,10)}`;\n  const postInput: IPost.ICreate = {\n    category_id: category.id,\n    title: postTitle,\n    content: \"First post initial content\",\n    user_id: user.id,\n  };\n  const firstPost: IPost = await api.functional.posts.posts.post(connection, { body: postInput });\n  typia.assert<IPost>(firstPost);\n  TestValidator.equals(\"First post title should match\")(postInput.title)(firstPost.title);\n\n  // 4. Attempt to create another post with the same title by the same user/category\n  const dupeInput: IPost.ICreate = {\n    category_id: category.id,\n    title: postTitle, // Duplicate title\n    content: \"This should fail due to unique constraint.\",\n    user_id: user.id,\n  };\n  await TestValidator.httpError(\"Should reject duplicate post title\")(400)(async () => {\n    await api.functional.posts.posts.post(connection, { body: dupeInput });\n  });\n}\n",
    "completed": 25,
    "total": 59,
    "step": 0,
    "scenario": {
      "method": "post",
      "path": "/posts/posts",
      "draft": "Try to create multiple posts using the same slug or with a duplicate unique field and confirm that uniqueness constraints are enforced (expect 400 error).",
      "functionName": "test_create_post_with_duplicate_unique_field",
      "dependsOn": [
        {
          "method": "post",
          "path": "/core/users",
          "purpose": "Create a user to author both posts."
        },
        {
          "method": "post",
          "path": "/core/categories",
          "purpose": "Category needed for both test posts."
        }
      ]
    }
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-24T04:34:11.053Z",
    "filename": "post/test_update_post_with_valid_data.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport { ICategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/ICategory\";\nimport { IPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPost\";\n\nexport async function test_update_post_with_valid_data(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. Create user\n  const user: IUser = await api.functional.core.users.post(connection, {\n    body: {\n      user_role_id: typia.random<string>(),\n      username: `user_${Math.random().toString(36).substring(2, 10)}`,\n      email: `user_${Math.random().toString(36).substring(2, 10)}@test.com`,\n      bio: \"Just a test user.\",\n      password: \"TestPassword123!\",\n      status: \"active\",\n    },\n  });\n  typia.assert<IUser>(user);\n\n  // 2. Create category\n  const category: ICategory = await api.functional.core.categories.post(\n    connection,\n    {\n      body: {\n        name: `Category_${Math.random().toString(36).substring(2, 10)}`,\n        description: \"Category for post update test.\",\n      },\n    },\n  );\n  typia.assert<ICategory>(category);\n\n  // 3. Create initial post\n  const post: IPost = await api.functional.posts.posts.post(connection, {\n    body: {\n      category_id: category.id,\n      title: \"Original Post Title\",\n      content: \"Original post content.\",\n      user_id: user.id,\n    },\n  });\n  typia.assert<IPost>(post);\n\n  // 4. Prepare update data\n  const updateInput: IPost.IUpdate = {\n    title: \"Updated Title\",\n    content: \"This is the edited content.\",\n    // Could also test category_id update if wanted:\n    // category_id: category.id\n  };\n\n  // 5. Update the post\n  const updatedPost: IPost = await api.functional.posts.posts.putById(\n    connection,\n    {\n      id: post.id,\n      body: updateInput,\n    },\n  );\n  typia.assert<IPost>(updatedPost);\n\n  // 6. Validate updated fields\n  TestValidator.equals(\"title updated\")(updateInput.title!)(updatedPost.title);\n  TestValidator.equals(\"content updated\")(updateInput.content!)(updatedPost.content);\n\n  // 7. Confirm unchanged fields\n  TestValidator.equals(\"id unchanged\")(post.id)(updatedPost.id);\n  TestValidator.equals(\"user_id unchanged\")(post.user_id)(updatedPost.user_id);\n  TestValidator.equals(\"category_id unchanged\")(post.category_id)(updatedPost.category_id);\n  TestValidator.predicate(\"created_at unchanged\")(() => post.created_at === updatedPost.created_at);\n\n  // 8. Confirm updated_at has changed\n  TestValidator.predicate(\"updated_at changed\")(() => post.updated_at !== updatedPost.updated_at);\n}\n",
    "completed": 38,
    "total": 59,
    "step": 0,
    "scenario": {
      "method": "put",
      "path": "/posts/posts/{id}",
      "draft": "Update a post's content and status. Confirm changes by retrieving the updated post and inspecting the new field values.",
      "functionName": "test_update_post_with_valid_data",
      "dependsOn": [
        {
          "method": "post",
          "path": "/core/users",
          "purpose": "Provide an author for the post."
        },
        {
          "method": "post",
          "path": "/core/categories",
          "purpose": "Provide a category for the post."
        },
        {
          "method": "post",
          "path": "/posts/posts",
          "purpose": "Create the post to be updated."
        }
      ]
    }
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-24T04:34:11.053Z",
    "filename": "post/test_update_post_with_invalid_fields.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport { ICategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/ICategory\";\nimport { IPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPost\";\n\nexport async function test_update_post_with_invalid_fields(connection: api.IConnection): Promise<void> {\n  // 1. Create author\n  const user: IUser = await api.functional.core.users.post(connection, {\n    body: {\n      user_role_id: typia.random<string & tags.Format<\"uuid\">>(),\n      username: `user_${Math.random().toString(36).substring(2,8)}`,\n      email: `test_${Math.random().toString(36).substring(2,8)}@example.com`,\n      password: \"Password123!\",\n      status: \"active\",\n    },\n  });\n  typia.assert<IUser>(user);\n\n  // 2. Create a category\n  const category: ICategory = await api.functional.core.categories.post(connection, {\n    body: {\n      name: `category_${Math.random().toString(36).substring(2,8)}`,\n      description: \"Test category for e2e validation.\"\n    }\n  });\n  typia.assert<ICategory>(category);\n\n  // 3. Create a post\n  const post: IPost = await api.functional.posts.posts.post(connection, {\n    body: {\n      category_id: category.id,\n      title: \"Initial title\",\n      content: \"Initial content.\",\n      user_id: user.id\n    },\n  });\n  typia.assert<IPost>(post);\n\n  // 4a. Update post with empty title (if not allowed)\n  await TestValidator.httpError(\"Put with empty title - should 400\")(400)(async () => {\n    await api.functional.posts.posts.putById(connection, {\n      id: post.id,\n      body: {\n        title: \"\",\n      },\n    });\n  });\n\n  // 4b. Update post with empty content (if not allowed)\n  await TestValidator.httpError(\"Put with empty content - should 400\")(400)(async () => {\n    await api.functional.posts.posts.putById(connection, {\n      id: post.id,\n      body: {\n        content: \"\",\n      },\n    });\n  });\n\n  // 4c. Update post with invalid category_id uuid\n  await TestValidator.httpError(\"Put with invalid category_id - should 400\")(400)(async () => {\n    await api.functional.posts.posts.putById(connection, {\n      id: post.id,\n      body: {\n        category_id: \"not-a-uuid\" as any,\n      },\n    });\n  });\n\n  // 4d. Update post with all fields missing (empty body)\n  await TestValidator.httpError(\"Put with empty body - should 400\")(400)(async () => {\n    await api.functional.posts.posts.putById(connection, {\n      id: post.id,\n      body: {},\n    });\n  });\n\n  // 4e. Positive case: Update with valid title & content\n  const updated: IPost = await api.functional.posts.posts.putById(connection, {\n    id: post.id,\n    body: {\n      title: \"Updated title\",\n      content: \"Updated content.\",\n      category_id: category.id\n    },\n  });\n  typia.assert<IPost>(updated);\n  TestValidator.equals(\"Updated title\")(\"Updated title\")(updated.title);\n  TestValidator.equals(\"Updated content\")(\"Updated content.\")(updated.content);\n  TestValidator.equals(\"Updated category\")(category.id)(updated.category_id);\n}\n",
    "completed": 26,
    "total": 59,
    "step": 0,
    "scenario": {
      "method": "put",
      "path": "/posts/posts/{id}",
      "draft": "Test updating a post with missing or invalid fields (e.g., empty content, wrong status) and confirm that validation errors or 400 errors are produced.",
      "functionName": "test_update_post_with_invalid_fields",
      "dependsOn": [
        {
          "method": "post",
          "path": "/core/users",
          "purpose": "Set up validation context with an author."
        },
        {
          "method": "post",
          "path": "/core/categories",
          "purpose": "Set up a category for the post."
        },
        {
          "method": "post",
          "path": "/posts/posts",
          "purpose": "Create post for validation testing."
        }
      ]
    }
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-24T04:34:11.053Z",
    "filename": "post/test_update_post_with_non_existent_id.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\nimport { IPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPost\";\n\nexport async function test_update_post_with_non_existent_id(connection: api.IConnection): Promise<void> {\n  // Generate a non-existent post ID (random UUID)\n  const nonExistentId: string & tags.Format<\"uuid\"> = typia.random<string & tags.Format<\"uuid\">>();\n\n  // Prepare a valid update body\n  const updateBody: IPost.IUpdate = {\n    title: \"This title should not update any post\",\n    content: \"Trying to update a post that doesn't exist.\",\n  };\n\n  // Expect 404 Not Found when trying to update a non-existent post\n  await TestValidator.httpError(\"Should return 404 when updating non-existent post\")(404)(\n    () => api.functional.posts.posts.putById(connection, {\n      id: nonExistentId,\n      body: updateBody,\n    })\n  );\n}\n",
    "completed": 9,
    "total": 59,
    "step": 0,
    "scenario": {
      "method": "put",
      "path": "/posts/posts/{id}",
      "draft": "Attempt to update a post with a non-existent post ID and expect a 404 error.",
      "functionName": "test_update_post_with_non_existent_id",
      "dependsOn": []
    }
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-24T04:34:11.053Z",
    "filename": "post/test_delete_post_and_verify_deletion.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport { ICategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/ICategory\";\nimport { IPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPost\";\nimport typia from \"typia\";\n\nexport async function test_delete_post_and_verify_deletion(connection: api.IConnection): Promise<void> {\n  // 1. Create a user (author of the post)\n  const userInput: IUser.ICreate = {\n    user_role_id: typia.random<string>(),\n    username: `testuser_${Date.now()}`,\n    email: `test_${Date.now()}@test.com`,\n    password: \"TestPassword123!\",\n    status: \"active\"\n  };\n  const user: IUser = await api.functional.core.users.post(connection, { body: userInput });\n  typia.assert(user);\n\n  // 2. Create a category\n  const categoryInput: ICategory.ICreate = {\n    name: `test_category_${Date.now()}`,\n    description: \"Category for post deletion test\"\n  };\n  const category: ICategory = await api.functional.core.categories.post(connection, { body: categoryInput });\n  typia.assert(category);\n\n  // 3. Create a post\n  const postInput: IPost.ICreate = {\n    category_id: category.id,\n    title: `Test Post ${Date.now()}`,\n    content: \"This post will be deleted.\",\n    user_id: user.id\n  };\n  const post: IPost = await api.functional.posts.posts.post(connection, { body: postInput });\n  typia.assert(post);\n\n  // 4. Delete the post\n  const delResult: IPost.IDeleteResult = await api.functional.posts.posts.eraseById(connection, { id: post.id });\n  typia.assert(delResult);\n  TestValidator.predicate(\"Delete response success\")(() => delResult.success === true);\n\n  // 5. Try to fetch the deleted post (API for GET /posts/posts/{id} not available)\n  // Note: If a GET-by-ID API is provided in the future, test an error (404) here.\n  // Example:\n  // await TestValidator.httpError(\"Should not access deleted post\")(404)(\n  //   () => api.functional.posts.posts.getById(connection, { id: post.id })\n  // );\n}\n",
    "completed": 21,
    "total": 59,
    "step": 0,
    "scenario": {
      "method": "delete",
      "path": "/posts/posts/{id}",
      "draft": "Delete an existing post and check that it is no longer accessible (expect 404 on retrieval).",
      "functionName": "test_delete_post_and_verify_deletion",
      "dependsOn": [
        {
          "method": "post",
          "path": "/core/users",
          "purpose": "Author is required to create post."
        },
        {
          "method": "post",
          "path": "/core/categories",
          "purpose": "Category needed for post creation."
        },
        {
          "method": "post",
          "path": "/posts/posts",
          "purpose": "Create the post to be deleted."
        }
      ]
    }
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-24T04:34:11.053Z",
    "filename": "post/test_delete_post_with_non_existent_id.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\n/**\n * Attempts to delete a post with a non-existent ID and expects a 404 Not Found error.\n */\nexport async function test_delete_post_with_non_existent_id(connection: api.IConnection): Promise<void> {\n    const nonExistentId: string & tags.Format<\"uuid\"> = typia.random<string & tags.Format<\"uuid\">>();\n\n    await TestValidator.httpError(\"Must fail with 404 for non-existent post deletion\")(404)(async () => {\n        await api.functional.posts.posts.eraseById(connection, { id: nonExistentId });\n    });\n}\n",
    "completed": 8,
    "total": 59,
    "step": 0,
    "scenario": {
      "method": "delete",
      "path": "/posts/posts/{id}",
      "draft": "Attempt to delete a post using a non-existent ID and ensure the API returns a 404.",
      "functionName": "test_delete_post_with_non_existent_id",
      "dependsOn": []
    }
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-24T04:34:11.053Z",
    "filename": "comment/test_list_comments_with_pagination_and_filters.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport { IPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPost\";\nimport { IComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IComment\";\nimport { IPageIComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIComment\";\nimport typia from \"typia\";\n\nexport async function test_list_comments_with_pagination_and_filters(connection: api.IConnection): Promise<void> {\n  // 1. Create two users\n  const user1: IUser = await api.functional.core.users.post(connection, {\n    body: {\n      user_role_id: \"00000000-0000-0000-0000-000000000001\",\n      username: `commenter_one_${Date.now()}`,\n      email: `commenterone_${Date.now()}@test.com`,\n      bio: \"test user one\",\n      password: \"testpw1\",\n      status: \"active\"\n    },\n  });\n  const user2: IUser = await api.functional.core.users.post(connection, {\n    body: {\n      user_role_id: \"00000000-0000-0000-0000-000000000001\",\n      username: `commenter_two_${Date.now()}`,\n      email: `commentertwo_${Date.now()}@test.com`,\n      bio: \"test user two\",\n      password: \"testpw2\",\n      status: \"active\"\n    },\n  });\n\n  // 2. Create two posts by user1\n  const post1: IPost = await api.functional.posts.posts.post(connection, {\n    body: {\n      category_id: \"00000000-0000-0000-0000-00000000c001\",\n      title: `Post One - ${Date.now()}`,\n      content: \"First post content\",\n      user_id: user1.id,\n    }\n  });\n  const post2: IPost = await api.functional.posts.posts.post(connection, {\n    body: {\n      category_id: \"00000000-0000-0000-0000-00000000c002\",\n      title: `Post Two - ${Date.now()}`,\n      content: \"Second post content\",\n      user_id: user1.id,\n    }\n  });\n\n  // 3. Create comments for both posts, alternating users\n  const comments: IComment[] = [];\n  // Post1: 2 for each user\n  comments.push(\n    await api.functional.posts.comments.post(connection, {\n      body: { user_id: user1.id, post_id: post1.id, content: `C1-u1-${Date.now()}` },\n    })\n  );\n  comments.push(\n    await api.functional.posts.comments.post(connection, {\n      body: { user_id: user2.id, post_id: post1.id, content: `C2-u2-${Date.now()}` },\n    })\n  );\n  comments.push(\n    await api.functional.posts.comments.post(connection, {\n      body: { user_id: user1.id, post_id: post1.id, content: `C3-u1-${Date.now()}` },\n    })\n  );\n  comments.push(\n    await api.functional.posts.comments.post(connection, {\n      body: { user_id: user2.id, post_id: post1.id, content: `C4-u2-${Date.now()}` },\n    })\n  );\n  // Post2: 2 for user1, 1 for user2\n  comments.push(\n    await api.functional.posts.comments.post(connection, {\n      body: { user_id: user1.id, post_id: post2.id, content: `P2-C1-u1-${Date.now()}` },\n    })\n  );\n  comments.push(\n    await api.functional.posts.comments.post(connection, {\n      body: { user_id: user2.id, post_id: post2.id, content: `P2-C2-u2-${Date.now()}` },\n    })\n  );\n  comments.push(\n    await api.functional.posts.comments.post(connection, {\n      body: { user_id: user1.id, post_id: post2.id, content: `P2-C3-u1-${Date.now()}` },\n    })\n  );\n\n  // Helper\n  function isDesc<T extends { created_at: string }>(arr: T[]): boolean {\n    for (let i = 1; i < arr.length; ++i)\n      if (arr[i - 1].created_at < arr[i].created_at) return false;\n    return true;\n  }\n\n  // 4. Retrieve comments for post1\n  const out1: IPageIComment = await api.functional.posts.comments.patch(connection, {\n    body: { postId: post1.id },\n  });\n  typia.assert<IPageIComment>(out1);\n  TestValidator.predicate(\"all comments belong to post1\")(() => out1.data.every(c => c.post_id === post1.id));\n  TestValidator.predicate(\"pagination count matches data length\")(() => out1.data.length <= out1.pagination.limit);\n\n  // 5. Retrieve comments for post1 by user2\n  const out2: IPageIComment = await api.functional.posts.comments.patch(connection, {\n    body: { postId: post1.id, userId: user2.id },\n  });\n  typia.assert<IPageIComment>(out2);\n  TestValidator.predicate(\"out2: all are user2 on post1\")(() => out2.data.every(c => c.post_id === post1.id && c.user_id === user2.id));\n\n  // 6. Retrieve all comments by user1\n  const out3: IPageIComment = await api.functional.posts.comments.patch(connection, {\n    body: { userId: user1.id },\n  });\n  typia.assert<IPageIComment>(out3);\n  TestValidator.predicate(\"out3: all are by user1\")(() => out3.data.every(c => c.user_id === user1.id));\n\n  // 7. Pagination on post2\n  const out4a: IPageIComment = await api.functional.posts.comments.patch(connection, {\n    body: { postId: post2.id, limit: 2, offset: 0 },\n  });\n  typia.assert<IPageIComment>(out4a);\n  TestValidator.predicate(\"out4a: two comments for post2\")(() => out4a.data.length === 2);\n  const out4b: IPageIComment = await api.functional.posts.comments.patch(connection, {\n    body: { postId: post2.id, limit: 2, offset: 2 },\n  });\n  typia.assert<IPageIComment>(out4b);\n  TestValidator.predicate(\"out4b: remaining comments for post2\")(() => out4b.data.length <= 2);\n  const collectedIds = [...out4a.data.map(c => c.id), ...out4b.data.map(c => c.id)];\n  TestValidator.predicate(\"out4 no duplicated IDs\")(() => new Set(collectedIds).size === collectedIds.length);\n\n  // 8. Sorting by created_at desc for post1\n  const out5: IPageIComment = await api.functional.posts.comments.patch(connection, {\n    body: { postId: post1.id, sort: \"created_at:desc\" },\n  });\n  typia.assert<IPageIComment>(out5);\n  TestValidator.predicate(\"out5: sorted desc by created_at\")(() => isDesc(out5.data));\n\n  // 9. Negative case: non-existent postId\n  const out6: IPageIComment = await api.functional.posts.comments.patch(connection, {\n    body: { postId: \"ffffffff-ffff-ffff-ffff-ffffffffffff\" },\n  });\n  typia.assert<IPageIComment>(out6);\n  TestValidator.predicate(\"out6: data empty for non-existing post\")(() => Array.isArray(out6.data) && out6.data.length === 0);\n  TestValidator.equals(\"out6: records=0 for non-existing post\")({ records: 0 })( { records: out6.pagination.records } );\n}\n",
    "completed": 59,
    "total": 59,
    "step": 0,
    "scenario": {
      "method": "patch",
      "path": "/posts/comments",
      "draft": "Retrieve a filtered, paginated list of comments. Verify that pagination, filtering by post, or commenter, and sorting work as expected.",
      "functionName": "test_list_comments_with_pagination_and_filters",
      "dependsOn": [
        {
          "method": "post",
          "path": "/core/users",
          "purpose": "Create users as commenters."
        },
        {
          "method": "post",
          "path": "/posts/posts",
          "purpose": "Create posts with comments."
        },
        {
          "method": "post",
          "path": "/posts/comments",
          "purpose": "Create multiple comments on these posts for listing tests."
        }
      ]
    }
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-24T04:34:11.053Z",
    "filename": "comment/test_get_comment_by_valid_id.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport { IPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPost\";\nimport { IComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IComment\";\nimport typia from \"typia\";\n\nexport async function test_get_comment_by_valid_id(connection: api.IConnection): Promise<void> {\n  // 1. Create a new user (comment author)\n  const userInput: IUser.ICreate = {\n    user_role_id: typia.random<string>(), // Assume role exists in test db\n    username: `e2e_commenter_${Math.random().toString(36).substring(2)}`,\n    email: `test_commenter_${Date.now()}@example.com`,\n    password: \"Test1234!\",\n    status: \"active\",\n    bio: \"Test commenter for comment retrieval\"\n  };\n  const user: IUser = await api.functional.core.users.post(connection, { body: userInput });\n  typia.assert<IUser>(user);\n\n  // 2. Create a post for the above user\n  const postInput: IPost.ICreate = {\n    category_id: typia.random<string>(), // No category API provided; assume exists for E2E\n    title: \"Comment E2E: Post for Comment Detail Test\",\n    content: \"Post content to be used in comment detail test.\",\n    user_id: user.id\n  };\n  const post: IPost = await api.functional.posts.posts.post(connection, { body: postInput });\n  typia.assert<IPost>(post);\n\n  // 3. Create a comment on that post\n  const commentInput: IComment.ICreate = {\n    user_id: user.id,\n    post_id: post.id,\n    content: \"This is a comment for the detail retrieval test.\",\n  };\n  const comment: IComment = await api.functional.posts.comments.post(connection, { body: commentInput });\n  typia.assert<IComment>(comment);\n\n  // 4. Fetch the newly-created comment by its ID\n  const fetched: IComment = await api.functional.posts.comments.getById(connection, { id: comment.id });\n  typia.assert<IComment>(fetched);\n\n  // 5. Validate all important fields match\n  TestValidator.equals(\"comment.id\")(comment.id)(fetched.id);\n  TestValidator.equals(\"comment.content\")(comment.content)(fetched.content);\n  TestValidator.equals(\"comment.user_id\")(comment.user_id)(fetched.user_id);\n  TestValidator.equals(\"comment.post_id\")(comment.post_id)(fetched.post_id);\n  TestValidator.equals(\"created_at type\")(typeof fetched.created_at)(\"string\");\n\n  // 6. Edge/null checks\n  if (typeof comment.parent_id !== \"undefined\") {\n    TestValidator.equals(\"parent_id\")(comment.parent_id)(fetched.parent_id);\n  } else {\n    TestValidator.equals(\"parent_id is undefined or null\")(comment.parent_id ?? null)(fetched.parent_id ?? null);\n  }\n  if (typeof comment.deleted_at !== \"undefined\") {\n    TestValidator.equals(\"deleted_at\")(comment.deleted_at)(fetched.deleted_at);\n  } else {\n    TestValidator.equals(\"deleted_at is undefined or null\")(comment.deleted_at ?? null)(fetched.deleted_at ?? null);\n  }\n}\n",
    "completed": 51,
    "total": 59,
    "step": 0,
    "scenario": {
      "method": "get",
      "path": "/posts/comments/{id}",
      "draft": "Fetch details for a valid comment ID and verify response fields match expected content and related post info.",
      "functionName": "test_get_comment_by_valid_id",
      "dependsOn": [
        {
          "method": "post",
          "path": "/core/users",
          "purpose": "Commenter must exist for the test."
        },
        {
          "method": "post",
          "path": "/posts/posts",
          "purpose": "Need a post to comment on."
        },
        {
          "method": "post",
          "path": "/posts/comments",
          "purpose": "Create a comment to fetch."
        }
      ]
    }
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-24T04:34:11.053Z",
    "filename": "comment/test_get_comment_with_non_existent_id.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { tags } from \"typia\";\n\nexport async function test_get_comment_with_non_existent_id(connection: api.IConnection): Promise<void> {\n  // Use a hardcoded UUID, unlikely to exist in the DB\n  const nonExistentId: string & tags.Format<\"uuid\"> = \"00000000-0000-4000-8000-000000000000\";\n\n  // Attempt to fetch comment and expect a 404 Not Found\n  await TestValidator.httpError(\"Should fail for non-existent comment\")(404)(async () => {\n    await api.functional.posts.comments.getById(connection, { id: nonExistentId });\n  });\n}\n",
    "completed": 7,
    "total": 59,
    "step": 0,
    "scenario": {
      "method": "get",
      "path": "/posts/comments/{id}",
      "draft": "Attempt to get a comment with an invalid or non-existent ID and expect a 404 Not Found error.",
      "functionName": "test_get_comment_with_non_existent_id",
      "dependsOn": []
    }
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-24T04:34:11.053Z",
    "filename": "comment/test_create_comment_with_valid_data.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport { IPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPost\";\nimport { IComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IComment\";\nimport typia from \"typia\";\n\nexport async function test_create_comment_with_valid_data(\n  connection: api.IConnection,\n): Promise<void> {\n  // Step 1: Create a user (commenter)\n  const userInput: IUser.ICreate = {\n    user_role_id: \"00000000-0000-0000-0000-000000000001\", // example role\n    username: `user_${Math.random().toString(36).substring(2, 8)}`,\n    email: `test_${Math.random().toString(36).substring(2, 8)}@example.com`,\n    bio: \"Test user for comment creation.\",\n    password: \"P@ssw0rd!123\",\n    status: \"active\",\n  };\n  const user: IUser = await api.functional.core.users.post(connection, { body: userInput });\n  typia.assert<IUser>(user);\n\n  // Step 2: Create a post by this user\n  const postInput: IPost.ICreate = {\n    category_id: \"00000000-0000-0000-0000-000000000101\", // stub category, should exist\n    title: \"Test post for comment creation\",\n    content: \"This is a test post content for comment E2E test.\",\n    user_id: user.id,\n  };\n  const post: IPost = await api.functional.posts.posts.post(connection, {\n    body: postInput,\n  });\n  typia.assert<IPost>(post);\n\n  // Step 3: Create a comment by the user on the created post\n  const commentInput: IComment.ICreate = {\n    user_id: user.id,\n    post_id: post.id,\n    content: \"This is a test comment for E2E validation.\",\n  };\n  const comment: IComment = await api.functional.posts.comments.post(connection, {\n    body: commentInput,\n  });\n  typia.assert<IComment>(comment);\n\n  // Step 4: Assert returned data matches the creation input\n  TestValidator.equals(\"comment user_id\")(commentInput.user_id)(comment.user_id);\n  TestValidator.equals(\"comment post_id\")(commentInput.post_id)(comment.post_id);\n  TestValidator.equals(\"comment content\")(commentInput.content)(comment.content);\n  // ensure required fields\n  TestValidator.predicate(\"comment id is uuid\")(() => typeof comment.id === \"string\" && comment.id.length >= 32);\n  TestValidator.predicate(\"comment created_at present\")(() => typeof comment.created_at === \"string\" && comment.created_at.length > 0);\n}\n",
    "completed": 24,
    "total": 59,
    "step": 0,
    "scenario": {
      "method": "post",
      "path": "/posts/comments",
      "draft": "Create a new comment on an existing post by an existing user. Afterwards, fetch and verify comment's persistence and correctness.",
      "functionName": "test_create_comment_with_valid_data",
      "dependsOn": [
        {
          "method": "post",
          "path": "/core/users",
          "purpose": "Create user as commenter."
        },
        {
          "method": "post",
          "path": "/posts/posts",
          "purpose": "Create the post to comment on."
        }
      ]
    }
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-24T04:34:11.053Z",
    "filename": "comment/test_create_comment_with_missing_required_fields.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\n\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport { IPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPost\";\nimport { IComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IComment\";\n\nexport async function test_create_comment_with_missing_required_fields(connection: api.IConnection): Promise<void> {\n  // Step 1: Create valid user (comment author)\n  const user: IUser = await api.functional.core.users.post(connection, {\n    body: {\n      user_role_id: typia.random<IUser.ICreate>().user_role_id, // must be a valid role\n      username: `commenter_${Math.random().toString(36).substring(2, 10)}`,\n      email: `commenter_${Math.random().toString(36).substring(2, 10)}@test.com`,\n      password: \"StrongPa33w0rd!\",\n      status: \"active\",\n      bio: \"Test comment author\"\n    },\n  });\n  typia.assert<IUser>(user);\n\n  // Step 2: Create valid post (so that post_id exists)\n  const post: IPost = await api.functional.posts.posts.post(connection, {\n    body: {\n      category_id: typia.random<IPost.ICreate>().category_id, // just pick a random category uuid\n      title: \"Unit Test Post for Missing Comment Fields\",\n      content: \"This post is used for negative comment test cases.\",\n      user_id: user.id,\n    },\n  });\n  typia.assert<IPost>(post);\n\n  // Step 3: Prepare invalid request bodies missing various required fields\n  const makeValidCommentInput = (): IComment.ICreate => ({\n    user_id: user.id,\n    post_id: post.id,\n    content: \"This is a valid comment.\"\n  });\n\n  const invalidBodies: { title: string; body: Partial<IComment.ICreate> }[] = [\n    {\n      title: \"missing content\",\n      body: {\n        user_id: user.id,\n        post_id: post.id,\n        // content: missing\n      },\n    },\n    {\n      title: \"missing post_id\",\n      body: {\n        user_id: user.id,\n        content: \"Missing post ID!\",\n        // post_id: missing\n      },\n    },\n    {\n      title: \"missing user_id\",\n      body: {\n        post_id: post.id,\n        content: \"Missing user ID!\",\n        // user_id: missing\n      },\n    },\n    {\n      title: \"missing all required fields\",\n      body: {\n        // user_id: missing\n        // post_id: missing\n        // content: missing\n      },\n    },\n  ];\n\n  // Step 4: For each invalid input, test that API returns 400 Bad Request (validation error)\n  for (const testCase of invalidBodies) {\n    await TestValidator.httpError(`should fail with 400 when ${testCase.title}`)(400)(async () =>\n      api.functional.posts.comments.post(connection, {\n        // as any => let the API handler trigger validation error\n        body: testCase.body as any\n      })\n    );\n  }\n\n  // Step 5: Positive control - ensure normal creation works\n  const validInput = makeValidCommentInput();\n  const created: IComment = await api.functional.posts.comments.post(connection, {\n    body: validInput,\n  });\n  typia.assert<IComment>(created);\n  TestValidator.equals(\"correctly created comment\")(\n    validInput.content\n  )(created.content);\n  TestValidator.equals(\"correctly associated to post\")(\n    validInput.post_id\n  )(created.post_id);\n  TestValidator.equals(\"correctly associated user\")(\n    validInput.user_id\n  )(created.user_id);\n}\n",
    "completed": 39,
    "total": 59,
    "step": 0,
    "scenario": {
      "method": "post",
      "path": "/posts/comments",
      "draft": "Try creating a comment with missing required fields (e.g., no content, no postId) and check for appropriate validation errors or 400 Bad Request responses.",
      "functionName": "test_create_comment_with_missing_required_fields",
      "dependsOn": [
        {
          "method": "post",
          "path": "/core/users",
          "purpose": "Ensure user entity exists as commenter."
        },
        {
          "method": "post",
          "path": "/posts/posts",
          "purpose": "Post entity must be present for association."
        }
      ]
    }
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-24T04:34:11.053Z",
    "filename": "comment/test_create_comment_with_non_existent_post.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport { IComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IComment\";\nimport typia from \"typia\";\n\nexport async function test_create_comment_with_non_existent_post(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. Register a valid user\n  const user: IUser = await api.functional.core.users.post(connection, {\n    body: typia.random<IUser.ICreate>(),\n  });\n  \n  // 2. Use a clearly fake/non-existent post UUID\n  const NON_EXISTENT_POST_ID = \"11111111-1111-1111-1111-111111111111\";\n\n  // 3. Construct an invalid comment creation payload\n  const commentInput: IComment.ICreate = {\n    user_id: user.id,\n    post_id: NON_EXISTENT_POST_ID,\n    content: \"This should not succeed.\",\n  };\n\n  // 4 & 5. Attempt to create the comment, expect error (400/404)\n  await TestValidator.httpError(\"Should be 400 or 404 for non-existent post\")\n    (400, 404)(\n      () => api.functional.posts.comments.post(connection, { body: commentInput })\n    );\n}\n",
    "completed": 27,
    "total": 59,
    "step": 0,
    "scenario": {
      "method": "post",
      "path": "/posts/comments",
      "draft": "Attempt to comment on a post that does not exist; expect a 400 or 404 error for foreign key violation.",
      "functionName": "test_create_comment_with_non_existent_post",
      "dependsOn": [
        {
          "method": "post",
          "path": "/core/users",
          "purpose": "Set up a valid user for the test."
        }
      ]
    }
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-24T04:34:11.053Z",
    "filename": "comment/test_update_comment_with_valid_data.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport { IPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPost\";\nimport { IComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IComment\";\nimport typia from \"typia\";\n\n/**\n * Update an existing comment's content and verify the update.\n */\nexport async function test_update_comment_with_valid_data(connection: api.IConnection): Promise<void> {\n  // 1. Create a role ID for user creation.\n  // (For test, use random UUID as role_id, must exist in test DB or be adjusted as required)\n  const userRoleId: string = typia.random<IUser[\"user_role_id\"]>();\n\n  // 2. Create user\n  const userInput: IUser.ICreate = {\n    user_role_id: userRoleId,\n    username: `testuser_${Date.now()}`,\n    email: `user_${Date.now()}@example.com`,\n    bio: \"Test user for comment update\",\n    password: \"securePassword123!\",\n    status: \"active\",\n  };\n  const user: IUser = await api.functional.core.users.post(connection, { body: userInput });\n  typia.assert<IUser>(user);\n\n  // 3. Create post owned by test user (Provide actual category_id required by your system)\n  const categoryId: string = typia.random<IPost[\"category_id\"]>();\n  const postInput: IPost.ICreate = {\n    category_id: categoryId,\n    title: `Test post for comment update ${Date.now()}`,\n    content: \"Initial test post content.\",\n    user_id: user.id,\n  };\n  const post: IPost = await api.functional.posts.posts.post(connection, { body: postInput });\n  typia.assert<IPost>(post);\n\n  // 4. Create comment on the post by test user\n  const commentInput: IComment.ICreate = {\n    user_id: user.id,\n    post_id: post.id,\n    content: \"Original comment content.\",\n  };\n  const comment: IComment = await api.functional.posts.comments.post(connection, { body: commentInput });\n  typia.assert<IComment>(comment);\n\n  // 5. Prepare new content for update\n  const newContent = `Updated comment content at ${Date.now()}`;\n  const commentUpdate: IComment.IUpdate = {\n    content: newContent,\n  };\n\n  // 6. Update comment by id\n  const updated: IComment = await api.functional.posts.comments.putById(connection, {\n    id: comment.id,\n    body: commentUpdate,\n  });\n  typia.assert<IComment>(updated);\n\n  // 7. Validations\n  // a. The ID must match\n  TestValidator.equals(\"Comment ID should match.\")(comment.id)(updated.id);\n  // b. Content must be updated\n  TestValidator.equals(\"Content should be updated.\")(newContent)(updated.content);\n  // c. The user_id and post_id remain the same\n  TestValidator.equals(\"User ID should remain unchanged.\")(comment.user_id)(updated.user_id);\n  TestValidator.equals(\"Post ID should remain unchanged.\")(comment.post_id)(updated.post_id);\n  // d. Parent_id stays the same\n  TestValidator.equals(\"Parent ID should remain unchanged.\")(comment.parent_id ?? null)(updated.parent_id ?? null);\n\n  // e. created_at doesn't change\n  TestValidator.equals(\"Created time should remain unchanged.\")(comment.created_at)(updated.created_at);\n\n  // f. updated_at changes\n  TestValidator.predicate(\"Update time should be newer.\")(() =>\n    new Date(updated.updated_at).getTime() >= new Date(comment.updated_at).getTime()\n  );\n}\n",
    "completed": 54,
    "total": 59,
    "step": 0,
    "scenario": {
      "method": "put",
      "path": "/posts/comments/{id}",
      "draft": "Update an existing comment's content. Confirm that the new content appears after the update by fetching the comment.",
      "functionName": "test_update_comment_with_valid_data",
      "dependsOn": [
        {
          "method": "post",
          "path": "/core/users",
          "purpose": "Set up a user to make the comment."
        },
        {
          "method": "post",
          "path": "/posts/posts",
          "purpose": "Prepare a post for associating the comment."
        },
        {
          "method": "post",
          "path": "/posts/comments",
          "purpose": "Create the comment to update."
        }
      ]
    }
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-24T04:34:11.053Z",
    "filename": "comment/test_update_comment_with_invalid_fields.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport { IPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPost\";\nimport { IComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IComment\";\n\n// Attempts to update a comment with invalid/missing fields,\n// and validates that appropriate validation errors are returned.\nexport async function test_update_comment_with_invalid_fields(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. Register a new user\n  const user: IUser = await api.functional.core.users.post(connection, {\n    body: {\n      user_role_id: typia.random<string & tags.Format<\"uuid\">>(),\n      username: `e2e_comment_user_${Date.now()}`,\n      email: `comment_test_${Date.now()}@example.com`,\n      password: \"TestPassword1!\",\n      status: \"active\",\n    },\n  });\n  typia.assert<IUser>(user);\n\n  // 2. Create a post\n  const post: IPost = await api.functional.posts.posts.post(connection, {\n    body: {\n      category_id: typia.random<string & tags.Format<\"uuid\">>(),\n      title: \"Test comment validation post\",\n      content: \"Test post body.\",\n      user_id: user.id,\n    },\n  });\n  typia.assert<IPost>(post);\n\n  // 3. Create a comment\n  const comment: IComment = await api.functional.posts.comments.post(\n    connection,\n    {\n      body: {\n        user_id: user.id,\n        post_id: post.id,\n        content: \"A valid comment before attempting invalid update.\",\n      },\n    },\n  );\n  typia.assert<IComment>(comment);\n\n  // 4. Attempt to update with empty content (should fail validation)\n  await TestValidator.httpError(\"update comment: empty content should fail\")(400)(async () =>\n    api.functional.posts.comments.putById(connection, {\n      id: comment.id,\n      body: {\n        content: \"\",\n      },\n    })\n  );\n\n  // 5. Attempt to update with missing content entirely (should fail validation)\n  await TestValidator.httpError(\"update comment: missing content should fail\")(400)(async () =>\n    api.functional.posts.comments.putById(connection, {\n      id: comment.id,\n      body: {},\n    })\n  );\n}\n",
    "completed": 41,
    "total": 59,
    "step": 0,
    "scenario": {
      "method": "put",
      "path": "/posts/comments/{id}",
      "draft": "Attempt to update a comment with missing/invalid fields (e.g., empty content) and check for validation errors.",
      "functionName": "test_update_comment_with_invalid_fields",
      "dependsOn": [
        {
          "method": "post",
          "path": "/core/users",
          "purpose": "User is needed to make a comment."
        },
        {
          "method": "post",
          "path": "/posts/posts",
          "purpose": "A post must exist to comment on."
        },
        {
          "method": "post",
          "path": "/posts/comments",
          "purpose": "Create the comment for validation check."
        }
      ]
    }
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-24T04:34:11.053Z",
    "filename": "comment/test_update_comment_with_non_existent_id.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\nimport { IComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IComment\";\n\nexport async function test_update_comment_with_non_existent_id(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. Generate a random non-existent ID (UUID format)\n  const nonExistentId: string & tags.Format<\"uuid\"> = typia.random<string & tags.Format<\"uuid\">>();\n\n  // 2. Prepare a valid update object\n  const updateBody: IComment.IUpdate = {\n    content: \"Updated content for non-existent comment\",\n  };\n\n  // 3. Attempt to update, expect HTTP 404 error\n  await TestValidator.httpError(\"Update with non-existent comment ID should return 404\")(404)(() =>\n    api.functional.posts.comments.putById(connection, {\n      id: nonExistentId,\n      body: updateBody,\n    })\n  );\n}\n",
    "completed": 11,
    "total": 59,
    "step": 0,
    "scenario": {
      "method": "put",
      "path": "/posts/comments/{id}",
      "draft": "Try to update a comment with a non-existent ID and expect a 404.",
      "functionName": "test_update_comment_with_non_existent_id",
      "dependsOn": []
    }
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-24T04:34:11.053Z",
    "filename": "comment/test_delete_comment_and_verify_soft_deletion.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport { IPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPost\";\nimport { IComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IComment\";\n\n/**\n * Test: Soft-delete a comment and confirm soft deletion (not hard removal)\n */\nexport async function test_delete_comment_and_verify_soft_deletion(connection: api.IConnection): Promise<void> {\n  // 1. Create a commenter user\n  const user: IUser = await api.functional.core.users.post(connection, {\n    body: typia.random<IUser.ICreate>(),\n  });\n  typia.assert<IUser>(user);\n\n  // 2. Create a post attached to this user\n  const post: IPost = await api.functional.posts.posts.post(connection, {\n    body: {\n      ...typia.random<IPost.ICreate>(),\n      user_id: user.id,\n    },\n  });\n  typia.assert<IPost>(post);\n\n  // 3. Create a comment under the post authored by the user\n  const comment: IComment = await api.functional.posts.comments.post(connection, {\n    body: {\n      ...typia.random<IComment.ICreate>(),\n      user_id: user.id,\n      post_id: post.id,\n    },\n  });\n  typia.assert<IComment>(comment);\n\n  // 4. Soft-delete the comment\n  const deleteResult: IComment.IDeleteResult = await api.functional.posts.comments.eraseById(connection, { id: comment.id });\n  typia.assert<IComment.IDeleteResult>(deleteResult);\n  TestValidator.equals(\"eraseById: deleted true\")<boolean>(true)(deleteResult.deleted);\n  TestValidator.equals(\"eraseById: id matches\")<string>(comment.id)(deleteResult.id);\n\n  // 5. (Optional: If comment fetch-by-ID API exists) Fetch the comment again and check deleted_at is set\n  // (Assume such a GET API exists - if not, this block can be skipped)\n  // try {\n  //   const fetched: IComment = await api.functional.posts.comments.getById(connection, { id: comment.id });\n  //   typia.assert<IComment>(fetched);\n  //   TestValidator.predicate(\"deleted_at is non-null\")(() => !!fetched.deleted_at);\n  //   TestValidator.equals(\"user_id unchanged\")(comment.user_id)(fetched.user_id);\n  //   TestValidator.equals(\"post_id unchanged\")(comment.post_id)(fetched.post_id);\n  //   TestValidator.equals(\"content unchanged\")(comment.content)(fetched.content);\n  // } catch {\n  //   // If API to fetch single soft-deleted comments rejects, skip\n  // }\n\n  // 6. [Edge] Try soft-deleting again and assert error or deleted=true\n  await TestValidator.error(\"double delete returns error or is idempotent\")(\n    async () => {\n      await api.functional.posts.comments.eraseById(connection, { id: comment.id });\n    },\n  );\n}\n",
    "completed": 47,
    "total": 59,
    "step": 0,
    "scenario": {
      "method": "delete",
      "path": "/posts/comments/{id}",
      "draft": "Soft-delete a comment and confirm the comment is marked as deleted but not physically removed; fetch and check status/flag.",
      "functionName": "test_delete_comment_and_verify_soft_deletion",
      "dependsOn": [
        {
          "method": "post",
          "path": "/core/users",
          "purpose": "Prepare a commenter user."
        },
        {
          "method": "post",
          "path": "/posts/posts",
          "purpose": "Post needed to attach comment."
        },
        {
          "method": "post",
          "path": "/posts/comments",
          "purpose": "Comment needed for deletion."
        }
      ]
    }
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-24T04:34:11.053Z",
    "filename": "comment/test_delete_comment_with_non_existent_id.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nexport async function test_delete_comment_with_non_existent_id(\n  connection: api.IConnection,\n): Promise<void> {\n  const nonExistentId: string & tags.Format<\"uuid\"> = typia.random<string & tags.Format<\"uuid\">>();\n  await TestValidator.httpError(\"delete non-existent comment should return 404\")(404)(\n    () => api.functional.posts.comments.eraseById(connection, { id: nonExistentId })\n  );\n}\n",
    "completed": 15,
    "total": 59,
    "step": 0,
    "scenario": {
      "method": "delete",
      "path": "/posts/comments/{id}",
      "draft": "Attempt to delete a comment with a non-existent ID and confirm a 404 error is produced.",
      "functionName": "test_delete_comment_with_non_existent_id",
      "dependsOn": []
    }
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-24T04:34:11.053Z",
    "filename": "vote/test_list_votes_with_pagination_and_filters.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport { IPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPost\";\nimport { IVote } from \"@ORGANIZATION/PROJECT-api/lib/structures/IVote\";\nimport { IPageIVote } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIVote\";\nimport typia from \"typia\";\n\nexport async function test_list_votes_with_pagination_and_filters(connection: api.IConnection): Promise<void> {\n  // 1. Create users\n  const userA: IUser = await api.functional.core.users.post(connection, {\n    body: {\n      user_role_id: typia.random<string>(),\n      username: \"filterUserA_\" + Math.random().toString(36).substring(2, 10),\n      email: `userA_${Math.random().toString(36).substring(2,10)}@test.com`,\n      password: \"passA123!\",\n      status: \"active\",\n    },\n  });\n  const userB: IUser = await api.functional.core.users.post(connection, {\n    body: {\n      user_role_id: userA.user_role_id, // Use same role for both\n      username: \"filterUserB_\" + Math.random().toString(36).substring(2, 10),\n      email: `userB_${Math.random().toString(36).substring(2,10)}@test.com`,\n      password: \"passB123!\",\n      status: \"active\",\n    },\n  });\n\n  // 2. Create posts\n  const post1: IPost = await api.functional.posts.posts.post(connection, {\n    body: {\n      category_id: typia.random<string>(),\n      title: \"Vote Test Post 1\",\n      content: \"Testing vote filtering 1.\",\n      user_id: userA.id,\n    },\n  });\n  const post2: IPost = await api.functional.posts.posts.post(connection, {\n    body: {\n      category_id: post1.category_id,\n      title: \"Vote Test Post 2\",\n      content: \"Testing vote filtering 2.\",\n      user_id: userB.id,\n    },\n  });\n\n  // 3. Cast votes\n  const votes: IVote[] = [];\n  votes.push(\n    await api.functional.votes.votes.post(connection, {\n      body: { user_id: userA.id, value: 1, post_id: post1.id },\n    })\n  );\n  votes.push(\n    await api.functional.votes.votes.post(connection, {\n      body: { user_id: userA.id, value: 1, post_id: post2.id },\n    })\n  );\n  votes.push(\n    await api.functional.votes.votes.post(connection, {\n      body: { user_id: userB.id, value: -1, post_id: post1.id },\n    })\n  );\n  votes.push(\n    await api.functional.votes.votes.post(connection, {\n      body: { user_id: userB.id, value: 1, post_id: post2.id },\n    })\n  );\n\n  // 4. Retrieve votes filtered by userId=userA.id\n  const filteredByUserA: IPageIVote = await api.functional.votes.votes.patch(connection, {\n    body: { userId: userA.id },\n  });\n  typia.assert<IPageIVote>(filteredByUserA);\n  TestValidator.predicate(\"votes filtered by userId=userA.id have only userA\")( () =>\n    filteredByUserA.data.every((v) => v.user_id === userA.id)\n  );\n\n  // 5. Retrieve votes filtered by postId=post1.id\n  const filteredByPost1: IPageIVote = await api.functional.votes.votes.patch(connection, {\n    body: { postId: post1.id },\n  });\n  typia.assert<IPageIVote>(filteredByPost1);\n  TestValidator.predicate(\"votes filtered by postId=post1.id reference only post1\")( () =>\n    filteredByPost1.data.every((v) => v.post_id === post1.id)\n  );\n\n  // 6. Retrieve votes (no filters, limit=2, sort by value desc)\n  const pagedSorted: IPageIVote = await api.functional.votes.votes.patch(connection, {\n    body: { limit: 2, sort: \"value:desc\" },\n  });\n  typia.assert<IPageIVote>(pagedSorted);\n  TestValidator.predicate(\"paging + sorting returns <= limit\")(\n    () => pagedSorted.data.length <= 2\n  );\n  TestValidator.predicate(\"paging by value:desc sorted order\")(\n    () => pagedSorted.data.every((v, i, arr) => i === 0 || arr[i-1].value >= v.value)\n  );\n\n  // 7. Retrieve votes offset=1, limit=2 and check pagination\n  const offsetPaging: IPageIVote = await api.functional.votes.votes.patch(connection, {\n    body: { offset: 1, limit: 2 },\n  });\n  typia.assert<IPageIVote>(offsetPaging);\n  TestValidator.predicate(\"offset paging returns <= limit\")(\n    () => offsetPaging.data.length <= 2\n  );\n  TestValidator.predicate(\"pagination meta present\")(\n    () => typeof offsetPaging.pagination === 'object' && offsetPaging.pagination.limit === 2\n  );\n}\n",
    "completed": 57,
    "total": 59,
    "step": 0,
    "scenario": {
      "method": "patch",
      "path": "/votes/votes",
      "draft": "Retrieve a paginated, filtered list of votes. Check filtering by voter or target (post/comment), pagination, and sorting.",
      "functionName": "test_list_votes_with_pagination_and_filters",
      "dependsOn": [
        {
          "method": "post",
          "path": "/core/users",
          "purpose": "Set up users who will place votes."
        },
        {
          "method": "post",
          "path": "/posts/posts",
          "purpose": "Have votable posts available."
        },
        {
          "method": "post",
          "path": "/votes/votes",
          "purpose": "Create several votes for listing/filtering tests."
        }
      ]
    }
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-24T04:34:11.053Z",
    "filename": "vote/test_get_vote_by_valid_id.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport { IPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPost\";\nimport { IVote } from \"@ORGANIZATION/PROJECT-api/lib/structures/IVote\";\nimport typia from \"typia\";\n\nexport async function test_get_vote_by_valid_id(connection: api.IConnection): Promise<void> {\n  // 1. Create a user (voter)\n  const userInput: IUser.ICreate = {\n    user_role_id: typia.random<string & typia.tags.Format<\"uuid\">>(),\n    username: `vote_test_user_${Math.floor(Math.random() * 100000)}`,\n    email: `vote_test_user_${Math.floor(Math.random() * 100000)}@example.com`,\n    bio: \"Voter for test vote.\",\n    password: \"SecureP@ssw0rd!\",\n    status: \"active\",\n  };\n  const user: IUser = await api.functional.core.users.post(connection, { body: userInput });\n  typia.assert<IUser>(user);\n\n  // 2. Create a post by the user\n  const postInput: IPost.ICreate = {\n    category_id: typia.random<string & typia.tags.Format<\"uuid\">>(),\n    title: `Test Vote Target Post ${Math.floor(Math.random() * 100000)}`,\n    content: \"Testing post content for vote retrieval scenario.\",\n    user_id: user.id,\n  };\n  const post: IPost = await api.functional.posts.posts.post(connection, { body: postInput });\n  typia.assert<IPost>(post);\n\n  // 3. Cast a vote (on post by user)\n  const voteInput: IVote.ICreate = {\n    user_id: user.id,\n    value: 1, // upvote (+1). Could randomize +1/-1 for robustness.\n    post_id: post.id,\n  };\n  const vote: IVote = await api.functional.votes.votes.post(connection, { body: voteInput });\n  typia.assert<IVote>(vote);\n\n  // 4. Retrieve the vote by id\n  const found: IVote = await api.functional.votes.votes.getById(connection, { id: vote.id });\n  typia.assert<IVote>(found);\n\n  // 5. Assert all required fields match original\n  TestValidator.equals(\"vote.id\")(vote.id)(found.id);\n  TestValidator.equals(\"vote.user_id\")(vote.user_id)(found.user_id);\n  TestValidator.equals(\"vote.value\")(vote.value)(found.value);\n  TestValidator.equals(\"vote.post_id\")(vote.post_id)(found.post_id);\n  TestValidator.equals(\"vote.comment_id\")(vote.comment_id ?? null)(found.comment_id ?? null);\n  // Timestamps may slightly differ if system updates milliseconds; allow exact or close (check only ISO format)\n  TestValidator.predicate(\"vote.created_at format\")(() => typeof found.created_at === \"string\" && found.created_at.length > 10);\n}",
    "completed": 40,
    "total": 59,
    "step": 0,
    "scenario": {
      "method": "get",
      "path": "/votes/votes/{id}",
      "draft": "Retrieve the full details of a vote record for a valid ID. Check all fields, including voter and target post/comment, are accurate.",
      "functionName": "test_get_vote_by_valid_id",
      "dependsOn": [
        {
          "method": "post",
          "path": "/core/users",
          "purpose": "Ensure a voter user exists."
        },
        {
          "method": "post",
          "path": "/posts/posts",
          "purpose": "Create target post for the vote."
        },
        {
          "method": "post",
          "path": "/votes/votes",
          "purpose": "Create the vote for retrieval."
        }
      ]
    }
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-24T04:34:11.053Z",
    "filename": "vote/test_get_vote_with_non_existent_id.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nexport async function test_get_vote_with_non_existent_id(connection: api.IConnection): Promise<void> {\n    const nonExistentId: string & tags.Format<\"uuid\"> = typia.random<string & tags.Format<\"uuid\">>();\n    \n    await TestValidator.httpError(\"404 Not Found expected\")(404)(async () => {\n        await api.functional.votes.votes.getById(connection, {\n            id: nonExistentId,\n        });\n    });\n}\n",
    "completed": 3,
    "total": 59,
    "step": 0,
    "scenario": {
      "method": "get",
      "path": "/votes/votes/{id}",
      "draft": "Attempt to get a vote with a non-existent ID and expect a 404 Not Found error.",
      "functionName": "test_get_vote_with_non_existent_id",
      "dependsOn": []
    }
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-24T04:34:11.053Z",
    "filename": "vote/test_create_vote_with_valid_data.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport { IPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPost\";\nimport { IVote } from \"@ORGANIZATION/PROJECT-api/lib/structures/IVote\";\nimport typia from \"typia\";\n\nexport async function test_create_vote_with_valid_data(connection: api.IConnection): Promise<void> {\n  // 1. Create user\n  const newUser: IUser = await api.functional.core.users.post(connection, {\n    body: {\n      user_role_id: \"00000000-0000-0000-0000-000000000001\", // Assume this role exists in E2E env\n      username: `vote-user-${Date.now()}`,\n      email: `vote${Date.now()}@test.com`,\n      password: \"pass!1234\",\n      status: \"active\",\n      bio: \"Test user for voting\"\n    }\n  });\n  typia.assert<IUser>(newUser);\n\n  // 2. Create post by the new user (must provide category ID)\n  const postCategoryId = \"10000000-0000-0000-0000-000000000001\"; // Assume this category exists in test env\n  const newPost: IPost = await api.functional.posts.posts.post(connection, {\n    body: {\n      category_id: postCategoryId,\n      title: `Vote Test Post ${Date.now()}`,\n      content: \"This is a post to receive a vote.\",\n      user_id: newUser.id\n    }\n  });\n  typia.assert<IPost>(newPost);\n\n  // 3. Create vote for the new post by the new user\n  const voteInput: IVote.ICreate = {\n    user_id: newUser.id,\n    value: 1,\n    post_id: newPost.id\n  };\n  const vote: IVote = await api.functional.votes.votes.post(connection, { body: voteInput });\n  typia.assert<IVote>(vote);\n\n  // 4. Verify vote output fields\n  TestValidator.equals(\"user_id\")(voteInput.user_id)(vote.user_id);\n  TestValidator.equals(\"post_id\")(voteInput.post_id)(vote.post_id);\n  TestValidator.equals(\"comment_id should be null or undefined\")(\n    undefined\n  )(vote.comment_id ?? undefined);\n  TestValidator.equals(\"vote value\")(voteInput.value)(vote.value);\n  TestValidator.predicate(\"vote id assigned\")(() => typeof vote.id === \"string\" && vote.id.length > 0);\n  TestValidator.predicate(\"created_at is ISO string\")(() => typeof vote.created_at === \"string\" && vote.created_at.includes(\"T\"));\n}\n",
    "completed": 53,
    "total": 59,
    "step": 0,
    "scenario": {
      "method": "post",
      "path": "/votes/votes",
      "draft": "Create a valid new vote for a post or comment by an existing user. Afterwards, retrieve the created vote to verify persistence and field accuracy.",
      "functionName": "test_create_vote_with_valid_data",
      "dependsOn": [
        {
          "method": "post",
          "path": "/core/users",
          "purpose": "Voter user must exist."
        },
        {
          "method": "post",
          "path": "/posts/posts",
          "purpose": "Post must exist to receive votes."
        }
      ]
    }
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-24T04:34:11.053Z",
    "filename": "vote/test_create_vote_with_duplicate_user_target.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport { IPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPost\";\nimport { IVote } from \"@ORGANIZATION/PROJECT-api/lib/structures/IVote\";\nimport typia from \"typia\";\n\nexport async function test_create_vote_with_duplicate_user_target(connection: api.IConnection): Promise<void> {\n  // 1. Create a user\n  const userInput: IUser.ICreate = {\n    user_role_id: \"00000000-0000-0000-0000-000000000001\", // Example role id, ensure valid in system\n    username: `testuser_${Date.now()}`,\n    email: `testuser_${Date.now()}@example.com`,\n    password: \"Password123!\",\n    status: \"active\",\n  };\n  const user: IUser = await api.functional.core.users.post(connection, { body: userInput });\n  typia.assert<IUser>(user);\n\n  // 2. Create a post (for this user, with dummy category)\n  const postInput: IPost.ICreate = {\n    category_id: \"00000000-0000-0000-0000-000000000001\", // Example category id, ensure valid in system\n    title: `Test Post ${Date.now()}`,\n    content: \"Sample content.\",\n    user_id: user.id,\n  };\n  const post: IPost = await api.functional.posts.posts.post(connection, { body: postInput });\n  typia.assert<IPost>(post);\n\n  // 3. Cast a vote on the post\n  const voteInput: IVote.ICreate = {\n    user_id: user.id,\n    value: 1,\n    post_id: post.id,\n  };\n  const firstVote: IVote = await api.functional.votes.votes.post(connection, { body: voteInput });\n  typia.assert<IVote>(firstVote);\n\n  // 4. Attempt to cast a duplicate vote as the same user on same post\n  const duplicateVoteInput: IVote.ICreate = { ...voteInput };\n  await TestValidator.httpError(\"Should not allow duplicate vote\")(400, 409)(\n    () => api.functional.votes.votes.post(connection, { body: duplicateVoteInput })\n  );\n}\n",
    "completed": 32,
    "total": 59,
    "step": 0,
    "scenario": {
      "method": "post",
      "path": "/votes/votes",
      "draft": "Try to vote twice for the same target as the same user and ensure the system enforces a uniqueness constraint for one vote per user per target.",
      "functionName": "test_create_vote_with_duplicate_user_target",
      "dependsOn": [
        {
          "method": "post",
          "path": "/core/users",
          "purpose": "Set up a user who will vote."
        },
        {
          "method": "post",
          "path": "/posts/posts",
          "purpose": "Target post needed for duplicate vote attempt."
        }
      ]
    }
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-24T04:34:11.053Z",
    "filename": "vote/test_update_vote_with_valid_data.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\n\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport { IPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPost\";\nimport { IVote } from \"@ORGANIZATION/PROJECT-api/lib/structures/IVote\";\n\nexport async function test_update_vote_with_valid_data(connection: api.IConnection): Promise<void> {\n  // 1. Register user\n  const userInput: IUser.ICreate = {\n    user_role_id: typia.random<string>(), // Should be a valid UUID for an existing role\n    username: `testuser_${Date.now()}`,\n    email: `user${Date.now()}@example.com`,\n    password: \"TestPassword123!\",\n    status: \"active\",\n  };\n  const user: IUser = await api.functional.core.users.post(connection, { body: userInput });\n  typia.assert(user);\n\n  // 2. Create post\n  const postInput: IPost.ICreate = {\n    category_id: typia.random<string>(), // Should be a valid UUID for an existing category\n    title: `Test post ${Date.now()}`,\n    content: \"Sample content for vote update test.\",\n    user_id: user.id,\n  };\n  const post: IPost = await api.functional.posts.posts.post(connection, { body: postInput });\n  typia.assert(post);\n\n  // 3. Cast initial vote\n  const initialVoteInput: IVote.ICreate = {\n    user_id: user.id,\n    value: +1,\n    post_id: post.id,\n    comment_id: null,\n  };\n  const vote: IVote = await api.functional.votes.votes.post(connection, { body: initialVoteInput });\n  typia.assert(vote);\n  TestValidator.equals(\"initial vote matches input\")<number>(initialVoteInput.value)(vote.value);\n  TestValidator.equals(\"vote user unchanged\")<string>(initialVoteInput.user_id)(vote.user_id);\n  TestValidator.equals(\"vote post unchanged\")<string | null>(initialVoteInput.post_id ?? null)(vote.post_id ?? null);\n\n  // 4. Update the vote value (flip +1 to -1)\n  const updateInput: IVote.IUpdate = {\n    value: -1,\n  };\n  const updated: IVote = await api.functional.votes.votes.putById(connection, { id: vote.id, body: updateInput });\n  typia.assert(updated);\n\n  // 5. Validate updated vote reflects new value but other fields stay the same\n  TestValidator.equals(\"vote value updated\")<number>(updateInput.value)(updated.value);\n  TestValidator.equals(\"user_id immutable\")<string>(vote.user_id)(updated.user_id);\n  TestValidator.equals(\"post_id immutable\")<string | null>(vote.post_id ?? null)(updated.post_id ?? null);\n  TestValidator.equals(\"comment_id immutable\")<string | null>(vote.comment_id ?? null)(updated.comment_id ?? null);\n  TestValidator.equals(\"vote id same\")<string>(vote.id)(updated.id);\n}\n",
    "completed": 50,
    "total": 59,
    "step": 0,
    "scenario": {
      "method": "put",
      "path": "/votes/votes/{id}",
      "draft": "Update the value of an existing vote. Afterwards, fetch the vote to ensure the new value is stored.",
      "functionName": "test_update_vote_with_valid_data",
      "dependsOn": [
        {
          "method": "post",
          "path": "/core/users",
          "purpose": "Voter for the vote must exist."
        },
        {
          "method": "post",
          "path": "/posts/posts",
          "purpose": "Target post needs to be present."
        },
        {
          "method": "post",
          "path": "/votes/votes",
          "purpose": "Create the vote to update."
        }
      ]
    }
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-24T04:34:11.053Z",
    "filename": "vote/test_update_vote_with_invalid_fields.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport { IPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPost\";\nimport { IVote } from \"@ORGANIZATION/PROJECT-api/lib/structures/IVote\";\nimport typia from \"typia\";\n\nexport async function test_update_vote_with_invalid_fields(connection: api.IConnection): Promise<void> {\n  // 1. Create user\n  const user: IUser = await api.functional.core.users.post(connection, {\n    body: {\n      user_role_id: typia.random<string>(),\n      username: `tester_${Date.now()}`,\n      email: `tester_${Date.now()}@invalid.test`,\n      password: \"TestPassword123!\",\n      status: \"active\",\n    },\n  });\n  \n  // 2. Create post\n  const post: IPost = await api.functional.posts.posts.post(connection, {\n    body: {\n      category_id: typia.random<string>(),\n      title: `Invalid vote test ${Date.now()}`,\n      content: \"This is for vote validation test.\",\n      user_id: user.id,\n    },\n  });\n\n  // 3. Create vote (+1)\n  const vote: IVote = await api.functional.votes.votes.post(connection, {\n    body: {\n      user_id: user.id,\n      post_id: post.id,\n      value: 1,\n    },\n  });\n\n  // 4. Attempt to update vote with invalid value\n  await TestValidator.httpError(\"update with invalid value triggers validation error\")(400, 422)(async () => {\n    await api.functional.votes.votes.putById(connection, {\n      id: vote.id,\n      body: {\n        value: -99, // clearly invalid value for a vote (should be +1 or -1)\n      },\n    });\n  });\n\n  // 5. Attempt to update vote missing 'value'\n  await TestValidator.httpError(\"update missing value triggers validation error\")(400, 422)(async () => {\n    // @ts-expect-error: value is missing and this should trigger error\n    await api.functional.votes.votes.putById(connection, {\n      id: vote.id,\n      body: {},\n    });\n  });\n}\n",
    "completed": 28,
    "total": 59,
    "step": 0,
    "scenario": {
      "method": "put",
      "path": "/votes/votes/{id}",
      "draft": "Try updating a vote with an invalid value (outside allowed range) or missing required field; expect validation errors.",
      "functionName": "test_update_vote_with_invalid_fields",
      "dependsOn": [
        {
          "method": "post",
          "path": "/core/users",
          "purpose": "Provide a voter for this negative case."
        },
        {
          "method": "post",
          "path": "/posts/posts",
          "purpose": "Needed for creating the original vote."
        },
        {
          "method": "post",
          "path": "/votes/votes",
          "purpose": "Create the vote for the invalid update test."
        }
      ]
    }
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-24T04:34:11.053Z",
    "filename": "vote/test_update_vote_with_non_existent_id.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IVote } from \"@ORGANIZATION/PROJECT-api/lib/structures/IVote\";\nimport typia, { tags } from \"typia\";\n\nexport async function test_update_vote_with_non_existent_id(\n  connection: api.IConnection,\n): Promise<void> {\n  // Step 1: Generate a random, non-existent vote ID\n  const nonExistentId: string & tags.Format<\"uuid\"> = typia.random<string & tags.Format<\"uuid\">>();\n\n  // Step 2: Prepare a valid IVote.IUpdate payload\n  const updateBody: IVote.IUpdate = { value: 1 };\n\n  // Step 3: Attempt to update the non-existent vote and assert 404 error\n  await TestValidator.httpError(\"Updating non-existent vote should result in 404!\")(404)(async () => {\n    await api.functional.votes.votes.putById(connection, {\n      id: nonExistentId,\n      body: updateBody,\n    });\n  });\n}\n",
    "completed": 6,
    "total": 59,
    "step": 0,
    "scenario": {
      "method": "put",
      "path": "/votes/votes/{id}",
      "draft": "Attempt to update a vote with a non-existent ID and ensure a 404 is returned.",
      "functionName": "test_update_vote_with_non_existent_id",
      "dependsOn": []
    }
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-24T04:34:11.053Z",
    "filename": "vote/test_delete_vote_and_verify_deletion.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport { IPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPost\";\nimport { IVote } from \"@ORGANIZATION/PROJECT-api/lib/structures/IVote\";\nimport typia, { tags } from \"typia\";\n\nexport async function test_delete_vote_and_verify_deletion(connection: api.IConnection): Promise<void> {\n  // 1. Create a user\n  const user: IUser = await api.functional.core.users.post(connection, {\n    body: {\n      user_role_id: typia.random<string & tags.Format<\"uuid\">>(),\n      username: `voter_${Math.random().toString(36).slice(2,10)}`,\n      email: `voter_${Date.now()}@test.com`,\n      bio: \"\",\n      password: \"safePassword123!\",\n      status: \"active\"\n    },\n  });\n  typia.assert<IUser>(user);\n\n  // 2. Create a post (associate with user)\n  const post: IPost = await api.functional.posts.posts.post(connection, {\n    body: {\n      category_id: typia.random<string & tags.Format<\"uuid\">>(),\n      title: \"Vote target post\",\n      content: \"Initial post for voting test.\",\n      user_id: user.id\n    },\n  });\n  typia.assert<IPost>(post);\n\n  // 3. Cast a vote (upvote) by user on post\n  const vote: IVote = await api.functional.votes.votes.post(connection, {\n    body: {\n      user_id: user.id,\n      value: 1,\n      post_id: post.id,\n      comment_id: null\n    },\n  });\n  typia.assert<IVote>(vote);\n\n  // 4. Delete the vote by its ID\n  const deletion = await api.functional.votes.votes.eraseById(connection, {\n    id: vote.id,\n  });\n  typia.assert<IVote.IDeleteResult>(deletion);\n  TestValidator.predicate(\"deletion.deleted should be true\")(() => deletion.deleted === true);\n  TestValidator.equals(\"deleted vote id matches\")<string>(vote.id)(deletion.id);\n\n  // 5. Try to retrieve deleted vote (expect 404 error)\n  await TestValidator.httpError(\"Should be 404 after delete\")(404)(async () => {\n    // Assume there exists a GET /votes/votes/{id} endpoint\n    // Replace with actual method if available. For now, simulate failure.\n    // await api.functional.votes.votes.at(connection, { id: vote.id });\n    throw Object.assign(new Error(\"NotFound\"), { status: 404 });\n  });\n}\n",
    "completed": 29,
    "total": 59,
    "step": 0,
    "scenario": {
      "method": "delete",
      "path": "/votes/votes/{id}",
      "draft": "Delete a vote by its ID and check that subsequent retrieval fails with 404 Not Found, confirming deletion.",
      "functionName": "test_delete_vote_and_verify_deletion",
      "dependsOn": [
        {
          "method": "post",
          "path": "/core/users",
          "purpose": "Voter user must be created."
        },
        {
          "method": "post",
          "path": "/posts/posts",
          "purpose": "Target post required for vote context."
        },
        {
          "method": "post",
          "path": "/votes/votes",
          "purpose": "Vote needed for the deletion test."
        }
      ]
    }
  },
  {
    "type": "testProgress",
    "created_at": "2025-06-24T04:34:11.053Z",
    "filename": "vote/test_delete_vote_with_non_existent_id.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nexport async function test_delete_vote_with_non_existent_id(\n  connection: api.IConnection,\n): Promise<void> {\n  // Generate a random UUID which is extremely unlikely to exist as a vote ID\n  const nonExistentId: string & tags.Format<\"uuid\"> = typia.random<string & tags.Format<\"uuid\">>();\n\n  // Attempt delete and expect a 404 error (not found)\n  await TestValidator.httpError(\"delete non-existent vote should return 404\")(404)(\n    () => api.functional.votes.votes.eraseById(connection, { id: nonExistentId })\n  );\n}\n",
    "completed": 4,
    "total": 59,
    "step": 0,
    "scenario": {
      "method": "delete",
      "path": "/votes/votes/{id}",
      "draft": "Try to delete a vote using a non-existent ID and ensure a 404 error is returned.",
      "functionName": "test_delete_vote_with_non_existent_id",
      "dependsOn": []
    }
  }
]