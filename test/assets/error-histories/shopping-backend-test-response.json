{
  ".vscode/launch.json": "{\n  // Use IntelliSense to learn about possible Node.js debug attributes.\n  // Hover to view descriptions of existing attributes.\n  // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387\n  \"version\": \"0.2.0\",\n  \"configurations\": [\n  {\n    \"type\": \"node\",\n    \"request\": \"launch\",\n    \"name\": \"Backend Test\",\n    \"program\": \"${workspaceRoot}/test/index.ts\",\n    \"cwd\": \"${workspaceRoot}\",\n    \"args\": [\n      // //----\n      // // Not possible to reset DB in debugging mode\n      // //\n      // // Therefore, if you need DB reset, then do it \n      // // through `npm run reset-for-debugging` command\n      // //----\n      // \"--reset\", \"false\",\n      // \"--mode\", \"local\",\n      \n      //----\n      // You can run specific test functions\n      //\n      // If you want to include or exclude multiple words,\n      // then separate them with space character\n      //----\n      // \"--include\", \"some-words-to-include\",\n      // \"--exclude\", \"some-word another-word\",\n  ],\n    \"outFiles\": [\"${workspaceRoot}/bin/**/*.js\"],\n  }\n]\n}",
  ".vscode/settings.json": "{\n  \"editor.tabSize\": 2,\n  \"editor.formatOnSave\": true,\n  \"[javascript][typescript]\": {\n    \"editor.defaultFormatter\": \"esbenp.prettier-vscode\",\n    \"editor.codeActionsOnSave\": {\n      \"source.fixAll.eslint\": \"explicit\"\n    },\n  }\n}",
  "build/env.ts": "import fs from \"fs\";\n\nif (fs.existsSync(`${__dirname}/../.env`) === false)\n  fs.copyFileSync(`${__dirname}/../.env.local`, `${__dirname}/../.env`);\n",
  "nest-cli.json": "{\n  \"$schema\": \"https://json.schemastore.org/nest-cli\",\n  \"collection\": \"@nestjs/schematics\",\n  \"sourceRoot\": \"src\",\n  \"entryFile\": \"executable/server\",\n  \"compilerOptions\": {\n    \"deleteOutDir\": true\n  }\n}\n",
  "nestia.config.ts": "// nestia configuration file\nimport type sdk from \"@nestia/sdk\";\nimport { NestFactory } from \"@nestjs/core\";\n\nimport { MyModule } from \"./src/MyModule\";\n\nconst NESTIA_CONFIG: sdk.INestiaConfig = {\n  input: () => NestFactory.create(MyModule),\n  output: \"src/api\",\n  swagger: {\n    output: \"packages/api/swagger.json\",\n    servers: [\n      {\n        url: \"http://localhost:37001\",\n        description: \"Local Server\",\n      },\n    ],\n    beautify: true,\n  },\n  distribute: \"packages/api\",\n  primitive: false,\n  simulate: true,\n};\nexport default NESTIA_CONFIG;\n",
  "package.json": "{\n  \"private\": true,\n  \"name\": \"@ORGANIZATION/PROJECT\",\n  \"version\": \"0.1.0\",\n  \"description\": \"Starter kit of Nestia\",\n  \"main\": \"lib/index.js\",\n  \"scripts\": {\n    \"benchmark\": \"node bin/test/benchmark\",\n    \"test\": \"node bin/test\",\n    \"test:webpack\": \"npm run webpack && node bin/test/webpack.js\",\n    \"------------------------BUILDS------------------------\": \"\",\n    \"build\": \"npm run build:sdk && npm run build:main && npm run build:test\",\n    \"build:api\": \"rimraf packages/api/lib && nestia all && rimraf packages/api/lib && tsc -p packages/api/tsconfig.json && rollup -c packages/api/rollup.config.js\",\n    \"build:main\": \"rimraf lib && tsc\",\n    \"build:sdk\": \"rimraf src/api/functional && nestia sdk\",\n    \"build:swagger\": \"npx nestia swagger\",\n    \"build:test\": \"rimraf bin && tsc -p test/tsconfig.json\",\n    \"dev\": \"npm run build:test -- --watch\",\n    \"eslint\": \"eslint src && eslint test\",\n    \"eslint:fix\": \"eslint --fix src && eslint --fix test\",\n    \"prepare\": \"ts-patch install && ts-node build/env.ts\",\n    \"prettier\": \"prettier src --write && prettier test --write\",\n    \"------------------------WEBPACK------------------------\": \"\",\n    \"webpack\": \"rimraf dist && webpack\",\n    \"webpack:start\": \"cd dist && node dist/server\",\n    \"webpack:test\": \"npm run webpack && node bin/test/webpack.js\",\n    \"------------------------DEPLOYS------------------------\": \"\",\n    \"package:api\": \"npm run build:api && cd packages/api && npm publish\",\n    \"start\": \"node lib/executable/server\",\n    \"start:dev\": \"nest start --watch\",\n    \"start:swagger\": \"ts-node src/executable/swagger.ts\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/samchon/nestia-start\"\n  },\n  \"keywords\": [\n    \"nestia\",\n    \"template\",\n    \"boilerplate\"\n  ],\n  \"author\": \"AUTHOR\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/samchon/nestia-start/issues\"\n  },\n  \"homepage\": \"https://github.com/samchon/nestia-start#readme\",\n  \"devDependencies\": {\n    \"@nestia/benchmark\": \"^6.0.6\",\n    \"@nestia/e2e\": \"^6.0.6\",\n    \"@nestia/sdk\": \"^7.0.0\",\n    \"@nestjs/cli\": \"^11.0.7\",\n    \"@rollup/plugin-terser\": \"^0.4.4\",\n    \"@rollup/plugin-typescript\": \"^11.1.6\",\n    \"@trivago/prettier-plugin-sort-imports\": \"^4.3.0\",\n    \"@types/cli\": \"^0.11.21\",\n    \"@types/cli-progress\": \"^3.11.5\",\n    \"@types/express\": \"^4.17.21\",\n    \"@types/inquirer\": \"^8.2.5\",\n    \"@types/node\": \"^18.11.0\",\n    \"@types/uuid\": \"^8.3.4\",\n    \"@typescript-eslint/eslint-plugin\": \"^8.1.0\",\n    \"@typescript-eslint/parser\": \"^8.1.0\",\n    \"chalk\": \"^4.1.2\",\n    \"cli\": \"^1.0.1\",\n    \"cli-progress\": \"^3.12.0\",\n    \"copy-webpack-plugin\": \"^11.0.0\",\n    \"eslint-plugin-deprecation\": \"^3.0.0\",\n    \"express\": \"^4.18.2\",\n    \"nestia\": \"^7.0.0\",\n    \"prettier\": \"^3.2.4\",\n    \"prettier-plugin-prisma\": \"^5.0.0\",\n    \"rimraf\": \"^3.0.2\",\n    \"rollup\": \"^4.18.0\",\n    \"source-map-support\": \"^0.5.21\",\n    \"swagger-ui-express\": \"^5.0.0\",\n    \"ts-loader\": \"^9.5.1\",\n    \"ts-node\": \"^10.9.1\",\n    \"ts-patch\": \"^3.3.0\",\n    \"typescript\": \"~5.8.3\",\n    \"typescript-transform-paths\": \"^3.5.5\",\n    \"webpack\": \"^5.89.0\",\n    \"webpack-cli\": \"^5.1.4\",\n    \"write-file-webpack-plugin\": \"^4.5.1\"\n  },\n  \"dependencies\": {\n    \"@nestia/core\": \"^7.0.0\",\n    \"@nestia/fetcher\": \"^7.0.0\",\n    \"@nestjs/common\": \"^11.1.3\",\n    \"@nestjs/core\": \"^11.1.3\",\n    \"@nestjs/platform-express\": \"^11.1.3\",\n    \"commander\": \"10.0.0\",\n    \"dotenv\": \"^16.3.1\",\n    \"dotenv-expand\": \"^10.0.0\",\n    \"inquirer\": \"8.2.5\",\n    \"serialize-error\": \"^4.1.0\",\n    \"tgrid\": \"^1.1.0\",\n    \"tstl\": \"^3.0.0\",\n    \"typia\": \"^9.3.1\",\n    \"uuid\": \"^9.0.0\"\n  },\n  \"stackblitz\": {\n    \"startCommand\": \"npm run prepare && npm run build:test && npm run test -- --simultaneous 1\"\n  }\n}",
  "packages/api/package.json": "{\n  \"name\": \"@ORGANIZATION/PROJECT-api\",\n  \"version\": \"0.1.0\",\n  \"description\": \"SDK library generated by Nestia\",\n  \"main\": \"lib/index.js\",\n  \"module\": \"lib/index.mjs\",\n  \"typings\": \"lib/index.d.ts\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/samchon/nestia\"\n  },\n  \"author\": \"Jeongho Nam\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/samchon/nestia/issues\"\n  },\n  \"homepage\": \"https://nestia.io\",\n  \"files\": [\n    \"lib\",\n    \"package.json\",\n    \"swagger.json\",\n    \"openai.json\",\n    \"README.md\"\n  ],\n  \"dependencies\": {\n    \"@nestia/fetcher\": \"^6.0.6\",\n    \"tgrid\": \"^1.1.0\",\n    \"typia\": \"^9.3.1\"\n  }\n}",
  "packages/api/tsconfig.json": "{\n  \"compilerOptions\": {\n    /* Visit https://aka.ms/tsconfig to read more about this file */\n    /* Projects */\n    // \"incremental\": true,                              /* Save .tsbuildinfo files to allow for incremental compilation of projects. */\n    // \"composite\": true,                                /* Enable constraints that allow a TypeScript project to be used with project references. */\n    // \"tsBuildInfoFile\": \"./.tsbuildinfo\",              /* Specify the path to .tsbuildinfo incremental compilation file. */\n    // \"disableSourceOfProjectReferenceRedirect\": true,  /* Disable preferring source files instead of declaration files when referencing composite projects. */\n    // \"disableSolutionSearching\": true,                 /* Opt a project out of multi-project reference checking when editing. */\n    // \"disableReferencedProjectLoad\": true,             /* Reduce the number of projects loaded automatically by TypeScript. */\n    /* Language and Environment */\n    \"target\": \"ES5\", /* Set the JavaScript language version for emitted JavaScript and include compatible library declarations. */\n    \"lib\": [\n      \"DOM\",\n      \"ES2015\"\n    ], /* Specify a set of bundled library declaration files that describe the target runtime environment. */// \"jsx\": \"preserve\",                                /* Specify what JSX code is generated. */\n    // \"experimentalDecorators\": true,                   /* Enable experimental support for TC39 stage 2 draft decorators. */\n    // \"emitDecoratorMetadata\": true,                    /* Emit design-type metadata for decorated declarations in source files. */\n    // \"jsxFactory\": \"\",                                 /* Specify the JSX factory function used when targeting React JSX emit, e.g. 'React.createElement' or 'h'. */\n    // \"jsxFragmentFactory\": \"\",                         /* Specify the JSX Fragment reference used for fragments when targeting React JSX emit e.g. 'React.Fragment' or 'Fragment'. */\n    // \"jsxImportSource\": \"\",                            /* Specify module specifier used to import the JSX factory functions when using 'jsx: react-jsx*'. */\n    // \"reactNamespace\": \"\",                             /* Specify the object invoked for 'createElement'. This only applies when targeting 'react' JSX emit. */\n    // \"noLib\": true,                                    /* Disable including any library files, including the default lib.d.ts. */\n    // \"useDefineForClassFields\": true,                  /* Emit ECMAScript-standard-compliant class fields. */\n    // \"moduleDetection\": \"auto\",                        /* Control what method is used to detect module-format JS files. */\n    /* Modules */\n    \"module\": \"commonjs\", /* Specify what module code is generated. */// \"rootDir\": \"./\",                                  /* Specify the root folder within your source files. */\n    // \"moduleResolution\": \"node\",                       /* Specify how TypeScript looks up a file from a given module specifier. */\n    // \"baseUrl\": \"./\",                                  /* Specify the base directory to resolve non-relative module names. */\n    // \"paths\": {},                                      /* Specify a set of entries that re-map imports to additional lookup locations. */\n    // \"rootDirs\": [],                                   /* Allow multiple folders to be treated as one when resolving modules. */\n    // \"typeRoots\": [],                                  /* Specify multiple folders that act like './node_modules/@types'. */\n    // \"types\": [],                                      /* Specify type package names to be included without being referenced in a source file. */\n    // \"allowUmdGlobalAccess\": true,                     /* Allow accessing UMD globals from modules. */\n    // \"moduleSuffixes\": [],                             /* List of file name suffixes to search when resolving a module. */\n    // \"resolveJsonModule\": true,                        /* Enable importing .json files. */\n    // \"noResolve\": true,                                /* Disallow 'import's, 'require's or '<reference>'s from expanding the number of files TypeScript should add to a project. */\n    /* JavaScript Support */\n    // \"allowJs\": true,                                  /* Allow JavaScript files to be a part of your program. Use the 'checkJS' option to get errors from these files. */\n    // \"checkJs\": true,                                  /* Enable error reporting in type-checked JavaScript files. */\n    // \"maxNodeModuleJsDepth\": 1,                        /* Specify the maximum folder depth used for checking JavaScript files from 'node_modules'. Only applicable with 'allowJs'. */\n    /* Emit */\n    \"declaration\": true, /* Generate .d.ts files from TypeScript and JavaScript files in your project. */// \"declarationMap\": true,                           /* Create sourcemaps for d.ts files. */\n    // \"emitDeclarationOnly\": true,                      /* Only output d.ts files and not JavaScript files. */\n    \"sourceMap\": true, /* Create source map files for emitted JavaScript files. */// \"outFile\": \"./\",                                  /* Specify a file that bundles all outputs into one JavaScript file. If 'declaration' is true, also designates a file that bundles all .d.ts output. */\n    \"outDir\": \"./lib\", /* Specify an output folder for all emitted files. */// \"removeComments\": true,                           /* Disable emitting comments. */\n    // \"noEmit\": true,                                   /* Disable emitting files from a compilation. */\n    // \"importHelpers\": true,                            /* Allow importing helper functions from tslib once per project, instead of including them per-file. */\n    // \"importsNotUsedAsValues\": \"remove\",               /* Specify emit/checking behavior for imports that are only used for types. */\n    \"downlevelIteration\": true, /* Emit more compliant, but verbose and less performant JavaScript for iteration. */// \"sourceRoot\": \"\",                                 /* Specify the root path for debuggers to find the reference source code. */\n    // \"mapRoot\": \"\",                                    /* Specify the location where debugger should locate map files instead of generated locations. */\n    // \"inlineSourceMap\": true,                          /* Include sourcemap files inside the emitted JavaScript. */\n    // \"inlineSources\": true,                            /* Include source code in the sourcemaps inside the emitted JavaScript. */\n    // \"emitBOM\": true,                                  /* Emit a UTF-8 Byte Order Mark (BOM) in the beginning of output files. */\n    \"newLine\": \"lf\", /* Set the newline character for emitting files. */// \"stripInternal\": true,                            /* Disable emitting declarations that have '@internal' in their JSDoc comments. */\n    // \"noEmitHelpers\": true,                            /* Disable generating custom helper functions like '__extends' in compiled output. */\n    // \"noEmitOnError\": true,                            /* Disable emitting files if any type checking errors are reported. */\n    // \"preserveConstEnums\": true,                       /* Disable erasing 'const enum' declarations in generated code. */\n    // \"declarationDir\": \"./\",                           /* Specify the output directory for generated declaration files. */\n    // \"preserveValueImports\": true,                     /* Preserve unused imported values in the JavaScript output that would otherwise be removed. */\n    /* Interop Constraints */\n    // \"isolatedModules\": true,                          /* Ensure that each file can be safely transpiled without relying on other imports. */\n    // \"allowSyntheticDefaultImports\": true,             /* Allow 'import x from y' when a module doesn't have a default export. */\n    \"esModuleInterop\": true, /* Emit additional JavaScript to ease support for importing CommonJS modules. This enables 'allowSyntheticDefaultImports' for type compatibility. */// \"preserveSymlinks\": true,                         /* Disable resolving symlinks to their realpath. This correlates to the same flag in node. */\n    \"forceConsistentCasingInFileNames\": true, /* Ensure that casing is correct in imports. *//* Type Checking */\n    \"strict\": true, /* Enable all strict type-checking options. */// \"noImplicitAny\": true,                            /* Enable error reporting for expressions and declarations with an implied 'any' type. */\n    // \"strictNullChecks\": true,                         /* When type checking, take into account 'null' and 'undefined'. */\n    // \"strictFunctionTypes\": true,                      /* When assigning functions, check to ensure parameters and the return values are subtype-compatible. */\n    // \"strictBindCallApply\": true,                      /* Check that the arguments for 'bind', 'call', and 'apply' methods match the original function. */\n    // \"strictPropertyInitialization\": true,             /* Check for class properties that are declared but not set in the constructor. */\n    // \"noImplicitThis\": true,                           /* Enable error reporting when 'this' is given the type 'any'. */\n    // \"useUnknownInCatchVariables\": true,               /* Default catch clause variables as 'unknown' instead of 'any'. */\n    // \"alwaysStrict\": true,                             /* Ensure 'use strict' is always emitted. */\n    // \"noUnusedLocals\": true,                           /* Enable error reporting when local variables aren't read. */\n    // \"noUnusedParameters\": true,                       /* Raise an error when a function parameter isn't read. */\n    // \"exactOptionalPropertyTypes\": true,               /* Interpret optional property types as written, rather than adding 'undefined'. */\n    // \"noImplicitReturns\": true,                        /* Enable error reporting for codepaths that do not explicitly return in a function. */\n    // \"noFallthroughCasesInSwitch\": true,               /* Enable error reporting for fallthrough cases in switch statements. */\n    // \"noUncheckedIndexedAccess\": true,                 /* Add 'undefined' to a type when accessed using an index. */\n    // \"noImplicitOverride\": true,                       /* Ensure overriding members in derived classes are marked with an override modifier. */\n    // \"noPropertyAccessFromIndexSignature\": true,       /* Enforces using indexed accessors for keys declared using an indexed type. */\n    // \"allowUnusedLabels\": true,                        /* Disable error reporting for unused labels. */\n    // \"allowUnreachableCode\": true,                     /* Disable error reporting for unreachable code. */\n    /* Completeness */\n    // \"skipDefaultLibCheck\": true,                      /* Skip type checking .d.ts files that are included with TypeScript. */\n    \"skipLibCheck\": true, /* Skip type checking all .d.ts files. */\n    \"plugins\": [\n      {\n        \"transform\": \"typia/lib/transform\"\n      }\n    ],\n    \"strictNullChecks\": true\n  },\n  \"include\": [\n    \"../../src/api\"\n  ]\n}",
  "src/MyBackend.ts": "import { WebSocketAdaptor } from \"@nestia/core\";\nimport { INestApplication } from \"@nestjs/common\";\nimport { NestFactory } from \"@nestjs/core\";\n\nimport { MyConfiguration } from \"./MyConfiguration\";\nimport { MyModule } from \"./MyModule\";\n\nexport class MyBackend {\n  private application_?: INestApplication;\n\n  public async open(): Promise<void> {\n    //----\n    // OPEN THE BACKEND SERVER\n    //----\n    // MOUNT CONTROLLERS\n    this.application_ = await NestFactory.create(MyModule, { logger: false });\n    await WebSocketAdaptor.upgrade(this.application_);\n\n    // DO OPEN\n    this.application_.enableCors();\n    await this.application_.listen(MyConfiguration.API_PORT(), \"0.0.0.0\");\n\n    //----\n    // POST-PROCESSES\n    //----\n    // INFORM TO THE PM2\n    if (process.send) process.send(\"ready\");\n\n    // WHEN KILL COMMAND COMES\n    process.on(\"SIGINT\", async () => {\n      await this.close();\n      process.exit(0);\n    });\n  }\n\n  public async close(): Promise<void> {\n    if (this.application_ === undefined) return;\n\n    // DO CLOSE\n    await this.application_.close();\n    delete this.application_;\n  }\n}\n",
  "src/MyConfiguration.ts": "import fs from \"fs\";\nimport path from \"path\";\n\nimport { MyGlobal } from \"./MyGlobal\";\n\nexport namespace MyConfiguration {\n  export const API_PORT = () => Number(MyGlobal.env.API_PORT);\n\n  export const ROOT = (() => {\n    const split: string[] = __dirname.split(path.sep);\n    return split.at(-1) === \"src\" && split.at(-2) === \"bin\"\n      ? path.resolve(__dirname + \"/../..\")\n      : fs.existsSync(__dirname + \"/.env\")\n        ? __dirname\n        : path.resolve(__dirname + \"/..\");\n  })();\n}\n",
  "src/MyGlobal.ts": "import dotenv from \"dotenv\";\nimport dotenvExpand from \"dotenv-expand\";\nimport { Singleton } from \"tstl\";\nimport typia from \"typia\";\n\n/* eslint-disable */\nexport class MyGlobal {\n  public static testing: boolean = false;\n  public static get env(): MyGlobal.IEnvironments {\n    return environments.get();\n  }\n}\nexport namespace MyGlobal {\n  export interface IEnvironments {\n    API_PORT: `${number}`;\n  }\n}\n\nconst environments = new Singleton(() => {\n  const env = dotenv.config();\n  dotenvExpand.expand(env);\n  return typia.assert<MyGlobal.IEnvironments>(process.env);\n});\n",
  "src/api/HttpError.ts": "export { HttpError } from \"@nestia/fetcher\";\n",
  "src/api/IConnection.ts": "export type { IConnection } from \"@nestia/fetcher\";\n",
  "src/api/Primitive.ts": "export type { Primitive } from \"typia\";\n",
  "src/api/Resolved.ts": "export type { Resolved } from \"typia\";\n",
  "src/api/index.ts": "import * as api from \"./module\";\n\nexport * from \"./module\";\nexport default api;\n",
  "src/api/module.ts": "export type * from \"./IConnection\";\nexport * from \"./HttpError\";\n\nexport * as functional from \"./functional\";\n",
  "src/executable/server.ts": "import { MyBackend } from \"../MyBackend\";\n\nconst EXTENSION = __filename.substring(__filename.length - 2);\nif (EXTENSION === \"js\") require(\"source-map-support/register\");\n\nasync function main(): Promise<void> {\n  // BACKEND SEVER\n  const backend: MyBackend = new MyBackend();\n  await backend.open();\n\n  // UNEXPECTED ERRORS\n  global.process.on(\"uncaughtException\", console.error);\n  global.process.on(\"unhandledRejection\", console.error);\n}\nmain().catch((exp) => {\n  console.log(exp);\n  process.exit(-1);\n});\n",
  "src/executable/swagger.ts": "import cp from \"child_process\";\nimport express from \"express\";\n\nconst execute = (command: string): void => {\n  console.log(`\\n$ ${command}\\n`);\n  cp.execSync(command, { stdio: \"inherit\" });\n};\n\nconst main = async (): Promise<void> => {\n  if (!process.argv.some((str) => str === \"--skipBuild\"))\n    execute(\"npm run build:swagger\");\n\n  const docs = await import(\"../../packages/api/swagger.json\" as any);\n\n  const app = express();\n  const swaggerUi = require(\"swagger-ui-express\");\n  app.use(\"/api-docs\", swaggerUi.serve, swaggerUi.setup(docs));\n  app.listen(37810);\n\n  console.log(\"\\n\");\n  console.log(\"-----------------------------------------------------------\");\n  console.log(\"\\n Swagger UI Address: http://127.0.0.1:37810/api-docs \\n\");\n  console.log(\"-----------------------------------------------------------\");\n};\nmain().catch((exp) => {\n  console.log(exp);\n  process.exit(-1);\n});\n",
  "src/utils/ErrorUtil.ts": "import serializeError = require(\"serialize-error\");\n\nexport namespace ErrorUtil {\n  export const toJSON = (err: any): object =>\n    err instanceof Object && err.toJSON instanceof Function\n      ? err.toJSON()\n      : serializeError(err);\n}\n",
  "src/utils/MapUtil.ts": "export namespace MapUtil {\n  export function take<Key, T>(\n    dict: Map<Key, T>,\n    key: Key,\n    generator: () => T,\n  ): T {\n    const oldbie: T | undefined = dict.get(key);\n    if (oldbie) return oldbie;\n\n    const value: T = generator();\n    dict.set(key, value);\n    return value;\n  }\n}\n",
  "test/TestAutomation.ts": "import { DynamicExecutor } from \"@nestia/e2e\";\nimport chalk from \"chalk\";\nimport { sleep_for } from \"tstl\";\n\nimport { MyConfiguration } from \"../src/MyConfiguration\";\nimport api from \"../src/api\";\nimport { ArgumentParser } from \"./helpers/ArgumentParser\";\n\nexport namespace TestAutomation {\n  export interface IProps<T> {\n    open(options: IOptions): Promise<T>;\n    close(backend: T): Promise<void>;\n  }\n\n  export interface IOptions {\n    simultaneous: number;\n    include?: string[];\n    exclude?: string[];\n  }\n\n  export const execute = async <T,>(props: IProps<T>): Promise<void> => {\n    // OPEN BACKEND\n    const options: IOptions = await getOptions();\n    const backend: T = await props.open(options);\n\n    // DO TEST\n    const connection: api.IConnection = {\n      host: `http://127.0.0.1:${MyConfiguration.API_PORT()}`,\n    };\n    const report: DynamicExecutor.IReport = await DynamicExecutor.validate({\n      prefix: \"test\",\n      location: __dirname + \"/features\",\n      parameters: () => [\n        {\n          host: connection.host,\n          encryption: connection.encryption,\n        },\n      ],\n      filter: (func) =>\n        (!options.include?.length ||\n          (options.include ?? []).some((str) => func.includes(str))) &&\n        (!options.exclude?.length ||\n          (options.exclude ?? []).every((str) => !func.includes(str))),\n      onComplete: (exec) => {\n        const trace = (str: string) =>\n          console.log(`  - ${chalk.green(exec.name)}: ${str}`);\n        if (exec.error === null) {\n          const elapsed: number =\n            new Date(exec.completed_at).getTime() -\n            new Date(exec.started_at).getTime();\n          trace(`${chalk.yellow(elapsed.toLocaleString())} ms`);\n        } else trace(chalk.red(exec.error.name));\n      },\n      simultaneous: options.simultaneous,\n    });\n\n    // TERMINATE - WAIT FOR BACKGROUND EVENTS\n    await sleep_for(2500);\n    await props.close(backend);\n\n    const failures: DynamicExecutor.IExecution[] = report.executions.filter(\n      (exec) => exec.error !== null,\n    );\n    if (failures.length === 0) {\n      console.log(\"Success\");\n      console.log(\"Elapsed time\", report.time.toLocaleString(), `ms`);\n    } else {\n      for (const f of failures) console.log(f.error);\n      process.exit(-1);\n    }\n\n    console.log(\n      [\n        `All: #${report.executions.length}`,\n        `Success: #${report.executions.length - failures.length}`,\n        `Failed: #${failures.length}`,\n      ].join(\"\\n\"),\n    );\n  };\n}\n\nconst getOptions = () =>\n  ArgumentParser.parse<TestAutomation.IOptions>(\n    async (command, prompt, action) => {\n      command.option(\n        \"--simultaneous <number>\",\n        \"number of simultaneous requests\",\n      );\n      command.option(\"--include <string...>\", \"include feature files\");\n      command.option(\"--exclude <string...>\", \"exclude feature files\");\n\n      return action(async (options) => {\n        options.simultaneous = Number(\n          options.simultaneous ??\n            (await prompt.number(\"simultaneous\")(\n              \"Number of simultaneous requests to make\",\n            )),\n        );\n        if (isNaN(options.simultaneous) || options.simultaneous <= 0)\n          options.simultaneous = 1;\n        return options as TestAutomation.IOptions;\n      });\n    },\n  );\n",
  "test/helpers/ArgumentParser.ts": "import commander from \"commander\";\nimport * as inquirer from \"inquirer\";\n\nexport namespace ArgumentParser {\n  export type Inquiry<T> = (\n    command: commander.Command,\n    prompt: (opt?: inquirer.StreamOptions) => inquirer.PromptModule,\n    action: (closure: (options: Partial<T>) => Promise<T>) => Promise<T>,\n  ) => Promise<T>;\n\n  export interface Prompt {\n    select: (\n      name: string,\n    ) => (\n      message: string,\n    ) => <Choice extends string>(choices: Choice[]) => Promise<Choice>;\n    boolean: (name: string) => (message: string) => Promise<boolean>;\n    number: (name: string) => (message: string) => Promise<number>;\n  }\n\n  export const parse = async <T,>(\n    inquiry: (\n      command: commander.Command,\n      prompt: Prompt,\n      action: (closure: (options: Partial<T>) => Promise<T>) => Promise<T>,\n    ) => Promise<T>,\n  ): Promise<T> => {\n    // TAKE OPTIONS\n    const action = (closure: (options: Partial<T>) => Promise<T>) =>\n      new Promise<T>((resolve, reject) => {\n        commander.program.action(async (options) => {\n          try {\n            resolve(await closure(options));\n          } catch (exp) {\n            reject(exp);\n          }\n        });\n        commander.program.parseAsync().catch(reject);\n      });\n\n    const select =\n      (name: string) =>\n      (message: string) =>\n      async <Choice extends string>(choices: Choice[]): Promise<Choice> =>\n        (\n          await inquirer.createPromptModule()({\n            type: \"list\",\n            name,\n            message,\n            choices,\n          })\n        )[name];\n    const boolean = (name: string) => async (message: string) =>\n      (\n        await inquirer.createPromptModule()({\n          type: \"confirm\",\n          name,\n          message,\n        })\n      )[name] as boolean;\n    const number = (name: string) => async (message: string) =>\n      Number(\n        (\n          await inquirer.createPromptModule()({\n            type: \"number\",\n            name,\n            message,\n          })\n        )[name],\n      );\n\n    const output: T | Error = await (async () => {\n      try {\n        return await inquiry(\n          commander.program,\n          { select, boolean, number },\n          action,\n        );\n      } catch (error) {\n        return error as Error;\n      }\n    })();\n\n    // RETURNS\n    if (output instanceof Error) throw output;\n    return output;\n  };\n}\n",
  "test/index.ts": "import { MyBackend } from \"../src/MyBackend\";\nimport { MyGlobal } from \"../src/MyGlobal\";\nimport { TestAutomation } from \"./TestAutomation\";\n\nconst main = async (): Promise<void> => {\n  MyGlobal.testing = true;\n  await TestAutomation.execute({\n    open: async () => {\n      const backend: MyBackend = new MyBackend();\n      await backend.open();\n      return backend;\n    },\n    close: (backend) => backend.close(),\n  });\n};\nmain().catch((exp) => {\n  console.log(exp);\n  process.exit(-1);\n});\n",
  "test/tsconfig.json": "{\n  \"extends\": \"../tsconfig.json\",\n  \"compilerOptions\": {\n    \"outDir\": \"../bin\",\n  },\n  \"include\": [\".\", \"../src\"]\n}",
  "test/webpack.ts": "import cp from \"child_process\";\nimport { sleep_for } from \"tstl\";\n\nimport { MyConfiguration } from \"../src/MyConfiguration\";\nimport { MyGlobal } from \"../src/MyGlobal\";\nimport { TestAutomation } from \"./TestAutomation\";\n\nconst wait = async (): Promise<void> => {\n  while (true)\n    try {\n      await fetch(`http://localhost:${MyConfiguration.API_PORT()}/dsafdsafsd`);\n      return;\n    } catch (exp) {\n      await sleep_for(100);\n    }\n};\n\nconst main = async (): Promise<void> => {\n  MyGlobal.testing = true;\n  await TestAutomation.execute({\n    open: async () => {\n      const backend: cp.ChildProcess = cp.fork(\n        `${MyConfiguration.ROOT}/dist/server.js`,\n        {\n          cwd: `${MyConfiguration.ROOT}/dist`,\n        },\n      );\n      await wait();\n      return backend;\n    },\n    close: async (backend) => {\n      backend.kill();\n    },\n  });\n};\nmain().catch((exp) => {\n  console.log(exp);\n  process.exit(-1);\n});\n",
  "tsconfig.json": "{\n  \"compilerOptions\": {\n    /* Visit https://aka.ms/tsconfig to read more about this file */\n\n    /* Projects */\n    // \"incremental\": true,                              /* Save .tsbuildinfo files to allow for incremental compilation of projects. */\n    // \"composite\": true,                                /* Enable constraints that allow a TypeScript project to be used with project references. */\n    // \"tsBuildInfoFile\": \"./.tsbuildinfo\",              /* Specify the path to .tsbuildinfo incremental compilation file. */\n    // \"disableSourceOfProjectReferenceRedirect\": true,  /* Disable preferring source files instead of declaration files when referencing composite projects. */\n    // \"disableSolutionSearching\": true,                 /* Opt a project out of multi-project reference checking when editing. */\n    // \"disableReferencedProjectLoad\": true,             /* Reduce the number of projects loaded automatically by TypeScript. */\n\n    /* Language and Environment */\n    \"target\": \"ES2015\",                                  /* Set the JavaScript language version for emitted JavaScript and include compatible library declarations. */\n    // \"lib\": [],                                        /* Specify a set of bundled library declaration files that describe the target runtime environment. */\n    // \"jsx\": \"preserve\",                                /* Specify what JSX code is generated. */\n    \"experimentalDecorators\": true,                   /* Enable experimental support for TC39 stage 2 draft decorators. */\n    \"emitDecoratorMetadata\": true,                    /* Emit design-type metadata for decorated declarations in source files. */\n    // \"jsxFactory\": \"\",                                 /* Specify the JSX factory function used when targeting React JSX emit, e.g. 'React.createElement' or 'h'. */\n    // \"jsxFragmentFactory\": \"\",                         /* Specify the JSX Fragment reference used for fragments when targeting React JSX emit e.g. 'React.Fragment' or 'Fragment'. */\n    // \"jsxImportSource\": \"\",                            /* Specify module specifier used to import the JSX factory functions when using 'jsx: react-jsx*'. */\n    // \"reactNamespace\": \"\",                             /* Specify the object invoked for 'createElement'. This only applies when targeting 'react' JSX emit. */\n    // \"noLib\": true,                                    /* Disable including any library files, including the default lib.d.ts. */\n    // \"useDefineForClassFields\": true,                  /* Emit ECMAScript-standard-compliant class fields. */\n    // \"moduleDetection\": \"auto\",                        /* Control what method is used to detect module-format JS files. */\n\n    /* Modules */\n    \"module\": \"commonjs\",                                /* Specify what module code is generated. */\n    // \"rootDir\": \"./\",                                  /* Specify the root folder within your source files. */\n    // \"moduleResolution\": \"node\",                       /* Specify how TypeScript looks up a file from a given module specifier. */\n    // \"baseUrl\": \"./\",                                  /* Specify the base directory to resolve non-relative module names. */\n    \"paths\": {\n      \"@ORGANIZATION/PROJECT-api/lib/*\": [\"./src/api/*\"],\n      \"@ORGANIZATION/PROJECT-api\": [\"./src/api\"],\n    },                                      /* Specify a set of entries that re-map imports to additional lookup locations. */\n    // \"rootDirs\": [],                                   /* Allow multiple folders to be treated as one when resolving modules. */\n    // \"typeRoots\": [],                                  /* Specify multiple folders that act like './node_modules/@types'. */\n    // \"types\": [],                                      /* Specify type package names to be included without being referenced in a source file. */\n    // \"allowUmdGlobalAccess\": true,                     /* Allow accessing UMD globals from modules. */\n    // \"moduleSuffixes\": [],                             /* List of file name suffixes to search when resolving a module. */\n    // \"resolveJsonModule\": true,                        /* Enable importing .json files. */\n    // \"noResolve\": true,                                /* Disallow 'import's, 'require's or '<reference>'s from expanding the number of files TypeScript should add to a project. */\n\n    /* JavaScript Support */\n    // \"allowJs\": true,                                  /* Allow JavaScript files to be a part of your program. Use the 'checkJS' option to get errors from these files. */\n    // \"checkJs\": true,                                  /* Enable error reporting in type-checked JavaScript files. */\n    // \"maxNodeModuleJsDepth\": 1,                        /* Specify the maximum folder depth used for checking JavaScript files from 'node_modules'. Only applicable with 'allowJs'. */\n\n    /* Emit */\n    // \"declaration\": true,                              /* Generate .d.ts files from TypeScript and JavaScript files in your project. */\n    // \"declarationMap\": true,                           /* Create sourcemaps for d.ts files. */\n    // \"emitDeclarationOnly\": true,                      /* Only output d.ts files and not JavaScript files. */\n    \"sourceMap\": true,                                /* Create source map files for emitted JavaScript files. */\n    // \"outFile\": \"./\",                                  /* Specify a file that bundles all outputs into one JavaScript file. If 'declaration' is true, also designates a file that bundles all .d.ts output. */\n    \"outDir\": \"./lib\",                                   /* Specify an output folder for all emitted files. */\n    // \"removeComments\": true,                           /* Disable emitting comments. */\n    // \"noEmit\": true,                                   /* Disable emitting files from a compilation. */\n    // \"importHelpers\": true,                            /* Allow importing helper functions from tslib once per project, instead of including them per-file. */\n    // \"importsNotUsedAsValues\": \"remove\",               /* Specify emit/checking behavior for imports that are only used for types. */\n    // \"downlevelIteration\": true,                       /* Emit more compliant, but verbose and less performant JavaScript for iteration. */\n    // \"sourceRoot\": \"\",                                 /* Specify the root path for debuggers to find the reference source code. */\n    // \"mapRoot\": \"\",                                    /* Specify the location where debugger should locate map files instead of generated locations. */\n    // \"inlineSourceMap\": true,                          /* Include sourcemap files inside the emitted JavaScript. */\n    // \"inlineSources\": true,                            /* Include source code in the sourcemaps inside the emitted JavaScript. */\n    // \"emitBOM\": true,                                  /* Emit a UTF-8 Byte Order Mark (BOM) in the beginning of output files. */\n    \"newLine\": \"lf\",                                /* Set the newline character for emitting files. */\n    \"stripInternal\": true,                            /* Disable emitting declarations that have '@internal' in their JSDoc comments. */\n    // \"noEmitHelpers\": true,                            /* Disable generating custom helper functions like '__extends' in compiled output. */\n    // \"noEmitOnError\": true,                            /* Disable emitting files if any type checking errors are reported. */\n    // \"preserveConstEnums\": true,                       /* Disable erasing 'const enum' declarations in generated code. */\n    // \"declarationDir\": \"./\",                           /* Specify the output directory for generated declaration files. */\n    // \"preserveValueImports\": true,                     /* Preserve unused imported values in the JavaScript output that would otherwise be removed. */\n\n    /* Interop Constraints */\n    // \"isolatedModules\": true,                          /* Ensure that each file can be safely transpiled without relying on other imports. */\n    // \"allowSyntheticDefaultImports\": true,             /* Allow 'import x from y' when a module doesn't have a default export. */\n    \"esModuleInterop\": true,                             /* Emit additional JavaScript to ease support for importing CommonJS modules. This enables 'allowSyntheticDefaultImports' for type compatibility. */\n    // \"preserveSymlinks\": true,                         /* Disable resolving symlinks to their realpath. This correlates to the same flag in node. */\n    \"forceConsistentCasingInFileNames\": true,            /* Ensure that casing is correct in imports. */\n\n    /* Type Checking */\n    \"strict\": true,                                      /* Enable all strict type-checking options. */\n    // \"noImplicitAny\": true,                            /* Enable error reporting for expressions and declarations with an implied 'any' type. */\n    // \"strictNullChecks\": true,                         /* When type checking, take into account 'null' and 'undefined'. */\n    // \"strictFunctionTypes\": true,                      /* When assigning functions, check to ensure parameters and the return values are subtype-compatible. */\n    // \"strictBindCallApply\": true,                      /* Check that the arguments for 'bind', 'call', and 'apply' methods match the original function. */\n    // \"strictPropertyInitialization\": true,             /* Check for class properties that are declared but not set in the constructor. */\n    // \"noImplicitThis\": true,                           /* Enable error reporting when 'this' is given the type 'any'. */\n    // \"useUnknownInCatchVariables\": true,               /* Default catch clause variables as 'unknown' instead of 'any'. */\n    // \"alwaysStrict\": true,                             /* Ensure 'use strict' is always emitted. */\n    \"noUnusedLocals\": true,                           /* Enable error reporting when local variables aren't read. */\n    \"noUnusedParameters\": true,                       /* Raise an error when a function parameter isn't read. */\n    // \"exactOptionalPropertyTypes\": true,               /* Interpret optional property types as written, rather than adding 'undefined'. */\n    \"noImplicitReturns\": true,                        /* Enable error reporting for codepaths that do not explicitly return in a function. */\n    \"noFallthroughCasesInSwitch\": true,               /* Enable error reporting for fallthrough cases in switch statements. */\n    // \"noUncheckedIndexedAccess\": true,                 /* Add 'undefined' to a type when accessed using an index. */\n    // \"noImplicitOverride\": true,                       /* Ensure overriding members in derived classes are marked with an override modifier. */\n    // \"noPropertyAccessFromIndexSignature\": true,       /* Enforces using indexed accessors for keys declared using an indexed type. */\n    // \"allowUnusedLabels\": true,                        /* Disable error reporting for unused labels. */\n    // \"allowUnreachableCode\": true,                     /* Disable error reporting for unreachable code. */\n\n    /* Completeness */\n    // \"skipDefaultLibCheck\": true,                      /* Skip type checking .d.ts files that are included with TypeScript. */\n    \"skipLibCheck\": true,                                 /* Skip type checking all .d.ts files. */\n    \"plugins\": [\n      { \"transform\": \"typescript-transform-paths\" },\n      { \"transform\": \"typia/lib/transform\" },\n      { \n        \"transform\": \"@nestia/core/lib/transform\",\n        /**\n         * Validate request body.\n         * \n         *   - \"assert\": Use typia.assert() function\n         *   - \"is\": Use typia.is() function\n         *   - \"validate\": Use typia.validate() function\n         *   - \"assertEquals\": Use typia.assertEquals() function\n         *   - \"equals\": Use typia.equals() function\n         *   - \"validateEquals\": Use typia.validateEquals() function\n         */\n        \"validate\": \"validate\",\n        /**\n         * Validate JSON typed response body.\n         * \n         *   - \"assert\": Use typia.assertStringify() function\n         *   - \"is\": Use typia.isStringify() function\n         *   - \"validate\": Use typia.validateStringify() function\n         *   - \"validate.log\": typia.validateStringify(), but do not throw and just log it\n         *   - \"stringify\": Use typia.stringify() function, but dangerous\n         *   - null: Just use JSON.stringify() function, without boosting\n         */\n        \"stringify\": \"assert\",\n      },\n    ]\n  },\n  \"include\": [\n    \"src\"\n  ],\n  \"exclude\": [\n    \"node_modules\",\n    \"packages\",\n  ]\n}\n",
  "src/MyModule.ts": "import { Module } from \"@nestjs/common\";\n\nimport { MonitorsHealthController } from \"./controllers/monitors/health/MonitorsHealthController\";\nimport { MonitorsPerformanceController } from \"./controllers/monitors/performance/MonitorsPerformanceController\";\nimport { MonitorsSystemController } from \"./controllers/monitors/system/MonitorsSystemController\";\nimport { ShoppingsAdminsAuthenticateController } from \"./controllers/shoppings/admins/authenticate/ShoppingsAdminsAuthenticateController\";\nimport { ShoppingsAdminsAuthenticateLoginController } from \"./controllers/shoppings/admins/authenticate/login/ShoppingsAdminsAuthenticateLoginController\";\nimport { ShoppingsAdminsCouponsController } from \"./controllers/shoppings/admins/coupons/ShoppingsAdminsCouponsController\";\nimport { ShoppingsAdminsDepositsController } from \"./controllers/shoppings/admins/deposits/ShoppingsAdminsDepositsController\";\nimport { ShoppingsAdminsDepositsGetController } from \"./controllers/shoppings/admins/deposits/get/ShoppingsAdminsDepositsGetController\";\nimport { ShoppingsAdminsMileagesController } from \"./controllers/shoppings/admins/mileages/ShoppingsAdminsMileagesController\";\nimport { ShoppingsAdminsMileagesGetController } from \"./controllers/shoppings/admins/mileages/get/ShoppingsAdminsMileagesGetController\";\nimport { ShoppingsAdminsMileagesDonationsController } from \"./controllers/shoppings/admins/mileages/donations/ShoppingsAdminsMileagesDonationsController\";\nimport { ShoppingsAdminsOrdersController } from \"./controllers/shoppings/admins/orders/ShoppingsAdminsOrdersController\";\nimport { ShoppingsAdminsSalesDetailsController } from \"./controllers/shoppings/admins/sales/details/ShoppingsAdminsSalesDetailsController\";\nimport { ShoppingsAdminsSalesController } from \"./controllers/shoppings/admins/sales/ShoppingsAdminsSalesController\";\nimport { ShoppingsAdminsSalesQuestionsCommentsController } from \"./controllers/shoppings/admins/sales/questions/comments/ShoppingsAdminsSalesQuestionsCommentsController\";\nimport { ShoppingsAdminsSalesQuestionsController } from \"./controllers/shoppings/admins/sales/questions/ShoppingsAdminsSalesQuestionsController\";\nimport { ShoppingsAdminsSalesQuestionsAbridgesController } from \"./controllers/shoppings/admins/sales/questions/abridges/ShoppingsAdminsSalesQuestionsAbridgesController\";\nimport { ShoppingsAdminsSalesReviewsCommentsController } from \"./controllers/shoppings/admins/sales/reviews/comments/ShoppingsAdminsSalesReviewsCommentsController\";\nimport { ShoppingsAdminsSalesReviewsController } from \"./controllers/shoppings/admins/sales/reviews/ShoppingsAdminsSalesReviewsController\";\nimport { ShoppingsAdminsSalesReviewsAbridgesController } from \"./controllers/shoppings/admins/sales/reviews/abridges/ShoppingsAdminsSalesReviewsAbridgesController\";\nimport { ShoppingsAdminsSalesSnapshotsController } from \"./controllers/shoppings/admins/sales/snapshots/ShoppingsAdminsSalesSnapshotsController\";\nimport { ShoppingsAdminsSalesSnapshotsFlipController } from \"./controllers/shoppings/admins/sales/snapshots/flip/ShoppingsAdminsSalesSnapshotsFlipController\";\nimport { ShoppingsAdminsSystematicChannelsCategoriesController } from \"./controllers/shoppings/admins/systematic/channels/categories/ShoppingsAdminsSystematicChannelsCategoriesController\";\nimport { ShoppingsAdminsSystematicChannelsCategoriesMergeController } from \"./controllers/shoppings/admins/systematic/channels/categories/merge/ShoppingsAdminsSystematicChannelsCategoriesMergeController\";\nimport { ShoppingsAdminsSystematicChannelsCategoriesInvertController } from \"./controllers/shoppings/admins/systematic/channels/categories/invert/ShoppingsAdminsSystematicChannelsCategoriesInvertController\";\nimport { ShoppingsAdminsSystematicChannelsController } from \"./controllers/shoppings/admins/systematic/channels/ShoppingsAdminsSystematicChannelsController\";\nimport { ShoppingsAdminsSystematicChannelsMergeController } from \"./controllers/shoppings/admins/systematic/channels/merge/ShoppingsAdminsSystematicChannelsMergeController\";\nimport { ShoppingsAdminsSystematicChannelsHierarchicalController } from \"./controllers/shoppings/admins/systematic/channels/hierarchical/ShoppingsAdminsSystematicChannelsHierarchicalController\";\nimport { ShoppingsAdminsSystematicChannelsGetController } from \"./controllers/shoppings/admins/systematic/channels/get/ShoppingsAdminsSystematicChannelsGetController\";\nimport { ShoppingsAdminsSystematicSectionsController } from \"./controllers/shoppings/admins/systematic/sections/ShoppingsAdminsSystematicSectionsController\";\nimport { ShoppingsAdminsSystematicSectionsMergeController } from \"./controllers/shoppings/admins/systematic/sections/merge/ShoppingsAdminsSystematicSectionsMergeController\";\nimport { ShoppingsAdminsSystematicSectionsGetController } from \"./controllers/shoppings/admins/systematic/sections/get/ShoppingsAdminsSystematicSectionsGetController\";\nimport { ShoppingsCustomersAuthenticateRefreshController } from \"./controllers/shoppings/customers/authenticate/refresh/ShoppingsCustomersAuthenticateRefreshController\";\nimport { ShoppingsCustomersAuthenticateController } from \"./controllers/shoppings/customers/authenticate/ShoppingsCustomersAuthenticateController\";\nimport { ShoppingsCustomersAuthenticateJoinController } from \"./controllers/shoppings/customers/authenticate/join/ShoppingsCustomersAuthenticateJoinController\";\nimport { ShoppingsCustomersAuthenticateLoginController } from \"./controllers/shoppings/customers/authenticate/login/ShoppingsCustomersAuthenticateLoginController\";\nimport { ShoppingsCustomersAuthenticateActivateController } from \"./controllers/shoppings/customers/authenticate/activate/ShoppingsCustomersAuthenticateActivateController\";\nimport { ShoppingsCustomersAuthenticateExternalController } from \"./controllers/shoppings/customers/authenticate/external/ShoppingsCustomersAuthenticateExternalController\";\nimport { ShoppingsCustomersAuthenticatePasswordChangeController } from \"./controllers/shoppings/customers/authenticate/password/change/ShoppingsCustomersAuthenticatePasswordChangeController\";\nimport { ShoppingsCustomersCouponsController } from \"./controllers/shoppings/customers/coupons/ShoppingsCustomersCouponsController\";\nimport { ShoppingsCustomersCouponsTicketsController } from \"./controllers/shoppings/customers/coupons/tickets/ShoppingsCustomersCouponsTicketsController\";\nimport { ShoppingsCustomersDepositsChargesController } from \"./controllers/shoppings/customers/deposits/charges/ShoppingsCustomersDepositsChargesController\";\nimport { ShoppingsCustomersDepositsChargesPublishAbleController } from \"./controllers/shoppings/customers/deposits/charges/publish/able/ShoppingsCustomersDepositsChargesPublishAbleController\";\nimport { ShoppingsCustomersDepositsChargesPublishController } from \"./controllers/shoppings/customers/deposits/charges/publish/ShoppingsCustomersDepositsChargesPublishController\";\nimport { ShoppingsCustomersDepositsHistoriesController } from \"./controllers/shoppings/customers/deposits/histories/ShoppingsCustomersDepositsHistoriesController\";\nimport { ShoppingsCustomersDepositsHistoriesBalanceController } from \"./controllers/shoppings/customers/deposits/histories/balance/ShoppingsCustomersDepositsHistoriesBalanceController\";\nimport { ShoppingsCustomersMileagesHistoriesController } from \"./controllers/shoppings/customers/mileages/histories/ShoppingsCustomersMileagesHistoriesController\";\nimport { ShoppingsCustomersMileagesHistoriesBalanceController } from \"./controllers/shoppings/customers/mileages/histories/balance/ShoppingsCustomersMileagesHistoriesBalanceController\";\nimport { ShoppingsCustomersCartsCommoditiesController } from \"./controllers/shoppings/customers/carts/commodities/ShoppingsCustomersCartsCommoditiesController\";\nimport { ShoppingsCustomersCartsCommoditiesReplicaController } from \"./controllers/shoppings/customers/carts/commodities/replica/ShoppingsCustomersCartsCommoditiesReplicaController\";\nimport { ShoppingsCustomersCartsCommoditiesDiscountableController } from \"./controllers/shoppings/customers/carts/commodities/discountable/ShoppingsCustomersCartsCommoditiesDiscountableController\";\nimport { ShoppingsCustomersOrdersController } from \"./controllers/shoppings/customers/orders/ShoppingsCustomersOrdersController\";\nimport { ShoppingsCustomersOrdersDirectController } from \"./controllers/shoppings/customers/orders/direct/ShoppingsCustomersOrdersDirectController\";\nimport { ShoppingsCustomersOrdersPriceController } from \"./controllers/shoppings/customers/orders/price/ShoppingsCustomersOrdersPriceController\";\nimport { ShoppingsCustomersOrdersDiscountableController } from \"./controllers/shoppings/customers/orders/discountable/ShoppingsCustomersOrdersDiscountableController\";\nimport { ShoppingsCustomersOrdersDiscountController } from \"./controllers/shoppings/customers/orders/discount/ShoppingsCustomersOrdersDiscountController\";\nimport { ShoppingsCustomersOrdersGoodsConfirmController } from \"./controllers/shoppings/customers/orders/goods/confirm/ShoppingsCustomersOrdersGoodsConfirmController\";\nimport { ShoppingsCustomersOrdersPublishAbleController } from \"./controllers/shoppings/customers/orders/publish/able/ShoppingsCustomersOrdersPublishAbleController\";\nimport { ShoppingsCustomersOrdersPublishController } from \"./controllers/shoppings/customers/orders/publish/ShoppingsCustomersOrdersPublishController\";\nimport { ShoppingsCustomersSalesDetailsController } from \"./controllers/shoppings/customers/sales/details/ShoppingsCustomersSalesDetailsController\";\nimport { ShoppingsCustomersSalesController } from \"./controllers/shoppings/customers/sales/ShoppingsCustomersSalesController\";\nimport { ShoppingsCustomersSalesQuestionsCommentsController } from \"./controllers/shoppings/customers/sales/questions/comments/ShoppingsCustomersSalesQuestionsCommentsController\";\nimport { ShoppingsCustomersSalesQuestionsController } from \"./controllers/shoppings/customers/sales/questions/ShoppingsCustomersSalesQuestionsController\";\nimport { ShoppingsCustomersSalesQuestionsAbridgesController } from \"./controllers/shoppings/customers/sales/questions/abridges/ShoppingsCustomersSalesQuestionsAbridgesController\";\nimport { ShoppingsCustomersSalesReviewsCommentsController } from \"./controllers/shoppings/customers/sales/reviews/comments/ShoppingsCustomersSalesReviewsCommentsController\";\nimport { ShoppingsCustomersSalesReviewsController } from \"./controllers/shoppings/customers/sales/reviews/ShoppingsCustomersSalesReviewsController\";\nimport { ShoppingsCustomersSalesReviewsAbridgesController } from \"./controllers/shoppings/customers/sales/reviews/abridges/ShoppingsCustomersSalesReviewsAbridgesController\";\nimport { ShoppingsCustomersSalesSnapshotsController } from \"./controllers/shoppings/customers/sales/snapshots/ShoppingsCustomersSalesSnapshotsController\";\nimport { ShoppingsCustomersSalesSnapshotsFlipController } from \"./controllers/shoppings/customers/sales/snapshots/flip/ShoppingsCustomersSalesSnapshotsFlipController\";\nimport { ShoppingsCustomersSystematicChannelsCategoriesController } from \"./controllers/shoppings/customers/systematic/channels/categories/ShoppingsCustomersSystematicChannelsCategoriesController\";\nimport { ShoppingsCustomersSystematicChannelsCategoriesInvertController } from \"./controllers/shoppings/customers/systematic/channels/categories/invert/ShoppingsCustomersSystematicChannelsCategoriesInvertController\";\nimport { ShoppingsCustomersSystematicChannelsController } from \"./controllers/shoppings/customers/systematic/channels/ShoppingsCustomersSystematicChannelsController\";\nimport { ShoppingsCustomersSystematicChannelsHierarchicalController } from \"./controllers/shoppings/customers/systematic/channels/hierarchical/ShoppingsCustomersSystematicChannelsHierarchicalController\";\nimport { ShoppingsCustomersSystematicChannelsGetController } from \"./controllers/shoppings/customers/systematic/channels/get/ShoppingsCustomersSystematicChannelsGetController\";\nimport { ShoppingsCustomersSystematicSectionsController } from \"./controllers/shoppings/customers/systematic/sections/ShoppingsCustomersSystematicSectionsController\";\nimport { ShoppingsCustomersSystematicSectionsGetController } from \"./controllers/shoppings/customers/systematic/sections/get/ShoppingsCustomersSystematicSectionsGetController\";\nimport { ShoppingsSellersAuthenticateController } from \"./controllers/shoppings/sellers/authenticate/ShoppingsSellersAuthenticateController\";\nimport { ShoppingsSellersAuthenticateLoginController } from \"./controllers/shoppings/sellers/authenticate/login/ShoppingsSellersAuthenticateLoginController\";\nimport { ShoppingsSellersDeliveriesController } from \"./controllers/shoppings/sellers/deliveries/ShoppingsSellersDeliveriesController\";\nimport { ShoppingsSellersDeliveriesIncompletesController } from \"./controllers/shoppings/sellers/deliveries/incompletes/ShoppingsSellersDeliveriesIncompletesController\";\nimport { ShoppingsSellersDeliveriesJourneysController } from \"./controllers/shoppings/sellers/deliveries/journeys/ShoppingsSellersDeliveriesJourneysController\";\nimport { ShoppingsSellersDeliveriesJourneysCompleteController } from \"./controllers/shoppings/sellers/deliveries/journeys/complete/ShoppingsSellersDeliveriesJourneysCompleteController\";\nimport { ShoppingsSellersDeliveriesShippersController } from \"./controllers/shoppings/sellers/deliveries/shippers/ShoppingsSellersDeliveriesShippersController\";\nimport { ShoppingsSellersCouponsController } from \"./controllers/shoppings/sellers/coupons/ShoppingsSellersCouponsController\";\nimport { ShoppingsSellersOrdersController } from \"./controllers/shoppings/sellers/orders/ShoppingsSellersOrdersController\";\nimport { ShoppingsSellersSalesController } from \"./controllers/shoppings/sellers/sales/ShoppingsSellersSalesController\";\nimport { ShoppingsSellersSalesOpenController } from \"./controllers/shoppings/sellers/sales/open/ShoppingsSellersSalesOpenController\";\nimport { ShoppingsSellersSalesReplicaController } from \"./controllers/shoppings/sellers/sales/replica/ShoppingsSellersSalesReplicaController\";\nimport { ShoppingsSellersSalesPauseController } from \"./controllers/shoppings/sellers/sales/pause/ShoppingsSellersSalesPauseController\";\nimport { ShoppingsSellersSalesSuspendController } from \"./controllers/shoppings/sellers/sales/suspend/ShoppingsSellersSalesSuspendController\";\nimport { ShoppingsSellersSalesRestoreController } from \"./controllers/shoppings/sellers/sales/restore/ShoppingsSellersSalesRestoreController\";\nimport { ShoppingsSellersSalesDetailsController } from \"./controllers/shoppings/sellers/sales/details/ShoppingsSellersSalesDetailsController\";\nimport { ShoppingsSellersSalesQuestionsAnswerController } from \"./controllers/shoppings/sellers/sales/questions/answer/ShoppingsSellersSalesQuestionsAnswerController\";\nimport { ShoppingsSellersSalesQuestionsCommentsController } from \"./controllers/shoppings/sellers/sales/questions/comments/ShoppingsSellersSalesQuestionsCommentsController\";\nimport { ShoppingsSellersSalesQuestionsController } from \"./controllers/shoppings/sellers/sales/questions/ShoppingsSellersSalesQuestionsController\";\nimport { ShoppingsSellersSalesQuestionsAbridgesController } from \"./controllers/shoppings/sellers/sales/questions/abridges/ShoppingsSellersSalesQuestionsAbridgesController\";\nimport { ShoppingsSellersSalesReviewsAnswerController } from \"./controllers/shoppings/sellers/sales/reviews/answer/ShoppingsSellersSalesReviewsAnswerController\";\nimport { ShoppingsSellersSalesReviewsCommentsController } from \"./controllers/shoppings/sellers/sales/reviews/comments/ShoppingsSellersSalesReviewsCommentsController\";\nimport { ShoppingsSellersSalesReviewsController } from \"./controllers/shoppings/sellers/sales/reviews/ShoppingsSellersSalesReviewsController\";\nimport { ShoppingsSellersSalesReviewsAbridgesController } from \"./controllers/shoppings/sellers/sales/reviews/abridges/ShoppingsSellersSalesReviewsAbridgesController\";\nimport { ShoppingsSellersSalesSnapshotsReplicaController } from \"./controllers/shoppings/sellers/sales/snapshots/replica/ShoppingsSellersSalesSnapshotsReplicaController\";\nimport { ShoppingsSellersSalesSnapshotsController } from \"./controllers/shoppings/sellers/sales/snapshots/ShoppingsSellersSalesSnapshotsController\";\nimport { ShoppingsSellersSalesSnapshotsFlipController } from \"./controllers/shoppings/sellers/sales/snapshots/flip/ShoppingsSellersSalesSnapshotsFlipController\";\nimport { ShoppingsSellersSalesUnitsStocksSupplementsController } from \"./controllers/shoppings/sellers/sales/units/stocks/supplements/ShoppingsSellersSalesUnitsStocksSupplementsController\";\nimport { ShoppingsSellersSystematicChannelsCategoriesController } from \"./controllers/shoppings/sellers/systematic/channels/categories/ShoppingsSellersSystematicChannelsCategoriesController\";\nimport { ShoppingsSellersSystematicChannelsCategoriesInvertController } from \"./controllers/shoppings/sellers/systematic/channels/categories/invert/ShoppingsSellersSystematicChannelsCategoriesInvertController\";\nimport { ShoppingsSellersSystematicChannelsController } from \"./controllers/shoppings/sellers/systematic/channels/ShoppingsSellersSystematicChannelsController\";\nimport { ShoppingsSellersSystematicChannelsHierarchicalController } from \"./controllers/shoppings/sellers/systematic/channels/hierarchical/ShoppingsSellersSystematicChannelsHierarchicalController\";\nimport { ShoppingsSellersSystematicChannelsGetController } from \"./controllers/shoppings/sellers/systematic/channels/get/ShoppingsSellersSystematicChannelsGetController\";\nimport { ShoppingsSellersSystematicSectionsController } from \"./controllers/shoppings/sellers/systematic/sections/ShoppingsSellersSystematicSectionsController\";\nimport { ShoppingsSellersSystematicSectionsGetController } from \"./controllers/shoppings/sellers/systematic/sections/get/ShoppingsSellersSystematicSectionsGetController\";\n\n@Module({\n  controllers: [\n    MonitorsHealthController,\n    MonitorsPerformanceController,\n    MonitorsSystemController,\n    ShoppingsAdminsAuthenticateController,\n    ShoppingsAdminsAuthenticateLoginController,\n    ShoppingsAdminsCouponsController,\n    ShoppingsAdminsDepositsController,\n    ShoppingsAdminsDepositsGetController,\n    ShoppingsAdminsMileagesController,\n    ShoppingsAdminsMileagesGetController,\n    ShoppingsAdminsMileagesDonationsController,\n    ShoppingsAdminsOrdersController,\n    ShoppingsAdminsSalesDetailsController,\n    ShoppingsAdminsSalesController,\n    ShoppingsAdminsSalesQuestionsCommentsController,\n    ShoppingsAdminsSalesQuestionsController,\n    ShoppingsAdminsSalesQuestionsAbridgesController,\n    ShoppingsAdminsSalesReviewsCommentsController,\n    ShoppingsAdminsSalesReviewsController,\n    ShoppingsAdminsSalesReviewsAbridgesController,\n    ShoppingsAdminsSalesSnapshotsController,\n    ShoppingsAdminsSalesSnapshotsFlipController,\n    ShoppingsAdminsSystematicChannelsCategoriesController,\n    ShoppingsAdminsSystematicChannelsCategoriesMergeController,\n    ShoppingsAdminsSystematicChannelsCategoriesInvertController,\n    ShoppingsAdminsSystematicChannelsController,\n    ShoppingsAdminsSystematicChannelsMergeController,\n    ShoppingsAdminsSystematicChannelsHierarchicalController,\n    ShoppingsAdminsSystematicChannelsGetController,\n    ShoppingsAdminsSystematicSectionsController,\n    ShoppingsAdminsSystematicSectionsMergeController,\n    ShoppingsAdminsSystematicSectionsGetController,\n    ShoppingsCustomersAuthenticateRefreshController,\n    ShoppingsCustomersAuthenticateController,\n    ShoppingsCustomersAuthenticateJoinController,\n    ShoppingsCustomersAuthenticateLoginController,\n    ShoppingsCustomersAuthenticateActivateController,\n    ShoppingsCustomersAuthenticateExternalController,\n    ShoppingsCustomersAuthenticatePasswordChangeController,\n    ShoppingsCustomersCouponsController,\n    ShoppingsCustomersCouponsTicketsController,\n    ShoppingsCustomersDepositsChargesController,\n    ShoppingsCustomersDepositsChargesPublishAbleController,\n    ShoppingsCustomersDepositsChargesPublishController,\n    ShoppingsCustomersDepositsHistoriesController,\n    ShoppingsCustomersDepositsHistoriesBalanceController,\n    ShoppingsCustomersMileagesHistoriesController,\n    ShoppingsCustomersMileagesHistoriesBalanceController,\n    ShoppingsCustomersCartsCommoditiesController,\n    ShoppingsCustomersCartsCommoditiesReplicaController,\n    ShoppingsCustomersCartsCommoditiesDiscountableController,\n    ShoppingsCustomersOrdersController,\n    ShoppingsCustomersOrdersDirectController,\n    ShoppingsCustomersOrdersPriceController,\n    ShoppingsCustomersOrdersDiscountableController,\n    ShoppingsCustomersOrdersDiscountController,\n    ShoppingsCustomersOrdersGoodsConfirmController,\n    ShoppingsCustomersOrdersPublishAbleController,\n    ShoppingsCustomersOrdersPublishController,\n    ShoppingsCustomersSalesDetailsController,\n    ShoppingsCustomersSalesController,\n    ShoppingsCustomersSalesQuestionsCommentsController,\n    ShoppingsCustomersSalesQuestionsController,\n    ShoppingsCustomersSalesQuestionsAbridgesController,\n    ShoppingsCustomersSalesReviewsCommentsController,\n    ShoppingsCustomersSalesReviewsController,\n    ShoppingsCustomersSalesReviewsAbridgesController,\n    ShoppingsCustomersSalesSnapshotsController,\n    ShoppingsCustomersSalesSnapshotsFlipController,\n    ShoppingsCustomersSystematicChannelsCategoriesController,\n    ShoppingsCustomersSystematicChannelsCategoriesInvertController,\n    ShoppingsCustomersSystematicChannelsController,\n    ShoppingsCustomersSystematicChannelsHierarchicalController,\n    ShoppingsCustomersSystematicChannelsGetController,\n    ShoppingsCustomersSystematicSectionsController,\n    ShoppingsCustomersSystematicSectionsGetController,\n    ShoppingsSellersAuthenticateController,\n    ShoppingsSellersAuthenticateLoginController,\n    ShoppingsSellersDeliveriesController,\n    ShoppingsSellersDeliveriesIncompletesController,\n    ShoppingsSellersDeliveriesJourneysController,\n    ShoppingsSellersDeliveriesJourneysCompleteController,\n    ShoppingsSellersDeliveriesShippersController,\n    ShoppingsSellersCouponsController,\n    ShoppingsSellersOrdersController,\n    ShoppingsSellersSalesController,\n    ShoppingsSellersSalesOpenController,\n    ShoppingsSellersSalesReplicaController,\n    ShoppingsSellersSalesPauseController,\n    ShoppingsSellersSalesSuspendController,\n    ShoppingsSellersSalesRestoreController,\n    ShoppingsSellersSalesDetailsController,\n    ShoppingsSellersSalesQuestionsAnswerController,\n    ShoppingsSellersSalesQuestionsCommentsController,\n    ShoppingsSellersSalesQuestionsController,\n    ShoppingsSellersSalesQuestionsAbridgesController,\n    ShoppingsSellersSalesReviewsAnswerController,\n    ShoppingsSellersSalesReviewsCommentsController,\n    ShoppingsSellersSalesReviewsController,\n    ShoppingsSellersSalesReviewsAbridgesController,\n    ShoppingsSellersSalesSnapshotsReplicaController,\n    ShoppingsSellersSalesSnapshotsController,\n    ShoppingsSellersSalesSnapshotsFlipController,\n    ShoppingsSellersSalesUnitsStocksSupplementsController,\n    ShoppingsSellersSystematicChannelsCategoriesController,\n    ShoppingsSellersSystematicChannelsCategoriesInvertController,\n    ShoppingsSellersSystematicChannelsController,\n    ShoppingsSellersSystematicChannelsHierarchicalController,\n    ShoppingsSellersSystematicChannelsGetController,\n    ShoppingsSellersSystematicSectionsController,\n    ShoppingsSellersSystematicSectionsGetController,\n  ],\n})\nexport class MyModule {}\n",
  "src/controllers/monitors/health/MonitorsHealthController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute } from \"@nestia/core\";\nimport typia from \"typia\";\n\n@Controller(\"/monitors/health\")\nexport class MonitorsHealthController {\n  /**\n   * Health check API.\n   *\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get()\n  public async get(): Promise<void> {\n    return typia.random<void>();\n  }\n}\n",
  "src/controllers/monitors/performance/MonitorsPerformanceController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute } from \"@nestia/core\";\nimport typia from \"typia\";\n\nimport { IPerformance } from \"../../../api/structures/IPerformance\";\n\n@Controller(\"/monitors/performance\")\nexport class MonitorsPerformanceController {\n  /**\n   * Get performance information.\n   *\n   * Get perofmration information composed with CPU, memory and resource\n   * usage.\n   *\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get()\n  public async get(): Promise<IPerformance> {\n    return typia.random<IPerformance>();\n  }\n}\n",
  "src/controllers/monitors/system/MonitorsSystemController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute } from \"@nestia/core\";\nimport typia from \"typia\";\n\nimport { ISystem } from \"../../../api/structures/ISystem\";\n\n@Controller(\"/monitors/system\")\nexport class MonitorsSystemController {\n  /**\n   * Get system information.\n   *\n   * Get system information with commit and package information.\n   *\n   * As such information is a type of sensitive, response be encrypted.\n   *\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get()\n  public async get(): Promise<ISystem> {\n    return typia.random<ISystem>();\n  }\n}\n",
  "src/controllers/shoppings/admins/authenticate/ShoppingsAdminsAuthenticateController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody } from \"@nestia/core\";\nimport typia from \"typia\";\n\nimport { IShoppingAdministrator } from \"../../../../api/structures/IShoppingAdministrator\";\n\n@Controller(\"/shoppings/admins/authenticate\")\nexport class ShoppingsAdminsAuthenticateController {\n  /**\n   * Get administrator information.\n   *\n   * Get {@link IShoppingAdministrator.IInvert administrator} information of\n   * current {@link IShoppingCustomer customer}.\n   *\n   * If current {@link IShoppingMember member} is not an administrator, it\n   * throws 403 forbidden exception.\n   *\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get()\n  public async get(): Promise<IShoppingAdministrator.IInvert> {\n    return typia.random<IShoppingAdministrator.IInvert>();\n  }\n\n  /**\n   * Join as an administrator.\n   *\n   * Join as an administrator with\n   * {@link IShoppingAdministrator.IJoin joining info}.\n   *\n   * This method is allowed only when the {@link IShoppingCustomer customer}\n   * already has joined the {@link IShoppingMember membership}. IF not, he\n   * (she) must accomplish it before. If not, 403 forbidden exception would be\n   * thrown.\n   *\n   * @param body Joining request info\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Post()\n  public async post(\n    @TypedBody()\n    body: IShoppingAdministrator.IJoin,\n  ): Promise<IShoppingAdministrator.IInvert> {\n    body;\n    return typia.random<IShoppingAdministrator.IInvert>();\n  }\n}\n",
  "src/controllers/shoppings/admins/authenticate/login/ShoppingsAdminsAuthenticateLoginController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody } from \"@nestia/core\";\nimport typia from \"typia\";\n\nimport { IShoppingAdministrator } from \"../../../../../api/structures/IShoppingAdministrator\";\nimport { IShoppingMember } from \"../../../../../api/structures/IShoppingMember\";\n\n@Controller(\"/shoppings/admins/authenticate/login\")\nexport class ShoppingsAdminsAuthenticateLoginController {\n  /**\n   * Login as an administrator.\n   *\n   * Login as an administrator with\n   * {@link IShoppingAdministrator.ILogin login info}.\n   *\n   * This method has exactly same effect with\n   * {@link ShoppingApi.functional.customers.authenticate.login} function, but\n   * returned type is a llttle different. The similar function returns\n   * {@link IShoppingCustomer} type that starting from the customer\n   * information, so that you have to access to the administrator info through\n   * `customer.member.administrator`. In contrast with that, this method\n   * returns {@link IShoppingAdministrator.IInvert} type that starting from the\n   * administrator info, so that can access to the customer info through\n   * `administrator.customer`.\n   *\n   * Of course, to use this function, you had to {@link join} as an\n   * administrator before. If not, 403 forbidden exception would be thrown,\n   *\n   * @param body Login request info\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Put()\n  public async put(\n    @TypedBody()\n    body: IShoppingMember.ILogin,\n  ): Promise<IShoppingAdministrator.IInvert> {\n    body;\n    return typia.random<IShoppingAdministrator.IInvert>();\n  }\n}\n",
  "src/controllers/shoppings/admins/coupons/ShoppingsAdminsCouponsController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody, TypedParam } from \"@nestia/core\";\nimport typia from \"typia\";\n\nimport { IShoppingCoupon } from \"../../../../api/structures/IShoppingCoupon\";\nimport { IPageIShoppingCoupon } from \"../../../../api/structures/IPageIShoppingCoupon\";\n\n@Controller(\"/shoppings/admins/coupons\")\nexport class ShoppingsAdminsCouponsController {\n  /**\n   * Create a new coupon.\n   *\n   * Create a new {@link IShoppingCoupon coupon} with given information.\n   *\n   * By the way, if you are a {@link IShoppingSeller seller}, you have to add\n   * include direction's {@link IShoppingCouponSellerCriteria} or\n   * {@link IShoppingCouponSaleCriteria} condition. This is because only\n   * {@link IShoppingAdministrator administrators} can create a coupon which\n   * can be used throughout the market. Seller must limit the usage range by\n   * his/her {@link IShoppingSale sale(s)}.\n   *\n   * Of course, when administrator is planning to make a general coupon that\n   * can be used throughout the market, the administrator must get agree from\n   * the sellers who are going to be affected.\n   *\n   * @param body Creation info of the coupon\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Post()\n  public async post(\n    @TypedBody()\n    body: IShoppingCoupon.ICreate,\n  ): Promise<IShoppingCoupon> {\n    body;\n    return typia.random<IShoppingCoupon>();\n  }\n\n  /**\n   * List up every coupons.\n   *\n   * List up every {@link IShoppingCoupon coupons} with pagination.\n   *\n   * If you want, you can limit the result by configuring\n   * {@link IShoppingCoupon.IRequest.search search condition} in the request\n   * body. Also, it is possible to customize sequence order of records by\n   * configuring {@link IShoppingCoupon.IRequest.sort sort condition}.\n   *\n   * For reference, if you are a {@link IShoppingCustomer customer}, then only\n   * {@link IShoppingCouponTicket ticketable} coupons would be listed up.\n   * Otherwise, non-ticketable coupons would also be listed up.\n   *\n   * @param body Request info of pagination, searching and sorting\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patch(\n    @TypedBody()\n    body: IShoppingCoupon.IRequest,\n  ): Promise<IPageIShoppingCoupon> {\n    body;\n    return typia.random<IPageIShoppingCoupon>();\n  }\n\n  /**\n   * Get a coupon info.\n   *\n   * Get a {@link IShoppingCoupon coupon} information.\n   *\n   * If you are a {@link IShoppingCustomer customer}, then only\n   * {@link IShoppingCouponTicket ticketable} coupons are accessible. Non\n   * ticketable coupons cause 410 gone error. Otherwise you are a\n   * {@link IShoppingSeller seller} or\n   * {@link IShoppingAdministrator administrator}, non-ticketable coupons are\n   * also accessible.\n   *\n   * @param id Target coupon's {@link IShoppingCoupon.id }\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get(\":id\")\n  public async getById(\n    @TypedParam(\"id\")\n    id: string,\n  ): Promise<IShoppingCoupon> {\n    id;\n    return typia.random<IShoppingCoupon>();\n  }\n\n  /**\n   * Erase a coupon.\n   *\n   * Erase a {@link IShoppingCoupon coupon} with given ID.\n   *\n   * For reference, if there're some {@link IShoppingCouponTicket tickets}\n   * which are already issued from the target coupon, they would not be\n   * affected. Those tickets are still valid until their expration time.\n   *\n   * @param id Target coupon's {@link IShoppingCoupon.id }\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Delete(\":id\")\n  public async eraseById(\n    @TypedParam(\"id\")\n    id: string,\n  ): Promise<void> {\n    id;\n    return typia.random<void>();\n  }\n}\n",
  "src/controllers/shoppings/admins/deposits/ShoppingsAdminsDepositsController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody, TypedParam } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IShoppingDeposit } from \"../../../../api/structures/IShoppingDeposit\";\nimport { IPageIShoppingDeposit } from \"../../../../api/structures/IPageIShoppingDeposit\";\n\n@Controller(\"/shoppings/admins/deposits\")\nexport class ShoppingsAdminsDepositsController {\n  /**\n   * Create a new deposit metadata.\n   *\n   * Create a new {@link IShoppingDeposit deposit} metadata.\n   *\n   * This action means that adding a new origin reason of deposit's\n   * income/outcome. Of course, creating a new deposit record does not mean\n   * that automatically increase or decrease the\n   * {@link IShoppingCustomer customer}'s balance following the record's reason\n   * why. The logic must be developed manually in the backend side.\n   *\n   * @param body Creation information of deposit metadata\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Post()\n  public async post(\n    @TypedBody()\n    body: IShoppingDeposit.ICreate,\n  ): Promise<IShoppingDeposit> {\n    body;\n    return typia.random<IShoppingDeposit>();\n  }\n\n  /**\n   * Get deposit metadata list.\n   *\n   * List up every {@link IShoppingDeposit deposit} metadata information with\n   * {@link IPage pagination}.\n   *\n   * If you want, you can limit the result by configuring\n   * {@link IShoppingDeposit.IRequest.search search condition} in the request\n   * body. Also, it is possible to customize sequence order of records by\n   * configuring {@link IShoppingDeposit.IRequest.sort sort condition}.\n   *\n   * @param body Request info of pagination, searching and sorting\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patch(\n    @TypedBody()\n    body: IShoppingDeposit.IRequest,\n  ): Promise<IPageIShoppingDeposit> {\n    body;\n    return typia.random<IPageIShoppingDeposit>();\n  }\n\n  /**\n   * Get a deposit metadata.\n   *\n   * Get a {@link IShoppingDeposit deposit} metadata information with its ID.\n   *\n   * @param id Target deposit's {@link IShoppingDeposit.id }\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get(\":id\")\n  public async getById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<IShoppingDeposit> {\n    id;\n    return typia.random<IShoppingDeposit>();\n  }\n\n  /**\n   * Erase a deposit metadata.\n   *\n   * Erase a {@link IShoppingDeposit deposit} metadata, so that no more\n   * {@link IShoppingCustomer customer}'s balance does not be increased or\n   * decreased by the deposit's reason why.\n   *\n   * @param id Target deposit's {@link IShoppingDeposit.id }\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Delete(\":id\")\n  public async eraseById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<void> {\n    id;\n    return typia.random<void>();\n  }\n}\n",
  "src/controllers/shoppings/admins/deposits/get/ShoppingsAdminsDepositsGetController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedParam } from \"@nestia/core\";\nimport typia from \"typia\";\n\nimport { IShoppingDeposit } from \"../../../../../api/structures/IShoppingDeposit\";\n\n@Controller(\"/shoppings/admins/deposits/:code/get\")\nexport class ShoppingsAdminsDepositsGetController {\n  /**\n   * Get a deposit metadata by its code.\n   *\n   * Get a {@link IShoppingDeposit deposit} metadata information with its code.\n   *\n   * @param code Describe description as much as possible with clear and\n   *   concise words.\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get()\n  public async getByCode(\n    @TypedParam(\"code\")\n    code: string,\n  ): Promise<IShoppingDeposit> {\n    code;\n    return typia.random<IShoppingDeposit>();\n  }\n}\n",
  "src/controllers/shoppings/admins/mileages/ShoppingsAdminsMileagesController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody, TypedParam } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IShoppingMileage } from \"../../../../api/structures/IShoppingMileage\";\nimport { IPageIShoppingMileage } from \"../../../../api/structures/IPageIShoppingMileage\";\n\n@Controller(\"/shoppings/admins/mileages\")\nexport class ShoppingsAdminsMileagesController {\n  /**\n   * Create a new mileage metadata.\n   *\n   * Create a new {@link IShoppingMileage mileage} metadata.\n   *\n   * This action means that adding a new origin reason of mileage's\n   * income/outcome. Of course, creating a new mileage record does not mean\n   * that automatically increase or decrease the\n   * {@link IShoppingCustomer customer}'s balance following the record's reason\n   * why. The logic must be developed manually in the backend side.\n   *\n   * @param body Creation information of mileage metadata\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Post()\n  public async post(\n    @TypedBody()\n    body: IShoppingMileage.ICreate,\n  ): Promise<IShoppingMileage> {\n    body;\n    return typia.random<IShoppingMileage>();\n  }\n\n  /**\n   * Get mileage metadata list.\n   *\n   * List up every {@link IShoppingMileage mileage} metadata information with\n   * {@link IPage pagination}.\n   *\n   * If you want, you can limit the result by configuring\n   * {@link IShoppingMileage.IRequest.search search condition} in the request\n   * body. Also, it is possible to customize sequence order of records by\n   * configuring {@link IShoppingMileage.IRequest.sort sort condition}.\n   *\n   * @param body Request info of pagination, searching and sorting\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patch(\n    @TypedBody()\n    body: IShoppingMileage.IRequest,\n  ): Promise<IPageIShoppingMileage> {\n    body;\n    return typia.random<IPageIShoppingMileage>();\n  }\n\n  /**\n   * Get a mileage metadata.\n   *\n   * Get a {@link IShoppingMileage mileage} metadata information with its ID.\n   *\n   * @param id Target mileage's {@link IShoppingMileage.id }\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get(\":id\")\n  public async getById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<IShoppingMileage> {\n    id;\n    return typia.random<IShoppingMileage>();\n  }\n\n  /**\n   * Erase a mileage metadata.\n   *\n   * Erase a {@link IShoppingMileage mileage} metadata, so that no more\n   * {@link IShoppingCustomer customer}'s balance does not be increased or\n   * decreased by the mileage's reason why.\n   *\n   * @param id Target mileage's {@link IShoppingMileage.id }\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Delete(\":id\")\n  public async eraseById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<void> {\n    id;\n    return typia.random<void>();\n  }\n}\n",
  "src/controllers/shoppings/admins/mileages/get/ShoppingsAdminsMileagesGetController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedParam } from \"@nestia/core\";\nimport typia from \"typia\";\n\nimport { IShoppingMileage } from \"../../../../../api/structures/IShoppingMileage\";\n\n@Controller(\"/shoppings/admins/mileages/:code/get\")\nexport class ShoppingsAdminsMileagesGetController {\n  /**\n   * Get a mileage metadata by its code.\n   *\n   * Get a {@link IShoppingMileage mileage} metadata information with its code.\n   *\n   * @param code Describe description as much as possible with clear and\n   *   concise words.\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get()\n  public async getByCode(\n    @TypedParam(\"code\")\n    code: string,\n  ): Promise<IShoppingMileage> {\n    code;\n    return typia.random<IShoppingMileage>();\n  }\n}\n",
  "src/controllers/shoppings/admins/mileages/donations/ShoppingsAdminsMileagesDonationsController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody, TypedParam } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IShoppingMileageDonation } from \"../../../../../api/structures/IShoppingMileageDonation\";\nimport { IPageIShoppingMileageDonation } from \"../../../../../api/structures/IPageIShoppingMileageDonation\";\n\n@Controller(\"/shoppings/admins/mileages/donations\")\nexport class ShoppingsAdminsMileagesDonationsController {\n  /**\n   * Donate a mileage to a citizen.\n   *\n   * Donate a mileage to a specific {@link IShoppingCitizen citizen} from\n   * current {@link IShoppingAdministrator administrator}, with detailed reason\n   * why.\n   *\n   * Note that, as donating mileage affects to the citizen's balance and\n   * current shopping mall's operating profit, administrator must archive the\n   * detailed reason why the mileage is donated.\n   *\n   * @param body Request info of mileage donation\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Post()\n  public async post(\n    @TypedBody()\n    body: IShoppingMileageDonation.ICreate,\n  ): Promise<IShoppingMileageDonation> {\n    body;\n    return typia.random<IShoppingMileageDonation>();\n  }\n\n  /**\n   * List up every mileage donation histories.\n   *\n   * List up every {@link IShoppingMileageDonation mileage donation histories}\n   * with {@link IPage pagination}.\n   *\n   * If you want, you can limit the result by configuring\n   * {@link IShoppingMileageDonation.IRequest.search search condition} in the\n   * request body. Also, it is possible to customize sequence order of records\n   * by configuring {@link IShoppingMileageDonation.IRequest.sort sort}.\n   *\n   * @param body Request info of pagination, searching and sorting\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patch(\n    @TypedBody()\n    body: IShoppingMileageDonation.IRequest,\n  ): Promise<IPageIShoppingMileageDonation> {\n    body;\n    return typia.random<IPageIShoppingMileageDonation>();\n  }\n\n  /**\n   * Get a mileage donation history.\n   *\n   * Get a {@link IShoppingMileageDonation mileage donation history} with its\n   * ID.\n   *\n   * @param id Target history's {@link IShoppingMileageDonation.id }\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get(\":id\")\n  public async getById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<IShoppingMileageDonation> {\n    id;\n    return typia.random<IShoppingMileageDonation>();\n  }\n}\n",
  "src/controllers/shoppings/admins/orders/ShoppingsAdminsOrdersController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody, TypedParam } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IPageIShoppingOrder } from \"../../../../api/structures/IPageIShoppingOrder\";\nimport { IShoppingOrder } from \"../../../../api/structures/IShoppingOrder\";\n\n@Controller(\"/shoppings/admins/orders\")\nexport class ShoppingsAdminsOrdersController {\n  /**\n   * List up every orders.\n   *\n   * List up every {@link IShoppingOrder orders} with pagination.\n   *\n   * If you want, you can limit the result by configuring\n   * {@link IShoppingOrder.IRequest.search search condition} in the request\n   * body. Also, it is possible to customize sequence order of records by\n   * configuring {@link IShoppingOrder.IRequest.sort sort condition}.\n   *\n   * For reference, if you are a {@link IShoppingCustomer customer}, then you\n   * can list up your own orders, and it is not a matter whether the order has\n   * been {@link IShoppingOrderPublish.paid_at paid} or not.\n   *\n   * Otherwise you are a {@link IShoppingSeller seller} or\n   * {@link IShoppingAdministrator administrator}, then you can list up only\n   * paid orders. Also, in the seller case, only related\n   * {@link IShoppingOrder.goods goods} would be listed up in the order.\n   *\n   * @param body Request info of pagination, searching and sorting\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patch(\n    @TypedBody()\n    body: IShoppingOrder.IRequest,\n  ): Promise<IPageIShoppingOrder> {\n    body;\n    return typia.random<IPageIShoppingOrder>();\n  }\n\n  /**\n   * Get an order info.\n   *\n   * Get a detailed {@link IShoppingOrder order} information.\n   *\n   * If you are not a {@link IShoppingCustomer customer}, then you can't access\n   * to the order which has not been {@link IShoppingOrderPublish.paid_at paid}\n   * yet. In that case, 404 not found error would be thrown.\n   *\n   * @param id Target order's {@link IShoppingOrder.id }\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get(\":id\")\n  public async getById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<IShoppingOrder> {\n    id;\n    return typia.random<IShoppingOrder>();\n  }\n}\n",
  "src/controllers/shoppings/admins/sales/details/ShoppingsAdminsSalesDetailsController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody } from \"@nestia/core\";\nimport typia from \"typia\";\n\nimport { IPageIShoppingSale } from \"../../../../../api/structures/IPageIShoppingSale\";\nimport { IShoppingSale } from \"../../../../../api/structures/IShoppingSale\";\n\n@Controller(\"/shoppings/admins/sales/details\")\nexport class ShoppingsAdminsSalesDetailsController {\n  /**\n   * List up every sales.\n   *\n   * List up every {@link IShoppingSale sales} with detailed information.\n   *\n   * As you can see, returned sales are detailed, not summarized. If you want\n   * to get the summarized information of sale for a brief, use {@link index}\n   * function instead.\n   *\n   * For reference, if you're a {@link IShoppingSeller seller}, you can only\n   * access to the your own {@link IShoppingSale sale}s. Otherwise you're a\n   * {@link IShoppingCustomer customer}, you can see only the operating sales\n   * in the market. Instead, you can't see the unopened, closed, or suspended\n   * sales.\n   *\n   * > If you're an A.I. chatbot, please don't summarize the\n   * > {@link IShoppingSaleUnitStock stock information}. Just list up the every\n   * > stocks in the sale with detailed information.\n   *\n   * @param body Request info of pagination, searching and sorting\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patch(\n    @TypedBody()\n    body: IShoppingSale.IRequest,\n  ): Promise<IPageIShoppingSale> {\n    body;\n    return typia.random<IPageIShoppingSale>();\n  }\n}\n",
  "src/controllers/shoppings/admins/sales/ShoppingsAdminsSalesController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody, TypedParam } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IPageIShoppingSale } from \"../../../../api/structures/IPageIShoppingSale\";\nimport { IShoppingSale } from \"../../../../api/structures/IShoppingSale\";\n\n@Controller(\"/shoppings/admins/sales\")\nexport class ShoppingsAdminsSalesController {\n  /**\n   * List up every summarized sales.\n   *\n   * List up every {@link IShoppingSale.ISummary summarized sales}.\n   *\n   * As you can see, returned sales are summarized, not detailed. It does not\n   * contain the SKU (Stock Keeping Unit) information represented by the\n   * {@link IShoppingSaleUnitOption} and {@link IShoppingSaleUnitStock} types.\n   * If you want to get such detailed information of a sale, use `GET\n   * /shoppings/customers/sales/{id}` operation for each sale.\n   *\n   * > If you're an A.I. chatbot, and the user wants to buy or compose\n   * > {@link IShoppingCartCommodity shopping cart} from a sale, please call the\n   * > `GET /shoppings/customers/sales/{id}` operation at least once to the\n   * > target sale to get detailed SKU information about the sale. It needs to\n   * > be run at least once for the next steps.\n   *\n   * @param body Request info of pagination, searching and sorting\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patch(\n    @TypedBody()\n    body: IShoppingSale.IRequest,\n  ): Promise<IPageIShoppingSale.ISummary> {\n    body;\n    return typia.random<IPageIShoppingSale.ISummary>();\n  }\n\n  /**\n   * Get a sale with detailed information.\n   *\n   * Get a {@link IShoppingSale sale} with detailed information including the\n   * SKU (Stock Keeping Unit) information represented by the\n   * {@link IShoppingSaleUnitOption} and {@link IShoppingSaleUnitStock} types.\n   *\n   * > If you're an A.I. chatbot, and the user wants to buy or compose a\n   * > {@link IShoppingCartCommodity shopping cart} from a sale, please call this\n   * > operation at least once to the target sale to get detailed SKU\n   * > information about the sale.\n   *\n   * > It needs to be run at least once for the next steps. In other words, if\n   * > you A.I. agent has called this operation to a specific sale, you don't\n   * > need to call this operation again for the same sale.\n   *\n   * > Additionally, please do not summarize the SKU information. Just show the\n   * > every options and stocks in the sale with detailed information.\n   *\n   * @param id Target sale's {@link IShoppingSale.id }\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get(\":id\")\n  public async getById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<IShoppingSale> {\n    id;\n    return typia.random<IShoppingSale>();\n  }\n}\n",
  "src/controllers/shoppings/admins/sales/questions/comments/ShoppingsAdminsSalesQuestionsCommentsController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedParam, TypedBody } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IShoppingSaleInquiryComment } from \"../../../../../../api/structures/IShoppingSaleInquiryComment\";\nimport { IPageIShoppingSaleInquiryComment } from \"../../../../../../api/structures/IPageIShoppingSaleInquiryComment\";\n\n@Controller(\"/shoppings/admins/sales/:saleId/questions/:inquiryId/comments\")\nexport class ShoppingsAdminsSalesQuestionsCommentsController {\n  /**\n   * Create an inquiry comment.\n   *\n   * Create an {@link IShoppingSaleInquiryComment inquiry comment} of a\n   * {@link IShoppingSaleQuestion question} or\n   * {@link IShoppingSaleReview review}.\n   *\n   * For reference, if you're a {@link IShoppingSeller seller}, you can only\n   * create an inquiry comment to your own {@link IShoppingSale sale}'s\n   * inquiry. Otherwise, you can create an inquiry comment to every inquiries\n   * of the sales.\n   *\n   * @param saleId Belonged sale's {@link IShoppingSale.id }\n   * @param inquiryId Target inquiry's {@link IShoppingSaleInquiry.id }\n   * @param body Creation info of the inquiry comment\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Post()\n  public async postBySaleidAndInquiryid(\n    @TypedParam(\"saleId\")\n    saleId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"inquiryId\")\n    inquiryId: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IShoppingSaleInquiryComment.ICreate,\n  ): Promise<IShoppingSaleInquiryComment> {\n    saleId;\n    inquiryId;\n    body;\n    return typia.random<IShoppingSaleInquiryComment>();\n  }\n\n  /**\n   * List up every inquiry comments.\n   *\n   * List up every {@link IShoppingSaleInquiryComment inquiry comments} of a\n   * {@link IShoppingSaleQuestion question} or\n   * {@link IShoppingSaleReview review} with {@link IPage pagination}.\n   *\n   * If you want, you can limit the result by configuring\n   * {@link IShoppingSaleInquiryComment.IRequest.search search condition} in\n   * the request body. Also, it is possible to customize sequence order of\n   * records by configuring\n   * {@link IShoppingSaleInquiryComment.IRequest.sort sort condition}.\n   *\n   * By the way, if you're a {@link IShoppingSeller seller}, you can only\n   * access to the your own {@link IShoppingSale sale}'s inquiries. Otherwise,\n   * you can access to every inquiries of the sales.\n   *\n   * @param saleId Belonged sale's {@link IShoppingSale.id }\n   * @param inquiryId Belonged inquiry's {@link IShoppingSaleInquiry.id }\n   * @param body Request info of pagination, searching and sorting\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patchBySaleidAndInquiryid(\n    @TypedParam(\"saleId\")\n    saleId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"inquiryId\")\n    inquiryId: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IShoppingSaleInquiryComment.IRequest,\n  ): Promise<IPageIShoppingSaleInquiryComment> {\n    saleId;\n    inquiryId;\n    body;\n    return typia.random<IPageIShoppingSaleInquiryComment>();\n  }\n\n  /**\n   * Get an inquiry comment info.\n   *\n   * Get a detailed {@link IShoppingSaleInquiryComment inquiry comment}\n   * information of a {@link IShoppingSaleQuestion question} or\n   * {@link IShoppingSaleReview review}.\n   *\n   * For reference, if you're a {@link IShoppingSeller seller}, you can only\n   * access to the your own {@link IShoppingSale sale}'s inquiry comment.\n   * Otherwise, you can access to every inquiry comments of the sales.\n   *\n   * @param saleId Belonged sale's {@link IShoppingSale.id }\n   * @param inquiryId Belonged inquiry's {@link IShoppingSaleInquiry.id }\n   * @param id Target inquiry comment's {@link IShoppingSaleInquiryComment.id }\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get(\":id\")\n  public async getBySaleidAndInquiryidAndId(\n    @TypedParam(\"saleId\")\n    saleId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"inquiryId\")\n    inquiryId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<IShoppingSaleInquiryComment> {\n    saleId;\n    inquiryId;\n    id;\n    return typia.random<IShoppingSaleInquiryComment>();\n  }\n\n  /**\n   * Update an inquiry comment.\n   *\n   * Update an {@link IShoppingSaleInquiryComment inquiry comment} to a\n   * specific {@link IShoppingSaleQuestion question} or\n   * {@link IShoppingSaleReview review}.\n   *\n   * By the way, as is the general policy of this shopping mall regarding\n   * comments, modifying a comment does not actually change the existing\n   * content. Modified content is accumulated and recorded in the existing\n   * comment record as a new\n   * {@link IShoppingSaleInquiryComment.ISnapshot snapshot}. And this is made\n   * public to everyone, who can read this inquiry comment.\n   *\n   * This is to prevent customers or sellers from modifying their comments and\n   * manipulating the circumstances due to the nature of e-commerce, where\n   * disputes easily arise. That is, to preserve evidence.\n   *\n   * @param saleId Belonged sale's {@link IShoppingSale.id }\n   * @param inquiryId Belonged inquiry's {@link IShoppingSaleInquiry.id }\n   * @param id Target inquiry comment's {@link IShoppingSaleInquiryComment.id }\n   * @param body Update info of the inquiry comment\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Put(\":id\")\n  public async putBySaleidAndInquiryidAndId(\n    @TypedParam(\"saleId\")\n    saleId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"inquiryId\")\n    inquiryId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IShoppingSaleInquiryComment.ICreate,\n  ): Promise<IShoppingSaleInquiryComment.ISnapshot> {\n    saleId;\n    inquiryId;\n    id;\n    body;\n    return typia.random<IShoppingSaleInquiryComment.ISnapshot>();\n  }\n}\n",
  "src/controllers/shoppings/admins/sales/questions/ShoppingsAdminsSalesQuestionsController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedParam, TypedBody } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IPageIShoppingSaleQuestion } from \"../../../../../api/structures/IPageIShoppingSaleQuestion\";\nimport { IShoppingSaleQuestion } from \"../../../../../api/structures/IShoppingSaleQuestion\";\n\n@Controller(\"/shoppings/admins/sales/:saleId/questions\")\nexport class ShoppingsAdminsSalesQuestionsController {\n  /**\n   * List up every summarized questions.\n   *\n   * List up every {@link IShoppingSaleQuestion.ISummary summarized questions}\n   * of a {@link IShoppingSale sale}.\n   *\n   * As you can see, returned questions are summarized, not detailed. If you\n   * want to get the detailed information of a question, use {@link adridges}\n   * function or {@link at} function for each article.\n   *\n   * Also, returned question has {@link IShoppingSaleQuestion.ISummary.answer}\n   * property which means the formal answer from the {@link IShoppingSeller}.\n   * Additionally, returned question has another special property\n   * {@link IShoppingSaleQuestion.ISummary.secret} with masking to other\n   * princple properties, and it means only related actors can {@link at read}\n   * the question.\n   *\n   * For reference, if you're a {@link IShoppingSeller seller}, you can only\n   * access to the your own {@link IShoppingSale sale}'s questions. Otherwise,\n   * you can access to every questions of the sales.\n   *\n   * By the way, if you want, you can limit the result by configuring\n   * {@link IShoppingSaleQuestion.IRequest.search search condition} in the\n   * request body. Also, it is possible to customize sequence order of records\n   * by configuring\n   * {@link IShoppingSaleQuestion.IRequest.sort sort condition}.\n   *\n   * @param saleId Belonged sale's {@link IShoppingSale.id }\n   * @param body Request info of pagination, searching and sorting\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patchBySaleid(\n    @TypedParam(\"saleId\")\n    saleId: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IShoppingSaleQuestion.IRequest,\n  ): Promise<IPageIShoppingSaleQuestion.ISummary> {\n    saleId;\n    body;\n    return typia.random<IPageIShoppingSaleQuestion.ISummary>();\n  }\n\n  /**\n   * Get a question info.\n   *\n   * Get a detailed {@link IShoppingSaleQuestion question} information of a\n   * {@link IShoppingSale sale}.\n   *\n   * For reference, if you're a {@link IShoppingSeller seller}, you can only\n   * access to the your own {@link IShoppingSale sale}'s question. Otherwise\n   * you are a {@link IShoppingCustomer customer}, you can access to every\n   * questions of the sales except the {@link IShoppingSaleQuestion.secret}\n   * value is `false`.\n   *\n   * @param saleId Belonged sale's {@link IShoppingSale.id }\n   * @param id Target question's {@link IShoppingSaleQuestion.id }\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get(\":id\")\n  public async getBySaleidAndId(\n    @TypedParam(\"saleId\")\n    saleId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<IShoppingSaleQuestion> {\n    saleId;\n    id;\n    return typia.random<IShoppingSaleQuestion>();\n  }\n}\n",
  "src/controllers/shoppings/admins/sales/questions/abridges/ShoppingsAdminsSalesQuestionsAbridgesController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedParam, TypedBody } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IPageIShoppingSaleQuestion } from \"../../../../../../api/structures/IPageIShoppingSaleQuestion\";\nimport { IShoppingSaleQuestion } from \"../../../../../../api/structures/IShoppingSaleQuestion\";\n\n@Controller(\"/shoppings/admins/sales/:saleId/questions/abridges\")\nexport class ShoppingsAdminsSalesQuestionsAbridgesController {\n  /**\n   * List up every abridged questions.\n   *\n   * List up every {@link IShoppingSaleQuestion.IAbridge abridged questions} of\n   * a {@link IShoppingSale sale}.\n   *\n   * As you can see, returned questions are abridged, not detailed. If you\n   * want to get the detailed information of a question, use {@link at}\n   * function for each article.\n   *\n   * Also, returned question has {@link IShoppingSaleQuestion.IAridge.answer}\n   * property which means the formal answer from the {@link IShoppingSeller}.\n   * Additionally, returned question has another special property\n   * {@link IShoppingSaleQuestion.IAridge.secret} with masking to other\n   * princple properties, and it means only related actors can {@link at read}\n   * the question.\n   *\n   * For reference, if you're a {@link IShoppingSeller seller}, you can only\n   * access to the your own {@link IShoppingSale sale}'s questions. Otherwise,\n   * you can access to every questions of the sales.\n   *\n   * By the way, if you want, you can limit the result by configuring\n   * {@link IShoppingSaleQuestion.IRequest.search search condition} in the\n   * request body. Also, it is possible to customize sequence order of records\n   * by configuring\n   * {@link IShoppingSaleQuestion.IRequest.sort sort condition}.\n   *\n   * @param saleId Belonged sale's {@link IShoppingSale.id }\n   * @param body Request info of pagination, searching and sorting\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patchBySaleid(\n    @TypedParam(\"saleId\")\n    saleId: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IShoppingSaleQuestion.IRequest,\n  ): Promise<IPageIShoppingSaleQuestion.IAbridge> {\n    saleId;\n    body;\n    return typia.random<IPageIShoppingSaleQuestion.IAbridge>();\n  }\n}\n",
  "src/controllers/shoppings/admins/sales/reviews/comments/ShoppingsAdminsSalesReviewsCommentsController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedParam, TypedBody } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IShoppingSaleInquiryComment } from \"../../../../../../api/structures/IShoppingSaleInquiryComment\";\nimport { IPageIShoppingSaleInquiryComment } from \"../../../../../../api/structures/IPageIShoppingSaleInquiryComment\";\n\n@Controller(\"/shoppings/admins/sales/:saleId/reviews/:inquiryId/comments\")\nexport class ShoppingsAdminsSalesReviewsCommentsController {\n  /**\n   * Create an inquiry comment.\n   *\n   * Create an {@link IShoppingSaleInquiryComment inquiry comment} of a\n   * {@link IShoppingSaleQuestion question} or\n   * {@link IShoppingSaleReview review}.\n   *\n   * For reference, if you're a {@link IShoppingSeller seller}, you can only\n   * create an inquiry comment to your own {@link IShoppingSale sale}'s\n   * inquiry. Otherwise, you can create an inquiry comment to every inquiries\n   * of the sales.\n   *\n   * @param saleId Belonged sale's {@link IShoppingSale.id }\n   * @param inquiryId Target inquiry's {@link IShoppingSaleInquiry.id }\n   * @param body Creation info of the inquiry comment\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Post()\n  public async postBySaleidAndInquiryid(\n    @TypedParam(\"saleId\")\n    saleId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"inquiryId\")\n    inquiryId: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IShoppingSaleInquiryComment.ICreate,\n  ): Promise<IShoppingSaleInquiryComment> {\n    saleId;\n    inquiryId;\n    body;\n    return typia.random<IShoppingSaleInquiryComment>();\n  }\n\n  /**\n   * List up every inquiry comments.\n   *\n   * List up every {@link IShoppingSaleInquiryComment inquiry comments} of a\n   * {@link IShoppingSaleQuestion question} or\n   * {@link IShoppingSaleReview review} with {@link IPage pagination}.\n   *\n   * If you want, you can limit the result by configuring\n   * {@link IShoppingSaleInquiryComment.IRequest.search search condition} in\n   * the request body. Also, it is possible to customize sequence order of\n   * records by configuring\n   * {@link IShoppingSaleInquiryComment.IRequest.sort sort condition}.\n   *\n   * By the way, if you're a {@link IShoppingSeller seller}, you can only\n   * access to the your own {@link IShoppingSale sale}'s inquiries. Otherwise,\n   * you can access to every inquiries of the sales.\n   *\n   * @param saleId Belonged sale's {@link IShoppingSale.id }\n   * @param inquiryId Belonged inquiry's {@link IShoppingSaleInquiry.id }\n   * @param body Request info of pagination, searching and sorting\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patchBySaleidAndInquiryid(\n    @TypedParam(\"saleId\")\n    saleId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"inquiryId\")\n    inquiryId: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IShoppingSaleInquiryComment.IRequest,\n  ): Promise<IPageIShoppingSaleInquiryComment> {\n    saleId;\n    inquiryId;\n    body;\n    return typia.random<IPageIShoppingSaleInquiryComment>();\n  }\n\n  /**\n   * Get an inquiry comment info.\n   *\n   * Get a detailed {@link IShoppingSaleInquiryComment inquiry comment}\n   * information of a {@link IShoppingSaleQuestion question} or\n   * {@link IShoppingSaleReview review}.\n   *\n   * For reference, if you're a {@link IShoppingSeller seller}, you can only\n   * access to the your own {@link IShoppingSale sale}'s inquiry comment.\n   * Otherwise, you can access to every inquiry comments of the sales.\n   *\n   * @param saleId Belonged sale's {@link IShoppingSale.id }\n   * @param inquiryId Belonged inquiry's {@link IShoppingSaleInquiry.id }\n   * @param id Target inquiry comment's {@link IShoppingSaleInquiryComment.id }\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get(\":id\")\n  public async getBySaleidAndInquiryidAndId(\n    @TypedParam(\"saleId\")\n    saleId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"inquiryId\")\n    inquiryId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<IShoppingSaleInquiryComment> {\n    saleId;\n    inquiryId;\n    id;\n    return typia.random<IShoppingSaleInquiryComment>();\n  }\n\n  /**\n   * Update an inquiry comment.\n   *\n   * Update an {@link IShoppingSaleInquiryComment inquiry comment} to a\n   * specific {@link IShoppingSaleQuestion question} or\n   * {@link IShoppingSaleReview review}.\n   *\n   * By the way, as is the general policy of this shopping mall regarding\n   * comments, modifying a comment does not actually change the existing\n   * content. Modified content is accumulated and recorded in the existing\n   * comment record as a new\n   * {@link IShoppingSaleInquiryComment.ISnapshot snapshot}. And this is made\n   * public to everyone, who can read this inquiry comment.\n   *\n   * This is to prevent customers or sellers from modifying their comments and\n   * manipulating the circumstances due to the nature of e-commerce, where\n   * disputes easily arise. That is, to preserve evidence.\n   *\n   * @param saleId Belonged sale's {@link IShoppingSale.id }\n   * @param inquiryId Belonged inquiry's {@link IShoppingSaleInquiry.id }\n   * @param id Target inquiry comment's {@link IShoppingSaleInquiryComment.id }\n   * @param body Update info of the inquiry comment\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Put(\":id\")\n  public async putBySaleidAndInquiryidAndId(\n    @TypedParam(\"saleId\")\n    saleId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"inquiryId\")\n    inquiryId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IShoppingSaleInquiryComment.ICreate,\n  ): Promise<IShoppingSaleInquiryComment.ISnapshot> {\n    saleId;\n    inquiryId;\n    id;\n    body;\n    return typia.random<IShoppingSaleInquiryComment.ISnapshot>();\n  }\n}\n",
  "src/controllers/shoppings/admins/sales/reviews/ShoppingsAdminsSalesReviewsController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedParam, TypedBody } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IPageIShoppingSaleReview } from \"../../../../../api/structures/IPageIShoppingSaleReview\";\nimport { IShoppingSaleReview } from \"../../../../../api/structures/IShoppingSaleReview\";\n\n@Controller(\"/shoppings/admins/sales/:saleId/reviews\")\nexport class ShoppingsAdminsSalesReviewsController {\n  /**\n   * List up every summarized reviews.\n   *\n   * List up every {@link IShoppingSaleReview.ISummary summarized reviews} of a\n   * {@link IShoppingSale sale}.\n   *\n   * As you can see, returned reviews are summarized, not detailed. If you\n   * want to get the detailed information of a review, use {@link adridges}\n   * function or {@link at} function for each article.\n   *\n   * Also, returned review has {@link IShoppingSaleReview.ISummary.answer}\n   * property which means the formal answer from the {@link IShoppingSeller}.\n   *\n   * For reference, if you're a {@link IShoppingSeller seller}, you can only\n   * access to the your own {@link IShoppingSale sale}'s reviews. Otherwise,\n   * you can access to every reviews of the sales.\n   *\n   * By the way, if you want, you can limit the result by configuring\n   * {@link IShoppingSaleReview.IRequest.search search condition} in the\n   * request body. Also, it is possible to customize sequence order of records\n   * by configuring {@link IShoppingSaleReview.IRequest.sort sort condition}.\n   *\n   * @param saleId Belonged sale's {@link IShoppingSale.id }\n   * @param body Request info of pagination, searching and sorting\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patchBySaleid(\n    @TypedParam(\"saleId\")\n    saleId: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IShoppingSaleReview.IRequest,\n  ): Promise<IPageIShoppingSaleReview.ISummary> {\n    saleId;\n    body;\n    return typia.random<IPageIShoppingSaleReview.ISummary>();\n  }\n\n  /**\n   * Get a review info.\n   *\n   * Get a detailed {@link IShoppingSaleReview review} information of a\n   * {@link IShoppingSale sale}.\n   *\n   * For reference, if you're a {@link IShoppingSeller seller}, you can only\n   * access to the your own {@link IShoppingSale sale}'s review. Otherwise you\n   * are a {@link IShoppingCustomer customer}, you can access to every reviews\n   * of the sales.\n   *\n   * @param saleId Belonged sale's {@link IShoppingSale.id }\n   * @param id Target review's {@link IShoppingSaleReview.id }\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get(\":id\")\n  public async getBySaleidAndId(\n    @TypedParam(\"saleId\")\n    saleId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<IShoppingSaleReview> {\n    saleId;\n    id;\n    return typia.random<IShoppingSaleReview>();\n  }\n}\n",
  "src/controllers/shoppings/admins/sales/reviews/abridges/ShoppingsAdminsSalesReviewsAbridgesController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedParam, TypedBody } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IPageIShoppingSaleReview } from \"../../../../../../api/structures/IPageIShoppingSaleReview\";\nimport { IShoppingSaleReview } from \"../../../../../../api/structures/IShoppingSaleReview\";\n\n@Controller(\"/shoppings/admins/sales/:saleId/reviews/abridges\")\nexport class ShoppingsAdminsSalesReviewsAbridgesController {\n  /**\n   * List up every abridged reviews.\n   *\n   * List up every {@link IShoppingSaleReview.IAbridge abridged reviews} of a\n   * {@link IShoppingSale sale}.\n   *\n   * As you can see, returned reviews are abridged, not detailed. If you want\n   * to get the detailed information of a review, use {@link at} function for\n   * each article.\n   *\n   * Also, returned review has {@link IShoppingSaleReview.IAridge.answer}\n   * property which means the formal answer from the {@link IShoppingSeller}.\n   *\n   * For reference, if you're a {@link IShoppingSeller seller}, you can only\n   * access to the your own {@link IShoppingSale sale}'s reviews. Otherwise,\n   * you can access to every reviews of the sales.\n   *\n   * By the way, if you want, you can limit the result by configuring\n   * {@link IShoppingSaleReview.IRequest.search search condition} in the\n   * request body. Also, it is possible to customize sequence order of records\n   * by configuring {@link IShoppingSaleReview.IRequest.sort sort condition}.\n   *\n   * @param saleId Belonged sale's {@link IShoppingSale.id }\n   * @param body Request info of pagination, searching and sorting\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patchBySaleid(\n    @TypedParam(\"saleId\")\n    saleId: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IShoppingSaleReview.IRequest,\n  ): Promise<IPageIShoppingSaleReview.IAbridge> {\n    saleId;\n    body;\n    return typia.random<IPageIShoppingSaleReview.IAbridge>();\n  }\n}\n",
  "src/controllers/shoppings/admins/sales/snapshots/ShoppingsAdminsSalesSnapshotsController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedParam, TypedBody } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IPageIShoppingSaleSnapshot } from \"../../../../../api/structures/IPageIShoppingSaleSnapshot\";\nimport { IPage } from \"../../../../../api/structures/IPage\";\nimport { IShoppingSaleSnapshot } from \"../../../../../api/structures/IShoppingSaleSnapshot\";\n\n@Controller(\"/shoppings/admins/sales/:saleId/snapshots\")\nexport class ShoppingsAdminsSalesSnapshotsController {\n  /**\n   * List up every snapshots.\n   *\n   * Whenever {@link IShoppingSeller seller} updates a\n   * {@link IShoppingSale sale}, the sale record is not updated but a new\n   * {@link IShoppingSaleSnapshot snapshot} record is created to keep the\n   * integrity of the sale history. This API function is for listing up such\n   * snapshot records.\n   *\n   * Also, as you can see from the return type, returned snapshots are\n   * summarized, not detailed. If you want to get the detailed information of\n   * a snapshot, use {@link at} or {@link flipo} function for each snapshot.\n   *\n   * For reference, if you're a {@link IShoppingSeller seller}, you can only\n   * access to the your own {@link IShoppingSale sale}'s snapshots. Otherwise,\n   * you can access to every snapshots of the sales even though the sale has\n   * been closed or suspended.\n   *\n   * @param saleId Target sale's {@link IShoppingSale.id }\n   * @param body Requestion info of pagination\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patchBySaleid(\n    @TypedParam(\"saleId\")\n    saleId: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IPage.IRequest,\n  ): Promise<IPageIShoppingSaleSnapshot.ISummary> {\n    saleId;\n    body;\n    return typia.random<IPageIShoppingSaleSnapshot.ISummary>();\n  }\n\n  /**\n   * Get a snapshot info.\n   *\n   * Get a {@link IShoppingSaleSnapshot snapshot} with detailed information.\n   *\n   * As you can see from the return type, returned snapshot does not contain\n   * the {@link IShoppingSale sale} info. If you want to get the sale info, use\n   * the {@link flip} function instead.\n   *\n   * For reference, if you're a {@link IShoppingSeller seller}, you can only\n   * access to the your own {@link IShoppingSale sale}'s snapshots. Otherwise,\n   * you can access to every snapshots of the sales even though the sale has\n   * been closed or suspended.\n   *\n   * @param saleId Belonged sale's {@link IShoppingSale.id }\n   * @param id Target snapshot's {@link IShoppingSaleSnapshot.id }\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get(\":id\")\n  public async getBySaleidAndId(\n    @TypedParam(\"saleId\")\n    saleId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<IShoppingSaleSnapshot> {\n    saleId;\n    id;\n    return typia.random<IShoppingSaleSnapshot>();\n  }\n}\n",
  "src/controllers/shoppings/admins/sales/snapshots/flip/ShoppingsAdminsSalesSnapshotsFlipController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedParam } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IShoppingSale } from \"../../../../../../api/structures/IShoppingSale\";\n\n@Controller(\"/shoppings/admins/sales/:saleId/snapshots/:id/flip\")\nexport class ShoppingsAdminsSalesSnapshotsFlipController {\n  /**\n   * Get a flipped snapshot info.\n   *\n   * Get a {@link IShoppingSale sale} info of a flipped snapshot.\n   *\n   * As you can see from the return type, this function returns the\n   * {@link IShoppingSale sale} info. By the way, the sale info is not the\n   * latest one, but a flipped info in the snapshot side.\n   *\n   * Also, if you're a {@link IShoppingSeller seller}, you can only access to\n   * the your own {@link IShoppingSale sale}'s snapshots. Otherwise, you can\n   * access to every snapshots of the sales even though the sale has been\n   * closed or suspended.\n   *\n   * @param saleId Belonged sale's {@link IShoppingSale.id }\n   * @param id Target snapshot's {@link IShoppingSaleSnapshot.id }\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get()\n  public async getBySaleidAndId(\n    @TypedParam(\"saleId\")\n    saleId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<IShoppingSale> {\n    saleId;\n    id;\n    return typia.random<IShoppingSale>();\n  }\n}\n",
  "src/controllers/shoppings/admins/systematic/channels/categories/ShoppingsAdminsSystematicChannelsCategoriesController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedParam, TypedBody } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IShoppingChannelCategory } from \"../../../../../../api/structures/IShoppingChannelCategory\";\n\n@Controller(\"/shoppings/admins/systematic/channels/:channelCode/categories\")\nexport class ShoppingsAdminsSystematicChannelsCategoriesController {\n  /**\n   * Create a new category.\n   *\n   * Create a new {@link IShoppingChannelCategory category} of a\n   * {@link IShoppingChannel channel} with given name. If required, it is\n   * possible to specify the parent category by its ID.\n   *\n   * @param channelCode Belonged channel's {@link IShoppingChannel.code }\n   * @param body Creation info of the category\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Post()\n  public async postByChannelcode(\n    @TypedParam(\"channelCode\")\n    channelCode: string,\n    @TypedBody()\n    body: IShoppingChannelCategory.ICreate,\n  ): Promise<IShoppingChannelCategory> {\n    channelCode;\n    body;\n    return typia.random<IShoppingChannelCategory>();\n  }\n\n  /**\n   * List up every categories with children records.\n   *\n   * List up every {@link IShoppingChannelCategory.IHierarchical categories} of\n   * a {@link IShoppingChannel channel} with pagination. Returned categories\n   * contain children categories, too.\n   *\n   * If you want, you can limit the result by configuring\n   * {@link IShoppingChannelCategory.IRequest.search search condition} in the\n   * request body. Also, it is possible to customize sequence order of records\n   * by configuring\n   * {@link IShoppingChannelCategory.IRequest.sort sort condition}.\n   *\n   * @param channelCode Belonged channel's {@link IShoppingChannel.code }\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patchByChannelcode(\n    @TypedParam(\"channelCode\")\n    channelCode: string,\n  ): Promise<void> {\n    channelCode;\n    return typia.random<void>();\n  }\n\n  /**\n   * Get a category info.\n   *\n   * Get a detailed {@link IShoppingChannelCategory category} information.\n   *\n   * Returned category contains hierarchical children categories, and also\n   * contains the recursive parent categories, too.\n   *\n   * @param channelCode Belonged channel's {@link IShoppingChannel.code }\n   * @param id Target category's {@link IShoppingChannelCategory.id }\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get(\":id\")\n  public async getByChannelcodeAndId(\n    @TypedParam(\"channelCode\")\n    channelCode: string,\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<IShoppingChannelCategory> {\n    channelCode;\n    id;\n    return typia.random<IShoppingChannelCategory>();\n  }\n\n  /**\n   * Update a category.\n   *\n   * Update a {@link IShoppingChannelCategory category}'s name. If required, it\n   * is possible to change the parent category by its ID. Of course, detaching\n   * from the parent category so that becoming the root category is also\n   * possible.\n   *\n   * @param channelCode Belonged channel's {@link IShoppingChannel.code }\n   * @param id Target category's {@link IShoppingChannelCategory.id }\n   * @param body Update info of the category\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Put(\":id\")\n  public async putByChannelcodeAndId(\n    @TypedParam(\"channelCode\")\n    channelCode: string,\n    @TypedParam(\"id\")\n    id: string,\n    @TypedBody()\n    body: IShoppingChannelCategory.ICreate,\n  ): Promise<void> {\n    channelCode;\n    id;\n    body;\n    return typia.random<void>();\n  }\n}\n",
  "src/controllers/shoppings/admins/systematic/channels/categories/merge/ShoppingsAdminsSystematicChannelsCategoriesMergeController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedParam, TypedBody } from \"@nestia/core\";\nimport typia from \"typia\";\n\nimport { IRecordMerge } from \"../../../../../../../api/structures/IRecordMerge\";\n\n@Controller(\n  \"/shoppings/admins/systematic/channels/:channelCode/categories/merge\",\n)\nexport class ShoppingsAdminsSystematicChannelsCategoriesMergeController {\n  /**\n   * Merge multiple categories into one.\n   *\n   * In this shopping mall system, it is not possible to delete a\n   * {@link IShoppingChannelCategory category}, because it is a systematic\n   * entity affecting to all other core entities like\n   * {@link IShoppingSale sales}. Instead of deleting, you can merge multiple\n   * categories into one.\n   *\n   * If you specify a category to absorb others, then all of other categories\n   * will be merged into the specified one. Also, subsidiary entities of\n   * categories also be merged and their references also be merged\n   * cascadingly.\n   *\n   * @param channelCode Belonged channel's {@link IShoppingChannel.code }\n   * @param body Merge info of the categories\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Delete()\n  public async eraseByChannelcode(\n    @TypedParam(\"channelCode\")\n    channelCode: string,\n    @TypedBody()\n    body: IRecordMerge,\n  ): Promise<void> {\n    channelCode;\n    body;\n    return typia.random<void>();\n  }\n}\n",
  "src/controllers/shoppings/admins/systematic/channels/categories/invert/ShoppingsAdminsSystematicChannelsCategoriesInvertController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedParam } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IShoppingChannelCategory } from \"../../../../../../../api/structures/IShoppingChannelCategory\";\n\n@Controller(\n  \"/shoppings/admins/systematic/channels/:channelCode/categories/:id/invert\",\n)\nexport class ShoppingsAdminsSystematicChannelsCategoriesInvertController {\n  /**\n   * Get a category info of inverted.\n   *\n   * Get a inverted {@link IShoppingChannelCategory.IInvert category}\n   * information.\n   *\n   * Returned category contains the recursive parent categories, but not\n   * contains the hierarchical children categories.\n   *\n   * @param channelCode Belonged channel's {@link IShoppingChannel.code }\n   * @param id Target category's {@link IShoppingChannelCategory.id }\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get()\n  public async getByChannelcodeAndId(\n    @TypedParam(\"channelCode\")\n    channelCode: string,\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<IShoppingChannelCategory.IInvert> {\n    channelCode;\n    id;\n    return typia.random<IShoppingChannelCategory.IInvert>();\n  }\n}\n",
  "src/controllers/shoppings/admins/systematic/channels/ShoppingsAdminsSystematicChannelsController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody, TypedParam } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IShoppingChannel } from \"../../../../../api/structures/IShoppingChannel\";\nimport { IPageIShoppingChannel } from \"../../../../../api/structures/IPageIShoppingChannel\";\n\n@Controller(\"/shoppings/admins/systematic/channels\")\nexport class ShoppingsAdminsSystematicChannelsController {\n  /**\n   * Create a new channel.\n   *\n   * Create a new {@link IShoppingChannel channel} with given code and name.\n   *\n   * As channel means an individual market,\n   * {@link IShoppingAdministrator administrator} should perform this action\n   * only when a new application being registered.\n   *\n   * @param body Creation info of the channel\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Post()\n  public async post(\n    @TypedBody()\n    body: IShoppingChannel.ICreate,\n  ): Promise<IShoppingChannel> {\n    body;\n    return typia.random<IShoppingChannel>();\n  }\n\n  /**\n   * List up every channels.\n   *\n   * List up every {@link IShoppingChannel channels} with pagination.\n   *\n   * If you want, you can limit the result by configuring\n   * {@link IShoppingChannel.IRequest.search search condition} in the request\n   * body. Also, it is possible to customize sequence order of records by\n   * configuring {@link IShoppingChannel.IRequest.sort sort condition}.\n   *\n   * @param body Request info of pagination, searching and sorting\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patch(\n    @TypedBody()\n    body: IShoppingChannel.IRequest,\n  ): Promise<IPageIShoppingChannel> {\n    body;\n    return typia.random<IPageIShoppingChannel>();\n  }\n\n  /**\n   * Get a channel info.\n   *\n   * Get a detailed {@link IShoppingChannel.IHierarchical channel} information.\n   *\n   * Returned channel instance also contains the nested\n   * {@link IShoppingChannelCategory.IHierarchical hierarchical category}\n   * information.\n   *\n   * @param id Target channel's {@link IShoppingChannel.id }\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get(\":id\")\n  public async getById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<IShoppingChannel.IHierarchical> {\n    id;\n    return typia.random<IShoppingChannel.IHierarchical>();\n  }\n\n  /**\n   * Update a channel.\n   *\n   * Update a {@link IShoppingChannel channel}'s name.\n   *\n   * Note that, it is not possible to change the channel's code. If you want\n   * to to do it forcibly, then {@link create} new one and {@link merge} with\n   * it.\n   *\n   * @param id Target channel's {@link IShoppingChannel.code }\n   * @param body Update info of the channel\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Put(\":id\")\n  public async putById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IShoppingChannel.IUpdate,\n  ): Promise<void> {\n    id;\n    body;\n    return typia.random<void>();\n  }\n}\n",
  "src/controllers/shoppings/admins/systematic/channels/merge/ShoppingsAdminsSystematicChannelsMergeController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody } from \"@nestia/core\";\nimport typia from \"typia\";\n\nimport { IRecordMerge } from \"../../../../../../api/structures/IRecordMerge\";\n\n@Controller(\"/shoppings/admins/systematic/channels/merge\")\nexport class ShoppingsAdminsSystematicChannelsMergeController {\n  /**\n   * Merge multiple channels into one.\n   *\n   * In this shopping mall system, it is not possible to delete a\n   * {@link IShoppingChannel channel}, because it is a systematic entity\n   * affecting to all other core entities like customers, members and sales.\n   * Instead of deleting, you can merge multiple channels into one.\n   *\n   * If you specify a channel to absorb others, then all of other channels\n   * will be merged into the specified one. Also, subsidiary entities of\n   * channels also be merged and their references also be merged cascadingly.\n   *\n   * @param body Request info of the merge\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Delete()\n  public async erase(\n    @TypedBody()\n    body: IRecordMerge,\n  ): Promise<void> {\n    body;\n    return typia.random<void>();\n  }\n}\n",
  "src/controllers/shoppings/admins/systematic/channels/hierarchical/ShoppingsAdminsSystematicChannelsHierarchicalController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody } from \"@nestia/core\";\nimport typia from \"typia\";\n\nimport { IPageIShoppingChannel } from \"../../../../../../api/structures/IPageIShoppingChannel\";\nimport { IShoppingChannel } from \"../../../../../../api/structures/IShoppingChannel\";\n\n@Controller(\"/shoppings/admins/systematic/channels/hierarchical\")\nexport class ShoppingsAdminsSystematicChannelsHierarchicalController {\n  /**\n   * List up every channels with nested categories.\n   *\n   * List up every {@link IShoppingChannel.IHierarchical channels} with\n   * {@link IPage pagination}. Returned channels contain nested hierarchical\n   * {@link IShoppingChannelCategory.IHierarchical categories}.\n   *\n   * If you want, you can limit the result by configuring\n   * {@link IShoppingChannel.IRequest.search search condition} in the request\n   * body. Also, it is possible to customize sequence order of records by\n   * configuring {@link IShoppingChannel.IRequest.sort sort condition}.\n   *\n   * @param body Request info of pagination, searching and sorting\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patch(\n    @TypedBody()\n    body: IShoppingChannel.IRequest,\n  ): Promise<IPageIShoppingChannel.IHierarchical> {\n    body;\n    return typia.random<IPageIShoppingChannel.IHierarchical>();\n  }\n}\n",
  "src/controllers/shoppings/admins/systematic/channels/get/ShoppingsAdminsSystematicChannelsGetController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedParam } from \"@nestia/core\";\nimport typia from \"typia\";\n\nimport { IShoppingChannel } from \"../../../../../../api/structures/IShoppingChannel\";\n\n@Controller(\"/shoppings/admins/systematic/channels/:code/get\")\nexport class ShoppingsAdminsSystematicChannelsGetController {\n  /**\n   * Get a channel info by its code.\n   *\n   * Get a detailed {@link IShoppingChannel.IHierarchical channel} information\n   * by its code.\n   *\n   * Returned channel instance also contains the nested\n   * {@link IShoppingChannelCategory.IHierarchical hierarchical category}\n   * information.\n   *\n   * @param code Target channel's {@link IShoppingChannel.code }\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get()\n  public async getByCode(\n    @TypedParam(\"code\")\n    code: string,\n  ): Promise<IShoppingChannel.IHierarchical> {\n    code;\n    return typia.random<IShoppingChannel.IHierarchical>();\n  }\n}\n",
  "src/controllers/shoppings/admins/systematic/sections/ShoppingsAdminsSystematicSectionsController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody, TypedParam } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IShoppingSection } from \"../../../../../api/structures/IShoppingSection\";\nimport { IPageIShoppingSection } from \"../../../../../api/structures/IPageIShoppingSection\";\n\n@Controller(\"/shoppings/admins/systematic/sections\")\nexport class ShoppingsAdminsSystematicSectionsController {\n  /**\n   * Create a new section.\n   *\n   * Create a new {@link IShoppingSection section} with given code and name.\n   *\n   * As section means a spatial unit of a market that handling different type\n   * of products with other section,\n   * {@link IShoppingAdministrator administrator} should perform this action\n   * only when a new section being required.\n   *\n   * @param body Creation info of the section\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Post()\n  public async post(\n    @TypedBody()\n    body: IShoppingSection.ICreate,\n  ): Promise<IShoppingSection> {\n    body;\n    return typia.random<IShoppingSection>();\n  }\n\n  /**\n   * List up every sections.\n   *\n   * List up every {@link IShoppingSection sections} with pagination.\n   *\n   * If you want, you can limit the result by configuring\n   * {@link IShoppingSection.IRequest.search search condition} in the request\n   * body. Also, it is possible to customize sequence order of records by\n   * configuring {@link IShoppingSection.IRequest.sort sort condition}.\n   *\n   * @param body Request info of pagination, searching and sorting\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patch(\n    @TypedBody()\n    body: IShoppingSection.IRequest,\n  ): Promise<IPageIShoppingSection> {\n    body;\n    return typia.random<IPageIShoppingSection>();\n  }\n\n  /**\n   * Get a section info.\n   *\n   * Get a detailed {@link IShoppingSection section} information.\n   *\n   * @param id Target section's {@link IShoppingSection.id }\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get(\":id\")\n  public async getById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<IShoppingSection> {\n    id;\n    return typia.random<IShoppingSection>();\n  }\n\n  /**\n   * Update a section.\n   *\n   * Update a {@link IShoppingSection section}'s name.\n   *\n   * Note that, it is not possible to change the section's code. If you want\n   * to to do it forcibly, then {@link create} new one and {@link merge} with\n   * it.\n   *\n   * @param id Target section's {@link IShoppingSection.code }\n   * @param body Update info of the section\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Put(\":id\")\n  public async putById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IShoppingSection.IUpdate,\n  ): Promise<void> {\n    id;\n    body;\n    return typia.random<void>();\n  }\n}\n",
  "src/controllers/shoppings/admins/systematic/sections/merge/ShoppingsAdminsSystematicSectionsMergeController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody } from \"@nestia/core\";\nimport typia from \"typia\";\n\nimport { IRecordMerge } from \"../../../../../../api/structures/IRecordMerge\";\n\n@Controller(\"/shoppings/admins/systematic/sections/merge\")\nexport class ShoppingsAdminsSystematicSectionsMergeController {\n  /**\n   * Merge multiple sections into one.\n   *\n   * In this shopping mall system, it is not possible to delete a\n   * {@link IShoppingSection section}, because it is a systematic entity\n   * affecting to all other core entities like {@link IShoppingSale sales}.\n   * Instead of deleting, you can merge multiple sections into one.\n   *\n   * If you specify a section to absorb others, then all of other sections\n   * will be merged into the specified one. Also, subsidiary entities of\n   * sections also be merged and their references also be merged cascadingly.\n   *\n   * @param body Input Request info of the merge\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Delete()\n  public async erase(\n    @TypedBody()\n    body: IRecordMerge,\n  ): Promise<void> {\n    body;\n    return typia.random<void>();\n  }\n}\n",
  "src/controllers/shoppings/admins/systematic/sections/get/ShoppingsAdminsSystematicSectionsGetController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedParam } from \"@nestia/core\";\nimport typia from \"typia\";\n\nimport { IShoppingSection } from \"../../../../../../api/structures/IShoppingSection\";\n\n@Controller(\"/shoppings/admins/systematic/sections/:code/get\")\nexport class ShoppingsAdminsSystematicSectionsGetController {\n  /**\n   * Get a section info by its code.\n   *\n   * Get a detailed {@link IShoppingSection section} information by its code.\n   *\n   * @param code Target section's {@link IShoppingSection.code }\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get()\n  public async getByCode(\n    @TypedParam(\"code\")\n    code: string,\n  ): Promise<IShoppingSection> {\n    code;\n    return typia.random<IShoppingSection>();\n  }\n}\n",
  "src/controllers/shoppings/customers/authenticate/refresh/ShoppingsCustomersAuthenticateRefreshController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody } from \"@nestia/core\";\nimport typia from \"typia\";\n\nimport { IShoppingCustomer } from \"../../../../../api/structures/IShoppingCustomer\";\n\n@Controller(\"/shoppings/customers/authenticate/refresh\")\nexport class ShoppingsCustomersAuthenticateRefreshController {\n  /**\n   * Refresh the authentication token.\n   *\n   * Create a new {@link IShoppingCustomer.IToken.access access token} of a\n   * {@link IShoppingCustomer customer} with the pre-issued\n   * {@link IShoppingCustomer.IToken.refresh refresh} token.\n   *\n   * Note that, this function is available until the\n   * {@link IShoppingCustomer.IToken.refreshable_until} value.\n   *\n   * @param body Refresh token.\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patch(\n    @TypedBody()\n    body: IShoppingCustomer.IRefresh,\n  ): Promise<IShoppingCustomer.IAuthorized> {\n    body;\n    return typia.random<IShoppingCustomer.IAuthorized>();\n  }\n}\n",
  "src/controllers/shoppings/customers/authenticate/ShoppingsCustomersAuthenticateController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody } from \"@nestia/core\";\nimport typia from \"typia\";\n\nimport { IShoppingCustomer } from \"../../../../api/structures/IShoppingCustomer\";\n\n@Controller(\"/shoppings/customers/authenticate\")\nexport class ShoppingsCustomersAuthenticateController {\n  /**\n   * Get current customer info.\n   *\n   * Get current {@link IShoppingCustomer customer} information from the\n   * {@link IShoppingCustomer.IToken.access access token}.\n   *\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get()\n  public async get(): Promise<IShoppingCustomer> {\n    return typia.random<IShoppingCustomer>();\n  }\n\n  /**\n   * Create a new customer record.\n   *\n   * This shopping mall system defines everyone participating in this market\n   * as a \"customer\". And the customer records are not archived based on\n   * individual {@link IShoppingCitizen people}, but based on the unit of\n   * connection. Therefore, even if it is the same person, a new\n   * {@link IShoppingCustomer} record is created every time a connection is\n   * made.\n   *\n   * Therefore, all Client Applications that access this service must first\n   * call this function, report the customer's inflow path to the server, and\n   * create an {@link IShoppingCustomer.IToken.access access token}. If you\n   * skip this function call, all the other API functions would be prohibited.\n   * There is no exception, even if you want to {@link activate} your\n   * citizenship or {@link login} with your\n   * {@link IShoppingMember member account}. Before authenticating yourself or\n   * logging in, be sure to call this function first. This also applies when\n   * an {@link IShoppingAdministrator administrator} or\n   * {@link IShoppingSeller seller} logs in.\n   *\n   * Also, the authentication token has an\n   * {@link IShoppingCustomer.IToken.expired_at expiration time} and cannot be\n   * used permanently. For reference, the authentication token is valid for 3\n   * hours, and if you want to maintain customer authentication even after 3\n   * hours, you must call the {@link refresh} function.\n   *\n   * @param body Creation information of the customer.\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Post()\n  public async post(\n    @TypedBody()\n    body: IShoppingCustomer.ICreate,\n  ): Promise<IShoppingCustomer.IAuthorized> {\n    body;\n    return typia.random<IShoppingCustomer.IAuthorized>();\n  }\n}\n",
  "src/controllers/shoppings/customers/authenticate/join/ShoppingsCustomersAuthenticateJoinController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody } from \"@nestia/core\";\nimport typia from \"typia\";\n\nimport { IShoppingCustomer } from \"../../../../../api/structures/IShoppingCustomer\";\nimport { IShoppingMember } from \"../../../../../api/structures/IShoppingMember\";\n\n@Controller(\"/shoppings/customers/authenticate/join\")\nexport class ShoppingsCustomersAuthenticateJoinController {\n  /**\n   * Join membership.\n   *\n   * {@link IShoppingCustomer Customer} signs up for\n   * {@link IShoppingMember membership} of current shopping mall system.\n   *\n   * If you've performed the {@link IShoppingCitizen citizenship}\n   * {@link activate activation} too, then you can skip the {@link activate}\n   * function calling everytime you log in from now on. Also, if the person\n   * had {@link IShoppingOrder purchased} with {@link activate} and\n   * {@link external} function calling, you can also access to the order\n   * history too. In other words, activity details prior to membership\n   * registration can also be accessed with continuity.\n   *\n   * For reference, as described in the {@link create} function, before calling\n   * this `join` function, you must first create a customer record and token\n   * by calling the {@link create} function.\n   *\n   * @param body Join information of the member\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Post()\n  public async post(\n    @TypedBody()\n    body: IShoppingMember.IJoin,\n  ): Promise<IShoppingCustomer> {\n    body;\n    return typia.random<IShoppingCustomer>();\n  }\n}\n",
  "src/controllers/shoppings/customers/authenticate/login/ShoppingsCustomersAuthenticateLoginController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody } from \"@nestia/core\";\nimport typia from \"typia\";\n\nimport { IShoppingCustomer } from \"../../../../../api/structures/IShoppingCustomer\";\nimport { IShoppingMember } from \"../../../../../api/structures/IShoppingMember\";\n\n@Controller(\"/shoppings/customers/authenticate/login\")\nexport class ShoppingsCustomersAuthenticateLoginController {\n  /**\n   * Membership login.\n   *\n   * {@link IShoppingCustomer Customer} logs in with his/her\n   * {@link IShoppingMember membership} account with the email and password.\n   *\n   * If the {@link IShoppingMember member} has previously performed\n   * {@link activate citizenship activation}, the\n   * {@link IShoppingCustomer.citizen} value would be filled in accordingly.\n   * And if the member has also signed up as an\n   * {@link IShoppingAdministrator administrator} or\n   * {@link IShoppingSeller seller}, the relevant information is also entered\n   * accordingly.\n   *\n   * For reference, as described in the {@link create} function, before calling\n   * this `login` function, you must first create a customer record and token\n   * by calling the {@link create} function.\n   *\n   * @param body Login request info\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Put()\n  public async put(\n    @TypedBody()\n    body: IShoppingMember.ILogin,\n  ): Promise<IShoppingCustomer> {\n    body;\n    return typia.random<IShoppingCustomer>();\n  }\n}\n",
  "src/controllers/shoppings/customers/authenticate/activate/ShoppingsCustomersAuthenticateActivateController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody } from \"@nestia/core\";\nimport typia from \"typia\";\n\nimport { IShoppingCustomer } from \"../../../../../api/structures/IShoppingCustomer\";\nimport { IShoppingCitizen } from \"../../../../../api/structures/IShoppingCitizen\";\n\n@Controller(\"/shoppings/customers/authenticate/activate\")\nexport class ShoppingsCustomersAuthenticateActivateController {\n  /**\n   * Activate citizenship.\n   *\n   * {@link IShoppingCustomer Customer} activates his/her\n   * {@link IShoppingCitizen citizenship} with mobile number and real name.\n   *\n   * If the custommer already {@link join joined} to the\n   * {@link IShoppingMember membership}, then you can skip the citizenship\n   * {@link activation} function calling everytime you log in from now on. Of\n   * course, such story would be same to the {@link external} function, too.\n   *\n   * For reference, as described in the {@link create} function, before calling\n   * this `activate` function, you must first create a customer record and\n   * token by calling the {@link create} function.\n   *\n   * @param body Activation information of the citizenship\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Post()\n  public async post(\n    @TypedBody()\n    body: IShoppingCitizen.ICreate,\n  ): Promise<IShoppingCustomer> {\n    body;\n    return typia.random<IShoppingCustomer>();\n  }\n}\n",
  "src/controllers/shoppings/customers/authenticate/external/ShoppingsCustomersAuthenticateExternalController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody } from \"@nestia/core\";\nimport typia from \"typia\";\n\nimport { IShoppingCustomer } from \"../../../../../api/structures/IShoppingCustomer\";\nimport { IShoppingExternalUser } from \"../../../../../api/structures/IShoppingExternalUser\";\n\n@Controller(\"/shoppings/customers/authenticate/external\")\nexport class ShoppingsCustomersAuthenticateExternalController {\n  /**\n   * Enroll external user info.\n   *\n   * {@link IShoppingCustomer Customer} enrolls his/her\n   * {@link IShoppingExternalUser external user} information from other\n   * service.\n   *\n   * It has similar effect with the {@link join membership joining} function,\n   * so that if you've performed the {@link IShoppingCitizen citizenship}\n   * {@link activate activation} too, then you can skip the {@link activate}\n   * function calling everytime you call this `external` function with same\n   * info from now on. Also, if the person had {@link IShoppingOrder purchased}\n   * with {@link activate} and {@link join} function calling, you can also\n   * access to the order history too. In other words, activity details prior\n   * to external server registration can also be accessed with continuity.\n   *\n   * For reference, as described in the {@link create} function, before calling\n   * this `external` function, you must first create a customer record and\n   * token by calling the {@link create} function.\n   *\n   * @param body Enroll information of the external user\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Post()\n  public async post(\n    @TypedBody()\n    body: IShoppingExternalUser.ICreate,\n  ): Promise<IShoppingCustomer> {\n    body;\n    return typia.random<IShoppingCustomer>();\n  }\n}\n",
  "src/controllers/shoppings/customers/authenticate/password/change/ShoppingsCustomersAuthenticatePasswordChangeController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody } from \"@nestia/core\";\nimport typia from \"typia\";\n\nimport { IShoppingMember } from \"../../../../../../api/structures/IShoppingMember\";\n\n@Controller(\"/shoppings/customers/authenticate/password/change\")\nexport class ShoppingsCustomersAuthenticatePasswordChangeController {\n  /**\n   * Change password.\n   *\n   * Change password of {@link IShoppingMember member} with the current\n   * password.\n   *\n   * The reason why the current password is required is for security.\n   *\n   * @param body New password and current password\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Put()\n  public async put(\n    @TypedBody()\n    body: IShoppingMember.IPasswordChange,\n  ): Promise<void> {\n    body;\n    return typia.random<void>();\n  }\n}\n",
  "src/controllers/shoppings/customers/coupons/ShoppingsCustomersCouponsController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody, TypedParam } from \"@nestia/core\";\nimport typia from \"typia\";\n\nimport { IPageIShoppingCoupon } from \"../../../../api/structures/IPageIShoppingCoupon\";\nimport { IShoppingCoupon } from \"../../../../api/structures/IShoppingCoupon\";\n\n@Controller(\"/shoppings/customers/coupons\")\nexport class ShoppingsCustomersCouponsController {\n  /**\n   * List up every coupons.\n   *\n   * List up every {@link IShoppingCoupon coupons} with pagination.\n   *\n   * If you want, you can limit the result by configuring\n   * {@link IShoppingCoupon.IRequest.search search condition} in the request\n   * body. Also, it is possible to customize sequence order of records by\n   * configuring {@link IShoppingCoupon.IRequest.sort sort condition}.\n   *\n   * For reference, if you are a {@link IShoppingCustomer customer}, then only\n   * {@link IShoppingCouponTicket ticketable} coupons would be listed up.\n   * Otherwise, non-ticketable coupons would also be listed up.\n   *\n   * @param body Request info of pagination, searching and sorting\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patch(\n    @TypedBody()\n    body: IShoppingCoupon.IRequest,\n  ): Promise<IPageIShoppingCoupon> {\n    body;\n    return typia.random<IPageIShoppingCoupon>();\n  }\n\n  /**\n   * Get a coupon info.\n   *\n   * Get a {@link IShoppingCoupon coupon} information.\n   *\n   * If you are a {@link IShoppingCustomer customer}, then only\n   * {@link IShoppingCouponTicket ticketable} coupons are accessible. Non\n   * ticketable coupons cause 410 gone error. Otherwise you are a\n   * {@link IShoppingSeller seller} or\n   * {@link IShoppingAdministrator administrator}, non-ticketable coupons are\n   * also accessible.\n   *\n   * @param id Target coupon's {@link IShoppingCoupon.id }\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get(\":id\")\n  public async getById(\n    @TypedParam(\"id\")\n    id: string,\n  ): Promise<IShoppingCoupon> {\n    id;\n    return typia.random<IShoppingCoupon>();\n  }\n}\n",
  "src/controllers/shoppings/customers/coupons/tickets/ShoppingsCustomersCouponsTicketsController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody, TypedParam } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IShoppingCouponTicket } from \"../../../../../api/structures/IShoppingCouponTicket\";\nimport { IPageIShoppingCouponTicket } from \"../../../../../api/structures/IPageIShoppingCouponTicket\";\n\n@Controller(\"/shoppings/customers/coupons/tickets\")\nexport class ShoppingsCustomersCouponsTicketsController {\n  /**\n   * Create a new coupon ticket.\n   *\n   * Create a new {@link IShoppingCouponTicket coupon ticket} of a specific\n   * {@link IShoppingCoupon coupon} for the {@link IShoppingCustomer customer}.\n   *\n   * By the way, if the target coupon has been\n   * {@link IShoppingCoupon.expired_at expired} or\n   * {@link IShoppingCoupon.IInventory.volume out of stock} or\n   * {@link IShoppingCoupon.IInventory.volume_per_citizen exhausted for him/her},\n   * 410 gone exception would be thrown.\n   *\n   * Also, even though succeeded to create a new coupon ticket from the target\n   * coupon, if the coupon has expiration day or date, the newly created\n   * ticket also has {@link IShoppingCouponTicket.expired_at expiration time},\n   * and it would be disabled after the expiration time.\n   *\n   * @param body Creation info of coupon ticket\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Post()\n  public async post(\n    @TypedBody()\n    body: IShoppingCouponTicket.ICreate,\n  ): Promise<IShoppingCouponTicket> {\n    body;\n    return typia.random<IShoppingCouponTicket>();\n  }\n\n  /**\n   * List up every coupon tickets.\n   *\n   * List up every {@link IShoppingCouponTicket coupon tickets} of the\n   * {@link IShoppingCustomer customer} with {@link IPage pagination}.\n   *\n   * For reference, coupon ticket means that a {@link IShoppingCoupon coupon}\n   * has been taken by a customer. If the target coupon has expiration day or\n   * date, the coupon ticket also has\n   * {@link IShoppingCouponTicket.expired_at expiration time}, and such expired\n   * tickets would not be listed up. Likewise, tickets used to\n   * {@link IShoppingCouponTicketPayment pay} for the\n   * {@link IShoppingOrder order} would not be listed up, either.\n   *\n   * Additionally, you can limit the result by configuring\n   * {@link IShoppingCouponTicket.IRequest.search search condition} in the\n   * request body. Also, it is possible to customize sequence order of records\n   * by configuring\n   * {@link IShoppingCouponTicket.IRequest.sort sort condition}.\n   *\n   * @param body Request info of pagination, searching and sorting\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patch(\n    @TypedBody()\n    body: IShoppingCouponTicket.IRequest,\n  ): Promise<IPageIShoppingCouponTicket> {\n    body;\n    return typia.random<IPageIShoppingCouponTicket>();\n  }\n\n  /**\n   * Get a coupon ticket.\n   *\n   * Get a {@link IShoppingCouponTicket coupon ticket} information with its ID.\n   *\n   * By the way, if the target coupon ticket has been\n   * {@link IShoppingCouponTicket.expired_at expired} or used to\n   * {@link IShoppingCouponTicketPayment pay} for the\n   * {@link IShoppingOrder order}, 410 gone exception would be thrown.\n   *\n   * @param id Target coupon ticket's {@link IShoppingCouponTicket.id }\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get(\":id\")\n  public async getById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<IShoppingCouponTicket> {\n    id;\n    return typia.random<IShoppingCouponTicket>();\n  }\n}\n",
  "src/controllers/shoppings/customers/deposits/charges/ShoppingsCustomersDepositsChargesController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody, TypedParam } from \"@nestia/core\";\nimport typia from \"typia\";\n\nimport { IShoppingDepositCharge } from \"../../../../../api/structures/IShoppingDepositCharge\";\nimport { IPageIShoppingDepositCharge } from \"../../../../../api/structures/IPageIShoppingDepositCharge\";\n\n@Controller(\"/shoppings/customers/deposits/charges\")\nexport class ShoppingsCustomersDepositsChargesController {\n  /**\n   * Create a new deposit charge application.\n   *\n   * Create a new {@link IShoppingDepositCharge deposit charge application}.\n   *\n   * By the way, this function does not mean completion the deposit charge,\n   * but means just {@link IShoppingCustomer customer} is applying the deposit\n   * charge. The deposit charge be completed only when customer\n   * {@link IShoppingDepositChargePublish.publish pay} the deposit charge.\n   *\n   * @param body Creation info of the deposit charge\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Post()\n  public async post(\n    @TypedBody()\n    body: IShoppingDepositCharge.ICreate,\n  ): Promise<IShoppingDepositCharge> {\n    body;\n    return typia.random<IShoppingDepositCharge>();\n  }\n\n  /**\n   * List up every deposit charges.\n   *\n   * List up every {@link IShoppingDepositCharge deposit charges} of the\n   * {@link IShoppingCustomer customer} with {@link IPage pagination}.\n   *\n   * If you want, you can limit the result by configuring\n   * {@link IShoppingDepositCharge.IRequest.search search condition} in the\n   * request body. Also, it is possible to customize sequence order of records\n   * by configuring\n   * {@link IShoppingDepositCharge.IRequest.sort sort condition}.\n   *\n   * @param body Request info of pagination, searching and sorting\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patch(\n    @TypedBody()\n    body: IShoppingDepositCharge.IRequest,\n  ): Promise<IPageIShoppingDepositCharge> {\n    body;\n    return typia.random<IPageIShoppingDepositCharge>();\n  }\n\n  /**\n   * Get a deposit charge info.\n   *\n   * Get a {@link IShoppingDepositCharge deposit charge} information.\n   *\n   * @param id Target deposit charge's {@link IShoppingDepositCharge.id }\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get(\":id\")\n  public async getById(\n    @TypedParam(\"id\")\n    id: string,\n  ): Promise<IShoppingDepositCharge> {\n    id;\n    return typia.random<IShoppingDepositCharge>();\n  }\n\n  /**\n   * Update a deposit charge application.\n   *\n   * Update value of a\n   * {@link IShoppingDepositCharge deposit charge application} that has been\n   * applied by the {@link IShoppingCustomer}.\n   *\n   * If the charge has been {@link IShoppingDepositChargePublish published},\n   * then it is not possible to update the deposit charge. Only 410 gone\n   * exception would be thrown.\n   *\n   * @param id Target deposit charge's {@link IShoppingDepositCharge.id }\n   * @param body Value to change\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Put(\":id\")\n  public async putById(\n    @TypedParam(\"id\")\n    id: string,\n    @TypedBody()\n    body: IShoppingDepositCharge.ICreate,\n  ): Promise<void> {\n    id;\n    body;\n    return typia.random<void>();\n  }\n\n  /**\n   * Erase a deposit charge application.\n   *\n   * Erase a {@link IShoppingDepositCharge deposit charge application} that has\n   * been applied by the {@link IShoppingCustomer}.\n   *\n   * If the charge has been {@link IShoppingDepositChargePublish published},\n   * then it is not possible to erase the deposit charge. In that case, you've\n   * to cancel the payment by calling the {@link publish.cancel} function.\n   *\n   * @param id Target deposit charge's {@link IShoppingDepositCharge.id }\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Delete(\":id\")\n  public async eraseById(\n    @TypedParam(\"id\")\n    id: string,\n  ): Promise<void> {\n    id;\n    return typia.random<void>();\n  }\n}\n",
  "src/controllers/shoppings/customers/deposits/charges/publish/able/ShoppingsCustomersDepositsChargesPublishAbleController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedParam } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\n@Controller(\"/shoppings/customers/deposits/charges/:chargeId/publish/able\")\nexport class ShoppingsCustomersDepositsChargesPublishAbleController {\n  /**\n   * Check publishable.\n   *\n   * Test whether the {@link IShoppingDepositCharge charge} is publishable or\n   * not.\n   *\n   * If the charge has not been {@link IShoppingDepositChargePublish published}\n   * and not deleted yet, then it is possible to publish the charge\n   *\n   * @param chargeId Target charge's {@link IShoppingDepositCharge.id }\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get()\n  public async getByChargeid(\n    @TypedParam(\"chargeId\")\n    chargeId: string & tags.Format<\"uuid\">,\n  ): Promise<void> {\n    chargeId;\n    return typia.random<void>();\n  }\n}\n",
  "src/controllers/shoppings/customers/deposits/charges/publish/ShoppingsCustomersDepositsChargesPublishController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedParam, TypedBody } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IShoppingDepositChargePublish } from \"../../../../../../api/structures/IShoppingDepositChargePublish\";\n\n@Controller(\"/shoppings/customers/deposits/charges/:chargeId/publish\")\nexport class ShoppingsCustomersDepositsChargesPublishController {\n  /**\n   * Publish a charge.\n   *\n   * {@link IShoppingDepositChargePublish Publish} a\n   * {@link IShoppingDepositCharge charge} that has been applied by the\n   * {@link IShoppingCustomer} with payment information gotten from the payment\n   * vendor system.\n   *\n   * Also, the payment time can be different with the publish time. For\n   * example, if the payment method is manual bank account transfer, then the\n   * payment would be delayed until the customer actually transfer the money.\n   * In that case, {@link IShoppingDepositChargePublish.paid_at} would be\n   * `null` value, so that you have to check it after calling this publish\n   * function.\n   *\n   * @param chargeId Target charge's {@link IShoppingDepositCharge.id }\n   * @param body Creation info of the publish\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Post()\n  public async postByChargeid(\n    @TypedParam(\"chargeId\")\n    chargeId: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IShoppingDepositChargePublish.ICreate,\n  ): Promise<IShoppingDepositChargePublish> {\n    chargeId;\n    body;\n    return typia.random<IShoppingDepositChargePublish>();\n  }\n}\n",
  "src/controllers/shoppings/customers/deposits/histories/ShoppingsCustomersDepositsHistoriesController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody, TypedParam } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IPageIShoppingDepositHistory } from \"../../../../../api/structures/IPageIShoppingDepositHistory\";\nimport { IShoppingDepositHistory } from \"../../../../../api/structures/IShoppingDepositHistory\";\n\n@Controller(\"/shoppings/customers/deposits/histories\")\nexport class ShoppingsCustomersDepositsHistoriesController {\n  /**\n   * List up every deposit histories.\n   *\n   * List up every {@link IShoppingDepositHistory deposit histories} of the\n   * {@link IShoppingCustomer customer} with {@link IPage pagination}.\n   *\n   * If you want, you can limit the result by configuring\n   * {@link IShoppingDepositHistory.IRequest.search search condition} in the\n   * request body. Also, it is possible to customize sequence order of records\n   * by configuring\n   * {@link IShoppingDepositHistory.IRequest.sort sort condition}.\n   *\n   * @param body Request info of pagination, searching and sorting\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patch(\n    @TypedBody()\n    body: IShoppingDepositHistory.IRequest,\n  ): Promise<IPageIShoppingDepositHistory> {\n    body;\n    return typia.random<IPageIShoppingDepositHistory>();\n  }\n\n  /**\n   * Get a deposit history info.\n   *\n   * Get a {@link IShoppingDepositHistory deposit history} information.\n   *\n   * @param id Describe description as much as possible with clear and concise\n   *   words.\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get(\":id\")\n  public async getById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<IShoppingDepositHistory> {\n    id;\n    return typia.random<IShoppingDepositHistory>();\n  }\n}\n",
  "src/controllers/shoppings/customers/deposits/histories/balance/ShoppingsCustomersDepositsHistoriesBalanceController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute } from \"@nestia/core\";\nimport typia from \"typia\";\n\n@Controller(\"/shoppings/customers/deposits/histories/balance\")\nexport class ShoppingsCustomersDepositsHistoriesBalanceController {\n  /**\n   * Get balance of the deposit.\n   *\n   * Get current balance of the deposit of the\n   * {@link IShoppingCustomer customer}.\n   *\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get()\n  public async get(): Promise<void> {\n    return typia.random<void>();\n  }\n}\n",
  "src/controllers/shoppings/customers/mileages/histories/ShoppingsCustomersMileagesHistoriesController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody, TypedParam } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IPageIShoppingMileageHistory } from \"../../../../../api/structures/IPageIShoppingMileageHistory\";\nimport { IShoppingMileageHistory } from \"../../../../../api/structures/IShoppingMileageHistory\";\n\n@Controller(\"/shoppings/customers/mileages/histories\")\nexport class ShoppingsCustomersMileagesHistoriesController {\n  /**\n   * List up every mileage histories.\n   *\n   * List up every {@link IShoppingMileageHistory mileage histories} of the\n   * {@link IShoppingCustomer customer} with {@link IPage pagination}.\n   *\n   * If you want, you can limit the result by configuring\n   * {@link IShoppingMileageHistory.IRequest.search search condition} in the\n   * request body. Also, it is possible to customize sequence order of records\n   * by configuring\n   * {@link IShoppingMileageHistory.IRequest.sort sort condition}.\n   *\n   * @param body Request info of pagination, searching and sorting\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patch(\n    @TypedBody()\n    body: IShoppingMileageHistory.IRequest,\n  ): Promise<IPageIShoppingMileageHistory> {\n    body;\n    return typia.random<IPageIShoppingMileageHistory>();\n  }\n\n  /**\n   * Get a mileage history info.\n   *\n   * Get a {@link IShoppingMileageHistory mileage history} information.\n   *\n   * @param id Target mileage history's {@link IShoppingMileageHistory.id }\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get(\":id\")\n  public async getById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<IShoppingMileageHistory> {\n    id;\n    return typia.random<IShoppingMileageHistory>();\n  }\n}\n",
  "src/controllers/shoppings/customers/mileages/histories/balance/ShoppingsCustomersMileagesHistoriesBalanceController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute } from \"@nestia/core\";\nimport typia from \"typia\";\n\n@Controller(\"/shoppings/customers/mileages/histories/balance\")\nexport class ShoppingsCustomersMileagesHistoriesBalanceController {\n  /**\n   * Get balance of the mileage.\n   *\n   * Get current balance of the mileage of the\n   * {@link IShoppingCustomer customer}.\n   *\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get()\n  public async get(): Promise<void> {\n    return typia.random<void>();\n  }\n}\n",
  "src/controllers/shoppings/customers/carts/commodities/ShoppingsCustomersCartsCommoditiesController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody, TypedParam } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IShoppingCartCommodity } from \"../../../../../api/structures/IShoppingCartCommodity\";\nimport { IPageIShoppingCartCommodity } from \"../../../../../api/structures/IPageIShoppingCartCommodity\";\n\n@Controller(\"/shoppings/customers/carts/commodities\")\nexport class ShoppingsCustomersCartsCommoditiesController {\n  /**\n   * Create a new commodity.\n   *\n   * Create a new {@link IShoppingCartCommodity commodity} into a specific\n   * shopping cart.\n   *\n   * If {@link IShoppingCartCommodity.ICreate.accumulate} has `true` value and\n   * there's some same commodity that composed with same\n   * {@link IShoppingSaleUnitStock.IInvert stocks and quantities}, then new\n   * commodity would not be created but the volume would be accumulated.\n   *\n   * By the way, if the target {@link IShoppingSale sale} has been suspended or\n   * {@link IShoppingSaleUnitStockInventory out of stock}, then 410 gone error\n   * would be thrown. Therefore, it would better to check the target sale and\n   * {@link IShoppingSaleUnitStock stock}'s status before.\n   *\n   * @param body Creation info of the commodity\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Post()\n  public async post(\n    @TypedBody()\n    body: IShoppingCartCommodity.ICreate,\n  ): Promise<IShoppingCartCommodity> {\n    body;\n    return typia.random<IShoppingCartCommodity>();\n  }\n\n  /**\n   * List of every commodities.\n   *\n   * List up every {@link IShoppingCartCommodity commodities} in the shopping\n   * cart with {@link IPage pagination}.\n   *\n   * You can limit the result by configuring\n   * {@link IShoppingCartCommodity.IRequest.search search condition} in the\n   * request body. Furthermore, it is possible to customize sequence order of\n   * records by configuring {@link IShoppingCartCommodity.IRequest.sort}.\n   *\n   * For reference, when some commodity be {@link IShoppingOrder ordered} and\n   * {@link IShoppingOrderPublish published}, then it would not be appread in\n   * the shopping cart more. Otherwise, the order has not been published yet,\n   * it would be appread in the shopping cart and still enable to create a new\n   * {@link IShoppingOrder order application} with the same commodity.\n   *\n   * Of course, if the target {@link IShoppingSale sale} has been suspended, or\n   * {@link IShoppingSaleUnitStockInventory out of stock}, then it would not be\n   * appread in the shopping cart more, either.\n   *\n   * @param body Request info of pagination, searching and sorting\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patch(\n    @TypedBody()\n    body: IShoppingCartCommodity.IRequest,\n  ): Promise<IPageIShoppingCartCommodity> {\n    body;\n    return typia.random<IPageIShoppingCartCommodity>();\n  }\n\n  /**\n   * Get a commodity.\n   *\n   * Get a {@link IShoppingCartCommodity commodity} record of the shopping\n   * cart.\n   *\n   * If target {@link IShoppingSale sale} has been suspended or\n   * {@link IShoppingSaleUnitStockInventory out of stock}, then 410 gone error\n   * would be thrown. Therefore, even if you've created a commodity\n   * successfully with the {@link create} method, it still can be failed when\n   * you access the commodity with this {@link at} method.\n   *\n   * @param id Target commodity's {@link IShoppingCartCommodity.id }\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get(\":id\")\n  public async getById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<IShoppingCartCommodity> {\n    id;\n    return typia.random<IShoppingCartCommodity>();\n  }\n\n  /**\n   * Update a commodity (volume).\n   *\n   * Update a {@link IShoppingCartCommodity commodity}'s volume in the shopping\n   * cart.\n   *\n   * If target {@link IShoppingSale sale} has been suspended or\n   * {@link IShoppingSaleUnitStockInventory out of stock} suddenly, then 410\n   * gone error would be thrown, either.\n   *\n   * @param id Target commodity's {@link IShoppingCartCommodity.id }\n   * @param body Update info of the commodity (volume)\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Put(\":id\")\n  public async putById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IShoppingCartCommodity.IUpdate,\n  ): Promise<void> {\n    id;\n    body;\n    return typia.random<void>();\n  }\n\n  /**\n   * Erase a commodity.\n   *\n   * Erase a {@link IShoppingCartCommodity commodity} from the shopping cart.\n   *\n   * If the commodity is on an {@link IShoppingOrder order} process, it is not\n   * possible to erase it. Instead, if the order has been\n   * {@link IShoppingOrderPublish published}, then it would not be appread in\n   * the shopping cart more. If the order be erased, then you also can\n   * continue erasinng the commodity, neither.\n   *\n   * @param id Target commodity's {@link IShoppingCartCommodity.id }\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Delete(\":id\")\n  public async eraseById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<void> {\n    id;\n    return typia.random<void>();\n  }\n}\n",
  "src/controllers/shoppings/customers/carts/commodities/replica/ShoppingsCustomersCartsCommoditiesReplicaController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedParam } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IShoppingCartCommodity } from \"../../../../../../api/structures/IShoppingCartCommodity\";\n\n@Controller(\"/shoppings/customers/carts/commodities/:id/replica\")\nexport class ShoppingsCustomersCartsCommoditiesReplicaController {\n  /**\n   * Get replica of a commodity.\n   *\n   * Get a {@link IShoppingCartCommodity.ICreate} typed info of the target\n   * commodity for replication.\n   *\n   * If target {@link IShoppingSale sale} has been suspended or\n   * {@link IShoppingSaleUnitStockInventory out of stock} suddenly, then 410\n   * gone error would be thrown, either.\n   *\n   * @param id Target commodity's {@link IShoppingCartCommodity.id }\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get()\n  public async getById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<IShoppingCartCommodity.ICreate> {\n    id;\n    return typia.random<IShoppingCartCommodity.ICreate>();\n  }\n}\n",
  "src/controllers/shoppings/customers/carts/commodities/discountable/ShoppingsCustomersCartsCommoditiesDiscountableController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody } from \"@nestia/core\";\nimport typia from \"typia\";\n\nimport { IShoppingCartDiscountable } from \"../../../../../../api/structures/IShoppingCartDiscountable\";\n\n@Controller(\"/shoppings/customers/carts/commodities/discountable\")\nexport class ShoppingsCustomersCartsCommoditiesDiscountableController {\n  /**\n   * Get discountable info.\n   *\n   * Compute discountable features about the\n   * {@link IShoppingCartCommodity shopping cart} even including non-carted\n   * {@link IShoppingSale sales}.\n   *\n   * Returned {@link IShoppingCartDiscountable} contains including combinations\n   * of adjustable {@link IShoppingCoupon coupons}, withdrawable\n   * {@link IShoppingDepositHistory deposits} and\n   * {@link IShoppingMileageHistory mileages}.\n   *\n   * If you want to know the discountable info about some specific sales that\n   * have not been carted yet, specify the sales to the\n   * {@link IShoppingCartDiscountable.pseudos} property with composing\n   * {@link IShoppingCartCommodity.ICreate creation info of the commodities}.\n   * Then, they would be included in the discountable info.\n   *\n   * @param body Request info for discountable\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patch(\n    @TypedBody()\n    body: IShoppingCartDiscountable.IRequest,\n  ): Promise<IShoppingCartDiscountable> {\n    body;\n    return typia.random<IShoppingCartDiscountable>();\n  }\n}\n",
  "src/controllers/shoppings/customers/orders/ShoppingsCustomersOrdersController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody, TypedParam } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IShoppingOrder } from \"../../../../api/structures/IShoppingOrder\";\nimport { IPageIShoppingOrder } from \"../../../../api/structures/IPageIShoppingOrder\";\n\n@Controller(\"/shoppings/customers/orders\")\nexport class ShoppingsCustomersOrdersController {\n  /**\n   * Create a new order application.\n   *\n   * Create a new {@link IShoppingOrder order application} from a\n   * {@link IShoppingCartCommodity shopping cart} that has been composed by the\n   * {@link IShoppingCustomer}. Of course, do not need to put every commodities\n   * to the order, but possible to select some of them by the customer.\n   *\n   * By the way, this function does not mean completion the order, but means\n   * just customer is applying the order. The order be completed only when\n   * customer {@link IShoppingOrderPublish.paid_at pays} the order.\n   *\n   * > If you are an A.I. chatbot, don't take a mistake that writing the\n   * > `commodity_id` with the user selected stock ID. The `commodity_id` is the\n   * > ID of the shopping cart commodity, not the stock ID. The stock ID is\n   * > already included in the shopping cart commodity.\n   *\n   * @param body Creation info of the order\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Post()\n  public async post(\n    @TypedBody()\n    body: IShoppingOrder.ICreate,\n  ): Promise<IShoppingOrder> {\n    body;\n    return typia.random<IShoppingOrder>();\n  }\n\n  /**\n   * List up every orders.\n   *\n   * List up every {@link IShoppingOrder orders} with pagination.\n   *\n   * If you want, you can limit the result by configuring\n   * {@link IShoppingOrder.IRequest.search search condition} in the request\n   * body. Also, it is possible to customize sequence order of records by\n   * configuring {@link IShoppingOrder.IRequest.sort sort condition}.\n   *\n   * For reference, if you are a {@link IShoppingCustomer customer}, then you\n   * can list up your own orders, and it is not a matter whether the order has\n   * been {@link IShoppingOrderPublish.paid_at paid} or not.\n   *\n   * Otherwise you are a {@link IShoppingSeller seller} or\n   * {@link IShoppingAdministrator administrator}, then you can list up only\n   * paid orders. Also, in the seller case, only related\n   * {@link IShoppingOrder.goods goods} would be listed up in the order.\n   *\n   * @param body Request info of pagination, searching and sorting\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patch(\n    @TypedBody()\n    body: IShoppingOrder.IRequest,\n  ): Promise<IPageIShoppingOrder> {\n    body;\n    return typia.random<IPageIShoppingOrder>();\n  }\n\n  /**\n   * Get an order info.\n   *\n   * Get a detailed {@link IShoppingOrder order} information.\n   *\n   * If you are not a {@link IShoppingCustomer customer}, then you can't access\n   * to the order which has not been {@link IShoppingOrderPublish.paid_at paid}\n   * yet. In that case, 404 not found error would be thrown.\n   *\n   * @param id Target order's {@link IShoppingOrder.id }\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get(\":id\")\n  public async getById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<IShoppingOrder> {\n    id;\n    return typia.random<IShoppingOrder>();\n  }\n\n  /**\n   * Erase an order application.\n   *\n   * Erase an order application that has been applied by the\n   * {@link IShoppingCustomer}.\n   *\n   * If the order has been {@link IShoppingOrderPublish published}, then it is\n   * not possible to erase the order. In that case, you've to cancel the\n   * payment by calling the {@link publish.cancel} function.\n   *\n   * @param id Target order's {@link IShoppingOrder.id }\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Delete(\":id\")\n  public async eraseById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<void> {\n    id;\n    return typia.random<void>();\n  }\n}\n",
  "src/controllers/shoppings/customers/orders/direct/ShoppingsCustomersOrdersDirectController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody } from \"@nestia/core\";\nimport typia from \"typia\";\n\nimport { IShoppingOrder } from \"../../../../../api/structures/IShoppingOrder\";\nimport { IShoppingCartCommodity } from \"../../../../../api/structures/IShoppingCartCommodity\";\n\n@Controller(\"/shoppings/customers/orders/direct\")\nexport class ShoppingsCustomersOrdersDirectController {\n  /**\n   * Create a new order application without a shopping cart.\n   *\n   * Carete a new {@link IShoppingOrder order application} without a\n   * {@link IShoppingCartCommodity shopping cart commodity} composition. If\n   * you're an A.I. chatbot and user wants to directly purchase a product,\n   * then select and call this function.\n   *\n   * By the way, this function does not mean completion the order, but means\n   * just customer is applying the order. The order be completed only when\n   * customer {@link IShoppingOrderPublish.paid_at pays} the order.\n   *\n   * @param body Creation info of the order without a shopping cart\n   *   composition\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Post()\n  public async post(\n    @TypedBody()\n    body: IShoppingCartCommodity.ICreate,\n  ): Promise<IShoppingOrder> {\n    body;\n    return typia.random<IShoppingOrder>();\n  }\n}\n",
  "src/controllers/shoppings/customers/orders/price/ShoppingsCustomersOrdersPriceController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedParam } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IShoppingOrderPrice } from \"../../../../../api/structures/IShoppingOrderPrice\";\n\n@Controller(\"/shoppings/customers/orders/:id/price\")\nexport class ShoppingsCustomersOrdersPriceController {\n  /**\n   * Get price of the order.\n   *\n   * Get detailed price information of the {@link IShoppingOrder order}.\n   *\n   * Returned price info contains not only the amount of the order, but also\n   * contains the discount amount by {@link IShoppingCoupono coupons},\n   * {@link IShoppingDepositHistory deposits} and\n   * {@link IShoppingMileageHistory mileages}.\n   *\n   * @param id Target order's {@link IShoppingOrder.id }\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get()\n  public async getById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<IShoppingOrderPrice> {\n    id;\n    return typia.random<IShoppingOrderPrice>();\n  }\n}\n",
  "src/controllers/shoppings/customers/orders/discountable/ShoppingsCustomersOrdersDiscountableController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedParam, TypedBody } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IShoppingOrderDiscountable } from \"../../../../../api/structures/IShoppingOrderDiscountable\";\n\n@Controller(\"/shoppings/customers/orders/:id/discountable\")\nexport class ShoppingsCustomersOrdersDiscountableController {\n  /**\n   * Get discountable info.\n   *\n   * Compute discountable features about the {@link IShoppingOrder}.\n   *\n   * Returned {@link IShoppingOrderDiscountable} contains including\n   * combinations of adjustable {@link IShoppingCoupon coupons}, withdrawable\n   * {@link IShoppingDepositHistory deposits} and\n   * {@link IShoppingMileageHistory mileages}.\n   *\n   * Of course, returned features are valid only when the order has not been\n   * {@link IShoppingOrderPublish published} yet. If the order has already been\n   * published, then no way to discount the price more.\n   *\n   * @param id Target order's {@link IShoppingOrder.id }\n   * @param body Request info for discountable\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patchById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IShoppingOrderDiscountable.IRequest,\n  ): Promise<IShoppingOrderDiscountable> {\n    id;\n    body;\n    return typia.random<IShoppingOrderDiscountable>();\n  }\n}\n",
  "src/controllers/shoppings/customers/orders/discount/ShoppingsCustomersOrdersDiscountController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedParam, TypedBody } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IShoppingOrderPrice } from \"../../../../../api/structures/IShoppingOrderPrice\";\n\n@Controller(\"/shoppings/customers/orders/:id/discount\")\nexport class ShoppingsCustomersOrdersDiscountController {\n  /**\n   * Discount the order.\n   *\n   * Discount total price of the {@link IShoppingOrder} by adjusting\n   * {@link IShoppingCoupon coupons}, {@link IShoppingDepositHistory deposits}\n   * and {@link IShoppingMileageHistory mileages}. If amount of discount\n   * features are equal to the total price of the order, it is possible to\n   * {@link IShoppingOrderPublish publish} it without any cash.\n   *\n   * By the way, the discounting features must be valid. If not, 428\n   * unprocessable entity error would be thrown. To know which features are\n   * adjustable or withdrawable, call the {@link discountable} function\n   * before.\n   *\n   * @param id Target order's {@link IShoppingOrder.id }\n   * @param body Discount info\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Put()\n  public async putById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IShoppingOrderPrice.ICreate,\n  ): Promise<IShoppingOrderPrice> {\n    id;\n    body;\n    return typia.random<IShoppingOrderPrice>();\n  }\n}\n",
  "src/controllers/shoppings/customers/orders/goods/confirm/ShoppingsCustomersOrdersGoodsConfirmController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedParam } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\n@Controller(\"/shoppings/customers/orders/:orderId/goods/:id/confirm\")\nexport class ShoppingsCustomersOrdersGoodsConfirmController {\n  /**\n   * Confirm an order good.\n   *\n   * Confirm an {@link IShoppingOrderGood order good} that has been completed\n   * {@link IShoppingDelivery delivering} to the\n   * {@link IShoppingCustomer customer}.\n   *\n   * In other words, belonged {@link IShoppingOrder order} must be\n   * {@link IShoppingPublish.paid_at published, paid} and delivery of the good\n   * must be {@link IShoppingDeliveryJourney arrived} to the customer. If not,\n   * 428 unprocessable entity error would be thrown.\n   *\n   * @param orderId Belonged order's {@link IShoppingOrder.id }\n   * @param id Target good's {@link IShoppingOrderGood.id }\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Put()\n  public async putByOrderidAndId(\n    @TypedParam(\"orderId\")\n    orderId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<void> {\n    orderId;\n    id;\n    return typia.random<void>();\n  }\n}\n",
  "src/controllers/shoppings/customers/orders/publish/able/ShoppingsCustomersOrdersPublishAbleController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedParam } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\n@Controller(\"/shoppings/customers/orders/:orderId/publish/able\")\nexport class ShoppingsCustomersOrdersPublishAbleController {\n  /**\n   * Check publishable.\n   *\n   * Test whether the {@link IShoppingOrder order} is publishable or not.\n   *\n   * If the order has not been {@link IShoppingOrderPublish published} and not\n   * deleted yet, then it is possible to publish the order. Even thouogh\n   * target {@link IShoppingSale sale} is suspended or\n   * {@link IShoppingSaleUnitStockInventory out of stock}, it is still possible\n   * to publish because the order already has been applied.\n   *\n   * @param orderId Target order's {@link IShoppingOrder.id }\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get()\n  public async getByOrderid(\n    @TypedParam(\"orderId\")\n    orderId: string & tags.Format<\"uuid\">,\n  ): Promise<void> {\n    orderId;\n    return typia.random<void>();\n  }\n}\n",
  "src/controllers/shoppings/customers/orders/publish/ShoppingsCustomersOrdersPublishController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedParam, TypedBody } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IShoppingOrderPublish } from \"../../../../../api/structures/IShoppingOrderPublish\";\n\n@Controller(\"/shoppings/customers/orders/:orderId/publish\")\nexport class ShoppingsCustomersOrdersPublishController {\n  /**\n   * Publish an order.\n   *\n   * {@link IShoppingOrderPublish Publish} an {@link IShoppingOrder order} that\n   * has been applied by the {@link IShoppingCustomer} with\n   * {@link IShoppingAddress address} to delivery and payment information\n   * gotten from the payment vendor system.\n   *\n   * If the order has been discounted for entire order price, then no need to\n   * send payment vendor info. Instead, only address info is required.\n   *\n   * Also, the payment time can be different with the publish time. For\n   * example, if the payment method is manual bank account transfer, then the\n   * payment would be delayed until the customer actually transfer the money.\n   * In that case, {@link IShoppingOrderPublish.paid_at} would be `null` value,\n   * so that you have to check it after calling this publish function.\n   *\n   * @param orderId Target order's {@link IShoppingOrder.id }\n   * @param body Creation info of the publish\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Post()\n  public async postByOrderid(\n    @TypedParam(\"orderId\")\n    orderId: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IShoppingOrderPublish.ICreate,\n  ): Promise<IShoppingOrderPublish> {\n    orderId;\n    body;\n    return typia.random<IShoppingOrderPublish>();\n  }\n\n  /**\n   * Cancel the publish (payment).\n   *\n   * Cancel payment of an {@link IShoppingOrder order} that has been\n   * {@link IShoppingOrderPublish published}.\n   *\n   * If target publish's payment method is manual bank account transfer, then\n   * it would be cancelled directly. If not, then payment cancel request would\n   * be sent to the payment vendor system.\n   *\n   * @param orderId Target order's {@link IShoppingOrder.id }\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Delete()\n  public async eraseByOrderid(\n    @TypedParam(\"orderId\")\n    orderId: string & tags.Format<\"uuid\">,\n  ): Promise<void> {\n    orderId;\n    return typia.random<void>();\n  }\n}\n",
  "src/controllers/shoppings/customers/sales/details/ShoppingsCustomersSalesDetailsController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody } from \"@nestia/core\";\nimport typia from \"typia\";\n\nimport { IPageIShoppingSale } from \"../../../../../api/structures/IPageIShoppingSale\";\nimport { IShoppingSale } from \"../../../../../api/structures/IShoppingSale\";\n\n@Controller(\"/shoppings/customers/sales/details\")\nexport class ShoppingsCustomersSalesDetailsController {\n  /**\n   * List up every sales.\n   *\n   * List up every {@link IShoppingSale sales} with detailed information.\n   *\n   * As you can see, returned sales are detailed, not summarized. If you want\n   * to get the summarized information of sale for a brief, use {@link index}\n   * function instead.\n   *\n   * For reference, if you're a {@link IShoppingSeller seller}, you can only\n   * access to the your own {@link IShoppingSale sale}s. Otherwise you're a\n   * {@link IShoppingCustomer customer}, you can see only the operating sales\n   * in the market. Instead, you can't see the unopened, closed, or suspended\n   * sales.\n   *\n   * > If you're an A.I. chatbot, please don't summarize the\n   * > {@link IShoppingSaleUnitStock stock information}. Just list up the every\n   * > stocks in the sale with detailed information.\n   *\n   * @param body Request info of pagination, searching and sorting\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patch(\n    @TypedBody()\n    body: IShoppingSale.IRequest,\n  ): Promise<IPageIShoppingSale> {\n    body;\n    return typia.random<IPageIShoppingSale>();\n  }\n}\n",
  "src/controllers/shoppings/customers/sales/ShoppingsCustomersSalesController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody, TypedParam } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IPageIShoppingSale } from \"../../../../api/structures/IPageIShoppingSale\";\nimport { IShoppingSale } from \"../../../../api/structures/IShoppingSale\";\n\n@Controller(\"/shoppings/customers/sales\")\nexport class ShoppingsCustomersSalesController {\n  /**\n   * List up every summarized sales.\n   *\n   * List up every {@link IShoppingSale.ISummary summarized sales}.\n   *\n   * As you can see, returned sales are summarized, not detailed. It does not\n   * contain the SKU (Stock Keeping Unit) information represented by the\n   * {@link IShoppingSaleUnitOption} and {@link IShoppingSaleUnitStock} types.\n   * If you want to get such detailed information of a sale, use `GET\n   * /shoppings/customers/sales/{id}` operation for each sale.\n   *\n   * > If you're an A.I. chatbot, and the user wants to buy or compose\n   * > {@link IShoppingCartCommodity shopping cart} from a sale, please call the\n   * > `GET /shoppings/customers/sales/{id}` operation at least once to the\n   * > target sale to get detailed SKU information about the sale. It needs to\n   * > be run at least once for the next steps.\n   *\n   * @param body Request info of pagination, searching and sorting\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patch(\n    @TypedBody()\n    body: IShoppingSale.IRequest,\n  ): Promise<IPageIShoppingSale.ISummary> {\n    body;\n    return typia.random<IPageIShoppingSale.ISummary>();\n  }\n\n  /**\n   * Get a sale with detailed information.\n   *\n   * Get a {@link IShoppingSale sale} with detailed information including the\n   * SKU (Stock Keeping Unit) information represented by the\n   * {@link IShoppingSaleUnitOption} and {@link IShoppingSaleUnitStock} types.\n   *\n   * > If you're an A.I. chatbot, and the user wants to buy or compose a\n   * > {@link IShoppingCartCommodity shopping cart} from a sale, please call this\n   * > operation at least once to the target sale to get detailed SKU\n   * > information about the sale.\n   *\n   * > It needs to be run at least once for the next steps. In other words, if\n   * > you A.I. agent has called this operation to a specific sale, you don't\n   * > need to call this operation again for the same sale.\n   *\n   * > Additionally, please do not summarize the SKU information. Just show the\n   * > every options and stocks in the sale with detailed information.\n   *\n   * @param id Target sale's {@link IShoppingSale.id }\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get(\":id\")\n  public async getById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<IShoppingSale> {\n    id;\n    return typia.random<IShoppingSale>();\n  }\n}\n",
  "src/controllers/shoppings/customers/sales/questions/comments/ShoppingsCustomersSalesQuestionsCommentsController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedParam, TypedBody } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IShoppingSaleInquiryComment } from \"../../../../../../api/structures/IShoppingSaleInquiryComment\";\nimport { IPageIShoppingSaleInquiryComment } from \"../../../../../../api/structures/IPageIShoppingSaleInquiryComment\";\n\n@Controller(\"/shoppings/customers/sales/:saleId/questions/:inquiryId/comments\")\nexport class ShoppingsCustomersSalesQuestionsCommentsController {\n  /**\n   * Create an inquiry comment.\n   *\n   * Create an {@link IShoppingSaleInquiryComment inquiry comment} of a\n   * {@link IShoppingSaleQuestion question} or\n   * {@link IShoppingSaleReview review}.\n   *\n   * For reference, if you're a {@link IShoppingSeller seller}, you can only\n   * create an inquiry comment to your own {@link IShoppingSale sale}'s\n   * inquiry. Otherwise, you can create an inquiry comment to every inquiries\n   * of the sales.\n   *\n   * @param saleId Belonged sale's {@link IShoppingSale.id }\n   * @param inquiryId Target inquiry's {@link IShoppingSaleInquiry.id }\n   * @param body Creation info of the inquiry comment\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Post()\n  public async postBySaleidAndInquiryid(\n    @TypedParam(\"saleId\")\n    saleId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"inquiryId\")\n    inquiryId: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IShoppingSaleInquiryComment.ICreate,\n  ): Promise<IShoppingSaleInquiryComment> {\n    saleId;\n    inquiryId;\n    body;\n    return typia.random<IShoppingSaleInquiryComment>();\n  }\n\n  /**\n   * List up every inquiry comments.\n   *\n   * List up every {@link IShoppingSaleInquiryComment inquiry comments} of a\n   * {@link IShoppingSaleQuestion question} or\n   * {@link IShoppingSaleReview review} with {@link IPage pagination}.\n   *\n   * If you want, you can limit the result by configuring\n   * {@link IShoppingSaleInquiryComment.IRequest.search search condition} in\n   * the request body. Also, it is possible to customize sequence order of\n   * records by configuring\n   * {@link IShoppingSaleInquiryComment.IRequest.sort sort condition}.\n   *\n   * By the way, if you're a {@link IShoppingSeller seller}, you can only\n   * access to the your own {@link IShoppingSale sale}'s inquiries. Otherwise,\n   * you can access to every inquiries of the sales.\n   *\n   * @param saleId Belonged sale's {@link IShoppingSale.id }\n   * @param inquiryId Belonged inquiry's {@link IShoppingSaleInquiry.id }\n   * @param body Request info of pagination, searching and sorting\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patchBySaleidAndInquiryid(\n    @TypedParam(\"saleId\")\n    saleId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"inquiryId\")\n    inquiryId: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IShoppingSaleInquiryComment.IRequest,\n  ): Promise<IPageIShoppingSaleInquiryComment> {\n    saleId;\n    inquiryId;\n    body;\n    return typia.random<IPageIShoppingSaleInquiryComment>();\n  }\n\n  /**\n   * Get an inquiry comment info.\n   *\n   * Get a detailed {@link IShoppingSaleInquiryComment inquiry comment}\n   * information of a {@link IShoppingSaleQuestion question} or\n   * {@link IShoppingSaleReview review}.\n   *\n   * For reference, if you're a {@link IShoppingSeller seller}, you can only\n   * access to the your own {@link IShoppingSale sale}'s inquiry comment.\n   * Otherwise, you can access to every inquiry comments of the sales.\n   *\n   * @param saleId Belonged sale's {@link IShoppingSale.id }\n   * @param inquiryId Belonged inquiry's {@link IShoppingSaleInquiry.id }\n   * @param id Target inquiry comment's {@link IShoppingSaleInquiryComment.id }\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get(\":id\")\n  public async getBySaleidAndInquiryidAndId(\n    @TypedParam(\"saleId\")\n    saleId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"inquiryId\")\n    inquiryId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<IShoppingSaleInquiryComment> {\n    saleId;\n    inquiryId;\n    id;\n    return typia.random<IShoppingSaleInquiryComment>();\n  }\n\n  /**\n   * Update an inquiry comment.\n   *\n   * Update an {@link IShoppingSaleInquiryComment inquiry comment} to a\n   * specific {@link IShoppingSaleQuestion question} or\n   * {@link IShoppingSaleReview review}.\n   *\n   * By the way, as is the general policy of this shopping mall regarding\n   * comments, modifying a comment does not actually change the existing\n   * content. Modified content is accumulated and recorded in the existing\n   * comment record as a new\n   * {@link IShoppingSaleInquiryComment.ISnapshot snapshot}. And this is made\n   * public to everyone, who can read this inquiry comment.\n   *\n   * This is to prevent customers or sellers from modifying their comments and\n   * manipulating the circumstances due to the nature of e-commerce, where\n   * disputes easily arise. That is, to preserve evidence.\n   *\n   * @param saleId Belonged sale's {@link IShoppingSale.id }\n   * @param inquiryId Belonged inquiry's {@link IShoppingSaleInquiry.id }\n   * @param id Target inquiry comment's {@link IShoppingSaleInquiryComment.id }\n   * @param body Update info of the inquiry comment\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Put(\":id\")\n  public async putBySaleidAndInquiryidAndId(\n    @TypedParam(\"saleId\")\n    saleId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"inquiryId\")\n    inquiryId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IShoppingSaleInquiryComment.ICreate,\n  ): Promise<IShoppingSaleInquiryComment.ISnapshot> {\n    saleId;\n    inquiryId;\n    id;\n    body;\n    return typia.random<IShoppingSaleInquiryComment.ISnapshot>();\n  }\n}\n",
  "src/controllers/shoppings/customers/sales/questions/ShoppingsCustomersSalesQuestionsController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedParam, TypedBody } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IShoppingSaleQuestion } from \"../../../../../api/structures/IShoppingSaleQuestion\";\nimport { IPageIShoppingSaleQuestion } from \"../../../../../api/structures/IPageIShoppingSaleQuestion\";\nimport { IBbsArticle } from \"../../../../../api/structures/IBbsArticle\";\n\n@Controller(\"/shoppings/customers/sales/:saleId/questions\")\nexport class ShoppingsCustomersSalesQuestionsController {\n  /**\n   * Write a question article.\n   *\n   * When a {@link IShoppingCustomer customer} wants to ask something about a\n   * specific {@link IShoppingSale sale}, he/she can ask it by writing a new\n   * {@link IShoppingSaleQuestion question article}.\n   *\n   * If the customer does not want to reveal his/her identify and question,\n   * he/she can write the question as a secret article. In that case, only the\n   * customer and the related {@link IShoppingSeller seller} can see the\n   * {@link at detailed content}. Also, such secret question's title and writer\n   * name would be masked with `*` characters in the\n   * {@link index pagiation API}.\n   *\n   * @param saleId Belonged sale's {@link IShoppingSale.id }\n   * @param body Creation info of the question\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Post()\n  public async postBySaleid(\n    @TypedParam(\"saleId\")\n    saleId: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IShoppingSaleQuestion.ICreate,\n  ): Promise<IShoppingSaleQuestion> {\n    saleId;\n    body;\n    return typia.random<IShoppingSaleQuestion>();\n  }\n\n  /**\n   * List up every summarized questions.\n   *\n   * List up every {@link IShoppingSaleQuestion.ISummary summarized questions}\n   * of a {@link IShoppingSale sale}.\n   *\n   * As you can see, returned questions are summarized, not detailed. If you\n   * want to get the detailed information of a question, use {@link adridges}\n   * function or {@link at} function for each article.\n   *\n   * Also, returned question has {@link IShoppingSaleQuestion.ISummary.answer}\n   * property which means the formal answer from the {@link IShoppingSeller}.\n   * Additionally, returned question has another special property\n   * {@link IShoppingSaleQuestion.ISummary.secret} with masking to other\n   * princple properties, and it means only related actors can {@link at read}\n   * the question.\n   *\n   * For reference, if you're a {@link IShoppingSeller seller}, you can only\n   * access to the your own {@link IShoppingSale sale}'s questions. Otherwise,\n   * you can access to every questions of the sales.\n   *\n   * By the way, if you want, you can limit the result by configuring\n   * {@link IShoppingSaleQuestion.IRequest.search search condition} in the\n   * request body. Also, it is possible to customize sequence order of records\n   * by configuring\n   * {@link IShoppingSaleQuestion.IRequest.sort sort condition}.\n   *\n   * @param saleId Belonged sale's {@link IShoppingSale.id }\n   * @param body Request info of pagination, searching and sorting\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patchBySaleid(\n    @TypedParam(\"saleId\")\n    saleId: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IShoppingSaleQuestion.IRequest,\n  ): Promise<IPageIShoppingSaleQuestion.ISummary> {\n    saleId;\n    body;\n    return typia.random<IPageIShoppingSaleQuestion.ISummary>();\n  }\n\n  /**\n   * Get a question info.\n   *\n   * Get a detailed {@link IShoppingSaleQuestion question} information of a\n   * {@link IShoppingSale sale}.\n   *\n   * For reference, if you're a {@link IShoppingSeller seller}, you can only\n   * access to the your own {@link IShoppingSale sale}'s question. Otherwise\n   * you are a {@link IShoppingCustomer customer}, you can access to every\n   * questions of the sales except the {@link IShoppingSaleQuestion.secret}\n   * value is `false`.\n   *\n   * @param saleId Belonged sale's {@link IShoppingSale.id }\n   * @param id Target question's {@link IShoppingSaleQuestion.id }\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get(\":id\")\n  public async getBySaleidAndId(\n    @TypedParam(\"saleId\")\n    saleId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<IShoppingSaleQuestion> {\n    saleId;\n    id;\n    return typia.random<IShoppingSaleQuestion>();\n  }\n\n  /**\n   * Update a question.\n   *\n   * Update a {@link IShoppingSaleQuestion question}'s content.\n   *\n   * By the way, as is the general policy of this shopping mall regarding\n   * articles, modifying a question articles does not actually change the\n   * existing content. Modified content is accumulated and recorded in the\n   * existing article record as a new\n   * {@link IShoppingSaleQuestion.ISnapshot snapshot}. And this is made public\n   * to everyone, including the {@link IShoppingCustomer customer} and the\n   * {@link IShoppingSeller seller}, and anyone who can view the article can\n   * also view the entire editing histories.\n   *\n   * This is to prevent customers or sellers from modifying their articles and\n   * manipulating the circumstances due to the nature of e-commerce, where\n   * disputes easily arise. That is, to preserve evidence.\n   *\n   * @param saleId Belonged sale's {@link IShoppingSale.id }\n   * @param id Target question's {@link IShoppingSaleQuestion.id }\n   * @param body Update info of the question\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Post(\":id\")\n  public async postBySaleidAndId(\n    @TypedParam(\"saleId\")\n    saleId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IBbsArticle.ICreate,\n  ): Promise<IBbsArticle.ISnapshot> {\n    saleId;\n    id;\n    body;\n    return typia.random<IBbsArticle.ISnapshot>();\n  }\n}\n",
  "src/controllers/shoppings/customers/sales/questions/abridges/ShoppingsCustomersSalesQuestionsAbridgesController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedParam, TypedBody } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IPageIShoppingSaleQuestion } from \"../../../../../../api/structures/IPageIShoppingSaleQuestion\";\nimport { IShoppingSaleQuestion } from \"../../../../../../api/structures/IShoppingSaleQuestion\";\n\n@Controller(\"/shoppings/customers/sales/:saleId/questions/abridges\")\nexport class ShoppingsCustomersSalesQuestionsAbridgesController {\n  /**\n   * List up every abridged questions.\n   *\n   * List up every {@link IShoppingSaleQuestion.IAbridge abridged questions} of\n   * a {@link IShoppingSale sale}.\n   *\n   * As you can see, returned questions are abridged, not detailed. If you\n   * want to get the detailed information of a question, use {@link at}\n   * function for each article.\n   *\n   * Also, returned question has {@link IShoppingSaleQuestion.IAridge.answer}\n   * property which means the formal answer from the {@link IShoppingSeller}.\n   * Additionally, returned question has another special property\n   * {@link IShoppingSaleQuestion.IAridge.secret} with masking to other\n   * princple properties, and it means only related actors can {@link at read}\n   * the question.\n   *\n   * For reference, if you're a {@link IShoppingSeller seller}, you can only\n   * access to the your own {@link IShoppingSale sale}'s questions. Otherwise,\n   * you can access to every questions of the sales.\n   *\n   * By the way, if you want, you can limit the result by configuring\n   * {@link IShoppingSaleQuestion.IRequest.search search condition} in the\n   * request body. Also, it is possible to customize sequence order of records\n   * by configuring\n   * {@link IShoppingSaleQuestion.IRequest.sort sort condition}.\n   *\n   * @param saleId Belonged sale's {@link IShoppingSale.id }\n   * @param body Request info of pagination, searching and sorting\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patchBySaleid(\n    @TypedParam(\"saleId\")\n    saleId: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IShoppingSaleQuestion.IRequest,\n  ): Promise<IPageIShoppingSaleQuestion.IAbridge> {\n    saleId;\n    body;\n    return typia.random<IPageIShoppingSaleQuestion.IAbridge>();\n  }\n}\n",
  "src/controllers/shoppings/customers/sales/reviews/comments/ShoppingsCustomersSalesReviewsCommentsController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedParam, TypedBody } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IShoppingSaleInquiryComment } from \"../../../../../../api/structures/IShoppingSaleInquiryComment\";\nimport { IPageIShoppingSaleInquiryComment } from \"../../../../../../api/structures/IPageIShoppingSaleInquiryComment\";\n\n@Controller(\"/shoppings/customers/sales/:saleId/reviews/:inquiryId/comments\")\nexport class ShoppingsCustomersSalesReviewsCommentsController {\n  /**\n   * Create an inquiry comment.\n   *\n   * Create an {@link IShoppingSaleInquiryComment inquiry comment} of a\n   * {@link IShoppingSaleQuestion question} or\n   * {@link IShoppingSaleReview review}.\n   *\n   * For reference, if you're a {@link IShoppingSeller seller}, you can only\n   * create an inquiry comment to your own {@link IShoppingSale sale}'s\n   * inquiry. Otherwise, you can create an inquiry comment to every inquiries\n   * of the sales.\n   *\n   * @param saleId Belonged sale's {@link IShoppingSale.id }\n   * @param inquiryId Target inquiry's {@link IShoppingSaleInquiry.id }\n   * @param body Creation info of the inquiry comment\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Post()\n  public async postBySaleidAndInquiryid(\n    @TypedParam(\"saleId\")\n    saleId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"inquiryId\")\n    inquiryId: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IShoppingSaleInquiryComment.ICreate,\n  ): Promise<IShoppingSaleInquiryComment> {\n    saleId;\n    inquiryId;\n    body;\n    return typia.random<IShoppingSaleInquiryComment>();\n  }\n\n  /**\n   * List up every inquiry comments.\n   *\n   * List up every {@link IShoppingSaleInquiryComment inquiry comments} of a\n   * {@link IShoppingSaleQuestion question} or\n   * {@link IShoppingSaleReview review} with {@link IPage pagination}.\n   *\n   * If you want, you can limit the result by configuring\n   * {@link IShoppingSaleInquiryComment.IRequest.search search condition} in\n   * the request body. Also, it is possible to customize sequence order of\n   * records by configuring\n   * {@link IShoppingSaleInquiryComment.IRequest.sort sort condition}.\n   *\n   * By the way, if you're a {@link IShoppingSeller seller}, you can only\n   * access to the your own {@link IShoppingSale sale}'s inquiries. Otherwise,\n   * you can access to every inquiries of the sales.\n   *\n   * @param saleId Belonged sale's {@link IShoppingSale.id }\n   * @param inquiryId Belonged inquiry's {@link IShoppingSaleInquiry.id }\n   * @param body Request info of pagination, searching and sorting\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patchBySaleidAndInquiryid(\n    @TypedParam(\"saleId\")\n    saleId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"inquiryId\")\n    inquiryId: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IShoppingSaleInquiryComment.IRequest,\n  ): Promise<IPageIShoppingSaleInquiryComment> {\n    saleId;\n    inquiryId;\n    body;\n    return typia.random<IPageIShoppingSaleInquiryComment>();\n  }\n\n  /**\n   * Get an inquiry comment info.\n   *\n   * Get a detailed {@link IShoppingSaleInquiryComment inquiry comment}\n   * information of a {@link IShoppingSaleQuestion question} or\n   * {@link IShoppingSaleReview review}.\n   *\n   * For reference, if you're a {@link IShoppingSeller seller}, you can only\n   * access to the your own {@link IShoppingSale sale}'s inquiry comment.\n   * Otherwise, you can access to every inquiry comments of the sales.\n   *\n   * @param saleId Belonged sale's {@link IShoppingSale.id }\n   * @param inquiryId Belonged inquiry's {@link IShoppingSaleInquiry.id }\n   * @param id Target inquiry comment's {@link IShoppingSaleInquiryComment.id }\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get(\":id\")\n  public async getBySaleidAndInquiryidAndId(\n    @TypedParam(\"saleId\")\n    saleId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"inquiryId\")\n    inquiryId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<IShoppingSaleInquiryComment> {\n    saleId;\n    inquiryId;\n    id;\n    return typia.random<IShoppingSaleInquiryComment>();\n  }\n\n  /**\n   * Update an inquiry comment.\n   *\n   * Update an {@link IShoppingSaleInquiryComment inquiry comment} to a\n   * specific {@link IShoppingSaleQuestion question} or\n   * {@link IShoppingSaleReview review}.\n   *\n   * By the way, as is the general policy of this shopping mall regarding\n   * comments, modifying a comment does not actually change the existing\n   * content. Modified content is accumulated and recorded in the existing\n   * comment record as a new\n   * {@link IShoppingSaleInquiryComment.ISnapshot snapshot}. And this is made\n   * public to everyone, who can read this inquiry comment.\n   *\n   * This is to prevent customers or sellers from modifying their comments and\n   * manipulating the circumstances due to the nature of e-commerce, where\n   * disputes easily arise. That is, to preserve evidence.\n   *\n   * @param saleId Belonged sale's {@link IShoppingSale.id }\n   * @param inquiryId Belonged inquiry's {@link IShoppingSaleInquiry.id }\n   * @param id Target inquiry comment's {@link IShoppingSaleInquiryComment.id }\n   * @param body Update info of the inquiry comment\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Put(\":id\")\n  public async putBySaleidAndInquiryidAndId(\n    @TypedParam(\"saleId\")\n    saleId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"inquiryId\")\n    inquiryId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IShoppingSaleInquiryComment.ICreate,\n  ): Promise<IShoppingSaleInquiryComment.ISnapshot> {\n    saleId;\n    inquiryId;\n    id;\n    body;\n    return typia.random<IShoppingSaleInquiryComment.ISnapshot>();\n  }\n}\n",
  "src/controllers/shoppings/customers/sales/reviews/ShoppingsCustomersSalesReviewsController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedParam, TypedBody } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IShoppingSaleReview } from \"../../../../../api/structures/IShoppingSaleReview\";\nimport { IPageIShoppingSaleReview } from \"../../../../../api/structures/IPageIShoppingSaleReview\";\n\n@Controller(\"/shoppings/customers/sales/:saleId/reviews\")\nexport class ShoppingsCustomersSalesReviewsController {\n  /**\n   * Write a review article.\n   *\n   * When a {@link IShoppingCustomer customer} has purchased a specific\n   * {@link IShoppingSale sale} and get {@link IShoppingDelivery delivered} it,\n   * he/she can write a {@link IShoppingSaleReview review} article about the\n   * sale.\n   *\n   * If try to write a review article without purchasing or the delivery has\n   * not been completed, 428 unprocessable entity error would be thrown. Also,\n   * the customer can write multiple review articles per an order, but the\n   * next article can be written after 2 weeks from the previous article. If\n   * not, 428 unprocessable entity error would be thrown, either.\n   *\n   * @param saleId Belonged sale's {@link IShoppingSale.id }\n   * @param body Creation info of the review\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Post()\n  public async postBySaleid(\n    @TypedParam(\"saleId\")\n    saleId: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IShoppingSaleReview.ICreate,\n  ): Promise<IShoppingSaleReview> {\n    saleId;\n    body;\n    return typia.random<IShoppingSaleReview>();\n  }\n\n  /**\n   * List up every summarized reviews.\n   *\n   * List up every {@link IShoppingSaleReview.ISummary summarized reviews} of a\n   * {@link IShoppingSale sale}.\n   *\n   * As you can see, returned reviews are summarized, not detailed. If you\n   * want to get the detailed information of a review, use {@link adridges}\n   * function or {@link at} function for each article.\n   *\n   * Also, returned review has {@link IShoppingSaleReview.ISummary.answer}\n   * property which means the formal answer from the {@link IShoppingSeller}.\n   *\n   * For reference, if you're a {@link IShoppingSeller seller}, you can only\n   * access to the your own {@link IShoppingSale sale}'s reviews. Otherwise,\n   * you can access to every reviews of the sales.\n   *\n   * By the way, if you want, you can limit the result by configuring\n   * {@link IShoppingSaleReview.IRequest.search search condition} in the\n   * request body. Also, it is possible to customize sequence order of records\n   * by configuring {@link IShoppingSaleReview.IRequest.sort sort condition}.\n   *\n   * @param saleId Belonged sale's {@link IShoppingSale.id }\n   * @param body Request info of pagination, searching and sorting\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patchBySaleid(\n    @TypedParam(\"saleId\")\n    saleId: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IShoppingSaleReview.IRequest,\n  ): Promise<IPageIShoppingSaleReview.ISummary> {\n    saleId;\n    body;\n    return typia.random<IPageIShoppingSaleReview.ISummary>();\n  }\n\n  /**\n   * Get a review info.\n   *\n   * Get a detailed {@link IShoppingSaleReview review} information of a\n   * {@link IShoppingSale sale}.\n   *\n   * For reference, if you're a {@link IShoppingSeller seller}, you can only\n   * access to the your own {@link IShoppingSale sale}'s review. Otherwise you\n   * are a {@link IShoppingCustomer customer}, you can access to every reviews\n   * of the sales.\n   *\n   * @param saleId Belonged sale's {@link IShoppingSale.id }\n   * @param id Target review's {@link IShoppingSaleReview.id }\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get(\":id\")\n  public async getBySaleidAndId(\n    @TypedParam(\"saleId\")\n    saleId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<IShoppingSaleReview> {\n    saleId;\n    id;\n    return typia.random<IShoppingSaleReview>();\n  }\n\n  /**\n   * Update a review.\n   *\n   * Updadte a {@link IShoppingSaleReview review}'s content and score.\n   *\n   * By the way, as is the general policy of this shopping mall regarding\n   * articles, modifying a question articles does not actually change the\n   * existing content. Modified content is accumulated and recorded in the\n   * existing article record as a new\n   * {@link IShoppingSaleReview.ISnapshot snapshot}. And this is made public to\n   * everyone, including the {@link IShoppingCustomer customer} and the\n   * {@link IShoppingSeller seller}, and anyone who can view the article can\n   * also view the entire editing histories.\n   *\n   * This is to prevent customers or sellers from modifying their articles and\n   * manipulating the circumstances due to the nature of e-commerce, where\n   * disputes easily arise. That is, to preserve evidence.\n   *\n   * @param saleId Belonged sale's {@link IShoppingSale.id }\n   * @param id Target review's {@link IShoppingSaleReview.id }\n   * @param body Update info of the review\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Post(\":id\")\n  public async postBySaleidAndId(\n    @TypedParam(\"saleId\")\n    saleId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IShoppingSaleReview.IUpdate,\n  ): Promise<IShoppingSaleReview.ISnapshot> {\n    saleId;\n    id;\n    body;\n    return typia.random<IShoppingSaleReview.ISnapshot>();\n  }\n}\n",
  "src/controllers/shoppings/customers/sales/reviews/abridges/ShoppingsCustomersSalesReviewsAbridgesController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedParam, TypedBody } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IPageIShoppingSaleReview } from \"../../../../../../api/structures/IPageIShoppingSaleReview\";\nimport { IShoppingSaleReview } from \"../../../../../../api/structures/IShoppingSaleReview\";\n\n@Controller(\"/shoppings/customers/sales/:saleId/reviews/abridges\")\nexport class ShoppingsCustomersSalesReviewsAbridgesController {\n  /**\n   * List up every abridged reviews.\n   *\n   * List up every {@link IShoppingSaleReview.IAbridge abridged reviews} of a\n   * {@link IShoppingSale sale}.\n   *\n   * As you can see, returned reviews are abridged, not detailed. If you want\n   * to get the detailed information of a review, use {@link at} function for\n   * each article.\n   *\n   * Also, returned review has {@link IShoppingSaleReview.IAridge.answer}\n   * property which means the formal answer from the {@link IShoppingSeller}.\n   *\n   * For reference, if you're a {@link IShoppingSeller seller}, you can only\n   * access to the your own {@link IShoppingSale sale}'s reviews. Otherwise,\n   * you can access to every reviews of the sales.\n   *\n   * By the way, if you want, you can limit the result by configuring\n   * {@link IShoppingSaleReview.IRequest.search search condition} in the\n   * request body. Also, it is possible to customize sequence order of records\n   * by configuring {@link IShoppingSaleReview.IRequest.sort sort condition}.\n   *\n   * @param saleId Belonged sale's {@link IShoppingSale.id }\n   * @param body Request info of pagination, searching and sorting\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patchBySaleid(\n    @TypedParam(\"saleId\")\n    saleId: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IShoppingSaleReview.IRequest,\n  ): Promise<IPageIShoppingSaleReview.IAbridge> {\n    saleId;\n    body;\n    return typia.random<IPageIShoppingSaleReview.IAbridge>();\n  }\n}\n",
  "src/controllers/shoppings/customers/sales/snapshots/ShoppingsCustomersSalesSnapshotsController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedParam, TypedBody } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IPageIShoppingSaleSnapshot } from \"../../../../../api/structures/IPageIShoppingSaleSnapshot\";\nimport { IPage } from \"../../../../../api/structures/IPage\";\nimport { IShoppingSaleSnapshot } from \"../../../../../api/structures/IShoppingSaleSnapshot\";\n\n@Controller(\"/shoppings/customers/sales/:saleId/snapshots\")\nexport class ShoppingsCustomersSalesSnapshotsController {\n  /**\n   * List up every snapshots.\n   *\n   * Whenever {@link IShoppingSeller seller} updates a\n   * {@link IShoppingSale sale}, the sale record is not updated but a new\n   * {@link IShoppingSaleSnapshot snapshot} record is created to keep the\n   * integrity of the sale history. This API function is for listing up such\n   * snapshot records.\n   *\n   * Also, as you can see from the return type, returned snapshots are\n   * summarized, not detailed. If you want to get the detailed information of\n   * a snapshot, use {@link at} or {@link flipo} function for each snapshot.\n   *\n   * For reference, if you're a {@link IShoppingSeller seller}, you can only\n   * access to the your own {@link IShoppingSale sale}'s snapshots. Otherwise,\n   * you can access to every snapshots of the sales even though the sale has\n   * been closed or suspended.\n   *\n   * @param saleId Target sale's {@link IShoppingSale.id }\n   * @param body Requestion info of pagination\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patchBySaleid(\n    @TypedParam(\"saleId\")\n    saleId: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IPage.IRequest,\n  ): Promise<IPageIShoppingSaleSnapshot.ISummary> {\n    saleId;\n    body;\n    return typia.random<IPageIShoppingSaleSnapshot.ISummary>();\n  }\n\n  /**\n   * Get a snapshot info.\n   *\n   * Get a {@link IShoppingSaleSnapshot snapshot} with detailed information.\n   *\n   * As you can see from the return type, returned snapshot does not contain\n   * the {@link IShoppingSale sale} info. If you want to get the sale info, use\n   * the {@link flip} function instead.\n   *\n   * For reference, if you're a {@link IShoppingSeller seller}, you can only\n   * access to the your own {@link IShoppingSale sale}'s snapshots. Otherwise,\n   * you can access to every snapshots of the sales even though the sale has\n   * been closed or suspended.\n   *\n   * @param saleId Belonged sale's {@link IShoppingSale.id }\n   * @param id Target snapshot's {@link IShoppingSaleSnapshot.id }\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get(\":id\")\n  public async getBySaleidAndId(\n    @TypedParam(\"saleId\")\n    saleId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<IShoppingSaleSnapshot> {\n    saleId;\n    id;\n    return typia.random<IShoppingSaleSnapshot>();\n  }\n}\n",
  "src/controllers/shoppings/customers/sales/snapshots/flip/ShoppingsCustomersSalesSnapshotsFlipController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedParam } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IShoppingSale } from \"../../../../../../api/structures/IShoppingSale\";\n\n@Controller(\"/shoppings/customers/sales/:saleId/snapshots/:id/flip\")\nexport class ShoppingsCustomersSalesSnapshotsFlipController {\n  /**\n   * Get a flipped snapshot info.\n   *\n   * Get a {@link IShoppingSale sale} info of a flipped snapshot.\n   *\n   * As you can see from the return type, this function returns the\n   * {@link IShoppingSale sale} info. By the way, the sale info is not the\n   * latest one, but a flipped info in the snapshot side.\n   *\n   * Also, if you're a {@link IShoppingSeller seller}, you can only access to\n   * the your own {@link IShoppingSale sale}'s snapshots. Otherwise, you can\n   * access to every snapshots of the sales even though the sale has been\n   * closed or suspended.\n   *\n   * @param saleId Belonged sale's {@link IShoppingSale.id }\n   * @param id Target snapshot's {@link IShoppingSaleSnapshot.id }\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get()\n  public async getBySaleidAndId(\n    @TypedParam(\"saleId\")\n    saleId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<IShoppingSale> {\n    saleId;\n    id;\n    return typia.random<IShoppingSale>();\n  }\n}\n",
  "src/controllers/shoppings/customers/systematic/channels/categories/ShoppingsCustomersSystematicChannelsCategoriesController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedParam } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IShoppingChannelCategory } from \"../../../../../../api/structures/IShoppingChannelCategory\";\n\n@Controller(\"/shoppings/customers/systematic/channels/:channelCode/categories\")\nexport class ShoppingsCustomersSystematicChannelsCategoriesController {\n  /**\n   * List up every categories with children records.\n   *\n   * List up every {@link IShoppingChannelCategory.IHierarchical categories} of\n   * a {@link IShoppingChannel channel} with pagination. Returned categories\n   * contain children categories, too.\n   *\n   * If you want, you can limit the result by configuring\n   * {@link IShoppingChannelCategory.IRequest.search search condition} in the\n   * request body. Also, it is possible to customize sequence order of records\n   * by configuring\n   * {@link IShoppingChannelCategory.IRequest.sort sort condition}.\n   *\n   * @param channelCode Belonged channel's {@link IShoppingChannel.code }\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patchByChannelcode(\n    @TypedParam(\"channelCode\")\n    channelCode: string,\n  ): Promise<void> {\n    channelCode;\n    return typia.random<void>();\n  }\n\n  /**\n   * Get a category info.\n   *\n   * Get a detailed {@link IShoppingChannelCategory category} information.\n   *\n   * Returned category contains hierarchical children categories, and also\n   * contains the recursive parent categories, too.\n   *\n   * @param channelCode Belonged channel's {@link IShoppingChannel.code }\n   * @param id Target category's {@link IShoppingChannelCategory.id }\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get(\":id\")\n  public async getByChannelcodeAndId(\n    @TypedParam(\"channelCode\")\n    channelCode: string,\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<IShoppingChannelCategory> {\n    channelCode;\n    id;\n    return typia.random<IShoppingChannelCategory>();\n  }\n}\n",
  "src/controllers/shoppings/customers/systematic/channels/categories/invert/ShoppingsCustomersSystematicChannelsCategoriesInvertController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedParam } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IShoppingChannelCategory } from \"../../../../../../../api/structures/IShoppingChannelCategory\";\n\n@Controller(\n  \"/shoppings/customers/systematic/channels/:channelCode/categories/:id/invert\",\n)\nexport class ShoppingsCustomersSystematicChannelsCategoriesInvertController {\n  /**\n   * Get a category info of inverted.\n   *\n   * Get a inverted {@link IShoppingChannelCategory.IInvert category}\n   * information.\n   *\n   * Returned category contains the recursive parent categories, but not\n   * contains the hierarchical children categories.\n   *\n   * @param channelCode Belonged channel's {@link IShoppingChannel.code }\n   * @param id Target category's {@link IShoppingChannelCategory.id }\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get()\n  public async getByChannelcodeAndId(\n    @TypedParam(\"channelCode\")\n    channelCode: string,\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<IShoppingChannelCategory.IInvert> {\n    channelCode;\n    id;\n    return typia.random<IShoppingChannelCategory.IInvert>();\n  }\n}\n",
  "src/controllers/shoppings/customers/systematic/channels/ShoppingsCustomersSystematicChannelsController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody, TypedParam } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IPageIShoppingChannel } from \"../../../../../api/structures/IPageIShoppingChannel\";\nimport { IShoppingChannel } from \"../../../../../api/structures/IShoppingChannel\";\n\n@Controller(\"/shoppings/customers/systematic/channels\")\nexport class ShoppingsCustomersSystematicChannelsController {\n  /**\n   * List up every channels.\n   *\n   * List up every {@link IShoppingChannel channels} with pagination.\n   *\n   * If you want, you can limit the result by configuring\n   * {@link IShoppingChannel.IRequest.search search condition} in the request\n   * body. Also, it is possible to customize sequence order of records by\n   * configuring {@link IShoppingChannel.IRequest.sort sort condition}.\n   *\n   * @param body Request info of pagination, searching and sorting\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patch(\n    @TypedBody()\n    body: IShoppingChannel.IRequest,\n  ): Promise<IPageIShoppingChannel> {\n    body;\n    return typia.random<IPageIShoppingChannel>();\n  }\n\n  /**\n   * Get a channel info.\n   *\n   * Get a detailed {@link IShoppingChannel.IHierarchical channel} information.\n   *\n   * Returned channel instance also contains the nested\n   * {@link IShoppingChannelCategory.IHierarchical hierarchical category}\n   * information.\n   *\n   * @param id Target channel's {@link IShoppingChannel.id }\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get(\":id\")\n  public async getById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<IShoppingChannel.IHierarchical> {\n    id;\n    return typia.random<IShoppingChannel.IHierarchical>();\n  }\n}\n",
  "src/controllers/shoppings/customers/systematic/channels/hierarchical/ShoppingsCustomersSystematicChannelsHierarchicalController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody } from \"@nestia/core\";\nimport typia from \"typia\";\n\nimport { IPageIShoppingChannel } from \"../../../../../../api/structures/IPageIShoppingChannel\";\nimport { IShoppingChannel } from \"../../../../../../api/structures/IShoppingChannel\";\n\n@Controller(\"/shoppings/customers/systematic/channels/hierarchical\")\nexport class ShoppingsCustomersSystematicChannelsHierarchicalController {\n  /**\n   * List up every channels with nested categories.\n   *\n   * List up every {@link IShoppingChannel.IHierarchical channels} with\n   * {@link IPage pagination}. Returned channels contain nested hierarchical\n   * {@link IShoppingChannelCategory.IHierarchical categories}.\n   *\n   * If you want, you can limit the result by configuring\n   * {@link IShoppingChannel.IRequest.search search condition} in the request\n   * body. Also, it is possible to customize sequence order of records by\n   * configuring {@link IShoppingChannel.IRequest.sort sort condition}.\n   *\n   * @param body Request info of pagination, searching and sorting\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patch(\n    @TypedBody()\n    body: IShoppingChannel.IRequest,\n  ): Promise<IPageIShoppingChannel.IHierarchical> {\n    body;\n    return typia.random<IPageIShoppingChannel.IHierarchical>();\n  }\n}\n",
  "src/controllers/shoppings/customers/systematic/channels/get/ShoppingsCustomersSystematicChannelsGetController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedParam } from \"@nestia/core\";\nimport typia from \"typia\";\n\nimport { IShoppingChannel } from \"../../../../../../api/structures/IShoppingChannel\";\n\n@Controller(\"/shoppings/customers/systematic/channels/:code/get\")\nexport class ShoppingsCustomersSystematicChannelsGetController {\n  /**\n   * Get a channel info by its code.\n   *\n   * Get a detailed {@link IShoppingChannel.IHierarchical channel} information\n   * by its code.\n   *\n   * Returned channel instance also contains the nested\n   * {@link IShoppingChannelCategory.IHierarchical hierarchical category}\n   * information.\n   *\n   * @param code Target channel's {@link IShoppingChannel.code }\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get()\n  public async getByCode(\n    @TypedParam(\"code\")\n    code: string,\n  ): Promise<IShoppingChannel.IHierarchical> {\n    code;\n    return typia.random<IShoppingChannel.IHierarchical>();\n  }\n}\n",
  "src/controllers/shoppings/customers/systematic/sections/ShoppingsCustomersSystematicSectionsController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody, TypedParam } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IPageIShoppingSection } from \"../../../../../api/structures/IPageIShoppingSection\";\nimport { IShoppingSection } from \"../../../../../api/structures/IShoppingSection\";\n\n@Controller(\"/shoppings/customers/systematic/sections\")\nexport class ShoppingsCustomersSystematicSectionsController {\n  /**\n   * List up every sections.\n   *\n   * List up every {@link IShoppingSection sections} with pagination.\n   *\n   * If you want, you can limit the result by configuring\n   * {@link IShoppingSection.IRequest.search search condition} in the request\n   * body. Also, it is possible to customize sequence order of records by\n   * configuring {@link IShoppingSection.IRequest.sort sort condition}.\n   *\n   * @param body Request info of pagination, searching and sorting\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patch(\n    @TypedBody()\n    body: IShoppingSection.IRequest,\n  ): Promise<IPageIShoppingSection> {\n    body;\n    return typia.random<IPageIShoppingSection>();\n  }\n\n  /**\n   * Get a section info.\n   *\n   * Get a detailed {@link IShoppingSection section} information.\n   *\n   * @param id Target section's {@link IShoppingSection.id }\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get(\":id\")\n  public async getById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<IShoppingSection> {\n    id;\n    return typia.random<IShoppingSection>();\n  }\n}\n",
  "src/controllers/shoppings/customers/systematic/sections/get/ShoppingsCustomersSystematicSectionsGetController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedParam } from \"@nestia/core\";\nimport typia from \"typia\";\n\nimport { IShoppingSection } from \"../../../../../../api/structures/IShoppingSection\";\n\n@Controller(\"/shoppings/customers/systematic/sections/:code/get\")\nexport class ShoppingsCustomersSystematicSectionsGetController {\n  /**\n   * Get a section info by its code.\n   *\n   * Get a detailed {@link IShoppingSection section} information by its code.\n   *\n   * @param code Target section's {@link IShoppingSection.code }\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get()\n  public async getByCode(\n    @TypedParam(\"code\")\n    code: string,\n  ): Promise<IShoppingSection> {\n    code;\n    return typia.random<IShoppingSection>();\n  }\n}\n",
  "src/controllers/shoppings/sellers/authenticate/ShoppingsSellersAuthenticateController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody } from \"@nestia/core\";\nimport typia from \"typia\";\n\nimport { IShoppingSeller } from \"../../../../api/structures/IShoppingSeller\";\n\n@Controller(\"/shoppings/sellers/authenticate\")\nexport class ShoppingsSellersAuthenticateController {\n  /**\n   * Get seller information.\n   *\n   * Get {@link IShoppingSeller.IInvert seller} information of current\n   * {@link IShoppingCustomer customer}.\n   *\n   * If current {@link IShoppingMember member} is not an seller, it throws 403\n   * forbidden exception.\n   *\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get()\n  public async get(): Promise<IShoppingSeller.IInvert> {\n    return typia.random<IShoppingSeller.IInvert>();\n  }\n\n  /**\n   * Join as an seller.\n   *\n   * Join as an seller with {@link IShoppingSeller.IJoin joining info}.\n   *\n   * This method is allowed only when the {@link IShoppingCustomer customer}\n   * already has joined the {@link IShoppingMember membership}. IF not, he\n   * (she) must accomplish it before. If not, 403 forbidden exception would be\n   * thrown.\n   *\n   * @param body Joining request info\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Post()\n  public async post(\n    @TypedBody()\n    body: IShoppingSeller.IJoin,\n  ): Promise<IShoppingSeller.IInvert> {\n    body;\n    return typia.random<IShoppingSeller.IInvert>();\n  }\n}\n",
  "src/controllers/shoppings/sellers/authenticate/login/ShoppingsSellersAuthenticateLoginController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody } from \"@nestia/core\";\nimport typia from \"typia\";\n\nimport { IShoppingSeller } from \"../../../../../api/structures/IShoppingSeller\";\nimport { IShoppingMember } from \"../../../../../api/structures/IShoppingMember\";\n\n@Controller(\"/shoppings/sellers/authenticate/login\")\nexport class ShoppingsSellersAuthenticateLoginController {\n  /**\n   * Login as an seller.\n   *\n   * Login as an seller with {@link IShoppingSeller.ILogin login info}.\n   *\n   * This method has exactly same effect with\n   * {@link ShoppingApi.functional.customers.authenticate.login} function, but\n   * returned type is a llttle different. The similar function returns\n   * {@link IShoppingCustomer} type that starting from the customer\n   * information, so that you have to access to the seller info through\n   * `customer.member.seller`. In contrast with that, this method returns\n   * {@link IShoppingSeller.IInvert} type that starting from the seller info,\n   * so that can access to the customer info through `seller.customer`.\n   *\n   * Of course, to use this function, you had to {@link join} as an seller\n   * before. If not, 403 forbidden exception would be thrown,\n   *\n   * @param body Login request info\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Put()\n  public async put(\n    @TypedBody()\n    body: IShoppingMember.ILogin,\n  ): Promise<IShoppingSeller.IInvert> {\n    body;\n    return typia.random<IShoppingSeller.IInvert>();\n  }\n}\n",
  "src/controllers/shoppings/sellers/deliveries/ShoppingsSellersDeliveriesController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody, TypedParam } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IShoppingDelivery } from \"../../../../api/structures/IShoppingDelivery\";\nimport { IPageIShoppingDelivery } from \"../../../../api/structures/IPageIShoppingDelivery\";\n\n@Controller(\"/shoppings/sellers/deliveries\")\nexport class ShoppingsSellersDeliveriesController {\n  /**\n   * Create a delivery.\n   *\n   * Create a {@link IShoppingDelivery delivery} record targeting\n   * {@link IShoppingOrder orders}, their {@link IShoppingOrderGood goods} and\n   * {@link IShoppingSaleUnitStock stocks} ({@link IShoppingDeliveryPiece}) with\n   * {@link IShoppingDeliveryJourney journeys} and\n   * {@link IShoppingDeliveryShipper shippers} info.\n   *\n   * Note that, composition of the {@link IShoppingDeliveryPiece} must not over\n   * the required. To identify which pieces are required, recommend to call\n   * the {@link incompletes} function with target orders'\n   * {@link IShoppingOrderPublish.id}s before calling this one.\n   *\n   * @param body Creation info of delivery\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Post()\n  public async post(\n    @TypedBody()\n    body: IShoppingDelivery.ICreate,\n  ): Promise<IShoppingDelivery> {\n    body;\n    return typia.random<IShoppingDelivery>();\n  }\n\n  /**\n   * Get list of deliveries.\n   *\n   * Get list of {@link IShoppingDelivery.IInvert deliveries} of current\n   * {@link IShoppingSeller seller} with {@link IPage pagination}.\n   *\n   * For reference, returned deliveries are containing the target\n   * {@link IShoppingOrder.IInvertFromDelivery order} information. Of course,\n   * only related {@link IShoppingOrderGood goods} are contained in the\n   * orders.\n   *\n   * Additionally, you can limit the result by configuring\n   * {@link IShoppingDelivery.IRequest.search search condition} in the request\n   * body. Also, it is possible to customize sequence order of records by\n   * configuring {@link IShoppingDelivery.IRequest.sort sort condition}.\n   *\n   * @param body Request info of pagination, searching and sorting\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patch(\n    @TypedBody()\n    body: IShoppingDelivery.IRequest,\n  ): Promise<IPageIShoppingDelivery.IInvert> {\n    body;\n    return typia.random<IPageIShoppingDelivery.IInvert>();\n  }\n\n  /**\n   * Get a delivery.\n   *\n   * Get a {@link IShoppingDelivery.IInvert delivery} information with its ID.\n   *\n   * For reference, returned delivery is containing the target\n   * {@link IShoppingOrder.IInvertFromDelivery order} information. Of course,\n   * only related {@link IShoppingOrderGood goods} are contained in the\n   * orders.\n   *\n   * @param id Target delivery's {@link IShoppingDelivery.id }\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get(\":id\")\n  public async getById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<IShoppingDelivery.IInvert> {\n    id;\n    return typia.random<IShoppingDelivery.IInvert>();\n  }\n}\n",
  "src/controllers/shoppings/sellers/deliveries/incompletes/ShoppingsSellersDeliveriesIncompletesController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody } from \"@nestia/core\";\nimport typia from \"typia\";\n\nimport { IShoppingDeliveryPiece } from \"../../../../../api/structures/IShoppingDeliveryPiece\";\n\n@Controller(\"/shoppings/sellers/deliveries/incompletes\")\nexport class ShoppingsSellersDeliveriesIncompletesController {\n  /**\n   * Get list of incomplete pieces.\n   *\n   * Get list of {@link IShoppingDeliveryPiece incomplete pieces} of target\n   * orders' {@link IShoppingOrderPublish.id}s.\n   *\n   * If you specify target orders' publish IDs, then this function returns\n   * incompleted pieces of the orders with computation as an Array of\n   * {@link IShoppingDeliveryPiece.ICreate} type.\n   *\n   * You can utillize the result to make a huge\n   * {@link IShoppingDelivery delivery} for integrated delivering, and also\n   * possible to make multiple deliveries for split delivering.\n   *\n   * @param body List of target orders'\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patch(\n    @TypedBody()\n    body: IShoppingDeliveryPiece.IRequest,\n  ): Promise<void> {\n    body;\n    return typia.random<void>();\n  }\n}\n",
  "src/controllers/shoppings/sellers/deliveries/journeys/ShoppingsSellersDeliveriesJourneysController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedParam, TypedBody } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IShoppingDeliveryJourney } from \"../../../../../api/structures/IShoppingDeliveryJourney\";\n\n@Controller(\"/shoppings/sellers/deliveries/:deliveryId/journeys\")\nexport class ShoppingsSellersDeliveriesJourneysController {\n  /**\n   * Create a new journey.\n   *\n   * Create a new {@link IShoppingDeliveryJourney journey} of the\n   * {@link IShoppingDelivery delivery}.\n   *\n   * This action may change the related {@link IShoppingOrderGood.state}. Also,\n   * if the target journey's type is \"delivering\", whether the property\n   * {@link IShoppingDeliveryJourney.completed_at} is null or not affects to\n   * the related goods' states. If the property is not null, the state becomes\n   * \"arrived\". Otherwise, the state becomes \"delivering\".\n   *\n   * @param deliveryId Belonged delivery's {@link IShoppingDelivery.id }\n   * @param body Creation info of the journey\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Post()\n  public async postByDeliveryid(\n    @TypedParam(\"deliveryId\")\n    deliveryId: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IShoppingDeliveryJourney.ICreate,\n  ): Promise<IShoppingDeliveryJourney> {\n    deliveryId;\n    body;\n    return typia.random<IShoppingDeliveryJourney>();\n  }\n\n  /**\n   * Erase a journey.\n   *\n   * Erase a {@link IShoppingDeliveryJourney journey} of the\n   * {@link IShoppingDelivery delivery}.\n   *\n   * If erasing journey is the last one of the belonged delivery, this action\n   * may change the related {@link IShoppingOrderGood.state}. By erasing the\n   * last journey, the state rolls back to the previous.\n   *\n   * @param deliveryId Belonged delivery's {@link IShoppingDelivery.id }\n   * @param id Target journey's {@link IShoppingDeliveryJourney.id }\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Delete(\":id\")\n  public async eraseByDeliveryidAndId(\n    @TypedParam(\"deliveryId\")\n    deliveryId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<void> {\n    deliveryId;\n    id;\n    return typia.random<void>();\n  }\n}\n",
  "src/controllers/shoppings/sellers/deliveries/journeys/complete/ShoppingsSellersDeliveriesJourneysCompleteController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedParam, TypedBody } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IShoppingDeliveryJourney } from \"../../../../../../api/structures/IShoppingDeliveryJourney\";\n\n@Controller(\"/shoppings/sellers/deliveries/:deliveryId/journeys/:id/complete\")\nexport class ShoppingsSellersDeliveriesJourneysCompleteController {\n  /**\n   * Complete a journey.\n   *\n   * Complete a {@link IShoppingDeliveryJourney journey} of the\n   * {@link IShoppingDelivery delivery}. In other words, fills the\n   * {@link IShoppingDeliveryJourney.completed_at} property with current time.\n   *\n   * If the target journey's type is \"delivering\", this action may change the\n   * related {@link IShoppingOrderGood.state goods' states} to be \"arrived\".\n   *\n   * @param deliveryId Belonged delivery's {@link IShoppingDelivery.id }\n   * @param id Target journey's {@link IShoppingDeliveryJourney.id }\n   * @param body Completion time of the journey\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Put()\n  public async putByDeliveryidAndId(\n    @TypedParam(\"deliveryId\")\n    deliveryId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IShoppingDeliveryJourney.IComplete,\n  ): Promise<void> {\n    deliveryId;\n    id;\n    body;\n    return typia.random<void>();\n  }\n}\n",
  "src/controllers/shoppings/sellers/deliveries/shippers/ShoppingsSellersDeliveriesShippersController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedParam, TypedBody } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IShoppingDeliveryShipper } from \"../../../../../api/structures/IShoppingDeliveryShipper\";\n\n@Controller(\"/shoppings/sellers/deliveries/:deliveryId/shippers\")\nexport class ShoppingsSellersDeliveriesShippersController {\n  /**\n   * Create a new shipper.\n   *\n   * Create a new {@link IShoppingDeliveryShipper shipper} of the\n   * {@link IShoppingDelivery delivery}.\n   *\n   * This action does not affect to the related {@link IShoppingOrder orders}\n   * or {@link IShoppingOrderGood goods} like {@link IShoppingDeliveryJourney}\n   * or {@link IShoppingDeliveryPiece} case, but just informs to the\n   * {@link IShoppingCustomer customer}.\n   *\n   * @param deliveryId Belonged delivery's {@link IShoppingDelivery.id }\n   * @param body Creation info of the shipper\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Post()\n  public async postByDeliveryid(\n    @TypedParam(\"deliveryId\")\n    deliveryId: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IShoppingDeliveryShipper.ICreate,\n  ): Promise<IShoppingDeliveryShipper> {\n    deliveryId;\n    body;\n    return typia.random<IShoppingDeliveryShipper>();\n  }\n}\n",
  "src/controllers/shoppings/sellers/coupons/ShoppingsSellersCouponsController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody, TypedParam } from \"@nestia/core\";\nimport typia from \"typia\";\n\nimport { IShoppingCoupon } from \"../../../../api/structures/IShoppingCoupon\";\nimport { IPageIShoppingCoupon } from \"../../../../api/structures/IPageIShoppingCoupon\";\n\n@Controller(\"/shoppings/sellers/coupons\")\nexport class ShoppingsSellersCouponsController {\n  /**\n   * Create a new coupon.\n   *\n   * Create a new {@link IShoppingCoupon coupon} with given information.\n   *\n   * By the way, if you are a {@link IShoppingSeller seller}, you have to add\n   * include direction's {@link IShoppingCouponSellerCriteria} or\n   * {@link IShoppingCouponSaleCriteria} condition. This is because only\n   * {@link IShoppingAdministrator administrators} can create a coupon which\n   * can be used throughout the market. Seller must limit the usage range by\n   * his/her {@link IShoppingSale sale(s)}.\n   *\n   * Of course, when administrator is planning to make a general coupon that\n   * can be used throughout the market, the administrator must get agree from\n   * the sellers who are going to be affected.\n   *\n   * @param body Creation info of the coupon\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Post()\n  public async post(\n    @TypedBody()\n    body: IShoppingCoupon.ICreate,\n  ): Promise<IShoppingCoupon> {\n    body;\n    return typia.random<IShoppingCoupon>();\n  }\n\n  /**\n   * List up every coupons.\n   *\n   * List up every {@link IShoppingCoupon coupons} with pagination.\n   *\n   * If you want, you can limit the result by configuring\n   * {@link IShoppingCoupon.IRequest.search search condition} in the request\n   * body. Also, it is possible to customize sequence order of records by\n   * configuring {@link IShoppingCoupon.IRequest.sort sort condition}.\n   *\n   * For reference, if you are a {@link IShoppingCustomer customer}, then only\n   * {@link IShoppingCouponTicket ticketable} coupons would be listed up.\n   * Otherwise, non-ticketable coupons would also be listed up.\n   *\n   * @param body Request info of pagination, searching and sorting\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patch(\n    @TypedBody()\n    body: IShoppingCoupon.IRequest,\n  ): Promise<IPageIShoppingCoupon> {\n    body;\n    return typia.random<IPageIShoppingCoupon>();\n  }\n\n  /**\n   * Get a coupon info.\n   *\n   * Get a {@link IShoppingCoupon coupon} information.\n   *\n   * If you are a {@link IShoppingCustomer customer}, then only\n   * {@link IShoppingCouponTicket ticketable} coupons are accessible. Non\n   * ticketable coupons cause 410 gone error. Otherwise you are a\n   * {@link IShoppingSeller seller} or\n   * {@link IShoppingAdministrator administrator}, non-ticketable coupons are\n   * also accessible.\n   *\n   * @param id Target coupon's {@link IShoppingCoupon.id }\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get(\":id\")\n  public async getById(\n    @TypedParam(\"id\")\n    id: string,\n  ): Promise<IShoppingCoupon> {\n    id;\n    return typia.random<IShoppingCoupon>();\n  }\n\n  /**\n   * Erase a coupon.\n   *\n   * Erase a {@link IShoppingCoupon coupon} with given ID.\n   *\n   * For reference, if there're some {@link IShoppingCouponTicket tickets}\n   * which are already issued from the target coupon, they would not be\n   * affected. Those tickets are still valid until their expration time.\n   *\n   * @param id Target coupon's {@link IShoppingCoupon.id }\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Delete(\":id\")\n  public async eraseById(\n    @TypedParam(\"id\")\n    id: string,\n  ): Promise<void> {\n    id;\n    return typia.random<void>();\n  }\n}\n",
  "src/controllers/shoppings/sellers/orders/ShoppingsSellersOrdersController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody, TypedParam } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IPageIShoppingOrder } from \"../../../../api/structures/IPageIShoppingOrder\";\nimport { IShoppingOrder } from \"../../../../api/structures/IShoppingOrder\";\n\n@Controller(\"/shoppings/sellers/orders\")\nexport class ShoppingsSellersOrdersController {\n  /**\n   * List up every orders.\n   *\n   * List up every {@link IShoppingOrder orders} with pagination.\n   *\n   * If you want, you can limit the result by configuring\n   * {@link IShoppingOrder.IRequest.search search condition} in the request\n   * body. Also, it is possible to customize sequence order of records by\n   * configuring {@link IShoppingOrder.IRequest.sort sort condition}.\n   *\n   * For reference, if you are a {@link IShoppingCustomer customer}, then you\n   * can list up your own orders, and it is not a matter whether the order has\n   * been {@link IShoppingOrderPublish.paid_at paid} or not.\n   *\n   * Otherwise you are a {@link IShoppingSeller seller} or\n   * {@link IShoppingAdministrator administrator}, then you can list up only\n   * paid orders. Also, in the seller case, only related\n   * {@link IShoppingOrder.goods goods} would be listed up in the order.\n   *\n   * @param body Request info of pagination, searching and sorting\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patch(\n    @TypedBody()\n    body: IShoppingOrder.IRequest,\n  ): Promise<IPageIShoppingOrder> {\n    body;\n    return typia.random<IPageIShoppingOrder>();\n  }\n\n  /**\n   * Get an order info.\n   *\n   * Get a detailed {@link IShoppingOrder order} information.\n   *\n   * If you are not a {@link IShoppingCustomer customer}, then you can't access\n   * to the order which has not been {@link IShoppingOrderPublish.paid_at paid}\n   * yet. In that case, 404 not found error would be thrown.\n   *\n   * @param id Target order's {@link IShoppingOrder.id }\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get(\":id\")\n  public async getById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<IShoppingOrder> {\n    id;\n    return typia.random<IShoppingOrder>();\n  }\n}\n",
  "src/controllers/shoppings/sellers/sales/ShoppingsSellersSalesController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody, TypedParam } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IShoppingSale } from \"../../../../api/structures/IShoppingSale\";\nimport { IPageIShoppingSale } from \"../../../../api/structures/IPageIShoppingSale\";\nimport { IShoppingSaleSnapshot } from \"../../../../api/structures/IShoppingSaleSnapshot\";\n\n@Controller(\"/shoppings/sellers/sales\")\nexport class ShoppingsSellersSalesController {\n  /**\n   * Create a sale.\n   *\n   * {@link IShoppingSeller Seller} creates a new {@link IShoppingSale} for\n   * operation.\n   *\n   * For reference, sale has complicate hierarchical structure that composing\n   * with {@link IShoppingSaleUnit units},\n   * {@link IShoppingSaleUnitOption options} and\n   * {@link IShoppingSaleUnitStock stocks}. Therefore, I recommend you to read\n   * the {@link IShoppingSale} and related DTOs' documents before creating a\n   * new sale.\n   *\n   * ERD (Entity Relationship Diagram) and its description document also would\n   * be helpful, too.\n   *\n   * @param body Creation info of the sale\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Post()\n  public async post(\n    @TypedBody()\n    body: IShoppingSale.ICreate,\n  ): Promise<IShoppingSale> {\n    body;\n    return typia.random<IShoppingSale>();\n  }\n\n  /**\n   * List up every summarized sales.\n   *\n   * List up every {@link IShoppingSale.ISummary summarized sales}.\n   *\n   * As you can see, returned sales are summarized, not detailed. It does not\n   * contain the SKU (Stock Keeping Unit) information represented by the\n   * {@link IShoppingSaleUnitOption} and {@link IShoppingSaleUnitStock} types.\n   * If you want to get such detailed information of a sale, use `GET\n   * /shoppings/customers/sales/{id}` operation for each sale.\n   *\n   * > If you're an A.I. chatbot, and the user wants to buy or compose\n   * > {@link IShoppingCartCommodity shopping cart} from a sale, please call the\n   * > `GET /shoppings/customers/sales/{id}` operation at least once to the\n   * > target sale to get detailed SKU information about the sale. It needs to\n   * > be run at least once for the next steps.\n   *\n   * @param body Request info of pagination, searching and sorting\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patch(\n    @TypedBody()\n    body: IShoppingSale.IRequest,\n  ): Promise<IPageIShoppingSale.ISummary> {\n    body;\n    return typia.random<IPageIShoppingSale.ISummary>();\n  }\n\n  /**\n   * Get a sale with detailed information.\n   *\n   * Get a {@link IShoppingSale sale} with detailed information including the\n   * SKU (Stock Keeping Unit) information represented by the\n   * {@link IShoppingSaleUnitOption} and {@link IShoppingSaleUnitStock} types.\n   *\n   * > If you're an A.I. chatbot, and the user wants to buy or compose a\n   * > {@link IShoppingCartCommodity shopping cart} from a sale, please call this\n   * > operation at least once to the target sale to get detailed SKU\n   * > information about the sale.\n   *\n   * > It needs to be run at least once for the next steps. In other words, if\n   * > you A.I. agent has called this operation to a specific sale, you don't\n   * > need to call this operation again for the same sale.\n   *\n   * > Additionally, please do not summarize the SKU information. Just show the\n   * > every options and stocks in the sale with detailed information.\n   *\n   * @param id Target sale's {@link IShoppingSale.id }\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get(\":id\")\n  public async getById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<IShoppingSale> {\n    id;\n    return typia.random<IShoppingSale>();\n  }\n\n  /**\n   * Update a sale.\n   *\n   * Update a {@link IShoppingSale sale} with new information.\n   *\n   * By the way, the sale actually does not being modified, but just make a\n   * new {@link IShoppingSaleSnapshot snapshot} record of the sale. Its 1st\n   * purpose is to keeping the integrity of the sale, due to modification of\n   * the sale must not affect to the {@link IShoppingOrder orders} that already\n   * had been applied to the sale.\n   *\n   * The 2nd purpose is for the A/B tests. {@link IShoppingSeller Seller} needs\n   * to demonstrate operating performance by changing price, content, and\n   * composition of the product. This snapshot concept would be helpful for\n   * it.\n   *\n   * @param id Target sale's {@link IShoppingSale.id }\n   * @param body New information of the sale\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Put(\":id\")\n  public async putById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IShoppingSaleSnapshot.ICreate,\n  ): Promise<IShoppingSale> {\n    id;\n    body;\n    return typia.random<IShoppingSale>();\n  }\n}\n",
  "src/controllers/shoppings/sellers/sales/open/ShoppingsSellersSalesOpenController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedParam, TypedBody } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IShoppingSale } from \"../../../../../api/structures/IShoppingSale\";\n\n@Controller(\"/shoppings/sellers/sales/:id/open\")\nexport class ShoppingsSellersSalesOpenController {\n  /**\n   * Change opening and closing time of a sale.\n   *\n   * Update a {@link IShoppingSale sale}'s opening and closing time.\n   *\n   * By the way, if the sale still be opened or closed, it is not possible to\n   * change the opening time. In contrary, if the sale already had been opened\n   * but still not closed, it is possible to change the closing time.\n   *\n   * Of course, if closing time is less than opening time or not, 428\n   * unprocessable entity error would be thrown.\n   *\n   * @param id Target sale's {@link IShoppingSale.id }\n   * @param body New opening and closing time\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Put()\n  public async putById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IShoppingSale.IUpdateOpeningTime,\n  ): Promise<void> {\n    id;\n    body;\n    return typia.random<void>();\n  }\n}\n",
  "src/controllers/shoppings/sellers/sales/replica/ShoppingsSellersSalesReplicaController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedParam } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IShoppingSale } from \"../../../../../api/structures/IShoppingSale\";\n\n@Controller(\"/shoppings/sellers/sales/:id/replica\")\nexport class ShoppingsSellersSalesReplicaController {\n  /**\n   * Get replica of a sale.\n   *\n   * Get a {@link IShoppingSale.ICreate} typed info of the target sale for\n   * replication.\n   *\n   * It would be useful for creating a new replication\n   * {@link IShoppingSale sale} with similar innformatiopn.\n   *\n   * @param id Target sale's {@link IShoppingSale.id }\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Post()\n  public async postById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<IShoppingSale.ICreate> {\n    id;\n    return typia.random<IShoppingSale.ICreate>();\n  }\n}\n",
  "src/controllers/shoppings/sellers/sales/pause/ShoppingsSellersSalesPauseController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedParam } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\n@Controller(\"/shoppings/sellers/sales/:id/pause\")\nexport class ShoppingsSellersSalesPauseController {\n  /**\n   * Pause a sale.\n   *\n   * Pause a {@link IShoppingSale sale} from {@link open opened} state.\n   * Therefore, the sale can not be operated again until it be\n   * {@link restore restored}. By the way, {@link IShoppingCustomer customer}\n   * still can sale from the {@link index} and {@link at} API endpoints, but\n   * \"paused\" label would be attached.\n   *\n   * Also, customer no more can put into the shopping cart, either. Even the\n   * sale already had been put into the shopping cart, the\n   * {@link IShoppingCartCommodity commodity} will not be listed on the\n   * shopping cart. Also, it is not possible to applying an\n   * {@link IShoppingOrder order} with the paused sale's commodity, either.\n   *\n   * By the way, if the sale already had been applied to an order, the order\n   * can be {@link IShoppingOrderPublish published} and\n   * {@link IShoppingSeller seller} must {@link IShoppingDelivery deliver} the\n   * good to the customer.\n   *\n   * @param id Target sale's {@link IShoppingSale.id }\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Delete()\n  public async eraseById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<void> {\n    id;\n    return typia.random<void>();\n  }\n}\n",
  "src/controllers/shoppings/sellers/sales/suspend/ShoppingsSellersSalesSuspendController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedParam } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\n@Controller(\"/shoppings/sellers/sales/:id/suspend\")\nexport class ShoppingsSellersSalesSuspendController {\n  /**\n   * Suspend a sale.\n   *\n   * Suspend a {@link IShoppingSale sale} from {@link open opened} state.\n   * Therefore, the sale can not be operated again until it be\n   * {@link restore restored} and {@link IShoppingCustomer customer} cannot see\n   * the sale from the {@link index} and {@link at} API.\n   *\n   * Also, customer no more can put into the shopping cart, either. Even the\n   * sale already had been put into the shopping cart, the\n   * {@link IShoppingCartCommodity commodity} will not be listed on the\n   * shopping cart. Also, it is not possible to applying an\n   * {@link IShoppingOrder order} with the suspended sale's commodity, either.\n   *\n   * By the way, if the sale already had been applied to an order, the order\n   * can be {@link IShoppingOrderPublish published} and\n   * {@link IShoppingSeller seller} must {@link IShoppingDelivery deliver} the\n   * good to the customer.\n   *\n   * @param id Target sale's {@link IShoppingSale.id }\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Delete()\n  public async eraseById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<void> {\n    id;\n    return typia.random<void>();\n  }\n}\n",
  "src/controllers/shoppings/sellers/sales/restore/ShoppingsSellersSalesRestoreController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedParam } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\n@Controller(\"/shoppings/sellers/sales/:id/restore\")\nexport class ShoppingsSellersSalesRestoreController {\n  /**\n   * Describe summary as much as possible with clear and concise words.\n   *\n   * Restore a sale\n   *\n   * Restore a {@link IShoppingSale sale} from {@link pause paused} or\n   * {@link suspend suspended} state\n   *\n   * Therefore the sale can be operated again if its\n   * {@link IShoppingSale.closed_at closing time} has not been reached. Also,\n   * if a {@link IShoppingCustomer customer} had put the sale into the shopping\n   * cart when being paused or suspended, the\n   * {@link IShoppingCartCommodity commodity} will be listed again on the\n   * shopping cart.\n   *\n   * @param id Target sale's {@link IShoppingSale.id }\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Put()\n  public async putById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<void> {\n    id;\n    return typia.random<void>();\n  }\n}\n",
  "src/controllers/shoppings/sellers/sales/details/ShoppingsSellersSalesDetailsController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody } from \"@nestia/core\";\nimport typia from \"typia\";\n\nimport { IPageIShoppingSale } from \"../../../../../api/structures/IPageIShoppingSale\";\nimport { IShoppingSale } from \"../../../../../api/structures/IShoppingSale\";\n\n@Controller(\"/shoppings/sellers/sales/details\")\nexport class ShoppingsSellersSalesDetailsController {\n  /**\n   * List up every sales.\n   *\n   * List up every {@link IShoppingSale sales} with detailed information.\n   *\n   * As you can see, returned sales are detailed, not summarized. If you want\n   * to get the summarized information of sale for a brief, use {@link index}\n   * function instead.\n   *\n   * For reference, if you're a {@link IShoppingSeller seller}, you can only\n   * access to the your own {@link IShoppingSale sale}s. Otherwise you're a\n   * {@link IShoppingCustomer customer}, you can see only the operating sales\n   * in the market. Instead, you can't see the unopened, closed, or suspended\n   * sales.\n   *\n   * > If you're an A.I. chatbot, please don't summarize the\n   * > {@link IShoppingSaleUnitStock stock information}. Just list up the every\n   * > stocks in the sale with detailed information.\n   *\n   * @param body Request info of pagination, searching and sorting\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patch(\n    @TypedBody()\n    body: IShoppingSale.IRequest,\n  ): Promise<IPageIShoppingSale> {\n    body;\n    return typia.random<IPageIShoppingSale>();\n  }\n}\n",
  "src/controllers/shoppings/sellers/sales/questions/answer/ShoppingsSellersSalesQuestionsAnswerController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedParam, TypedBody } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IShoppingSaleInquiryAnswer } from \"../../../../../../api/structures/IShoppingSaleInquiryAnswer\";\nimport { IBbsArticle } from \"../../../../../../api/structures/IBbsArticle\";\n\n@Controller(\"/shoppings/sellers/sales/:saleId/questions/:questionId/answer\")\nexport class ShoppingsSellersSalesQuestionsAnswerController {\n  /**\n   * Write an answer article.\n   *\n   * Write a formal {@link IShoppingSaleInquiryAnswer answer article} to a\n   * specific {@link IShoppingSaleInquiry question article} written by a\n   * {@link IShoppingCustomer}.\n   *\n   * Note that, this is the formal answer that can be written only one per a\n   * question article (but {@link update updatable}). Therefore, it needs to\n   * guide the {@link IShoppingSeller seller} to write it carefully.\n   *\n   * Also, as seller can write {@link IShoppingSaleInquiryComment comments} to\n   * the question article as many as he/she wants, it would be useful for\n   * additional communication.\n   *\n   * @param saleId Belonged sale's {@link IShoppingSale.id }\n   * @param questionId Target question's {@link IShoppingSaleQuestion.id }\n   * @param body Creation info of the answer article\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Post()\n  public async postBySaleidAndQuestionid(\n    @TypedParam(\"saleId\")\n    saleId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"questionId\")\n    questionId: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IBbsArticle.ICreate,\n  ): Promise<IShoppingSaleInquiryAnswer> {\n    saleId;\n    questionId;\n    body;\n    return typia.random<IShoppingSaleInquiryAnswer>();\n  }\n\n  /**\n   * Update an answer article.\n   *\n   * Update a formal {@link IShoppingSaleInquiryAnswer answer article} to a\n   * specific {@link IShoppingSaleInquiry question article} written by a\n   * {@link IShoppingCustomer}.\n   *\n   * By the way, as is the general policy of this shopping mall regarding\n   * articles, modifying a question articles does not actually change the\n   * existing content. Modified content is accumulated and recorded in the\n   * existing article record as a new\n   * {@link IShoppingSaleInquiryAnswer.ISnapshot snapshot}. And this is made\n   * public to everyone, including the {@link IShoppingCustomer customer} and\n   * the {@link IShoppingSeller seller}, and anyone who can view the article\n   * can also view the entire editing histories.\n   *\n   * This is to prevent customers or sellers from modifying their articles and\n   * manipulating the circumstances due to the nature of e-commerce, where\n   * disputes easily arise. That is, to preserve evidence.\n   *\n   * @param saleId Belonged sale's {@link IShoppingSale.id }\n   * @param questionId Target question's {@link IShoppingSaleQuestion.id }\n   * @param body Update info of the answer article\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Put()\n  public async putBySaleidAndQuestionid(\n    @TypedParam(\"saleId\")\n    saleId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"questionId\")\n    questionId: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IBbsArticle.ICreate,\n  ): Promise<IShoppingSaleInquiryAnswer.ISnapshot> {\n    saleId;\n    questionId;\n    body;\n    return typia.random<IShoppingSaleInquiryAnswer.ISnapshot>();\n  }\n}\n",
  "src/controllers/shoppings/sellers/sales/questions/comments/ShoppingsSellersSalesQuestionsCommentsController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedParam, TypedBody } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IShoppingSaleInquiryComment } from \"../../../../../../api/structures/IShoppingSaleInquiryComment\";\nimport { IPageIShoppingSaleInquiryComment } from \"../../../../../../api/structures/IPageIShoppingSaleInquiryComment\";\n\n@Controller(\"/shoppings/sellers/sales/:saleId/questions/:inquiryId/comments\")\nexport class ShoppingsSellersSalesQuestionsCommentsController {\n  /**\n   * Create an inquiry comment.\n   *\n   * Create an {@link IShoppingSaleInquiryComment inquiry comment} of a\n   * {@link IShoppingSaleQuestion question} or\n   * {@link IShoppingSaleReview review}.\n   *\n   * For reference, if you're a {@link IShoppingSeller seller}, you can only\n   * create an inquiry comment to your own {@link IShoppingSale sale}'s\n   * inquiry. Otherwise, you can create an inquiry comment to every inquiries\n   * of the sales.\n   *\n   * @param saleId Belonged sale's {@link IShoppingSale.id }\n   * @param inquiryId Target inquiry's {@link IShoppingSaleInquiry.id }\n   * @param body Creation info of the inquiry comment\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Post()\n  public async postBySaleidAndInquiryid(\n    @TypedParam(\"saleId\")\n    saleId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"inquiryId\")\n    inquiryId: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IShoppingSaleInquiryComment.ICreate,\n  ): Promise<IShoppingSaleInquiryComment> {\n    saleId;\n    inquiryId;\n    body;\n    return typia.random<IShoppingSaleInquiryComment>();\n  }\n\n  /**\n   * List up every inquiry comments.\n   *\n   * List up every {@link IShoppingSaleInquiryComment inquiry comments} of a\n   * {@link IShoppingSaleQuestion question} or\n   * {@link IShoppingSaleReview review} with {@link IPage pagination}.\n   *\n   * If you want, you can limit the result by configuring\n   * {@link IShoppingSaleInquiryComment.IRequest.search search condition} in\n   * the request body. Also, it is possible to customize sequence order of\n   * records by configuring\n   * {@link IShoppingSaleInquiryComment.IRequest.sort sort condition}.\n   *\n   * By the way, if you're a {@link IShoppingSeller seller}, you can only\n   * access to the your own {@link IShoppingSale sale}'s inquiries. Otherwise,\n   * you can access to every inquiries of the sales.\n   *\n   * @param saleId Belonged sale's {@link IShoppingSale.id }\n   * @param inquiryId Belonged inquiry's {@link IShoppingSaleInquiry.id }\n   * @param body Request info of pagination, searching and sorting\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patchBySaleidAndInquiryid(\n    @TypedParam(\"saleId\")\n    saleId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"inquiryId\")\n    inquiryId: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IShoppingSaleInquiryComment.IRequest,\n  ): Promise<IPageIShoppingSaleInquiryComment> {\n    saleId;\n    inquiryId;\n    body;\n    return typia.random<IPageIShoppingSaleInquiryComment>();\n  }\n\n  /**\n   * Get an inquiry comment info.\n   *\n   * Get a detailed {@link IShoppingSaleInquiryComment inquiry comment}\n   * information of a {@link IShoppingSaleQuestion question} or\n   * {@link IShoppingSaleReview review}.\n   *\n   * For reference, if you're a {@link IShoppingSeller seller}, you can only\n   * access to the your own {@link IShoppingSale sale}'s inquiry comment.\n   * Otherwise, you can access to every inquiry comments of the sales.\n   *\n   * @param saleId Belonged sale's {@link IShoppingSale.id }\n   * @param inquiryId Belonged inquiry's {@link IShoppingSaleInquiry.id }\n   * @param id Target inquiry comment's {@link IShoppingSaleInquiryComment.id }\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get(\":id\")\n  public async getBySaleidAndInquiryidAndId(\n    @TypedParam(\"saleId\")\n    saleId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"inquiryId\")\n    inquiryId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<IShoppingSaleInquiryComment> {\n    saleId;\n    inquiryId;\n    id;\n    return typia.random<IShoppingSaleInquiryComment>();\n  }\n\n  /**\n   * Update an inquiry comment.\n   *\n   * Update an {@link IShoppingSaleInquiryComment inquiry comment} to a\n   * specific {@link IShoppingSaleQuestion question} or\n   * {@link IShoppingSaleReview review}.\n   *\n   * By the way, as is the general policy of this shopping mall regarding\n   * comments, modifying a comment does not actually change the existing\n   * content. Modified content is accumulated and recorded in the existing\n   * comment record as a new\n   * {@link IShoppingSaleInquiryComment.ISnapshot snapshot}. And this is made\n   * public to everyone, who can read this inquiry comment.\n   *\n   * This is to prevent customers or sellers from modifying their comments and\n   * manipulating the circumstances due to the nature of e-commerce, where\n   * disputes easily arise. That is, to preserve evidence.\n   *\n   * @param saleId Belonged sale's {@link IShoppingSale.id }\n   * @param inquiryId Belonged inquiry's {@link IShoppingSaleInquiry.id }\n   * @param id Target inquiry comment's {@link IShoppingSaleInquiryComment.id }\n   * @param body Update info of the inquiry comment\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Put(\":id\")\n  public async putBySaleidAndInquiryidAndId(\n    @TypedParam(\"saleId\")\n    saleId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"inquiryId\")\n    inquiryId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IShoppingSaleInquiryComment.ICreate,\n  ): Promise<IShoppingSaleInquiryComment.ISnapshot> {\n    saleId;\n    inquiryId;\n    id;\n    body;\n    return typia.random<IShoppingSaleInquiryComment.ISnapshot>();\n  }\n}\n",
  "src/controllers/shoppings/sellers/sales/questions/ShoppingsSellersSalesQuestionsController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedParam, TypedBody } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IPageIShoppingSaleQuestion } from \"../../../../../api/structures/IPageIShoppingSaleQuestion\";\nimport { IShoppingSaleQuestion } from \"../../../../../api/structures/IShoppingSaleQuestion\";\n\n@Controller(\"/shoppings/sellers/sales/:saleId/questions\")\nexport class ShoppingsSellersSalesQuestionsController {\n  /**\n   * List up every summarized questions.\n   *\n   * List up every {@link IShoppingSaleQuestion.ISummary summarized questions}\n   * of a {@link IShoppingSale sale}.\n   *\n   * As you can see, returned questions are summarized, not detailed. If you\n   * want to get the detailed information of a question, use {@link adridges}\n   * function or {@link at} function for each article.\n   *\n   * Also, returned question has {@link IShoppingSaleQuestion.ISummary.answer}\n   * property which means the formal answer from the {@link IShoppingSeller}.\n   * Additionally, returned question has another special property\n   * {@link IShoppingSaleQuestion.ISummary.secret} with masking to other\n   * princple properties, and it means only related actors can {@link at read}\n   * the question.\n   *\n   * For reference, if you're a {@link IShoppingSeller seller}, you can only\n   * access to the your own {@link IShoppingSale sale}'s questions. Otherwise,\n   * you can access to every questions of the sales.\n   *\n   * By the way, if you want, you can limit the result by configuring\n   * {@link IShoppingSaleQuestion.IRequest.search search condition} in the\n   * request body. Also, it is possible to customize sequence order of records\n   * by configuring\n   * {@link IShoppingSaleQuestion.IRequest.sort sort condition}.\n   *\n   * @param saleId Belonged sale's {@link IShoppingSale.id }\n   * @param body Request info of pagination, searching and sorting\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patchBySaleid(\n    @TypedParam(\"saleId\")\n    saleId: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IShoppingSaleQuestion.IRequest,\n  ): Promise<IPageIShoppingSaleQuestion.ISummary> {\n    saleId;\n    body;\n    return typia.random<IPageIShoppingSaleQuestion.ISummary>();\n  }\n\n  /**\n   * Get a question info.\n   *\n   * Get a detailed {@link IShoppingSaleQuestion question} information of a\n   * {@link IShoppingSale sale}.\n   *\n   * For reference, if you're a {@link IShoppingSeller seller}, you can only\n   * access to the your own {@link IShoppingSale sale}'s question. Otherwise\n   * you are a {@link IShoppingCustomer customer}, you can access to every\n   * questions of the sales except the {@link IShoppingSaleQuestion.secret}\n   * value is `false`.\n   *\n   * @param saleId Belonged sale's {@link IShoppingSale.id }\n   * @param id Target question's {@link IShoppingSaleQuestion.id }\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get(\":id\")\n  public async getBySaleidAndId(\n    @TypedParam(\"saleId\")\n    saleId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<IShoppingSaleQuestion> {\n    saleId;\n    id;\n    return typia.random<IShoppingSaleQuestion>();\n  }\n}\n",
  "src/controllers/shoppings/sellers/sales/questions/abridges/ShoppingsSellersSalesQuestionsAbridgesController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedParam, TypedBody } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IPageIShoppingSaleQuestion } from \"../../../../../../api/structures/IPageIShoppingSaleQuestion\";\nimport { IShoppingSaleQuestion } from \"../../../../../../api/structures/IShoppingSaleQuestion\";\n\n@Controller(\"/shoppings/sellers/sales/:saleId/questions/abridges\")\nexport class ShoppingsSellersSalesQuestionsAbridgesController {\n  /**\n   * List up every abridged questions.\n   *\n   * List up every {@link IShoppingSaleQuestion.IAbridge abridged questions} of\n   * a {@link IShoppingSale sale}.\n   *\n   * As you can see, returned questions are abridged, not detailed. If you\n   * want to get the detailed information of a question, use {@link at}\n   * function for each article.\n   *\n   * Also, returned question has {@link IShoppingSaleQuestion.IAridge.answer}\n   * property which means the formal answer from the {@link IShoppingSeller}.\n   * Additionally, returned question has another special property\n   * {@link IShoppingSaleQuestion.IAridge.secret} with masking to other\n   * princple properties, and it means only related actors can {@link at read}\n   * the question.\n   *\n   * For reference, if you're a {@link IShoppingSeller seller}, you can only\n   * access to the your own {@link IShoppingSale sale}'s questions. Otherwise,\n   * you can access to every questions of the sales.\n   *\n   * By the way, if you want, you can limit the result by configuring\n   * {@link IShoppingSaleQuestion.IRequest.search search condition} in the\n   * request body. Also, it is possible to customize sequence order of records\n   * by configuring\n   * {@link IShoppingSaleQuestion.IRequest.sort sort condition}.\n   *\n   * @param saleId Belonged sale's {@link IShoppingSale.id }\n   * @param body Request info of pagination, searching and sorting\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patchBySaleid(\n    @TypedParam(\"saleId\")\n    saleId: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IShoppingSaleQuestion.IRequest,\n  ): Promise<IPageIShoppingSaleQuestion.IAbridge> {\n    saleId;\n    body;\n    return typia.random<IPageIShoppingSaleQuestion.IAbridge>();\n  }\n}\n",
  "src/controllers/shoppings/sellers/sales/reviews/answer/ShoppingsSellersSalesReviewsAnswerController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedParam, TypedBody } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IShoppingSaleInquiryAnswer } from \"../../../../../../api/structures/IShoppingSaleInquiryAnswer\";\nimport { IBbsArticle } from \"../../../../../../api/structures/IBbsArticle\";\n\n@Controller(\"/shoppings/sellers/sales/:saleId/reviews/:reviewId/answer\")\nexport class ShoppingsSellersSalesReviewsAnswerController {\n  /**\n   * Write an answer article.\n   *\n   * Write a formal {@link IShoppingSaleInquiryAnswer answer article} to a\n   * specific {@link IShoppingSaleInquiry review article} written by a\n   * {@link IShoppingCustomer}.\n   *\n   * Note that, this is the formal answer that can be written only one per a\n   * review article (but {@link update updatable}). Therefore, it needs to\n   * guide the {@link IShoppingSeller seller} to write it carefully.\n   *\n   * Also, as seller can write {@link IShoppingSaleInquiryComment comments} to\n   * the review article as many as he/she wants, it would be useful for\n   * additional communication.\n   *\n   * @param saleId Belonged sale's {@link IShoppingSale.id }\n   * @param reviewId Target review's {@link IShoppingSaleReview.id }\n   * @param body Creation info of the answer article\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Post()\n  public async postBySaleidAndReviewid(\n    @TypedParam(\"saleId\")\n    saleId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"reviewId\")\n    reviewId: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IBbsArticle.ICreate,\n  ): Promise<IShoppingSaleInquiryAnswer> {\n    saleId;\n    reviewId;\n    body;\n    return typia.random<IShoppingSaleInquiryAnswer>();\n  }\n\n  /**\n   * Update an answer article.\n   *\n   * Update a formal {@link IShoppingSaleInquiryAnswer answer article} to a\n   * specific {@link IShoppingSaleInquiry review article} written by a\n   * {@link IShoppingCustomer}.\n   *\n   * By the way, as is the general policy of this shopping mall regarding\n   * articles, modifying a review articles does not actually change the\n   * existing content. Modified content is accumulated and recorded in the\n   * existing article record as a new\n   * {@link IShoppingSaleInquiryAnswer.ISnapshot snapshot}. And this is made\n   * public to everyone, including the {@link IShoppingCustomer customer} and\n   * the {@link IShoppingSeller seller}, and anyone who can view the article\n   * can also view the entire editing histories.\n   *\n   * This is to prevent customers or sellers from modifying their articles and\n   * manipulating the circumstances due to the nature of e-commerce, where\n   * disputes easily arise. That is, to preserve evidence.\n   *\n   * @param saleId Belonged sale's {@link IShoppingSale.id }\n   * @param reviewId Target review's {@link IShoppingSaleReview.id }\n   * @param body Update info of the answer article\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Put()\n  public async putBySaleidAndReviewid(\n    @TypedParam(\"saleId\")\n    saleId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"reviewId\")\n    reviewId: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IBbsArticle.ICreate,\n  ): Promise<IShoppingSaleInquiryAnswer.ISnapshot> {\n    saleId;\n    reviewId;\n    body;\n    return typia.random<IShoppingSaleInquiryAnswer.ISnapshot>();\n  }\n}\n",
  "src/controllers/shoppings/sellers/sales/reviews/comments/ShoppingsSellersSalesReviewsCommentsController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedParam, TypedBody } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IShoppingSaleInquiryComment } from \"../../../../../../api/structures/IShoppingSaleInquiryComment\";\nimport { IPageIShoppingSaleInquiryComment } from \"../../../../../../api/structures/IPageIShoppingSaleInquiryComment\";\n\n@Controller(\"/shoppings/sellers/sales/:saleId/reviews/:inquiryId/comments\")\nexport class ShoppingsSellersSalesReviewsCommentsController {\n  /**\n   * Create an inquiry comment.\n   *\n   * Create an {@link IShoppingSaleInquiryComment inquiry comment} of a\n   * {@link IShoppingSaleQuestion question} or\n   * {@link IShoppingSaleReview review}.\n   *\n   * For reference, if you're a {@link IShoppingSeller seller}, you can only\n   * create an inquiry comment to your own {@link IShoppingSale sale}'s\n   * inquiry. Otherwise, you can create an inquiry comment to every inquiries\n   * of the sales.\n   *\n   * @param saleId Belonged sale's {@link IShoppingSale.id }\n   * @param inquiryId Target inquiry's {@link IShoppingSaleInquiry.id }\n   * @param body Creation info of the inquiry comment\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Post()\n  public async postBySaleidAndInquiryid(\n    @TypedParam(\"saleId\")\n    saleId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"inquiryId\")\n    inquiryId: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IShoppingSaleInquiryComment.ICreate,\n  ): Promise<IShoppingSaleInquiryComment> {\n    saleId;\n    inquiryId;\n    body;\n    return typia.random<IShoppingSaleInquiryComment>();\n  }\n\n  /**\n   * List up every inquiry comments.\n   *\n   * List up every {@link IShoppingSaleInquiryComment inquiry comments} of a\n   * {@link IShoppingSaleQuestion question} or\n   * {@link IShoppingSaleReview review} with {@link IPage pagination}.\n   *\n   * If you want, you can limit the result by configuring\n   * {@link IShoppingSaleInquiryComment.IRequest.search search condition} in\n   * the request body. Also, it is possible to customize sequence order of\n   * records by configuring\n   * {@link IShoppingSaleInquiryComment.IRequest.sort sort condition}.\n   *\n   * By the way, if you're a {@link IShoppingSeller seller}, you can only\n   * access to the your own {@link IShoppingSale sale}'s inquiries. Otherwise,\n   * you can access to every inquiries of the sales.\n   *\n   * @param saleId Belonged sale's {@link IShoppingSale.id }\n   * @param inquiryId Belonged inquiry's {@link IShoppingSaleInquiry.id }\n   * @param body Request info of pagination, searching and sorting\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patchBySaleidAndInquiryid(\n    @TypedParam(\"saleId\")\n    saleId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"inquiryId\")\n    inquiryId: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IShoppingSaleInquiryComment.IRequest,\n  ): Promise<IPageIShoppingSaleInquiryComment> {\n    saleId;\n    inquiryId;\n    body;\n    return typia.random<IPageIShoppingSaleInquiryComment>();\n  }\n\n  /**\n   * Get an inquiry comment info.\n   *\n   * Get a detailed {@link IShoppingSaleInquiryComment inquiry comment}\n   * information of a {@link IShoppingSaleQuestion question} or\n   * {@link IShoppingSaleReview review}.\n   *\n   * For reference, if you're a {@link IShoppingSeller seller}, you can only\n   * access to the your own {@link IShoppingSale sale}'s inquiry comment.\n   * Otherwise, you can access to every inquiry comments of the sales.\n   *\n   * @param saleId Belonged sale's {@link IShoppingSale.id }\n   * @param inquiryId Belonged inquiry's {@link IShoppingSaleInquiry.id }\n   * @param id Target inquiry comment's {@link IShoppingSaleInquiryComment.id }\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get(\":id\")\n  public async getBySaleidAndInquiryidAndId(\n    @TypedParam(\"saleId\")\n    saleId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"inquiryId\")\n    inquiryId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<IShoppingSaleInquiryComment> {\n    saleId;\n    inquiryId;\n    id;\n    return typia.random<IShoppingSaleInquiryComment>();\n  }\n\n  /**\n   * Update an inquiry comment.\n   *\n   * Update an {@link IShoppingSaleInquiryComment inquiry comment} to a\n   * specific {@link IShoppingSaleQuestion question} or\n   * {@link IShoppingSaleReview review}.\n   *\n   * By the way, as is the general policy of this shopping mall regarding\n   * comments, modifying a comment does not actually change the existing\n   * content. Modified content is accumulated and recorded in the existing\n   * comment record as a new\n   * {@link IShoppingSaleInquiryComment.ISnapshot snapshot}. And this is made\n   * public to everyone, who can read this inquiry comment.\n   *\n   * This is to prevent customers or sellers from modifying their comments and\n   * manipulating the circumstances due to the nature of e-commerce, where\n   * disputes easily arise. That is, to preserve evidence.\n   *\n   * @param saleId Belonged sale's {@link IShoppingSale.id }\n   * @param inquiryId Belonged inquiry's {@link IShoppingSaleInquiry.id }\n   * @param id Target inquiry comment's {@link IShoppingSaleInquiryComment.id }\n   * @param body Update info of the inquiry comment\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Put(\":id\")\n  public async putBySaleidAndInquiryidAndId(\n    @TypedParam(\"saleId\")\n    saleId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"inquiryId\")\n    inquiryId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IShoppingSaleInquiryComment.ICreate,\n  ): Promise<IShoppingSaleInquiryComment.ISnapshot> {\n    saleId;\n    inquiryId;\n    id;\n    body;\n    return typia.random<IShoppingSaleInquiryComment.ISnapshot>();\n  }\n}\n",
  "src/controllers/shoppings/sellers/sales/reviews/ShoppingsSellersSalesReviewsController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedParam, TypedBody } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IPageIShoppingSaleReview } from \"../../../../../api/structures/IPageIShoppingSaleReview\";\nimport { IShoppingSaleReview } from \"../../../../../api/structures/IShoppingSaleReview\";\n\n@Controller(\"/shoppings/sellers/sales/:saleId/reviews\")\nexport class ShoppingsSellersSalesReviewsController {\n  /**\n   * List up every summarized reviews.\n   *\n   * List up every {@link IShoppingSaleReview.ISummary summarized reviews} of a\n   * {@link IShoppingSale sale}.\n   *\n   * As you can see, returned reviews are summarized, not detailed. If you\n   * want to get the detailed information of a review, use {@link adridges}\n   * function or {@link at} function for each article.\n   *\n   * Also, returned review has {@link IShoppingSaleReview.ISummary.answer}\n   * property which means the formal answer from the {@link IShoppingSeller}.\n   *\n   * For reference, if you're a {@link IShoppingSeller seller}, you can only\n   * access to the your own {@link IShoppingSale sale}'s reviews. Otherwise,\n   * you can access to every reviews of the sales.\n   *\n   * By the way, if you want, you can limit the result by configuring\n   * {@link IShoppingSaleReview.IRequest.search search condition} in the\n   * request body. Also, it is possible to customize sequence order of records\n   * by configuring {@link IShoppingSaleReview.IRequest.sort sort condition}.\n   *\n   * @param saleId Belonged sale's {@link IShoppingSale.id }\n   * @param body Request info of pagination, searching and sorting\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patchBySaleid(\n    @TypedParam(\"saleId\")\n    saleId: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IShoppingSaleReview.IRequest,\n  ): Promise<IPageIShoppingSaleReview.ISummary> {\n    saleId;\n    body;\n    return typia.random<IPageIShoppingSaleReview.ISummary>();\n  }\n\n  /**\n   * Get a review info.\n   *\n   * Get a detailed {@link IShoppingSaleReview review} information of a\n   * {@link IShoppingSale sale}.\n   *\n   * For reference, if you're a {@link IShoppingSeller seller}, you can only\n   * access to the your own {@link IShoppingSale sale}'s review. Otherwise you\n   * are a {@link IShoppingCustomer customer}, you can access to every reviews\n   * of the sales.\n   *\n   * @param saleId Belonged sale's {@link IShoppingSale.id }\n   * @param id Target review's {@link IShoppingSaleReview.id }\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get(\":id\")\n  public async getBySaleidAndId(\n    @TypedParam(\"saleId\")\n    saleId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<IShoppingSaleReview> {\n    saleId;\n    id;\n    return typia.random<IShoppingSaleReview>();\n  }\n}\n",
  "src/controllers/shoppings/sellers/sales/reviews/abridges/ShoppingsSellersSalesReviewsAbridgesController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedParam, TypedBody } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IPageIShoppingSaleReview } from \"../../../../../../api/structures/IPageIShoppingSaleReview\";\nimport { IShoppingSaleReview } from \"../../../../../../api/structures/IShoppingSaleReview\";\n\n@Controller(\"/shoppings/sellers/sales/:saleId/reviews/abridges\")\nexport class ShoppingsSellersSalesReviewsAbridgesController {\n  /**\n   * List up every abridged reviews.\n   *\n   * List up every {@link IShoppingSaleReview.IAbridge abridged reviews} of a\n   * {@link IShoppingSale sale}.\n   *\n   * As you can see, returned reviews are abridged, not detailed. If you want\n   * to get the detailed information of a review, use {@link at} function for\n   * each article.\n   *\n   * Also, returned review has {@link IShoppingSaleReview.IAridge.answer}\n   * property which means the formal answer from the {@link IShoppingSeller}.\n   *\n   * For reference, if you're a {@link IShoppingSeller seller}, you can only\n   * access to the your own {@link IShoppingSale sale}'s reviews. Otherwise,\n   * you can access to every reviews of the sales.\n   *\n   * By the way, if you want, you can limit the result by configuring\n   * {@link IShoppingSaleReview.IRequest.search search condition} in the\n   * request body. Also, it is possible to customize sequence order of records\n   * by configuring {@link IShoppingSaleReview.IRequest.sort sort condition}.\n   *\n   * @param saleId Belonged sale's {@link IShoppingSale.id }\n   * @param body Request info of pagination, searching and sorting\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patchBySaleid(\n    @TypedParam(\"saleId\")\n    saleId: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IShoppingSaleReview.IRequest,\n  ): Promise<IPageIShoppingSaleReview.IAbridge> {\n    saleId;\n    body;\n    return typia.random<IPageIShoppingSaleReview.IAbridge>();\n  }\n}\n",
  "src/controllers/shoppings/sellers/sales/snapshots/replica/ShoppingsSellersSalesSnapshotsReplicaController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedParam } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IShoppingSale } from \"../../../../../../api/structures/IShoppingSale\";\n\n@Controller(\"/shoppings/sellers/sales/:saleId/snapshots/:id/replica\")\nexport class ShoppingsSellersSalesSnapshotsReplicaController {\n  /**\n   * Get replica of a snapshot.\n   *\n   * Get a {@link IShoppingSale.ICreate} typed info of the target\n   * {@link IShoppingSaleSnapshot snapshot} record for replication.\n   *\n   * It would be useful for creating a new replication\n   * {@link IShoppingSale sale} from the old snapshot.\n   *\n   * @param saleId Belonged sale's {@link IShoppingSale.id }\n   * @param id Target snapshot's {@link IShoppingSaleSnapshot.id }\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Post()\n  public async postBySaleidAndId(\n    @TypedParam(\"saleId\")\n    saleId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<IShoppingSale.ICreate> {\n    saleId;\n    id;\n    return typia.random<IShoppingSale.ICreate>();\n  }\n}\n",
  "src/controllers/shoppings/sellers/sales/snapshots/ShoppingsSellersSalesSnapshotsController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedParam, TypedBody } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IPageIShoppingSaleSnapshot } from \"../../../../../api/structures/IPageIShoppingSaleSnapshot\";\nimport { IPage } from \"../../../../../api/structures/IPage\";\nimport { IShoppingSaleSnapshot } from \"../../../../../api/structures/IShoppingSaleSnapshot\";\n\n@Controller(\"/shoppings/sellers/sales/:saleId/snapshots\")\nexport class ShoppingsSellersSalesSnapshotsController {\n  /**\n   * List up every snapshots.\n   *\n   * Whenever {@link IShoppingSeller seller} updates a\n   * {@link IShoppingSale sale}, the sale record is not updated but a new\n   * {@link IShoppingSaleSnapshot snapshot} record is created to keep the\n   * integrity of the sale history. This API function is for listing up such\n   * snapshot records.\n   *\n   * Also, as you can see from the return type, returned snapshots are\n   * summarized, not detailed. If you want to get the detailed information of\n   * a snapshot, use {@link at} or {@link flipo} function for each snapshot.\n   *\n   * For reference, if you're a {@link IShoppingSeller seller}, you can only\n   * access to the your own {@link IShoppingSale sale}'s snapshots. Otherwise,\n   * you can access to every snapshots of the sales even though the sale has\n   * been closed or suspended.\n   *\n   * @param saleId Target sale's {@link IShoppingSale.id }\n   * @param body Requestion info of pagination\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patchBySaleid(\n    @TypedParam(\"saleId\")\n    saleId: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IPage.IRequest,\n  ): Promise<IPageIShoppingSaleSnapshot.ISummary> {\n    saleId;\n    body;\n    return typia.random<IPageIShoppingSaleSnapshot.ISummary>();\n  }\n\n  /**\n   * Get a snapshot info.\n   *\n   * Get a {@link IShoppingSaleSnapshot snapshot} with detailed information.\n   *\n   * As you can see from the return type, returned snapshot does not contain\n   * the {@link IShoppingSale sale} info. If you want to get the sale info, use\n   * the {@link flip} function instead.\n   *\n   * For reference, if you're a {@link IShoppingSeller seller}, you can only\n   * access to the your own {@link IShoppingSale sale}'s snapshots. Otherwise,\n   * you can access to every snapshots of the sales even though the sale has\n   * been closed or suspended.\n   *\n   * @param saleId Belonged sale's {@link IShoppingSale.id }\n   * @param id Target snapshot's {@link IShoppingSaleSnapshot.id }\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get(\":id\")\n  public async getBySaleidAndId(\n    @TypedParam(\"saleId\")\n    saleId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<IShoppingSaleSnapshot> {\n    saleId;\n    id;\n    return typia.random<IShoppingSaleSnapshot>();\n  }\n}\n",
  "src/controllers/shoppings/sellers/sales/snapshots/flip/ShoppingsSellersSalesSnapshotsFlipController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedParam } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IShoppingSale } from \"../../../../../../api/structures/IShoppingSale\";\n\n@Controller(\"/shoppings/sellers/sales/:saleId/snapshots/:id/flip\")\nexport class ShoppingsSellersSalesSnapshotsFlipController {\n  /**\n   * Get a flipped snapshot info.\n   *\n   * Get a {@link IShoppingSale sale} info of a flipped snapshot.\n   *\n   * As you can see from the return type, this function returns the\n   * {@link IShoppingSale sale} info. By the way, the sale info is not the\n   * latest one, but a flipped info in the snapshot side.\n   *\n   * Also, if you're a {@link IShoppingSeller seller}, you can only access to\n   * the your own {@link IShoppingSale sale}'s snapshots. Otherwise, you can\n   * access to every snapshots of the sales even though the sale has been\n   * closed or suspended.\n   *\n   * @param saleId Belonged sale's {@link IShoppingSale.id }\n   * @param id Target snapshot's {@link IShoppingSaleSnapshot.id }\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get()\n  public async getBySaleidAndId(\n    @TypedParam(\"saleId\")\n    saleId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<IShoppingSale> {\n    saleId;\n    id;\n    return typia.random<IShoppingSale>();\n  }\n}\n",
  "src/controllers/shoppings/sellers/sales/units/stocks/supplements/ShoppingsSellersSalesUnitsStocksSupplementsController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedParam, TypedBody } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IShoppingSaleUnitStockSupplement } from \"../../../../../../../api/structures/IShoppingSaleUnitStockSupplement\";\nimport { IPageIShoppingSaleUnitStockSupplement } from \"../../../../../../../api/structures/IPageIShoppingSaleUnitStockSupplement\";\n\n@Controller(\n  \"/shoppings/sellers/sales/:saleId/units/:unitId/stocks/:stockId/supplements\",\n)\nexport class ShoppingsSellersSalesUnitsStocksSupplementsController {\n  /**\n   * Create a supplement.\n   *\n   * Create a {@link IShoppingSaleUnitStockSupplement supplement history} of a\n   * specific {@link IShoppingSaleUnitStock stock}.\n   *\n   * Therefore, {@link IShoppingSaleUnitStockInventory.income inventory} of the\n   * target stock will be increased by the\n   * {@link IShoppingSaleUnitStockSupplement.value supplement's value}.\n   *\n   * @param saleId Belonged sale's {@link IShoppingSale.id }\n   * @param unitId Belonged unit's {@link IShoppingSaleUnit.id }\n   * @param stockId Target stock's {@link IShoppingSaleUnitStock.id }\n   * @param body Create info of the supplement\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Post()\n  public async postBySaleidAndUnitidAndStockid(\n    @TypedParam(\"saleId\")\n    saleId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"unitId\")\n    unitId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"stockId\")\n    stockId: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IShoppingSaleUnitStockSupplement.ICreate,\n  ): Promise<IShoppingSaleUnitStockSupplement> {\n    saleId;\n    unitId;\n    stockId;\n    body;\n    return typia.random<IShoppingSaleUnitStockSupplement>();\n  }\n\n  /**\n   * List up every supplements.\n   *\n   * List up every\n   * {@link IShoppingSaleUnitStockSupplement supplement histories} of a\n   * specific {@link IShoppingSaleUnitStock stock}.\n   *\n   * If you want, you can limit the result by configuring\n   * {@link IShoppingSaleUnitStockSupplement.IRequest.search search condition}\n   * in the request body. Also, it is possible to customize sequence order of\n   * records by configuring\n   * {@link IShoppingSaleUnitStockSupplement.IRequest.sort} property.\n   *\n   * @param saleId Belonged sale's {@link IShoppingSale.id }\n   * @param unitId Belonged unit's {@link IShoppingSaleUnit.id }\n   * @param stockId Target stock's {@link IShoppingSaleUnitStock.id }\n   * @param body Request info of pagination, searching and sorting\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patchBySaleidAndUnitidAndStockid(\n    @TypedParam(\"saleId\")\n    saleId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"unitId\")\n    unitId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"stockId\")\n    stockId: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IShoppingSaleUnitStockSupplement.IRequest,\n  ): Promise<IPageIShoppingSaleUnitStockSupplement> {\n    saleId;\n    unitId;\n    stockId;\n    body;\n    return typia.random<IPageIShoppingSaleUnitStockSupplement>();\n  }\n\n  /**\n   * Update a supplement.\n   *\n   * Update quantity value of a\n   * {@link IShoppingSaleUnitStockSupplement supplement} of a specific\n   * {@link IShoppingSaleUnitStock stock}.\n   *\n   * Therefore, {@link IShoppingSaleUnitStockInventory.income inventory} of the\n   * target stock will be changed by the\n   * {@link IShoppingSaleUnitStockSupplement.value supplement's value}.\n   *\n   * @param saleId Belonged sale's {@link IShoppingSale.id }\n   * @param unitId Belonged unit's {@link IShoppingSaleUnit.id }\n   * @param stockId Target stock's {@link IShoppingSaleUnitStock.id }\n   * @param id Target supplement's {@link IShoppingSaleUnitStockSupplement.id }\n   * @param body Update info (quantity) of the supplement\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Put(\":id\")\n  public async putBySaleidAndUnitidAndStockidAndId(\n    @TypedParam(\"saleId\")\n    saleId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"unitId\")\n    unitId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"stockId\")\n    stockId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IShoppingSaleUnitStockSupplement.ICreate,\n  ): Promise<void> {\n    saleId;\n    unitId;\n    stockId;\n    id;\n    body;\n    return typia.random<void>();\n  }\n\n  /**\n   * Erase a supplement.\n   *\n   * Erase a {@link IShoppingSaleUnitStockSupplement supplement} of a specific\n   * {@link IShoppingSaleUnitStock stock}.\n   *\n   * Therefore, {@link IShoppingSaleUnitStockInventory.income inventory} of the\n   * target stock will be decreased by the\n   * {@link IShoppingSaleUnitStockSupplement.value supplement's value}.\n   *\n   * @param saleId Belonged sale's {@link IShoppingSale.id }\n   * @param unitId Belonged unit's {@link IShoppingSaleUnit.id }\n   * @param stockId Target stock's {@link IShoppingSaleUnitStock.id }\n   * @param id Target supplement's {@link IShoppingSaleUnitStockSupplement.id }\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Delete(\":id\")\n  public async eraseBySaleidAndUnitidAndStockidAndId(\n    @TypedParam(\"saleId\")\n    saleId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"unitId\")\n    unitId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"stockId\")\n    stockId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<void> {\n    saleId;\n    unitId;\n    stockId;\n    id;\n    return typia.random<void>();\n  }\n}\n",
  "src/controllers/shoppings/sellers/systematic/channels/categories/ShoppingsSellersSystematicChannelsCategoriesController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedParam } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IShoppingChannelCategory } from \"../../../../../../api/structures/IShoppingChannelCategory\";\n\n@Controller(\"/shoppings/sellers/systematic/channels/:channelCode/categories\")\nexport class ShoppingsSellersSystematicChannelsCategoriesController {\n  /**\n   * List up every categories with children records.\n   *\n   * List up every {@link IShoppingChannelCategory.IHierarchical categories} of\n   * a {@link IShoppingChannel channel} with pagination. Returned categories\n   * contain children categories, too.\n   *\n   * If you want, you can limit the result by configuring\n   * {@link IShoppingChannelCategory.IRequest.search search condition} in the\n   * request body. Also, it is possible to customize sequence order of records\n   * by configuring\n   * {@link IShoppingChannelCategory.IRequest.sort sort condition}.\n   *\n   * @param channelCode Belonged channel's {@link IShoppingChannel.code }\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patchByChannelcode(\n    @TypedParam(\"channelCode\")\n    channelCode: string,\n  ): Promise<void> {\n    channelCode;\n    return typia.random<void>();\n  }\n\n  /**\n   * Get a category info.\n   *\n   * Get a detailed {@link IShoppingChannelCategory category} information.\n   *\n   * Returned category contains hierarchical children categories, and also\n   * contains the recursive parent categories, too.\n   *\n   * @param channelCode Belonged channel's {@link IShoppingChannel.code }\n   * @param id Target category's {@link IShoppingChannelCategory.id }\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get(\":id\")\n  public async getByChannelcodeAndId(\n    @TypedParam(\"channelCode\")\n    channelCode: string,\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<IShoppingChannelCategory> {\n    channelCode;\n    id;\n    return typia.random<IShoppingChannelCategory>();\n  }\n}\n",
  "src/controllers/shoppings/sellers/systematic/channels/categories/invert/ShoppingsSellersSystematicChannelsCategoriesInvertController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedParam } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IShoppingChannelCategory } from \"../../../../../../../api/structures/IShoppingChannelCategory\";\n\n@Controller(\n  \"/shoppings/sellers/systematic/channels/:channelCode/categories/:id/invert\",\n)\nexport class ShoppingsSellersSystematicChannelsCategoriesInvertController {\n  /**\n   * Get a category info of inverted.\n   *\n   * Get a inverted {@link IShoppingChannelCategory.IInvert category}\n   * information.\n   *\n   * Returned category contains the recursive parent categories, but not\n   * contains the hierarchical children categories.\n   *\n   * @param channelCode Belonged channel's {@link IShoppingChannel.code }\n   * @param id Target category's {@link IShoppingChannelCategory.id }\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get()\n  public async getByChannelcodeAndId(\n    @TypedParam(\"channelCode\")\n    channelCode: string,\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<IShoppingChannelCategory.IInvert> {\n    channelCode;\n    id;\n    return typia.random<IShoppingChannelCategory.IInvert>();\n  }\n}\n",
  "src/controllers/shoppings/sellers/systematic/channels/ShoppingsSellersSystematicChannelsController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody, TypedParam } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IPageIShoppingChannel } from \"../../../../../api/structures/IPageIShoppingChannel\";\nimport { IShoppingChannel } from \"../../../../../api/structures/IShoppingChannel\";\n\n@Controller(\"/shoppings/sellers/systematic/channels\")\nexport class ShoppingsSellersSystematicChannelsController {\n  /**\n   * List up every channels.\n   *\n   * List up every {@link IShoppingChannel channels} with pagination.\n   *\n   * If you want, you can limit the result by configuring\n   * {@link IShoppingChannel.IRequest.search search condition} in the request\n   * body. Also, it is possible to customize sequence order of records by\n   * configuring {@link IShoppingChannel.IRequest.sort sort condition}.\n   *\n   * @param body Request info of pagination, searching and sorting\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patch(\n    @TypedBody()\n    body: IShoppingChannel.IRequest,\n  ): Promise<IPageIShoppingChannel> {\n    body;\n    return typia.random<IPageIShoppingChannel>();\n  }\n\n  /**\n   * Get a channel info.\n   *\n   * Get a detailed {@link IShoppingChannel.IHierarchical channel} information.\n   *\n   * Returned channel instance also contains the nested\n   * {@link IShoppingChannelCategory.IHierarchical hierarchical category}\n   * information.\n   *\n   * @param id Target channel's {@link IShoppingChannel.id }\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get(\":id\")\n  public async getById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<IShoppingChannel.IHierarchical> {\n    id;\n    return typia.random<IShoppingChannel.IHierarchical>();\n  }\n}\n",
  "src/controllers/shoppings/sellers/systematic/channels/hierarchical/ShoppingsSellersSystematicChannelsHierarchicalController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody } from \"@nestia/core\";\nimport typia from \"typia\";\n\nimport { IPageIShoppingChannel } from \"../../../../../../api/structures/IPageIShoppingChannel\";\nimport { IShoppingChannel } from \"../../../../../../api/structures/IShoppingChannel\";\n\n@Controller(\"/shoppings/sellers/systematic/channels/hierarchical\")\nexport class ShoppingsSellersSystematicChannelsHierarchicalController {\n  /**\n   * List up every channels with nested categories.\n   *\n   * List up every {@link IShoppingChannel.IHierarchical channels} with\n   * {@link IPage pagination}. Returned channels contain nested hierarchical\n   * {@link IShoppingChannelCategory.IHierarchical categories}.\n   *\n   * If you want, you can limit the result by configuring\n   * {@link IShoppingChannel.IRequest.search search condition} in the request\n   * body. Also, it is possible to customize sequence order of records by\n   * configuring {@link IShoppingChannel.IRequest.sort sort condition}.\n   *\n   * @param body Request info of pagination, searching and sorting\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patch(\n    @TypedBody()\n    body: IShoppingChannel.IRequest,\n  ): Promise<IPageIShoppingChannel.IHierarchical> {\n    body;\n    return typia.random<IPageIShoppingChannel.IHierarchical>();\n  }\n}\n",
  "src/controllers/shoppings/sellers/systematic/channels/get/ShoppingsSellersSystematicChannelsGetController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedParam } from \"@nestia/core\";\nimport typia from \"typia\";\n\nimport { IShoppingChannel } from \"../../../../../../api/structures/IShoppingChannel\";\n\n@Controller(\"/shoppings/sellers/systematic/channels/:code/get\")\nexport class ShoppingsSellersSystematicChannelsGetController {\n  /**\n   * Get a channel info by its code.\n   *\n   * Get a detailed {@link IShoppingChannel.IHierarchical channel} information\n   * by its code.\n   *\n   * Returned channel instance also contains the nested\n   * {@link IShoppingChannelCategory.IHierarchical hierarchical category}\n   * information.\n   *\n   * @param code Target channel's {@link IShoppingChannel.code }\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get()\n  public async getByCode(\n    @TypedParam(\"code\")\n    code: string,\n  ): Promise<IShoppingChannel.IHierarchical> {\n    code;\n    return typia.random<IShoppingChannel.IHierarchical>();\n  }\n}\n",
  "src/controllers/shoppings/sellers/systematic/sections/ShoppingsSellersSystematicSectionsController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody, TypedParam } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IPageIShoppingSection } from \"../../../../../api/structures/IPageIShoppingSection\";\nimport { IShoppingSection } from \"../../../../../api/structures/IShoppingSection\";\n\n@Controller(\"/shoppings/sellers/systematic/sections\")\nexport class ShoppingsSellersSystematicSectionsController {\n  /**\n   * List up every sections.\n   *\n   * List up every {@link IShoppingSection sections} with pagination.\n   *\n   * If you want, you can limit the result by configuring\n   * {@link IShoppingSection.IRequest.search search condition} in the request\n   * body. Also, it is possible to customize sequence order of records by\n   * configuring {@link IShoppingSection.IRequest.sort sort condition}.\n   *\n   * @param body Request info of pagination, searching and sorting\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patch(\n    @TypedBody()\n    body: IShoppingSection.IRequest,\n  ): Promise<IPageIShoppingSection> {\n    body;\n    return typia.random<IPageIShoppingSection>();\n  }\n\n  /**\n   * Get a section info.\n   *\n   * Get a detailed {@link IShoppingSection section} information.\n   *\n   * @param id Target section's {@link IShoppingSection.id }\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get(\":id\")\n  public async getById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<IShoppingSection> {\n    id;\n    return typia.random<IShoppingSection>();\n  }\n}\n",
  "src/controllers/shoppings/sellers/systematic/sections/get/ShoppingsSellersSystematicSectionsGetController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedParam } from \"@nestia/core\";\nimport typia from \"typia\";\n\nimport { IShoppingSection } from \"../../../../../../api/structures/IShoppingSection\";\n\n@Controller(\"/shoppings/sellers/systematic/sections/:code/get\")\nexport class ShoppingsSellersSystematicSectionsGetController {\n  /**\n   * Get a section info by its code.\n   *\n   * Get a detailed {@link IShoppingSection section} information by its code.\n   *\n   * @param code Target section's {@link IShoppingSection.code }\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get()\n  public async getByCode(\n    @TypedParam(\"code\")\n    code: string,\n  ): Promise<IShoppingSection> {\n    code;\n    return typia.random<IShoppingSection>();\n  }\n}\n",
  "src/api/structures/IPerformance.ts": "import { process } from \"./process\";\n\n/** @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe */\nexport type IPerformance = {\n  cpu: process.global.NodeJS.CpuUsage;\n  memory: process.global.NodeJS.MemoryUsage;\n  resource: process.global.NodeJS.ResourceUsage;\n};\n",
  "src/api/structures/process.ts": "export namespace process {\n  export namespace global {\n    export namespace NodeJS {\n      export type CpuUsage = {\n        user: number;\n        system: number;\n      };\n\n      export type MemoryUsage = {\n        /**\n         * Resident Set Size, is the amount of space occupied in the\n         * main memory device (that is a subset of the total allocated\n         * memory) for the process, including all C++ and JavaScript\n         * objects and code.\n         */\n        rss: number;\n\n        /**\n         * Refers to V8's memory usage.\n         *\n         * @title Refers to V8's memory usage\n         */\n        heapTotal: number;\n\n        /**\n         * Refers to V8's memory usage.\n         *\n         * @title Refers to V8's memory usage\n         */\n        heapUsed: number;\n        external: number;\n\n        /**\n         * Refers to memory allocated for `ArrayBuffer`s and\n         * `SharedArrayBuffer`s, including all Node.js Buffers. This is\n         * also included in the external value. When Node.js is used as\n         * an embedded library, this value may be `0` because\n         * allocations for `ArrayBuffer`s may not be tracked in that\n         * case.\n         */\n        arrayBuffers: number;\n      };\n\n      export type ResourceUsage = {\n        fsRead: number;\n        fsWrite: number;\n        involuntaryContextSwitches: number;\n        ipcReceived: number;\n        ipcSent: number;\n        majorPageFault: number;\n        maxRSS: number;\n        minorPageFault: number;\n        sharedMemorySize: number;\n        signalsCount: number;\n        swappedOut: number;\n        systemCPUTime: number;\n        unsharedDataSize: number;\n        unsharedStackSize: number;\n        userCPUTime: number;\n        voluntaryContextSwitches: number;\n      };\n    }\n  }\n}\n",
  "src/api/structures/ISystem.ts": "import { Recordstringstring } from \"./Recordstringstring\";\n\n/**\n * System Information.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type ISystem = {\n  /**\n   * Random Unique ID.\n   *\n   * @title Random Unique ID\n   */\n  uid: number;\n\n  /** `process.argv` */\n  arguments: string[];\n\n  /**\n   * Git commit info.\n   *\n   * @title Git commit info\n   */\n  commit: ISystem.ICommit;\n\n  /** `package.json` */\n  package: ISystem.IPackage;\n\n  /**\n   * Creation time of this server.\n   *\n   * @title Creation time of this server\n   */\n  created_at: string;\n};\nexport namespace ISystem {\n  /** Git commit info. */\n  export type ICommit = {\n    shortHash: string;\n    branch: string;\n    hash: string;\n    subject: string;\n    sanitizedSubject: string;\n    body: string;\n    author: ISystem.ICommit.IUser;\n    committer: ISystem.ICommit.IUser;\n    authored_at: string;\n    committed_at: string;\n    notes?: string;\n    tags: string[];\n  };\n  export namespace ICommit {\n    /** Git user account info. */\n    export type IUser = {\n      name: string;\n      email: string;\n    };\n  }\n\n  /** NPM package info. */\n  export type IPackage = {\n    name: string;\n    version: string;\n    description: string;\n    main?: string;\n    typings?: string;\n    scripts: Recordstringstring;\n    repository: {\n      type: \"git\";\n      url: string;\n    };\n    author: string;\n    license: string;\n    bugs: {\n      url: string;\n    };\n    homepage: string;\n    devDependencies?: Recordstringstring;\n    dependencies: Recordstringstring;\n    publishConfig?: {\n      registry: string;\n    };\n    files?: string[];\n  };\n}\n",
  "src/api/structures/Recordstringstring.ts": "/**\n * Construct a type with a set of properties K of type T\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type Recordstringstring = {\n  [key: string]: string;\n};\n",
  "src/api/structures/IShoppingAdministrator.ts": "import { tags } from \"typia\";\n\nimport { IShoppingMember } from \"./IShoppingMember\";\nimport { IShoppingCustomer } from \"./IShoppingCustomer\";\nimport { IShoppingCitizen } from \"./IShoppingCitizen\";\n\n/**\n * Administrator account.\n *\n * `IShoppingAdministrator` is an entity that embodies a person who manages the\n * shopping mall system, with {@link IShoppingMember membership} joining.\n *\n * For reference, unlike {@link IShoppingCustomer customers} which can\n * participate even without membership joining, administrator must join\n * membership to operate managements. Also, administrator must perform the\n * {@link IShoppingCitizen real-name and mobile authentication}, too.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IShoppingAdministrator = {\n  /**\n   * Primary Key.\n   *\n   * @title Primary Key\n   */\n  id: string & tags.Format<\"uuid\">;\n\n  /**\n   * Creation time of record.\n   *\n   * Another words, the time when the administrator has signed up.\n   *\n   * @title Creation time of record\n   */\n  created_at: string & tags.Format<\"date-time\">;\n};\nexport namespace IShoppingAdministrator {\n  /**\n   * Invert information starting from administrator info.\n   *\n   * Instead of accessing to the administrator information from the\n   * {@link IShoppingCustomer.member} -> {@link IShoppingMember.administrator},\n   * `IShoppingAdministrator.IInvert` starts from the administrator\n   * information and access to the customer, member and\n   * {@link IShoppingCitizen citizen} information inversely.\n   */\n  export type IInvert = {\n    /**\n     * Discriminant for the type of customer.\n     *\n     * @title Discriminant for the type of customer\n     */\n    type: \"administrator\";\n\n    /**\n     * Membership joining information.\n     *\n     * @title Membership joining information\n     */\n    member: IShoppingMember.IInvert;\n\n    /**\n     * Customer, the connection information.\n     *\n     * @title Customer, the connection information\n     */\n    customer: IShoppingCustomer.IInvert;\n\n    /**\n     * Real-name and mobile number authentication information.\n     *\n     * @title Real-name and mobile number authentication information\n     */\n    citizen: IShoppingCitizen;\n\n    /**\n     * Primary Key.\n     *\n     * @title Primary Key\n     */\n    id: string & tags.Format<\"uuid\">;\n\n    /**\n     * Creation time of record.\n     *\n     * Another words, the time when the administrator has signed up.\n     *\n     * @title Creation time of record\n     */\n    created_at: string & tags.Format<\"date-time\">;\n  };\n\n  /** Joining request info. */\n  export type IJoin = {};\n}\n",
  "src/api/structures/IShoppingMember.ts": "import { tags } from \"typia\";\n\nimport { IShoppingCitizen } from \"./IShoppingCitizen\";\nimport { IShoppingSeller } from \"./IShoppingSeller\";\nimport { IShoppingAdministrator } from \"./IShoppingAdministrator\";\nimport { IShoppingMemberEmail } from \"./IShoppingMemberEmail\";\n\n/**\n * Member Account.\n *\n * `IShoppingMember` is an entity that symbolizes the case when a\n * {@link IShoppingCustomer} signs up as a member of this shopping mall system.\n *\n * If a `IShoppingMember` has seller or administrator property. it means that\n * the {@link IShoppingCustomer} has acting as a {@link IShoppingSeller seller} or\n * {@link IShoppingAdministrator administrator} at the same time.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IShoppingMember = {\n  /**\n   * Citizen information.\n   *\n   * Only when has verified as a citizen, with mobile number and real name.\n   *\n   * For reference, if the member has signed up as a seller or administrator,\n   * this citizen information must be.\n   *\n   * @title Citizen information\n   */\n  citizen: null | IShoppingCitizen;\n\n  /**\n   * Seller information.\n   *\n   * If the member also signed up as a seller.\n   *\n   * @title Seller information\n   */\n  seller: null | IShoppingSeller;\n\n  /**\n   * Administrator information.\n   *\n   * If the member also signed up as an administrator.\n   *\n   * @title Administrator information\n   */\n  administrator: null | IShoppingAdministrator;\n\n  /**\n   * Primary Key.\n   *\n   * @title Primary Key\n   */\n  id: string & tags.Format<\"uuid\">;\n\n  /**\n   * Nickname that uniquely identifies the member.\n   *\n   * @title Nickname that uniquely identifies the member\n   */\n  nickname: string;\n\n  /**\n   * List of emails.\n   *\n   * @title List of emails\n   */\n  emails: IShoppingMemberEmail[];\n\n  /**\n   * Creation time of record.\n   *\n   * Another words, the time when the member has signed up.\n   *\n   * @title Creation time of record\n   */\n  created_at: string & tags.Format<\"date-time\">;\n};\nexport namespace IShoppingMember {\n  /**\n   * Invert information of member.\n   *\n   * This invert member information has been designed to be used for another\n   * invert information of sellers and administrators like below.\n   *\n   * - {@link IShoppingSeller.IInvert}\n   * - {@link IShoppingAdministrator.IInvert}\n   */\n  export type IInvert = {\n    /**\n     * Primary Key.\n     *\n     * @title Primary Key\n     */\n    id: string & tags.Format<\"uuid\">;\n\n    /**\n     * Nickname that uniquely identifies the member.\n     *\n     * @title Nickname that uniquely identifies the member\n     */\n    nickname: string;\n\n    /**\n     * List of emails.\n     *\n     * @title List of emails\n     */\n    emails: IShoppingMemberEmail[];\n\n    /**\n     * Creation time of record.\n     *\n     * Another words, the time when the member has signed up.\n     *\n     * @title Creation time of record\n     */\n    created_at: string & tags.Format<\"date-time\">;\n  };\n\n  /** Login request info. */\n  export type ILogin = {\n    /**\n     * Email address of member.\n     *\n     * If the member has multiple email addresses, just use one of them.\n     *\n     * @title Email address of member\n     */\n    email: string & tags.Format<\"email\">;\n\n    /**\n     * Password of the member account.\n     *\n     * @title Password of the member account\n     */\n    password: string;\n  };\n\n  /** Joining request info. */\n  export type IJoin = {\n    /**\n     * Nickname that uniquely identifies the member.\n     *\n     * @title Nickname that uniquely identifies the member\n     */\n    nickname: string;\n\n    /**\n     * Citizen information.\n     *\n     * @title Citizen information\n     */\n    citizen: null | IShoppingCitizen.ICreate;\n\n    /**\n     * Email address of member.\n     *\n     * If the member has multiple email addresses, just use one of them.\n     *\n     * @title Email address of member\n     */\n    email: string & tags.Format<\"email\">;\n\n    /**\n     * Password of the member account.\n     *\n     * @title Password of the member account\n     */\n    password: string;\n  };\n\n  /** Request info of password change. */\n  export type IPasswordChange = {\n    /**\n     * Current password.\n     *\n     * @title Current password\n     */\n    oldbie: string;\n\n    /**\n     * The new password to change.\n     *\n     * @title The new password to change\n     */\n    newbie: string;\n  };\n}\n",
  "src/api/structures/IShoppingMemberEmail.ts": "import { tags } from \"typia\";\n\n/**\n * Email address of member.\n *\n * This shopping mall system allows multiple email addresses to be registered\n * for one {@link IShoppingMember member}. If you don't have to plan such\n * multiple email addresses, just use only one.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IShoppingMemberEmail = {\n  /**\n   * Primary Key.\n   *\n   * @title Primary Key\n   */\n  id: string & tags.Format<\"uuid\">;\n\n  /**\n   * Email address value.\n   *\n   * @title Email address value\n   */\n  value: string & tags.Format<\"email\">;\n\n  /**\n   * Creation time of record.\n   *\n   * @title Creation time of record\n   */\n  created_at: string & tags.Format<\"date-time\">;\n};\n",
  "src/api/structures/IShoppingCustomer.ts": "import { tags } from \"typia\";\n\nimport { IShoppingMember } from \"./IShoppingMember\";\nimport { IShoppingCitizen } from \"./IShoppingCitizen\";\nimport { IShoppingChannel } from \"./IShoppingChannel\";\nimport { IShoppingExternalUser } from \"./IShoppingExternalUser\";\n\n/**\n * Customer information, but not a person but a connection basis.\n *\n * `IShoppingCustomer` is an entity that literally embodies the information of\n * those who participated in the market as customers. By the way, the\n * `IShoppingCustomer` does not mean a person, but a connection basis.\n * Therefore, even if the same person connects to the shopping mall multiple,\n * multiple records are created in `IShoppingCustomer`.\n *\n * The first purpose of this is to track the customer's inflow path in detail,\n * and it is for cases where the same person enters as a non-member,\n * {@link IShoppingCartCommodity puts items in the shopping cart} in advance, and\n * only authenticates their {@link IShoppingCitizen real name} or registers/logs\n * in at the moment of {@link IShoppingOrderPublish payment}. It is the second.\n * Lastly, it is to accurately track the activities that a person performs at\n * the shopping mall in various ways like below.\n *\n * - Same person comes from an {@link IShoppingExternalUser external service}\n * - Same person creates multiple accounts\n * - Same person makes a {@link IShoppingOrderPublish purchase} as a non-member\n *   with only {@link IShoppingCitizen real name authentication}\n * - Same person acts both {@link IShoppingSeller seller} and\n *   {@link IShoppingAdministrator admin} at the same time\n *\n * Therefore, `IShoppingCustomer` can have multiple records with the same\n * {@link IShoppingCitizen}, {@link IShoppingMember}, and\n * {@link IShoppingExternalUser}. Additionally, if a customer signs up for\n * membership after verifying their real name or signs up for our service after\n * being a user of an external service, all related records are changed at once.\n * Therefore, identification and tracking of customers can be done very\n * systematically.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IShoppingCustomer = {\n  /**\n   * Discriminant for the type of customer.\n   *\n   * @title Discriminant for the type of customer\n   */\n  type: \"customer\";\n\n  /**\n   * Membership information.\n   *\n   * If the customer has joined as a member.\n   *\n   * @title Membership information\n   */\n  member: null | IShoppingMember;\n\n  /**\n   * Citizen information.\n   *\n   * If the customer has verified his real name and mobile number.\n   *\n   * @title Citizen information\n   */\n  citizen: null | IShoppingCitizen;\n\n  /**\n   * Primary Key.\n   *\n   * @title Primary Key\n   */\n  id: string & tags.Format<\"uuid\">;\n\n  /**\n   * Belonged channel.\n   *\n   * @title Belonged channel\n   */\n  channel: IShoppingChannel;\n\n  /**\n   * External user information.\n   *\n   * When the customer has come from an external service.\n   *\n   * @title External user information\n   */\n  external_user: null | IShoppingExternalUser;\n\n  /**\n   * Connection address.\n   *\n   * Same with {@link window.location.href} of client.\n   *\n   * @title Connection address\n   */\n  href: string & tags.Format<\"uri\">;\n\n  /**\n   * Referrer address.\n   *\n   * Same with {@link window.document.referrer} of client.\n   *\n   * @title Referrer address\n   */\n  referrer: null | (string & tags.Format<\"uri\">) | (string & tags.MaxLength<0>);\n\n  /**\n   * Connection IP Address.\n   *\n   * @title Connection IP Address\n   */\n  ip: (string & tags.Format<\"ipv4\">) | (string & tags.Format<\"ipv6\">);\n\n  /**\n   * Creation time of the connection record.\n   *\n   * @title Creation time of the connection record\n   */\n  created_at: string & tags.Format<\"date-time\">;\n};\nexport namespace IShoppingCustomer {\n  /**\n   * Inverted customer information.\n   *\n   * This inverted customer information has been designed to be used for\n   * another invert information of sellers and administrators like below.\n   *\n   * - {@link IShoppingSeller.IInvert}\n   * - {@link IShoppingAdministrator.IInvert}\n   */\n  export type IInvert = {\n    /**\n     * Primary Key.\n     *\n     * @title Primary Key\n     */\n    id: string & tags.Format<\"uuid\">;\n\n    /**\n     * Belonged channel.\n     *\n     * @title Belonged channel\n     */\n    channel: IShoppingChannel;\n\n    /**\n     * External user information.\n     *\n     * When the customer has come from an external service.\n     *\n     * @title External user information\n     */\n    external_user: null | IShoppingExternalUser;\n\n    /**\n     * Connection address.\n     *\n     * Same with {@link window.location.href} of client.\n     *\n     * @title Connection address\n     */\n    href: string & tags.Format<\"uri\">;\n\n    /**\n     * Referrer address.\n     *\n     * Same with {@link window.document.referrer} of client.\n     *\n     * @title Referrer address\n     */\n    referrer:\n      | null\n      | (string & tags.Format<\"uri\">)\n      | (string & tags.MaxLength<0>);\n\n    /**\n     * Connection IP Address.\n     *\n     * @title Connection IP Address\n     */\n    ip: (string & tags.Format<\"ipv4\">) | (string & tags.Format<\"ipv6\">);\n\n    /**\n     * Creation time of the connection record.\n     *\n     * @title Creation time of the connection record\n     */\n    created_at: string & tags.Format<\"date-time\">;\n  };\n\n  export type IAuthorized = {\n    setHeaders: {\n      Authorization: string;\n    };\n    token: IShoppingCustomer.IToken;\n\n    /**\n     * Discriminant for the type of customer.\n     *\n     * @title Discriminant for the type of customer\n     */\n    type: \"customer\";\n\n    /**\n     * Membership information.\n     *\n     * If the customer has joined as a member.\n     *\n     * @title Membership information\n     */\n    member: null | IShoppingMember;\n\n    /**\n     * Citizen information.\n     *\n     * If the customer has verified his real name and mobile number.\n     *\n     * @title Citizen information\n     */\n    citizen: null | IShoppingCitizen;\n\n    /**\n     * Primary Key.\n     *\n     * @title Primary Key\n     */\n    id: string & tags.Format<\"uuid\">;\n\n    /**\n     * Belonged channel.\n     *\n     * @title Belonged channel\n     */\n    channel: IShoppingChannel;\n\n    /**\n     * External user information.\n     *\n     * When the customer has come from an external service.\n     *\n     * @title External user information\n     */\n    external_user: null | IShoppingExternalUser;\n\n    /**\n     * Connection address.\n     *\n     * Same with {@link window.location.href} of client.\n     *\n     * @title Connection address\n     */\n    href: string & tags.Format<\"uri\">;\n\n    /**\n     * Referrer address.\n     *\n     * Same with {@link window.document.referrer} of client.\n     *\n     * @title Referrer address\n     */\n    referrer:\n      | null\n      | (string & tags.Format<\"uri\">)\n      | (string & tags.MaxLength<0>);\n\n    /**\n     * Connection IP Address.\n     *\n     * @title Connection IP Address\n     */\n    ip: (string & tags.Format<\"ipv4\">) | (string & tags.Format<\"ipv6\">);\n\n    /**\n     * Creation time of the connection record.\n     *\n     * @title Creation time of the connection record\n     */\n    created_at: string & tags.Format<\"date-time\">;\n  };\n\n  export type IToken = {\n    access: string;\n    refresh: string;\n    expired_at: string & tags.Format<\"date-time\">;\n    refreshable_until: string & tags.Format<\"date-time\">;\n  };\n\n  export type IRefresh = {\n    value: string;\n  };\n\n  export type ICreate = {\n    /**\n     * Belonged channel's {@link IShoppingChannel.code}.\n     *\n     * @title Belonged channel's {@link IShoppingChannel.code}\n     */\n    channel_code: string;\n\n    /**\n     * External user information.\n     *\n     * When the customer has come from an external service.\n     *\n     * @title External user information\n     */\n    external_user: null | IShoppingExternalUser.ICreate;\n\n    /**\n     * Connection address.\n     *\n     * Same with {@link window.location.href} of client.\n     *\n     * @title Connection address\n     */\n    href: string & tags.Format<\"uri\">;\n\n    /**\n     * Referrer address.\n     *\n     * Same with {@link window.document.referrer} of client.\n     *\n     * @title Referrer address\n     */\n    referrer:\n      | null\n      | (string & tags.Format<\"uri\">)\n      | (string & tags.MaxLength<0>);\n\n    /**\n     * Connection IP Address.\n     *\n     * @title Connection IP Address\n     */\n    ip?: null | (string & tags.Format<\"ipv4\">) | (string & tags.Format<\"ipv6\">);\n  };\n}\n",
  "src/api/structures/IShoppingChannel.ts": "import { tags } from \"typia\";\n\nimport { IShoppingChannelCategory } from \"./IShoppingChannelCategory\";\n\n/**\n * Channel information.\n *\n * `IShoppingChannel` is a concept that shapes the distribution channel in the\n * market. Therefore, the difference in the channel in this e-commerce system\n * means that it is another site or application.\n *\n * By the way, if your shopping mall system requires only one channel, then just\n * use only one. This concept is designed to be expandable in the future.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IShoppingChannel = {\n  /**\n   * Primary Key.\n   *\n   * @title Primary Key\n   */\n  id: string & tags.Format<\"uuid\">;\n\n  /**\n   * Creation time of record.\n   *\n   * @title Creation time of record\n   */\n  created_at: string & tags.Format<\"date-time\">;\n\n  /**\n   * Identifier code.\n   *\n   * @title Identifier code\n   */\n  code: string;\n\n  /**\n   * Name of the channel.\n   *\n   * @title Name of the channel\n   */\n  name: string;\n};\nexport namespace IShoppingChannel {\n  /** Creation information of the channel. */\n  export type ICreate = {\n    /**\n     * Identifier code.\n     *\n     * @title Identifier code\n     */\n    code: string;\n\n    /**\n     * Name of the channel.\n     *\n     * @title Name of the channel\n     */\n    name: string;\n  };\n\n  /** Updating information of the channel. */\n  export type IUpdate = {\n    /**\n     * Name of the channel.\n     *\n     * @title Name of the channel\n     */\n    name: string;\n  };\n\n  /** Request of the channels with pagination and searching/sorting options. */\n  export type IRequest = {\n    search?: null | IShoppingChannel.IRequest.ISearch;\n    sort?:\n      | null\n      | (\n          | \"-channel.code\"\n          | \"-channel.name\"\n          | \"-channel.created_at\"\n          | \"+channel.code\"\n          | \"+channel.name\"\n          | \"+channel.created_at\"\n        )[];\n\n    /**\n     * Page number.\n     *\n     * @title Page number\n     */\n    page?: null | (number & tags.Type<\"int32\"> & tags.Minimum<0>);\n\n    /**\n     * Limitation of records per a page.\n     *\n     * @title Limitation of records per a page\n     */\n    limit?: null | (number & tags.Type<\"int32\"> & tags.Minimum<0>);\n  };\n  export namespace IRequest {\n    export type ISearch = {\n      code?: null | string;\n      name?: null | string;\n    };\n  }\n\n  /** Hierarchical channel information with children categories. */\n  export type IHierarchical = {\n    /**\n     * Children categories with hierarchical structure.\n     *\n     * @title Children categories with hierarchical structure\n     */\n    categories: IShoppingChannelCategory.IHierarchical[];\n\n    /**\n     * Primary Key.\n     *\n     * @title Primary Key\n     */\n    id: string & tags.Format<\"uuid\">;\n\n    /**\n     * Creation time of record.\n     *\n     * @title Creation time of record\n     */\n    created_at: string & tags.Format<\"date-time\">;\n\n    /**\n     * Identifier code.\n     *\n     * @title Identifier code\n     */\n    code: string;\n\n    /**\n     * Name of the channel.\n     *\n     * @title Name of the channel\n     */\n    name: string;\n  };\n}\n",
  "src/api/structures/IShoppingExternalUser.ts": "import { tags } from \"typia\";\n\nimport { IShoppingCitizen } from \"./IShoppingCitizen\";\n\n/**\n * External user information.\n *\n * `IShoppingExternalUser` is an entity dsigned for when this system needs to\n * connect with external services and welcome their users as\n * {@link IShoppingCustomer customers} of this service.\n *\n * For reference, customers who connect from an external service must have this\n * record, and the external service user is identified through the two\n * attributes {@link application} and {@link uid}. If a customer connected from an\n * external service completes {@link IShoppingCitizen real-name authentication}\n * from this service, each time the external service user reconnects to this\n * service and issues a new customer authentication token, real-name\n * authentication begins with completed.\n *\n * And {@link password} is the password issued to the user by the external\n * service system (the so-called permanent user authentication token), and is\n * never the actual user password. However, for customers who entered the same\n * application and uid as the current external system user, this is to determine\n * whether to view this as a correct external system user or a violation.\n *\n * In addition, additional information received from external services can be\n * recorded in the data field in JSON format.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IShoppingExternalUser = {\n  /**\n   * Primary Key.\n   *\n   * @title Primary Key\n   */\n  id: string & tags.Format<\"uuid\">;\n\n  /**\n   * Citizen activation info.\n   *\n   * @title Citizen activation info\n   */\n  citizen: null | IShoppingCitizen;\n\n  /**\n   * Creation time of record.\n   *\n   * Another word, first time when the external user connected.\n   *\n   * @title Creation time of record\n   */\n  created_at: string & tags.Format<\"date-time\">;\n\n  /**\n   * Identifier key of external user from the external system.\n   *\n   * @title Identifier key of external user from the external system\n   */\n  uid: string;\n\n  /**\n   * Identifier code of the external service.\n   *\n   * It can be same with {@link IShoppingChannel.code} in common.\n   *\n   * @title Identifier code of the external service\n   */\n  application: string;\n\n  /**\n   * Nickname of external user in the external system.\n   *\n   * @title Nickname of external user in the external system\n   */\n  nickname: string;\n\n  /** Additional information about external user from the external system. */\n  data: any;\n};\nexport namespace IShoppingExternalUser {\n  /** Creation information of external user. */\n  export type ICreate = {\n    /**\n     * Citizen activation info.\n     *\n     * @title Citizen activation info\n     */\n    citizen: null | IShoppingCitizen.ICreate;\n\n    /**\n     * Identifier code of the external service.\n     *\n     * It can be same with {@link IShoppingChannel.code} in common.\n     *\n     * @title Identifier code of the external service\n     */\n    application: string;\n\n    /**\n     * Identifier key of external user from the external system.\n     *\n     * @title Identifier key of external user from the external system\n     */\n    uid: string;\n\n    /**\n     * Nickname of external user in the external system.\n     *\n     * @title Nickname of external user in the external system\n     */\n    nickname: string;\n\n    /**\n     * Password of external user from the external system.\n     *\n     * This is a password issued to the user by an external service, and is\n     * by no means the actual user password. However, for\n     * {@link IShoppingCustomer customers} who entered the same application\n     * and code as the current external system user, this is to determine\n     * whether to view this as a correct external system user or a\n     * violation.\n     *\n     * @title Password of external user from the external system\n     */\n    password: string;\n\n    /** Additional information about external user from the external system. */\n    data: any;\n  };\n}\n",
  "src/api/structures/IShoppingCitizen.ts": "import { tags } from \"typia\";\n\n/**\n * Citizen verification information.\n *\n * `IShoppingCitizen` is an entity that records the user's {@link name real name}\n * and {@link mobile} input information.\n *\n * For reference, in South Korea, real name authentication is required for\n * e-commerce participants, so the name attribute is important. However, the\n * situation is different overseas, so in reality, mobile attributes are the\n * most important, and identification of individual person is also done based on\n * this mobile.\n *\n * Of course, real name and mobile phone authentication information are\n * encrypted and stored.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IShoppingCitizen = {\n  /**\n   * Primary Key.\n   *\n   * @title Primary Key\n   */\n  id: string & tags.Format<\"uuid\">;\n\n  /**\n   * Creation time of record.\n   *\n   * @title Creation time of record\n   */\n  created_at: string & tags.Format<\"date-time\">;\n\n  /**\n   * Mobile number.\n   *\n   * @title Mobile number\n   */\n  mobile: string &\n    tags.Pattern<\"^[0-9]*$\"> &\n    tags.JsonSchemaPlugin<{\n      \"x-wrtn-payment-order-mobile\": true;\n    }>;\n\n  /**\n   * Real name, or equivalent nickname.\n   *\n   * @title Real name, or equivalent nickname\n   */\n  name: string &\n    tags.JsonSchemaPlugin<{\n      \"x-wrtn-payment-order-citizen\": true;\n    }>;\n};\nexport namespace IShoppingCitizen {\n  export namespace IRequest {\n    export type ISearch = {\n      mobile?: null | (string & tags.Pattern<\"^[0-9]*$\">);\n      name?: null | string;\n    };\n  }\n\n  /** Creation information of citizen verification. */\n  export type ICreate = {\n    /**\n     * Mobile number.\n     *\n     * @title Mobile number\n     */\n    mobile: string &\n      tags.Pattern<\"^[0-9]*$\"> &\n      tags.JsonSchemaPlugin<{\n        \"x-wrtn-payment-order-mobile\": true;\n      }>;\n\n    /**\n     * Real name, or equivalent nickname.\n     *\n     * @title Real name, or equivalent nickname\n     */\n    name: string &\n      tags.JsonSchemaPlugin<{\n        \"x-wrtn-payment-order-citizen\": true;\n      }>;\n  };\n}\n",
  "src/api/structures/IShoppingCoupon.ts": "import { tags } from \"typia\";\n\nimport { IShoppingAdministrator } from \"./IShoppingAdministrator\";\nimport { IShoppingSeller } from \"./IShoppingSeller\";\nimport { IShoppingCouponInventory } from \"./IShoppingCouponInventory\";\nimport { IShoppingCouponSectionCriteria } from \"./IShoppingCouponSectionCriteria\";\nimport { IShoppingCouponSellerCriteria } from \"./IShoppingCouponSellerCriteria\";\nimport { IShoppingCouponSaleCriteria } from \"./IShoppingCouponSaleCriteria\";\nimport { IShoppingCouponFunnelCriteria } from \"./IShoppingCouponFunnelCriteria\";\nimport { IShoppingCouponDiscount } from \"./IShoppingCouponDiscount\";\nimport { IShoppingCouponRestriction } from \"./IShoppingCouponRestriction\";\n\n/**\n * Discount coupon.\n *\n * `IShoppingCoupon` is an entity that symbolizes discount coupons at a shopping\n * mall.\n *\n * Note that, `IShoppingCoupon` only contains specification information about\n * discount coupons. Please keep in mind that this is a different concept from\n * {@link IShoppingCouponTicket}, which refers to the issuance of a discount\n * coupon, or {@link IShoppingCouponTicketPayment}, which refers to its payment.\n *\n * Additionally, discount coupons are applied on an order-by-order basis, but\n * each has its own unique restrictions. For example, a coupon with\n * {@link IShoppingCouponSellerCriteria} may or may not be used only for\n * {@link IShoppingSale} of listings registered by the {@link IShoppingSeller}.\n * Also, there are restrictions such as\n * {@link IShoppingCouponDiscount.threshold minimum amount restrictions} for\n * using discount coupons and\n * {@link IShoppingCouponDiscount.limit maximum discount amount limits}.\n *\n * In addition, you can set whether to issue discount coupons publicly or give\n * them only to people who know the specific issuing code. In addition, there\n * are restrictions such as issued discount coupons having an\n * {@link IShoppingCouponRestriction.expired_at expiration date} or being issued\n * only to customers who came in through a\n * {@link IShoppingCouponFunnelCriteria specific funnel}.\n *\n * For more information, please refer to the properties below and the subsidiary\n * entities described later.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IShoppingCoupon = {\n  /**\n   * Primary Key.\n   *\n   * @title Primary Key\n   */\n  id: string & tags.Format<\"uuid\">;\n\n  /**\n   * Designer who've made the coupon.\n   *\n   * @title Designer who've made the coupon\n   */\n  designer: IShoppingAdministrator | IShoppingSeller;\n\n  /**\n   * Inventory information.\n   *\n   * @title Inventory information\n   */\n  inventory: IShoppingCouponInventory;\n\n  /**\n   * List of criteria information.\n   *\n   * @title List of criteria information\n   */\n  criterias: (\n    | IShoppingCouponSectionCriteria\n    | IShoppingCouponSellerCriteria\n    | IShoppingCouponSaleCriteria\n    | IShoppingCouponFunnelCriteria\n  )[];\n\n  /**\n   * Discount information.\n   *\n   * @title Discount information\n   */\n  discount: IShoppingCouponDiscount.IAmount | IShoppingCouponDiscount.IPercent;\n\n  /**\n   * Restriction information.\n   *\n   * @title Restriction information\n   */\n  restriction: IShoppingCouponRestriction;\n\n  /**\n   * Representative name of the coupon.\n   *\n   * @title Representative name of the coupon\n   */\n  name: string;\n\n  /**\n   * Opening time of the coupon.\n   *\n   * @title Opening time of the coupon\n   */\n  opened_at: null | (string & tags.Format<\"date-time\">);\n\n  /**\n   * Closing time of the coupon.\n   *\n   * Tickets cannot be issued after this time.\n   *\n   * However, previously issued tickets can still be used until their\n   * expiration date.\n   *\n   * @title Closing time of the coupon\n   */\n  closed_at: null | (string & tags.Format<\"date-time\">);\n\n  /**\n   * Creation tie of the record.\n   *\n   * @title Creation tie of the record\n   */\n  created_at: string & tags.Format<\"date-time\">;\n};\nexport namespace IShoppingCoupon {\n  /** Creation information of the coupon. */\n  export type ICreate = {\n    /**\n     * Discount information.\n     *\n     * @title Discount information\n     */\n    discount:\n      | IShoppingCouponDiscount.IAmount\n      | IShoppingCouponDiscount.IPercent;\n\n    /**\n     * Restriction information.\n     *\n     * @title Restriction information\n     */\n    restriction: IShoppingCouponRestriction;\n\n    /**\n     * List of criteria information.\n     *\n     * @title List of criteria information\n     */\n    criterias: (\n      | IShoppingCouponSectionCriteria.ICreate\n      | IShoppingCouponSellerCriteria.ICreate\n      | IShoppingCouponSaleCriteria.ICreate\n      | IShoppingCouponFunnelCriteria.ICreate\n    )[];\n\n    /**\n     * Disposable codes for the coupon.\n     *\n     * @title Disposable codes for the coupon\n     */\n    disposable_codes: string[];\n\n    /**\n     * Representative name of the coupon.\n     *\n     * @title Representative name of the coupon\n     */\n    name: string;\n\n    /**\n     * Opening time of the coupon.\n     *\n     * @title Opening time of the coupon\n     */\n    opened_at: null | (string & tags.Format<\"date-time\">);\n\n    /**\n     * Closing time of the coupon.\n     *\n     * Tickets cannot be issued after this time.\n     *\n     * However, previously issued tickets can still be used until their\n     * expiration date.\n     *\n     * @title Closing time of the coupon\n     */\n    closed_at: null | (string & tags.Format<\"date-time\">);\n  };\n\n  export type IRequest = {\n    search?: null | IShoppingCoupon.IRequest.ISearch;\n    sort?:\n      | null\n      | (\n          | \"-coupon.name\"\n          | \"-coupon.unit\"\n          | \"-coupon.value\"\n          | \"-coupon.created_at\"\n          | \"-coupon.opened_at\"\n          | \"-coupon.closed_at\"\n          | \"+coupon.name\"\n          | \"+coupon.unit\"\n          | \"+coupon.value\"\n          | \"+coupon.created_at\"\n          | \"+coupon.opened_at\"\n          | \"+coupon.closed_at\"\n        )[];\n\n    /**\n     * Page number.\n     *\n     * @title Page number\n     */\n    page?: null | (number & tags.Type<\"int32\"> & tags.Minimum<0>);\n\n    /**\n     * Limitation of records per a page.\n     *\n     * @title Limitation of records per a page\n     */\n    limit?: null | (number & tags.Type<\"int32\"> & tags.Minimum<0>);\n  };\n  export namespace IRequest {\n    export type ISearch = {\n      name?: null | string;\n    };\n  }\n}\n",
  "src/api/structures/IShoppingSeller.ts": "import { tags } from \"typia\";\n\nimport { IShoppingMember } from \"./IShoppingMember\";\nimport { IShoppingCitizen } from \"./IShoppingCitizen\";\nimport { IShoppingCustomer } from \"./IShoppingCustomer\";\n\n/**\n * Seller information.\n *\n * `IShoppingSeller` is an entity that embodies a person who registers\n * {@link IShoppingSale sales} to operate selling activities, with\n * {@link IShoppingMember membership} joining.\n *\n * For reference, unlike {@link IShoppingCustomer customers} which can\n * participate even without membership joining, seller must join membership to\n * operate sales. Also, seller must do the\n * {@link IShoppingCitizen real-name and mobile authentication}, too.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IShoppingSeller = {\n  /**\n   * Primary Key.\n   *\n   * @title Primary Key\n   */\n  id: string & tags.Format<\"uuid\">;\n\n  /**\n   * Creation tmie of record.\n   *\n   * Another words, the time when the seller has signed up.\n   *\n   * @title Creation tmie of record\n   */\n  created_at: string & tags.Format<\"date-time\">;\n};\nexport namespace IShoppingSeller {\n  /** Summary of seller information. */\n  export type ISummary = {\n    /**\n     * Discriminant for the type of seller.\n     *\n     * @title Discriminant for the type of seller\n     */\n    type: \"seller\";\n\n    /**\n     * Membership joining information.\n     *\n     * @title Membership joining information\n     */\n    member: IShoppingMember.IInvert;\n\n    /**\n     * Real-name and mobile number authentication information.\n     *\n     * @title Real-name and mobile number authentication information\n     */\n    citizen: IShoppingCitizen;\n\n    /**\n     * Primary Key.\n     *\n     * @title Primary Key\n     */\n    id: string & tags.Format<\"uuid\">;\n\n    /**\n     * Creation tmie of record.\n     *\n     * Another words, the time when the seller has signed up.\n     *\n     * @title Creation tmie of record\n     */\n    created_at: string & tags.Format<\"date-time\">;\n  };\n\n  /**\n   * Invert information starting from seller info.\n   *\n   * Instead of accessing to the seller information from the\n   * {@link IShoppingCustomer.member} -> {@link IShoppingMember.seller},\n   * `IShoppingSeller.IInvert` starts from the seller information and access\n   * to the customer, member and {@link IShoppingCitizen citizen} information\n   * inversely.\n   */\n  export type IInvert = {\n    /**\n     * Discriminant for the type of seller.\n     *\n     * @title Discriminant for the type of seller\n     */\n    type: \"seller\";\n\n    /**\n     * Membership joining information.\n     *\n     * @title Membership joining information\n     */\n    member: IShoppingMember.IInvert;\n\n    /**\n     * Customer, the connection information.\n     *\n     * @title Customer, the connection information\n     */\n    customer: IShoppingCustomer.IInvert;\n\n    /**\n     * Real-name and mobile number authentication information.\n     *\n     * @title Real-name and mobile number authentication information\n     */\n    citizen: IShoppingCitizen;\n\n    /**\n     * Primary Key.\n     *\n     * @title Primary Key\n     */\n    id: string & tags.Format<\"uuid\">;\n\n    /**\n     * Creation tmie of record.\n     *\n     * Another words, the time when the seller has signed up.\n     *\n     * @title Creation tmie of record\n     */\n    created_at: string & tags.Format<\"date-time\">;\n  };\n\n  export namespace IRequest {\n    export type ISearch = {\n      id?: null | (string & tags.Format<\"uuid\">);\n      mobile?: null | (string & tags.Pattern<\"^[0-9]*$\">);\n      name?: null | string;\n      email?: null | (string & tags.Format<\"email\">);\n      nickname?: null | string;\n    };\n  }\n\n  export type IJoin = {};\n}\n",
  "src/api/structures/IShoppingCouponInventory.ts": "import { tags } from \"typia\";\n\n/**\n * Inventory information of the coupon.\n *\n * If a {@link IShoppingCoupon coupon} has been designed with limited inventory,\n * this `IShoppingCouponInventory` structure represents the remaining inventory\n * information.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IShoppingCouponInventory = {\n  /**\n   * Remaining volume for everyone.\n   *\n   * If there is a limit to the quantity issued, it becomes impossible to\n   * issue tickets exceeding this value.\n   *\n   * In other words, the concept of N coupons being issued on a first-come,\n   * first-served basis is created.\n   *\n   * @title Remaining volume for everyone\n   */\n  volume: null | (number & tags.Type<\"int32\"> & tags.Minimum<0>);\n\n  /**\n   * Remaining volume per citizen.\n   *\n   * As a limit to the total amount of issuance per person, it is common to\n   * assign 1 to limit duplicate issuance to the same citizen, or to use the\n   * `nul`` value to set no limit.\n   *\n   * Of course, by assigning a value of N, the total amount issued to the same\n   * citizen can be limited.\n   *\n   * @title Remaining volume per citizen\n   */\n  volume_per_citizen: null | (number & tags.Type<\"int32\"> & tags.Minimum<0>);\n};\n",
  "src/api/structures/IShoppingCouponSectionCriteria.ts": "import { tags } from \"typia\";\n\nimport { IShoppingSection } from \"./IShoppingSection\";\n\n/**\n * Conditions for sections of discount coupons.\n *\n * `IShoppingCouponSectionCriteria` is a subtype entity of\n * {@link IShoppingCouponCriteriaBase} and is used when setting conditions for a\n * specific {@link IShoppingSection section}.\n *\n * If the {@link direction} value is \"include\", the coupon can only be used for\n * the target {@link sections}. Conversely, if it is \"exclude\", the coupon cannot\n * be used.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IShoppingCouponSectionCriteria = {\n  /**\n   * Target sections to include or exclude.\n   *\n   * @title Target sections to include or exclude\n   */\n  sections: IShoppingSection[] & tags.MinItems<1>;\n\n  /**\n   * Descrimanator type.\n   *\n   * @title Descrimanator type\n   */\n  type: \"section\";\n\n  /**\n   * Direction of the criteria.\n   *\n   * @title Direction of the criteria\n   */\n  direction: \"include\" | \"exclude\";\n};\nexport namespace IShoppingCouponSectionCriteria {\n  /** Creation information of the section criteria. */\n  export type ICreate = {\n    /**\n     * List of target section's {@link IShoppingSection.code}s.\n     *\n     * @title List of target section's {@link IShoppingSection.code}s\n     */\n    section_codes: string[] & tags.MinItems<1>;\n    type: \"section\";\n    direction: \"include\" | \"exclude\";\n  };\n}\n",
  "src/api/structures/IShoppingSection.ts": "import { tags } from \"typia\";\n\n/**\n * Section information.\n *\n * `IShoppingSection` is a concept that refers to the spatial information of the\n * market.\n *\n * If we compare the section mentioned here to the offline market, it means a\n * spatially separated area within the store, such as the \"fruit corner\" or\n * \"butcher corner\". Therefore, in the {@link IShoppingSale sale} entity, it is\n * not possible to classify multiple sections simultaneously, but only one\n * section can be classified.\n *\n * By the way, if your shopping mall system requires only one section, then just\n * use only one. This concept is designed to be expandable in the future.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IShoppingSection = {\n  /**\n   * Primary Key.\n   *\n   * @title Primary Key\n   */\n  id: string & tags.Format<\"uuid\">;\n\n  /**\n   * Identifier code.\n   *\n   * @title Identifier code\n   */\n  code: string;\n\n  /**\n   * Representative name of the section.\n   *\n   * @title Representative name of the section\n   */\n  name: string;\n\n  /**\n   * Creation time of record.\n   *\n   * @title Creation time of record\n   */\n  created_at: string & tags.Format<\"date-time\">;\n};\nexport namespace IShoppingSection {\n  /** Creation information of the section. */\n  export type ICreate = {\n    /**\n     * Identifier code.\n     *\n     * @title Identifier code\n     */\n    code: string;\n\n    /**\n     * Representative name of the section.\n     *\n     * @title Representative name of the section\n     */\n    name: string;\n  };\n\n  /** Updating information of the section. */\n  export type IUpdate = {\n    /**\n     * Representative name of the section.\n     *\n     * @title Representative name of the section\n     */\n    name: string;\n  };\n\n  /** Request of the sections with pagination and searching/sorting options. */\n  export type IRequest = {\n    search?: null | IShoppingSection.IRequest.ISearch;\n    sort?:\n      | null\n      | (\n          | \"-section.code\"\n          | \"-section.name\"\n          | \"-section.created_at\"\n          | \"+section.code\"\n          | \"+section.name\"\n          | \"+section.created_at\"\n        )[];\n\n    /**\n     * Page number.\n     *\n     * @title Page number\n     */\n    page?: null | (number & tags.Type<\"int32\"> & tags.Minimum<0>);\n\n    /**\n     * Limitation of records per a page.\n     *\n     * @title Limitation of records per a page\n     */\n    limit?: null | (number & tags.Type<\"int32\"> & tags.Minimum<0>);\n  };\n  export namespace IRequest {\n    export type ISearch = {\n      code?: null | string;\n      name?: null | string;\n    };\n  }\n}\n",
  "src/api/structures/IShoppingCouponSellerCriteria.ts": "import { tags } from \"typia\";\n\nimport { IShoppingSeller } from \"./IShoppingSeller\";\n\n/**\n * Conditions for sellers of discount coupons.\n *\n * `IShoppingCouponSellerCriteria` is a subtype entity of\n * {@link IShoppingCouponCriteriaBase} and is used when setting conditions for a\n * specific {@link IShoppingSeller seller}.\n *\n * If the {@link direction} value is \"include\", the coupon can only be used for\n * the target {@link sellers}. Conversely, if it is \"exclude\", the coupon cannot\n * be used.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IShoppingCouponSellerCriteria = {\n  /**\n   * Target sellers to include or exclude.\n   *\n   * @title Target sellers to include or exclude\n   */\n  sellers: IShoppingSeller[] & tags.MinItems<1>;\n\n  /**\n   * Descrimanator type.\n   *\n   * @title Descrimanator type\n   */\n  type: \"seller\";\n\n  /**\n   * Direction of the criteria.\n   *\n   * @title Direction of the criteria\n   */\n  direction: \"include\" | \"exclude\";\n};\nexport namespace IShoppingCouponSellerCriteria {\n  /** Creation information of the seller criteria. */\n  export type ICreate = {\n    /**\n     * List of target seller's {@link IShoppingSeller.id}s.\n     *\n     * @title List of target seller's {@link IShoppingSeller.id}s\n     */\n    seller_ids: (string & tags.Format<\"uuid\">)[] & tags.MinItems<1>;\n    type: \"seller\";\n    direction: \"include\" | \"exclude\";\n  };\n}\n",
  "src/api/structures/IShoppingCouponSaleCriteria.ts": "import { tags } from \"typia\";\n\nimport { IShoppingSale } from \"./IShoppingSale\";\n\n/**\n * Conditions for sales of discount coupons.\n *\n * `IShoppingCouponSaleCriteria` is a subtype entity of\n * {@link IShoppingCouponCriteriaBase} and is used when setting conditions for a\n * specific {@link IShoppingSale sale}.\n *\n * If the {@link direction} value is \"include\", the coupon can only be used for\n * the target {@link sales}. Conversely, if it is \"exclude\", the coupon cannot be\n * used.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IShoppingCouponSaleCriteria = {\n  /**\n   * Target sales to include or exclude.\n   *\n   * @title Target sales to include or exclude\n   */\n  sales: IShoppingSale.ISummary[] & tags.MinItems<1>;\n\n  /**\n   * Descrimanator type.\n   *\n   * @title Descrimanator type\n   */\n  type: \"sale\";\n\n  /**\n   * Direction of the criteria.\n   *\n   * @title Direction of the criteria\n   */\n  direction: \"include\" | \"exclude\";\n};\nexport namespace IShoppingCouponSaleCriteria {\n  /** Creation information of the sale criteria. */\n  export type ICreate = {\n    /**\n     * List of target sale's {@link IShoppingSale.id}s.\n     *\n     * @title List of target sale's {@link IShoppingSale.id}s\n     */\n    sale_ids: (string & tags.Format<\"uuid\">)[] & tags.MinItems<1>;\n    type: \"sale\";\n    direction: \"include\" | \"exclude\";\n  };\n}\n",
  "src/api/structures/IShoppingSale.ts": "import { tags } from \"typia\";\n\nimport { IShoppingSection } from \"./IShoppingSection\";\nimport { IShoppingSeller } from \"./IShoppingSeller\";\nimport { IShoppingSaleContent } from \"./IShoppingSaleContent\";\nimport { IShoppingChannelCategory } from \"./IShoppingChannelCategory\";\nimport { IShoppingSaleUnit } from \"./IShoppingSaleUnit\";\nimport { IShoppingSalePriceRange } from \"./IShoppingSalePriceRange\";\nimport { IShoppingPrice } from \"./IShoppingPrice\";\nimport { IShoppingSaleReview } from \"./IShoppingSaleReview\";\n\n/**\n * Seller sales products.\n *\n * `IShoppingSale` is an entity that embodies \"product sales\" (sales)\n * information registered by the {@link ISoppingSeller seller}. And the main\n * information of the sale is recorded in the sub {@link IShoppingSaleSnapshot},\n * not in the main `IShoppingSale`. When a seller changes a previously\n * registered item, the existing `IShoppingSale` record is not changed, but a\n * new {@link IShoppingSaleSnapshot snapshot} record be created.\n *\n * This is to preserve the {@link IShoppingCustomer customer}'s\n * {@link IShoppingOrder purchase history} flawlessly after the customer\n * purchases a specific item, even if the seller changes the components or price\n * of the item. It is also intended to support sellers in so-called A/B testing,\n * which involves changing components or prices and measuring the performance in\n * each case.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IShoppingSale = {\n  /**\n   * Belonged section.\n   *\n   * @title Belonged section\n   */\n  section: IShoppingSection;\n\n  /**\n   * Seller who has registered the sale.\n   *\n   * @title Seller who has registered the sale\n   */\n  seller: IShoppingSeller.IInvert;\n\n  /**\n   * Primary Key of Sale.\n   *\n   * @title Primary Key of Sale\n   */\n  id: string & tags.Format<\"uuid\">;\n\n  /**\n   * Primary Key of Snapshot.\n   *\n   * @title Primary Key of Snapshot\n   */\n  snapshot_id: string & tags.Format<\"uuid\">;\n\n  /**\n   * Whether the snapshot is the latest one or not.\n   *\n   * @title Whether the snapshot is the latest one or not\n   */\n  latest: boolean;\n\n  /**\n   * Description and image content describing the sale.\n   *\n   * @title Description and image content describing the sale\n   */\n  content: IShoppingSaleContent;\n\n  /**\n   * List of categories.\n   *\n   * Which categories the sale is registered to.\n   *\n   * @title List of categories\n   */\n  categories: IShoppingChannelCategory.IInvert[];\n\n  /**\n   * List of search tags.\n   *\n   * @title List of search tags\n   */\n  tags: string[];\n\n  /**\n   * List of units.\n   *\n   * Records about individual product composition information that are sold in\n   * the sale. Each {@link IShoppingSaleUnit unit} record has configurable\n   * {@link IShoppingSaleUnitOption options},\n   * {@link IShoppingSaleUnitOptionCandidate candidate} values for each option,\n   * and {@link IShoppingSaleUnitStock final stocks} determined by selecting\n   * every candidate values of each option.\n   *\n   * @title List of units\n   */\n  units: IShoppingSaleUnit[] & tags.MinItems<1>;\n\n  /**\n   * Creation time of the record.\n   *\n   * Note that, this property is different with {@link opened_at}, which means\n   * the timepoint of the sale is opened.\n   *\n   * @title Creation time of the record\n   */\n  created_at: string & tags.Format<\"date-time\">;\n\n  /**\n   * Last updated time of the record.\n   *\n   * In another words, creation time of the last snapshot.\n   *\n   * @title Last updated time of the record\n   */\n  updated_at: string & tags.Format<\"date-time\">;\n\n  /**\n   * Paused time of the sale.\n   *\n   * The sale is paused by the seller, for some reason.\n   *\n   * {@link IShoppingCustomer Customers} can still see the sale on the both\n   * list and detail pages, but the sale has a warning label \"The sale is\n   * paused by the seller\".\n   *\n   * @title Paused time of the sale\n   */\n  paused_at: null | (string & tags.Format<\"date-time\">);\n\n  /**\n   * Suspended time of the sale.\n   *\n   * The sale is suspended by the seller, for some reason.\n   *\n   * {@link IShoppingCustomer Customers} cannot see the sale on the both list\n   * and detail pages. It is almost same with soft delettion, but there's a\n   * little bit difference that the owner {@link IShoppingSeller seller} can\n   * still see the sale and resume it.\n   *\n   * Of course, the {@link IShoppingCustomer customers} who have already\n   * purchased the sale can still see the sale on the\n   * {@link IShoppingOrder order} page.\n   *\n   * @title Suspended time of the sale\n   */\n  suspended_at: null | (string & tags.Format<\"date-time\">);\n\n  /**\n   * Opening time of the sale.\n   *\n   * @title Opening time of the sale\n   */\n  opened_at: null | (string & tags.Format<\"date-time\">);\n\n  /**\n   * Closing time of the sale.\n   *\n   * If this value is `null`, the sale be continued forever.\n   *\n   * @title Closing time of the sale\n   */\n  closed_at: null | (string & tags.Format<\"date-time\">);\n};\nexport namespace IShoppingSale {\n  /**\n   * Summarized information of sale.\n   *\n   * This summarized information being used for pagination.\n   */\n  export type ISummary = {\n    /**\n     * Belonged section.\n     *\n     * @title Belonged section\n     */\n    section: IShoppingSection;\n\n    /**\n     * Seller who has registered the sale.\n     *\n     * @title Seller who has registered the sale\n     */\n    seller: IShoppingSeller.ISummary;\n\n    /**\n     * Price range of the unit.\n     *\n     * @title Price range of the unit\n     */\n    price_range: IShoppingSalePriceRange;\n\n    /**\n     * Primary Key of Sale.\n     *\n     * @title Primary Key of Sale\n     */\n    id: string & tags.Format<\"uuid\">;\n\n    /**\n     * Primary Key of Snapshot.\n     *\n     * @title Primary Key of Snapshot\n     */\n    snapshot_id: string & tags.Format<\"uuid\">;\n\n    /**\n     * Whether the snapshot is the latest one or not.\n     *\n     * @title Whether the snapshot is the latest one or not\n     */\n    latest: boolean;\n\n    /**\n     * Description and image content describing the sale.\n     *\n     * @title Description and image content describing the sale\n     */\n    content: IShoppingSaleContent.IInvert;\n\n    /**\n     * List of categories.\n     *\n     * Which categories the sale is registered to.\n     *\n     * @title List of categories\n     */\n    categories: IShoppingChannelCategory.IInvert[];\n\n    /**\n     * List of search tags.\n     *\n     * @title List of search tags\n     */\n    tags: string[];\n\n    /**\n     * List of units.\n     *\n     * Records about individual product composition information that are\n     * sold in the sale. Each {@link IShoppingSaleUnit unit} record has\n     * configurable {@link IShoppingSaleUnitOption options},\n     * {@link IShoppingSaleUnitOptionCandidate candidate} values for each\n     * option, and {@link IShoppingSaleUnitStock final stocks} determined by\n     * selecting every candidate values of each option.\n     *\n     * @title List of units\n     */\n    units: IShoppingSaleUnit.ISummary[] & tags.MinItems<1>;\n\n    /**\n     * Creation time of the record.\n     *\n     * Note that, this property is different with {@link opened_at}, which\n     * means the timepoint of the sale is opened.\n     *\n     * @title Creation time of the record\n     */\n    created_at: string & tags.Format<\"date-time\">;\n\n    /**\n     * Last updated time of the record.\n     *\n     * In another words, creation time of the last snapshot.\n     *\n     * @title Last updated time of the record\n     */\n    updated_at: string & tags.Format<\"date-time\">;\n\n    /**\n     * Paused time of the sale.\n     *\n     * The sale is paused by the seller, for some reason.\n     *\n     * {@link IShoppingCustomer Customers} can still see the sale on the both\n     * list and detail pages, but the sale has a warning label \"The sale is\n     * paused by the seller\".\n     *\n     * @title Paused time of the sale\n     */\n    paused_at: null | (string & tags.Format<\"date-time\">);\n\n    /**\n     * Suspended time of the sale.\n     *\n     * The sale is suspended by the seller, for some reason.\n     *\n     * {@link IShoppingCustomer Customers} cannot see the sale on the both\n     * list and detail pages. It is almost same with soft delettion, but\n     * there's a little bit difference that the owner\n     * {@link IShoppingSeller seller} can still see the sale and resume it.\n     *\n     * Of course, the {@link IShoppingCustomer customers} who have already\n     * purchased the sale can still see the sale on the\n     * {@link IShoppingOrder order} page.\n     *\n     * @title Suspended time of the sale\n     */\n    suspended_at: null | (string & tags.Format<\"date-time\">);\n\n    /**\n     * Opening time of the sale.\n     *\n     * @title Opening time of the sale\n     */\n    opened_at: null | (string & tags.Format<\"date-time\">);\n\n    /**\n     * Closing time of the sale.\n     *\n     * If this value is `null`, the sale be continued forever.\n     *\n     * @title Closing time of the sale\n     */\n    closed_at: null | (string & tags.Format<\"date-time\">);\n  };\n\n  /**\n   * Request of summarized sales with pagination and searching/sorting\n   * options.\n   */\n  export type IRequest = {\n    /**\n     * Sorting conditions.\n     *\n     * @title Sorting conditions\n     */\n    sort?:\n      | null\n      | (\n          | \"-seller.created_at\"\n          | \"-seller.goods.payments.real\"\n          | \"-seller.goods.publish_count\"\n          | \"-seller.reviews.average\"\n          | \"-seller.reviews.count\"\n          | \"-goods.publish_count\"\n          | \"-goods.payments.real\"\n          | \"-reviews.average\"\n          | \"-reviews.count\"\n          | \"-sale.created_at\"\n          | \"-sale.updated_at\"\n          | \"-sale.opened_at\"\n          | \"-sale.closed_at\"\n          | \"-sale.content.title\"\n          | \"-sale.price_range.lowest.real\"\n          | \"-sale.price_range.highest.real\"\n          | \"+seller.created_at\"\n          | \"+seller.goods.payments.real\"\n          | \"+seller.goods.publish_count\"\n          | \"+seller.reviews.average\"\n          | \"+seller.reviews.count\"\n          | \"+goods.publish_count\"\n          | \"+goods.payments.real\"\n          | \"+reviews.average\"\n          | \"+reviews.count\"\n          | \"+sale.created_at\"\n          | \"+sale.updated_at\"\n          | \"+sale.opened_at\"\n          | \"+sale.closed_at\"\n          | \"+sale.content.title\"\n          | \"+sale.price_range.lowest.real\"\n          | \"+sale.price_range.highest.real\"\n        )[];\n\n    /**\n     * Page number.\n     *\n     * @title Page number\n     */\n    page?: null | (number & tags.Type<\"int32\"> & tags.Minimum<0>);\n\n    /**\n     * Limitation of records per a page.\n     *\n     * @title Limitation of records per a page\n     */\n    limit?: null | (number & tags.Type<\"int32\"> & tags.Minimum<0>);\n  };\n  export namespace IRequest {\n    export type ISearch = {\n      show_paused?: null | boolean;\n      show_suspended?: null | \"only\" | boolean;\n      title?: null | string;\n      content?: null | string;\n      title_or_content?: null | string;\n      price?: null | IShoppingPrice.ISearch;\n      review?: null | IShoppingSaleReview.IInvertSearch;\n      section_codes?: null | string[];\n      channel_category_ids?: null | string[];\n      tags?: null | string[];\n      seller?: null | IShoppingSeller.IRequest.ISearch;\n    };\n  }\n\n  /** Creation information of sale. */\n  export type ICreate = {\n    /**\n     * Belonged section's {@link IShoppingSection.code}.\n     *\n     * @title Belonged section's {@link IShoppingSection.code}\n     */\n    section_code: string;\n\n    /**\n     * Initial status of the sale.\n     *\n     * `null` or `undefined`: No restriction `paused`: Starts with\n     * {@link ITimestamps.paused_at paused} status `suspended`: Starts with\n     * {@link ITimestamps.suspended_at suspended} status\n     *\n     * @title Initial status of the sale\n     */\n    status?: null | \"paused\" | \"suspended\";\n\n    /**\n     * Opening time of the sale.\n     *\n     * @title Opening time of the sale\n     */\n    opened_at: null | (string & tags.Format<\"date-time\">);\n\n    /**\n     * Closing time of the sale.\n     *\n     * If this value is `null`, the sale be continued forever.\n     *\n     * @title Closing time of the sale\n     */\n    closed_at: null | (string & tags.Format<\"date-time\">);\n\n    /**\n     * Description and image content describing the sale.\n     *\n     * @title Description and image content describing the sale\n     */\n    content: IShoppingSaleContent.ICreate;\n\n    /**\n     * List of units.\n     *\n     * @title List of units\n     */\n    units: IShoppingSaleUnit.ICreate[] & tags.MinItems<1>;\n\n    /**\n     * List of search tags.\n     *\n     * @title List of search tags\n     */\n    tags: string[];\n\n    /**\n     * List of target categories' {@link IShoppingChannelCategory.code}s.\n     *\n     * If empty, it means all categories of the channel is listing the sale.\n     *\n     * @title List of target categories' {@link IShoppingChannelCategory.code}s\n     */\n    category_codes: string[];\n  };\n\n  /** Update opening time information of sale. */\n  export type IUpdateOpeningTime = {\n    /**\n     * Opening time of the sale.\n     *\n     * @title Opening time of the sale\n     */\n    opened_at: null | (string & tags.Format<\"date-time\">);\n\n    /**\n     * Closing time of the sale.\n     *\n     * If this value is `null`, the sale be continued forever.\n     *\n     * @title Closing time of the sale\n     */\n    closed_at: null | (string & tags.Format<\"date-time\">);\n  };\n}\n",
  "src/api/structures/IShoppingSalePriceRange.ts": "import { IShoppingPrice } from \"./IShoppingPrice\";\n\n/** @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe */\nexport type IShoppingSalePriceRange = {\n  lowest: IShoppingPrice;\n  highest: IShoppingPrice;\n};\n",
  "src/api/structures/IShoppingPrice.ts": "import { tags } from \"typia\";\n\n/**\n * Shopping price interface.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IShoppingPrice = {\n  /**\n   * Nominal price.\n   *\n   * This is not {@link real real price} to pay, but just a nominal price to\n   * show. If this value is greater than the {@link real real price}, it would\n   * be shown like {@link IShoppingSeller seller} is giving a discount.\n   *\n   * @title Nominal price\n   */\n  nominal: number & tags.Minimum<0>;\n\n  /**\n   * Real price to pay.\n   *\n   * @title Real price to pay\n   */\n  real: number & tags.Minimum<0>;\n};\nexport namespace IShoppingPrice {\n  export type ISearch = {\n    minimum?: null | number;\n    maximum?: null | number;\n  };\n}\n",
  "src/api/structures/IShoppingSaleContent.ts": "import { tags } from \"typia\";\n\nimport { IAttachmentFile } from \"./IAttachmentFile\";\n\n/**\n * Content information of sale snapshot.\n *\n * `IShoppingSaleContent` is an entity embodies the description contents of\n * {@link IShoppingSale}.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IShoppingSaleContent = {\n  /**\n   * Primary Key.\n   *\n   * @title Primary Key\n   */\n  id: string & tags.Format<\"uuid\">;\n\n  /**\n   * Title of the content.\n   *\n   * @title Title of the content\n   */\n  title: string;\n\n  /**\n   * Format of the body content.\n   *\n   * Same meaning with file extension like `html`, `md`, and `txt`.\n   *\n   * @title Format of the body content\n   */\n  format: \"html\" | \"md\" | \"txt\";\n\n  /**\n   * The main body content.\n   *\n   * Format follows the {@link format}, and default is `md` (markdown).\n   *\n   * @title The main body content\n   */\n  body: string;\n\n  /**\n   * List of attached files.\n   *\n   * @title List of attached files\n   */\n  files: IAttachmentFile[];\n\n  /**\n   * List of thumbnails.\n   *\n   * @title List of thumbnails\n   */\n  thumbnails: IAttachmentFile[];\n};\nexport namespace IShoppingSaleContent {\n  export type IInvert = {\n    id: string & tags.Format<\"uuid\">;\n    title: string;\n    thumbnails: IAttachmentFile[];\n  };\n\n  export type ICreate = {\n    title: string;\n    format: \"html\" | \"md\" | \"txt\";\n    body: string;\n    files: IAttachmentFile.ICreate[];\n    thumbnails: IAttachmentFile.ICreate[];\n  };\n}\n",
  "src/api/structures/IAttachmentFile.ts": "import { tags } from \"typia\";\n\n/**\n * Attachment File.\n *\n * Every attachment files that are managed in current system.\n *\n * For reference, it is possible to omit one of file {@link name} or\n * {@link extension} like `.gitignore` or `README` case, but not possible to omit\n * both of them.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IAttachmentFile = {\n  /**\n   * Primary Key.\n   *\n   * @title Primary Key\n   */\n  id: string & tags.Format<\"uuid\">;\n\n  /**\n   * Creation time of attachment file.\n   *\n   * @title Creation time of attachment file\n   */\n  created_at: string & tags.Format<\"date-time\">;\n\n  /**\n   * File name, except extension.\n   *\n   * If there's file `.gitignore`, then its name is an empty string.\n   *\n   * @title File name, except extension\n   */\n  name: string & tags.MaxLength<255>;\n\n  /**\n   * Extension.\n   *\n   * Possible to omit like `README` case.\n   *\n   * @title Extension\n   */\n  extension: null | (string & tags.MinLength<1> & tags.MaxLength<8>);\n\n  /**\n   * URL path of the real file.\n   *\n   * @title URL path of the real file\n   */\n  url: string & tags.Format<\"uri\"> & tags.ContentMediaType<\"image/*\">;\n};\nexport namespace IAttachmentFile {\n  export type ICreate = {\n    /**\n     * File name, except extension.\n     *\n     * If there's file `.gitignore`, then its name is an empty string.\n     *\n     * @title File name, except extension\n     */\n    name: string & tags.MaxLength<255>;\n\n    /**\n     * Extension.\n     *\n     * Possible to omit like `README` case.\n     *\n     * @title Extension\n     */\n    extension: null | (string & tags.MinLength<1> & tags.MaxLength<8>);\n\n    /**\n     * URL path of the real file.\n     *\n     * @title URL path of the real file\n     */\n    url: string & tags.Format<\"uri\"> & tags.ContentMediaType<\"image/*\">;\n  };\n}\n",
  "src/api/structures/IShoppingChannelCategory.ts": "import { tags } from \"typia\";\n\n/**\n * Category of channel.\n *\n * `IShoppingChannelCategory` is a concept that refers to classification\n * categories within a specific {@link IShoppingChannel channel}, and is exactly\n * the same as the concept commonly referred to as \"category\" in shopping\n * malls.\n *\n * And `IShoppingChannelCategory` is different with {@link IShoppingSection}.\n * {@link IShoppingSection} refers to a \"corner\" that is independent spatial\n * information in the offline market, which cannot simultaneously classified in\n * a {@link IShoppingSale sale}. Besides, `IShoppingChannelCategory` can be\n * classified into multiple categories in a sale simultaneously.\n *\n * Product | Section (corner) | Categories\n * ---------|------------------|----------------------------------- Beef |\n * Butcher corner | Frozen food, Meat, Favorite food Grape | Fruit corner |\n * Fresh food, Favorite food\n *\n * In addition, as `IShoppingChannelCategory` has 1:N self recursive\n * relationship, it is possible to express below hierarchical structures. Thus,\n * each channel can set their own category classification as they want.\n *\n * - Food > Meat > Frozen\n * - Electronics > Notebook > 15 inches\n * - Miscellaneous > Wallet\n *\n * Furthermore, `IShoppingChannelCategory` is designed to merge between\n * themselves, so there is no burden to edit the category at any time.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IShoppingChannelCategory = {\n  /**\n   * Parent category info.\n   *\n   * @title Parent category info\n   */\n  parent: null | IShoppingChannelCategory.IInvert;\n\n  /**\n   * List of children categories with hierarchical structure.\n   *\n   * @title List of children categories with hierarchical structure\n   */\n  children: IShoppingChannelCategory.IHierarchical[];\n\n  /**\n   * Primary Key.\n   *\n   * @title Primary Key\n   */\n  id: string & tags.Format<\"uuid\">;\n\n  /**\n   * Identifier code of the category.\n   *\n   * The code must be unique in the channel.\n   *\n   * @title Identifier code of the category\n   */\n  code: string;\n\n  /**\n   * Parent category's ID.\n   *\n   * @title Parent category's ID\n   */\n  parent_id: null | (string & tags.Format<\"uuid\">);\n\n  /**\n   * Representative name of the category.\n   *\n   * The name must be unique within the parent category. If no parent exists,\n   * then the name must be unique within the channel between no parent\n   * categories.\n   *\n   * @title Representative name of the category\n   */\n  name: string;\n\n  /**\n   * Creation time of record.\n   *\n   * @title Creation time of record\n   */\n  created_at: string & tags.Format<\"date-time\">;\n};\nexport namespace IShoppingChannelCategory {\n  /** Invert category information with parent category. */\n  export type IInvert = {\n    /**\n     * Parent category info with recursive structure.\n     *\n     * If no parent exists, then be `null`.\n     *\n     * @title Parent category info with recursive structure\n     */\n    parent: null | IShoppingChannelCategory.IInvert;\n\n    /**\n     * Primary Key.\n     *\n     * @title Primary Key\n     */\n    id: string & tags.Format<\"uuid\">;\n\n    /**\n     * Identifier code of the category.\n     *\n     * The code must be unique in the channel.\n     *\n     * @title Identifier code of the category\n     */\n    code: string;\n\n    /**\n     * Parent category's ID.\n     *\n     * @title Parent category's ID\n     */\n    parent_id: null | (string & tags.Format<\"uuid\">);\n\n    /**\n     * Representative name of the category.\n     *\n     * The name must be unique within the parent category. If no parent\n     * exists, then the name must be unique within the channel between no\n     * parent categories.\n     *\n     * @title Representative name of the category\n     */\n    name: string;\n\n    /**\n     * Creation time of record.\n     *\n     * @title Creation time of record\n     */\n    created_at: string & tags.Format<\"date-time\">;\n  };\n\n  /** Hierarchical category information with children categories. */\n  export type IHierarchical = {\n    /**\n     * List of children categories with hierarchical structure.\n     *\n     * @title List of children categories with hierarchical structure\n     */\n    children: IShoppingChannelCategory.IHierarchical[];\n\n    /**\n     * Primary Key.\n     *\n     * @title Primary Key\n     */\n    id: string & tags.Format<\"uuid\">;\n\n    /**\n     * Identifier code of the category.\n     *\n     * The code must be unique in the channel.\n     *\n     * @title Identifier code of the category\n     */\n    code: string;\n\n    /**\n     * Parent category's ID.\n     *\n     * @title Parent category's ID\n     */\n    parent_id: null | (string & tags.Format<\"uuid\">);\n\n    /**\n     * Representative name of the category.\n     *\n     * The name must be unique within the parent category. If no parent\n     * exists, then the name must be unique within the channel between no\n     * parent categories.\n     *\n     * @title Representative name of the category\n     */\n    name: string;\n\n    /**\n     * Creation time of record.\n     *\n     * @title Creation time of record\n     */\n    created_at: string & tags.Format<\"date-time\">;\n  };\n\n  /** Creation information of the category. */\n  export type ICreate = {\n    /**\n     * Parent category's ID.\n     *\n     * @title Parent category's ID\n     */\n    parent_id: null | (string & tags.Format<\"uuid\">);\n\n    /**\n     * Identifier code of the category.\n     *\n     * The code must be unique in the channel.\n     *\n     * @title Identifier code of the category\n     */\n    code: string;\n\n    /**\n     * Representative name of the category.\n     *\n     * The name must be unique within the parent category. If no parent\n     * exists, then the name must be unique within the channel between no\n     * parent categories.\n     *\n     * @title Representative name of the category\n     */\n    name: string;\n  };\n}\n",
  "src/api/structures/IShoppingSaleUnit.ts": "import { tags } from \"typia\";\n\nimport { IShoppingSaleUnitSelectableOption } from \"./IShoppingSaleUnitSelectableOption\";\nimport { IShoppingSaleUnitDescriptiveOption } from \"./IShoppingSaleUnitDescriptiveOption\";\nimport { IShoppingSaleUnitStock } from \"./IShoppingSaleUnitStock\";\nimport { IShoppingSalePriceRange } from \"./IShoppingSalePriceRange\";\n\n/**\n * Product composition information handled in the sale.\n *\n * `IShoppingSaleUnit` is an entity that embodies the \"individual product\"\n * information handled in the {@link IShoppingSale sale}.\n *\n * For reference, the reason why `IShoppingSaleUnit` is separated from\n * {@link IShoppingSaleSnapshot} by an algebraic relationship of 1: N is because\n * there are some cases where multiple products are sold in one listing. This is\n * the case with so-called \"bundled products\".\n *\n * - Bundle from regular product (Mackbook Set)\n *\n *   - Main Body\n *   - Keyboard\n *   - Mouse\n *   - Apple Care (Free A/S Voucher)\n *\n * And again, `IShoppingSaleUnit` does not in itself refer to the\n * {@link IShoppingSaleUnitStock final stock} that the\n * {@link IShoppingCustomer customer} will {@link IShoppingOrder purchase}. The\n * final stock can be found only after selecting all given\n * {@link IShoppingSaleUnitOption options} and their\n * {@link IShoppingSaleUnitOptionCandidate candidate values}.\n *\n * For example, even if you buy a Macbook, the final stocks are determined only\n * after selecting all the options (CPU / RAM / SSD), etc.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IShoppingSaleUnit = {\n  /**\n   * List of options.\n   *\n   * @title List of options\n   */\n  options: (\n    | IShoppingSaleUnitSelectableOption\n    | IShoppingSaleUnitDescriptiveOption\n  )[];\n\n  /**\n   * List of final stocks.\n   *\n   * @title List of final stocks\n   */\n  stocks: IShoppingSaleUnitStock[] & tags.MinItems<1>;\n\n  /**\n   * Primary Key.\n   *\n   * @title Primary Key\n   */\n  id: string & tags.Format<\"uuid\">;\n\n  /**\n   * Representative name of the unit.\n   *\n   * @title Representative name of the unit\n   */\n  name: string;\n\n  /**\n   * Whether the unit is primary or not.\n   *\n   * Just a labeling value.\n   *\n   * @title Whether the unit is primary or not\n   */\n  primary: boolean;\n\n  /**\n   * Whether the unit is required or not.\n   *\n   * When the unit is required, the customer must select the unit. If do not\n   * select, customer can't buy it.\n   *\n   * For example, if there's a sale \"Macbook Set\" and one of the unit is the\n   * \"Main Body\", is it possible to buy the \"Macbook Set\" without the \"Main\n   * Body\" unit? This property is for that case.\n   *\n   * @title Whether the unit is required or not\n   */\n  required: boolean;\n};\nexport namespace IShoppingSaleUnit {\n  export type ISummary = {\n    price_range: IShoppingSalePriceRange;\n\n    /**\n     * Primary Key.\n     *\n     * @title Primary Key\n     */\n    id: string & tags.Format<\"uuid\">;\n\n    /**\n     * Representative name of the unit.\n     *\n     * @title Representative name of the unit\n     */\n    name: string;\n\n    /**\n     * Whether the unit is primary or not.\n     *\n     * Just a labeling value.\n     *\n     * @title Whether the unit is primary or not\n     */\n    primary: boolean;\n\n    /**\n     * Whether the unit is required or not.\n     *\n     * When the unit is required, the customer must select the unit. If do\n     * not select, customer can't buy it.\n     *\n     * For example, if there's a sale \"Macbook Set\" and one of the unit is\n     * the \"Main Body\", is it possible to buy the \"Macbook Set\" without the\n     * \"Main Body\" unit? This property is for that case.\n     *\n     * @title Whether the unit is required or not\n     */\n    required: boolean;\n  };\n\n  export type IInvert = {\n    /**\n     * List of final stocks.\n     *\n     * @title List of final stocks\n     */\n    stocks: IShoppingSaleUnitStock.IInvert[] & tags.MinItems<1>;\n\n    /**\n     * Primary Key.\n     *\n     * @title Primary Key\n     */\n    id: string & tags.Format<\"uuid\">;\n\n    /**\n     * Representative name of the unit.\n     *\n     * @title Representative name of the unit\n     */\n    name: string;\n\n    /**\n     * Whether the unit is primary or not.\n     *\n     * Just a labeling value.\n     *\n     * @title Whether the unit is primary or not\n     */\n    primary: boolean;\n\n    /**\n     * Whether the unit is required or not.\n     *\n     * When the unit is required, the customer must select the unit. If do\n     * not select, customer can't buy it.\n     *\n     * For example, if there's a sale \"Macbook Set\" and one of the unit is\n     * the \"Main Body\", is it possible to buy the \"Macbook Set\" without the\n     * \"Main Body\" unit? This property is for that case.\n     *\n     * @title Whether the unit is required or not\n     */\n    required: boolean;\n  };\n\n  /** Creation information of sale unit. */\n  export type ICreate = {\n    /**\n     * List of options.\n     *\n     * @title List of options\n     */\n    options: (\n      | IShoppingSaleUnitSelectableOption.ICreate\n      | IShoppingSaleUnitDescriptiveOption.ICreate\n    )[];\n\n    /**\n     * List of final stocks.\n     *\n     * @title List of final stocks\n     */\n    stocks: IShoppingSaleUnitStock.ICreate[] & tags.MinItems<1>;\n\n    /**\n     * Representative name of the unit.\n     *\n     * @title Representative name of the unit\n     */\n    name: string;\n\n    /**\n     * Whether the unit is primary or not.\n     *\n     * Just a labeling value.\n     *\n     * @title Whether the unit is primary or not\n     */\n    primary: boolean;\n\n    /**\n     * Whether the unit is required or not.\n     *\n     * When the unit is required, the customer must select the unit. If do\n     * not select, customer can't buy it.\n     *\n     * For example, if there's a sale \"Macbook Set\" and one of the unit is\n     * the \"Main Body\", is it possible to buy the \"Macbook Set\" without the\n     * \"Main Body\" unit? This property is for that case.\n     *\n     * @title Whether the unit is required or not\n     */\n    required: boolean;\n  };\n}\n",
  "src/api/structures/IShoppingCouponFunnelCriteria.ts": "import { tags } from \"typia\";\n\n/**\n * Limit the funnel of discount coupons.\n *\n * `ishoppingcouponfunnelcriteria` is a subtype entity of\n * {@link IShoppingCouponCriteria}, and is used when you want to issue or exclude\n * discount coupons only to {@link IShoppingCustomer customers} who came from a\n * specific path.\n *\n * And funnel restrictions are possible in 3 ways: The first is\n * {@link IShoppingCustomer.referrer}, and by parsing\n * {@link IShoppingCustomer.href}, which records the customer's access address,\n * restrictions can be made in units of specific URLs or variables.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IShoppingCouponFunnelCriteria = {\n  /**\n   * List of target funnels.\n   *\n   * @title List of target funnels\n   */\n  funnels: (\n    | IShoppingCouponFunnelCriteria.IValueFunnel\n    | IShoppingCouponFunnelCriteria.IVariableFunnel\n  )[] &\n    tags.MinItems<1>;\n\n  /**\n   * Descrimanator type.\n   *\n   * @title Descrimanator type\n   */\n  type: \"funnel\";\n\n  /**\n   * Direction of the criteria.\n   *\n   * @title Direction of the criteria\n   */\n  direction: \"include\" | \"exclude\";\n};\nexport namespace IShoppingCouponFunnelCriteria {\n  /** Kind of funnel restriction by a value. */\n  export type IValueFunnel = {\n    /**\n     * Kind of funnel restriction.\n     *\n     * @title Kind of funnel restriction\n     */\n    kind: \"url\" | \"referrer\";\n\n    /**\n     * Target value.\n     *\n     * @title Target value\n     */\n    value: string;\n  };\n\n  /** Kind of funnel restriction by a variable. */\n  export type IVariableFunnel = {\n    /**\n     * Kind of funnel restriction.\n     *\n     * @title Kind of funnel restriction\n     */\n    kind: \"variable\";\n\n    /**\n     * Target variable's key.\n     *\n     * @title Target variable's key\n     */\n    key: string;\n\n    /**\n     * Target variable's value.\n     *\n     * @title Target variable's value\n     */\n    value: string;\n  };\n\n  /** Creation information of the funnel criteria. */\n  export type ICreate = {\n    /**\n     * List of target funnels.\n     *\n     * @title List of target funnels\n     */\n    funnels: (\n      | IShoppingCouponFunnelCriteria.IValueFunnel\n      | IShoppingCouponFunnelCriteria.IVariableFunnel\n    )[] &\n      tags.MinItems<1>;\n    type: \"funnel\";\n    direction: \"include\" | \"exclude\";\n  };\n}\n",
  "src/api/structures/IShoppingCouponDiscount.ts": "import { tags } from \"typia\";\n\nexport namespace IShoppingCouponDiscount {\n  /** Discount information with amount unit. */\n  export type IAmount = {\n    /**\n     * Discount unit as amount.\n     *\n     * It means the order price would be discounted by the amount value.\n     *\n     * @title Discount unit as amount\n     */\n    unit: \"amount\";\n\n    /**\n     * Discount value as amount.\n     *\n     * @title Discount value as amount\n     */\n    value: number;\n\n    /**\n     * Minimum purchase amount for discount.\n     *\n     * When setting this value, discount coupons cannot be applied to order\n     * totals that are less than this value.\n     *\n     * @title Minimum purchase amount for discount\n     */\n    threshold: null | (number & tags.Minimum<0>);\n\n    /**\n     * Maximum amount available for discount.\n     *\n     * When this value is set, no further discount will be given no matter\n     * how much you order. This property would be meaningful only when the\n     * {@link multiplicative} is `true`.\n     *\n     * @title Maximum amount available for discount\n     */\n    limit: null | number;\n\n    /**\n     * Multiplicative or not.\n     *\n     * If this property is `true`, the discount value would be multiplied to\n     * the {@link IShoppingCartCommodity.volume} or\n     * {@link IShoppingOrderGood.volume} value. Also, in that case, the\n     * {@link limit} property would be meaningful.\n     *\n     * @title Multiplicative or not\n     */\n    multiplicative: boolean;\n  };\n\n  /** Discount information with percent unit. */\n  export type IPercent = {\n    /**\n     * Discount unit as percent.\n     *\n     * It means the order price would be discounted by the percent value.\n     *\n     * @title Discount unit as percent\n     */\n    unit: \"percent\";\n\n    /**\n     * Discount value as percent.\n     *\n     * @title Discount value as percent\n     */\n    value: number & tags.Minimum<0> & tags.Maximum<100>;\n\n    /**\n     * Minimum purchase amount for discount.\n     *\n     * When setting this value, discount coupons cannot be applied to order\n     * totals that are less than this value.\n     *\n     * @title Minimum purchase amount for discount\n     */\n    threshold: null | (number & tags.Minimum<0>);\n\n    /**\n     * Maximum amount available for discount.\n     *\n     * When this value is set, no further discount will be given no matter\n     * how much you order.\n     *\n     * @title Maximum amount available for discount\n     */\n    limit: null | number;\n  };\n}\n",
  "src/api/structures/IShoppingCouponRestriction.ts": "import { tags } from \"typia\";\n\n/**\n * Restriction information of the coupon.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IShoppingCouponRestriction = {\n  /**\n   * Access level of coupon.\n   *\n   * - Public: possible to find from public API\n   * - Private: unable to find from public API\n   *\n   *   - Arbitrarily assigned by the seller or administrator\n   *   - Issued from one-time link\n   *\n   * @title Access level of coupon\n   */\n  access: \"public\" | \"private\";\n\n  /**\n   * Exclusivity or not.\n   *\n   * An exclusive discount coupon refers to a discount coupon that has an\n   * exclusive relationship with other discount coupons and can only be used\n   * alone. That is, when an exclusive discount coupon is used, no other\n   * discount coupon can be used for the same {@link IShoppingOrder order} or\n   * {@link IShoppingOrderGood good}.\n   *\n   * Please note that this exclusive attribute is a very different concept\n   * from multiplicative, which means whether the same coupon can be\n   * multiplied and applied to multiple coupons of the same order, so please\n   * do not confuse them.\n   *\n   * @title Exclusivity or not\n   */\n  exclusive: boolean;\n\n  /**\n   * Limited quantity issued.\n   *\n   * If there is a limit to the quantity issued, it becomes impossible to\n   * issue tickets exceeding this value.\n   *\n   * In other words, the concept of N coupons being issued on a first-come,\n   * first-served basis is created.\n   *\n   * @title Limited quantity issued\n   */\n  volume: null | (number & tags.Type<\"int32\"> & tags.Minimum<0>);\n\n  /**\n   * Limited quantity issued per person.\n   *\n   * As a limit to the total amount of issuance per person, it is common to\n   * assign 1 to limit duplicate issuance to the same citizen, or to use the\n   * NULL value to set no limit.\n   *\n   * Of course, by assigning a value of N, the total amount issued to the same\n   * citizen can be limited.\n   *\n   * @title Limited quantity issued per person\n   */\n  volume_per_citizen: null | (number & tags.Type<\"int32\"> & tags.Minimum<0>);\n\n  /**\n   * Expiration day(s) value.\n   *\n   * The concept of expiring N days after a discount coupon ticket is issued.\n   *\n   * Therefore, customers must use the ticket within N days, if possible, from\n   * the time it is issued.\n   *\n   * @title Expiration day(s) value\n   */\n  expired_in: null | (number & tags.Type<\"int32\"> & tags.Minimum<0>);\n\n  /**\n   * Expiration date.\n   *\n   * A concept that expires after YYYY-MM-DD after a discount coupon ticket is\n   * issued.\n   *\n   * Double restrictions are possible with expired_in, of which the one with\n   * the shorter expiration date is used.\n   *\n   * @title Expiration date\n   */\n  expired_at: null | (string & tags.Format<\"date-time\">);\n};\n",
  "src/api/structures/IPageIShoppingCoupon.ts": "import { IPage } from \"./IPage\";\nimport { IShoppingCoupon } from \"./IShoppingCoupon\";\n\n/**\n * A page.\n *\n * Collection of records with pagination indformation.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IPageIShoppingCoupon = {\n  /**\n   * Page information.\n   *\n   * @title Page information\n   */\n  pagination: IPage.IPagination;\n\n  /**\n   * List of records.\n   *\n   * @title List of records\n   */\n  data: IShoppingCoupon[];\n};\n",
  "src/api/structures/IPage.ts": "import { tags } from \"typia\";\n\nexport namespace IPage {\n  /** Page information. */\n  export type IPagination = {\n    /**\n     * Current page number.\n     *\n     * @title Current page number\n     */\n    current: number & tags.Type<\"int32\"> & tags.Minimum<0>;\n\n    /**\n     * Limitation of records per a page.\n     *\n     * @title Limitation of records per a page\n     */\n    limit: number & tags.Type<\"int32\"> & tags.Minimum<0>;\n\n    /**\n     * Total records in the database.\n     *\n     * @title Total records in the database\n     */\n    records: number & tags.Type<\"int32\"> & tags.Minimum<0>;\n\n    /**\n     * Total pages.\n     *\n     * Equal to {@link records} / {@link limit} with ceiling.\n     *\n     * @title Total pages\n     */\n    pages: number & tags.Type<\"int32\"> & tags.Minimum<0>;\n  };\n\n  /** Page request data */\n  export type IRequest = {\n    /**\n     * Page number.\n     *\n     * @title Page number\n     */\n    page?: null | (number & tags.Type<\"int32\"> & tags.Minimum<0>);\n\n    /**\n     * Limitation of records per a page.\n     *\n     * @title Limitation of records per a page\n     */\n    limit?: null | (number & tags.Type<\"int32\"> & tags.Minimum<0>);\n  };\n}\n",
  "src/api/structures/IPageIShoppingDeposit.ts": "import { IPage } from \"./IPage\";\nimport { IShoppingDeposit } from \"./IShoppingDeposit\";\n\n/**\n * A page.\n *\n * Collection of records with pagination indformation.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IPageIShoppingDeposit = {\n  /**\n   * Page information.\n   *\n   * @title Page information\n   */\n  pagination: IPage.IPagination;\n\n  /**\n   * List of records.\n   *\n   * @title List of records\n   */\n  data: IShoppingDeposit[];\n};\n",
  "src/api/structures/IShoppingDeposit.ts": "import { tags } from \"typia\";\n\n/** @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe */\nexport type IShoppingDeposit = {\n  id: string & tags.Format<\"uuid\">;\n  created_at: string & tags.Format<\"date-time\">;\n  code: string;\n  source: string;\n  direction: -1 | 1;\n};\nexport namespace IShoppingDeposit {\n  export type IRequest = {\n    search?: null | IShoppingDeposit.IRequest.ISearch;\n    sort?:\n      | null\n      | (\n          | \"-deposit.source\"\n          | \"-deposit.code\"\n          | \"-deposit.direction\"\n          | \"+deposit.source\"\n          | \"+deposit.code\"\n          | \"+deposit.direction\"\n        )[];\n\n    /**\n     * Page number.\n     *\n     * @title Page number\n     */\n    page?: null | (number & tags.Type<\"int32\"> & tags.Minimum<0>);\n\n    /**\n     * Limitation of records per a page.\n     *\n     * @title Limitation of records per a page\n     */\n    limit?: null | (number & tags.Type<\"int32\"> & tags.Minimum<0>);\n  };\n  export namespace IRequest {\n    export type ISearch = {\n      source?: null | string;\n      code?: null | string;\n      direction?: null | -1 | 1;\n    };\n  }\n\n  export type ICreate = {\n    code: string;\n    source: string;\n    direction: -1 | 1;\n  };\n}\n",
  "src/api/structures/IPageIShoppingMileage.ts": "import { IPage } from \"./IPage\";\nimport { IShoppingMileage } from \"./IShoppingMileage\";\n\n/**\n * A page.\n *\n * Collection of records with pagination indformation.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IPageIShoppingMileage = {\n  /**\n   * Page information.\n   *\n   * @title Page information\n   */\n  pagination: IPage.IPagination;\n\n  /**\n   * List of records.\n   *\n   * @title List of records\n   */\n  data: IShoppingMileage[];\n};\n",
  "src/api/structures/IShoppingMileage.ts": "import { tags } from \"typia\";\n\n/** @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe */\nexport type IShoppingMileage = {\n  id: string & tags.Format<\"uuid\">;\n  value: null | number;\n  created_at: string & tags.Format<\"date-time\">;\n  code: string;\n  source: string;\n  direction: -1 | 1;\n};\nexport namespace IShoppingMileage {\n  export type IRequest = {\n    search?: null | IShoppingMileage.IRequest.ISearch;\n    sort?:\n      | null\n      | (\n          | \"-mileage.source\"\n          | \"-mileage.code\"\n          | \"-mileage.direction\"\n          | \"+mileage.source\"\n          | \"+mileage.code\"\n          | \"+mileage.direction\"\n        )[];\n\n    /**\n     * Page number.\n     *\n     * @title Page number\n     */\n    page?: null | (number & tags.Type<\"int32\"> & tags.Minimum<0>);\n\n    /**\n     * Limitation of records per a page.\n     *\n     * @title Limitation of records per a page\n     */\n    limit?: null | (number & tags.Type<\"int32\"> & tags.Minimum<0>);\n  };\n  export namespace IRequest {\n    export type ISearch = {\n      source?: null | string;\n      code?: null | string;\n      direction?: null | -1 | 1;\n    };\n  }\n\n  export type ICreate = {\n    code: string;\n    source: string;\n    direction: -1 | 1;\n    value: null | number;\n  };\n}\n",
  "src/api/structures/IPageIShoppingMileageDonation.ts": "import { IPage } from \"./IPage\";\nimport { IShoppingMileageDonation } from \"./IShoppingMileageDonation\";\n\n/**\n * A page.\n *\n * Collection of records with pagination indformation.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IPageIShoppingMileageDonation = {\n  /**\n   * Page information.\n   *\n   * @title Page information\n   */\n  pagination: IPage.IPagination;\n\n  /**\n   * List of records.\n   *\n   * @title List of records\n   */\n  data: IShoppingMileageDonation[];\n};\n",
  "src/api/structures/IShoppingMileageDonation.ts": "import { tags } from \"typia\";\n\nimport { IShoppingAdministrator } from \"./IShoppingAdministrator\";\nimport { IShoppingCitizen } from \"./IShoppingCitizen\";\n\n/** @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe */\nexport type IShoppingMileageDonation = {\n  id: string & tags.Format<\"uuid\">;\n  administrator: IShoppingAdministrator.IInvert;\n  citizen: IShoppingCitizen;\n  value: number;\n  reason: string;\n  created_at: string & tags.Format<\"date-time\">;\n};\nexport namespace IShoppingMileageDonation {\n  export type IRequest = {\n    search?: null | IShoppingMileageDonation.IRequest.ISearch;\n    sort?:\n      | null\n      | (\n          | \"-donation.created_at\"\n          | \"-donation.value\"\n          | \"-donation.reason\"\n          | \"+donation.created_at\"\n          | \"+donation.value\"\n          | \"+donation.reason\"\n        )[];\n\n    /**\n     * Page number.\n     *\n     * @title Page number\n     */\n    page?: null | (number & tags.Type<\"int32\"> & tags.Minimum<0>);\n\n    /**\n     * Limitation of records per a page.\n     *\n     * @title Limitation of records per a page\n     */\n    limit?: null | (number & tags.Type<\"int32\"> & tags.Minimum<0>);\n  };\n  export namespace IRequest {\n    export type ISearch = {\n      citizen?: null | IShoppingCitizen.IRequest.ISearch;\n      minimum?: null | (number & tags.Minimum<0>);\n      maximum?: null | (number & tags.Minimum<0>);\n      from?: null | (string & tags.Format<\"date-time\">);\n      to?: null | (string & tags.Format<\"date-time\">);\n    };\n  }\n\n  export type ICreate = {\n    citizen_id: string & tags.Format<\"uuid\">;\n    value: number;\n    reason: string;\n  };\n}\n",
  "src/api/structures/IPageIShoppingOrder.ts": "import { IPage } from \"./IPage\";\nimport { IShoppingOrder } from \"./IShoppingOrder\";\n\n/**\n * A page.\n *\n * Collection of records with pagination indformation.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IPageIShoppingOrder = {\n  /**\n   * Page information.\n   *\n   * @title Page information\n   */\n  pagination: IPage.IPagination;\n\n  /**\n   * List of records.\n   *\n   * @title List of records\n   */\n  data: IShoppingOrder[];\n};\n",
  "src/api/structures/IShoppingOrder.ts": "import { tags } from \"typia\";\n\nimport { IShoppingCustomer } from \"./IShoppingCustomer\";\nimport { IShoppingOrderGood } from \"./IShoppingOrderGood\";\nimport { IShoppingOrderPrice } from \"./IShoppingOrderPrice\";\nimport { IShoppingOrderPublish } from \"./IShoppingOrderPublish\";\nimport { IShoppingSale } from \"./IShoppingSale\";\n\n/**\n * Order application information.\n *\n * `IShoppingOrder` is an entity that embodies\n * {@link IShoppingCustomer customer}'s order application information. However,\n * please note that at this time, you are still at the \"order application\" stage\n * and not the \"order confirmation\" stage.\n *\n * And as soon as a customer applies for an order, all\n * {@link IShoppingCartCommodity commodities} in the target shopping cart are\n * promoted to {@link IShoppingOrderGood goods}, and those good records are\n * created under this `IShoppingOrder`.\n *\n * Of course, not all commodities in the target shopping cart become\n * {@link IShoppingOrderGood}, but only those selected by the customer become the\n * {@link IShoppingOrderGood}.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IShoppingOrder = {\n  /**\n   * Primary Key.\n   *\n   * @title Primary Key\n   */\n  id: string &\n    tags.Format<\"uuid\"> &\n    tags.JsonSchemaPlugin<{\n      \"x-wrtn-payment-order-id\": true;\n    }>;\n\n  /**\n   * Representative name of the order.\n   *\n   * @title Representative name of the order\n   */\n  name: string &\n    tags.JsonSchemaPlugin<{\n      \"x-wrtn-payment-order-name\": true;\n    }>;\n\n  /**\n   * Customer who've applied for the order.\n   *\n   * @title Customer who've applied for the order\n   */\n  customer: IShoppingCustomer;\n\n  /**\n   * List of goods in the order.\n   *\n   * @title List of goods in the order\n   */\n  goods: IShoppingOrderGood[] & tags.MinItems<1>;\n\n  /**\n   * Price information including discounts.\n   *\n   * For reference, this price value has multiplied by the {@link volume}\n   * value. Therefore, even if {@link volume} value is equal to the target\n   * {@link IShoppingCartCommodity.volume}, this price value can be different\n   * with the {@link IShoppingCartCommodity.price} value.\n   *\n   * @title Price information including discounts\n   */\n  price: IShoppingOrderPrice;\n\n  /**\n   * Order completion and payment information.\n   *\n   * @title Order completion and payment information\n   */\n  publish: null | IShoppingOrderPublish;\n\n  /**\n   * Creation time of the record.\n   *\n   * @title Creation time of the record\n   */\n  created_at: string & tags.Format<\"date-time\">;\n};\nexport namespace IShoppingOrder {\n  /** Request of orders with pagination and searching/sorting conditions. */\n  export type IRequest = {\n    search?: null | IShoppingOrder.IRequest.ISearch;\n    sort?:\n      | null\n      | (\n          | \"-order.price\"\n          | \"-order.quantity\"\n          | \"-order.created_at\"\n          | \"-order.publish.paid_at\"\n          | \"+order.price\"\n          | \"+order.quantity\"\n          | \"+order.created_at\"\n          | \"+order.publish.paid_at\"\n        )[];\n\n    /**\n     * Page number.\n     *\n     * @title Page number\n     */\n    page?: null | (number & tags.Type<\"int32\"> & tags.Minimum<0>);\n\n    /**\n     * Limitation of records per a page.\n     *\n     * @title Limitation of records per a page\n     */\n    limit?: null | (number & tags.Type<\"int32\"> & tags.Minimum<0>);\n  };\n  export namespace IRequest {\n    export type ISearch = {\n      min_price?: null | number;\n      max_price?: null | number;\n      paid?: null | boolean;\n      sale?: null | IShoppingSale.IRequest.ISearch;\n    };\n  }\n\n  /** Creation information of the order appliance. */\n  export type ICreate = {\n    /**\n     * List of goods in the order.\n     *\n     * @title List of goods in the order\n     */\n    goods: IShoppingOrderGood.ICreate[] & tags.MinItems<1>;\n\n    /**\n     * Representative name of the order.\n     *\n     * If omit, the name will be generated automatically.\n     *\n     * @title Representative name of the order\n     */\n    name?: null | string;\n  };\n\n  /** Invert information from delivery. */\n  export type IInvertFromDelivery = {\n    /**\n     * Primary Key.\n     *\n     * @title Primary Key\n     */\n    id: string & tags.Format<\"uuid\">;\n\n    /**\n     * Customer who've applied for the order.\n     *\n     * @title Customer who've applied for the order\n     */\n    customer: IShoppingCustomer;\n\n    /**\n     * List of goods in the order.\n     *\n     * @title List of goods in the order\n     */\n    goods: IShoppingOrderGood[] & tags.MinItems<1>;\n\n    /**\n     * Price information including discounts.\n     *\n     * @title Price information including discounts\n     */\n    price: IShoppingOrderPrice;\n\n    /**\n     * Order completion and payment information.\n     *\n     * @title Order completion and payment information\n     */\n    publish: null | IShoppingOrderPublish.IInvertFromDelivery;\n\n    /**\n     * Creation time of the record.\n     *\n     * @title Creation time of the record\n     */\n    created_at: string & tags.Format<\"date-time\">;\n  };\n}\n",
  "src/api/structures/IShoppingOrderGood.ts": "import { tags } from \"typia\";\n\nimport { IShoppingCartCommodity } from \"./IShoppingCartCommodity\";\nimport { IShoppingOrderPrice } from \"./IShoppingOrderPrice\";\n\n/**\n * Information about the individual goods that make up your order.\n *\n * `IShoppingOrderGood` is an entity that represents each good ordered by a\n * {@link IShoppingCustomer customer}, and the record is created in the process\n * of upgrading the product {@link IShoppingCartCommodity commodity} in the\n * shopping cart to a good due to the customer's {@link IShoppingOrder order}\n * request.\n *\n * And `IShoppingOrderGood`, like {@link IShoppingCartCommodity}, is a concept\n * that corresponds to the listing {@link IShoppingSaleSnapshot sale snapshot}.\n *\n * For reference, `IShoppingOrderGood` also contains {@link volume} information\n * separately from the belonging {@link IShoppingCartCommodity.volume}. This is\n * because there are some cases where you put 3 books in your shopping cart and\n * then change them to 4 during the actual order application process. This is to\n * increase the reusability of the shopping cart by changing the volume\n * attribute of the current entity rather than directly changing the commodity\n * information.\n *\n * In addition, `IShoppingOrderGood` becomes the most basic unit for the\n * post-order process, that is, after service (A/S). For example, after\n * receiving a customer's product, confirming the order is recorded in the\n * {@link confirmed_at} attribute. Additionally, `IShoppingOrderGood` is the unit\n * in which customers issues or request exchanges or refunds for ordered\n * products.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IShoppingOrderGood = {\n  /**\n   * Primary Key.\n   *\n   * @title Primary Key\n   */\n  id: string & tags.Format<\"uuid\">;\n\n  /**\n   * Commodity that is the basis of the good.\n   *\n   * @title Commodity that is the basis of the good\n   */\n  commodity: IShoppingCartCommodity;\n\n  /**\n   * Volume of the good.\n   *\n   * The value multiplied to {@link IShoppingCartCommodityStock.quantity}. It's\n   * purpose is exactly same with {@link IShoppingCartCommodity.volume}, but\n   * rewritten because the {@link IShoppingCartCommodity} records are reusable\n   * until payment.\n   *\n   * @title Volume of the good\n   */\n  volume: number & tags.Type<\"int32\"> & tags.Minimum<0>;\n\n  /**\n   * Price information including discounts and multiplied volume.\n   *\n   * @title Price information including discounts and multiplied volume\n   */\n  price: IShoppingOrderPrice.ISummary;\n\n  /**\n   * State of delivery about the good.\n   *\n   * @title State of delivery about the good\n   */\n  state:\n    | null\n    | \"none\"\n    | \"underway\"\n    | \"preparing\"\n    | \"manufacturing\"\n    | \"shipping\"\n    | \"delivering\"\n    | \"arrived\";\n\n  /**\n   * Confirmation time of order good.\n   *\n   * When be confirmed, customer can't request refund or exchange.\n   *\n   * The confirmation be accomplished by following cases.\n   *\n   * - Customer does it directly.\n   * - 14 days after the delivery.\n   *\n   * @title Confirmation time of order good\n   */\n  confirmed_at: null | (string & tags.Format<\"date-time\">);\n};\nexport namespace IShoppingOrderGood {\n  /** Creation information of the good. */\n  export type ICreate = {\n    /**\n     * Target shopping cart commodity's {@link IShoppingCartCommodity.id}.\n     *\n     * `commodity_id` is the primary key of the\n     * {@link IShoppingCartCommodity} entity, which is the basis of the good\n     * to be created. In other words, it is the primary key of the shopping\n     * cart commodity that the customer has selected and applied for the\n     * order.\n     *\n     * @title Target shopping cart commodity's {@link IShoppingCartCommodity.id}\n     */\n    commodity_id: string & tags.Format<\"uuid\">;\n\n    /**\n     * Volume of the good.\n     *\n     * The value multiplied to {@link IShoppingCartCommodityStock.quantity}.\n     * It's purpose is exactly same with\n     * {@link IShoppingCartCommodity.volume}, but rewritten because the\n     * {@link IShoppingCartCommodity} records are reusable until payment.\n     *\n     * @title Volume of the good\n     */\n    volume: number & tags.Type<\"int32\"> & tags.Minimum<0>;\n  };\n}\n",
  "src/api/structures/IShoppingCartCommodity.ts": "import { tags } from \"typia\";\n\nimport { IShoppingSaleSnapshot } from \"./IShoppingSaleSnapshot\";\nimport { IShoppingPrice } from \"./IShoppingPrice\";\nimport { IShoppingSale } from \"./IShoppingSale\";\nimport { IShoppingCartCommodityStock } from \"./IShoppingCartCommodityStock\";\n\n/**\n * Item in a shopping cart.\n *\n * `IShoppingCartCommodity` is an entity that represents a\n * {@link IShoppingSaleSnapshot snapshot} of the items that\n * {@link IShoppingCustomer customer} has placed into his shopping cart with a\n * {@link IShoppingOrder purchase} in mind. And if the customer continues this\n * into an actual order in the future, `IShoppingCartCommodity` be changed to\n * {@link IShoppingOrderGood}.\n *\n * And while adding a sale snapshot to the shopping cart, the customer\n * inevitably selects specific {@link IShoppingSaleUnit units} and\n * {@link IShoppingSaleUnitStock final stocks} within the listing snapshot.\n * Information about these units and stocks is recorded in the subsidiary entity\n * {@link IShoppingCartCommodityStock}. Also, there is an attribute {@link volume}\n * that indicates how many sets of snapshots of the target commodity will be\n * purchased. This \"volume\" is a value that will be multiplied by\n * {@link IShoppingSaleUnitStock.IInvert.quantity}, the quantity for each\n * component.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IShoppingCartCommodity = {\n  /**\n   * Primary Key.\n   *\n   * If you want to continue to the order the commodity, then use this ID to\n   * order.\n   *\n   * @title Primary Key\n   */\n  id: string & tags.Format<\"uuid\">;\n\n  /**\n   * Invert information of the sale (snapshot), in the perspective of\n   * commodity.\n   *\n   * @title Invert information of the sale (snapshot), in the perspective of commodity\n   */\n  sale: IShoppingSaleSnapshot.IInvert;\n\n  /**\n   * Whether current commodity is orderable or not.\n   *\n   * If this attribute is `false`, then the commodity is not orderable,\n   * because it has already been ordered.\n   *\n   * @title Whether current commodity is orderable or not\n   */\n  orderable: boolean;\n\n  /**\n   * Whether current commodity is pseudo or not.\n   *\n   * When this attribute is `true`, then the commodity is not the real one,\n   * but just fake information only for calculating the discount effect by\n   * {@link IShoppingCoupon coupons}.\n   *\n   * @title Whether current commodity is pseudo or not\n   */\n  pseudo: boolean;\n\n  /**\n   * Volume of the commodity to purchase.\n   *\n   * A value indicating how many sets would be multiplied to the children\n   * {@link IShoppingSaleUnitStock.IInvert.quantity} values.\n   *\n   * @title Volume of the commodity to purchase\n   */\n  volume: number & tags.Type<\"int32\"> & tags.Minimum<1>;\n\n  /**\n   * Price of the commodity.\n   *\n   * For reference, this price value has not been multiplied by the\n   * {@link volume} value. It just sumed up the prices of the children\n   * {@link IShoppingSaleUnitStock.IInvert.price} values.\n   *\n   * @title Price of the commodity\n   */\n  price: IShoppingPrice;\n\n  /**\n   * Creation time of the record.\n   *\n   * @title Creation time of the record\n   */\n  created_at: string & tags.Format<\"date-time\">;\n};\nexport namespace IShoppingCartCommodity {\n  export type IRequest = {\n    search?: IShoppingCartCommodity.IRequest.ISearch;\n    sort?: (\n      | \"-seller.created_at\"\n      | \"-seller.goods.payments.real\"\n      | \"-seller.goods.publish_count\"\n      | \"-seller.reviews.average\"\n      | \"-seller.reviews.count\"\n      | \"-goods.publish_count\"\n      | \"-goods.payments.real\"\n      | \"-reviews.average\"\n      | \"-reviews.count\"\n      | \"-sale.created_at\"\n      | \"-sale.updated_at\"\n      | \"-sale.opened_at\"\n      | \"-sale.closed_at\"\n      | \"-sale.content.title\"\n      | \"-sale.price_range.lowest.real\"\n      | \"-sale.price_range.highest.real\"\n      | \"+seller.created_at\"\n      | \"+seller.goods.payments.real\"\n      | \"+seller.goods.publish_count\"\n      | \"+seller.reviews.average\"\n      | \"+seller.reviews.count\"\n      | \"+goods.publish_count\"\n      | \"+goods.payments.real\"\n      | \"+reviews.average\"\n      | \"+reviews.count\"\n      | \"+sale.created_at\"\n      | \"+sale.updated_at\"\n      | \"+sale.opened_at\"\n      | \"+sale.closed_at\"\n      | \"+sale.content.title\"\n      | \"+sale.price_range.lowest.real\"\n      | \"+sale.price_range.highest.real\"\n      | \"-commodity.price\"\n      | \"-commodity.volume\"\n      | \"-commodity.volumed_price\"\n      | \"-commodity.created_at\"\n      | \"+commodity.price\"\n      | \"+commodity.volume\"\n      | \"+commodity.volumed_price\"\n      | \"+commodity.created_at\"\n    )[];\n\n    /**\n     * Page number.\n     *\n     * @title Page number\n     */\n    page?: null | (number & tags.Type<\"int32\"> & tags.Minimum<0>);\n\n    /**\n     * Limitation of records per a page.\n     *\n     * @title Limitation of records per a page\n     */\n    limit?: null | (number & tags.Type<\"int32\"> & tags.Minimum<0>);\n  };\n  export namespace IRequest {\n    export type ISearch = {\n      min_price?: number;\n      max_price?: number;\n      min_volumed_price?: number;\n      max_volumed_price?: number;\n      sale?: IShoppingSale.IRequest.ISearch;\n    };\n  }\n\n  /** Creation information of a shopping cart commodity. */\n  export type ICreate = {\n    /**\n     * Target sale's {@link IShoppingSale.id}.\n     *\n     * @title Target sale's {@link IShoppingSale.id}\n     */\n    sale_id: string & tags.Format<\"uuid\">;\n\n    /**\n     * List of the stocks to be purchased.\n     *\n     * @title List of the stocks to be purchased\n     */\n    stocks: IShoppingCartCommodityStock.ICreate[] & tags.MinItems<1>;\n\n    /**\n     * Volume of the commodity to purchase.\n     *\n     * A value indicating how many sets would be multiplied to the children\n     * {@link IShoppingSaleUnitStock.IInvert.quantity} values.\n     *\n     * @title Volume of the commodity to purchase\n     */\n    volume: number & tags.Type<\"int32\"> & tags.Minimum<1>;\n\n    /**\n     * Whether to accumulate the volume or not.\n     *\n     * If this attribute is not `false` and there's same commodity that\n     * composed with same stocks and options, then the volume will be\n     * accumulated to the existed one.\n     *\n     * Otherwise, duplicated commodity would be newly created.\n     *\n     * @title Whether to accumulate the volume or not\n     */\n    accumulate?: null | boolean;\n  };\n\n  /** Update information of a shopping cart commodity. */\n  export type IUpdate = {\n    /**\n     * Volume of the commodity to purchase.\n     *\n     * A value indicating how many sets would be multiplied to the children\n     * {@link IShoppingSaleUnitStock.IInvert.quantity} values.\n     *\n     * @title Volume of the commodity to purchase\n     */\n    volume: number & tags.Type<\"int32\"> & tags.Minimum<1>;\n  };\n}\n",
  "src/api/structures/IShoppingSaleSnapshot.ts": "import { tags } from \"typia\";\n\nimport { IShoppingSaleContent } from \"./IShoppingSaleContent\";\nimport { IShoppingChannelCategory } from \"./IShoppingChannelCategory\";\nimport { IShoppingSaleUnit } from \"./IShoppingSaleUnit\";\nimport { IShoppingSection } from \"./IShoppingSection\";\nimport { IShoppingSeller } from \"./IShoppingSeller\";\nimport { IShoppingSalePriceRange } from \"./IShoppingSalePriceRange\";\n\n/**\n * Snapshot record of sale.\n *\n * `IShoppingSaleSnapshot` is an entity that embodies a snapshot of a sale, and\n * the ERD (Entity Relationship Diagram) describes the role of the\n * `shopping_sale_snapshots` table as follows:\n *\n * > {@link IShoppingSale shopping_sales} is an entity that embodies \"product\n * > sales\" (sales) information registered by the {@link IShoppingSeller seller}.\n * > And the main information of the sale is recorded in the sub\n * > `shopping_sale_snapshots`, not in the main\n * > {@link IShoppingSale shopping_sales}. When a seller changes a previously\n * > registered item, the existing {@link IShoppingSale shopping_sales} record is\n * > not changed, but a new snapshot record is created.\n *\n * > This is to preserve the {@link IShoppingCustomer customer}'s\n * > {@link IShoppingOrder purchase history} flawlessly after the customer\n * > purchases a specific item, even if the seller changes the components or price\n * > of the item. It is also intended to support sellers in so-called A/B testing,\n * > which involves changing components or prices and measuring the performance in\n * > each case.\n *\n * By the way, DTO (Data Transfer Object) level used by the front-end developer,\n * it does not distinguish {@link IShoppingSale} and `IShoppingSaleSnapshot`\n * strictly, and generally handles {@link IShoppingSale} and snapshot together.\n *\n * But even though the DTO level does not strictly distinguish them, the word\n * and concept of \"snapshot\" is still important, so it is recommended to\n * understand the concept of \"snapshot\" properly.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IShoppingSaleSnapshot = {\n  /**\n   * Primary Key of Sale.\n   *\n   * @title Primary Key of Sale\n   */\n  id: string & tags.Format<\"uuid\">;\n\n  /**\n   * Primary Key of Snapshot.\n   *\n   * @title Primary Key of Snapshot\n   */\n  snapshot_id: string & tags.Format<\"uuid\">;\n\n  /**\n   * Whether the snapshot is the latest one or not.\n   *\n   * @title Whether the snapshot is the latest one or not\n   */\n  latest: boolean;\n\n  /**\n   * Description and image content describing the sale.\n   *\n   * @title Description and image content describing the sale\n   */\n  content: IShoppingSaleContent;\n\n  /**\n   * List of categories.\n   *\n   * Which categories the sale is registered to.\n   *\n   * @title List of categories\n   */\n  categories: IShoppingChannelCategory.IInvert[];\n\n  /**\n   * List of search tags.\n   *\n   * @title List of search tags\n   */\n  tags: string[];\n\n  /**\n   * List of units.\n   *\n   * Records about individual product composition information that are sold in\n   * the sale. Each {@link IShoppingSaleUnit unit} record has configurable\n   * {@link IShoppingSaleUnitOption options},\n   * {@link IShoppingSaleUnitOptionCandidate candidate} values for each option,\n   * and {@link IShoppingSaleUnitStock final stocks} determined by selecting\n   * every candidate values of each option.\n   *\n   * @title List of units\n   */\n  units: IShoppingSaleUnit[] & tags.MinItems<1>;\n};\nexport namespace IShoppingSaleSnapshot {\n  /**\n   * Invert information of the sale snapshot, in the perspective of commodity.\n   *\n   * `IShoppingSaleSnapshot.IInvert` is a structure used to represent a\n   * snapshot in the perspective of a {@link IShoppingCommodity}, corresponding\n   * to an {@link IShoppingCartCommodityStock} entity.\n   *\n   * Therefore, `IShoppingSaleSnapshot.IInvert` does not contain every\n   * {@link IShoppingSaleUnit units} and {@link IShoppingSaleUnitStock stocks}\n   * of the snapshot records, but only some of the records which are put into\n   * the {@link IShoppingCartCommodity shopping cart}.\n   */\n  export type IInvert = {\n    /**\n     * Belonged section's information.\n     *\n     * @title Belonged section's information\n     */\n    section: IShoppingSection;\n\n    /**\n     * Seller who've registered the sale.\n     *\n     * @title Seller who've registered the sale\n     */\n    seller: IShoppingSeller.IInvert;\n\n    /**\n     * Primary Key of Sale.\n     *\n     * @title Primary Key of Sale\n     */\n    id: string & tags.Format<\"uuid\">;\n\n    /**\n     * Primary Key of Snapshot.\n     *\n     * @title Primary Key of Snapshot\n     */\n    snapshot_id: string & tags.Format<\"uuid\">;\n\n    /**\n     * Whether the snapshot is the latest one or not.\n     *\n     * @title Whether the snapshot is the latest one or not\n     */\n    latest: boolean;\n\n    /**\n     * Description and image content describing the sale.\n     *\n     * @title Description and image content describing the sale\n     */\n    content: IShoppingSaleContent.IInvert;\n\n    /**\n     * List of categories.\n     *\n     * Which categories the sale is registered to.\n     *\n     * @title List of categories\n     */\n    categories: IShoppingChannelCategory.IInvert[];\n\n    /**\n     * List of search tags.\n     *\n     * @title List of search tags\n     */\n    tags: string[];\n\n    /**\n     * List of units.\n     *\n     * Records about individual product composition information that are\n     * sold in the sale. Each {@link IShoppingSaleUnit unit} record has\n     * configurable {@link IShoppingSaleUnitOption options},\n     * {@link IShoppingSaleUnitOptionCandidate candidate} values for each\n     * option, and {@link IShoppingSaleUnitStock final stocks} determined by\n     * selecting every candidate values of each option.\n     *\n     * @title List of units\n     */\n    units: IShoppingSaleUnit.IInvert[] & tags.MinItems<1>;\n\n    /**\n     * Creation time of the record.\n     *\n     * Note that, this property is different with {@link opened_at}, which\n     * means the timepoint of the sale is opened.\n     *\n     * @title Creation time of the record\n     */\n    created_at: string & tags.Format<\"date-time\">;\n\n    /**\n     * Last updated time of the record.\n     *\n     * In another words, creation time of the last snapshot.\n     *\n     * @title Last updated time of the record\n     */\n    updated_at: string & tags.Format<\"date-time\">;\n\n    /**\n     * Paused time of the sale.\n     *\n     * The sale is paused by the seller, for some reason.\n     *\n     * {@link IShoppingCustomer Customers} can still see the sale on the both\n     * list and detail pages, but the sale has a warning label \"The sale is\n     * paused by the seller\".\n     *\n     * @title Paused time of the sale\n     */\n    paused_at: null | (string & tags.Format<\"date-time\">);\n\n    /**\n     * Suspended time of the sale.\n     *\n     * The sale is suspended by the seller, for some reason.\n     *\n     * {@link IShoppingCustomer Customers} cannot see the sale on the both\n     * list and detail pages. It is almost same with soft delettion, but\n     * there's a little bit difference that the owner\n     * {@link IShoppingSeller seller} can still see the sale and resume it.\n     *\n     * Of course, the {@link IShoppingCustomer customers} who have already\n     * purchased the sale can still see the sale on the\n     * {@link IShoppingOrder order} page.\n     *\n     * @title Suspended time of the sale\n     */\n    suspended_at: null | (string & tags.Format<\"date-time\">);\n\n    /**\n     * Opening time of the sale.\n     *\n     * @title Opening time of the sale\n     */\n    opened_at: null | (string & tags.Format<\"date-time\">);\n\n    /**\n     * Closing time of the sale.\n     *\n     * If this value is `null`, the sale be continued forever.\n     *\n     * @title Closing time of the sale\n     */\n    closed_at: null | (string & tags.Format<\"date-time\">);\n  };\n\n  /** Summarized information of the sale snapshot. */\n  export type ISummary = {\n    /**\n     * Price range of the unit.\n     *\n     * @title Price range of the unit\n     */\n    price_range: IShoppingSalePriceRange;\n\n    /**\n     * Primary Key of Sale.\n     *\n     * @title Primary Key of Sale\n     */\n    id: string & tags.Format<\"uuid\">;\n\n    /**\n     * Primary Key of Snapshot.\n     *\n     * @title Primary Key of Snapshot\n     */\n    snapshot_id: string & tags.Format<\"uuid\">;\n\n    /**\n     * Whether the snapshot is the latest one or not.\n     *\n     * @title Whether the snapshot is the latest one or not\n     */\n    latest: boolean;\n\n    /**\n     * Description and image content describing the sale.\n     *\n     * @title Description and image content describing the sale\n     */\n    content: IShoppingSaleContent.IInvert;\n\n    /**\n     * List of categories.\n     *\n     * Which categories the sale is registered to.\n     *\n     * @title List of categories\n     */\n    categories: IShoppingChannelCategory.IInvert[];\n\n    /**\n     * List of search tags.\n     *\n     * @title List of search tags\n     */\n    tags: string[];\n\n    /**\n     * List of units.\n     *\n     * Records about individual product composition information that are\n     * sold in the sale. Each {@link IShoppingSaleUnit unit} record has\n     * configurable {@link IShoppingSaleUnitOption options},\n     * {@link IShoppingSaleUnitOptionCandidate candidate} values for each\n     * option, and {@link IShoppingSaleUnitStock final stocks} determined by\n     * selecting every candidate values of each option.\n     *\n     * @title List of units\n     */\n    units: IShoppingSaleUnit.ISummary[] & tags.MinItems<1>;\n  };\n\n  /** Creation information of the snapshot. */\n  export type ICreate = {\n    /**\n     * Description and image content describing the sale.\n     *\n     * @title Description and image content describing the sale\n     */\n    content: IShoppingSaleContent.ICreate;\n\n    /**\n     * List of units.\n     *\n     * @title List of units\n     */\n    units: IShoppingSaleUnit.ICreate[] & tags.MinItems<1>;\n\n    /**\n     * List of search tags.\n     *\n     * @title List of search tags\n     */\n    tags: string[];\n\n    /**\n     * List of target categories' {@link IShoppingChannelCategory.code}s.\n     *\n     * If empty, it means all categories of the channel is listing the sale.\n     *\n     * @title List of target categories' {@link IShoppingChannelCategory.code}s\n     */\n    category_codes: string[];\n  };\n}\n",
  "src/api/structures/IShoppingSaleUnitStock.ts": "import { tags } from \"typia\";\n\nimport { IShoppingPrice } from \"./IShoppingPrice\";\nimport { IShoppingSaleUnitStockInventory } from \"./IShoppingSaleUnitStockInventory\";\nimport { IShoppingSaleUnitStockChoice } from \"./IShoppingSaleUnitStockChoice\";\n\n/**\n * Final component information on units for sale.\n *\n * `IShoppingSaleUnitStock` is a subsidiary entity of {@link IShoppingSaleUnit}\n * that represents a product catalog for sale, and is a kind of final stock that\n * is constructed by selecting all\n * {@link IShoppingSaleUnitSelectableOption options} (variable \"select\" type) and\n * their {@link IShoppingSaleUnitOptionCandidate candidate} values in the\n * belonging unit. It is the \"good\" itself that customers actually purchase.\n *\n * - Product Name) MacBook\n *\n *   - Options\n *\n *       - CPU: { i3, i5, i7, i9 }\n *       - RAM: { 8GB, 16GB, 32GB, 64GB, 96GB }\n *       - SSD: { 256GB, 512GB, 1TB }\n *   - Number of final stocks: 4 * 5 * 3 = 60\n *\n * For reference, the total number of `IShoppingSaleUnitStock` records in an\n * attribution unit can be obtained using Cartesian Product. In other words, the\n * value obtained by multiplying all the candidate values that each (variable\n * \"select\" type) option can have by the number of cases is the total number of\n * final stocks in the unit.\n *\n * Of course, without a single variable \"select\" type option, the final stocks\n * count in the unit is only 1.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IShoppingSaleUnitStock = {\n  /**\n   * Primary Key.\n   *\n   * @title Primary Key\n   */\n  id: string & tags.Format<\"uuid\">;\n\n  /**\n   * Representative name of the stock.\n   *\n   * @title Representative name of the stock\n   */\n  name: string;\n\n  /**\n   * Price of the stock.\n   *\n   * @title Price of the stock\n   */\n  price: IShoppingPrice;\n\n  /**\n   * Current inventory status of the stock.\n   *\n   * @title Current inventory status of the stock\n   */\n  inventory: IShoppingSaleUnitStockInventory;\n\n  /**\n   * List of choices.\n   *\n   * Which candidate values being chosen for each option.\n   *\n   * @title List of choices\n   */\n  choices: IShoppingSaleUnitStockChoice[];\n};\nexport namespace IShoppingSaleUnitStock {\n  /** Invert information from the cart. */\n  export type IInvert = {\n    /**\n     * Primary Key.\n     *\n     * @title Primary Key\n     */\n    id: string & tags.Format<\"uuid\">;\n\n    /**\n     * Representative name of the stock.\n     *\n     * @title Representative name of the stock\n     */\n    name: string;\n\n    /**\n     * Price of the stock.\n     *\n     * @title Price of the stock\n     */\n    price: IShoppingPrice;\n\n    /**\n     * Quantity of the stock in the cart.\n     *\n     * @title Quantity of the stock in the cart\n     */\n    quantity: number & tags.Type<\"int32\"> & tags.Minimum<1>;\n\n    /**\n     * Current inventory status of the stock.\n     *\n     * @title Current inventory status of the stock\n     */\n    inventory: IShoppingSaleUnitStockInventory;\n\n    /**\n     * List of choices.\n     *\n     * Which values being written for each option.\n     *\n     * @title List of choices\n     */\n    choices: IShoppingSaleUnitStockChoice.IInvert[];\n  };\n\n  /** Creation information of the stock. */\n  export type ICreate = {\n    /**\n     * Representative name of the stock.\n     *\n     * @title Representative name of the stock\n     */\n    name: string;\n\n    /**\n     * Price of the stock.\n     *\n     * @title Price of the stock\n     */\n    price: IShoppingPrice;\n\n    /**\n     * Initial inventory quantity.\n     *\n     * @title Initial inventory quantity\n     */\n    quantity: number & tags.Type<\"int32\"> & tags.Minimum<1>;\n\n    /**\n     * List of choices.\n     *\n     * Which candidate values being chosen for each option.\n     *\n     * @title List of choices\n     */\n    choices: IShoppingSaleUnitStockChoice.ICreate[];\n  };\n}\n",
  "src/api/structures/IShoppingSaleUnitStockInventory.ts": "import { tags } from \"typia\";\n\n/**\n * Inventory information of a final stock.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IShoppingSaleUnitStockInventory = {\n  /**\n   * Total income quantity.\n   *\n   * @title Total income quantity\n   */\n  income: number & tags.Type<\"int32\"> & tags.Minimum<0>;\n\n  /**\n   * Total outcome quantity.\n   *\n   * @title Total outcome quantity\n   */\n  outcome: number & tags.Type<\"int32\"> & tags.Minimum<0>;\n};\n",
  "src/api/structures/IShoppingSaleUnitStockChoice.ts": "import { tags } from \"typia\";\n\nimport { IShoppingSaleUnitSelectableOption } from \"./IShoppingSaleUnitSelectableOption\";\nimport { IShoppingSaleUnitDescriptiveOption } from \"./IShoppingSaleUnitDescriptiveOption\";\nimport { IShoppingSaleUnitOptionCandidate } from \"./IShoppingSaleUnitOptionCandidate\";\n\n/**\n * Selection information of final stock.\n *\n * `IShoppingSaleUnitStockChoice` is an entity that represents which\n * {@link IShoppingSaleUnitSelectableOption option} of each variable \"select\"\n * type was selected for each {@link IShoppingSaleUnitStock stock} and which\n * {@link IShoppingSaleUnitOptionCandidate candidate value} was selected within\n * it.\n *\n * Of course, if the bound {@link IShoppingSaleUnit unit} does not have any\n * options, this entity can also be ignored.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IShoppingSaleUnitStockChoice = {\n  /**\n   * Primary Key.\n   *\n   * @title Primary Key\n   */\n  id: string & tags.Format<\"uuid\">;\n\n  /** Target option's {@link IShoppingSaleUnitOption.id} */\n  option_id: string & tags.Format<\"uuid\">;\n\n  /** Target candidate's {@link IShoppingSaleUnitOptionCandidate.id} */\n  candidate_id: string & tags.Format<\"uuid\">;\n};\nexport namespace IShoppingSaleUnitStockChoice {\n  /** Invert information from the cart. */\n  export type IInvert = {\n    /**\n     * Primary Key.\n     *\n     * @title Primary Key\n     */\n    id: string & tags.Format<\"uuid\">;\n\n    /**\n     * Target option.\n     *\n     * @title Target option\n     */\n    option:\n      | IShoppingSaleUnitSelectableOption.IInvert\n      | IShoppingSaleUnitDescriptiveOption;\n\n    /**\n     * Selected candidate value.\n     *\n     * @title Selected candidate value\n     */\n    candidate: null | IShoppingSaleUnitOptionCandidate;\n\n    /**\n     * Written value.\n     *\n     * @title Written value\n     */\n    value: null | string | number | boolean;\n  };\n\n  /** Creation information of stock choice. */\n  export type ICreate = {\n    /**\n     * Target option's index number in\n     * {@link IShoppingSaleUnit.ICreate.options}.\n     */\n    option_index: number & tags.Type<\"int32\"> & tags.Minimum<0>;\n\n    /**\n     * Target candidate's index number in\n     * {@link IShoppingSaleUnitSelectableOption.ICreate.candidates}.\n     */\n    candidate_index: number & tags.Type<\"int32\"> & tags.Minimum<0>;\n  };\n}\n",
  "src/api/structures/IShoppingSaleUnitSelectableOption.ts": "import { tags } from \"typia\";\n\nimport { IShoppingSaleUnitOptionCandidate } from \"./IShoppingSaleUnitOptionCandidate\";\n\n/**\n * Individual option information on units for sale.\n *\n * `IShoppingSaleUnitSelectableOption` is a subsidiary entity of\n * {@link IShoppingSaleUnit} that represents individual products in the\n * {@link IShoppingSale sale}, and is an entity designed to represent individual\n * selectable option information for the unit.\n *\n * - Examples of Options\n *\n *   - Selectable options\n *\n *       - Computer: CPU, RAM, SSD, etc.\n *       - Clothes: size, color, style, etc.\n *   - Descriptive options\n *\n *       - Engrave\n *       - Simple question\n *\n * If the {@link variable} property value is `true`, the final stock that the\n * {@link IShoppingCustomer customer} will purchase changes depending on the\n * selection of the {@link IShoppingSaleUnitOptionCandidate candidate value}.\n *\n * Conversely, if it is a type other than \"select\", or if the {@link variable}\n * property value is \"false\", , this is an option that has no meaning beyond\n * simple information transfer. Therefore, no matter what value the customer\n * chooses when purchasing it, the option in this case does not affect the\n * {@link IShoppingSaleUnitStock final stock}.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IShoppingSaleUnitSelectableOption = {\n  /**\n   * List of candidate values.\n   *\n   * @title List of candidate values\n   */\n  candidates: IShoppingSaleUnitOptionCandidate[] & tags.MinItems<1>;\n\n  /**\n   * Primary Key.\n   *\n   * @title Primary Key\n   */\n  id: string & tags.Format<\"uuid\">;\n\n  /**\n   * Discriminant for the type of selectable option.\n   *\n   * @title Discriminant for the type of selectable option\n   */\n  type: \"select\";\n\n  /**\n   * Represents the name of the option.\n   *\n   * @title Represents the name of the option\n   */\n  name: string;\n\n  /**\n   * Whether the option is variable or not.\n   *\n   * When type of current option is \"select\", this attribute means whether\n   * selecting different candidate value affects the final stock or not.\n   *\n   * @title Whether the option is variable or not\n   */\n  variable: boolean;\n};\nexport namespace IShoppingSaleUnitSelectableOption {\n  export type IInvert = {\n    /**\n     * Primary Key.\n     *\n     * @title Primary Key\n     */\n    id: string & tags.Format<\"uuid\">;\n\n    /**\n     * Discriminant for the type of selectable option.\n     *\n     * @title Discriminant for the type of selectable option\n     */\n    type: \"select\";\n\n    /**\n     * Represents the name of the option.\n     *\n     * @title Represents the name of the option\n     */\n    name: string;\n\n    /**\n     * Whether the option is variable or not.\n     *\n     * When type of current option is \"select\", this attribute means whether\n     * selecting different candidate value affects the final stock or not.\n     *\n     * @title Whether the option is variable or not\n     */\n    variable: boolean;\n  };\n\n  /** Creation information of the selectable option. */\n  export type ICreate = {\n    /**\n     * Discriminant for the type of selectable option.\n     *\n     * @title Discriminant for the type of selectable option\n     */\n    type: \"select\";\n\n    /**\n     * Represents the name of the option.\n     *\n     * @title Represents the name of the option\n     */\n    name: string;\n\n    /**\n     * Whether the option is variable or not.\n     *\n     * When type of current option is \"select\", this attribute means whether\n     * selecting different candidate value affects the final stock or not.\n     *\n     * @title Whether the option is variable or not\n     */\n    variable: boolean;\n\n    /**\n     * List of candidate values.\n     *\n     * @title List of candidate values\n     */\n    candidates: IShoppingSaleUnitOptionCandidate.ICreate[] & tags.MinItems<1>;\n  };\n}\n",
  "src/api/structures/IShoppingSaleUnitDescriptiveOption.ts": "import { tags } from \"typia\";\n\n/**\n * Descriptive option.\n *\n * When type of the option not `\"select\"`, it means the option is descriptive\n * that requiring {@link IShoppingCustomer customers} to write some value to\n * {@link IShoppingOrder purchase}. Also, whatever customer writes about the\n * option, it does not affect the {@link IShoppingSaleUnitStock final stock}.\n *\n * Another words, the descriptive option is just for information transfer.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IShoppingSaleUnitDescriptiveOption = {\n  /**\n   * Primary Key.\n   *\n   * @title Primary Key\n   */\n  id: string & tags.Format<\"uuid\">;\n\n  /**\n   * Type of descriptive option.\n   *\n   * Which typed value should be written when purchasing.\n   *\n   * @title Type of descriptive option\n   */\n  type: \"string\" | \"number\" | \"boolean\";\n\n  /**\n   * Readable name of the option.\n   *\n   * @title Readable name of the option\n   */\n  name: string;\n};\nexport namespace IShoppingSaleUnitDescriptiveOption {\n  /** Creation information of the descriptive option. */\n  export type ICreate = {\n    /**\n     * Type of descriptive option.\n     *\n     * Which typed value should be written when purchasing.\n     *\n     * @title Type of descriptive option\n     */\n    type: \"string\" | \"number\" | \"boolean\";\n\n    /**\n     * Readable name of the option.\n     *\n     * @title Readable name of the option\n     */\n    name: string;\n  };\n}\n",
  "src/api/structures/IShoppingSaleUnitOptionCandidate.ts": "import { tags } from \"typia\";\n\n/**\n * Selectable candidate values within an option.\n *\n * `IShoppingSaleUnitOptionCandidate` is an entity that represents individual\n * candidate values that can be selected from\n * {@link IShoppingSaleUnitSelectableOption options of the \"select\" type}.\n *\n * - Example\n *\n *   - RAM: 8GB, 16GB, 32GB\n *   - GPU: RTX 3060, RTX 4080, TESLA\n *   - License: Private, Commercial, Educatiion\n *\n * By the way, if belonged option is not \"select\" type, this entity never being\n * used.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IShoppingSaleUnitOptionCandidate = {\n  /**\n   * Primary Key.\n   *\n   * @title Primary Key\n   */\n  id: string & tags.Format<\"uuid\">;\n\n  /**\n   * Represents the name of the candidate value.\n   *\n   * @title Represents the name of the candidate value\n   */\n  name: string;\n};\nexport namespace IShoppingSaleUnitOptionCandidate {\n  /** Creation information of the candidate value. */\n  export type ICreate = {\n    /**\n     * Represents the name of the candidate value.\n     *\n     * @title Represents the name of the candidate value\n     */\n    name: string;\n  };\n}\n",
  "src/api/structures/IShoppingOrderPrice.ts": "import { tags } from \"typia\";\n\nimport { IShoppingCouponTicketPayment } from \"./IShoppingCouponTicketPayment\";\n\n/**\n * Price information of the order including discounts.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IShoppingOrderPrice = {\n  /**\n   * List of discount coupon ticket payments.\n   *\n   * @title List of discount coupon ticket payments\n   */\n  ticket_payments: IShoppingCouponTicketPayment[];\n\n  /**\n   * Amount of the cash payment.\n   *\n   * @title Amount of the cash payment\n   */\n  cash: number &\n    tags.Minimum<0> &\n    tags.JsonSchemaPlugin<{\n      \"x-wrtn-payment-price\": true;\n    }>;\n\n  /**\n   * Amount of the deposit payment.\n   *\n   * @title Amount of the deposit payment\n   */\n  deposit: number & tags.Minimum<0>;\n\n  /**\n   * Amount of the mileage payment.\n   *\n   * @title Amount of the mileage payment\n   */\n  mileage: number & tags.Minimum<0>;\n\n  /**\n   * Amount of the discount coupon ticket payment.\n   *\n   * @title Amount of the discount coupon ticket payment\n   */\n  ticket: number & tags.Minimum<0>;\n\n  /**\n   * Nominal price.\n   *\n   * This is not {@link real real price} to pay, but just a nominal price to\n   * show. If this value is greater than the {@link real real price}, it would\n   * be shown like {@link IShoppingSeller seller} is giving a discount.\n   *\n   * @title Nominal price\n   */\n  nominal: number & tags.Minimum<0>;\n\n  /**\n   * Real price to pay.\n   *\n   * @title Real price to pay\n   */\n  real: number & tags.Minimum<0>;\n};\nexport namespace IShoppingOrderPrice {\n  /** Summarized information of the order price. */\n  export type ISummary = {\n    /**\n     * Amount of the cash payment.\n     *\n     * @title Amount of the cash payment\n     */\n    cash: number &\n      tags.Minimum<0> &\n      tags.JsonSchemaPlugin<{\n        \"x-wrtn-payment-price\": true;\n      }>;\n\n    /**\n     * Amount of the deposit payment.\n     *\n     * @title Amount of the deposit payment\n     */\n    deposit: number & tags.Minimum<0>;\n\n    /**\n     * Amount of the mileage payment.\n     *\n     * @title Amount of the mileage payment\n     */\n    mileage: number & tags.Minimum<0>;\n\n    /**\n     * Amount of the discount coupon ticket payment.\n     *\n     * @title Amount of the discount coupon ticket payment\n     */\n    ticket: number & tags.Minimum<0>;\n\n    /**\n     * Nominal price.\n     *\n     * This is not {@link real real price} to pay, but just a nominal price\n     * to show. If this value is greater than the {@link real real price}, it\n     * would be shown like {@link IShoppingSeller seller} is giving a\n     * discount.\n     *\n     * @title Nominal price\n     */\n    nominal: number & tags.Minimum<0>;\n\n    /**\n     * Real price to pay.\n     *\n     * @title Real price to pay\n     */\n    real: number & tags.Minimum<0>;\n  };\n\n  export type ICreate = {\n    deposit: number;\n    mileage: number;\n    coupon_ids: (string & tags.Format<\"uuid\">)[];\n  };\n}\n",
  "src/api/structures/IShoppingCouponTicketPayment.ts": "import { tags } from \"typia\";\n\nimport { IShoppingCouponTicket } from \"./IShoppingCouponTicket\";\n\n/**\n * Discount coupon ticket payment details.\n *\n * `IShoppingCouponTicketPayment` is an entity that embodies the payment\n * information for the {@link IShoppingOrder order} of\n * {@link IShoppingCouponTicket}, and is used when a consumer uses the discount\n * coupon ticket he or she was issued to order and has the payment amount\n * deducted.\n *\n * And since {@link IShoppingOrder} itself is not an entity used in situations\n * where an order is completed, but rather an entity designed to express an\n * order request, the creation of this `IShoppingCouponTicketPayment` record\n * does not actually mean that the attached ticket disappears. Until the\n * {@link IShoppingCustomer customer}\n * {@link IShoppingOrderPublish.paid_at completes the payment} and confirms the\n * order, the ticket can be understood as a kind of deposit.\n *\n * Additionally, this record can be deleted by the customer reversing the\n * payment of the ticket, but it can also be deleted when the attribution order\n * itself is cancelled.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IShoppingCouponTicketPayment = {\n  /**\n   * Primary Key.\n   *\n   * @title Primary Key\n   */\n  id: string & tags.Format<\"uuid\">;\n\n  /**\n   * Target ticket.\n   *\n   * @title Target ticket\n   */\n  ticket: IShoppingCouponTicket;\n\n  /**\n   * Creation time of the record.\n   *\n   * @title Creation time of the record\n   */\n  created_at: string & tags.Format<\"date-time\">;\n};\n",
  "src/api/structures/IShoppingCouponTicket.ts": "import { tags } from \"typia\";\n\nimport { IShoppingCustomer } from \"./IShoppingCustomer\";\nimport { IShoppingCoupon } from \"./IShoppingCoupon\";\n\n/**\n * Discount coupon ticket issuance details.\n *\n * `IShoppingCouponTicket` is an entity that symbolizes\n * {@link IShoppingCoupon discount coupon} tickets issued by\n * {@link IShoppingCustomer customers}.\n *\n * And if the target discount coupon specification itself has an expiration\n * date, the expiration date is recorded in expired_at and is automatically\n * discarded after that expiration date. Of course, it doesn't matter if you use\n * the discount coupon for your order within the deadline.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IShoppingCouponTicket = {\n  /**\n   * Primary Key.\n   *\n   * @title Primary Key\n   */\n  id: string & tags.Format<\"uuid\">;\n\n  /**\n   * Customer who've taken the coupon ticket.\n   *\n   * @title Customer who've taken the coupon ticket\n   */\n  customer: IShoppingCustomer;\n\n  /**\n   * Target coupon.\n   *\n   * @title Target coupon\n   */\n  coupon: IShoppingCoupon;\n\n  /**\n   * Creation time of the record.\n   *\n   * @title Creation time of the record\n   */\n  created_at: string & tags.Format<\"date-time\">;\n\n  /**\n   * Expiration time of the ticket.\n   *\n   * @title Expiration time of the ticket\n   */\n  expired_at: null | (string & tags.Format<\"date-time\">);\n};\nexport namespace IShoppingCouponTicket {\n  export type IRequest = {\n    sort?:\n      | null\n      | (\n          | \"-ticket.created_at\"\n          | \"-ticket.expired_at\"\n          | \"+ticket.created_at\"\n          | \"+ticket.expired_at\"\n        )[];\n\n    /**\n     * Page number.\n     *\n     * @title Page number\n     */\n    page?: null | (number & tags.Type<\"int32\"> & tags.Minimum<0>);\n\n    /**\n     * Limitation of records per a page.\n     *\n     * @title Limitation of records per a page\n     */\n    limit?: null | (number & tags.Type<\"int32\"> & tags.Minimum<0>);\n  };\n\n  export type ICreate = {\n    coupon_id: string & tags.Format<\"uuid\">;\n  };\n}\n",
  "src/api/structures/IShoppingOrderPublish.ts": "import { tags } from \"typia\";\n\nimport { IShoppingDelivery } from \"./IShoppingDelivery\";\nimport { IShoppingAddress } from \"./IShoppingAddress\";\n\n/**\n * Order completion and payment information.\n *\n * `IShoppingOrderPublish` is an entity that embodies the series of processes in\n * which a {@link IShoppingCustomer customer} pays for his or her\n * {@link IShoppingOrder order}, thereby completing the order. And only after the\n * order is {@link paid_at completed}, can the {@link IShoppingSeller seller}\n * recognize that the customer has purchased his product.\n *\n * By the way, please note that just because the `IShoppingOrderPublish` record\n * exists, it does not mean that the payment has been completed. Of course, with\n * \"credit cards\" and \"Google Pay\", payment application and payment occur at the\n * same time. However, there are some cases where payment is made after the\n * payment application, such as \"bank transfer\" or \"virtual account payment\".\n * Therefore, to see the completion of payment, be sure to check the\n * {@link paid_at} property.\n *\n * In addition, even after payment has been made, there may be cases where it is\n * suddenly cancelled, so please be aware of this as well.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IShoppingOrderPublish = {\n  /**\n   * List of deliveries.\n   *\n   * An {@link IShoppingOrder order} can be delivered in multiple times. Of\n   * course, the opposite case is also possible, that a\n   * {@link IShoppingDelivery delivery} can be composed of multiple orders.\n   *\n   * @title List of deliveries\n   */\n  deliveries: IShoppingDelivery[];\n\n  /**\n   * State of the order, about the deliveries.\n   *\n   * @title State of the order, about the deliveries\n   */\n  state:\n    | \"none\"\n    | \"underway\"\n    | \"preparing\"\n    | \"manufacturing\"\n    | \"shipping\"\n    | \"delivering\"\n    | \"arrived\";\n\n  /**\n   * Primary Key.\n   *\n   * @title Primary Key\n   */\n  id: string & tags.Format<\"uuid\">;\n\n  /**\n   * Creation time of the record.\n   *\n   * @title Creation time of the record\n   */\n  created_at: string & tags.Format<\"date-time\">;\n\n  /**\n   * Time when the order was paid.\n   *\n   * @title Time when the order was paid\n   */\n  paid_at: null | (string & tags.Format<\"date-time\">);\n\n  /**\n   * Time when the payment was cancelled.\n   *\n   * @title Time when the payment was cancelled\n   */\n  cancelled_at: null | (string & tags.Format<\"date-time\">);\n\n  /**\n   * Address where the {@link IShoppingOrderGood goods} to be delivered.\n   *\n   * @title Address where the {@link IShoppingOrderGood goods} to be delivered\n   */\n  address: IShoppingAddress;\n};\nexport namespace IShoppingOrderPublish {\n  /** Creation info of the publish. */\n  export type ICreate = {\n    /**\n     * Address to receive.\n     *\n     * @title Address to receive\n     */\n    address: IShoppingAddress.ICreate;\n\n    /**\n     * Payment identifier from the payment vendor service.\n     *\n     * If the order has been discounted for entire order price, then no need\n     * to send payment vendor info. Instead, you just configure the `null`\n     * value to this property.\n     *\n     * @title Payment identifier from the payment vendor service\n     */\n    vendor: null | IShoppingOrderPublish.IPaymentIdentifier;\n  };\n\n  /** Payment identifier from the payment vendor service. */\n  export type IPaymentIdentifier = {\n    /**\n     * The vendor code who will receive the payment.\n     *\n     * @title The vendor code who will receive the payment\n     */\n    code: string &\n      tags.JsonSchemaPlugin<{\n        \"x-wrtn-payment-vendor\": true;\n      }>;\n\n    /**\n     * The payment uid.\n     *\n     * @title The payment uid\n     */\n    uid: string &\n      tags.JsonSchemaPlugin<{\n        \"x-wrtn-payment-uid\": true;\n      }>;\n  };\n\n  /** Invert information from the delivery. */\n  export type IInvertFromDelivery = {\n    /**\n     * Primary Key.\n     *\n     * @title Primary Key\n     */\n    id: string & tags.Format<\"uuid\">;\n\n    /**\n     * Creation time of the record.\n     *\n     * @title Creation time of the record\n     */\n    created_at: string & tags.Format<\"date-time\">;\n\n    /**\n     * Time when the order was paid.\n     *\n     * @title Time when the order was paid\n     */\n    paid_at: null | (string & tags.Format<\"date-time\">);\n\n    /**\n     * Time when the payment was cancelled.\n     *\n     * @title Time when the payment was cancelled\n     */\n    cancelled_at: null | (string & tags.Format<\"date-time\">);\n\n    /**\n     * Address where the {@link IShoppingOrderGood goods} to be delivered.\n     *\n     * @title Address where the {@link IShoppingOrderGood goods} to be delivered\n     */\n    address: IShoppingAddress;\n  };\n}\n",
  "src/api/structures/IShoppingDelivery.ts": "import { tags } from \"typia\";\n\nimport { IShoppingSeller } from \"./IShoppingSeller\";\nimport { IShoppingDeliveryJourney } from \"./IShoppingDeliveryJourney\";\nimport { IShoppingDeliveryPiece } from \"./IShoppingDeliveryPiece\";\nimport { IShoppingDeliveryShipper } from \"./IShoppingDeliveryShipper\";\nimport { IShoppingOrder } from \"./IShoppingOrder\";\n\n/**\n * Delivery information.\n *\n * When delivering {@link IShoppingOrderGood goods} to\n * {@link IShoppingCustomer customer}, {@link IShoppingSeller seller} can deliver\n * multiple {@link IShoppingSaleUnitStock stocks}, goods at once. Also, it is\n * possible to deliver a stock or good in multiple times due to physical\n * restriction like volume or weight problem.\n *\n * As you can see from above, the relationship between delivery with\n * {@link IShoppingOrder order} (or {@link IShoppingOrderGood good}) is not 1: 1\n * or N: 1, but M: N. Entity `IShoppingDelivery` has been designed to represent\n * such relationship, by referencing target stocks or goods through subsidiary\n * entity {@link IShoppingDeliveryPiece}.\n *\n * Also, delivery does not end with only one step. It has multiple processes\n * like manufacturing, planning, shipping and delivering. Those steps are\n * represented by another subsidiary entity {@link IShoppingDeliveryJourney}.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IShoppingDelivery = {\n  /**\n   * Primary Key.\n   *\n   * @title Primary Key\n   */\n  id: string & tags.Format<\"uuid\">;\n\n  /**\n   * Seller who've delivered the goods.\n   *\n   * @title Seller who've delivered the goods\n   */\n  seller: IShoppingSeller;\n\n  /**\n   * List of journeys of the delivery.\n   *\n   * @title List of journeys of the delivery\n   */\n  journeys: IShoppingDeliveryJourney[];\n\n  /**\n   * List of pieces of the delivery.\n   *\n   * @title List of pieces of the delivery\n   */\n  pieces: IShoppingDeliveryPiece[] & tags.MinItems<1>;\n\n  /**\n   * List of shippers of the delivery.\n   *\n   * @title List of shippers of the delivery\n   */\n  shippers: IShoppingDeliveryShipper[];\n\n  /**\n   * State of the delivery.\n   *\n   * @title State of the delivery\n   */\n  state:\n    | \"none\"\n    | \"underway\"\n    | \"preparing\"\n    | \"manufacturing\"\n    | \"shipping\"\n    | \"delivering\"\n    | \"arrived\";\n\n  /**\n   * Creation time of the record.\n   *\n   * @title Creation time of the record\n   */\n  created_at: string & tags.Format<\"date-time\">;\n};\nexport namespace IShoppingDelivery {\n  /** Invert information of the delivery. */\n  export type IInvert = {\n    /**\n     * List of orders of the delivery.\n     *\n     * @title List of orders of the delivery\n     */\n    orders: IShoppingOrder.IInvertFromDelivery[] & tags.MinItems<1>;\n\n    /**\n     * Primary Key.\n     *\n     * @title Primary Key\n     */\n    id: string & tags.Format<\"uuid\">;\n\n    /**\n     * Seller who've delivered the goods.\n     *\n     * @title Seller who've delivered the goods\n     */\n    seller: IShoppingSeller;\n\n    /**\n     * List of journeys of the delivery.\n     *\n     * @title List of journeys of the delivery\n     */\n    journeys: IShoppingDeliveryJourney[];\n\n    /**\n     * List of pieces of the delivery.\n     *\n     * @title List of pieces of the delivery\n     */\n    pieces: IShoppingDeliveryPiece[] & tags.MinItems<1>;\n\n    /**\n     * List of shippers of the delivery.\n     *\n     * @title List of shippers of the delivery\n     */\n    shippers: IShoppingDeliveryShipper[];\n\n    /**\n     * State of the delivery.\n     *\n     * @title State of the delivery\n     */\n    state:\n      | \"none\"\n      | \"underway\"\n      | \"preparing\"\n      | \"manufacturing\"\n      | \"shipping\"\n      | \"delivering\"\n      | \"arrived\";\n\n    /**\n     * Creation time of the record.\n     *\n     * @title Creation time of the record\n     */\n    created_at: string & tags.Format<\"date-time\">;\n  };\n\n  export type IRequest = {\n    sort?: null | (\"-delivery.created_at\" | \"+delivery.created_at\")[];\n\n    /**\n     * Page number.\n     *\n     * @title Page number\n     */\n    page?: null | (number & tags.Type<\"int32\"> & tags.Minimum<0>);\n\n    /**\n     * Limitation of records per a page.\n     *\n     * @title Limitation of records per a page\n     */\n    limit?: null | (number & tags.Type<\"int32\"> & tags.Minimum<0>);\n  };\n\n  /** Creation information of the delivery. */\n  export type ICreate = {\n    /**\n     * List of pieces of the delivery.\n     *\n     * @title List of pieces of the delivery\n     */\n    pieces: IShoppingDeliveryPiece.ICreate[] & tags.MinItems<1>;\n\n    /**\n     * List of journeys of the delivery.\n     *\n     * This is initial data, and it is also possible to accumulate journey\n     * data after the delivery creation.\n     *\n     * @title List of journeys of the delivery\n     */\n    journeys: IShoppingDeliveryJourney.ICreate[];\n\n    /**\n     * List of shippers of the delivery.\n     *\n     * @title List of shippers of the delivery\n     */\n    shippers: IShoppingDeliveryShipper.ICreate[];\n  };\n}\n",
  "src/api/structures/IShoppingDeliveryJourney.ts": "import { tags } from \"typia\";\n\n/**\n * Journey of delivery.\n *\n * `IShoppingDeliveryJourney` is a subsidiary entity of\n * {@link IShoppingDelivery}, describing each journey of the delivery. For\n * reference, the word journey means each step of the delivery process, such as\n * preparing, shipping, and delivering {@link IShoppingOrderGood goods} to the\n * {@link IShoppingCustomer customer}.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IShoppingDeliveryJourney = {\n  /**\n   * Primary Key.\n   *\n   * @title Primary Key\n   */\n  id: string & tags.Format<\"uuid\">;\n\n  /**\n   * Creation time of the record.\n   *\n   * @title Creation time of the record\n   */\n  created_at: string & tags.Format<\"date-time\">;\n\n  /**\n   * Deletion time of the record.\n   *\n   * @title Deletion time of the record\n   */\n  deleted_at: null | (string & tags.Format<\"date-time\">);\n\n  /**\n   * Type of journey.\n   *\n   * - Preparing\n   * - Manufacturing\n   * - Shipping\n   * - Delivering\n   *\n   * @title Type of journey\n   */\n  type: \"preparing\" | \"manufacturing\" | \"shipping\" | \"delivering\";\n\n  /**\n   * Title of journey.\n   *\n   * @title Title of journey\n   */\n  title: null | string;\n\n  /**\n   * Description of journey.\n   *\n   * @title Description of journey\n   */\n  description: null | string;\n\n  /**\n   * Start time of the journey.\n   *\n   * @title Start time of the journey\n   */\n  started_at: null | (string & tags.Format<\"date-time\">);\n\n  /**\n   * Completion time of the journey.\n   *\n   * @title Completion time of the journey\n   */\n  completed_at: null | (string & tags.Format<\"date-time\">);\n};\nexport namespace IShoppingDeliveryJourney {\n  /** Creation information of the delivery journey. */\n  export type ICreate = {\n    /**\n     * Type of journey.\n     *\n     * - Preparing\n     * - Manufacturing\n     * - Shipping\n     * - Delivering\n     *\n     * @title Type of journey\n     */\n    type: \"preparing\" | \"manufacturing\" | \"shipping\" | \"delivering\";\n\n    /**\n     * Title of journey.\n     *\n     * @title Title of journey\n     */\n    title: null | string;\n\n    /**\n     * Description of journey.\n     *\n     * @title Description of journey\n     */\n    description: null | string;\n\n    /**\n     * Start time of the journey.\n     *\n     * @title Start time of the journey\n     */\n    started_at: null | (string & tags.Format<\"date-time\">);\n\n    /**\n     * Completion time of the journey.\n     *\n     * @title Completion time of the journey\n     */\n    completed_at: null | (string & tags.Format<\"date-time\">);\n  };\n\n  /** Completion information of the delivery journey. */\n  export type IComplete = {\n    /**\n     * Completion time of the journey.\n     *\n     * @title Completion time of the journey\n     */\n    completed_at: null | (string & tags.Format<\"date-time\">);\n  };\n}\n",
  "src/api/structures/IShoppingDeliveryPiece.ts": "import { tags } from \"typia\";\n\n/**\n * Which stocks are delivered.\n *\n * `IShoppingDeliveryPiece` is a subsidiary entity of {@link IShoppingDelivery},\n * describing how much quantity is delivered for each\n * {@link IShoppingSaleUnitStock stock} in {@link IShoppingOrder}.\n *\n * For reference, as an order can be delivered in multiple times due to volume\n * or weight problem, it is possible to have multiple `IShoppingDeliveryPiece`\n * records for a single stock.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IShoppingDeliveryPiece = {\n  /**\n   * Primary Key.\n   *\n   * @title Primary Key\n   */\n  id: string & tags.Format<\"uuid\">;\n\n  /**\n   * Target order's {@link IShoppingOrderPublish.id}.\n   *\n   * @title Target order's {@link IShoppingOrderPublish.id}\n   */\n  publish_id: string & tags.Format<\"uuid\">;\n\n  /**\n   * Target good's {@link IShoppingOrderGood.id}.\n   *\n   * @title Target good's {@link IShoppingOrderGood.id}\n   */\n  good_id: string & tags.Format<\"uuid\">;\n\n  /**\n   * Target stock's {@link IShoppingSaleUnitStock.id}.\n   *\n   * @title Target stock's {@link IShoppingSaleUnitStock.id}\n   */\n  stock_id: string & tags.Format<\"uuid\">;\n\n  /**\n   * Quantity of the stock.\n   *\n   * It can be precision value to express split shipping.\n   *\n   * @title Quantity of the stock\n   */\n  quantity: number & tags.Minimum<0>;\n};\nexport namespace IShoppingDeliveryPiece {\n  /** Creation information of the delivery piece. */\n  export type ICreate = {\n    /**\n     * Target order's {@link IShoppingOrderPublish.id}.\n     *\n     * @title Target order's {@link IShoppingOrderPublish.id}\n     */\n    publish_id: string & tags.Format<\"uuid\">;\n\n    /**\n     * Target good's {@link IShoppingOrderGood.id}.\n     *\n     * @title Target good's {@link IShoppingOrderGood.id}\n     */\n    good_id: string & tags.Format<\"uuid\">;\n\n    /**\n     * Target stock's {@link IShoppingSaleUnitStock.id}.\n     *\n     * @title Target stock's {@link IShoppingSaleUnitStock.id}\n     */\n    stock_id: string & tags.Format<\"uuid\">;\n\n    /**\n     * Quantity of the stock.\n     *\n     * It can be precision value to express split shipping.\n     *\n     * @title Quantity of the stock\n     */\n    quantity: number & tags.Minimum<0>;\n  };\n\n  export type IRequest = {\n    publish_ids: (string & tags.Format<\"uuid\">)[];\n  };\n}\n",
  "src/api/structures/IShoppingDeliveryShipper.ts": "import { tags } from \"typia\";\n\n/** @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe */\nexport type IShoppingDeliveryShipper = {\n  id: string & tags.Format<\"uuid\">;\n  created_at: string & tags.Format<\"date-time\">;\n  company: null | string;\n  name: string;\n  mobile: string;\n};\nexport namespace IShoppingDeliveryShipper {\n  export type ICreate = {\n    company: null | string;\n    name: string;\n    mobile: string;\n  };\n}\n",
  "src/api/structures/IShoppingAddress.ts": "import { tags } from \"typia\";\n\n/**\n * The address information.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IShoppingAddress = {\n  /**\n   * Primary Key.\n   *\n   * @title Primary Key\n   */\n  id: string & tags.Format<\"uuid\">;\n\n  /**\n   * Creation time of record.\n   *\n   * @title Creation time of record\n   */\n  created_at: string & tags.Format<\"date-time\">;\n\n  /**\n   * Mobile number to contact.\n   *\n   * @title Mobile number to contact\n   */\n  mobile: string & tags.Pattern<\"^[0-9]*$\">;\n\n  /**\n   * Representative name of the address.\n   *\n   * Sometimes be receiver's name, and sometimes be place name.\n   *\n   * @title Representative name of the address\n   */\n  name: string;\n\n  /**\n   * Country name.\n   *\n   * @title Country name\n   */\n  country: string;\n\n  /**\n   * Province name.\n   *\n   * @title Province name\n   */\n  province: string;\n\n  /**\n   * City name.\n   *\n   * @title City name\n   */\n  city: string;\n\n  /**\n   * Department name.\n   *\n   * @title Department name\n   */\n  department: string;\n\n  /**\n   * Detailed address containing street name, building number, and room\n   * number.\n   *\n   * @title Detailed address containing street name, building number, and room number\n   */\n  possession: string;\n\n  /**\n   * Zip code, or postal code.\n   *\n   * @title Zip code, or postal code\n   */\n  zip_code: string;\n\n  /**\n   * Special description if required.\n   *\n   * @title Special description if required\n   */\n  special_note: null | string;\n};\nexport namespace IShoppingAddress {\n  export type ICreate = {\n    /**\n     * Mobile number to contact.\n     *\n     * @title Mobile number to contact\n     */\n    mobile: string & tags.Pattern<\"^[0-9]*$\">;\n\n    /**\n     * Representative name of the address.\n     *\n     * Sometimes be receiver's name, and sometimes be place name.\n     *\n     * @title Representative name of the address\n     */\n    name: string;\n\n    /**\n     * Country name.\n     *\n     * @title Country name\n     */\n    country: string;\n\n    /**\n     * Province name.\n     *\n     * @title Province name\n     */\n    province: string;\n\n    /**\n     * City name.\n     *\n     * @title City name\n     */\n    city: string;\n\n    /**\n     * Department name.\n     *\n     * @title Department name\n     */\n    department: string;\n\n    /**\n     * Detailed address containing street name, building number, and room\n     * number.\n     *\n     * @title Detailed address containing street name, building number, and room number\n     */\n    possession: string;\n\n    /**\n     * Zip code, or postal code.\n     *\n     * @title Zip code, or postal code\n     */\n    zip_code: string;\n\n    /**\n     * Special description if required.\n     *\n     * @title Special description if required\n     */\n    special_note: null | string;\n  };\n}\n",
  "src/api/structures/IShoppingSaleReview.ts": "import { tags } from \"typia\";\n\nimport { IShoppingCustomer } from \"./IShoppingCustomer\";\nimport { IShoppingSaleInquiryAnswer } from \"./IShoppingSaleInquiryAnswer\";\nimport { IAttachmentFile } from \"./IAttachmentFile\";\n\n/**\n * Reviews for sale snapshots.\n *\n * `IShoppingSaleReview` is a subtype entity of {@link IShoppingSaleInquiry}, and\n * is used when a {@link IShoppingCustomer customer} purchases a\n * {@link IShoppingSale sale} ({@link IShoppingSaleSnapshot snapshot} at the time)\n * registered by the {@link IShoppingSeller seller} as a product and leaves a\n * review and rating for it.\n *\n * For reference, `IShoppingSaleReview` and\n * {@link IShoppingOrderGod shopping_order_goods} have a logarithmic relationship\n * of N: 1, but this does not mean that customers can continue to write reviews\n * for the same product indefinitely. Wouldn't there be restrictions, such as if\n * you write a review once, you can write an additional review a month later?\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IShoppingSaleReview = {\n  /**\n   * Type of the derived inquiry.\n   *\n   * - `question`: {@link IShoppingSaleQuestion}\n   * - `review`: {@link IShoppingSaleReview}\n   *\n   * @title Type of the derived inquiry\n   */\n  type: \"review\";\n\n  /**\n   * Customer who wrote the inquiry.\n   *\n   * @title Customer who wrote the inquiry\n   */\n  customer: IShoppingCustomer;\n\n  /**\n   * Formal answer for the inquiry by the seller.\n   *\n   * @title Formal answer for the inquiry by the seller\n   */\n  answer: null | IShoppingSaleInquiryAnswer;\n\n  /**\n   * Whether the seller has viewed the inquiry or not.\n   *\n   * @title Whether the seller has viewed the inquiry or not\n   */\n  read_by_seller: boolean;\n\n  /**\n   * Primary Key.\n   *\n   * @title Primary Key\n   */\n  id: string & tags.Format<\"uuid\">;\n\n  /**\n   * List of snapshot contents.\n   *\n   * It is created for the first time when an article is created, and is\n   * accumulated every time the article is modified.\n   *\n   * @title List of snapshot contents\n   */\n  snapshots: IShoppingSaleReview.ISnapshot[] & tags.MinItems<1>;\n\n  /**\n   * Creation time of article.\n   *\n   * @title Creation time of article\n   */\n  created_at: string & tags.Format<\"date-time\">;\n};\nexport namespace IShoppingSaleReview {\n  export type IInvertSearch = {\n    score?: null | IShoppingSaleReview.IInvertSearch.IScoreRange;\n    count?: null | IShoppingSaleReview.IInvertSearch.ICountRange;\n  };\n  export namespace IInvertSearch {\n    export type IScoreRange = {\n      minimum?: null | (number & tags.Minimum<0> & tags.Maximum<100>);\n      maximum?: null | (number & tags.Minimum<0> & tags.Maximum<100>);\n    };\n\n    export type ICountRange = {\n      minimum?: null | (number & tags.Type<\"int32\"> & tags.Minimum<0>);\n      maximum?: null | (number & tags.Type<\"int32\"> & tags.Minimum<0>);\n    };\n  }\n\n  /** Summarized information of the review. */\n  export type ISummary = {\n    /**\n     * Score of the review.\n     *\n     * @title Score of the review\n     */\n    score: number;\n\n    /**\n     * Customer who wrote the inquiry.\n     *\n     * @title Customer who wrote the inquiry\n     */\n    customer: IShoppingCustomer;\n\n    /**\n     * Formal answer for the inquiry by the seller.\n     *\n     * @title Formal answer for the inquiry by the seller\n     */\n    answer: null | IShoppingSaleInquiryAnswer.ISummary;\n\n    /**\n     * Whether the seller has viewed the inquiry or not.\n     *\n     * @title Whether the seller has viewed the inquiry or not\n     */\n    read_by_seller: boolean;\n\n    /**\n     * Primary Key.\n     *\n     * @title Primary Key\n     */\n    id: string & tags.Format<\"uuid\">;\n\n    /**\n     * Title of the last snapshot.\n     *\n     * @title Title of the last snapshot\n     */\n    title: string;\n\n    /**\n     * Creation time of the article.\n     *\n     * @title Creation time of the article\n     */\n    created_at: string & tags.Format<\"date-time\">;\n\n    /**\n     * Modification time of the article.\n     *\n     * In other words, the time when the last snapshot was created.\n     *\n     * @title Modification time of the article\n     */\n    updated_at: string & tags.Format<\"date-time\">;\n  };\n\n  /**\n   * Request of summarized information with pagination searching/sorting\n   * options.\n   */\n  export type IRequest = {\n    /**\n     * Search conditions.\n     *\n     * @title Search conditions\n     */\n    search?: null | IShoppingSaleReview.IRequest.ISearch;\n\n    /**\n     * Sorting conditions.\n     *\n     * @title Sorting conditions\n     */\n    sort?:\n      | null\n      | (\n          | \"-nickname\"\n          | \"-answered_at\"\n          | \"-created_at\"\n          | \"-updated_at\"\n          | \"-title\"\n          | \"-score\"\n          | \"+nickname\"\n          | \"+answered_at\"\n          | \"+created_at\"\n          | \"+updated_at\"\n          | \"+title\"\n          | \"+score\"\n        )[];\n\n    /**\n     * Page number.\n     *\n     * @title Page number\n     */\n    page?: null | (number & tags.Type<\"int32\"> & tags.Minimum<0>);\n\n    /**\n     * Limitation of records per a page.\n     *\n     * @title Limitation of records per a page\n     */\n    limit?: null | (number & tags.Type<\"int32\"> & tags.Minimum<0>);\n  };\n  export namespace IRequest {\n    export type ISearch = {\n      name?: null | string;\n      nickname?: null | string;\n      answered?: null | boolean;\n      title?: null | string;\n      body?: null | string;\n      title_or_body?: null | string;\n      from?: null | (string & tags.Format<\"date-time\">);\n      to?: null | (string & tags.Format<\"date-time\">);\n      minimum?: null | (number & tags.Minimum<0> & tags.Maximum<100>);\n      maximum?: null | (number & tags.Minimum<0> & tags.Maximum<100>);\n    };\n  }\n\n  /** Abridged information of the review. */\n  export type IAbridge = {\n    /**\n     * Score of the review.\n     *\n     * @title Score of the review\n     */\n    score: number & tags.Minimum<0> & tags.Maximum<100>;\n\n    /**\n     * Customer who wrote the inquiry.\n     *\n     * @title Customer who wrote the inquiry\n     */\n    customer: IShoppingCustomer;\n\n    /**\n     * Formal answer for the inquiry by the seller.\n     *\n     * @title Formal answer for the inquiry by the seller\n     */\n    answer: null | IShoppingSaleInquiryAnswer.IAbridge;\n\n    /**\n     * Whether the seller has viewed the inquiry or not.\n     *\n     * @title Whether the seller has viewed the inquiry or not\n     */\n    read_by_seller: boolean;\n\n    /**\n     * Primary Key.\n     *\n     * @title Primary Key\n     */\n    id: string & tags.Format<\"uuid\">;\n\n    /**\n     * Title of the last snapshot.\n     *\n     * @title Title of the last snapshot\n     */\n    title: string;\n\n    /**\n     * Creation time of the article.\n     *\n     * @title Creation time of the article\n     */\n    created_at: string & tags.Format<\"date-time\">;\n\n    /**\n     * Modification time of the article.\n     *\n     * In other words, the time when the last snapshot was created.\n     *\n     * @title Modification time of the article\n     */\n    updated_at: string & tags.Format<\"date-time\">;\n\n    /**\n     * Format of body.\n     *\n     * Same meaning with extension like `html`, `md`, `txt`.\n     *\n     * @title Format of body\n     */\n    format: \"html\" | \"md\" | \"txt\";\n\n    /**\n     * Content body of article.\n     *\n     * @title Content body of article\n     */\n    body: string;\n\n    /**\n     * List of attachment files.\n     *\n     * @title List of attachment files\n     */\n    files: IAttachmentFile.ICreate[];\n  };\n\n  /** Snapshot content of the review article. */\n  export type ISnapshot = {\n    /**\n     * Score of the review.\n     *\n     * @title Score of the review\n     */\n    score: number & tags.Minimum<0> & tags.Maximum<100>;\n\n    /**\n     * Primary Key.\n     *\n     * @title Primary Key\n     */\n    id: string;\n\n    /**\n     * Creation time of snapshot record.\n     *\n     * In other words, creation time or update time or article.\n     *\n     * @title Creation time of snapshot record\n     */\n    created_at: string & tags.Format<\"date-time\">;\n\n    /**\n     * Format of body.\n     *\n     * Same meaning with extension like `html`, `md`, `txt`.\n     *\n     * @title Format of body\n     */\n    format: \"html\" | \"md\" | \"txt\";\n\n    /**\n     * Title of article.\n     *\n     * @title Title of article\n     */\n    title: string;\n\n    /**\n     * Content body of article.\n     *\n     * @title Content body of article\n     */\n    body: string;\n\n    /**\n     * List of attachment files.\n     *\n     * @title List of attachment files\n     */\n    files: IAttachmentFile.ICreate[];\n  };\n\n  /** Creation information of the review. */\n  export type ICreate = {\n    /**\n     * Target good's {@link IShoppingOrderGood.id}.\n     *\n     * @title Target good's {@link IShoppingOrderGood.id}\n     */\n    good_id: string & tags.Format<\"uuid\">;\n\n    /**\n     * Score of the review.\n     *\n     * @title Score of the review\n     */\n    score: number & tags.Minimum<0> & tags.Maximum<100>;\n\n    /**\n     * Format of body.\n     *\n     * Same meaning with extension like `html`, `md`, `txt`.\n     *\n     * @title Format of body\n     */\n    format: \"html\" | \"md\" | \"txt\";\n\n    /**\n     * Title of article.\n     *\n     * @title Title of article\n     */\n    title: string;\n\n    /**\n     * Content body of article.\n     *\n     * @title Content body of article\n     */\n    body: string;\n\n    /**\n     * List of attachment files.\n     *\n     * @title List of attachment files\n     */\n    files: IAttachmentFile.ICreate[];\n  };\n\n  /** Updating information of the review. */\n  export type IUpdate = {\n    /**\n     * Score of the review.\n     *\n     * @title Score of the review\n     */\n    score: number & tags.Minimum<0> & tags.Maximum<100>;\n\n    /**\n     * Format of body.\n     *\n     * Same meaning with extension like `html`, `md`, `txt`.\n     *\n     * @title Format of body\n     */\n    format: \"html\" | \"md\" | \"txt\";\n\n    /**\n     * Title of article.\n     *\n     * @title Title of article\n     */\n    title: string;\n\n    /**\n     * Content body of article.\n     *\n     * @title Content body of article\n     */\n    body: string;\n\n    /**\n     * List of attachment files.\n     *\n     * @title List of attachment files\n     */\n    files: IAttachmentFile.ICreate[];\n  };\n}\n",
  "src/api/structures/IPageIShoppingSale.ts": "import { IPage } from \"./IPage\";\nimport { IShoppingSale } from \"./IShoppingSale\";\n\n/**\n * A page.\n *\n * Collection of records with pagination indformation.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IPageIShoppingSale = {\n  /**\n   * Page information.\n   *\n   * @title Page information\n   */\n  pagination: IPage.IPagination;\n\n  /**\n   * List of records.\n   *\n   * @title List of records\n   */\n  data: IShoppingSale[];\n};\nexport namespace IPageIShoppingSale {\n  /**\n   * A page.\n   *\n   * Collection of records with pagination indformation.\n   */\n  export type ISummary = {\n    /**\n     * Page information.\n     *\n     * @title Page information\n     */\n    pagination: IPage.IPagination;\n\n    /**\n     * List of records.\n     *\n     * @title List of records\n     */\n    data: IShoppingSale.ISummary[];\n  };\n}\n",
  "src/api/structures/IPageIShoppingSaleInquiryComment.ts": "import { IPage } from \"./IPage\";\nimport { IShoppingSaleInquiryComment } from \"./IShoppingSaleInquiryComment\";\n\n/**\n * A page.\n *\n * Collection of records with pagination indformation.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IPageIShoppingSaleInquiryComment = {\n  /**\n   * Page information.\n   *\n   * @title Page information\n   */\n  pagination: IPage.IPagination;\n\n  /**\n   * List of records.\n   *\n   * @title List of records\n   */\n  data: IShoppingSaleInquiryComment[];\n};\n",
  "src/api/structures/IShoppingSaleInquiryComment.ts": "import { tags } from \"typia\";\n\nimport { IShoppingAdministrator } from \"./IShoppingAdministrator\";\nimport { IShoppingCustomer } from \"./IShoppingCustomer\";\nimport { IShoppingSeller } from \"./IShoppingSeller\";\nimport { IBbsArticleComment } from \"./IBbsArticleComment\";\nimport { IAttachmentFile } from \"./IAttachmentFile\";\n\n/**\n * A comment written on an inquiry article.\n *\n * `IShoppingSaleInquiryComment` is a subtype entity of\n * {@link IBbsArticleComment}, and is used when you want to communicate with\n * multiple people about an {@link IShoppingSaleInquiry inquiry} written by a\n * {@link IShoppingCustomer customer}.\n *\n * For reference, only related parties can write comments for\n * {@link IShoppingSeller sellers}, but there is no limit to\n * {@link IShoppingCustomer customers}. In other words, anyone customer can\n * freely write a comment, even if they are not the person who wrote the\n * inquiry.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IShoppingSaleInquiryComment = {\n  /**\n   * Writer of the comment.\n   *\n   * Both customer and seller can write comment on the sale inquiry.\n   *\n   * By the way, no restriction on the customer, but seller must be the person\n   * who've registered the sale.\n   *\n   * @title Writer of the comment\n   */\n  writer:\n    | IShoppingAdministrator.IInvert\n    | IShoppingCustomer\n    | IShoppingSeller.IInvert;\n\n  /**\n   * Primary Key.\n   *\n   * @title Primary Key\n   */\n  id: string & tags.Format<\"uuid\">;\n\n  /**\n   * Parent comment's ID.\n   *\n   * @title Parent comment's ID\n   */\n  parent_id: null | (string & tags.Format<\"uuid\">);\n\n  /**\n   * List of snapshot contents.\n   *\n   * It is created for the first time when a comment being created, and is\n   * accumulated every time the comment is modified.\n   *\n   * @title List of snapshot contents\n   */\n  snapshots: IBbsArticleComment.ISnapshot[] & tags.MinItems<1>;\n\n  /**\n   * Creation time of comment.\n   *\n   * @title Creation time of comment\n   */\n  created_at: string & tags.Format<\"date-time\">;\n};\nexport namespace IShoppingSaleInquiryComment {\n  /** Request of the comments with pagination and searching/sorting options. */\n  export type IRequest = {\n    search?: null | IShoppingSaleInquiryComment.IRequest.ISearch;\n    sort?: null | (\"-created_at\" | \"+created_at\")[];\n\n    /**\n     * Page number.\n     *\n     * @title Page number\n     */\n    page?: null | (number & tags.Type<\"int32\"> & tags.Minimum<0>);\n\n    /**\n     * Limitation of records per a page.\n     *\n     * @title Limitation of records per a page\n     */\n    limit?: null | (number & tags.Type<\"int32\"> & tags.Minimum<0>);\n  };\n  export namespace IRequest {\n    export type ISearch = {\n      name?: null | string;\n      nickname?: null | string;\n      body?: null | string;\n    };\n  }\n\n  /** Creation information of the comment. */\n  export type ICreate = {\n    /**\n     * Format of body.\n     *\n     * Same meaning with extension like `html`, `md`, `txt`.\n     *\n     * @title Format of body\n     */\n    format: \"html\" | \"md\" | \"txt\";\n\n    /**\n     * Content body of comment.\n     *\n     * @title Content body of comment\n     */\n    body: string;\n\n    /**\n     * List of attachment files.\n     *\n     * @title List of attachment files\n     */\n    files: IAttachmentFile.ICreate[];\n  };\n\n  /** Snapshot content of the comment. */\n  export type ISnapshot = {\n    /**\n     * Primary Key.\n     *\n     * @title Primary Key\n     */\n    id: string & tags.Format<\"uuid\">;\n\n    /**\n     * Creation time of snapshot record.\n     *\n     * In other words, creation time or update time or comment.\n     *\n     * @title Creation time of snapshot record\n     */\n    created_at: string & tags.Format<\"date-time\">;\n\n    /**\n     * Format of body.\n     *\n     * Same meaning with extension like `html`, `md`, `txt`.\n     *\n     * @title Format of body\n     */\n    format: \"html\" | \"md\" | \"txt\";\n\n    /**\n     * Content body of comment.\n     *\n     * @title Content body of comment\n     */\n    body: string;\n\n    /**\n     * List of attachment files.\n     *\n     * @title List of attachment files\n     */\n    files: IAttachmentFile.ICreate[];\n  };\n}\n",
  "src/api/structures/IBbsArticleComment.ts": "import { tags } from \"typia\";\n\nimport { IAttachmentFile } from \"./IAttachmentFile\";\n\nexport namespace IBbsArticleComment {\n  /**\n   * Snapshot of comment.\n   *\n   * `IBbsArticleComment.ISnapshot` is a snapshot entity that contains the\n   * contents of the comment.\n   *\n   * As mentioned in {@link IBbsArticleComment}, designed to keep evidence and\n   * prevent fraud.\n   */\n  export type ISnapshot = {\n    /**\n     * Primary Key.\n     *\n     * @title Primary Key\n     */\n    id: string & tags.Format<\"uuid\">;\n\n    /**\n     * Creation time of snapshot record.\n     *\n     * In other words, creation time or update time or comment.\n     *\n     * @title Creation time of snapshot record\n     */\n    created_at: string & tags.Format<\"date-time\">;\n\n    /**\n     * Format of body.\n     *\n     * Same meaning with extension like `html`, `md`, `txt`.\n     *\n     * @title Format of body\n     */\n    format: \"html\" | \"md\" | \"txt\";\n\n    /**\n     * Content body of comment.\n     *\n     * @title Content body of comment\n     */\n    body: string;\n\n    /**\n     * List of attachment files.\n     *\n     * @title List of attachment files\n     */\n    files: IAttachmentFile.ICreate[];\n  };\n}\n",
  "src/api/structures/IPageIShoppingSaleQuestion.ts": "import { IPage } from \"./IPage\";\nimport { IShoppingSaleQuestion } from \"./IShoppingSaleQuestion\";\n\nexport namespace IPageIShoppingSaleQuestion {\n  /**\n   * A page.\n   *\n   * Collection of records with pagination indformation.\n   */\n  export type ISummary = {\n    /**\n     * Page information.\n     *\n     * @title Page information\n     */\n    pagination: IPage.IPagination;\n\n    /**\n     * List of records.\n     *\n     * @title List of records\n     */\n    data: IShoppingSaleQuestion.ISummary[];\n  };\n\n  /**\n   * A page.\n   *\n   * Collection of records with pagination indformation.\n   */\n  export type IAbridge = {\n    /**\n     * Page information.\n     *\n     * @title Page information\n     */\n    pagination: IPage.IPagination;\n\n    /**\n     * List of records.\n     *\n     * @title List of records\n     */\n    data: IShoppingSaleQuestion.IAbridge[];\n  };\n}\n",
  "src/api/structures/IShoppingSaleQuestion.ts": "import { tags } from \"typia\";\n\nimport { IShoppingCustomer } from \"./IShoppingCustomer\";\nimport { IShoppingSaleInquiryAnswer } from \"./IShoppingSaleInquiryAnswer\";\nimport { IBbsArticle } from \"./IBbsArticle\";\nimport { IShoppingSaleInquiry } from \"./IShoppingSaleInquiry\";\nimport { IAttachmentFile } from \"./IAttachmentFile\";\n\n/**\n * Question about sale snapshot.\n *\n * `IShoppingSaleQuestion` is a subtype entity of {@link IShoppingSaleInquiry},\n * and is used when a {@link IShoppingCustomer customer} wants to ask something\n * about a {@link IShoppingSale sale} ({@link IShoppingSaleSnapshot snapshot} at\n * the time) registered by the {@link IShoppingSeller seller}.\n *\n * And, like most shopping malls, `IShoppingSaleQuestion` also provides a\n * {@link secret} attribute, allowing you to create a \"secret message\" that can\n * only be viewed by the seller and the customer who wrote the question.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IShoppingSaleQuestion = {\n  /**\n   * Whether the question article is secret or not.\n   *\n   * If secret article, only the writer customer and related seller can see\n   * the detailed content.\n   *\n   * @title Whether the question article is secret or not\n   */\n  secret: boolean;\n\n  /**\n   * Type of the derived inquiry.\n   *\n   * - `question`: {@link IShoppingSaleQuestion}\n   * - `review`: {@link IShoppingSaleReview}\n   *\n   * @title Type of the derived inquiry\n   */\n  type: \"question\";\n\n  /**\n   * Customer who wrote the inquiry.\n   *\n   * @title Customer who wrote the inquiry\n   */\n  customer: IShoppingCustomer;\n\n  /**\n   * Formal answer for the inquiry by the seller.\n   *\n   * @title Formal answer for the inquiry by the seller\n   */\n  answer: null | IShoppingSaleInquiryAnswer;\n\n  /**\n   * Whether the seller has viewed the inquiry or not.\n   *\n   * @title Whether the seller has viewed the inquiry or not\n   */\n  read_by_seller: boolean;\n\n  /**\n   * Primary Key.\n   *\n   * @title Primary Key\n   */\n  id: string & tags.Format<\"uuid\">;\n\n  /**\n   * List of snapshot contents.\n   *\n   * It is created for the first time when an article is created, and is\n   * accumulated every time the article is modified.\n   *\n   * @title List of snapshot contents\n   */\n  snapshots: IBbsArticle.ISnapshot[] & tags.MinItems<1>;\n\n  /**\n   * Creation time of article.\n   *\n   * @title Creation time of article\n   */\n  created_at: string & tags.Format<\"date-time\">;\n};\nexport namespace IShoppingSaleQuestion {\n  /** Summarized information of the question. */\n  export type ISummary = {\n    /**\n     * Whether the question article is secret or not.\n     *\n     * If secret article, only the writer customer and related seller can\n     * see the detailed content.\n     *\n     * @title Whether the question article is secret or not\n     */\n    secret: boolean;\n\n    /**\n     * Customer who wrote the inquiry.\n     *\n     * @title Customer who wrote the inquiry\n     */\n    customer: IShoppingCustomer;\n\n    /**\n     * Formal answer for the inquiry by the seller.\n     *\n     * @title Formal answer for the inquiry by the seller\n     */\n    answer: null | IShoppingSaleInquiryAnswer.ISummary;\n\n    /**\n     * Whether the seller has viewed the inquiry or not.\n     *\n     * @title Whether the seller has viewed the inquiry or not\n     */\n    read_by_seller: boolean;\n\n    /**\n     * Primary Key.\n     *\n     * @title Primary Key\n     */\n    id: string & tags.Format<\"uuid\">;\n\n    /**\n     * Title of the last snapshot.\n     *\n     * @title Title of the last snapshot\n     */\n    title: string;\n\n    /**\n     * Creation time of the article.\n     *\n     * @title Creation time of the article\n     */\n    created_at: string & tags.Format<\"date-time\">;\n\n    /**\n     * Modification time of the article.\n     *\n     * In other words, the time when the last snapshot was created.\n     *\n     * @title Modification time of the article\n     */\n    updated_at: string & tags.Format<\"date-time\">;\n  };\n\n  /**\n   * Request of summarized information with pagination searching/sorting\n   * options.\n   */\n  export type IRequest = {\n    /**\n     * Search conditions.\n     *\n     * @title Search conditions\n     */\n    search?: null | IShoppingSaleInquiry.IRequest.ISearch;\n\n    /**\n     * Sorting conditions.\n     *\n     * @title Sorting conditions\n     */\n    sort?:\n      | null\n      | (\n          | \"-nickname\"\n          | \"-answered_at\"\n          | \"-created_at\"\n          | \"-updated_at\"\n          | \"-title\"\n          | \"+nickname\"\n          | \"+answered_at\"\n          | \"+created_at\"\n          | \"+updated_at\"\n          | \"+title\"\n        )[];\n\n    /**\n     * Page number.\n     *\n     * @title Page number\n     */\n    page?: null | (number & tags.Type<\"int32\"> & tags.Minimum<0>);\n\n    /**\n     * Limitation of records per a page.\n     *\n     * @title Limitation of records per a page\n     */\n    limit?: null | (number & tags.Type<\"int32\"> & tags.Minimum<0>);\n  };\n\n  /** Abridged information of the question. */\n  export type IAbridge = {\n    /**\n     * Whether the question article is secret or not.\n     *\n     * If secret article, only the writer customer and related seller can\n     * see the detailed content.\n     *\n     * @title Whether the question article is secret or not\n     */\n    secret: boolean;\n\n    /**\n     * Customer who wrote the inquiry.\n     *\n     * @title Customer who wrote the inquiry\n     */\n    customer: IShoppingCustomer;\n\n    /**\n     * Formal answer for the inquiry by the seller.\n     *\n     * @title Formal answer for the inquiry by the seller\n     */\n    answer: null | IShoppingSaleInquiryAnswer.IAbridge;\n\n    /**\n     * Whether the seller has viewed the inquiry or not.\n     *\n     * @title Whether the seller has viewed the inquiry or not\n     */\n    read_by_seller: boolean;\n\n    /**\n     * Primary Key.\n     *\n     * @title Primary Key\n     */\n    id: string & tags.Format<\"uuid\">;\n\n    /**\n     * Title of the last snapshot.\n     *\n     * @title Title of the last snapshot\n     */\n    title: string;\n\n    /**\n     * Creation time of the article.\n     *\n     * @title Creation time of the article\n     */\n    created_at: string & tags.Format<\"date-time\">;\n\n    /**\n     * Modification time of the article.\n     *\n     * In other words, the time when the last snapshot was created.\n     *\n     * @title Modification time of the article\n     */\n    updated_at: string & tags.Format<\"date-time\">;\n\n    /**\n     * Format of body.\n     *\n     * Same meaning with extension like `html`, `md`, `txt`.\n     *\n     * @title Format of body\n     */\n    format: \"html\" | \"md\" | \"txt\";\n\n    /**\n     * Content body of article.\n     *\n     * @title Content body of article\n     */\n    body: string;\n\n    /**\n     * List of attachment files.\n     *\n     * @title List of attachment files\n     */\n    files: IAttachmentFile.ICreate[];\n  };\n\n  /** Creation information of the question. */\n  export type ICreate = {\n    /**\n     * Whether the question article is secret or not.\n     *\n     * If secret article, only the writer customer and related seller can\n     * see the detailed content.\n     *\n     * @title Whether the question article is secret or not\n     */\n    secret: boolean;\n\n    /**\n     * Format of body.\n     *\n     * Same meaning with extension like `html`, `md`, `txt`.\n     *\n     * @title Format of body\n     */\n    format: \"html\" | \"md\" | \"txt\";\n\n    /**\n     * Title of article.\n     *\n     * @title Title of article\n     */\n    title: string;\n\n    /**\n     * Content body of article.\n     *\n     * @title Content body of article\n     */\n    body: string;\n\n    /**\n     * List of attachment files.\n     *\n     * @title List of attachment files\n     */\n    files: IAttachmentFile.ICreate[];\n  };\n}\n",
  "src/api/structures/IShoppingSaleInquiryAnswer.ts": "import { tags } from \"typia\";\n\nimport { IShoppingSeller } from \"./IShoppingSeller\";\nimport { IBbsArticle } from \"./IBbsArticle\";\nimport { IAttachmentFile } from \"./IAttachmentFile\";\n\n/**\n * Answers to questions about sale snapshots.\n *\n * `IShoppingSaleInquiryAnswer` is an entity that embodies the official answer\n * written by the {@link IShoppingSeller seller} to the\n * {@link IShoppingSaleInquiry inquiry} written by the\n * {@link IShoppingCustomer customer}.\n *\n * Of course, in addition to writing an official response like this, it is also\n * possible for the seller to communicate with the inqjuiry written customer and\n * multiple customers through {@link IShoppingSaleInquiryComment comments} in the\n * attribution inquiry.\n *\n * For reference, it is not possible to write comments on this answer. Encourage\n * people to write comments on the inquiry article. This is to prevent comments\n * from being scattered in both inquiry and answer articles.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IShoppingSaleInquiryAnswer = {\n  /**\n   * Seller who've written the answer.\n   *\n   * @title Seller who've written the answer\n   */\n  seller: IShoppingSeller;\n\n  /**\n   * Primary Key.\n   *\n   * @title Primary Key\n   */\n  id: string & tags.Format<\"uuid\">;\n\n  /**\n   * List of snapshot contents.\n   *\n   * It is created for the first time when an article is created, and is\n   * accumulated every time the article is modified.\n   *\n   * @title List of snapshot contents\n   */\n  snapshots: IBbsArticle.ISnapshot[] & tags.MinItems<1>;\n\n  /**\n   * Creation time of article.\n   *\n   * @title Creation time of article\n   */\n  created_at: string & tags.Format<\"date-time\">;\n};\nexport namespace IShoppingSaleInquiryAnswer {\n  export type ISummary = {\n    seller: IShoppingSeller;\n\n    /**\n     * Primary Key.\n     *\n     * @title Primary Key\n     */\n    id: string & tags.Format<\"uuid\">;\n\n    /**\n     * Title of the last snapshot.\n     *\n     * @title Title of the last snapshot\n     */\n    title: string;\n\n    /**\n     * Creation time of the article.\n     *\n     * @title Creation time of the article\n     */\n    created_at: string & tags.Format<\"date-time\">;\n\n    /**\n     * Modification time of the article.\n     *\n     * In other words, the time when the last snapshot was created.\n     *\n     * @title Modification time of the article\n     */\n    updated_at: string & tags.Format<\"date-time\">;\n  };\n\n  export type IAbridge = {\n    seller: IShoppingSeller;\n\n    /**\n     * Primary Key.\n     *\n     * @title Primary Key\n     */\n    id: string & tags.Format<\"uuid\">;\n\n    /**\n     * Title of the last snapshot.\n     *\n     * @title Title of the last snapshot\n     */\n    title: string;\n\n    /**\n     * Creation time of the article.\n     *\n     * @title Creation time of the article\n     */\n    created_at: string & tags.Format<\"date-time\">;\n\n    /**\n     * Modification time of the article.\n     *\n     * In other words, the time when the last snapshot was created.\n     *\n     * @title Modification time of the article\n     */\n    updated_at: string & tags.Format<\"date-time\">;\n\n    /**\n     * Format of body.\n     *\n     * Same meaning with extension like `html`, `md`, `txt`.\n     *\n     * @title Format of body\n     */\n    format: \"html\" | \"md\" | \"txt\";\n\n    /**\n     * Content body of article.\n     *\n     * @title Content body of article\n     */\n    body: string;\n\n    /**\n     * List of attachment files.\n     *\n     * @title List of attachment files\n     */\n    files: IAttachmentFile.ICreate[];\n  };\n\n  export type ISnapshot = {\n    /**\n     * Primary Key.\n     *\n     * @title Primary Key\n     */\n    id: string;\n\n    /**\n     * Creation time of snapshot record.\n     *\n     * In other words, creation time or update time or article.\n     *\n     * @title Creation time of snapshot record\n     */\n    created_at: string & tags.Format<\"date-time\">;\n\n    /**\n     * Format of body.\n     *\n     * Same meaning with extension like `html`, `md`, `txt`.\n     *\n     * @title Format of body\n     */\n    format: \"html\" | \"md\" | \"txt\";\n\n    /**\n     * Title of article.\n     *\n     * @title Title of article\n     */\n    title: string;\n\n    /**\n     * Content body of article.\n     *\n     * @title Content body of article\n     */\n    body: string;\n\n    /**\n     * List of attachment files.\n     *\n     * @title List of attachment files\n     */\n    files: IAttachmentFile.ICreate[];\n  };\n}\n",
  "src/api/structures/IShoppingSaleInquiry.ts": "import { tags } from \"typia\";\n\nexport namespace IShoppingSaleInquiry {\n  export namespace IRequest {\n    export type ISearch = {\n      name?: null | string;\n      nickname?: null | string;\n      answered?: null | boolean;\n      title?: null | string;\n      body?: null | string;\n      title_or_body?: null | string;\n      from?: null | (string & tags.Format<\"date-time\">);\n      to?: null | (string & tags.Format<\"date-time\">);\n    };\n  }\n}\n",
  "src/api/structures/IBbsArticle.ts": "import { tags } from \"typia\";\n\nimport { IAttachmentFile } from \"./IAttachmentFile\";\n\nexport namespace IBbsArticle {\n  /**\n   * Snapshot of article.\n   *\n   * `IBbsArticle.ISnapshot` is a snapshot entity that contains the contents\n   * of the article, as mentioned in {@link IBbsArticle}, the contents of the\n   * article are separated from the article record to keep evidence and\n   * prevent fraud.\n   */\n  export type ISnapshot = {\n    /**\n     * Primary Key.\n     *\n     * @title Primary Key\n     */\n    id: string;\n\n    /**\n     * Creation time of snapshot record.\n     *\n     * In other words, creation time or update time or article.\n     *\n     * @title Creation time of snapshot record\n     */\n    created_at: string & tags.Format<\"date-time\">;\n\n    /**\n     * Format of body.\n     *\n     * Same meaning with extension like `html`, `md`, `txt`.\n     *\n     * @title Format of body\n     */\n    format: \"html\" | \"md\" | \"txt\";\n\n    /**\n     * Title of article.\n     *\n     * @title Title of article\n     */\n    title: string;\n\n    /**\n     * Content body of article.\n     *\n     * @title Content body of article\n     */\n    body: string;\n\n    /**\n     * List of attachment files.\n     *\n     * @title List of attachment files\n     */\n    files: IAttachmentFile.ICreate[];\n  };\n\n  /** Creation information of the article. */\n  export type ICreate = {\n    /**\n     * Format of body.\n     *\n     * Same meaning with extension like `html`, `md`, `txt`.\n     *\n     * @title Format of body\n     */\n    format: \"html\" | \"md\" | \"txt\";\n\n    /**\n     * Title of article.\n     *\n     * @title Title of article\n     */\n    title: string;\n\n    /**\n     * Content body of article.\n     *\n     * @title Content body of article\n     */\n    body: string;\n\n    /**\n     * List of attachment files.\n     *\n     * @title List of attachment files\n     */\n    files: IAttachmentFile.ICreate[];\n  };\n}\n",
  "src/api/structures/IPageIShoppingSaleReview.ts": "import { IPage } from \"./IPage\";\nimport { IShoppingSaleReview } from \"./IShoppingSaleReview\";\n\nexport namespace IPageIShoppingSaleReview {\n  /**\n   * A page.\n   *\n   * Collection of records with pagination indformation.\n   */\n  export type ISummary = {\n    /**\n     * Page information.\n     *\n     * @title Page information\n     */\n    pagination: IPage.IPagination;\n\n    /**\n     * List of records.\n     *\n     * @title List of records\n     */\n    data: IShoppingSaleReview.ISummary[];\n  };\n\n  /**\n   * A page.\n   *\n   * Collection of records with pagination indformation.\n   */\n  export type IAbridge = {\n    /**\n     * Page information.\n     *\n     * @title Page information\n     */\n    pagination: IPage.IPagination;\n\n    /**\n     * List of records.\n     *\n     * @title List of records\n     */\n    data: IShoppingSaleReview.IAbridge[];\n  };\n}\n",
  "src/api/structures/IPageIShoppingSaleSnapshot.ts": "import { IPage } from \"./IPage\";\nimport { IShoppingSaleSnapshot } from \"./IShoppingSaleSnapshot\";\n\nexport namespace IPageIShoppingSaleSnapshot {\n  /**\n   * A page.\n   *\n   * Collection of records with pagination indformation.\n   */\n  export type ISummary = {\n    /**\n     * Page information.\n     *\n     * @title Page information\n     */\n    pagination: IPage.IPagination;\n\n    /**\n     * List of records.\n     *\n     * @title List of records\n     */\n    data: IShoppingSaleSnapshot.ISummary[];\n  };\n}\n",
  "src/api/structures/IRecordMerge.ts": "import { tags } from \"typia\";\n\n/**\n * Record Merge DTO.\n *\n * `IRecordMerge` is a structure for merging records.\n *\n * The `merge` means that merging multiple {@link IRecordMerge.absorbed} records\n * into {@link IRecordMerge.keep} instead of deleting\n * {@link IRecordMerge.absorbed} records.\n *\n * If there're some dependent tables of the target `table` having unique\n * constraint on foreign key column, such dependent tables also perform the\n * merge process, too.\n *\n * Of course, if there're another dependent tables under those dependents, they\n * also perform the merge process recursively as well. Such recursive merge\n * process still works for self-recursive (tree-structured) tables.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IRecordMerge = {\n  /**\n   * Target record to keep after merging.\n   *\n   * After merge process, {@link absorbed} records would be merged into this\n   * {@link keep} record.\n   *\n   * @title Target record to keep after merging\n   */\n  keep: string & tags.Format<\"uuid\">;\n\n  /**\n   * To be absorbed to {@link keep} after merging.\n   *\n   * @title To be absorbed to {@link keep} after merging\n   */\n  absorbed: (string & tags.Format<\"uuid\">)[];\n};\n",
  "src/api/structures/IPageIShoppingChannel.ts": "import { IPage } from \"./IPage\";\nimport { IShoppingChannel } from \"./IShoppingChannel\";\n\n/**\n * A page.\n *\n * Collection of records with pagination indformation.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IPageIShoppingChannel = {\n  /**\n   * Page information.\n   *\n   * @title Page information\n   */\n  pagination: IPage.IPagination;\n\n  /**\n   * List of records.\n   *\n   * @title List of records\n   */\n  data: IShoppingChannel[];\n};\nexport namespace IPageIShoppingChannel {\n  /**\n   * A page.\n   *\n   * Collection of records with pagination indformation.\n   */\n  export type IHierarchical = {\n    /**\n     * Page information.\n     *\n     * @title Page information\n     */\n    pagination: IPage.IPagination;\n\n    /**\n     * List of records.\n     *\n     * @title List of records\n     */\n    data: IShoppingChannel.IHierarchical[];\n  };\n}\n",
  "src/api/structures/IPageIShoppingSection.ts": "import { IPage } from \"./IPage\";\nimport { IShoppingSection } from \"./IShoppingSection\";\n\n/**\n * A page.\n *\n * Collection of records with pagination indformation.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IPageIShoppingSection = {\n  /**\n   * Page information.\n   *\n   * @title Page information\n   */\n  pagination: IPage.IPagination;\n\n  /**\n   * List of records.\n   *\n   * @title List of records\n   */\n  data: IShoppingSection[];\n};\n",
  "src/api/structures/IPageIShoppingCouponTicket.ts": "import { IPage } from \"./IPage\";\nimport { IShoppingCouponTicket } from \"./IShoppingCouponTicket\";\n\n/**\n * A page.\n *\n * Collection of records with pagination indformation.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IPageIShoppingCouponTicket = {\n  /**\n   * Page information.\n   *\n   * @title Page information\n   */\n  pagination: IPage.IPagination;\n\n  /**\n   * List of records.\n   *\n   * @title List of records\n   */\n  data: IShoppingCouponTicket[];\n};\n",
  "src/api/structures/IPageIShoppingDepositCharge.ts": "import { IPage } from \"./IPage\";\nimport { IShoppingDepositCharge } from \"./IShoppingDepositCharge\";\n\n/**\n * A page.\n *\n * Collection of records with pagination indformation.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IPageIShoppingDepositCharge = {\n  /**\n   * Page information.\n   *\n   * @title Page information\n   */\n  pagination: IPage.IPagination;\n\n  /**\n   * List of records.\n   *\n   * @title List of records\n   */\n  data: IShoppingDepositCharge[];\n};\n",
  "src/api/structures/IShoppingDepositCharge.ts": "import { tags } from \"typia\";\n\nimport { IShoppingCustomer } from \"./IShoppingCustomer\";\nimport { IShoppingDepositChargePublish } from \"./IShoppingDepositChargePublish\";\n\n/** @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe */\nexport type IShoppingDepositCharge = {\n  id: string & tags.Format<\"uuid\">;\n  customer: IShoppingCustomer;\n  publish: null | IShoppingDepositChargePublish;\n  created_at: string & tags.Format<\"date-time\">;\n  value: number;\n};\nexport namespace IShoppingDepositCharge {\n  export type IRequest = {\n    search?: null | IShoppingDepositCharge.IRequest.ISearch;\n    sort?:\n      | null\n      | (\n          | \"-created_at\"\n          | \"+created_at\"\n          | \"-value\"\n          | \"-publish.created_at\"\n          | \"-publish.paid_at\"\n          | \"+value\"\n          | \"+publish.created_at\"\n          | \"+publish.paid_at\"\n        )[];\n\n    /**\n     * Page number.\n     *\n     * @title Page number\n     */\n    page?: null | (number & tags.Type<\"int32\"> & tags.Minimum<0>);\n\n    /**\n     * Limitation of records per a page.\n     *\n     * @title Limitation of records per a page\n     */\n    limit?: null | (number & tags.Type<\"int32\"> & tags.Minimum<0>);\n  };\n  export namespace IRequest {\n    export type ISearch = {\n      from?: null | (string & tags.Format<\"date-time\">);\n      to?: null | (string & tags.Format<\"date-time\">);\n      minimum?: null | number;\n      maximum?: null | number;\n      state: null | \"paid\" | \"published\" | \"pending\" | \"cancelled\";\n      publish?: null | {\n        from?: null | (string & tags.Format<\"date-time\">);\n        to?: null | (string & tags.Format<\"date-time\">);\n        payment?: null | {\n          from?: null | (string & tags.Format<\"date-time\">);\n          to?: null | (string & tags.Format<\"date-time\">);\n        };\n      };\n    };\n  }\n\n  export type ICreate = {\n    value: number;\n  };\n}\n",
  "src/api/structures/IShoppingDepositChargePublish.ts": "import { tags } from \"typia\";\n\n/** @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe */\nexport type IShoppingDepositChargePublish = {\n  id: string & tags.Format<\"uuid\">;\n  created_at: string & tags.Format<\"date-time\">;\n  paid_at: null | (string & tags.Format<\"date-time\">);\n  cancelled_at: null | (string & tags.Format<\"date-time\">);\n};\nexport namespace IShoppingDepositChargePublish {\n  export type ICreate = {\n    vendor: string;\n    uid: string;\n  };\n}\n",
  "src/api/structures/IPageIShoppingDepositHistory.ts": "import { IPage } from \"./IPage\";\nimport { IShoppingDepositHistory } from \"./IShoppingDepositHistory\";\n\n/**\n * A page.\n *\n * Collection of records with pagination indformation.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IPageIShoppingDepositHistory = {\n  /**\n   * Page information.\n   *\n   * @title Page information\n   */\n  pagination: IPage.IPagination;\n\n  /**\n   * List of records.\n   *\n   * @title List of records\n   */\n  data: IShoppingDepositHistory[];\n};\n",
  "src/api/structures/IShoppingDepositHistory.ts": "import { tags } from \"typia\";\n\nimport { IShoppingCitizen } from \"./IShoppingCitizen\";\nimport { IShoppingDeposit } from \"./IShoppingDeposit\";\n\n/** @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe */\nexport type IShoppingDepositHistory = {\n  id: string & tags.Format<\"uuid\">;\n  citizen: IShoppingCitizen;\n  deposit: IShoppingDeposit;\n  source_id: string & tags.Format<\"uuid\">;\n  value: number;\n  balance: number;\n  created_at: string & tags.Format<\"date-time\">;\n};\nexport namespace IShoppingDepositHistory {\n  export type IRequest = {\n    search?: null | IShoppingDepositHistory.IRequest.ISearch;\n    sort?:\n      | null\n      | (\n          | \"-deposit.source\"\n          | \"-deposit.code\"\n          | \"-deposit.direction\"\n          | \"+deposit.source\"\n          | \"+deposit.code\"\n          | \"+deposit.direction\"\n          | \"-history.value\"\n          | \"-history.created_at\"\n          | \"+history.value\"\n          | \"+history.created_at\"\n        )[];\n\n    /**\n     * Page number.\n     *\n     * @title Page number\n     */\n    page?: null | (number & tags.Type<\"int32\"> & tags.Minimum<0>);\n\n    /**\n     * Limitation of records per a page.\n     *\n     * @title Limitation of records per a page\n     */\n    limit?: null | (number & tags.Type<\"int32\"> & tags.Minimum<0>);\n  };\n  export namespace IRequest {\n    export type ISearch = {\n      deposit?: null | IShoppingDeposit.IRequest.ISearch;\n      citizen_id?: null | (string & tags.Format<\"uuid\">);\n      from?: null | (string & tags.Format<\"date-time\">);\n      to?: null | (string & tags.Format<\"date-time\">);\n      minimum?: null | (number & tags.Minimum<0>);\n      maximum?: null | (number & tags.Minimum<0>);\n    };\n  }\n}\n",
  "src/api/structures/IPageIShoppingMileageHistory.ts": "import { IPage } from \"./IPage\";\nimport { IShoppingMileageHistory } from \"./IShoppingMileageHistory\";\n\n/**\n * A page.\n *\n * Collection of records with pagination indformation.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IPageIShoppingMileageHistory = {\n  /**\n   * Page information.\n   *\n   * @title Page information\n   */\n  pagination: IPage.IPagination;\n\n  /**\n   * List of records.\n   *\n   * @title List of records\n   */\n  data: IShoppingMileageHistory[];\n};\n",
  "src/api/structures/IShoppingMileageHistory.ts": "import { tags } from \"typia\";\n\nimport { IShoppingCitizen } from \"./IShoppingCitizen\";\nimport { IShoppingMileage } from \"./IShoppingMileage\";\n\n/** @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe */\nexport type IShoppingMileageHistory = {\n  id: string & tags.Format<\"uuid\">;\n  citizen: IShoppingCitizen;\n  mileage: IShoppingMileage;\n  source_id: string & tags.Format<\"uuid\">;\n  value: number;\n  balance: number;\n  created_at: string & tags.Format<\"date-time\">;\n};\nexport namespace IShoppingMileageHistory {\n  export type IRequest = {\n    search?: null | IShoppingMileageHistory.IRequest.ISearch;\n    sort?:\n      | null\n      | (\n          | \"-mileage.source\"\n          | \"-mileage.code\"\n          | \"-mileage.direction\"\n          | \"+mileage.source\"\n          | \"+mileage.code\"\n          | \"+mileage.direction\"\n          | \"-history.value\"\n          | \"-history.created_at\"\n          | \"+history.value\"\n          | \"+history.created_at\"\n        )[];\n\n    /**\n     * Page number.\n     *\n     * @title Page number\n     */\n    page?: null | (number & tags.Type<\"int32\"> & tags.Minimum<0>);\n\n    /**\n     * Limitation of records per a page.\n     *\n     * @title Limitation of records per a page\n     */\n    limit?: null | (number & tags.Type<\"int32\"> & tags.Minimum<0>);\n  };\n  export namespace IRequest {\n    export type ISearch = {\n      mileage?: null | IShoppingMileage.IRequest.ISearch;\n      citizen_id?: null | (string & tags.Format<\"uuid\">);\n      from?: null | (string & tags.Format<\"date-time\">);\n      to?: null | (string & tags.Format<\"date-time\">);\n      minimum?: null | (number & tags.Minimum<0>);\n      maximum?: null | (number & tags.Minimum<0>);\n    };\n  }\n}\n",
  "src/api/structures/IPageIShoppingCartCommodity.ts": "import { IPage } from \"./IPage\";\nimport { IShoppingCartCommodity } from \"./IShoppingCartCommodity\";\n\n/**\n * A page.\n *\n * Collection of records with pagination indformation.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IPageIShoppingCartCommodity = {\n  /**\n   * Page information.\n   *\n   * @title Page information\n   */\n  pagination: IPage.IPagination;\n\n  /**\n   * List of records.\n   *\n   * @title List of records\n   */\n  data: IShoppingCartCommodity[];\n};\n",
  "src/api/structures/IShoppingCartCommodityStock.ts": "import { tags } from \"typia\";\n\nimport { IShoppingCartCommodityStockChoice } from \"./IShoppingCartCommodityStockChoice\";\n\nexport namespace IShoppingCartCommodityStock {\n  /**\n   * Creation information of the commodity stock of shopping cart.\n   *\n   * When record being created, its corresponding structure would be\n   * {@link IShoppingSaleSnapshotUnit.IInvert} and\n   * {@link IShoppingSaleSnapshotUnitStock.IInvert}.\n   */\n  export type ICreate = {\n    /**\n     * Target unit's {@link IShoppingSaleUnit.id}.\n     *\n     * @title Target unit's {@link IShoppingSaleUnit.id}\n     */\n    unit_id: string & tags.Format<\"uuid\">;\n\n    /**\n     * Target stock's {@link IShoppingSaleUnitStock.id}.\n     *\n     * It must be matched with the {@link choices} property.\n     *\n     * @title Target stock's {@link IShoppingSaleUnitStock.id}\n     */\n    stock_id: string & tags.Format<\"uuid\">;\n\n    /**\n     * Creation information of the choices for each descriptive option.\n     *\n     * If target option is not of descriptive but of selective, then this\n     * property must be an empty array.\n     *\n     * @title Creation information of the choices for each descriptive option\n     */\n    choices: IShoppingCartCommodityStockChoice.ICreate[];\n\n    /**\n     * Quantity of the stock to purchase.\n     *\n     * This value is multiplied by the {@link IShoppingCartCommodity.volume}.\n     *\n     * @title Quantity of the stock to purchase\n     */\n    quantity: number & tags.Type<\"int32\"> & tags.Minimum<1>;\n  };\n}\n",
  "src/api/structures/IShoppingCartCommodityStockChoice.ts": "import { tags } from \"typia\";\n\nexport namespace IShoppingCartCommodityStockChoice {\n  /**\n   * Creation information of the choice for each option (of descriptive).\n   *\n   * When target option is {@link IShoppingSaleUnitDescriptiveOption} type,\n   * then you have to compose this choice structure with {@link value}\n   * specification.\n   *\n   * Otherwise when target option is {@link IShoppingSaleUnitSelectableOption}\n   * type, you don't need to compose this choice structure. Just fill only the\n   * {@link IShoppingCartCommodityStock.ICreate.stock_id} property.\n   */\n  export type ICreate = {\n    /**\n     * Target option's {@link IShoppingSaleUnitOption.id}.\n     *\n     * @title Target option's {@link IShoppingSaleUnitOption.id}\n     */\n    option_id: string & tags.Format<\"uuid\">;\n\n    /**\n     * Written value about the option.\n     *\n     * When target option's type is 'descriptive', then you have to fill\n     * this property with the written value by the customer.\n     *\n     * @title Written value about the option\n     */\n    value: null | string | number | boolean;\n  };\n}\n",
  "src/api/structures/IShoppingCartDiscountable.ts": "import { tags } from \"typia\";\n\nimport { IShoppingCoupon } from \"./IShoppingCoupon\";\nimport { IShoppingCouponTicket } from \"./IShoppingCouponTicket\";\nimport { IShoppingCartCommodity } from \"./IShoppingCartCommodity\";\n\n/** @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe */\nexport type IShoppingCartDiscountable = {\n  deposit: number;\n  mileage: number;\n  combinations: IShoppingCartDiscountable.ICombination[];\n};\nexport namespace IShoppingCartDiscountable {\n  export type ICombination = {\n    coupons: IShoppingCoupon[];\n    tickets: IShoppingCouponTicket[];\n    entries: IShoppingCartDiscountable.IEntry[];\n    amount: number;\n  };\n\n  export type IEntry = {\n    commodity_id: string & tags.Format<\"uuid\">;\n    pseudo: boolean;\n    coupon_id: string & tags.Format<\"uuid\">;\n    amount: number;\n  };\n\n  export type IRequest = {\n    commodity_ids: null | (string & tags.Format<\"uuid\">)[];\n    pseudos: IShoppingCartCommodity.ICreate[];\n  };\n}\n",
  "src/api/structures/IShoppingOrderDiscountable.ts": "import { tags } from \"typia\";\n\nimport { IShoppingCoupon } from \"./IShoppingCoupon\";\nimport { IShoppingCouponTicket } from \"./IShoppingCouponTicket\";\n\n/** @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe */\nexport type IShoppingOrderDiscountable = {\n  deposit: number;\n  mileage: number;\n  combinations: IShoppingOrderDiscountable.ICombination[];\n};\nexport namespace IShoppingOrderDiscountable {\n  export type ICombination = {\n    coupons: IShoppingCoupon[];\n    tickets: IShoppingCouponTicket[];\n    entries: IShoppingOrderDiscountable.IEntry[];\n    amount: number;\n  };\n\n  export type IEntry = {\n    good_id: string & tags.Format<\"uuid\">;\n    coupon_id: string & tags.Format<\"uuid\">;\n    amount: number;\n  };\n\n  export type IRequest = {\n    good_ids: null | (string & tags.Format<\"uuid\">)[];\n  };\n}\n",
  "src/api/structures/IPageIShoppingDelivery.ts": "import { IPage } from \"./IPage\";\nimport { IShoppingDelivery } from \"./IShoppingDelivery\";\n\nexport namespace IPageIShoppingDelivery {\n  /**\n   * A page.\n   *\n   * Collection of records with pagination indformation.\n   */\n  export type IInvert = {\n    /**\n     * Page information.\n     *\n     * @title Page information\n     */\n    pagination: IPage.IPagination;\n\n    /**\n     * List of records.\n     *\n     * @title List of records\n     */\n    data: IShoppingDelivery.IInvert[];\n  };\n}\n",
  "src/api/structures/IPageIShoppingSaleUnitStockSupplement.ts": "import { IPage } from \"./IPage\";\nimport { IShoppingSaleUnitStockSupplement } from \"./IShoppingSaleUnitStockSupplement\";\n\n/**\n * A page.\n *\n * Collection of records with pagination indformation.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IPageIShoppingSaleUnitStockSupplement = {\n  /**\n   * Page information.\n   *\n   * @title Page information\n   */\n  pagination: IPage.IPagination;\n\n  /**\n   * List of records.\n   *\n   * @title List of records\n   */\n  data: IShoppingSaleUnitStockSupplement[];\n};\n",
  "src/api/structures/IShoppingSaleUnitStockSupplement.ts": "import { tags } from \"typia\";\n\n/**\n * Supplementation of inventory quantity of stock.\n *\n * You know what? If a {@link IShoppingSaleUnitStock stock} has been sold over\n * its\n * {@link IShoppingSaleUnitStock.ICreate.quantity initial inventory quantity},\n * the stock can't be sold anymore, because of out of stock. In that case, how\n * the {@link IShoppingSeller} should do?\n *\n * When the sotck is sold out, seller can supplement the inventory record by\n * registering this `IShoppingSaleUnitStockSupplement` record. Right, this\n * `IShoppingSaleUnitStockSupplement` is an entity that embodies the\n * supplementation of the inventory quantity of the belonged stock.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IShoppingSaleUnitStockSupplement = {\n  /**\n   * Primary Key.\n   *\n   * @title Primary Key\n   */\n  id: string & tags.Format<\"uuid\">;\n\n  /**\n   * Supplemented quantity.\n   *\n   * @title Supplemented quantity\n   */\n  value: number & tags.Type<\"int32\"> & tags.Minimum<0>;\n\n  /**\n   * Creation time of the record.\n   *\n   * Another words, the time when inventory of the stock being supplemented.\n   *\n   * @title Creation time of the record\n   */\n  created_at: string & tags.Format<\"date-time\">;\n};\nexport namespace IShoppingSaleUnitStockSupplement {\n  /** Request information of the stock supplement list. */\n  export type IRequest = {\n    /**\n     * Sortable columns.\n     *\n     * @title Sortable columns\n     */\n    sort?: null | (\"-created_at\" | \"+created_at\")[];\n\n    /**\n     * Page number.\n     *\n     * @title Page number\n     */\n    page?: null | (number & tags.Type<\"int32\"> & tags.Minimum<0>);\n\n    /**\n     * Limitation of records per a page.\n     *\n     * @title Limitation of records per a page\n     */\n    limit?: null | (number & tags.Type<\"int32\"> & tags.Minimum<0>);\n  };\n\n  /** Creation information of the supplement. */\n  export type ICreate = {\n    /**\n     * Supplemented quantity.\n     *\n     * @title Supplemented quantity\n     */\n    value: number & tags.Type<\"int32\"> & tags.Minimum<0>;\n  };\n}\n",
  "src/api/functional/monitors/health/index.ts": "import { IConnection } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia from \"typia\";\n\n/**\n * Health check API.\n *\n * @path /monitors/health\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function get(connection: IConnection): Promise<void> {\n  return !!connection.simulate\n    ? get.simulate(connection)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...get.METADATA,\n          path: get.path(),\n          status: null,\n        },\n      );\n}\nexport namespace get {\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/monitors/health\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/monitors/health\";\n  export const random = (g?: Partial<typia.IRandomGenerator>): void =>\n    typia.random<void>(g);\n  export const simulate = (connection: IConnection): void => {\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/monitors/index.ts": "export * as health from \"./health\";\nexport * as performance from \"./performance\";\nexport * as system from \"./system\";\n",
  "src/api/functional/index.ts": "export * as monitors from \"./monitors\";\nexport * as shoppings from \"./shoppings\";\n",
  "src/api/functional/monitors/performance/index.ts": "import { IConnection } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia from \"typia\";\n\nimport { IPerformance } from \"../../../structures/IPerformance\";\n\n/**\n * Get performance information.\n *\n * Get perofmration information composed with CPU, memory and resource usage.\n *\n * @path /monitors/performance\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function get(connection: IConnection): Promise<get.Response> {\n  return !!connection.simulate\n    ? get.simulate(connection)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...get.METADATA,\n          path: get.path(),\n          status: null,\n        },\n      );\n}\nexport namespace get {\n  export type Response = IPerformance;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/monitors/performance\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/monitors/performance\";\n  export const random = (g?: Partial<typia.IRandomGenerator>): IPerformance =>\n    typia.random<IPerformance>(g);\n  export const simulate = (connection: IConnection): Response => {\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/monitors/system/index.ts": "import { IConnection } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia from \"typia\";\n\nimport { ISystem } from \"../../../structures/ISystem\";\n\n/**\n * Get system information.\n *\n * Get system information with commit and package information.\n *\n * As such information is a type of sensitive, response be encrypted.\n *\n * @path /monitors/system\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function get(connection: IConnection): Promise<get.Response> {\n  return !!connection.simulate\n    ? get.simulate(connection)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...get.METADATA,\n          path: get.path(),\n          status: null,\n        },\n      );\n}\nexport namespace get {\n  export type Response = ISystem;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/monitors/system\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/monitors/system\";\n  export const random = (g?: Partial<typia.IRandomGenerator>): ISystem =>\n    typia.random<ISystem>(g);\n  export const simulate = (connection: IConnection): Response => {\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/admins/authenticate/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingAdministrator } from \"../../../../structures/IShoppingAdministrator\";\nexport * as login from \"./login\";\n\n/**\n * Get administrator information.\n *\n * Get {@link IShoppingAdministrator.IInvert administrator} information of\n * current {@link IShoppingCustomer customer}.\n *\n * If current {@link IShoppingMember member} is not an administrator, it throws\n * 403 forbidden exception.\n *\n * @path /shoppings/admins/authenticate\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function get(connection: IConnection): Promise<get.Response> {\n  return !!connection.simulate\n    ? get.simulate(connection)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...get.METADATA,\n          path: get.path(),\n          status: null,\n        },\n      );\n}\nexport namespace get {\n  export type Response = IShoppingAdministrator.IInvert;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/shoppings/admins/authenticate\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/shoppings/admins/authenticate\";\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingAdministrator.IInvert =>\n    typia.random<IShoppingAdministrator.IInvert>(g);\n  export const simulate = (connection: IConnection): Response => {\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Join as an administrator.\n *\n * Join as an administrator with\n * {@link IShoppingAdministrator.IJoin joining info}.\n *\n * This method is allowed only when the {@link IShoppingCustomer customer}\n * already has joined the {@link IShoppingMember membership}. IF not, he (she)\n * must accomplish it before. If not, 403 forbidden exception would be thrown.\n *\n * @param props.body Joining request info\n * @path /shoppings/admins/authenticate\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function post(\n  connection: IConnection,\n  props: post.Props,\n): Promise<post.Response> {\n  return !!connection.simulate\n    ? post.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...post.METADATA,\n          path: post.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace post {\n  export type Props = {\n    /** Joining request info */\n    body: IShoppingAdministrator.IJoin;\n  };\n  export type Body = IShoppingAdministrator.IJoin;\n  export type Response = IShoppingAdministrator.IInvert;\n\n  export const METADATA = {\n    method: \"POST\",\n    path: \"/shoppings/admins/authenticate\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/shoppings/admins/authenticate\";\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingAdministrator.IInvert =>\n    typia.random<IShoppingAdministrator.IInvert>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: post.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: post.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/admins/index.ts": "export * as authenticate from \"./authenticate\";\nexport * as coupons from \"./coupons\";\nexport * as deposits from \"./deposits\";\nexport * as mileages from \"./mileages\";\nexport * as orders from \"./orders\";\nexport * as sales from \"./sales\";\nexport * as systematic from \"./systematic\";\n",
  "src/api/functional/shoppings/index.ts": "export * as admins from \"./admins\";\nexport * as customers from \"./customers\";\nexport * as sellers from \"./sellers\";\n",
  "src/api/functional/shoppings/admins/authenticate/login/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingMember } from \"../../../../../structures/IShoppingMember\";\nimport { IShoppingAdministrator } from \"../../../../../structures/IShoppingAdministrator\";\n\n/**\n * Login as an administrator.\n *\n * Login as an administrator with\n * {@link IShoppingAdministrator.ILogin login info}.\n *\n * This method has exactly same effect with\n * {@link ShoppingApi.functional.customers.authenticate.login} function, but\n * returned type is a llttle different. The similar function returns\n * {@link IShoppingCustomer} type that starting from the customer information, so\n * that you have to access to the administrator info through\n * `customer.member.administrator`. In contrast with that, this method returns\n * {@link IShoppingAdministrator.IInvert} type that starting from the\n * administrator info, so that can access to the customer info through\n * `administrator.customer`.\n *\n * Of course, to use this function, you had to {@link join} as an administrator\n * before. If not, 403 forbidden exception would be thrown,\n *\n * @param props.body Login request info\n * @path /shoppings/admins/authenticate/login\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function put(\n  connection: IConnection,\n  props: put.Props,\n): Promise<put.Response> {\n  return !!connection.simulate\n    ? put.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...put.METADATA,\n          path: put.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace put {\n  export type Props = {\n    /** Login request info */\n    body: IShoppingMember.ILogin;\n  };\n  export type Body = IShoppingMember.ILogin;\n  export type Response = IShoppingAdministrator.IInvert;\n\n  export const METADATA = {\n    method: \"PUT\",\n    path: \"/shoppings/admins/authenticate/login\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/shoppings/admins/authenticate/login\";\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingAdministrator.IInvert =>\n    typia.random<IShoppingAdministrator.IInvert>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: put.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: put.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/admins/coupons/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingCoupon } from \"../../../../structures/IShoppingCoupon\";\nimport { IPageIShoppingCoupon } from \"../../../../structures/IPageIShoppingCoupon\";\n\n/**\n * Create a new coupon.\n *\n * Create a new {@link IShoppingCoupon coupon} with given information.\n *\n * By the way, if you are a {@link IShoppingSeller seller}, you have to add\n * include direction's {@link IShoppingCouponSellerCriteria} or\n * {@link IShoppingCouponSaleCriteria} condition. This is because only\n * {@link IShoppingAdministrator administrators} can create a coupon which can be\n * used throughout the market. Seller must limit the usage range by his/her\n * {@link IShoppingSale sale(s)}.\n *\n * Of course, when administrator is planning to make a general coupon that can\n * be used throughout the market, the administrator must get agree from the\n * sellers who are going to be affected.\n *\n * @param props.body Creation info of the coupon\n * @path /shoppings/admins/coupons\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function post(\n  connection: IConnection,\n  props: post.Props,\n): Promise<post.Response> {\n  return !!connection.simulate\n    ? post.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...post.METADATA,\n          path: post.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace post {\n  export type Props = {\n    /** Creation info of the coupon */\n    body: IShoppingCoupon.ICreate;\n  };\n  export type Body = IShoppingCoupon.ICreate;\n  export type Response = IShoppingCoupon;\n\n  export const METADATA = {\n    method: \"POST\",\n    path: \"/shoppings/admins/coupons\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/shoppings/admins/coupons\";\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingCoupon => typia.random<IShoppingCoupon>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: post.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: post.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * List up every coupons.\n *\n * List up every {@link IShoppingCoupon coupons} with pagination.\n *\n * If you want, you can limit the result by configuring\n * {@link IShoppingCoupon.IRequest.search search condition} in the request body.\n * Also, it is possible to customize sequence order of records by configuring\n * {@link IShoppingCoupon.IRequest.sort sort condition}.\n *\n * For reference, if you are a {@link IShoppingCustomer customer}, then only\n * {@link IShoppingCouponTicket ticketable} coupons would be listed up.\n * Otherwise, non-ticketable coupons would also be listed up.\n *\n * @param props.body Request info of pagination, searching and sorting\n * @path /shoppings/admins/coupons\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patch(\n  connection: IConnection,\n  props: patch.Props,\n): Promise<patch.Response> {\n  return !!connection.simulate\n    ? patch.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patch.METADATA,\n          path: patch.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace patch {\n  export type Props = {\n    /** Request info of pagination, searching and sorting */\n    body: IShoppingCoupon.IRequest;\n  };\n  export type Body = IShoppingCoupon.IRequest;\n  export type Response = IPageIShoppingCoupon;\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/shoppings/admins/coupons\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/shoppings/admins/coupons\";\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IPageIShoppingCoupon => typia.random<IPageIShoppingCoupon>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: patch.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patch.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Get a coupon info.\n *\n * Get a {@link IShoppingCoupon coupon} information.\n *\n * If you are a {@link IShoppingCustomer customer}, then only\n * {@link IShoppingCouponTicket ticketable} coupons are accessible. Non\n * ticketable coupons cause 410 gone error. Otherwise you are a\n * {@link IShoppingSeller seller} or {@link IShoppingAdministrator administrator},\n * non-ticketable coupons are also accessible.\n *\n * @param props.id Target coupon's {@link IShoppingCoupon.id }\n * @path /shoppings/admins/coupons/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getById(\n  connection: IConnection,\n  props: getById.Props,\n): Promise<getById.Response> {\n  return !!connection.simulate\n    ? getById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getById.METADATA,\n          path: getById.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace getById {\n  export type Props = {\n    /** Target coupon's {@link IShoppingCoupon.id } */\n    id: string;\n  };\n  export type Response = IShoppingCoupon;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/shoppings/admins/coupons/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/shoppings/admins/coupons/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingCoupon => typia.random<IShoppingCoupon>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: getById.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Erase a coupon.\n *\n * Erase a {@link IShoppingCoupon coupon} with given ID.\n *\n * For reference, if there're some {@link IShoppingCouponTicket tickets} which\n * are already issued from the target coupon, they would not be affected. Those\n * tickets are still valid until their expration time.\n *\n * @param props.id Target coupon's {@link IShoppingCoupon.id }\n * @path /shoppings/admins/coupons/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function eraseById(\n  connection: IConnection,\n  props: eraseById.Props,\n): Promise<void> {\n  return !!connection.simulate\n    ? eraseById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...eraseById.METADATA,\n          path: eraseById.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace eraseById {\n  export type Props = {\n    /** Target coupon's {@link IShoppingCoupon.id } */\n    id: string;\n  };\n\n  export const METADATA = {\n    method: \"DELETE\",\n    path: \"/shoppings/admins/coupons/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/shoppings/admins/coupons/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): void =>\n    typia.random<void>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: eraseById.Props,\n  ): void => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: eraseById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/admins/deposits/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingDeposit } from \"../../../../structures/IShoppingDeposit\";\nimport { IPageIShoppingDeposit } from \"../../../../structures/IPageIShoppingDeposit\";\nexport * as get from \"./get\";\n\n/**\n * Create a new deposit metadata.\n *\n * Create a new {@link IShoppingDeposit deposit} metadata.\n *\n * This action means that adding a new origin reason of deposit's\n * income/outcome. Of course, creating a new deposit record does not mean that\n * automatically increase or decrease the {@link IShoppingCustomer customer}'s\n * balance following the record's reason why. The logic must be developed\n * manually in the backend side.\n *\n * @param props.body Creation information of deposit metadata\n * @path /shoppings/admins/deposits\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function post(\n  connection: IConnection,\n  props: post.Props,\n): Promise<post.Response> {\n  return !!connection.simulate\n    ? post.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...post.METADATA,\n          path: post.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace post {\n  export type Props = {\n    /** Creation information of deposit metadata */\n    body: IShoppingDeposit.ICreate;\n  };\n  export type Body = IShoppingDeposit.ICreate;\n  export type Response = IShoppingDeposit;\n\n  export const METADATA = {\n    method: \"POST\",\n    path: \"/shoppings/admins/deposits\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/shoppings/admins/deposits\";\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingDeposit => typia.random<IShoppingDeposit>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: post.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: post.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Get deposit metadata list.\n *\n * List up every {@link IShoppingDeposit deposit} metadata information with\n * {@link IPage pagination}.\n *\n * If you want, you can limit the result by configuring\n * {@link IShoppingDeposit.IRequest.search search condition} in the request body.\n * Also, it is possible to customize sequence order of records by configuring\n * {@link IShoppingDeposit.IRequest.sort sort condition}.\n *\n * @param props.body Request info of pagination, searching and sorting\n * @path /shoppings/admins/deposits\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patch(\n  connection: IConnection,\n  props: patch.Props,\n): Promise<patch.Response> {\n  return !!connection.simulate\n    ? patch.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patch.METADATA,\n          path: patch.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace patch {\n  export type Props = {\n    /** Request info of pagination, searching and sorting */\n    body: IShoppingDeposit.IRequest;\n  };\n  export type Body = IShoppingDeposit.IRequest;\n  export type Response = IPageIShoppingDeposit;\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/shoppings/admins/deposits\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/shoppings/admins/deposits\";\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IPageIShoppingDeposit => typia.random<IPageIShoppingDeposit>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: patch.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patch.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Get a deposit metadata.\n *\n * Get a {@link IShoppingDeposit deposit} metadata information with its ID.\n *\n * @param props.id Target deposit's {@link IShoppingDeposit.id }\n * @path /shoppings/admins/deposits/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getById(\n  connection: IConnection,\n  props: getById.Props,\n): Promise<getById.Response> {\n  return !!connection.simulate\n    ? getById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getById.METADATA,\n          path: getById.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace getById {\n  export type Props = {\n    /** Target deposit's {@link IShoppingDeposit.id } */\n    id: string & tags.Format<\"uuid\">;\n  };\n  export type Response = IShoppingDeposit;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/shoppings/admins/deposits/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/shoppings/admins/deposits/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingDeposit => typia.random<IShoppingDeposit>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: getById.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Erase a deposit metadata.\n *\n * Erase a {@link IShoppingDeposit deposit} metadata, so that no more\n * {@link IShoppingCustomer customer}'s balance does not be increased or\n * decreased by the deposit's reason why.\n *\n * @param props.id Target deposit's {@link IShoppingDeposit.id }\n * @path /shoppings/admins/deposits/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function eraseById(\n  connection: IConnection,\n  props: eraseById.Props,\n): Promise<void> {\n  return !!connection.simulate\n    ? eraseById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...eraseById.METADATA,\n          path: eraseById.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace eraseById {\n  export type Props = {\n    /** Target deposit's {@link IShoppingDeposit.id } */\n    id: string & tags.Format<\"uuid\">;\n  };\n\n  export const METADATA = {\n    method: \"DELETE\",\n    path: \"/shoppings/admins/deposits/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/shoppings/admins/deposits/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): void =>\n    typia.random<void>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: eraseById.Props,\n  ): void => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: eraseById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/admins/deposits/get/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingDeposit } from \"../../../../../structures/IShoppingDeposit\";\n\n/**\n * Get a deposit metadata by its code.\n *\n * Get a {@link IShoppingDeposit deposit} metadata information with its code.\n *\n * @param props.code Describe description as much as possible with clear and\n *   concise words.\n * @path /shoppings/admins/deposits/:code/get\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getByCode(\n  connection: IConnection,\n  props: getByCode.Props,\n): Promise<getByCode.Response> {\n  return !!connection.simulate\n    ? getByCode.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getByCode.METADATA,\n          path: getByCode.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace getByCode {\n  export type Props = {\n    /**\n     * Describe description as much as possible with clear and concise\n     * words.\n     */\n    code: string;\n  };\n  export type Response = IShoppingDeposit;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/shoppings/admins/deposits/:code/get\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/shoppings/admins/deposits/${encodeURIComponent(props.code ?? \"null\")}/get`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingDeposit => typia.random<IShoppingDeposit>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: getByCode.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getByCode.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"code\")(() => typia.assert(props.code));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/admins/mileages/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingMileage } from \"../../../../structures/IShoppingMileage\";\nimport { IPageIShoppingMileage } from \"../../../../structures/IPageIShoppingMileage\";\nexport * as get from \"./get\";\nexport * as donations from \"./donations\";\n\n/**\n * Create a new mileage metadata.\n *\n * Create a new {@link IShoppingMileage mileage} metadata.\n *\n * This action means that adding a new origin reason of mileage's\n * income/outcome. Of course, creating a new mileage record does not mean that\n * automatically increase or decrease the {@link IShoppingCustomer customer}'s\n * balance following the record's reason why. The logic must be developed\n * manually in the backend side.\n *\n * @param props.body Creation information of mileage metadata\n * @path /shoppings/admins/mileages\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function post(\n  connection: IConnection,\n  props: post.Props,\n): Promise<post.Response> {\n  return !!connection.simulate\n    ? post.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...post.METADATA,\n          path: post.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace post {\n  export type Props = {\n    /** Creation information of mileage metadata */\n    body: IShoppingMileage.ICreate;\n  };\n  export type Body = IShoppingMileage.ICreate;\n  export type Response = IShoppingMileage;\n\n  export const METADATA = {\n    method: \"POST\",\n    path: \"/shoppings/admins/mileages\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/shoppings/admins/mileages\";\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingMileage => typia.random<IShoppingMileage>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: post.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: post.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Get mileage metadata list.\n *\n * List up every {@link IShoppingMileage mileage} metadata information with\n * {@link IPage pagination}.\n *\n * If you want, you can limit the result by configuring\n * {@link IShoppingMileage.IRequest.search search condition} in the request body.\n * Also, it is possible to customize sequence order of records by configuring\n * {@link IShoppingMileage.IRequest.sort sort condition}.\n *\n * @param props.body Request info of pagination, searching and sorting\n * @path /shoppings/admins/mileages\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patch(\n  connection: IConnection,\n  props: patch.Props,\n): Promise<patch.Response> {\n  return !!connection.simulate\n    ? patch.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patch.METADATA,\n          path: patch.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace patch {\n  export type Props = {\n    /** Request info of pagination, searching and sorting */\n    body: IShoppingMileage.IRequest;\n  };\n  export type Body = IShoppingMileage.IRequest;\n  export type Response = IPageIShoppingMileage;\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/shoppings/admins/mileages\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/shoppings/admins/mileages\";\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IPageIShoppingMileage => typia.random<IPageIShoppingMileage>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: patch.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patch.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Get a mileage metadata.\n *\n * Get a {@link IShoppingMileage mileage} metadata information with its ID.\n *\n * @param props.id Target mileage's {@link IShoppingMileage.id }\n * @path /shoppings/admins/mileages/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getById(\n  connection: IConnection,\n  props: getById.Props,\n): Promise<getById.Response> {\n  return !!connection.simulate\n    ? getById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getById.METADATA,\n          path: getById.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace getById {\n  export type Props = {\n    /** Target mileage's {@link IShoppingMileage.id } */\n    id: string & tags.Format<\"uuid\">;\n  };\n  export type Response = IShoppingMileage;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/shoppings/admins/mileages/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/shoppings/admins/mileages/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingMileage => typia.random<IShoppingMileage>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: getById.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Erase a mileage metadata.\n *\n * Erase a {@link IShoppingMileage mileage} metadata, so that no more\n * {@link IShoppingCustomer customer}'s balance does not be increased or\n * decreased by the mileage's reason why.\n *\n * @param props.id Target mileage's {@link IShoppingMileage.id }\n * @path /shoppings/admins/mileages/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function eraseById(\n  connection: IConnection,\n  props: eraseById.Props,\n): Promise<void> {\n  return !!connection.simulate\n    ? eraseById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...eraseById.METADATA,\n          path: eraseById.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace eraseById {\n  export type Props = {\n    /** Target mileage's {@link IShoppingMileage.id } */\n    id: string & tags.Format<\"uuid\">;\n  };\n\n  export const METADATA = {\n    method: \"DELETE\",\n    path: \"/shoppings/admins/mileages/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/shoppings/admins/mileages/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): void =>\n    typia.random<void>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: eraseById.Props,\n  ): void => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: eraseById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/admins/mileages/get/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingMileage } from \"../../../../../structures/IShoppingMileage\";\n\n/**\n * Get a mileage metadata by its code.\n *\n * Get a {@link IShoppingMileage mileage} metadata information with its code.\n *\n * @param props.code Describe description as much as possible with clear and\n *   concise words.\n * @path /shoppings/admins/mileages/:code/get\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getByCode(\n  connection: IConnection,\n  props: getByCode.Props,\n): Promise<getByCode.Response> {\n  return !!connection.simulate\n    ? getByCode.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getByCode.METADATA,\n          path: getByCode.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace getByCode {\n  export type Props = {\n    /**\n     * Describe description as much as possible with clear and concise\n     * words.\n     */\n    code: string;\n  };\n  export type Response = IShoppingMileage;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/shoppings/admins/mileages/:code/get\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/shoppings/admins/mileages/${encodeURIComponent(props.code ?? \"null\")}/get`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingMileage => typia.random<IShoppingMileage>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: getByCode.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getByCode.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"code\")(() => typia.assert(props.code));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/admins/mileages/donations/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingMileageDonation } from \"../../../../../structures/IShoppingMileageDonation\";\nimport { IPageIShoppingMileageDonation } from \"../../../../../structures/IPageIShoppingMileageDonation\";\n\n/**\n * Donate a mileage to a citizen.\n *\n * Donate a mileage to a specific {@link IShoppingCitizen citizen} from current\n * {@link IShoppingAdministrator administrator}, with detailed reason why.\n *\n * Note that, as donating mileage affects to the citizen's balance and current\n * shopping mall's operating profit, administrator must archive the detailed\n * reason why the mileage is donated.\n *\n * @param props.body Request info of mileage donation\n * @path /shoppings/admins/mileages/donations\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function post(\n  connection: IConnection,\n  props: post.Props,\n): Promise<post.Response> {\n  return !!connection.simulate\n    ? post.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...post.METADATA,\n          path: post.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace post {\n  export type Props = {\n    /** Request info of mileage donation */\n    body: IShoppingMileageDonation.ICreate;\n  };\n  export type Body = IShoppingMileageDonation.ICreate;\n  export type Response = IShoppingMileageDonation;\n\n  export const METADATA = {\n    method: \"POST\",\n    path: \"/shoppings/admins/mileages/donations\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/shoppings/admins/mileages/donations\";\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingMileageDonation => typia.random<IShoppingMileageDonation>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: post.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: post.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * List up every mileage donation histories.\n *\n * List up every {@link IShoppingMileageDonation mileage donation histories} with\n * {@link IPage pagination}.\n *\n * If you want, you can limit the result by configuring\n * {@link IShoppingMileageDonation.IRequest.search search condition} in the\n * request body. Also, it is possible to customize sequence order of records by\n * configuring {@link IShoppingMileageDonation.IRequest.sort sort}.\n *\n * @param props.body Request info of pagination, searching and sorting\n * @path /shoppings/admins/mileages/donations\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patch(\n  connection: IConnection,\n  props: patch.Props,\n): Promise<patch.Response> {\n  return !!connection.simulate\n    ? patch.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patch.METADATA,\n          path: patch.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace patch {\n  export type Props = {\n    /** Request info of pagination, searching and sorting */\n    body: IShoppingMileageDonation.IRequest;\n  };\n  export type Body = IShoppingMileageDonation.IRequest;\n  export type Response = IPageIShoppingMileageDonation;\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/shoppings/admins/mileages/donations\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/shoppings/admins/mileages/donations\";\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IPageIShoppingMileageDonation =>\n    typia.random<IPageIShoppingMileageDonation>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: patch.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patch.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Get a mileage donation history.\n *\n * Get a {@link IShoppingMileageDonation mileage donation history} with its ID.\n *\n * @param props.id Target history's {@link IShoppingMileageDonation.id }\n * @path /shoppings/admins/mileages/donations/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getById(\n  connection: IConnection,\n  props: getById.Props,\n): Promise<getById.Response> {\n  return !!connection.simulate\n    ? getById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getById.METADATA,\n          path: getById.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace getById {\n  export type Props = {\n    /** Target history's {@link IShoppingMileageDonation.id } */\n    id: string & tags.Format<\"uuid\">;\n  };\n  export type Response = IShoppingMileageDonation;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/shoppings/admins/mileages/donations/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/shoppings/admins/mileages/donations/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingMileageDonation => typia.random<IShoppingMileageDonation>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: getById.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/admins/orders/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingOrder } from \"../../../../structures/IShoppingOrder\";\nimport { IPageIShoppingOrder } from \"../../../../structures/IPageIShoppingOrder\";\n\n/**\n * List up every orders.\n *\n * List up every {@link IShoppingOrder orders} with pagination.\n *\n * If you want, you can limit the result by configuring\n * {@link IShoppingOrder.IRequest.search search condition} in the request body.\n * Also, it is possible to customize sequence order of records by configuring\n * {@link IShoppingOrder.IRequest.sort sort condition}.\n *\n * For reference, if you are a {@link IShoppingCustomer customer}, then you can\n * list up your own orders, and it is not a matter whether the order has been\n * {@link IShoppingOrderPublish.paid_at paid} or not.\n *\n * Otherwise you are a {@link IShoppingSeller seller} or\n * {@link IShoppingAdministrator administrator}, then you can list up only paid\n * orders. Also, in the seller case, only related\n * {@link IShoppingOrder.goods goods} would be listed up in the order.\n *\n * @param props.body Request info of pagination, searching and sorting\n * @path /shoppings/admins/orders\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patch(\n  connection: IConnection,\n  props: patch.Props,\n): Promise<patch.Response> {\n  return !!connection.simulate\n    ? patch.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patch.METADATA,\n          path: patch.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace patch {\n  export type Props = {\n    /** Request info of pagination, searching and sorting */\n    body: IShoppingOrder.IRequest;\n  };\n  export type Body = IShoppingOrder.IRequest;\n  export type Response = IPageIShoppingOrder;\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/shoppings/admins/orders\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/shoppings/admins/orders\";\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IPageIShoppingOrder => typia.random<IPageIShoppingOrder>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: patch.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patch.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Get an order info.\n *\n * Get a detailed {@link IShoppingOrder order} information.\n *\n * If you are not a {@link IShoppingCustomer customer}, then you can't access to\n * the order which has not been {@link IShoppingOrderPublish.paid_at paid} yet.\n * In that case, 404 not found error would be thrown.\n *\n * @param props.id Target order's {@link IShoppingOrder.id }\n * @path /shoppings/admins/orders/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getById(\n  connection: IConnection,\n  props: getById.Props,\n): Promise<getById.Response> {\n  return !!connection.simulate\n    ? getById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getById.METADATA,\n          path: getById.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace getById {\n  export type Props = {\n    /** Target order's {@link IShoppingOrder.id } */\n    id: string & tags.Format<\"uuid\">;\n  };\n  export type Response = IShoppingOrder;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/shoppings/admins/orders/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/shoppings/admins/orders/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): IShoppingOrder =>\n    typia.random<IShoppingOrder>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: getById.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/admins/sales/details/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingSale } from \"../../../../../structures/IShoppingSale\";\nimport { IPageIShoppingSale } from \"../../../../../structures/IPageIShoppingSale\";\n\n/**\n * List up every sales.\n *\n * List up every {@link IShoppingSale sales} with detailed information.\n *\n * As you can see, returned sales are detailed, not summarized. If you want to\n * get the summarized information of sale for a brief, use {@link index} function\n * instead.\n *\n * For reference, if you're a {@link IShoppingSeller seller}, you can only access\n * to the your own {@link IShoppingSale sale}s. Otherwise you're a\n * {@link IShoppingCustomer customer}, you can see only the operating sales in\n * the market. Instead, you can't see the unopened, closed, or suspended sales.\n *\n * > If you're an A.I. chatbot, please don't summarize the\n * > {@link IShoppingSaleUnitStock stock information}. Just list up the every\n * > stocks in the sale with detailed information.\n *\n * @param props.body Request info of pagination, searching and sorting\n * @path /shoppings/admins/sales/details\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patch(\n  connection: IConnection,\n  props: patch.Props,\n): Promise<patch.Response> {\n  return !!connection.simulate\n    ? patch.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patch.METADATA,\n          path: patch.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace patch {\n  export type Props = {\n    /** Request info of pagination, searching and sorting */\n    body: IShoppingSale.IRequest;\n  };\n  export type Body = IShoppingSale.IRequest;\n  export type Response = IPageIShoppingSale;\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/shoppings/admins/sales/details\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/shoppings/admins/sales/details\";\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IPageIShoppingSale => typia.random<IPageIShoppingSale>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: patch.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patch.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/admins/sales/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingSale } from \"../../../../structures/IShoppingSale\";\nimport { IPageIShoppingSale } from \"../../../../structures/IPageIShoppingSale\";\nexport * as details from \"./details\";\nexport * as questions from \"./questions\";\nexport * as reviews from \"./reviews\";\nexport * as snapshots from \"./snapshots\";\n\n/**\n * List up every summarized sales.\n *\n * List up every {@link IShoppingSale.ISummary summarized sales}.\n *\n * As you can see, returned sales are summarized, not detailed. It does not\n * contain the SKU (Stock Keeping Unit) information represented by the\n * {@link IShoppingSaleUnitOption} and {@link IShoppingSaleUnitStock} types. If\n * you want to get such detailed information of a sale, use `GET\n * /shoppings/customers/sales/{id}` operation for each sale.\n *\n * > If you're an A.I. chatbot, and the user wants to buy or compose\n * > {@link IShoppingCartCommodity shopping cart} from a sale, please call the `GET\n * > /shoppings/customers/sales/{id}` operation at least once to the target sale\n * > to get detailed SKU information about the sale. It needs to be run at least\n * > once for the next steps.\n *\n * @param props.body Request info of pagination, searching and sorting\n * @path /shoppings/admins/sales\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patch(\n  connection: IConnection,\n  props: patch.Props,\n): Promise<patch.Response> {\n  return !!connection.simulate\n    ? patch.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patch.METADATA,\n          path: patch.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace patch {\n  export type Props = {\n    /** Request info of pagination, searching and sorting */\n    body: IShoppingSale.IRequest;\n  };\n  export type Body = IShoppingSale.IRequest;\n  export type Response = IPageIShoppingSale.ISummary;\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/shoppings/admins/sales\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/shoppings/admins/sales\";\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IPageIShoppingSale.ISummary =>\n    typia.random<IPageIShoppingSale.ISummary>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: patch.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patch.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Get a sale with detailed information.\n *\n * Get a {@link IShoppingSale sale} with detailed information including the SKU\n * (Stock Keeping Unit) information represented by the\n * {@link IShoppingSaleUnitOption} and {@link IShoppingSaleUnitStock} types.\n *\n * > If you're an A.I. chatbot, and the user wants to buy or compose a\n * > {@link IShoppingCartCommodity shopping cart} from a sale, please call this\n * > operation at least once to the target sale to get detailed SKU information\n * > about the sale.\n *\n * > It needs to be run at least once for the next steps. In other words, if you\n * > A.I. agent has called this operation to a specific sale, you don't need to\n * > call this operation again for the same sale.\n *\n * > Additionally, please do not summarize the SKU information. Just show the\n * > every options and stocks in the sale with detailed information.\n *\n * @param props.id Target sale's {@link IShoppingSale.id }\n * @path /shoppings/admins/sales/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getById(\n  connection: IConnection,\n  props: getById.Props,\n): Promise<getById.Response> {\n  return !!connection.simulate\n    ? getById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getById.METADATA,\n          path: getById.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace getById {\n  export type Props = {\n    /** Target sale's {@link IShoppingSale.id } */\n    id: string & tags.Format<\"uuid\">;\n  };\n  export type Response = IShoppingSale;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/shoppings/admins/sales/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/shoppings/admins/sales/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): IShoppingSale =>\n    typia.random<IShoppingSale>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: getById.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/admins/sales/questions/comments/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingSaleInquiryComment } from \"../../../../../../structures/IShoppingSaleInquiryComment\";\nimport { IPageIShoppingSaleInquiryComment } from \"../../../../../../structures/IPageIShoppingSaleInquiryComment\";\n\n/**\n * Create an inquiry comment.\n *\n * Create an {@link IShoppingSaleInquiryComment inquiry comment} of a\n * {@link IShoppingSaleQuestion question} or {@link IShoppingSaleReview review}.\n *\n * For reference, if you're a {@link IShoppingSeller seller}, you can only create\n * an inquiry comment to your own {@link IShoppingSale sale}'s inquiry.\n * Otherwise, you can create an inquiry comment to every inquiries of the\n * sales.\n *\n * @param props.saleId Belonged sale's {@link IShoppingSale.id }\n * @param props.inquiryId Target inquiry's {@link IShoppingSaleInquiry.id }\n * @param props.body Creation info of the inquiry comment\n * @path /shoppings/admins/sales/:saleId/questions/:inquiryId/comments\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function postBySaleidAndInquiryid(\n  connection: IConnection,\n  props: postBySaleidAndInquiryid.Props,\n): Promise<postBySaleidAndInquiryid.Response> {\n  return !!connection.simulate\n    ? postBySaleidAndInquiryid.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...postBySaleidAndInquiryid.METADATA,\n          path: postBySaleidAndInquiryid.path(props),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace postBySaleidAndInquiryid {\n  export type Props = {\n    /** Belonged sale's {@link IShoppingSale.id } */\n    saleId: string & tags.Format<\"uuid\">;\n\n    /** Target inquiry's {@link IShoppingSaleInquiry.id } */\n    inquiryId: string & tags.Format<\"uuid\">;\n\n    /** Creation info of the inquiry comment */\n    body: IShoppingSaleInquiryComment.ICreate;\n  };\n  export type Body = IShoppingSaleInquiryComment.ICreate;\n  export type Response = IShoppingSaleInquiryComment;\n\n  export const METADATA = {\n    method: \"POST\",\n    path: \"/shoppings/admins/sales/:saleId/questions/:inquiryId/comments\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Omit<Props, \"body\">) =>\n    `/shoppings/admins/sales/${encodeURIComponent(props.saleId ?? \"null\")}/questions/${encodeURIComponent(props.inquiryId ?? \"null\")}/comments`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingSaleInquiryComment =>\n    typia.random<IShoppingSaleInquiryComment>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: postBySaleidAndInquiryid.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: postBySaleidAndInquiryid.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"saleId\")(() => typia.assert(props.saleId));\n      assert.param(\"inquiryId\")(() => typia.assert(props.inquiryId));\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * List up every inquiry comments.\n *\n * List up every {@link IShoppingSaleInquiryComment inquiry comments} of a\n * {@link IShoppingSaleQuestion question} or {@link IShoppingSaleReview review}\n * with {@link IPage pagination}.\n *\n * If you want, you can limit the result by configuring\n * {@link IShoppingSaleInquiryComment.IRequest.search search condition} in the\n * request body. Also, it is possible to customize sequence order of records by\n * configuring {@link IShoppingSaleInquiryComment.IRequest.sort sort condition}.\n *\n * By the way, if you're a {@link IShoppingSeller seller}, you can only access to\n * the your own {@link IShoppingSale sale}'s inquiries. Otherwise, you can access\n * to every inquiries of the sales.\n *\n * @param props.saleId Belonged sale's {@link IShoppingSale.id }\n * @param props.inquiryId Belonged inquiry's {@link IShoppingSaleInquiry.id }\n * @param props.body Request info of pagination, searching and sorting\n * @path /shoppings/admins/sales/:saleId/questions/:inquiryId/comments\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patchBySaleidAndInquiryid(\n  connection: IConnection,\n  props: patchBySaleidAndInquiryid.Props,\n): Promise<patchBySaleidAndInquiryid.Response> {\n  return !!connection.simulate\n    ? patchBySaleidAndInquiryid.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patchBySaleidAndInquiryid.METADATA,\n          path: patchBySaleidAndInquiryid.path(props),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace patchBySaleidAndInquiryid {\n  export type Props = {\n    /** Belonged sale's {@link IShoppingSale.id } */\n    saleId: string & tags.Format<\"uuid\">;\n\n    /** Belonged inquiry's {@link IShoppingSaleInquiry.id } */\n    inquiryId: string & tags.Format<\"uuid\">;\n\n    /** Request info of pagination, searching and sorting */\n    body: IShoppingSaleInquiryComment.IRequest;\n  };\n  export type Body = IShoppingSaleInquiryComment.IRequest;\n  export type Response = IPageIShoppingSaleInquiryComment;\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/shoppings/admins/sales/:saleId/questions/:inquiryId/comments\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Omit<Props, \"body\">) =>\n    `/shoppings/admins/sales/${encodeURIComponent(props.saleId ?? \"null\")}/questions/${encodeURIComponent(props.inquiryId ?? \"null\")}/comments`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IPageIShoppingSaleInquiryComment =>\n    typia.random<IPageIShoppingSaleInquiryComment>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: patchBySaleidAndInquiryid.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patchBySaleidAndInquiryid.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"saleId\")(() => typia.assert(props.saleId));\n      assert.param(\"inquiryId\")(() => typia.assert(props.inquiryId));\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Get an inquiry comment info.\n *\n * Get a detailed {@link IShoppingSaleInquiryComment inquiry comment} information\n * of a {@link IShoppingSaleQuestion question} or\n * {@link IShoppingSaleReview review}.\n *\n * For reference, if you're a {@link IShoppingSeller seller}, you can only access\n * to the your own {@link IShoppingSale sale}'s inquiry comment. Otherwise, you\n * can access to every inquiry comments of the sales.\n *\n * @param props.saleId Belonged sale's {@link IShoppingSale.id }\n * @param props.inquiryId Belonged inquiry's {@link IShoppingSaleInquiry.id }\n * @param props.id Target inquiry comment's\n *   {@link IShoppingSaleInquiryComment.id }\n * @path /shoppings/admins/sales/:saleId/questions/:inquiryId/comments/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getBySaleidAndInquiryidAndId(\n  connection: IConnection,\n  props: getBySaleidAndInquiryidAndId.Props,\n): Promise<getBySaleidAndInquiryidAndId.Response> {\n  return !!connection.simulate\n    ? getBySaleidAndInquiryidAndId.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getBySaleidAndInquiryidAndId.METADATA,\n          path: getBySaleidAndInquiryidAndId.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace getBySaleidAndInquiryidAndId {\n  export type Props = {\n    /** Belonged sale's {@link IShoppingSale.id } */\n    saleId: string & tags.Format<\"uuid\">;\n\n    /** Belonged inquiry's {@link IShoppingSaleInquiry.id } */\n    inquiryId: string & tags.Format<\"uuid\">;\n\n    /** Target inquiry comment's {@link IShoppingSaleInquiryComment.id } */\n    id: string & tags.Format<\"uuid\">;\n  };\n  export type Response = IShoppingSaleInquiryComment;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/shoppings/admins/sales/:saleId/questions/:inquiryId/comments/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/shoppings/admins/sales/${encodeURIComponent(props.saleId ?? \"null\")}/questions/${encodeURIComponent(props.inquiryId ?? \"null\")}/comments/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingSaleInquiryComment =>\n    typia.random<IShoppingSaleInquiryComment>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: getBySaleidAndInquiryidAndId.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getBySaleidAndInquiryidAndId.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"saleId\")(() => typia.assert(props.saleId));\n      assert.param(\"inquiryId\")(() => typia.assert(props.inquiryId));\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Update an inquiry comment.\n *\n * Update an {@link IShoppingSaleInquiryComment inquiry comment} to a specific\n * {@link IShoppingSaleQuestion question} or {@link IShoppingSaleReview review}.\n *\n * By the way, as is the general policy of this shopping mall regarding\n * comments, modifying a comment does not actually change the existing content.\n * Modified content is accumulated and recorded in the existing comment record\n * as a new {@link IShoppingSaleInquiryComment.ISnapshot snapshot}. And this is\n * made public to everyone, who can read this inquiry comment.\n *\n * This is to prevent customers or sellers from modifying their comments and\n * manipulating the circumstances due to the nature of e-commerce, where\n * disputes easily arise. That is, to preserve evidence.\n *\n * @param props.saleId Belonged sale's {@link IShoppingSale.id }\n * @param props.inquiryId Belonged inquiry's {@link IShoppingSaleInquiry.id }\n * @param props.id Target inquiry comment's\n *   {@link IShoppingSaleInquiryComment.id }\n * @param props.body Update info of the inquiry comment\n * @path /shoppings/admins/sales/:saleId/questions/:inquiryId/comments/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function putBySaleidAndInquiryidAndId(\n  connection: IConnection,\n  props: putBySaleidAndInquiryidAndId.Props,\n): Promise<putBySaleidAndInquiryidAndId.Response> {\n  return !!connection.simulate\n    ? putBySaleidAndInquiryidAndId.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...putBySaleidAndInquiryidAndId.METADATA,\n          path: putBySaleidAndInquiryidAndId.path(props),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace putBySaleidAndInquiryidAndId {\n  export type Props = {\n    /** Belonged sale's {@link IShoppingSale.id } */\n    saleId: string & tags.Format<\"uuid\">;\n\n    /** Belonged inquiry's {@link IShoppingSaleInquiry.id } */\n    inquiryId: string & tags.Format<\"uuid\">;\n\n    /** Target inquiry comment's {@link IShoppingSaleInquiryComment.id } */\n    id: string & tags.Format<\"uuid\">;\n\n    /** Update info of the inquiry comment */\n    body: IShoppingSaleInquiryComment.ICreate;\n  };\n  export type Body = IShoppingSaleInquiryComment.ICreate;\n  export type Response = IShoppingSaleInquiryComment.ISnapshot;\n\n  export const METADATA = {\n    method: \"PUT\",\n    path: \"/shoppings/admins/sales/:saleId/questions/:inquiryId/comments/:id\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Omit<Props, \"body\">) =>\n    `/shoppings/admins/sales/${encodeURIComponent(props.saleId ?? \"null\")}/questions/${encodeURIComponent(props.inquiryId ?? \"null\")}/comments/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingSaleInquiryComment.ISnapshot =>\n    typia.random<IShoppingSaleInquiryComment.ISnapshot>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: putBySaleidAndInquiryidAndId.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: putBySaleidAndInquiryidAndId.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"saleId\")(() => typia.assert(props.saleId));\n      assert.param(\"inquiryId\")(() => typia.assert(props.inquiryId));\n      assert.param(\"id\")(() => typia.assert(props.id));\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/admins/sales/questions/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingSaleQuestion } from \"../../../../../structures/IShoppingSaleQuestion\";\nimport { IPageIShoppingSaleQuestion } from \"../../../../../structures/IPageIShoppingSaleQuestion\";\nexport * as comments from \"./comments\";\nexport * as abridges from \"./abridges\";\n\n/**\n * List up every summarized questions.\n *\n * List up every {@link IShoppingSaleQuestion.ISummary summarized questions} of a\n * {@link IShoppingSale sale}.\n *\n * As you can see, returned questions are summarized, not detailed. If you want\n * to get the detailed information of a question, use {@link adridges} function\n * or {@link at} function for each article.\n *\n * Also, returned question has {@link IShoppingSaleQuestion.ISummary.answer}\n * property which means the formal answer from the {@link IShoppingSeller}.\n * Additionally, returned question has another special property\n * {@link IShoppingSaleQuestion.ISummary.secret} with masking to other princple\n * properties, and it means only related actors can {@link at read} the\n * question.\n *\n * For reference, if you're a {@link IShoppingSeller seller}, you can only access\n * to the your own {@link IShoppingSale sale}'s questions. Otherwise, you can\n * access to every questions of the sales.\n *\n * By the way, if you want, you can limit the result by configuring\n * {@link IShoppingSaleQuestion.IRequest.search search condition} in the request\n * body. Also, it is possible to customize sequence order of records by\n * configuring {@link IShoppingSaleQuestion.IRequest.sort sort condition}.\n *\n * @param props.saleId Belonged sale's {@link IShoppingSale.id }\n * @param props.body Request info of pagination, searching and sorting\n * @path /shoppings/admins/sales/:saleId/questions\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patchBySaleid(\n  connection: IConnection,\n  props: patchBySaleid.Props,\n): Promise<patchBySaleid.Response> {\n  return !!connection.simulate\n    ? patchBySaleid.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patchBySaleid.METADATA,\n          path: patchBySaleid.path(props),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace patchBySaleid {\n  export type Props = {\n    /** Belonged sale's {@link IShoppingSale.id } */\n    saleId: string & tags.Format<\"uuid\">;\n\n    /** Request info of pagination, searching and sorting */\n    body: IShoppingSaleQuestion.IRequest;\n  };\n  export type Body = IShoppingSaleQuestion.IRequest;\n  export type Response = IPageIShoppingSaleQuestion.ISummary;\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/shoppings/admins/sales/:saleId/questions\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Omit<Props, \"body\">) =>\n    `/shoppings/admins/sales/${encodeURIComponent(props.saleId ?? \"null\")}/questions`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IPageIShoppingSaleQuestion.ISummary =>\n    typia.random<IPageIShoppingSaleQuestion.ISummary>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: patchBySaleid.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patchBySaleid.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"saleId\")(() => typia.assert(props.saleId));\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Get a question info.\n *\n * Get a detailed {@link IShoppingSaleQuestion question} information of a\n * {@link IShoppingSale sale}.\n *\n * For reference, if you're a {@link IShoppingSeller seller}, you can only access\n * to the your own {@link IShoppingSale sale}'s question. Otherwise you are a\n * {@link IShoppingCustomer customer}, you can access to every questions of the\n * sales except the {@link IShoppingSaleQuestion.secret} value is `false`.\n *\n * @param props.saleId Belonged sale's {@link IShoppingSale.id }\n * @param props.id Target question's {@link IShoppingSaleQuestion.id }\n * @path /shoppings/admins/sales/:saleId/questions/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getBySaleidAndId(\n  connection: IConnection,\n  props: getBySaleidAndId.Props,\n): Promise<getBySaleidAndId.Response> {\n  return !!connection.simulate\n    ? getBySaleidAndId.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getBySaleidAndId.METADATA,\n          path: getBySaleidAndId.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace getBySaleidAndId {\n  export type Props = {\n    /** Belonged sale's {@link IShoppingSale.id } */\n    saleId: string & tags.Format<\"uuid\">;\n\n    /** Target question's {@link IShoppingSaleQuestion.id } */\n    id: string & tags.Format<\"uuid\">;\n  };\n  export type Response = IShoppingSaleQuestion;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/shoppings/admins/sales/:saleId/questions/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/shoppings/admins/sales/${encodeURIComponent(props.saleId ?? \"null\")}/questions/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingSaleQuestion => typia.random<IShoppingSaleQuestion>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: getBySaleidAndId.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getBySaleidAndId.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"saleId\")(() => typia.assert(props.saleId));\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/admins/sales/questions/abridges/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingSaleQuestion } from \"../../../../../../structures/IShoppingSaleQuestion\";\nimport { IPageIShoppingSaleQuestion } from \"../../../../../../structures/IPageIShoppingSaleQuestion\";\n\n/**\n * List up every abridged questions.\n *\n * List up every {@link IShoppingSaleQuestion.IAbridge abridged questions} of a\n * {@link IShoppingSale sale}.\n *\n * As you can see, returned questions are abridged, not detailed. If you want to\n * get the detailed information of a question, use {@link at} function for each\n * article.\n *\n * Also, returned question has {@link IShoppingSaleQuestion.IAridge.answer}\n * property which means the formal answer from the {@link IShoppingSeller}.\n * Additionally, returned question has another special property\n * {@link IShoppingSaleQuestion.IAridge.secret} with masking to other princple\n * properties, and it means only related actors can {@link at read} the\n * question.\n *\n * For reference, if you're a {@link IShoppingSeller seller}, you can only access\n * to the your own {@link IShoppingSale sale}'s questions. Otherwise, you can\n * access to every questions of the sales.\n *\n * By the way, if you want, you can limit the result by configuring\n * {@link IShoppingSaleQuestion.IRequest.search search condition} in the request\n * body. Also, it is possible to customize sequence order of records by\n * configuring {@link IShoppingSaleQuestion.IRequest.sort sort condition}.\n *\n * @param props.saleId Belonged sale's {@link IShoppingSale.id }\n * @param props.body Request info of pagination, searching and sorting\n * @path /shoppings/admins/sales/:saleId/questions/abridges\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patchBySaleid(\n  connection: IConnection,\n  props: patchBySaleid.Props,\n): Promise<patchBySaleid.Response> {\n  return !!connection.simulate\n    ? patchBySaleid.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patchBySaleid.METADATA,\n          path: patchBySaleid.path(props),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace patchBySaleid {\n  export type Props = {\n    /** Belonged sale's {@link IShoppingSale.id } */\n    saleId: string & tags.Format<\"uuid\">;\n\n    /** Request info of pagination, searching and sorting */\n    body: IShoppingSaleQuestion.IRequest;\n  };\n  export type Body = IShoppingSaleQuestion.IRequest;\n  export type Response = IPageIShoppingSaleQuestion.IAbridge;\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/shoppings/admins/sales/:saleId/questions/abridges\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Omit<Props, \"body\">) =>\n    `/shoppings/admins/sales/${encodeURIComponent(props.saleId ?? \"null\")}/questions/abridges`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IPageIShoppingSaleQuestion.IAbridge =>\n    typia.random<IPageIShoppingSaleQuestion.IAbridge>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: patchBySaleid.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patchBySaleid.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"saleId\")(() => typia.assert(props.saleId));\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/admins/sales/reviews/comments/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingSaleInquiryComment } from \"../../../../../../structures/IShoppingSaleInquiryComment\";\nimport { IPageIShoppingSaleInquiryComment } from \"../../../../../../structures/IPageIShoppingSaleInquiryComment\";\n\n/**\n * Create an inquiry comment.\n *\n * Create an {@link IShoppingSaleInquiryComment inquiry comment} of a\n * {@link IShoppingSaleQuestion question} or {@link IShoppingSaleReview review}.\n *\n * For reference, if you're a {@link IShoppingSeller seller}, you can only create\n * an inquiry comment to your own {@link IShoppingSale sale}'s inquiry.\n * Otherwise, you can create an inquiry comment to every inquiries of the\n * sales.\n *\n * @param props.saleId Belonged sale's {@link IShoppingSale.id }\n * @param props.inquiryId Target inquiry's {@link IShoppingSaleInquiry.id }\n * @param props.body Creation info of the inquiry comment\n * @path /shoppings/admins/sales/:saleId/reviews/:inquiryId/comments\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function postBySaleidAndInquiryid(\n  connection: IConnection,\n  props: postBySaleidAndInquiryid.Props,\n): Promise<postBySaleidAndInquiryid.Response> {\n  return !!connection.simulate\n    ? postBySaleidAndInquiryid.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...postBySaleidAndInquiryid.METADATA,\n          path: postBySaleidAndInquiryid.path(props),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace postBySaleidAndInquiryid {\n  export type Props = {\n    /** Belonged sale's {@link IShoppingSale.id } */\n    saleId: string & tags.Format<\"uuid\">;\n\n    /** Target inquiry's {@link IShoppingSaleInquiry.id } */\n    inquiryId: string & tags.Format<\"uuid\">;\n\n    /** Creation info of the inquiry comment */\n    body: IShoppingSaleInquiryComment.ICreate;\n  };\n  export type Body = IShoppingSaleInquiryComment.ICreate;\n  export type Response = IShoppingSaleInquiryComment;\n\n  export const METADATA = {\n    method: \"POST\",\n    path: \"/shoppings/admins/sales/:saleId/reviews/:inquiryId/comments\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Omit<Props, \"body\">) =>\n    `/shoppings/admins/sales/${encodeURIComponent(props.saleId ?? \"null\")}/reviews/${encodeURIComponent(props.inquiryId ?? \"null\")}/comments`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingSaleInquiryComment =>\n    typia.random<IShoppingSaleInquiryComment>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: postBySaleidAndInquiryid.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: postBySaleidAndInquiryid.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"saleId\")(() => typia.assert(props.saleId));\n      assert.param(\"inquiryId\")(() => typia.assert(props.inquiryId));\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * List up every inquiry comments.\n *\n * List up every {@link IShoppingSaleInquiryComment inquiry comments} of a\n * {@link IShoppingSaleQuestion question} or {@link IShoppingSaleReview review}\n * with {@link IPage pagination}.\n *\n * If you want, you can limit the result by configuring\n * {@link IShoppingSaleInquiryComment.IRequest.search search condition} in the\n * request body. Also, it is possible to customize sequence order of records by\n * configuring {@link IShoppingSaleInquiryComment.IRequest.sort sort condition}.\n *\n * By the way, if you're a {@link IShoppingSeller seller}, you can only access to\n * the your own {@link IShoppingSale sale}'s inquiries. Otherwise, you can access\n * to every inquiries of the sales.\n *\n * @param props.saleId Belonged sale's {@link IShoppingSale.id }\n * @param props.inquiryId Belonged inquiry's {@link IShoppingSaleInquiry.id }\n * @param props.body Request info of pagination, searching and sorting\n * @path /shoppings/admins/sales/:saleId/reviews/:inquiryId/comments\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patchBySaleidAndInquiryid(\n  connection: IConnection,\n  props: patchBySaleidAndInquiryid.Props,\n): Promise<patchBySaleidAndInquiryid.Response> {\n  return !!connection.simulate\n    ? patchBySaleidAndInquiryid.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patchBySaleidAndInquiryid.METADATA,\n          path: patchBySaleidAndInquiryid.path(props),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace patchBySaleidAndInquiryid {\n  export type Props = {\n    /** Belonged sale's {@link IShoppingSale.id } */\n    saleId: string & tags.Format<\"uuid\">;\n\n    /** Belonged inquiry's {@link IShoppingSaleInquiry.id } */\n    inquiryId: string & tags.Format<\"uuid\">;\n\n    /** Request info of pagination, searching and sorting */\n    body: IShoppingSaleInquiryComment.IRequest;\n  };\n  export type Body = IShoppingSaleInquiryComment.IRequest;\n  export type Response = IPageIShoppingSaleInquiryComment;\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/shoppings/admins/sales/:saleId/reviews/:inquiryId/comments\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Omit<Props, \"body\">) =>\n    `/shoppings/admins/sales/${encodeURIComponent(props.saleId ?? \"null\")}/reviews/${encodeURIComponent(props.inquiryId ?? \"null\")}/comments`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IPageIShoppingSaleInquiryComment =>\n    typia.random<IPageIShoppingSaleInquiryComment>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: patchBySaleidAndInquiryid.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patchBySaleidAndInquiryid.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"saleId\")(() => typia.assert(props.saleId));\n      assert.param(\"inquiryId\")(() => typia.assert(props.inquiryId));\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Get an inquiry comment info.\n *\n * Get a detailed {@link IShoppingSaleInquiryComment inquiry comment} information\n * of a {@link IShoppingSaleQuestion question} or\n * {@link IShoppingSaleReview review}.\n *\n * For reference, if you're a {@link IShoppingSeller seller}, you can only access\n * to the your own {@link IShoppingSale sale}'s inquiry comment. Otherwise, you\n * can access to every inquiry comments of the sales.\n *\n * @param props.saleId Belonged sale's {@link IShoppingSale.id }\n * @param props.inquiryId Belonged inquiry's {@link IShoppingSaleInquiry.id }\n * @param props.id Target inquiry comment's\n *   {@link IShoppingSaleInquiryComment.id }\n * @path /shoppings/admins/sales/:saleId/reviews/:inquiryId/comments/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getBySaleidAndInquiryidAndId(\n  connection: IConnection,\n  props: getBySaleidAndInquiryidAndId.Props,\n): Promise<getBySaleidAndInquiryidAndId.Response> {\n  return !!connection.simulate\n    ? getBySaleidAndInquiryidAndId.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getBySaleidAndInquiryidAndId.METADATA,\n          path: getBySaleidAndInquiryidAndId.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace getBySaleidAndInquiryidAndId {\n  export type Props = {\n    /** Belonged sale's {@link IShoppingSale.id } */\n    saleId: string & tags.Format<\"uuid\">;\n\n    /** Belonged inquiry's {@link IShoppingSaleInquiry.id } */\n    inquiryId: string & tags.Format<\"uuid\">;\n\n    /** Target inquiry comment's {@link IShoppingSaleInquiryComment.id } */\n    id: string & tags.Format<\"uuid\">;\n  };\n  export type Response = IShoppingSaleInquiryComment;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/shoppings/admins/sales/:saleId/reviews/:inquiryId/comments/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/shoppings/admins/sales/${encodeURIComponent(props.saleId ?? \"null\")}/reviews/${encodeURIComponent(props.inquiryId ?? \"null\")}/comments/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingSaleInquiryComment =>\n    typia.random<IShoppingSaleInquiryComment>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: getBySaleidAndInquiryidAndId.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getBySaleidAndInquiryidAndId.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"saleId\")(() => typia.assert(props.saleId));\n      assert.param(\"inquiryId\")(() => typia.assert(props.inquiryId));\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Update an inquiry comment.\n *\n * Update an {@link IShoppingSaleInquiryComment inquiry comment} to a specific\n * {@link IShoppingSaleQuestion question} or {@link IShoppingSaleReview review}.\n *\n * By the way, as is the general policy of this shopping mall regarding\n * comments, modifying a comment does not actually change the existing content.\n * Modified content is accumulated and recorded in the existing comment record\n * as a new {@link IShoppingSaleInquiryComment.ISnapshot snapshot}. And this is\n * made public to everyone, who can read this inquiry comment.\n *\n * This is to prevent customers or sellers from modifying their comments and\n * manipulating the circumstances due to the nature of e-commerce, where\n * disputes easily arise. That is, to preserve evidence.\n *\n * @param props.saleId Belonged sale's {@link IShoppingSale.id }\n * @param props.inquiryId Belonged inquiry's {@link IShoppingSaleInquiry.id }\n * @param props.id Target inquiry comment's\n *   {@link IShoppingSaleInquiryComment.id }\n * @param props.body Update info of the inquiry comment\n * @path /shoppings/admins/sales/:saleId/reviews/:inquiryId/comments/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function putBySaleidAndInquiryidAndId(\n  connection: IConnection,\n  props: putBySaleidAndInquiryidAndId.Props,\n): Promise<putBySaleidAndInquiryidAndId.Response> {\n  return !!connection.simulate\n    ? putBySaleidAndInquiryidAndId.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...putBySaleidAndInquiryidAndId.METADATA,\n          path: putBySaleidAndInquiryidAndId.path(props),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace putBySaleidAndInquiryidAndId {\n  export type Props = {\n    /** Belonged sale's {@link IShoppingSale.id } */\n    saleId: string & tags.Format<\"uuid\">;\n\n    /** Belonged inquiry's {@link IShoppingSaleInquiry.id } */\n    inquiryId: string & tags.Format<\"uuid\">;\n\n    /** Target inquiry comment's {@link IShoppingSaleInquiryComment.id } */\n    id: string & tags.Format<\"uuid\">;\n\n    /** Update info of the inquiry comment */\n    body: IShoppingSaleInquiryComment.ICreate;\n  };\n  export type Body = IShoppingSaleInquiryComment.ICreate;\n  export type Response = IShoppingSaleInquiryComment.ISnapshot;\n\n  export const METADATA = {\n    method: \"PUT\",\n    path: \"/shoppings/admins/sales/:saleId/reviews/:inquiryId/comments/:id\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Omit<Props, \"body\">) =>\n    `/shoppings/admins/sales/${encodeURIComponent(props.saleId ?? \"null\")}/reviews/${encodeURIComponent(props.inquiryId ?? \"null\")}/comments/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingSaleInquiryComment.ISnapshot =>\n    typia.random<IShoppingSaleInquiryComment.ISnapshot>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: putBySaleidAndInquiryidAndId.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: putBySaleidAndInquiryidAndId.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"saleId\")(() => typia.assert(props.saleId));\n      assert.param(\"inquiryId\")(() => typia.assert(props.inquiryId));\n      assert.param(\"id\")(() => typia.assert(props.id));\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/admins/sales/reviews/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingSaleReview } from \"../../../../../structures/IShoppingSaleReview\";\nimport { IPageIShoppingSaleReview } from \"../../../../../structures/IPageIShoppingSaleReview\";\nexport * as comments from \"./comments\";\nexport * as abridges from \"./abridges\";\n\n/**\n * List up every summarized reviews.\n *\n * List up every {@link IShoppingSaleReview.ISummary summarized reviews} of a\n * {@link IShoppingSale sale}.\n *\n * As you can see, returned reviews are summarized, not detailed. If you want to\n * get the detailed information of a review, use {@link adridges} function or\n * {@link at} function for each article.\n *\n * Also, returned review has {@link IShoppingSaleReview.ISummary.answer} property\n * which means the formal answer from the {@link IShoppingSeller}.\n *\n * For reference, if you're a {@link IShoppingSeller seller}, you can only access\n * to the your own {@link IShoppingSale sale}'s reviews. Otherwise, you can\n * access to every reviews of the sales.\n *\n * By the way, if you want, you can limit the result by configuring\n * {@link IShoppingSaleReview.IRequest.search search condition} in the request\n * body. Also, it is possible to customize sequence order of records by\n * configuring {@link IShoppingSaleReview.IRequest.sort sort condition}.\n *\n * @param props.saleId Belonged sale's {@link IShoppingSale.id }\n * @param props.body Request info of pagination, searching and sorting\n * @path /shoppings/admins/sales/:saleId/reviews\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patchBySaleid(\n  connection: IConnection,\n  props: patchBySaleid.Props,\n): Promise<patchBySaleid.Response> {\n  return !!connection.simulate\n    ? patchBySaleid.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patchBySaleid.METADATA,\n          path: patchBySaleid.path(props),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace patchBySaleid {\n  export type Props = {\n    /** Belonged sale's {@link IShoppingSale.id } */\n    saleId: string & tags.Format<\"uuid\">;\n\n    /** Request info of pagination, searching and sorting */\n    body: IShoppingSaleReview.IRequest;\n  };\n  export type Body = IShoppingSaleReview.IRequest;\n  export type Response = IPageIShoppingSaleReview.ISummary;\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/shoppings/admins/sales/:saleId/reviews\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Omit<Props, \"body\">) =>\n    `/shoppings/admins/sales/${encodeURIComponent(props.saleId ?? \"null\")}/reviews`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IPageIShoppingSaleReview.ISummary =>\n    typia.random<IPageIShoppingSaleReview.ISummary>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: patchBySaleid.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patchBySaleid.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"saleId\")(() => typia.assert(props.saleId));\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Get a review info.\n *\n * Get a detailed {@link IShoppingSaleReview review} information of a\n * {@link IShoppingSale sale}.\n *\n * For reference, if you're a {@link IShoppingSeller seller}, you can only access\n * to the your own {@link IShoppingSale sale}'s review. Otherwise you are a\n * {@link IShoppingCustomer customer}, you can access to every reviews of the\n * sales.\n *\n * @param props.saleId Belonged sale's {@link IShoppingSale.id }\n * @param props.id Target review's {@link IShoppingSaleReview.id }\n * @path /shoppings/admins/sales/:saleId/reviews/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getBySaleidAndId(\n  connection: IConnection,\n  props: getBySaleidAndId.Props,\n): Promise<getBySaleidAndId.Response> {\n  return !!connection.simulate\n    ? getBySaleidAndId.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getBySaleidAndId.METADATA,\n          path: getBySaleidAndId.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace getBySaleidAndId {\n  export type Props = {\n    /** Belonged sale's {@link IShoppingSale.id } */\n    saleId: string & tags.Format<\"uuid\">;\n\n    /** Target review's {@link IShoppingSaleReview.id } */\n    id: string & tags.Format<\"uuid\">;\n  };\n  export type Response = IShoppingSaleReview;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/shoppings/admins/sales/:saleId/reviews/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/shoppings/admins/sales/${encodeURIComponent(props.saleId ?? \"null\")}/reviews/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingSaleReview => typia.random<IShoppingSaleReview>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: getBySaleidAndId.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getBySaleidAndId.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"saleId\")(() => typia.assert(props.saleId));\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/admins/sales/reviews/abridges/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingSaleReview } from \"../../../../../../structures/IShoppingSaleReview\";\nimport { IPageIShoppingSaleReview } from \"../../../../../../structures/IPageIShoppingSaleReview\";\n\n/**\n * List up every abridged reviews.\n *\n * List up every {@link IShoppingSaleReview.IAbridge abridged reviews} of a\n * {@link IShoppingSale sale}.\n *\n * As you can see, returned reviews are abridged, not detailed. If you want to\n * get the detailed information of a review, use {@link at} function for each\n * article.\n *\n * Also, returned review has {@link IShoppingSaleReview.IAridge.answer} property\n * which means the formal answer from the {@link IShoppingSeller}.\n *\n * For reference, if you're a {@link IShoppingSeller seller}, you can only access\n * to the your own {@link IShoppingSale sale}'s reviews. Otherwise, you can\n * access to every reviews of the sales.\n *\n * By the way, if you want, you can limit the result by configuring\n * {@link IShoppingSaleReview.IRequest.search search condition} in the request\n * body. Also, it is possible to customize sequence order of records by\n * configuring {@link IShoppingSaleReview.IRequest.sort sort condition}.\n *\n * @param props.saleId Belonged sale's {@link IShoppingSale.id }\n * @param props.body Request info of pagination, searching and sorting\n * @path /shoppings/admins/sales/:saleId/reviews/abridges\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patchBySaleid(\n  connection: IConnection,\n  props: patchBySaleid.Props,\n): Promise<patchBySaleid.Response> {\n  return !!connection.simulate\n    ? patchBySaleid.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patchBySaleid.METADATA,\n          path: patchBySaleid.path(props),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace patchBySaleid {\n  export type Props = {\n    /** Belonged sale's {@link IShoppingSale.id } */\n    saleId: string & tags.Format<\"uuid\">;\n\n    /** Request info of pagination, searching and sorting */\n    body: IShoppingSaleReview.IRequest;\n  };\n  export type Body = IShoppingSaleReview.IRequest;\n  export type Response = IPageIShoppingSaleReview.IAbridge;\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/shoppings/admins/sales/:saleId/reviews/abridges\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Omit<Props, \"body\">) =>\n    `/shoppings/admins/sales/${encodeURIComponent(props.saleId ?? \"null\")}/reviews/abridges`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IPageIShoppingSaleReview.IAbridge =>\n    typia.random<IPageIShoppingSaleReview.IAbridge>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: patchBySaleid.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patchBySaleid.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"saleId\")(() => typia.assert(props.saleId));\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/admins/sales/snapshots/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IPage } from \"../../../../../structures/IPage\";\nimport { IPageIShoppingSaleSnapshot } from \"../../../../../structures/IPageIShoppingSaleSnapshot\";\nimport { IShoppingSaleSnapshot } from \"../../../../../structures/IShoppingSaleSnapshot\";\nexport * as flip from \"./flip\";\n\n/**\n * List up every snapshots.\n *\n * Whenever {@link IShoppingSeller seller} updates a {@link IShoppingSale sale},\n * the sale record is not updated but a new\n * {@link IShoppingSaleSnapshot snapshot} record is created to keep the integrity\n * of the sale history. This API function is for listing up such snapshot\n * records.\n *\n * Also, as you can see from the return type, returned snapshots are summarized,\n * not detailed. If you want to get the detailed information of a snapshot, use\n * {@link at} or {@link flipo} function for each snapshot.\n *\n * For reference, if you're a {@link IShoppingSeller seller}, you can only access\n * to the your own {@link IShoppingSale sale}'s snapshots. Otherwise, you can\n * access to every snapshots of the sales even though the sale has been closed\n * or suspended.\n *\n * @param props.saleId Target sale's {@link IShoppingSale.id }\n * @param props.body Requestion info of pagination\n * @path /shoppings/admins/sales/:saleId/snapshots\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patchBySaleid(\n  connection: IConnection,\n  props: patchBySaleid.Props,\n): Promise<patchBySaleid.Response> {\n  return !!connection.simulate\n    ? patchBySaleid.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patchBySaleid.METADATA,\n          path: patchBySaleid.path(props),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace patchBySaleid {\n  export type Props = {\n    /** Target sale's {@link IShoppingSale.id } */\n    saleId: string & tags.Format<\"uuid\">;\n\n    /** Requestion info of pagination */\n    body: IPage.IRequest;\n  };\n  export type Body = IPage.IRequest;\n  export type Response = IPageIShoppingSaleSnapshot.ISummary;\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/shoppings/admins/sales/:saleId/snapshots\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Omit<Props, \"body\">) =>\n    `/shoppings/admins/sales/${encodeURIComponent(props.saleId ?? \"null\")}/snapshots`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IPageIShoppingSaleSnapshot.ISummary =>\n    typia.random<IPageIShoppingSaleSnapshot.ISummary>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: patchBySaleid.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patchBySaleid.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"saleId\")(() => typia.assert(props.saleId));\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Get a snapshot info.\n *\n * Get a {@link IShoppingSaleSnapshot snapshot} with detailed information.\n *\n * As you can see from the return type, returned snapshot does not contain the\n * {@link IShoppingSale sale} info. If you want to get the sale info, use the\n * {@link flip} function instead.\n *\n * For reference, if you're a {@link IShoppingSeller seller}, you can only access\n * to the your own {@link IShoppingSale sale}'s snapshots. Otherwise, you can\n * access to every snapshots of the sales even though the sale has been closed\n * or suspended.\n *\n * @param props.saleId Belonged sale's {@link IShoppingSale.id }\n * @param props.id Target snapshot's {@link IShoppingSaleSnapshot.id }\n * @path /shoppings/admins/sales/:saleId/snapshots/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getBySaleidAndId(\n  connection: IConnection,\n  props: getBySaleidAndId.Props,\n): Promise<getBySaleidAndId.Response> {\n  return !!connection.simulate\n    ? getBySaleidAndId.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getBySaleidAndId.METADATA,\n          path: getBySaleidAndId.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace getBySaleidAndId {\n  export type Props = {\n    /** Belonged sale's {@link IShoppingSale.id } */\n    saleId: string & tags.Format<\"uuid\">;\n\n    /** Target snapshot's {@link IShoppingSaleSnapshot.id } */\n    id: string & tags.Format<\"uuid\">;\n  };\n  export type Response = IShoppingSaleSnapshot;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/shoppings/admins/sales/:saleId/snapshots/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/shoppings/admins/sales/${encodeURIComponent(props.saleId ?? \"null\")}/snapshots/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingSaleSnapshot => typia.random<IShoppingSaleSnapshot>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: getBySaleidAndId.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getBySaleidAndId.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"saleId\")(() => typia.assert(props.saleId));\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/admins/sales/snapshots/flip/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingSale } from \"../../../../../../structures/IShoppingSale\";\n\n/**\n * Get a flipped snapshot info.\n *\n * Get a {@link IShoppingSale sale} info of a flipped snapshot.\n *\n * As you can see from the return type, this function returns the\n * {@link IShoppingSale sale} info. By the way, the sale info is not the latest\n * one, but a flipped info in the snapshot side.\n *\n * Also, if you're a {@link IShoppingSeller seller}, you can only access to the\n * your own {@link IShoppingSale sale}'s snapshots. Otherwise, you can access to\n * every snapshots of the sales even though the sale has been closed or\n * suspended.\n *\n * @param props.saleId Belonged sale's {@link IShoppingSale.id }\n * @param props.id Target snapshot's {@link IShoppingSaleSnapshot.id }\n * @path /shoppings/admins/sales/:saleId/snapshots/:id/flip\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getBySaleidAndId(\n  connection: IConnection,\n  props: getBySaleidAndId.Props,\n): Promise<getBySaleidAndId.Response> {\n  return !!connection.simulate\n    ? getBySaleidAndId.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getBySaleidAndId.METADATA,\n          path: getBySaleidAndId.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace getBySaleidAndId {\n  export type Props = {\n    /** Belonged sale's {@link IShoppingSale.id } */\n    saleId: string & tags.Format<\"uuid\">;\n\n    /** Target snapshot's {@link IShoppingSaleSnapshot.id } */\n    id: string & tags.Format<\"uuid\">;\n  };\n  export type Response = IShoppingSale;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/shoppings/admins/sales/:saleId/snapshots/:id/flip\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/shoppings/admins/sales/${encodeURIComponent(props.saleId ?? \"null\")}/snapshots/${encodeURIComponent(props.id ?? \"null\")}/flip`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): IShoppingSale =>\n    typia.random<IShoppingSale>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: getBySaleidAndId.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getBySaleidAndId.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"saleId\")(() => typia.assert(props.saleId));\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/admins/systematic/channels/categories/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingChannelCategory } from \"../../../../../../structures/IShoppingChannelCategory\";\nexport * as merge from \"./merge\";\nexport * as invert from \"./invert\";\n\n/**\n * Create a new category.\n *\n * Create a new {@link IShoppingChannelCategory category} of a\n * {@link IShoppingChannel channel} with given name. If required, it is possible\n * to specify the parent category by its ID.\n *\n * @param props.channelCode Belonged channel's {@link IShoppingChannel.code }\n * @param props.body Creation info of the category\n * @path /shoppings/admins/systematic/channels/:channelCode/categories\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function postByChannelcode(\n  connection: IConnection,\n  props: postByChannelcode.Props,\n): Promise<postByChannelcode.Response> {\n  return !!connection.simulate\n    ? postByChannelcode.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...postByChannelcode.METADATA,\n          path: postByChannelcode.path(props),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace postByChannelcode {\n  export type Props = {\n    /** Belonged channel's {@link IShoppingChannel.code } */\n    channelCode: string;\n\n    /** Creation info of the category */\n    body: IShoppingChannelCategory.ICreate;\n  };\n  export type Body = IShoppingChannelCategory.ICreate;\n  export type Response = IShoppingChannelCategory;\n\n  export const METADATA = {\n    method: \"POST\",\n    path: \"/shoppings/admins/systematic/channels/:channelCode/categories\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Omit<Props, \"body\">) =>\n    `/shoppings/admins/systematic/channels/${encodeURIComponent(props.channelCode ?? \"null\")}/categories`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingChannelCategory => typia.random<IShoppingChannelCategory>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: postByChannelcode.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: postByChannelcode.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"channelCode\")(() => typia.assert(props.channelCode));\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * List up every categories with children records.\n *\n * List up every {@link IShoppingChannelCategory.IHierarchical categories} of a\n * {@link IShoppingChannel channel} with pagination. Returned categories contain\n * children categories, too.\n *\n * If you want, you can limit the result by configuring\n * {@link IShoppingChannelCategory.IRequest.search search condition} in the\n * request body. Also, it is possible to customize sequence order of records by\n * configuring {@link IShoppingChannelCategory.IRequest.sort sort condition}.\n *\n * @param props.channelCode Belonged channel's {@link IShoppingChannel.code }\n * @path /shoppings/admins/systematic/channels/:channelCode/categories\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patchByChannelcode(\n  connection: IConnection,\n  props: patchByChannelcode.Props,\n): Promise<void> {\n  return !!connection.simulate\n    ? patchByChannelcode.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patchByChannelcode.METADATA,\n          path: patchByChannelcode.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace patchByChannelcode {\n  export type Props = {\n    /** Belonged channel's {@link IShoppingChannel.code } */\n    channelCode: string;\n  };\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/shoppings/admins/systematic/channels/:channelCode/categories\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/shoppings/admins/systematic/channels/${encodeURIComponent(props.channelCode ?? \"null\")}/categories`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): void =>\n    typia.random<void>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: patchByChannelcode.Props,\n  ): void => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patchByChannelcode.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"channelCode\")(() => typia.assert(props.channelCode));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Get a category info.\n *\n * Get a detailed {@link IShoppingChannelCategory category} information.\n *\n * Returned category contains hierarchical children categories, and also\n * contains the recursive parent categories, too.\n *\n * @param props.channelCode Belonged channel's {@link IShoppingChannel.code }\n * @param props.id Target category's {@link IShoppingChannelCategory.id }\n * @path /shoppings/admins/systematic/channels/:channelCode/categories/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getByChannelcodeAndId(\n  connection: IConnection,\n  props: getByChannelcodeAndId.Props,\n): Promise<getByChannelcodeAndId.Response> {\n  return !!connection.simulate\n    ? getByChannelcodeAndId.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getByChannelcodeAndId.METADATA,\n          path: getByChannelcodeAndId.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace getByChannelcodeAndId {\n  export type Props = {\n    /** Belonged channel's {@link IShoppingChannel.code } */\n    channelCode: string;\n\n    /** Target category's {@link IShoppingChannelCategory.id } */\n    id: string & tags.Format<\"uuid\">;\n  };\n  export type Response = IShoppingChannelCategory;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/shoppings/admins/systematic/channels/:channelCode/categories/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/shoppings/admins/systematic/channels/${encodeURIComponent(props.channelCode ?? \"null\")}/categories/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingChannelCategory => typia.random<IShoppingChannelCategory>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: getByChannelcodeAndId.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getByChannelcodeAndId.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"channelCode\")(() => typia.assert(props.channelCode));\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Update a category.\n *\n * Update a {@link IShoppingChannelCategory category}'s name. If required, it is\n * possible to change the parent category by its ID. Of course, detaching from\n * the parent category so that becoming the root category is also possible.\n *\n * @param props.channelCode Belonged channel's {@link IShoppingChannel.code }\n * @param props.id Target category's {@link IShoppingChannelCategory.id }\n * @param props.body Update info of the category\n * @path /shoppings/admins/systematic/channels/:channelCode/categories/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function putByChannelcodeAndId(\n  connection: IConnection,\n  props: putByChannelcodeAndId.Props,\n): Promise<void> {\n  return !!connection.simulate\n    ? putByChannelcodeAndId.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...putByChannelcodeAndId.METADATA,\n          path: putByChannelcodeAndId.path(props),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace putByChannelcodeAndId {\n  export type Props = {\n    /** Belonged channel's {@link IShoppingChannel.code } */\n    channelCode: string;\n\n    /** Target category's {@link IShoppingChannelCategory.id } */\n    id: string;\n\n    /** Update info of the category */\n    body: IShoppingChannelCategory.ICreate;\n  };\n  export type Body = IShoppingChannelCategory.ICreate;\n\n  export const METADATA = {\n    method: \"PUT\",\n    path: \"/shoppings/admins/systematic/channels/:channelCode/categories/:id\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Omit<Props, \"body\">) =>\n    `/shoppings/admins/systematic/channels/${encodeURIComponent(props.channelCode ?? \"null\")}/categories/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): void =>\n    typia.random<void>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: putByChannelcodeAndId.Props,\n  ): void => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: putByChannelcodeAndId.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"channelCode\")(() => typia.assert(props.channelCode));\n      assert.param(\"id\")(() => typia.assert(props.id));\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/admins/systematic/channels/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingChannel } from \"../../../../../structures/IShoppingChannel\";\nimport { IPageIShoppingChannel } from \"../../../../../structures/IPageIShoppingChannel\";\nexport * as categories from \"./categories\";\nexport * as merge from \"./merge\";\nexport * as hierarchical from \"./hierarchical\";\nexport * as get from \"./get\";\n\n/**\n * Create a new channel.\n *\n * Create a new {@link IShoppingChannel channel} with given code and name.\n *\n * As channel means an individual market,\n * {@link IShoppingAdministrator administrator} should perform this action only\n * when a new application being registered.\n *\n * @param props.body Creation info of the channel\n * @path /shoppings/admins/systematic/channels\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function post(\n  connection: IConnection,\n  props: post.Props,\n): Promise<post.Response> {\n  return !!connection.simulate\n    ? post.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...post.METADATA,\n          path: post.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace post {\n  export type Props = {\n    /** Creation info of the channel */\n    body: IShoppingChannel.ICreate;\n  };\n  export type Body = IShoppingChannel.ICreate;\n  export type Response = IShoppingChannel;\n\n  export const METADATA = {\n    method: \"POST\",\n    path: \"/shoppings/admins/systematic/channels\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/shoppings/admins/systematic/channels\";\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingChannel => typia.random<IShoppingChannel>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: post.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: post.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * List up every channels.\n *\n * List up every {@link IShoppingChannel channels} with pagination.\n *\n * If you want, you can limit the result by configuring\n * {@link IShoppingChannel.IRequest.search search condition} in the request body.\n * Also, it is possible to customize sequence order of records by configuring\n * {@link IShoppingChannel.IRequest.sort sort condition}.\n *\n * @param props.body Request info of pagination, searching and sorting\n * @path /shoppings/admins/systematic/channels\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patch(\n  connection: IConnection,\n  props: patch.Props,\n): Promise<patch.Response> {\n  return !!connection.simulate\n    ? patch.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patch.METADATA,\n          path: patch.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace patch {\n  export type Props = {\n    /** Request info of pagination, searching and sorting */\n    body: IShoppingChannel.IRequest;\n  };\n  export type Body = IShoppingChannel.IRequest;\n  export type Response = IPageIShoppingChannel;\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/shoppings/admins/systematic/channels\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/shoppings/admins/systematic/channels\";\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IPageIShoppingChannel => typia.random<IPageIShoppingChannel>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: patch.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patch.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Get a channel info.\n *\n * Get a detailed {@link IShoppingChannel.IHierarchical channel} information.\n *\n * Returned channel instance also contains the nested\n * {@link IShoppingChannelCategory.IHierarchical hierarchical category}\n * information.\n *\n * @param props.id Target channel's {@link IShoppingChannel.id }\n * @path /shoppings/admins/systematic/channels/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getById(\n  connection: IConnection,\n  props: getById.Props,\n): Promise<getById.Response> {\n  return !!connection.simulate\n    ? getById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getById.METADATA,\n          path: getById.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace getById {\n  export type Props = {\n    /** Target channel's {@link IShoppingChannel.id } */\n    id: string & tags.Format<\"uuid\">;\n  };\n  export type Response = IShoppingChannel.IHierarchical;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/shoppings/admins/systematic/channels/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/shoppings/admins/systematic/channels/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingChannel.IHierarchical =>\n    typia.random<IShoppingChannel.IHierarchical>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: getById.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Update a channel.\n *\n * Update a {@link IShoppingChannel channel}'s name.\n *\n * Note that, it is not possible to change the channel's code. If you want to to\n * do it forcibly, then {@link create} new one and {@link merge} with it.\n *\n * @param props.id Target channel's {@link IShoppingChannel.code }\n * @param props.body Update info of the channel\n * @path /shoppings/admins/systematic/channels/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function putById(\n  connection: IConnection,\n  props: putById.Props,\n): Promise<void> {\n  return !!connection.simulate\n    ? putById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...putById.METADATA,\n          path: putById.path(props),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace putById {\n  export type Props = {\n    /** Target channel's {@link IShoppingChannel.code } */\n    id: string & tags.Format<\"uuid\">;\n\n    /** Update info of the channel */\n    body: IShoppingChannel.IUpdate;\n  };\n  export type Body = IShoppingChannel.IUpdate;\n\n  export const METADATA = {\n    method: \"PUT\",\n    path: \"/shoppings/admins/systematic/channels/:id\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Omit<Props, \"body\">) =>\n    `/shoppings/admins/systematic/channels/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): void =>\n    typia.random<void>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: putById.Props,\n  ): void => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: putById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/admins/systematic/index.ts": "export * as channels from \"./channels\";\nexport * as sections from \"./sections\";\n",
  "src/api/functional/shoppings/admins/systematic/channels/categories/merge/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IRecordMerge } from \"../../../../../../../structures/IRecordMerge\";\n\n/**\n * Merge multiple categories into one.\n *\n * In this shopping mall system, it is not possible to delete a\n * {@link IShoppingChannelCategory category}, because it is a systematic entity\n * affecting to all other core entities like {@link IShoppingSale sales}. Instead\n * of deleting, you can merge multiple categories into one.\n *\n * If you specify a category to absorb others, then all of other categories will\n * be merged into the specified one. Also, subsidiary entities of categories\n * also be merged and their references also be merged cascadingly.\n *\n * @param props.channelCode Belonged channel's {@link IShoppingChannel.code }\n * @param props.body Merge info of the categories\n * @path /shoppings/admins/systematic/channels/:channelCode/categories/merge\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function eraseByChannelcode(\n  connection: IConnection,\n  props: eraseByChannelcode.Props,\n): Promise<void> {\n  return !!connection.simulate\n    ? eraseByChannelcode.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...eraseByChannelcode.METADATA,\n          path: eraseByChannelcode.path(props),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace eraseByChannelcode {\n  export type Props = {\n    /** Belonged channel's {@link IShoppingChannel.code } */\n    channelCode: string;\n\n    /** Merge info of the categories */\n    body: IRecordMerge;\n  };\n  export type Body = IRecordMerge;\n\n  export const METADATA = {\n    method: \"DELETE\",\n    path: \"/shoppings/admins/systematic/channels/:channelCode/categories/merge\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Omit<Props, \"body\">) =>\n    `/shoppings/admins/systematic/channels/${encodeURIComponent(props.channelCode ?? \"null\")}/categories/merge`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): void =>\n    typia.random<void>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: eraseByChannelcode.Props,\n  ): void => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: eraseByChannelcode.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"channelCode\")(() => typia.assert(props.channelCode));\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/admins/systematic/channels/categories/invert/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingChannelCategory } from \"../../../../../../../structures/IShoppingChannelCategory\";\n\n/**\n * Get a category info of inverted.\n *\n * Get a inverted {@link IShoppingChannelCategory.IInvert category} information.\n *\n * Returned category contains the recursive parent categories, but not contains\n * the hierarchical children categories.\n *\n * @param props.channelCode Belonged channel's {@link IShoppingChannel.code }\n * @param props.id Target category's {@link IShoppingChannelCategory.id }\n * @path /shoppings/admins/systematic/channels/:channelCode/categories/:id/invert\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getByChannelcodeAndId(\n  connection: IConnection,\n  props: getByChannelcodeAndId.Props,\n): Promise<getByChannelcodeAndId.Response> {\n  return !!connection.simulate\n    ? getByChannelcodeAndId.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getByChannelcodeAndId.METADATA,\n          path: getByChannelcodeAndId.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace getByChannelcodeAndId {\n  export type Props = {\n    /** Belonged channel's {@link IShoppingChannel.code } */\n    channelCode: string;\n\n    /** Target category's {@link IShoppingChannelCategory.id } */\n    id: string & tags.Format<\"uuid\">;\n  };\n  export type Response = IShoppingChannelCategory.IInvert;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/shoppings/admins/systematic/channels/:channelCode/categories/:id/invert\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/shoppings/admins/systematic/channels/${encodeURIComponent(props.channelCode ?? \"null\")}/categories/${encodeURIComponent(props.id ?? \"null\")}/invert`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingChannelCategory.IInvert =>\n    typia.random<IShoppingChannelCategory.IInvert>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: getByChannelcodeAndId.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getByChannelcodeAndId.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"channelCode\")(() => typia.assert(props.channelCode));\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/admins/systematic/channels/merge/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IRecordMerge } from \"../../../../../../structures/IRecordMerge\";\n\n/**\n * Merge multiple channels into one.\n *\n * In this shopping mall system, it is not possible to delete a\n * {@link IShoppingChannel channel}, because it is a systematic entity affecting\n * to all other core entities like customers, members and sales. Instead of\n * deleting, you can merge multiple channels into one.\n *\n * If you specify a channel to absorb others, then all of other channels will be\n * merged into the specified one. Also, subsidiary entities of channels also be\n * merged and their references also be merged cascadingly.\n *\n * @param props.body Request info of the merge\n * @path /shoppings/admins/systematic/channels/merge\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function erase(\n  connection: IConnection,\n  props: erase.Props,\n): Promise<void> {\n  return !!connection.simulate\n    ? erase.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...erase.METADATA,\n          path: erase.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace erase {\n  export type Props = {\n    /** Request info of the merge */\n    body: IRecordMerge;\n  };\n  export type Body = IRecordMerge;\n\n  export const METADATA = {\n    method: \"DELETE\",\n    path: \"/shoppings/admins/systematic/channels/merge\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/shoppings/admins/systematic/channels/merge\";\n  export const random = (g?: Partial<typia.IRandomGenerator>): void =>\n    typia.random<void>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: erase.Props,\n  ): void => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: erase.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/admins/systematic/channels/hierarchical/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingChannel } from \"../../../../../../structures/IShoppingChannel\";\nimport { IPageIShoppingChannel } from \"../../../../../../structures/IPageIShoppingChannel\";\n\n/**\n * List up every channels with nested categories.\n *\n * List up every {@link IShoppingChannel.IHierarchical channels} with\n * {@link IPage pagination}. Returned channels contain nested hierarchical\n * {@link IShoppingChannelCategory.IHierarchical categories}.\n *\n * If you want, you can limit the result by configuring\n * {@link IShoppingChannel.IRequest.search search condition} in the request body.\n * Also, it is possible to customize sequence order of records by configuring\n * {@link IShoppingChannel.IRequest.sort sort condition}.\n *\n * @param props.body Request info of pagination, searching and sorting\n * @path /shoppings/admins/systematic/channels/hierarchical\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patch(\n  connection: IConnection,\n  props: patch.Props,\n): Promise<patch.Response> {\n  return !!connection.simulate\n    ? patch.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patch.METADATA,\n          path: patch.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace patch {\n  export type Props = {\n    /** Request info of pagination, searching and sorting */\n    body: IShoppingChannel.IRequest;\n  };\n  export type Body = IShoppingChannel.IRequest;\n  export type Response = IPageIShoppingChannel.IHierarchical;\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/shoppings/admins/systematic/channels/hierarchical\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () =>\n    \"/shoppings/admins/systematic/channels/hierarchical\";\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IPageIShoppingChannel.IHierarchical =>\n    typia.random<IPageIShoppingChannel.IHierarchical>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: patch.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patch.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/admins/systematic/channels/get/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingChannel } from \"../../../../../../structures/IShoppingChannel\";\n\n/**\n * Get a channel info by its code.\n *\n * Get a detailed {@link IShoppingChannel.IHierarchical channel} information by\n * its code.\n *\n * Returned channel instance also contains the nested\n * {@link IShoppingChannelCategory.IHierarchical hierarchical category}\n * information.\n *\n * @param props.code Target channel's {@link IShoppingChannel.code }\n * @path /shoppings/admins/systematic/channels/:code/get\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getByCode(\n  connection: IConnection,\n  props: getByCode.Props,\n): Promise<getByCode.Response> {\n  return !!connection.simulate\n    ? getByCode.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getByCode.METADATA,\n          path: getByCode.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace getByCode {\n  export type Props = {\n    /** Target channel's {@link IShoppingChannel.code } */\n    code: string;\n  };\n  export type Response = IShoppingChannel.IHierarchical;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/shoppings/admins/systematic/channels/:code/get\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/shoppings/admins/systematic/channels/${encodeURIComponent(props.code ?? \"null\")}/get`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingChannel.IHierarchical =>\n    typia.random<IShoppingChannel.IHierarchical>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: getByCode.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getByCode.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"code\")(() => typia.assert(props.code));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/admins/systematic/sections/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingSection } from \"../../../../../structures/IShoppingSection\";\nimport { IPageIShoppingSection } from \"../../../../../structures/IPageIShoppingSection\";\nexport * as merge from \"./merge\";\nexport * as get from \"./get\";\n\n/**\n * Create a new section.\n *\n * Create a new {@link IShoppingSection section} with given code and name.\n *\n * As section means a spatial unit of a market that handling different type of\n * products with other section, {@link IShoppingAdministrator administrator}\n * should perform this action only when a new section being required.\n *\n * @param props.body Creation info of the section\n * @path /shoppings/admins/systematic/sections\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function post(\n  connection: IConnection,\n  props: post.Props,\n): Promise<post.Response> {\n  return !!connection.simulate\n    ? post.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...post.METADATA,\n          path: post.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace post {\n  export type Props = {\n    /** Creation info of the section */\n    body: IShoppingSection.ICreate;\n  };\n  export type Body = IShoppingSection.ICreate;\n  export type Response = IShoppingSection;\n\n  export const METADATA = {\n    method: \"POST\",\n    path: \"/shoppings/admins/systematic/sections\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/shoppings/admins/systematic/sections\";\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingSection => typia.random<IShoppingSection>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: post.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: post.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * List up every sections.\n *\n * List up every {@link IShoppingSection sections} with pagination.\n *\n * If you want, you can limit the result by configuring\n * {@link IShoppingSection.IRequest.search search condition} in the request body.\n * Also, it is possible to customize sequence order of records by configuring\n * {@link IShoppingSection.IRequest.sort sort condition}.\n *\n * @param props.body Request info of pagination, searching and sorting\n * @path /shoppings/admins/systematic/sections\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patch(\n  connection: IConnection,\n  props: patch.Props,\n): Promise<patch.Response> {\n  return !!connection.simulate\n    ? patch.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patch.METADATA,\n          path: patch.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace patch {\n  export type Props = {\n    /** Request info of pagination, searching and sorting */\n    body: IShoppingSection.IRequest;\n  };\n  export type Body = IShoppingSection.IRequest;\n  export type Response = IPageIShoppingSection;\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/shoppings/admins/systematic/sections\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/shoppings/admins/systematic/sections\";\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IPageIShoppingSection => typia.random<IPageIShoppingSection>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: patch.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patch.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Get a section info.\n *\n * Get a detailed {@link IShoppingSection section} information.\n *\n * @param props.id Target section's {@link IShoppingSection.id }\n * @path /shoppings/admins/systematic/sections/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getById(\n  connection: IConnection,\n  props: getById.Props,\n): Promise<getById.Response> {\n  return !!connection.simulate\n    ? getById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getById.METADATA,\n          path: getById.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace getById {\n  export type Props = {\n    /** Target section's {@link IShoppingSection.id } */\n    id: string & tags.Format<\"uuid\">;\n  };\n  export type Response = IShoppingSection;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/shoppings/admins/systematic/sections/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/shoppings/admins/systematic/sections/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingSection => typia.random<IShoppingSection>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: getById.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Update a section.\n *\n * Update a {@link IShoppingSection section}'s name.\n *\n * Note that, it is not possible to change the section's code. If you want to to\n * do it forcibly, then {@link create} new one and {@link merge} with it.\n *\n * @param props.id Target section's {@link IShoppingSection.code }\n * @param props.body Update info of the section\n * @path /shoppings/admins/systematic/sections/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function putById(\n  connection: IConnection,\n  props: putById.Props,\n): Promise<void> {\n  return !!connection.simulate\n    ? putById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...putById.METADATA,\n          path: putById.path(props),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace putById {\n  export type Props = {\n    /** Target section's {@link IShoppingSection.code } */\n    id: string & tags.Format<\"uuid\">;\n\n    /** Update info of the section */\n    body: IShoppingSection.IUpdate;\n  };\n  export type Body = IShoppingSection.IUpdate;\n\n  export const METADATA = {\n    method: \"PUT\",\n    path: \"/shoppings/admins/systematic/sections/:id\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Omit<Props, \"body\">) =>\n    `/shoppings/admins/systematic/sections/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): void =>\n    typia.random<void>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: putById.Props,\n  ): void => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: putById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/admins/systematic/sections/merge/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IRecordMerge } from \"../../../../../../structures/IRecordMerge\";\n\n/**\n * Merge multiple sections into one.\n *\n * In this shopping mall system, it is not possible to delete a\n * {@link IShoppingSection section}, because it is a systematic entity affecting\n * to all other core entities like {@link IShoppingSale sales}. Instead of\n * deleting, you can merge multiple sections into one.\n *\n * If you specify a section to absorb others, then all of other sections will be\n * merged into the specified one. Also, subsidiary entities of sections also be\n * merged and their references also be merged cascadingly.\n *\n * @param props.body Input Request info of the merge\n * @path /shoppings/admins/systematic/sections/merge\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function erase(\n  connection: IConnection,\n  props: erase.Props,\n): Promise<void> {\n  return !!connection.simulate\n    ? erase.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...erase.METADATA,\n          path: erase.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace erase {\n  export type Props = {\n    /** Input Request info of the merge */\n    body: IRecordMerge;\n  };\n  export type Body = IRecordMerge;\n\n  export const METADATA = {\n    method: \"DELETE\",\n    path: \"/shoppings/admins/systematic/sections/merge\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/shoppings/admins/systematic/sections/merge\";\n  export const random = (g?: Partial<typia.IRandomGenerator>): void =>\n    typia.random<void>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: erase.Props,\n  ): void => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: erase.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/admins/systematic/sections/get/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingSection } from \"../../../../../../structures/IShoppingSection\";\n\n/**\n * Get a section info by its code.\n *\n * Get a detailed {@link IShoppingSection section} information by its code.\n *\n * @param props.code Target section's {@link IShoppingSection.code }\n * @path /shoppings/admins/systematic/sections/:code/get\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getByCode(\n  connection: IConnection,\n  props: getByCode.Props,\n): Promise<getByCode.Response> {\n  return !!connection.simulate\n    ? getByCode.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getByCode.METADATA,\n          path: getByCode.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace getByCode {\n  export type Props = {\n    /** Target section's {@link IShoppingSection.code } */\n    code: string;\n  };\n  export type Response = IShoppingSection;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/shoppings/admins/systematic/sections/:code/get\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/shoppings/admins/systematic/sections/${encodeURIComponent(props.code ?? \"null\")}/get`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingSection => typia.random<IShoppingSection>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: getByCode.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getByCode.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"code\")(() => typia.assert(props.code));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/customers/authenticate/refresh/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingCustomer } from \"../../../../../structures/IShoppingCustomer\";\n\n/**\n * Refresh the authentication token.\n *\n * Create a new {@link IShoppingCustomer.IToken.access access token} of a\n * {@link IShoppingCustomer customer} with the pre-issued\n * {@link IShoppingCustomer.IToken.refresh refresh} token.\n *\n * Note that, this function is available until the\n * {@link IShoppingCustomer.IToken.refreshable_until} value.\n *\n * @param props.body Refresh token.\n * @path /shoppings/customers/authenticate/refresh\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patch(\n  connection: IConnection,\n  props: patch.Props,\n): Promise<patch.Response> {\n  return !!connection.simulate\n    ? patch.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patch.METADATA,\n          path: patch.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace patch {\n  export type Props = {\n    /** Refresh token. */\n    body: IShoppingCustomer.IRefresh;\n  };\n  export type Body = IShoppingCustomer.IRefresh;\n  export type Response = IShoppingCustomer.IAuthorized;\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/shoppings/customers/authenticate/refresh\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/shoppings/customers/authenticate/refresh\";\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingCustomer.IAuthorized =>\n    typia.random<IShoppingCustomer.IAuthorized>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: patch.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patch.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/customers/authenticate/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingCustomer } from \"../../../../structures/IShoppingCustomer\";\nexport * as refresh from \"./refresh\";\nexport * as join from \"./join\";\nexport * as login from \"./login\";\nexport * as activate from \"./activate\";\nexport * as external from \"./external\";\nexport * as password from \"./password\";\n\n/**\n * Get current customer info.\n *\n * Get current {@link IShoppingCustomer customer} information from the\n * {@link IShoppingCustomer.IToken.access access token}.\n *\n * @path /shoppings/customers/authenticate\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function get(connection: IConnection): Promise<get.Response> {\n  return !!connection.simulate\n    ? get.simulate(connection)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...get.METADATA,\n          path: get.path(),\n          status: null,\n        },\n      );\n}\nexport namespace get {\n  export type Response = IShoppingCustomer;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/shoppings/customers/authenticate\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/shoppings/customers/authenticate\";\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingCustomer => typia.random<IShoppingCustomer>(g);\n  export const simulate = (connection: IConnection): Response => {\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Create a new customer record.\n *\n * This shopping mall system defines everyone participating in this market as a\n * \"customer\". And the customer records are not archived based on individual\n * {@link IShoppingCitizen people}, but based on the unit of connection.\n * Therefore, even if it is the same person, a new {@link IShoppingCustomer}\n * record is created every time a connection is made.\n *\n * Therefore, all Client Applications that access this service must first call\n * this function, report the customer's inflow path to the server, and create an\n * {@link IShoppingCustomer.IToken.access access token}. If you skip this\n * function call, all the other API functions would be prohibited. There is no\n * exception, even if you want to {@link activate} your citizenship or\n * {@link login} with your {@link IShoppingMember member account}. Before\n * authenticating yourself or logging in, be sure to call this function first.\n * This also applies when an {@link IShoppingAdministrator administrator} or\n * {@link IShoppingSeller seller} logs in.\n *\n * Also, the authentication token has an\n * {@link IShoppingCustomer.IToken.expired_at expiration time} and cannot be used\n * permanently. For reference, the authentication token is valid for 3 hours,\n * and if you want to maintain customer authentication even after 3 hours, you\n * must call the {@link refresh} function.\n *\n * @param props.body Creation information of the customer.\n * @path /shoppings/customers/authenticate\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function post(\n  connection: IConnection,\n  props: post.Props,\n): Promise<post.Response> {\n  return !!connection.simulate\n    ? post.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...post.METADATA,\n          path: post.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace post {\n  export type Props = {\n    /** Creation information of the customer. */\n    body: IShoppingCustomer.ICreate;\n  };\n  export type Body = IShoppingCustomer.ICreate;\n  export type Response = IShoppingCustomer.IAuthorized;\n\n  export const METADATA = {\n    method: \"POST\",\n    path: \"/shoppings/customers/authenticate\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/shoppings/customers/authenticate\";\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingCustomer.IAuthorized =>\n    typia.random<IShoppingCustomer.IAuthorized>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: post.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: post.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/customers/index.ts": "export * as authenticate from \"./authenticate\";\nexport * as coupons from \"./coupons\";\nexport * as deposits from \"./deposits\";\nexport * as mileages from \"./mileages\";\nexport * as carts from \"./carts\";\nexport * as orders from \"./orders\";\nexport * as sales from \"./sales\";\nexport * as systematic from \"./systematic\";\n",
  "src/api/functional/shoppings/customers/authenticate/join/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingMember } from \"../../../../../structures/IShoppingMember\";\nimport { IShoppingCustomer } from \"../../../../../structures/IShoppingCustomer\";\n\n/**\n * Join membership.\n *\n * {@link IShoppingCustomer Customer} signs up for\n * {@link IShoppingMember membership} of current shopping mall system.\n *\n * If you've performed the {@link IShoppingCitizen citizenship}\n * {@link activate activation} too, then you can skip the {@link activate}\n * function calling everytime you log in from now on. Also, if the person had\n * {@link IShoppingOrder purchased} with {@link activate} and {@link external}\n * function calling, you can also access to the order history too. In other\n * words, activity details prior to membership registration can also be accessed\n * with continuity.\n *\n * For reference, as described in the {@link create} function, before calling\n * this `join` function, you must first create a customer record and token by\n * calling the {@link create} function.\n *\n * @param props.body Join information of the member\n * @path /shoppings/customers/authenticate/join\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function post(\n  connection: IConnection,\n  props: post.Props,\n): Promise<post.Response> {\n  return !!connection.simulate\n    ? post.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...post.METADATA,\n          path: post.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace post {\n  export type Props = {\n    /** Join information of the member */\n    body: IShoppingMember.IJoin;\n  };\n  export type Body = IShoppingMember.IJoin;\n  export type Response = IShoppingCustomer;\n\n  export const METADATA = {\n    method: \"POST\",\n    path: \"/shoppings/customers/authenticate/join\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/shoppings/customers/authenticate/join\";\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingCustomer => typia.random<IShoppingCustomer>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: post.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: post.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/customers/authenticate/login/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingMember } from \"../../../../../structures/IShoppingMember\";\nimport { IShoppingCustomer } from \"../../../../../structures/IShoppingCustomer\";\n\n/**\n * Membership login.\n *\n * {@link IShoppingCustomer Customer} logs in with his/her\n * {@link IShoppingMember membership} account with the email and password.\n *\n * If the {@link IShoppingMember member} has previously performed\n * {@link activate citizenship activation}, the {@link IShoppingCustomer.citizen}\n * value would be filled in accordingly. And if the member has also signed up as\n * an {@link IShoppingAdministrator administrator} or\n * {@link IShoppingSeller seller}, the relevant information is also entered\n * accordingly.\n *\n * For reference, as described in the {@link create} function, before calling\n * this `login` function, you must first create a customer record and token by\n * calling the {@link create} function.\n *\n * @param props.body Login request info\n * @path /shoppings/customers/authenticate/login\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function put(\n  connection: IConnection,\n  props: put.Props,\n): Promise<put.Response> {\n  return !!connection.simulate\n    ? put.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...put.METADATA,\n          path: put.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace put {\n  export type Props = {\n    /** Login request info */\n    body: IShoppingMember.ILogin;\n  };\n  export type Body = IShoppingMember.ILogin;\n  export type Response = IShoppingCustomer;\n\n  export const METADATA = {\n    method: \"PUT\",\n    path: \"/shoppings/customers/authenticate/login\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/shoppings/customers/authenticate/login\";\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingCustomer => typia.random<IShoppingCustomer>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: put.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: put.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/customers/authenticate/activate/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingCitizen } from \"../../../../../structures/IShoppingCitizen\";\nimport { IShoppingCustomer } from \"../../../../../structures/IShoppingCustomer\";\n\n/**\n * Activate citizenship.\n *\n * {@link IShoppingCustomer Customer} activates his/her\n * {@link IShoppingCitizen citizenship} with mobile number and real name.\n *\n * If the custommer already {@link join joined} to the\n * {@link IShoppingMember membership}, then you can skip the citizenship\n * {@link activation} function calling everytime you log in from now on. Of\n * course, such story would be same to the {@link external} function, too.\n *\n * For reference, as described in the {@link create} function, before calling\n * this `activate` function, you must first create a customer record and token\n * by calling the {@link create} function.\n *\n * @param props.body Activation information of the citizenship\n * @path /shoppings/customers/authenticate/activate\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function post(\n  connection: IConnection,\n  props: post.Props,\n): Promise<post.Response> {\n  return !!connection.simulate\n    ? post.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...post.METADATA,\n          path: post.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace post {\n  export type Props = {\n    /** Activation information of the citizenship */\n    body: IShoppingCitizen.ICreate;\n  };\n  export type Body = IShoppingCitizen.ICreate;\n  export type Response = IShoppingCustomer;\n\n  export const METADATA = {\n    method: \"POST\",\n    path: \"/shoppings/customers/authenticate/activate\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/shoppings/customers/authenticate/activate\";\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingCustomer => typia.random<IShoppingCustomer>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: post.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: post.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/customers/authenticate/external/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingExternalUser } from \"../../../../../structures/IShoppingExternalUser\";\nimport { IShoppingCustomer } from \"../../../../../structures/IShoppingCustomer\";\n\n/**\n * Enroll external user info.\n *\n * {@link IShoppingCustomer Customer} enrolls his/her\n * {@link IShoppingExternalUser external user} information from other service.\n *\n * It has similar effect with the {@link join membership joining} function, so\n * that if you've performed the {@link IShoppingCitizen citizenship}\n * {@link activate activation} too, then you can skip the {@link activate}\n * function calling everytime you call this `external` function with same info\n * from now on. Also, if the person had {@link IShoppingOrder purchased} with\n * {@link activate} and {@link join} function calling, you can also access to the\n * order history too. In other words, activity details prior to external server\n * registration can also be accessed with continuity.\n *\n * For reference, as described in the {@link create} function, before calling\n * this `external` function, you must first create a customer record and token\n * by calling the {@link create} function.\n *\n * @param props.body Enroll information of the external user\n * @path /shoppings/customers/authenticate/external\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function post(\n  connection: IConnection,\n  props: post.Props,\n): Promise<post.Response> {\n  return !!connection.simulate\n    ? post.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...post.METADATA,\n          path: post.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace post {\n  export type Props = {\n    /** Enroll information of the external user */\n    body: IShoppingExternalUser.ICreate;\n  };\n  export type Body = IShoppingExternalUser.ICreate;\n  export type Response = IShoppingCustomer;\n\n  export const METADATA = {\n    method: \"POST\",\n    path: \"/shoppings/customers/authenticate/external\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/shoppings/customers/authenticate/external\";\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingCustomer => typia.random<IShoppingCustomer>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: post.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: post.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/customers/authenticate/password/change/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingMember } from \"../../../../../../structures/IShoppingMember\";\n\n/**\n * Change password.\n *\n * Change password of {@link IShoppingMember member} with the current password.\n *\n * The reason why the current password is required is for security.\n *\n * @param props.body New password and current password\n * @path /shoppings/customers/authenticate/password/change\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function put(\n  connection: IConnection,\n  props: put.Props,\n): Promise<void> {\n  return !!connection.simulate\n    ? put.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...put.METADATA,\n          path: put.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace put {\n  export type Props = {\n    /** New password and current password */\n    body: IShoppingMember.IPasswordChange;\n  };\n  export type Body = IShoppingMember.IPasswordChange;\n\n  export const METADATA = {\n    method: \"PUT\",\n    path: \"/shoppings/customers/authenticate/password/change\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/shoppings/customers/authenticate/password/change\";\n  export const random = (g?: Partial<typia.IRandomGenerator>): void =>\n    typia.random<void>(g);\n  export const simulate = (connection: IConnection, props: put.Props): void => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: put.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/customers/authenticate/password/index.ts": "export * as change from \"./change\";\n",
  "src/api/functional/shoppings/customers/coupons/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingCoupon } from \"../../../../structures/IShoppingCoupon\";\nimport { IPageIShoppingCoupon } from \"../../../../structures/IPageIShoppingCoupon\";\nexport * as tickets from \"./tickets\";\n\n/**\n * List up every coupons.\n *\n * List up every {@link IShoppingCoupon coupons} with pagination.\n *\n * If you want, you can limit the result by configuring\n * {@link IShoppingCoupon.IRequest.search search condition} in the request body.\n * Also, it is possible to customize sequence order of records by configuring\n * {@link IShoppingCoupon.IRequest.sort sort condition}.\n *\n * For reference, if you are a {@link IShoppingCustomer customer}, then only\n * {@link IShoppingCouponTicket ticketable} coupons would be listed up.\n * Otherwise, non-ticketable coupons would also be listed up.\n *\n * @param props.body Request info of pagination, searching and sorting\n * @path /shoppings/customers/coupons\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patch(\n  connection: IConnection,\n  props: patch.Props,\n): Promise<patch.Response> {\n  return !!connection.simulate\n    ? patch.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patch.METADATA,\n          path: patch.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace patch {\n  export type Props = {\n    /** Request info of pagination, searching and sorting */\n    body: IShoppingCoupon.IRequest;\n  };\n  export type Body = IShoppingCoupon.IRequest;\n  export type Response = IPageIShoppingCoupon;\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/shoppings/customers/coupons\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/shoppings/customers/coupons\";\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IPageIShoppingCoupon => typia.random<IPageIShoppingCoupon>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: patch.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patch.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Get a coupon info.\n *\n * Get a {@link IShoppingCoupon coupon} information.\n *\n * If you are a {@link IShoppingCustomer customer}, then only\n * {@link IShoppingCouponTicket ticketable} coupons are accessible. Non\n * ticketable coupons cause 410 gone error. Otherwise you are a\n * {@link IShoppingSeller seller} or {@link IShoppingAdministrator administrator},\n * non-ticketable coupons are also accessible.\n *\n * @param props.id Target coupon's {@link IShoppingCoupon.id }\n * @path /shoppings/customers/coupons/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getById(\n  connection: IConnection,\n  props: getById.Props,\n): Promise<getById.Response> {\n  return !!connection.simulate\n    ? getById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getById.METADATA,\n          path: getById.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace getById {\n  export type Props = {\n    /** Target coupon's {@link IShoppingCoupon.id } */\n    id: string;\n  };\n  export type Response = IShoppingCoupon;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/shoppings/customers/coupons/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/shoppings/customers/coupons/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingCoupon => typia.random<IShoppingCoupon>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: getById.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/customers/coupons/tickets/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingCouponTicket } from \"../../../../../structures/IShoppingCouponTicket\";\nimport { IPageIShoppingCouponTicket } from \"../../../../../structures/IPageIShoppingCouponTicket\";\n\n/**\n * Create a new coupon ticket.\n *\n * Create a new {@link IShoppingCouponTicket coupon ticket} of a specific\n * {@link IShoppingCoupon coupon} for the {@link IShoppingCustomer customer}.\n *\n * By the way, if the target coupon has been\n * {@link IShoppingCoupon.expired_at expired} or\n * {@link IShoppingCoupon.IInventory.volume out of stock} or\n * {@link IShoppingCoupon.IInventory.volume_per_citizen exhausted for him/her},\n * 410 gone exception would be thrown.\n *\n * Also, even though succeeded to create a new coupon ticket from the target\n * coupon, if the coupon has expiration day or date, the newly created ticket\n * also has {@link IShoppingCouponTicket.expired_at expiration time}, and it\n * would be disabled after the expiration time.\n *\n * @param props.body Creation info of coupon ticket\n * @path /shoppings/customers/coupons/tickets\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function post(\n  connection: IConnection,\n  props: post.Props,\n): Promise<post.Response> {\n  return !!connection.simulate\n    ? post.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...post.METADATA,\n          path: post.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace post {\n  export type Props = {\n    /** Creation info of coupon ticket */\n    body: IShoppingCouponTicket.ICreate;\n  };\n  export type Body = IShoppingCouponTicket.ICreate;\n  export type Response = IShoppingCouponTicket;\n\n  export const METADATA = {\n    method: \"POST\",\n    path: \"/shoppings/customers/coupons/tickets\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/shoppings/customers/coupons/tickets\";\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingCouponTicket => typia.random<IShoppingCouponTicket>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: post.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: post.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * List up every coupon tickets.\n *\n * List up every {@link IShoppingCouponTicket coupon tickets} of the\n * {@link IShoppingCustomer customer} with {@link IPage pagination}.\n *\n * For reference, coupon ticket means that a {@link IShoppingCoupon coupon} has\n * been taken by a customer. If the target coupon has expiration day or date,\n * the coupon ticket also has\n * {@link IShoppingCouponTicket.expired_at expiration time}, and such expired\n * tickets would not be listed up. Likewise, tickets used to\n * {@link IShoppingCouponTicketPayment pay} for the {@link IShoppingOrder order}\n * would not be listed up, either.\n *\n * Additionally, you can limit the result by configuring\n * {@link IShoppingCouponTicket.IRequest.search search condition} in the request\n * body. Also, it is possible to customize sequence order of records by\n * configuring {@link IShoppingCouponTicket.IRequest.sort sort condition}.\n *\n * @param props.body Request info of pagination, searching and sorting\n * @path /shoppings/customers/coupons/tickets\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patch(\n  connection: IConnection,\n  props: patch.Props,\n): Promise<patch.Response> {\n  return !!connection.simulate\n    ? patch.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patch.METADATA,\n          path: patch.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace patch {\n  export type Props = {\n    /** Request info of pagination, searching and sorting */\n    body: IShoppingCouponTicket.IRequest;\n  };\n  export type Body = IShoppingCouponTicket.IRequest;\n  export type Response = IPageIShoppingCouponTicket;\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/shoppings/customers/coupons/tickets\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/shoppings/customers/coupons/tickets\";\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IPageIShoppingCouponTicket => typia.random<IPageIShoppingCouponTicket>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: patch.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patch.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Get a coupon ticket.\n *\n * Get a {@link IShoppingCouponTicket coupon ticket} information with its ID.\n *\n * By the way, if the target coupon ticket has been\n * {@link IShoppingCouponTicket.expired_at expired} or used to\n * {@link IShoppingCouponTicketPayment pay} for the {@link IShoppingOrder order},\n * 410 gone exception would be thrown.\n *\n * @param props.id Target coupon ticket's {@link IShoppingCouponTicket.id }\n * @path /shoppings/customers/coupons/tickets/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getById(\n  connection: IConnection,\n  props: getById.Props,\n): Promise<getById.Response> {\n  return !!connection.simulate\n    ? getById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getById.METADATA,\n          path: getById.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace getById {\n  export type Props = {\n    /** Target coupon ticket's {@link IShoppingCouponTicket.id } */\n    id: string & tags.Format<\"uuid\">;\n  };\n  export type Response = IShoppingCouponTicket;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/shoppings/customers/coupons/tickets/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/shoppings/customers/coupons/tickets/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingCouponTicket => typia.random<IShoppingCouponTicket>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: getById.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/customers/deposits/charges/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingDepositCharge } from \"../../../../../structures/IShoppingDepositCharge\";\nimport { IPageIShoppingDepositCharge } from \"../../../../../structures/IPageIShoppingDepositCharge\";\nexport * as publish from \"./publish\";\n\n/**\n * Create a new deposit charge application.\n *\n * Create a new {@link IShoppingDepositCharge deposit charge application}.\n *\n * By the way, this function does not mean completion the deposit charge, but\n * means just {@link IShoppingCustomer customer} is applying the deposit charge.\n * The deposit charge be completed only when customer\n * {@link IShoppingDepositChargePublish.publish pay} the deposit charge.\n *\n * @param props.body Creation info of the deposit charge\n * @path /shoppings/customers/deposits/charges\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function post(\n  connection: IConnection,\n  props: post.Props,\n): Promise<post.Response> {\n  return !!connection.simulate\n    ? post.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...post.METADATA,\n          path: post.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace post {\n  export type Props = {\n    /** Creation info of the deposit charge */\n    body: IShoppingDepositCharge.ICreate;\n  };\n  export type Body = IShoppingDepositCharge.ICreate;\n  export type Response = IShoppingDepositCharge;\n\n  export const METADATA = {\n    method: \"POST\",\n    path: \"/shoppings/customers/deposits/charges\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/shoppings/customers/deposits/charges\";\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingDepositCharge => typia.random<IShoppingDepositCharge>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: post.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: post.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * List up every deposit charges.\n *\n * List up every {@link IShoppingDepositCharge deposit charges} of the\n * {@link IShoppingCustomer customer} with {@link IPage pagination}.\n *\n * If you want, you can limit the result by configuring\n * {@link IShoppingDepositCharge.IRequest.search search condition} in the request\n * body. Also, it is possible to customize sequence order of records by\n * configuring {@link IShoppingDepositCharge.IRequest.sort sort condition}.\n *\n * @param props.body Request info of pagination, searching and sorting\n * @path /shoppings/customers/deposits/charges\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patch(\n  connection: IConnection,\n  props: patch.Props,\n): Promise<patch.Response> {\n  return !!connection.simulate\n    ? patch.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patch.METADATA,\n          path: patch.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace patch {\n  export type Props = {\n    /** Request info of pagination, searching and sorting */\n    body: IShoppingDepositCharge.IRequest;\n  };\n  export type Body = IShoppingDepositCharge.IRequest;\n  export type Response = IPageIShoppingDepositCharge;\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/shoppings/customers/deposits/charges\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/shoppings/customers/deposits/charges\";\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IPageIShoppingDepositCharge =>\n    typia.random<IPageIShoppingDepositCharge>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: patch.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patch.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Get a deposit charge info.\n *\n * Get a {@link IShoppingDepositCharge deposit charge} information.\n *\n * @param props.id Target deposit charge's {@link IShoppingDepositCharge.id }\n * @path /shoppings/customers/deposits/charges/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getById(\n  connection: IConnection,\n  props: getById.Props,\n): Promise<getById.Response> {\n  return !!connection.simulate\n    ? getById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getById.METADATA,\n          path: getById.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace getById {\n  export type Props = {\n    /** Target deposit charge's {@link IShoppingDepositCharge.id } */\n    id: string;\n  };\n  export type Response = IShoppingDepositCharge;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/shoppings/customers/deposits/charges/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/shoppings/customers/deposits/charges/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingDepositCharge => typia.random<IShoppingDepositCharge>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: getById.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Update a deposit charge application.\n *\n * Update value of a {@link IShoppingDepositCharge deposit charge application}\n * that has been applied by the {@link IShoppingCustomer}.\n *\n * If the charge has been {@link IShoppingDepositChargePublish published}, then\n * it is not possible to update the deposit charge. Only 410 gone exception\n * would be thrown.\n *\n * @param props.id Target deposit charge's {@link IShoppingDepositCharge.id }\n * @param props.body Value to change\n * @path /shoppings/customers/deposits/charges/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function putById(\n  connection: IConnection,\n  props: putById.Props,\n): Promise<void> {\n  return !!connection.simulate\n    ? putById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...putById.METADATA,\n          path: putById.path(props),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace putById {\n  export type Props = {\n    /** Target deposit charge's {@link IShoppingDepositCharge.id } */\n    id: string;\n\n    /** Value to change */\n    body: IShoppingDepositCharge.ICreate;\n  };\n  export type Body = IShoppingDepositCharge.ICreate;\n\n  export const METADATA = {\n    method: \"PUT\",\n    path: \"/shoppings/customers/deposits/charges/:id\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Omit<Props, \"body\">) =>\n    `/shoppings/customers/deposits/charges/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): void =>\n    typia.random<void>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: putById.Props,\n  ): void => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: putById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Erase a deposit charge application.\n *\n * Erase a {@link IShoppingDepositCharge deposit charge application} that has\n * been applied by the {@link IShoppingCustomer}.\n *\n * If the charge has been {@link IShoppingDepositChargePublish published}, then\n * it is not possible to erase the deposit charge. In that case, you've to\n * cancel the payment by calling the {@link publish.cancel} function.\n *\n * @param props.id Target deposit charge's {@link IShoppingDepositCharge.id }\n * @path /shoppings/customers/deposits/charges/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function eraseById(\n  connection: IConnection,\n  props: eraseById.Props,\n): Promise<void> {\n  return !!connection.simulate\n    ? eraseById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...eraseById.METADATA,\n          path: eraseById.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace eraseById {\n  export type Props = {\n    /** Target deposit charge's {@link IShoppingDepositCharge.id } */\n    id: string;\n  };\n\n  export const METADATA = {\n    method: \"DELETE\",\n    path: \"/shoppings/customers/deposits/charges/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/shoppings/customers/deposits/charges/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): void =>\n    typia.random<void>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: eraseById.Props,\n  ): void => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: eraseById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/customers/deposits/index.ts": "export * as charges from \"./charges\";\nexport * as histories from \"./histories\";\n",
  "src/api/functional/shoppings/customers/deposits/charges/publish/able/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\n/**\n * Check publishable.\n *\n * Test whether the {@link IShoppingDepositCharge charge} is publishable or not.\n *\n * If the charge has not been {@link IShoppingDepositChargePublish published} and\n * not deleted yet, then it is possible to publish the charge\n *\n * @param props.chargeId Target charge's {@link IShoppingDepositCharge.id }\n * @path /shoppings/customers/deposits/charges/:chargeId/publish/able\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getByChargeid(\n  connection: IConnection,\n  props: getByChargeid.Props,\n): Promise<void> {\n  return !!connection.simulate\n    ? getByChargeid.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getByChargeid.METADATA,\n          path: getByChargeid.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace getByChargeid {\n  export type Props = {\n    /** Target charge's {@link IShoppingDepositCharge.id } */\n    chargeId: string & tags.Format<\"uuid\">;\n  };\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/shoppings/customers/deposits/charges/:chargeId/publish/able\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/shoppings/customers/deposits/charges/${encodeURIComponent(props.chargeId ?? \"null\")}/publish/able`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): void =>\n    typia.random<void>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: getByChargeid.Props,\n  ): void => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getByChargeid.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"chargeId\")(() => typia.assert(props.chargeId));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/customers/deposits/charges/publish/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingDepositChargePublish } from \"../../../../../../structures/IShoppingDepositChargePublish\";\nexport * as able from \"./able\";\n\n/**\n * Publish a charge.\n *\n * {@link IShoppingDepositChargePublish Publish} a\n * {@link IShoppingDepositCharge charge} that has been applied by the\n * {@link IShoppingCustomer} with payment information gotten from the payment\n * vendor system.\n *\n * Also, the payment time can be different with the publish time. For example,\n * if the payment method is manual bank account transfer, then the payment would\n * be delayed until the customer actually transfer the money. In that case,\n * {@link IShoppingDepositChargePublish.paid_at} would be `null` value, so that\n * you have to check it after calling this publish function.\n *\n * @param props.chargeId Target charge's {@link IShoppingDepositCharge.id }\n * @param props.body Creation info of the publish\n * @path /shoppings/customers/deposits/charges/:chargeId/publish\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function postByChargeid(\n  connection: IConnection,\n  props: postByChargeid.Props,\n): Promise<postByChargeid.Response> {\n  return !!connection.simulate\n    ? postByChargeid.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...postByChargeid.METADATA,\n          path: postByChargeid.path(props),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace postByChargeid {\n  export type Props = {\n    /** Target charge's {@link IShoppingDepositCharge.id } */\n    chargeId: string & tags.Format<\"uuid\">;\n\n    /** Creation info of the publish */\n    body: IShoppingDepositChargePublish.ICreate;\n  };\n  export type Body = IShoppingDepositChargePublish.ICreate;\n  export type Response = IShoppingDepositChargePublish;\n\n  export const METADATA = {\n    method: \"POST\",\n    path: \"/shoppings/customers/deposits/charges/:chargeId/publish\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Omit<Props, \"body\">) =>\n    `/shoppings/customers/deposits/charges/${encodeURIComponent(props.chargeId ?? \"null\")}/publish`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingDepositChargePublish =>\n    typia.random<IShoppingDepositChargePublish>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: postByChargeid.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: postByChargeid.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"chargeId\")(() => typia.assert(props.chargeId));\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/customers/deposits/histories/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingDepositHistory } from \"../../../../../structures/IShoppingDepositHistory\";\nimport { IPageIShoppingDepositHistory } from \"../../../../../structures/IPageIShoppingDepositHistory\";\nexport * as balance from \"./balance\";\n\n/**\n * List up every deposit histories.\n *\n * List up every {@link IShoppingDepositHistory deposit histories} of the\n * {@link IShoppingCustomer customer} with {@link IPage pagination}.\n *\n * If you want, you can limit the result by configuring\n * {@link IShoppingDepositHistory.IRequest.search search condition} in the\n * request body. Also, it is possible to customize sequence order of records by\n * configuring {@link IShoppingDepositHistory.IRequest.sort sort condition}.\n *\n * @param props.body Request info of pagination, searching and sorting\n * @path /shoppings/customers/deposits/histories\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patch(\n  connection: IConnection,\n  props: patch.Props,\n): Promise<patch.Response> {\n  return !!connection.simulate\n    ? patch.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patch.METADATA,\n          path: patch.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace patch {\n  export type Props = {\n    /** Request info of pagination, searching and sorting */\n    body: IShoppingDepositHistory.IRequest;\n  };\n  export type Body = IShoppingDepositHistory.IRequest;\n  export type Response = IPageIShoppingDepositHistory;\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/shoppings/customers/deposits/histories\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/shoppings/customers/deposits/histories\";\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IPageIShoppingDepositHistory =>\n    typia.random<IPageIShoppingDepositHistory>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: patch.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patch.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Get a deposit history info.\n *\n * Get a {@link IShoppingDepositHistory deposit history} information.\n *\n * @param props.id Describe description as much as possible with clear and\n *   concise words.\n * @path /shoppings/customers/deposits/histories/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getById(\n  connection: IConnection,\n  props: getById.Props,\n): Promise<getById.Response> {\n  return !!connection.simulate\n    ? getById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getById.METADATA,\n          path: getById.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace getById {\n  export type Props = {\n    /**\n     * Describe description as much as possible with clear and concise\n     * words.\n     */\n    id: string & tags.Format<\"uuid\">;\n  };\n  export type Response = IShoppingDepositHistory;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/shoppings/customers/deposits/histories/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/shoppings/customers/deposits/histories/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingDepositHistory => typia.random<IShoppingDepositHistory>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: getById.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/customers/deposits/histories/balance/index.ts": "import { IConnection } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia from \"typia\";\n\n/**\n * Get balance of the deposit.\n *\n * Get current balance of the deposit of the {@link IShoppingCustomer customer}.\n *\n * @path /shoppings/customers/deposits/histories/balance\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function get(connection: IConnection): Promise<void> {\n  return !!connection.simulate\n    ? get.simulate(connection)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...get.METADATA,\n          path: get.path(),\n          status: null,\n        },\n      );\n}\nexport namespace get {\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/shoppings/customers/deposits/histories/balance\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/shoppings/customers/deposits/histories/balance\";\n  export const random = (g?: Partial<typia.IRandomGenerator>): void =>\n    typia.random<void>(g);\n  export const simulate = (connection: IConnection): void => {\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/customers/mileages/histories/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingMileageHistory } from \"../../../../../structures/IShoppingMileageHistory\";\nimport { IPageIShoppingMileageHistory } from \"../../../../../structures/IPageIShoppingMileageHistory\";\nexport * as balance from \"./balance\";\n\n/**\n * List up every mileage histories.\n *\n * List up every {@link IShoppingMileageHistory mileage histories} of the\n * {@link IShoppingCustomer customer} with {@link IPage pagination}.\n *\n * If you want, you can limit the result by configuring\n * {@link IShoppingMileageHistory.IRequest.search search condition} in the\n * request body. Also, it is possible to customize sequence order of records by\n * configuring {@link IShoppingMileageHistory.IRequest.sort sort condition}.\n *\n * @param props.body Request info of pagination, searching and sorting\n * @path /shoppings/customers/mileages/histories\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patch(\n  connection: IConnection,\n  props: patch.Props,\n): Promise<patch.Response> {\n  return !!connection.simulate\n    ? patch.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patch.METADATA,\n          path: patch.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace patch {\n  export type Props = {\n    /** Request info of pagination, searching and sorting */\n    body: IShoppingMileageHistory.IRequest;\n  };\n  export type Body = IShoppingMileageHistory.IRequest;\n  export type Response = IPageIShoppingMileageHistory;\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/shoppings/customers/mileages/histories\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/shoppings/customers/mileages/histories\";\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IPageIShoppingMileageHistory =>\n    typia.random<IPageIShoppingMileageHistory>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: patch.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patch.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Get a mileage history info.\n *\n * Get a {@link IShoppingMileageHistory mileage history} information.\n *\n * @param props.id Target mileage history's {@link IShoppingMileageHistory.id }\n * @path /shoppings/customers/mileages/histories/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getById(\n  connection: IConnection,\n  props: getById.Props,\n): Promise<getById.Response> {\n  return !!connection.simulate\n    ? getById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getById.METADATA,\n          path: getById.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace getById {\n  export type Props = {\n    /** Target mileage history's {@link IShoppingMileageHistory.id } */\n    id: string & tags.Format<\"uuid\">;\n  };\n  export type Response = IShoppingMileageHistory;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/shoppings/customers/mileages/histories/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/shoppings/customers/mileages/histories/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingMileageHistory => typia.random<IShoppingMileageHistory>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: getById.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/customers/mileages/index.ts": "export * as histories from \"./histories\";\n",
  "src/api/functional/shoppings/customers/mileages/histories/balance/index.ts": "import { IConnection } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia from \"typia\";\n\n/**\n * Get balance of the mileage.\n *\n * Get current balance of the mileage of the {@link IShoppingCustomer customer}.\n *\n * @path /shoppings/customers/mileages/histories/balance\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function get(connection: IConnection): Promise<void> {\n  return !!connection.simulate\n    ? get.simulate(connection)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...get.METADATA,\n          path: get.path(),\n          status: null,\n        },\n      );\n}\nexport namespace get {\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/shoppings/customers/mileages/histories/balance\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/shoppings/customers/mileages/histories/balance\";\n  export const random = (g?: Partial<typia.IRandomGenerator>): void =>\n    typia.random<void>(g);\n  export const simulate = (connection: IConnection): void => {\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/customers/carts/commodities/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingCartCommodity } from \"../../../../../structures/IShoppingCartCommodity\";\nimport { IPageIShoppingCartCommodity } from \"../../../../../structures/IPageIShoppingCartCommodity\";\nexport * as replica from \"./replica\";\nexport * as discountable from \"./discountable\";\n\n/**\n * Create a new commodity.\n *\n * Create a new {@link IShoppingCartCommodity commodity} into a specific shopping\n * cart.\n *\n * If {@link IShoppingCartCommodity.ICreate.accumulate} has `true` value and\n * there's some same commodity that composed with same\n * {@link IShoppingSaleUnitStock.IInvert stocks and quantities}, then new\n * commodity would not be created but the volume would be accumulated.\n *\n * By the way, if the target {@link IShoppingSale sale} has been suspended or\n * {@link IShoppingSaleUnitStockInventory out of stock}, then 410 gone error\n * would be thrown. Therefore, it would better to check the target sale and\n * {@link IShoppingSaleUnitStock stock}'s status before.\n *\n * @param props.body Creation info of the commodity\n * @path /shoppings/customers/carts/commodities\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function post(\n  connection: IConnection,\n  props: post.Props,\n): Promise<post.Response> {\n  return !!connection.simulate\n    ? post.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...post.METADATA,\n          path: post.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace post {\n  export type Props = {\n    /** Creation info of the commodity */\n    body: IShoppingCartCommodity.ICreate;\n  };\n  export type Body = IShoppingCartCommodity.ICreate;\n  export type Response = IShoppingCartCommodity;\n\n  export const METADATA = {\n    method: \"POST\",\n    path: \"/shoppings/customers/carts/commodities\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/shoppings/customers/carts/commodities\";\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingCartCommodity => typia.random<IShoppingCartCommodity>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: post.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: post.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * List of every commodities.\n *\n * List up every {@link IShoppingCartCommodity commodities} in the shopping cart\n * with {@link IPage pagination}.\n *\n * You can limit the result by configuring\n * {@link IShoppingCartCommodity.IRequest.search search condition} in the request\n * body. Furthermore, it is possible to customize sequence order of records by\n * configuring {@link IShoppingCartCommodity.IRequest.sort}.\n *\n * For reference, when some commodity be {@link IShoppingOrder ordered} and\n * {@link IShoppingOrderPublish published}, then it would not be appread in the\n * shopping cart more. Otherwise, the order has not been published yet, it would\n * be appread in the shopping cart and still enable to create a new\n * {@link IShoppingOrder order application} with the same commodity.\n *\n * Of course, if the target {@link IShoppingSale sale} has been suspended, or\n * {@link IShoppingSaleUnitStockInventory out of stock}, then it would not be\n * appread in the shopping cart more, either.\n *\n * @param props.body Request info of pagination, searching and sorting\n * @path /shoppings/customers/carts/commodities\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patch(\n  connection: IConnection,\n  props: patch.Props,\n): Promise<patch.Response> {\n  return !!connection.simulate\n    ? patch.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patch.METADATA,\n          path: patch.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace patch {\n  export type Props = {\n    /** Request info of pagination, searching and sorting */\n    body: IShoppingCartCommodity.IRequest;\n  };\n  export type Body = IShoppingCartCommodity.IRequest;\n  export type Response = IPageIShoppingCartCommodity;\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/shoppings/customers/carts/commodities\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/shoppings/customers/carts/commodities\";\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IPageIShoppingCartCommodity =>\n    typia.random<IPageIShoppingCartCommodity>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: patch.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patch.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Get a commodity.\n *\n * Get a {@link IShoppingCartCommodity commodity} record of the shopping cart.\n *\n * If target {@link IShoppingSale sale} has been suspended or\n * {@link IShoppingSaleUnitStockInventory out of stock}, then 410 gone error\n * would be thrown. Therefore, even if you've created a commodity successfully\n * with the {@link create} method, it still can be failed when you access the\n * commodity with this {@link at} method.\n *\n * @param props.id Target commodity's {@link IShoppingCartCommodity.id }\n * @path /shoppings/customers/carts/commodities/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getById(\n  connection: IConnection,\n  props: getById.Props,\n): Promise<getById.Response> {\n  return !!connection.simulate\n    ? getById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getById.METADATA,\n          path: getById.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace getById {\n  export type Props = {\n    /** Target commodity's {@link IShoppingCartCommodity.id } */\n    id: string & tags.Format<\"uuid\">;\n  };\n  export type Response = IShoppingCartCommodity;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/shoppings/customers/carts/commodities/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/shoppings/customers/carts/commodities/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingCartCommodity => typia.random<IShoppingCartCommodity>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: getById.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Update a commodity (volume).\n *\n * Update a {@link IShoppingCartCommodity commodity}'s volume in the shopping\n * cart.\n *\n * If target {@link IShoppingSale sale} has been suspended or\n * {@link IShoppingSaleUnitStockInventory out of stock} suddenly, then 410 gone\n * error would be thrown, either.\n *\n * @param props.id Target commodity's {@link IShoppingCartCommodity.id }\n * @param props.body Update info of the commodity (volume)\n * @path /shoppings/customers/carts/commodities/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function putById(\n  connection: IConnection,\n  props: putById.Props,\n): Promise<void> {\n  return !!connection.simulate\n    ? putById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...putById.METADATA,\n          path: putById.path(props),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace putById {\n  export type Props = {\n    /** Target commodity's {@link IShoppingCartCommodity.id } */\n    id: string & tags.Format<\"uuid\">;\n\n    /** Update info of the commodity (volume) */\n    body: IShoppingCartCommodity.IUpdate;\n  };\n  export type Body = IShoppingCartCommodity.IUpdate;\n\n  export const METADATA = {\n    method: \"PUT\",\n    path: \"/shoppings/customers/carts/commodities/:id\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Omit<Props, \"body\">) =>\n    `/shoppings/customers/carts/commodities/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): void =>\n    typia.random<void>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: putById.Props,\n  ): void => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: putById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Erase a commodity.\n *\n * Erase a {@link IShoppingCartCommodity commodity} from the shopping cart.\n *\n * If the commodity is on an {@link IShoppingOrder order} process, it is not\n * possible to erase it. Instead, if the order has been\n * {@link IShoppingOrderPublish published}, then it would not be appread in the\n * shopping cart more. If the order be erased, then you also can continue\n * erasinng the commodity, neither.\n *\n * @param props.id Target commodity's {@link IShoppingCartCommodity.id }\n * @path /shoppings/customers/carts/commodities/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function eraseById(\n  connection: IConnection,\n  props: eraseById.Props,\n): Promise<void> {\n  return !!connection.simulate\n    ? eraseById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...eraseById.METADATA,\n          path: eraseById.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace eraseById {\n  export type Props = {\n    /** Target commodity's {@link IShoppingCartCommodity.id } */\n    id: string & tags.Format<\"uuid\">;\n  };\n\n  export const METADATA = {\n    method: \"DELETE\",\n    path: \"/shoppings/customers/carts/commodities/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/shoppings/customers/carts/commodities/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): void =>\n    typia.random<void>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: eraseById.Props,\n  ): void => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: eraseById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/customers/carts/index.ts": "export * as commodities from \"./commodities\";\n",
  "src/api/functional/shoppings/customers/carts/commodities/replica/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingCartCommodity } from \"../../../../../../structures/IShoppingCartCommodity\";\n\n/**\n * Get replica of a commodity.\n *\n * Get a {@link IShoppingCartCommodity.ICreate} typed info of the target\n * commodity for replication.\n *\n * If target {@link IShoppingSale sale} has been suspended or\n * {@link IShoppingSaleUnitStockInventory out of stock} suddenly, then 410 gone\n * error would be thrown, either.\n *\n * @param props.id Target commodity's {@link IShoppingCartCommodity.id }\n * @path /shoppings/customers/carts/commodities/:id/replica\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getById(\n  connection: IConnection,\n  props: getById.Props,\n): Promise<getById.Response> {\n  return !!connection.simulate\n    ? getById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getById.METADATA,\n          path: getById.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace getById {\n  export type Props = {\n    /** Target commodity's {@link IShoppingCartCommodity.id } */\n    id: string & tags.Format<\"uuid\">;\n  };\n  export type Response = IShoppingCartCommodity.ICreate;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/shoppings/customers/carts/commodities/:id/replica\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/shoppings/customers/carts/commodities/${encodeURIComponent(props.id ?? \"null\")}/replica`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingCartCommodity.ICreate =>\n    typia.random<IShoppingCartCommodity.ICreate>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: getById.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/customers/carts/commodities/discountable/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingCartDiscountable } from \"../../../../../../structures/IShoppingCartDiscountable\";\n\n/**\n * Get discountable info.\n *\n * Compute discountable features about the\n * {@link IShoppingCartCommodity shopping cart} even including non-carted\n * {@link IShoppingSale sales}.\n *\n * Returned {@link IShoppingCartDiscountable} contains including combinations of\n * adjustable {@link IShoppingCoupon coupons}, withdrawable\n * {@link IShoppingDepositHistory deposits} and\n * {@link IShoppingMileageHistory mileages}.\n *\n * If you want to know the discountable info about some specific sales that have\n * not been carted yet, specify the sales to the\n * {@link IShoppingCartDiscountable.pseudos} property with composing\n * {@link IShoppingCartCommodity.ICreate creation info of the commodities}. Then,\n * they would be included in the discountable info.\n *\n * @param props.body Request info for discountable\n * @path /shoppings/customers/carts/commodities/discountable\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patch(\n  connection: IConnection,\n  props: patch.Props,\n): Promise<patch.Response> {\n  return !!connection.simulate\n    ? patch.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patch.METADATA,\n          path: patch.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace patch {\n  export type Props = {\n    /** Request info for discountable */\n    body: IShoppingCartDiscountable.IRequest;\n  };\n  export type Body = IShoppingCartDiscountable.IRequest;\n  export type Response = IShoppingCartDiscountable;\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/shoppings/customers/carts/commodities/discountable\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () =>\n    \"/shoppings/customers/carts/commodities/discountable\";\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingCartDiscountable => typia.random<IShoppingCartDiscountable>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: patch.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patch.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/customers/orders/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingOrder } from \"../../../../structures/IShoppingOrder\";\nimport { IPageIShoppingOrder } from \"../../../../structures/IPageIShoppingOrder\";\nexport * as direct from \"./direct\";\nexport * as price from \"./price\";\nexport * as discountable from \"./discountable\";\nexport * as discount from \"./discount\";\nexport * as goods from \"./goods\";\nexport * as publish from \"./publish\";\n\n/**\n * Create a new order application.\n *\n * Create a new {@link IShoppingOrder order application} from a\n * {@link IShoppingCartCommodity shopping cart} that has been composed by the\n * {@link IShoppingCustomer}. Of course, do not need to put every commodities to\n * the order, but possible to select some of them by the customer.\n *\n * By the way, this function does not mean completion the order, but means just\n * customer is applying the order. The order be completed only when customer\n * {@link IShoppingOrderPublish.paid_at pays} the order.\n *\n * > If you are an A.I. chatbot, don't take a mistake that writing the\n * > `commodity_id` with the user selected stock ID. The `commodity_id` is the ID\n * > of the shopping cart commodity, not the stock ID. The stock ID is already\n * > included in the shopping cart commodity.\n *\n * @param props.body Creation info of the order\n * @path /shoppings/customers/orders\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function post(\n  connection: IConnection,\n  props: post.Props,\n): Promise<post.Response> {\n  return !!connection.simulate\n    ? post.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...post.METADATA,\n          path: post.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace post {\n  export type Props = {\n    /** Creation info of the order */\n    body: IShoppingOrder.ICreate;\n  };\n  export type Body = IShoppingOrder.ICreate;\n  export type Response = IShoppingOrder;\n\n  export const METADATA = {\n    method: \"POST\",\n    path: \"/shoppings/customers/orders\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/shoppings/customers/orders\";\n  export const random = (g?: Partial<typia.IRandomGenerator>): IShoppingOrder =>\n    typia.random<IShoppingOrder>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: post.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: post.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * List up every orders.\n *\n * List up every {@link IShoppingOrder orders} with pagination.\n *\n * If you want, you can limit the result by configuring\n * {@link IShoppingOrder.IRequest.search search condition} in the request body.\n * Also, it is possible to customize sequence order of records by configuring\n * {@link IShoppingOrder.IRequest.sort sort condition}.\n *\n * For reference, if you are a {@link IShoppingCustomer customer}, then you can\n * list up your own orders, and it is not a matter whether the order has been\n * {@link IShoppingOrderPublish.paid_at paid} or not.\n *\n * Otherwise you are a {@link IShoppingSeller seller} or\n * {@link IShoppingAdministrator administrator}, then you can list up only paid\n * orders. Also, in the seller case, only related\n * {@link IShoppingOrder.goods goods} would be listed up in the order.\n *\n * @param props.body Request info of pagination, searching and sorting\n * @path /shoppings/customers/orders\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patch(\n  connection: IConnection,\n  props: patch.Props,\n): Promise<patch.Response> {\n  return !!connection.simulate\n    ? patch.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patch.METADATA,\n          path: patch.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace patch {\n  export type Props = {\n    /** Request info of pagination, searching and sorting */\n    body: IShoppingOrder.IRequest;\n  };\n  export type Body = IShoppingOrder.IRequest;\n  export type Response = IPageIShoppingOrder;\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/shoppings/customers/orders\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/shoppings/customers/orders\";\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IPageIShoppingOrder => typia.random<IPageIShoppingOrder>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: patch.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patch.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Get an order info.\n *\n * Get a detailed {@link IShoppingOrder order} information.\n *\n * If you are not a {@link IShoppingCustomer customer}, then you can't access to\n * the order which has not been {@link IShoppingOrderPublish.paid_at paid} yet.\n * In that case, 404 not found error would be thrown.\n *\n * @param props.id Target order's {@link IShoppingOrder.id }\n * @path /shoppings/customers/orders/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getById(\n  connection: IConnection,\n  props: getById.Props,\n): Promise<getById.Response> {\n  return !!connection.simulate\n    ? getById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getById.METADATA,\n          path: getById.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace getById {\n  export type Props = {\n    /** Target order's {@link IShoppingOrder.id } */\n    id: string & tags.Format<\"uuid\">;\n  };\n  export type Response = IShoppingOrder;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/shoppings/customers/orders/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/shoppings/customers/orders/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): IShoppingOrder =>\n    typia.random<IShoppingOrder>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: getById.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Erase an order application.\n *\n * Erase an order application that has been applied by the\n * {@link IShoppingCustomer}.\n *\n * If the order has been {@link IShoppingOrderPublish published}, then it is not\n * possible to erase the order. In that case, you've to cancel the payment by\n * calling the {@link publish.cancel} function.\n *\n * @param props.id Target order's {@link IShoppingOrder.id }\n * @path /shoppings/customers/orders/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function eraseById(\n  connection: IConnection,\n  props: eraseById.Props,\n): Promise<void> {\n  return !!connection.simulate\n    ? eraseById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...eraseById.METADATA,\n          path: eraseById.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace eraseById {\n  export type Props = {\n    /** Target order's {@link IShoppingOrder.id } */\n    id: string & tags.Format<\"uuid\">;\n  };\n\n  export const METADATA = {\n    method: \"DELETE\",\n    path: \"/shoppings/customers/orders/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/shoppings/customers/orders/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): void =>\n    typia.random<void>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: eraseById.Props,\n  ): void => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: eraseById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/customers/orders/direct/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingCartCommodity } from \"../../../../../structures/IShoppingCartCommodity\";\nimport { IShoppingOrder } from \"../../../../../structures/IShoppingOrder\";\n\n/**\n * Create a new order application without a shopping cart.\n *\n * Carete a new {@link IShoppingOrder order application} without a\n * {@link IShoppingCartCommodity shopping cart commodity} composition. If you're\n * an A.I. chatbot and user wants to directly purchase a product, then select\n * and call this function.\n *\n * By the way, this function does not mean completion the order, but means just\n * customer is applying the order. The order be completed only when customer\n * {@link IShoppingOrderPublish.paid_at pays} the order.\n *\n * @param props.body Creation info of the order without a shopping cart\n *   composition\n * @path /shoppings/customers/orders/direct\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function post(\n  connection: IConnection,\n  props: post.Props,\n): Promise<post.Response> {\n  return !!connection.simulate\n    ? post.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...post.METADATA,\n          path: post.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace post {\n  export type Props = {\n    /** Creation info of the order without a shopping cart composition */\n    body: IShoppingCartCommodity.ICreate;\n  };\n  export type Body = IShoppingCartCommodity.ICreate;\n  export type Response = IShoppingOrder;\n\n  export const METADATA = {\n    method: \"POST\",\n    path: \"/shoppings/customers/orders/direct\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/shoppings/customers/orders/direct\";\n  export const random = (g?: Partial<typia.IRandomGenerator>): IShoppingOrder =>\n    typia.random<IShoppingOrder>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: post.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: post.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/customers/orders/price/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingOrderPrice } from \"../../../../../structures/IShoppingOrderPrice\";\n\n/**\n * Get price of the order.\n *\n * Get detailed price information of the {@link IShoppingOrder order}.\n *\n * Returned price info contains not only the amount of the order, but also\n * contains the discount amount by {@link IShoppingCoupono coupons},\n * {@link IShoppingDepositHistory deposits} and\n * {@link IShoppingMileageHistory mileages}.\n *\n * @param props.id Target order's {@link IShoppingOrder.id }\n * @path /shoppings/customers/orders/:id/price\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getById(\n  connection: IConnection,\n  props: getById.Props,\n): Promise<getById.Response> {\n  return !!connection.simulate\n    ? getById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getById.METADATA,\n          path: getById.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace getById {\n  export type Props = {\n    /** Target order's {@link IShoppingOrder.id } */\n    id: string & tags.Format<\"uuid\">;\n  };\n  export type Response = IShoppingOrderPrice;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/shoppings/customers/orders/:id/price\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/shoppings/customers/orders/${encodeURIComponent(props.id ?? \"null\")}/price`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingOrderPrice => typia.random<IShoppingOrderPrice>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: getById.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/customers/orders/discountable/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingOrderDiscountable } from \"../../../../../structures/IShoppingOrderDiscountable\";\n\n/**\n * Get discountable info.\n *\n * Compute discountable features about the {@link IShoppingOrder}.\n *\n * Returned {@link IShoppingOrderDiscountable} contains including combinations of\n * adjustable {@link IShoppingCoupon coupons}, withdrawable\n * {@link IShoppingDepositHistory deposits} and\n * {@link IShoppingMileageHistory mileages}.\n *\n * Of course, returned features are valid only when the order has not been\n * {@link IShoppingOrderPublish published} yet. If the order has already been\n * published, then no way to discount the price more.\n *\n * @param props.id Target order's {@link IShoppingOrder.id }\n * @param props.body Request info for discountable\n * @path /shoppings/customers/orders/:id/discountable\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patchById(\n  connection: IConnection,\n  props: patchById.Props,\n): Promise<patchById.Response> {\n  return !!connection.simulate\n    ? patchById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patchById.METADATA,\n          path: patchById.path(props),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace patchById {\n  export type Props = {\n    /** Target order's {@link IShoppingOrder.id } */\n    id: string & tags.Format<\"uuid\">;\n\n    /** Request info for discountable */\n    body: IShoppingOrderDiscountable.IRequest;\n  };\n  export type Body = IShoppingOrderDiscountable.IRequest;\n  export type Response = IShoppingOrderDiscountable;\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/shoppings/customers/orders/:id/discountable\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Omit<Props, \"body\">) =>\n    `/shoppings/customers/orders/${encodeURIComponent(props.id ?? \"null\")}/discountable`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingOrderDiscountable => typia.random<IShoppingOrderDiscountable>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: patchById.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patchById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/customers/orders/discount/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingOrderPrice } from \"../../../../../structures/IShoppingOrderPrice\";\n\n/**\n * Discount the order.\n *\n * Discount total price of the {@link IShoppingOrder} by adjusting\n * {@link IShoppingCoupon coupons}, {@link IShoppingDepositHistory deposits} and\n * {@link IShoppingMileageHistory mileages}. If amount of discount features are\n * equal to the total price of the order, it is possible to\n * {@link IShoppingOrderPublish publish} it without any cash.\n *\n * By the way, the discounting features must be valid. If not, 428 unprocessable\n * entity error would be thrown. To know which features are adjustable or\n * withdrawable, call the {@link discountable} function before.\n *\n * @param props.id Target order's {@link IShoppingOrder.id }\n * @param props.body Discount info\n * @path /shoppings/customers/orders/:id/discount\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function putById(\n  connection: IConnection,\n  props: putById.Props,\n): Promise<putById.Response> {\n  return !!connection.simulate\n    ? putById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...putById.METADATA,\n          path: putById.path(props),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace putById {\n  export type Props = {\n    /** Target order's {@link IShoppingOrder.id } */\n    id: string & tags.Format<\"uuid\">;\n\n    /** Discount info */\n    body: IShoppingOrderPrice.ICreate;\n  };\n  export type Body = IShoppingOrderPrice.ICreate;\n  export type Response = IShoppingOrderPrice;\n\n  export const METADATA = {\n    method: \"PUT\",\n    path: \"/shoppings/customers/orders/:id/discount\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Omit<Props, \"body\">) =>\n    `/shoppings/customers/orders/${encodeURIComponent(props.id ?? \"null\")}/discount`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingOrderPrice => typia.random<IShoppingOrderPrice>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: putById.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: putById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/customers/orders/goods/confirm/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\n/**\n * Confirm an order good.\n *\n * Confirm an {@link IShoppingOrderGood order good} that has been completed\n * {@link IShoppingDelivery delivering} to the\n * {@link IShoppingCustomer customer}.\n *\n * In other words, belonged {@link IShoppingOrder order} must be\n * {@link IShoppingPublish.paid_at published, paid} and delivery of the good must\n * be {@link IShoppingDeliveryJourney arrived} to the customer. If not, 428\n * unprocessable entity error would be thrown.\n *\n * @param props.orderId Belonged order's {@link IShoppingOrder.id }\n * @param props.id Target good's {@link IShoppingOrderGood.id }\n * @path /shoppings/customers/orders/:orderId/goods/:id/confirm\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function putByOrderidAndId(\n  connection: IConnection,\n  props: putByOrderidAndId.Props,\n): Promise<void> {\n  return !!connection.simulate\n    ? putByOrderidAndId.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...putByOrderidAndId.METADATA,\n          path: putByOrderidAndId.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace putByOrderidAndId {\n  export type Props = {\n    /** Belonged order's {@link IShoppingOrder.id } */\n    orderId: string & tags.Format<\"uuid\">;\n\n    /** Target good's {@link IShoppingOrderGood.id } */\n    id: string & tags.Format<\"uuid\">;\n  };\n\n  export const METADATA = {\n    method: \"PUT\",\n    path: \"/shoppings/customers/orders/:orderId/goods/:id/confirm\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/shoppings/customers/orders/${encodeURIComponent(props.orderId ?? \"null\")}/goods/${encodeURIComponent(props.id ?? \"null\")}/confirm`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): void =>\n    typia.random<void>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: putByOrderidAndId.Props,\n  ): void => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: putByOrderidAndId.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"orderId\")(() => typia.assert(props.orderId));\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/customers/orders/goods/index.ts": "export * as confirm from \"./confirm\";\n",
  "src/api/functional/shoppings/customers/orders/publish/able/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\n/**\n * Check publishable.\n *\n * Test whether the {@link IShoppingOrder order} is publishable or not.\n *\n * If the order has not been {@link IShoppingOrderPublish published} and not\n * deleted yet, then it is possible to publish the order. Even thouogh target\n * {@link IShoppingSale sale} is suspended or\n * {@link IShoppingSaleUnitStockInventory out of stock}, it is still possible to\n * publish because the order already has been applied.\n *\n * @param props.orderId Target order's {@link IShoppingOrder.id }\n * @path /shoppings/customers/orders/:orderId/publish/able\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getByOrderid(\n  connection: IConnection,\n  props: getByOrderid.Props,\n): Promise<void> {\n  return !!connection.simulate\n    ? getByOrderid.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getByOrderid.METADATA,\n          path: getByOrderid.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace getByOrderid {\n  export type Props = {\n    /** Target order's {@link IShoppingOrder.id } */\n    orderId: string & tags.Format<\"uuid\">;\n  };\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/shoppings/customers/orders/:orderId/publish/able\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/shoppings/customers/orders/${encodeURIComponent(props.orderId ?? \"null\")}/publish/able`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): void =>\n    typia.random<void>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: getByOrderid.Props,\n  ): void => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getByOrderid.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"orderId\")(() => typia.assert(props.orderId));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/customers/orders/publish/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingOrderPublish } from \"../../../../../structures/IShoppingOrderPublish\";\nexport * as able from \"./able\";\n\n/**\n * Publish an order.\n *\n * {@link IShoppingOrderPublish Publish} an {@link IShoppingOrder order} that has\n * been applied by the {@link IShoppingCustomer} with\n * {@link IShoppingAddress address} to delivery and payment information gotten\n * from the payment vendor system.\n *\n * If the order has been discounted for entire order price, then no need to send\n * payment vendor info. Instead, only address info is required.\n *\n * Also, the payment time can be different with the publish time. For example,\n * if the payment method is manual bank account transfer, then the payment would\n * be delayed until the customer actually transfer the money. In that case,\n * {@link IShoppingOrderPublish.paid_at} would be `null` value, so that you have\n * to check it after calling this publish function.\n *\n * @param props.orderId Target order's {@link IShoppingOrder.id }\n * @param props.body Creation info of the publish\n * @path /shoppings/customers/orders/:orderId/publish\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function postByOrderid(\n  connection: IConnection,\n  props: postByOrderid.Props,\n): Promise<postByOrderid.Response> {\n  return !!connection.simulate\n    ? postByOrderid.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...postByOrderid.METADATA,\n          path: postByOrderid.path(props),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace postByOrderid {\n  export type Props = {\n    /** Target order's {@link IShoppingOrder.id } */\n    orderId: string & tags.Format<\"uuid\">;\n\n    /** Creation info of the publish */\n    body: IShoppingOrderPublish.ICreate;\n  };\n  export type Body = IShoppingOrderPublish.ICreate;\n  export type Response = IShoppingOrderPublish;\n\n  export const METADATA = {\n    method: \"POST\",\n    path: \"/shoppings/customers/orders/:orderId/publish\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Omit<Props, \"body\">) =>\n    `/shoppings/customers/orders/${encodeURIComponent(props.orderId ?? \"null\")}/publish`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingOrderPublish => typia.random<IShoppingOrderPublish>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: postByOrderid.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: postByOrderid.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"orderId\")(() => typia.assert(props.orderId));\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Cancel the publish (payment).\n *\n * Cancel payment of an {@link IShoppingOrder order} that has been\n * {@link IShoppingOrderPublish published}.\n *\n * If target publish's payment method is manual bank account transfer, then it\n * would be cancelled directly. If not, then payment cancel request would be\n * sent to the payment vendor system.\n *\n * @param props.orderId Target order's {@link IShoppingOrder.id }\n * @path /shoppings/customers/orders/:orderId/publish\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function eraseByOrderid(\n  connection: IConnection,\n  props: eraseByOrderid.Props,\n): Promise<void> {\n  return !!connection.simulate\n    ? eraseByOrderid.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...eraseByOrderid.METADATA,\n          path: eraseByOrderid.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace eraseByOrderid {\n  export type Props = {\n    /** Target order's {@link IShoppingOrder.id } */\n    orderId: string & tags.Format<\"uuid\">;\n  };\n\n  export const METADATA = {\n    method: \"DELETE\",\n    path: \"/shoppings/customers/orders/:orderId/publish\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/shoppings/customers/orders/${encodeURIComponent(props.orderId ?? \"null\")}/publish`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): void =>\n    typia.random<void>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: eraseByOrderid.Props,\n  ): void => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: eraseByOrderid.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"orderId\")(() => typia.assert(props.orderId));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/customers/sales/details/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingSale } from \"../../../../../structures/IShoppingSale\";\nimport { IPageIShoppingSale } from \"../../../../../structures/IPageIShoppingSale\";\n\n/**\n * List up every sales.\n *\n * List up every {@link IShoppingSale sales} with detailed information.\n *\n * As you can see, returned sales are detailed, not summarized. If you want to\n * get the summarized information of sale for a brief, use {@link index} function\n * instead.\n *\n * For reference, if you're a {@link IShoppingSeller seller}, you can only access\n * to the your own {@link IShoppingSale sale}s. Otherwise you're a\n * {@link IShoppingCustomer customer}, you can see only the operating sales in\n * the market. Instead, you can't see the unopened, closed, or suspended sales.\n *\n * > If you're an A.I. chatbot, please don't summarize the\n * > {@link IShoppingSaleUnitStock stock information}. Just list up the every\n * > stocks in the sale with detailed information.\n *\n * @param props.body Request info of pagination, searching and sorting\n * @path /shoppings/customers/sales/details\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patch(\n  connection: IConnection,\n  props: patch.Props,\n): Promise<patch.Response> {\n  return !!connection.simulate\n    ? patch.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patch.METADATA,\n          path: patch.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace patch {\n  export type Props = {\n    /** Request info of pagination, searching and sorting */\n    body: IShoppingSale.IRequest;\n  };\n  export type Body = IShoppingSale.IRequest;\n  export type Response = IPageIShoppingSale;\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/shoppings/customers/sales/details\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/shoppings/customers/sales/details\";\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IPageIShoppingSale => typia.random<IPageIShoppingSale>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: patch.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patch.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/customers/sales/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingSale } from \"../../../../structures/IShoppingSale\";\nimport { IPageIShoppingSale } from \"../../../../structures/IPageIShoppingSale\";\nexport * as details from \"./details\";\nexport * as questions from \"./questions\";\nexport * as reviews from \"./reviews\";\nexport * as snapshots from \"./snapshots\";\n\n/**\n * List up every summarized sales.\n *\n * List up every {@link IShoppingSale.ISummary summarized sales}.\n *\n * As you can see, returned sales are summarized, not detailed. It does not\n * contain the SKU (Stock Keeping Unit) information represented by the\n * {@link IShoppingSaleUnitOption} and {@link IShoppingSaleUnitStock} types. If\n * you want to get such detailed information of a sale, use `GET\n * /shoppings/customers/sales/{id}` operation for each sale.\n *\n * > If you're an A.I. chatbot, and the user wants to buy or compose\n * > {@link IShoppingCartCommodity shopping cart} from a sale, please call the `GET\n * > /shoppings/customers/sales/{id}` operation at least once to the target sale\n * > to get detailed SKU information about the sale. It needs to be run at least\n * > once for the next steps.\n *\n * @param props.body Request info of pagination, searching and sorting\n * @path /shoppings/customers/sales\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patch(\n  connection: IConnection,\n  props: patch.Props,\n): Promise<patch.Response> {\n  return !!connection.simulate\n    ? patch.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patch.METADATA,\n          path: patch.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace patch {\n  export type Props = {\n    /** Request info of pagination, searching and sorting */\n    body: IShoppingSale.IRequest;\n  };\n  export type Body = IShoppingSale.IRequest;\n  export type Response = IPageIShoppingSale.ISummary;\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/shoppings/customers/sales\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/shoppings/customers/sales\";\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IPageIShoppingSale.ISummary =>\n    typia.random<IPageIShoppingSale.ISummary>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: patch.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patch.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Get a sale with detailed information.\n *\n * Get a {@link IShoppingSale sale} with detailed information including the SKU\n * (Stock Keeping Unit) information represented by the\n * {@link IShoppingSaleUnitOption} and {@link IShoppingSaleUnitStock} types.\n *\n * > If you're an A.I. chatbot, and the user wants to buy or compose a\n * > {@link IShoppingCartCommodity shopping cart} from a sale, please call this\n * > operation at least once to the target sale to get detailed SKU information\n * > about the sale.\n *\n * > It needs to be run at least once for the next steps. In other words, if you\n * > A.I. agent has called this operation to a specific sale, you don't need to\n * > call this operation again for the same sale.\n *\n * > Additionally, please do not summarize the SKU information. Just show the\n * > every options and stocks in the sale with detailed information.\n *\n * @param props.id Target sale's {@link IShoppingSale.id }\n * @path /shoppings/customers/sales/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getById(\n  connection: IConnection,\n  props: getById.Props,\n): Promise<getById.Response> {\n  return !!connection.simulate\n    ? getById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getById.METADATA,\n          path: getById.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace getById {\n  export type Props = {\n    /** Target sale's {@link IShoppingSale.id } */\n    id: string & tags.Format<\"uuid\">;\n  };\n  export type Response = IShoppingSale;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/shoppings/customers/sales/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/shoppings/customers/sales/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): IShoppingSale =>\n    typia.random<IShoppingSale>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: getById.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/customers/sales/questions/comments/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingSaleInquiryComment } from \"../../../../../../structures/IShoppingSaleInquiryComment\";\nimport { IPageIShoppingSaleInquiryComment } from \"../../../../../../structures/IPageIShoppingSaleInquiryComment\";\n\n/**\n * Create an inquiry comment.\n *\n * Create an {@link IShoppingSaleInquiryComment inquiry comment} of a\n * {@link IShoppingSaleQuestion question} or {@link IShoppingSaleReview review}.\n *\n * For reference, if you're a {@link IShoppingSeller seller}, you can only create\n * an inquiry comment to your own {@link IShoppingSale sale}'s inquiry.\n * Otherwise, you can create an inquiry comment to every inquiries of the\n * sales.\n *\n * @param props.saleId Belonged sale's {@link IShoppingSale.id }\n * @param props.inquiryId Target inquiry's {@link IShoppingSaleInquiry.id }\n * @param props.body Creation info of the inquiry comment\n * @path /shoppings/customers/sales/:saleId/questions/:inquiryId/comments\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function postBySaleidAndInquiryid(\n  connection: IConnection,\n  props: postBySaleidAndInquiryid.Props,\n): Promise<postBySaleidAndInquiryid.Response> {\n  return !!connection.simulate\n    ? postBySaleidAndInquiryid.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...postBySaleidAndInquiryid.METADATA,\n          path: postBySaleidAndInquiryid.path(props),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace postBySaleidAndInquiryid {\n  export type Props = {\n    /** Belonged sale's {@link IShoppingSale.id } */\n    saleId: string & tags.Format<\"uuid\">;\n\n    /** Target inquiry's {@link IShoppingSaleInquiry.id } */\n    inquiryId: string & tags.Format<\"uuid\">;\n\n    /** Creation info of the inquiry comment */\n    body: IShoppingSaleInquiryComment.ICreate;\n  };\n  export type Body = IShoppingSaleInquiryComment.ICreate;\n  export type Response = IShoppingSaleInquiryComment;\n\n  export const METADATA = {\n    method: \"POST\",\n    path: \"/shoppings/customers/sales/:saleId/questions/:inquiryId/comments\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Omit<Props, \"body\">) =>\n    `/shoppings/customers/sales/${encodeURIComponent(props.saleId ?? \"null\")}/questions/${encodeURIComponent(props.inquiryId ?? \"null\")}/comments`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingSaleInquiryComment =>\n    typia.random<IShoppingSaleInquiryComment>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: postBySaleidAndInquiryid.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: postBySaleidAndInquiryid.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"saleId\")(() => typia.assert(props.saleId));\n      assert.param(\"inquiryId\")(() => typia.assert(props.inquiryId));\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * List up every inquiry comments.\n *\n * List up every {@link IShoppingSaleInquiryComment inquiry comments} of a\n * {@link IShoppingSaleQuestion question} or {@link IShoppingSaleReview review}\n * with {@link IPage pagination}.\n *\n * If you want, you can limit the result by configuring\n * {@link IShoppingSaleInquiryComment.IRequest.search search condition} in the\n * request body. Also, it is possible to customize sequence order of records by\n * configuring {@link IShoppingSaleInquiryComment.IRequest.sort sort condition}.\n *\n * By the way, if you're a {@link IShoppingSeller seller}, you can only access to\n * the your own {@link IShoppingSale sale}'s inquiries. Otherwise, you can access\n * to every inquiries of the sales.\n *\n * @param props.saleId Belonged sale's {@link IShoppingSale.id }\n * @param props.inquiryId Belonged inquiry's {@link IShoppingSaleInquiry.id }\n * @param props.body Request info of pagination, searching and sorting\n * @path /shoppings/customers/sales/:saleId/questions/:inquiryId/comments\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patchBySaleidAndInquiryid(\n  connection: IConnection,\n  props: patchBySaleidAndInquiryid.Props,\n): Promise<patchBySaleidAndInquiryid.Response> {\n  return !!connection.simulate\n    ? patchBySaleidAndInquiryid.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patchBySaleidAndInquiryid.METADATA,\n          path: patchBySaleidAndInquiryid.path(props),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace patchBySaleidAndInquiryid {\n  export type Props = {\n    /** Belonged sale's {@link IShoppingSale.id } */\n    saleId: string & tags.Format<\"uuid\">;\n\n    /** Belonged inquiry's {@link IShoppingSaleInquiry.id } */\n    inquiryId: string & tags.Format<\"uuid\">;\n\n    /** Request info of pagination, searching and sorting */\n    body: IShoppingSaleInquiryComment.IRequest;\n  };\n  export type Body = IShoppingSaleInquiryComment.IRequest;\n  export type Response = IPageIShoppingSaleInquiryComment;\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/shoppings/customers/sales/:saleId/questions/:inquiryId/comments\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Omit<Props, \"body\">) =>\n    `/shoppings/customers/sales/${encodeURIComponent(props.saleId ?? \"null\")}/questions/${encodeURIComponent(props.inquiryId ?? \"null\")}/comments`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IPageIShoppingSaleInquiryComment =>\n    typia.random<IPageIShoppingSaleInquiryComment>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: patchBySaleidAndInquiryid.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patchBySaleidAndInquiryid.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"saleId\")(() => typia.assert(props.saleId));\n      assert.param(\"inquiryId\")(() => typia.assert(props.inquiryId));\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Get an inquiry comment info.\n *\n * Get a detailed {@link IShoppingSaleInquiryComment inquiry comment} information\n * of a {@link IShoppingSaleQuestion question} or\n * {@link IShoppingSaleReview review}.\n *\n * For reference, if you're a {@link IShoppingSeller seller}, you can only access\n * to the your own {@link IShoppingSale sale}'s inquiry comment. Otherwise, you\n * can access to every inquiry comments of the sales.\n *\n * @param props.saleId Belonged sale's {@link IShoppingSale.id }\n * @param props.inquiryId Belonged inquiry's {@link IShoppingSaleInquiry.id }\n * @param props.id Target inquiry comment's\n *   {@link IShoppingSaleInquiryComment.id }\n * @path /shoppings/customers/sales/:saleId/questions/:inquiryId/comments/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getBySaleidAndInquiryidAndId(\n  connection: IConnection,\n  props: getBySaleidAndInquiryidAndId.Props,\n): Promise<getBySaleidAndInquiryidAndId.Response> {\n  return !!connection.simulate\n    ? getBySaleidAndInquiryidAndId.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getBySaleidAndInquiryidAndId.METADATA,\n          path: getBySaleidAndInquiryidAndId.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace getBySaleidAndInquiryidAndId {\n  export type Props = {\n    /** Belonged sale's {@link IShoppingSale.id } */\n    saleId: string & tags.Format<\"uuid\">;\n\n    /** Belonged inquiry's {@link IShoppingSaleInquiry.id } */\n    inquiryId: string & tags.Format<\"uuid\">;\n\n    /** Target inquiry comment's {@link IShoppingSaleInquiryComment.id } */\n    id: string & tags.Format<\"uuid\">;\n  };\n  export type Response = IShoppingSaleInquiryComment;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/shoppings/customers/sales/:saleId/questions/:inquiryId/comments/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/shoppings/customers/sales/${encodeURIComponent(props.saleId ?? \"null\")}/questions/${encodeURIComponent(props.inquiryId ?? \"null\")}/comments/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingSaleInquiryComment =>\n    typia.random<IShoppingSaleInquiryComment>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: getBySaleidAndInquiryidAndId.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getBySaleidAndInquiryidAndId.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"saleId\")(() => typia.assert(props.saleId));\n      assert.param(\"inquiryId\")(() => typia.assert(props.inquiryId));\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Update an inquiry comment.\n *\n * Update an {@link IShoppingSaleInquiryComment inquiry comment} to a specific\n * {@link IShoppingSaleQuestion question} or {@link IShoppingSaleReview review}.\n *\n * By the way, as is the general policy of this shopping mall regarding\n * comments, modifying a comment does not actually change the existing content.\n * Modified content is accumulated and recorded in the existing comment record\n * as a new {@link IShoppingSaleInquiryComment.ISnapshot snapshot}. And this is\n * made public to everyone, who can read this inquiry comment.\n *\n * This is to prevent customers or sellers from modifying their comments and\n * manipulating the circumstances due to the nature of e-commerce, where\n * disputes easily arise. That is, to preserve evidence.\n *\n * @param props.saleId Belonged sale's {@link IShoppingSale.id }\n * @param props.inquiryId Belonged inquiry's {@link IShoppingSaleInquiry.id }\n * @param props.id Target inquiry comment's\n *   {@link IShoppingSaleInquiryComment.id }\n * @param props.body Update info of the inquiry comment\n * @path /shoppings/customers/sales/:saleId/questions/:inquiryId/comments/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function putBySaleidAndInquiryidAndId(\n  connection: IConnection,\n  props: putBySaleidAndInquiryidAndId.Props,\n): Promise<putBySaleidAndInquiryidAndId.Response> {\n  return !!connection.simulate\n    ? putBySaleidAndInquiryidAndId.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...putBySaleidAndInquiryidAndId.METADATA,\n          path: putBySaleidAndInquiryidAndId.path(props),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace putBySaleidAndInquiryidAndId {\n  export type Props = {\n    /** Belonged sale's {@link IShoppingSale.id } */\n    saleId: string & tags.Format<\"uuid\">;\n\n    /** Belonged inquiry's {@link IShoppingSaleInquiry.id } */\n    inquiryId: string & tags.Format<\"uuid\">;\n\n    /** Target inquiry comment's {@link IShoppingSaleInquiryComment.id } */\n    id: string & tags.Format<\"uuid\">;\n\n    /** Update info of the inquiry comment */\n    body: IShoppingSaleInquiryComment.ICreate;\n  };\n  export type Body = IShoppingSaleInquiryComment.ICreate;\n  export type Response = IShoppingSaleInquiryComment.ISnapshot;\n\n  export const METADATA = {\n    method: \"PUT\",\n    path: \"/shoppings/customers/sales/:saleId/questions/:inquiryId/comments/:id\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Omit<Props, \"body\">) =>\n    `/shoppings/customers/sales/${encodeURIComponent(props.saleId ?? \"null\")}/questions/${encodeURIComponent(props.inquiryId ?? \"null\")}/comments/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingSaleInquiryComment.ISnapshot =>\n    typia.random<IShoppingSaleInquiryComment.ISnapshot>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: putBySaleidAndInquiryidAndId.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: putBySaleidAndInquiryidAndId.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"saleId\")(() => typia.assert(props.saleId));\n      assert.param(\"inquiryId\")(() => typia.assert(props.inquiryId));\n      assert.param(\"id\")(() => typia.assert(props.id));\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/customers/sales/questions/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingSaleQuestion } from \"../../../../../structures/IShoppingSaleQuestion\";\nimport { IPageIShoppingSaleQuestion } from \"../../../../../structures/IPageIShoppingSaleQuestion\";\nimport { IBbsArticle } from \"../../../../../structures/IBbsArticle\";\nexport * as comments from \"./comments\";\nexport * as abridges from \"./abridges\";\n\n/**\n * Write a question article.\n *\n * When a {@link IShoppingCustomer customer} wants to ask something about a\n * specific {@link IShoppingSale sale}, he/she can ask it by writing a new\n * {@link IShoppingSaleQuestion question article}.\n *\n * If the customer does not want to reveal his/her identify and question, he/she\n * can write the question as a secret article. In that case, only the customer\n * and the related {@link IShoppingSeller seller} can see the\n * {@link at detailed content}. Also, such secret question's title and writer\n * name would be masked with `*` characters in the {@link index pagiation API}.\n *\n * @param props.saleId Belonged sale's {@link IShoppingSale.id }\n * @param props.body Creation info of the question\n * @path /shoppings/customers/sales/:saleId/questions\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function postBySaleid(\n  connection: IConnection,\n  props: postBySaleid.Props,\n): Promise<postBySaleid.Response> {\n  return !!connection.simulate\n    ? postBySaleid.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...postBySaleid.METADATA,\n          path: postBySaleid.path(props),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace postBySaleid {\n  export type Props = {\n    /** Belonged sale's {@link IShoppingSale.id } */\n    saleId: string & tags.Format<\"uuid\">;\n\n    /** Creation info of the question */\n    body: IShoppingSaleQuestion.ICreate;\n  };\n  export type Body = IShoppingSaleQuestion.ICreate;\n  export type Response = IShoppingSaleQuestion;\n\n  export const METADATA = {\n    method: \"POST\",\n    path: \"/shoppings/customers/sales/:saleId/questions\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Omit<Props, \"body\">) =>\n    `/shoppings/customers/sales/${encodeURIComponent(props.saleId ?? \"null\")}/questions`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingSaleQuestion => typia.random<IShoppingSaleQuestion>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: postBySaleid.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: postBySaleid.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"saleId\")(() => typia.assert(props.saleId));\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * List up every summarized questions.\n *\n * List up every {@link IShoppingSaleQuestion.ISummary summarized questions} of a\n * {@link IShoppingSale sale}.\n *\n * As you can see, returned questions are summarized, not detailed. If you want\n * to get the detailed information of a question, use {@link adridges} function\n * or {@link at} function for each article.\n *\n * Also, returned question has {@link IShoppingSaleQuestion.ISummary.answer}\n * property which means the formal answer from the {@link IShoppingSeller}.\n * Additionally, returned question has another special property\n * {@link IShoppingSaleQuestion.ISummary.secret} with masking to other princple\n * properties, and it means only related actors can {@link at read} the\n * question.\n *\n * For reference, if you're a {@link IShoppingSeller seller}, you can only access\n * to the your own {@link IShoppingSale sale}'s questions. Otherwise, you can\n * access to every questions of the sales.\n *\n * By the way, if you want, you can limit the result by configuring\n * {@link IShoppingSaleQuestion.IRequest.search search condition} in the request\n * body. Also, it is possible to customize sequence order of records by\n * configuring {@link IShoppingSaleQuestion.IRequest.sort sort condition}.\n *\n * @param props.saleId Belonged sale's {@link IShoppingSale.id }\n * @param props.body Request info of pagination, searching and sorting\n * @path /shoppings/customers/sales/:saleId/questions\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patchBySaleid(\n  connection: IConnection,\n  props: patchBySaleid.Props,\n): Promise<patchBySaleid.Response> {\n  return !!connection.simulate\n    ? patchBySaleid.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patchBySaleid.METADATA,\n          path: patchBySaleid.path(props),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace patchBySaleid {\n  export type Props = {\n    /** Belonged sale's {@link IShoppingSale.id } */\n    saleId: string & tags.Format<\"uuid\">;\n\n    /** Request info of pagination, searching and sorting */\n    body: IShoppingSaleQuestion.IRequest;\n  };\n  export type Body = IShoppingSaleQuestion.IRequest;\n  export type Response = IPageIShoppingSaleQuestion.ISummary;\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/shoppings/customers/sales/:saleId/questions\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Omit<Props, \"body\">) =>\n    `/shoppings/customers/sales/${encodeURIComponent(props.saleId ?? \"null\")}/questions`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IPageIShoppingSaleQuestion.ISummary =>\n    typia.random<IPageIShoppingSaleQuestion.ISummary>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: patchBySaleid.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patchBySaleid.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"saleId\")(() => typia.assert(props.saleId));\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Get a question info.\n *\n * Get a detailed {@link IShoppingSaleQuestion question} information of a\n * {@link IShoppingSale sale}.\n *\n * For reference, if you're a {@link IShoppingSeller seller}, you can only access\n * to the your own {@link IShoppingSale sale}'s question. Otherwise you are a\n * {@link IShoppingCustomer customer}, you can access to every questions of the\n * sales except the {@link IShoppingSaleQuestion.secret} value is `false`.\n *\n * @param props.saleId Belonged sale's {@link IShoppingSale.id }\n * @param props.id Target question's {@link IShoppingSaleQuestion.id }\n * @path /shoppings/customers/sales/:saleId/questions/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getBySaleidAndId(\n  connection: IConnection,\n  props: getBySaleidAndId.Props,\n): Promise<getBySaleidAndId.Response> {\n  return !!connection.simulate\n    ? getBySaleidAndId.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getBySaleidAndId.METADATA,\n          path: getBySaleidAndId.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace getBySaleidAndId {\n  export type Props = {\n    /** Belonged sale's {@link IShoppingSale.id } */\n    saleId: string & tags.Format<\"uuid\">;\n\n    /** Target question's {@link IShoppingSaleQuestion.id } */\n    id: string & tags.Format<\"uuid\">;\n  };\n  export type Response = IShoppingSaleQuestion;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/shoppings/customers/sales/:saleId/questions/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/shoppings/customers/sales/${encodeURIComponent(props.saleId ?? \"null\")}/questions/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingSaleQuestion => typia.random<IShoppingSaleQuestion>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: getBySaleidAndId.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getBySaleidAndId.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"saleId\")(() => typia.assert(props.saleId));\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Update a question.\n *\n * Update a {@link IShoppingSaleQuestion question}'s content.\n *\n * By the way, as is the general policy of this shopping mall regarding\n * articles, modifying a question articles does not actually change the existing\n * content. Modified content is accumulated and recorded in the existing article\n * record as a new {@link IShoppingSaleQuestion.ISnapshot snapshot}. And this is\n * made public to everyone, including the {@link IShoppingCustomer customer} and\n * the {@link IShoppingSeller seller}, and anyone who can view the article can\n * also view the entire editing histories.\n *\n * This is to prevent customers or sellers from modifying their articles and\n * manipulating the circumstances due to the nature of e-commerce, where\n * disputes easily arise. That is, to preserve evidence.\n *\n * @param props.saleId Belonged sale's {@link IShoppingSale.id }\n * @param props.id Target question's {@link IShoppingSaleQuestion.id }\n * @param props.body Update info of the question\n * @path /shoppings/customers/sales/:saleId/questions/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function postBySaleidAndId(\n  connection: IConnection,\n  props: postBySaleidAndId.Props,\n): Promise<postBySaleidAndId.Response> {\n  return !!connection.simulate\n    ? postBySaleidAndId.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...postBySaleidAndId.METADATA,\n          path: postBySaleidAndId.path(props),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace postBySaleidAndId {\n  export type Props = {\n    /** Belonged sale's {@link IShoppingSale.id } */\n    saleId: string & tags.Format<\"uuid\">;\n\n    /** Target question's {@link IShoppingSaleQuestion.id } */\n    id: string & tags.Format<\"uuid\">;\n\n    /** Update info of the question */\n    body: IBbsArticle.ICreate;\n  };\n  export type Body = IBbsArticle.ICreate;\n  export type Response = IBbsArticle.ISnapshot;\n\n  export const METADATA = {\n    method: \"POST\",\n    path: \"/shoppings/customers/sales/:saleId/questions/:id\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Omit<Props, \"body\">) =>\n    `/shoppings/customers/sales/${encodeURIComponent(props.saleId ?? \"null\")}/questions/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IBbsArticle.ISnapshot => typia.random<IBbsArticle.ISnapshot>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: postBySaleidAndId.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: postBySaleidAndId.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"saleId\")(() => typia.assert(props.saleId));\n      assert.param(\"id\")(() => typia.assert(props.id));\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/customers/sales/questions/abridges/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingSaleQuestion } from \"../../../../../../structures/IShoppingSaleQuestion\";\nimport { IPageIShoppingSaleQuestion } from \"../../../../../../structures/IPageIShoppingSaleQuestion\";\n\n/**\n * List up every abridged questions.\n *\n * List up every {@link IShoppingSaleQuestion.IAbridge abridged questions} of a\n * {@link IShoppingSale sale}.\n *\n * As you can see, returned questions are abridged, not detailed. If you want to\n * get the detailed information of a question, use {@link at} function for each\n * article.\n *\n * Also, returned question has {@link IShoppingSaleQuestion.IAridge.answer}\n * property which means the formal answer from the {@link IShoppingSeller}.\n * Additionally, returned question has another special property\n * {@link IShoppingSaleQuestion.IAridge.secret} with masking to other princple\n * properties, and it means only related actors can {@link at read} the\n * question.\n *\n * For reference, if you're a {@link IShoppingSeller seller}, you can only access\n * to the your own {@link IShoppingSale sale}'s questions. Otherwise, you can\n * access to every questions of the sales.\n *\n * By the way, if you want, you can limit the result by configuring\n * {@link IShoppingSaleQuestion.IRequest.search search condition} in the request\n * body. Also, it is possible to customize sequence order of records by\n * configuring {@link IShoppingSaleQuestion.IRequest.sort sort condition}.\n *\n * @param props.saleId Belonged sale's {@link IShoppingSale.id }\n * @param props.body Request info of pagination, searching and sorting\n * @path /shoppings/customers/sales/:saleId/questions/abridges\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patchBySaleid(\n  connection: IConnection,\n  props: patchBySaleid.Props,\n): Promise<patchBySaleid.Response> {\n  return !!connection.simulate\n    ? patchBySaleid.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patchBySaleid.METADATA,\n          path: patchBySaleid.path(props),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace patchBySaleid {\n  export type Props = {\n    /** Belonged sale's {@link IShoppingSale.id } */\n    saleId: string & tags.Format<\"uuid\">;\n\n    /** Request info of pagination, searching and sorting */\n    body: IShoppingSaleQuestion.IRequest;\n  };\n  export type Body = IShoppingSaleQuestion.IRequest;\n  export type Response = IPageIShoppingSaleQuestion.IAbridge;\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/shoppings/customers/sales/:saleId/questions/abridges\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Omit<Props, \"body\">) =>\n    `/shoppings/customers/sales/${encodeURIComponent(props.saleId ?? \"null\")}/questions/abridges`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IPageIShoppingSaleQuestion.IAbridge =>\n    typia.random<IPageIShoppingSaleQuestion.IAbridge>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: patchBySaleid.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patchBySaleid.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"saleId\")(() => typia.assert(props.saleId));\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/customers/sales/reviews/comments/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingSaleInquiryComment } from \"../../../../../../structures/IShoppingSaleInquiryComment\";\nimport { IPageIShoppingSaleInquiryComment } from \"../../../../../../structures/IPageIShoppingSaleInquiryComment\";\n\n/**\n * Create an inquiry comment.\n *\n * Create an {@link IShoppingSaleInquiryComment inquiry comment} of a\n * {@link IShoppingSaleQuestion question} or {@link IShoppingSaleReview review}.\n *\n * For reference, if you're a {@link IShoppingSeller seller}, you can only create\n * an inquiry comment to your own {@link IShoppingSale sale}'s inquiry.\n * Otherwise, you can create an inquiry comment to every inquiries of the\n * sales.\n *\n * @param props.saleId Belonged sale's {@link IShoppingSale.id }\n * @param props.inquiryId Target inquiry's {@link IShoppingSaleInquiry.id }\n * @param props.body Creation info of the inquiry comment\n * @path /shoppings/customers/sales/:saleId/reviews/:inquiryId/comments\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function postBySaleidAndInquiryid(\n  connection: IConnection,\n  props: postBySaleidAndInquiryid.Props,\n): Promise<postBySaleidAndInquiryid.Response> {\n  return !!connection.simulate\n    ? postBySaleidAndInquiryid.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...postBySaleidAndInquiryid.METADATA,\n          path: postBySaleidAndInquiryid.path(props),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace postBySaleidAndInquiryid {\n  export type Props = {\n    /** Belonged sale's {@link IShoppingSale.id } */\n    saleId: string & tags.Format<\"uuid\">;\n\n    /** Target inquiry's {@link IShoppingSaleInquiry.id } */\n    inquiryId: string & tags.Format<\"uuid\">;\n\n    /** Creation info of the inquiry comment */\n    body: IShoppingSaleInquiryComment.ICreate;\n  };\n  export type Body = IShoppingSaleInquiryComment.ICreate;\n  export type Response = IShoppingSaleInquiryComment;\n\n  export const METADATA = {\n    method: \"POST\",\n    path: \"/shoppings/customers/sales/:saleId/reviews/:inquiryId/comments\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Omit<Props, \"body\">) =>\n    `/shoppings/customers/sales/${encodeURIComponent(props.saleId ?? \"null\")}/reviews/${encodeURIComponent(props.inquiryId ?? \"null\")}/comments`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingSaleInquiryComment =>\n    typia.random<IShoppingSaleInquiryComment>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: postBySaleidAndInquiryid.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: postBySaleidAndInquiryid.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"saleId\")(() => typia.assert(props.saleId));\n      assert.param(\"inquiryId\")(() => typia.assert(props.inquiryId));\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * List up every inquiry comments.\n *\n * List up every {@link IShoppingSaleInquiryComment inquiry comments} of a\n * {@link IShoppingSaleQuestion question} or {@link IShoppingSaleReview review}\n * with {@link IPage pagination}.\n *\n * If you want, you can limit the result by configuring\n * {@link IShoppingSaleInquiryComment.IRequest.search search condition} in the\n * request body. Also, it is possible to customize sequence order of records by\n * configuring {@link IShoppingSaleInquiryComment.IRequest.sort sort condition}.\n *\n * By the way, if you're a {@link IShoppingSeller seller}, you can only access to\n * the your own {@link IShoppingSale sale}'s inquiries. Otherwise, you can access\n * to every inquiries of the sales.\n *\n * @param props.saleId Belonged sale's {@link IShoppingSale.id }\n * @param props.inquiryId Belonged inquiry's {@link IShoppingSaleInquiry.id }\n * @param props.body Request info of pagination, searching and sorting\n * @path /shoppings/customers/sales/:saleId/reviews/:inquiryId/comments\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patchBySaleidAndInquiryid(\n  connection: IConnection,\n  props: patchBySaleidAndInquiryid.Props,\n): Promise<patchBySaleidAndInquiryid.Response> {\n  return !!connection.simulate\n    ? patchBySaleidAndInquiryid.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patchBySaleidAndInquiryid.METADATA,\n          path: patchBySaleidAndInquiryid.path(props),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace patchBySaleidAndInquiryid {\n  export type Props = {\n    /** Belonged sale's {@link IShoppingSale.id } */\n    saleId: string & tags.Format<\"uuid\">;\n\n    /** Belonged inquiry's {@link IShoppingSaleInquiry.id } */\n    inquiryId: string & tags.Format<\"uuid\">;\n\n    /** Request info of pagination, searching and sorting */\n    body: IShoppingSaleInquiryComment.IRequest;\n  };\n  export type Body = IShoppingSaleInquiryComment.IRequest;\n  export type Response = IPageIShoppingSaleInquiryComment;\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/shoppings/customers/sales/:saleId/reviews/:inquiryId/comments\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Omit<Props, \"body\">) =>\n    `/shoppings/customers/sales/${encodeURIComponent(props.saleId ?? \"null\")}/reviews/${encodeURIComponent(props.inquiryId ?? \"null\")}/comments`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IPageIShoppingSaleInquiryComment =>\n    typia.random<IPageIShoppingSaleInquiryComment>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: patchBySaleidAndInquiryid.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patchBySaleidAndInquiryid.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"saleId\")(() => typia.assert(props.saleId));\n      assert.param(\"inquiryId\")(() => typia.assert(props.inquiryId));\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Get an inquiry comment info.\n *\n * Get a detailed {@link IShoppingSaleInquiryComment inquiry comment} information\n * of a {@link IShoppingSaleQuestion question} or\n * {@link IShoppingSaleReview review}.\n *\n * For reference, if you're a {@link IShoppingSeller seller}, you can only access\n * to the your own {@link IShoppingSale sale}'s inquiry comment. Otherwise, you\n * can access to every inquiry comments of the sales.\n *\n * @param props.saleId Belonged sale's {@link IShoppingSale.id }\n * @param props.inquiryId Belonged inquiry's {@link IShoppingSaleInquiry.id }\n * @param props.id Target inquiry comment's\n *   {@link IShoppingSaleInquiryComment.id }\n * @path /shoppings/customers/sales/:saleId/reviews/:inquiryId/comments/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getBySaleidAndInquiryidAndId(\n  connection: IConnection,\n  props: getBySaleidAndInquiryidAndId.Props,\n): Promise<getBySaleidAndInquiryidAndId.Response> {\n  return !!connection.simulate\n    ? getBySaleidAndInquiryidAndId.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getBySaleidAndInquiryidAndId.METADATA,\n          path: getBySaleidAndInquiryidAndId.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace getBySaleidAndInquiryidAndId {\n  export type Props = {\n    /** Belonged sale's {@link IShoppingSale.id } */\n    saleId: string & tags.Format<\"uuid\">;\n\n    /** Belonged inquiry's {@link IShoppingSaleInquiry.id } */\n    inquiryId: string & tags.Format<\"uuid\">;\n\n    /** Target inquiry comment's {@link IShoppingSaleInquiryComment.id } */\n    id: string & tags.Format<\"uuid\">;\n  };\n  export type Response = IShoppingSaleInquiryComment;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/shoppings/customers/sales/:saleId/reviews/:inquiryId/comments/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/shoppings/customers/sales/${encodeURIComponent(props.saleId ?? \"null\")}/reviews/${encodeURIComponent(props.inquiryId ?? \"null\")}/comments/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingSaleInquiryComment =>\n    typia.random<IShoppingSaleInquiryComment>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: getBySaleidAndInquiryidAndId.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getBySaleidAndInquiryidAndId.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"saleId\")(() => typia.assert(props.saleId));\n      assert.param(\"inquiryId\")(() => typia.assert(props.inquiryId));\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Update an inquiry comment.\n *\n * Update an {@link IShoppingSaleInquiryComment inquiry comment} to a specific\n * {@link IShoppingSaleQuestion question} or {@link IShoppingSaleReview review}.\n *\n * By the way, as is the general policy of this shopping mall regarding\n * comments, modifying a comment does not actually change the existing content.\n * Modified content is accumulated and recorded in the existing comment record\n * as a new {@link IShoppingSaleInquiryComment.ISnapshot snapshot}. And this is\n * made public to everyone, who can read this inquiry comment.\n *\n * This is to prevent customers or sellers from modifying their comments and\n * manipulating the circumstances due to the nature of e-commerce, where\n * disputes easily arise. That is, to preserve evidence.\n *\n * @param props.saleId Belonged sale's {@link IShoppingSale.id }\n * @param props.inquiryId Belonged inquiry's {@link IShoppingSaleInquiry.id }\n * @param props.id Target inquiry comment's\n *   {@link IShoppingSaleInquiryComment.id }\n * @param props.body Update info of the inquiry comment\n * @path /shoppings/customers/sales/:saleId/reviews/:inquiryId/comments/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function putBySaleidAndInquiryidAndId(\n  connection: IConnection,\n  props: putBySaleidAndInquiryidAndId.Props,\n): Promise<putBySaleidAndInquiryidAndId.Response> {\n  return !!connection.simulate\n    ? putBySaleidAndInquiryidAndId.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...putBySaleidAndInquiryidAndId.METADATA,\n          path: putBySaleidAndInquiryidAndId.path(props),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace putBySaleidAndInquiryidAndId {\n  export type Props = {\n    /** Belonged sale's {@link IShoppingSale.id } */\n    saleId: string & tags.Format<\"uuid\">;\n\n    /** Belonged inquiry's {@link IShoppingSaleInquiry.id } */\n    inquiryId: string & tags.Format<\"uuid\">;\n\n    /** Target inquiry comment's {@link IShoppingSaleInquiryComment.id } */\n    id: string & tags.Format<\"uuid\">;\n\n    /** Update info of the inquiry comment */\n    body: IShoppingSaleInquiryComment.ICreate;\n  };\n  export type Body = IShoppingSaleInquiryComment.ICreate;\n  export type Response = IShoppingSaleInquiryComment.ISnapshot;\n\n  export const METADATA = {\n    method: \"PUT\",\n    path: \"/shoppings/customers/sales/:saleId/reviews/:inquiryId/comments/:id\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Omit<Props, \"body\">) =>\n    `/shoppings/customers/sales/${encodeURIComponent(props.saleId ?? \"null\")}/reviews/${encodeURIComponent(props.inquiryId ?? \"null\")}/comments/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingSaleInquiryComment.ISnapshot =>\n    typia.random<IShoppingSaleInquiryComment.ISnapshot>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: putBySaleidAndInquiryidAndId.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: putBySaleidAndInquiryidAndId.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"saleId\")(() => typia.assert(props.saleId));\n      assert.param(\"inquiryId\")(() => typia.assert(props.inquiryId));\n      assert.param(\"id\")(() => typia.assert(props.id));\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/customers/sales/reviews/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingSaleReview } from \"../../../../../structures/IShoppingSaleReview\";\nimport { IPageIShoppingSaleReview } from \"../../../../../structures/IPageIShoppingSaleReview\";\nexport * as comments from \"./comments\";\nexport * as abridges from \"./abridges\";\n\n/**\n * Write a review article.\n *\n * When a {@link IShoppingCustomer customer} has purchased a specific\n * {@link IShoppingSale sale} and get {@link IShoppingDelivery delivered} it,\n * he/she can write a {@link IShoppingSaleReview review} article about the sale.\n *\n * If try to write a review article without purchasing or the delivery has not\n * been completed, 428 unprocessable entity error would be thrown. Also, the\n * customer can write multiple review articles per an order, but the next\n * article can be written after 2 weeks from the previous article. If not, 428\n * unprocessable entity error would be thrown, either.\n *\n * @param props.saleId Belonged sale's {@link IShoppingSale.id }\n * @param props.body Creation info of the review\n * @path /shoppings/customers/sales/:saleId/reviews\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function postBySaleid(\n  connection: IConnection,\n  props: postBySaleid.Props,\n): Promise<postBySaleid.Response> {\n  return !!connection.simulate\n    ? postBySaleid.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...postBySaleid.METADATA,\n          path: postBySaleid.path(props),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace postBySaleid {\n  export type Props = {\n    /** Belonged sale's {@link IShoppingSale.id } */\n    saleId: string & tags.Format<\"uuid\">;\n\n    /** Creation info of the review */\n    body: IShoppingSaleReview.ICreate;\n  };\n  export type Body = IShoppingSaleReview.ICreate;\n  export type Response = IShoppingSaleReview;\n\n  export const METADATA = {\n    method: \"POST\",\n    path: \"/shoppings/customers/sales/:saleId/reviews\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Omit<Props, \"body\">) =>\n    `/shoppings/customers/sales/${encodeURIComponent(props.saleId ?? \"null\")}/reviews`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingSaleReview => typia.random<IShoppingSaleReview>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: postBySaleid.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: postBySaleid.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"saleId\")(() => typia.assert(props.saleId));\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * List up every summarized reviews.\n *\n * List up every {@link IShoppingSaleReview.ISummary summarized reviews} of a\n * {@link IShoppingSale sale}.\n *\n * As you can see, returned reviews are summarized, not detailed. If you want to\n * get the detailed information of a review, use {@link adridges} function or\n * {@link at} function for each article.\n *\n * Also, returned review has {@link IShoppingSaleReview.ISummary.answer} property\n * which means the formal answer from the {@link IShoppingSeller}.\n *\n * For reference, if you're a {@link IShoppingSeller seller}, you can only access\n * to the your own {@link IShoppingSale sale}'s reviews. Otherwise, you can\n * access to every reviews of the sales.\n *\n * By the way, if you want, you can limit the result by configuring\n * {@link IShoppingSaleReview.IRequest.search search condition} in the request\n * body. Also, it is possible to customize sequence order of records by\n * configuring {@link IShoppingSaleReview.IRequest.sort sort condition}.\n *\n * @param props.saleId Belonged sale's {@link IShoppingSale.id }\n * @param props.body Request info of pagination, searching and sorting\n * @path /shoppings/customers/sales/:saleId/reviews\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patchBySaleid(\n  connection: IConnection,\n  props: patchBySaleid.Props,\n): Promise<patchBySaleid.Response> {\n  return !!connection.simulate\n    ? patchBySaleid.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patchBySaleid.METADATA,\n          path: patchBySaleid.path(props),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace patchBySaleid {\n  export type Props = {\n    /** Belonged sale's {@link IShoppingSale.id } */\n    saleId: string & tags.Format<\"uuid\">;\n\n    /** Request info of pagination, searching and sorting */\n    body: IShoppingSaleReview.IRequest;\n  };\n  export type Body = IShoppingSaleReview.IRequest;\n  export type Response = IPageIShoppingSaleReview.ISummary;\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/shoppings/customers/sales/:saleId/reviews\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Omit<Props, \"body\">) =>\n    `/shoppings/customers/sales/${encodeURIComponent(props.saleId ?? \"null\")}/reviews`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IPageIShoppingSaleReview.ISummary =>\n    typia.random<IPageIShoppingSaleReview.ISummary>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: patchBySaleid.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patchBySaleid.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"saleId\")(() => typia.assert(props.saleId));\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Get a review info.\n *\n * Get a detailed {@link IShoppingSaleReview review} information of a\n * {@link IShoppingSale sale}.\n *\n * For reference, if you're a {@link IShoppingSeller seller}, you can only access\n * to the your own {@link IShoppingSale sale}'s review. Otherwise you are a\n * {@link IShoppingCustomer customer}, you can access to every reviews of the\n * sales.\n *\n * @param props.saleId Belonged sale's {@link IShoppingSale.id }\n * @param props.id Target review's {@link IShoppingSaleReview.id }\n * @path /shoppings/customers/sales/:saleId/reviews/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getBySaleidAndId(\n  connection: IConnection,\n  props: getBySaleidAndId.Props,\n): Promise<getBySaleidAndId.Response> {\n  return !!connection.simulate\n    ? getBySaleidAndId.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getBySaleidAndId.METADATA,\n          path: getBySaleidAndId.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace getBySaleidAndId {\n  export type Props = {\n    /** Belonged sale's {@link IShoppingSale.id } */\n    saleId: string & tags.Format<\"uuid\">;\n\n    /** Target review's {@link IShoppingSaleReview.id } */\n    id: string & tags.Format<\"uuid\">;\n  };\n  export type Response = IShoppingSaleReview;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/shoppings/customers/sales/:saleId/reviews/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/shoppings/customers/sales/${encodeURIComponent(props.saleId ?? \"null\")}/reviews/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingSaleReview => typia.random<IShoppingSaleReview>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: getBySaleidAndId.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getBySaleidAndId.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"saleId\")(() => typia.assert(props.saleId));\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Update a review.\n *\n * Updadte a {@link IShoppingSaleReview review}'s content and score.\n *\n * By the way, as is the general policy of this shopping mall regarding\n * articles, modifying a question articles does not actually change the existing\n * content. Modified content is accumulated and recorded in the existing article\n * record as a new {@link IShoppingSaleReview.ISnapshot snapshot}. And this is\n * made public to everyone, including the {@link IShoppingCustomer customer} and\n * the {@link IShoppingSeller seller}, and anyone who can view the article can\n * also view the entire editing histories.\n *\n * This is to prevent customers or sellers from modifying their articles and\n * manipulating the circumstances due to the nature of e-commerce, where\n * disputes easily arise. That is, to preserve evidence.\n *\n * @param props.saleId Belonged sale's {@link IShoppingSale.id }\n * @param props.id Target review's {@link IShoppingSaleReview.id }\n * @param props.body Update info of the review\n * @path /shoppings/customers/sales/:saleId/reviews/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function postBySaleidAndId(\n  connection: IConnection,\n  props: postBySaleidAndId.Props,\n): Promise<postBySaleidAndId.Response> {\n  return !!connection.simulate\n    ? postBySaleidAndId.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...postBySaleidAndId.METADATA,\n          path: postBySaleidAndId.path(props),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace postBySaleidAndId {\n  export type Props = {\n    /** Belonged sale's {@link IShoppingSale.id } */\n    saleId: string & tags.Format<\"uuid\">;\n\n    /** Target review's {@link IShoppingSaleReview.id } */\n    id: string & tags.Format<\"uuid\">;\n\n    /** Update info of the review */\n    body: IShoppingSaleReview.IUpdate;\n  };\n  export type Body = IShoppingSaleReview.IUpdate;\n  export type Response = IShoppingSaleReview.ISnapshot;\n\n  export const METADATA = {\n    method: \"POST\",\n    path: \"/shoppings/customers/sales/:saleId/reviews/:id\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Omit<Props, \"body\">) =>\n    `/shoppings/customers/sales/${encodeURIComponent(props.saleId ?? \"null\")}/reviews/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingSaleReview.ISnapshot =>\n    typia.random<IShoppingSaleReview.ISnapshot>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: postBySaleidAndId.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: postBySaleidAndId.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"saleId\")(() => typia.assert(props.saleId));\n      assert.param(\"id\")(() => typia.assert(props.id));\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/customers/sales/reviews/abridges/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingSaleReview } from \"../../../../../../structures/IShoppingSaleReview\";\nimport { IPageIShoppingSaleReview } from \"../../../../../../structures/IPageIShoppingSaleReview\";\n\n/**\n * List up every abridged reviews.\n *\n * List up every {@link IShoppingSaleReview.IAbridge abridged reviews} of a\n * {@link IShoppingSale sale}.\n *\n * As you can see, returned reviews are abridged, not detailed. If you want to\n * get the detailed information of a review, use {@link at} function for each\n * article.\n *\n * Also, returned review has {@link IShoppingSaleReview.IAridge.answer} property\n * which means the formal answer from the {@link IShoppingSeller}.\n *\n * For reference, if you're a {@link IShoppingSeller seller}, you can only access\n * to the your own {@link IShoppingSale sale}'s reviews. Otherwise, you can\n * access to every reviews of the sales.\n *\n * By the way, if you want, you can limit the result by configuring\n * {@link IShoppingSaleReview.IRequest.search search condition} in the request\n * body. Also, it is possible to customize sequence order of records by\n * configuring {@link IShoppingSaleReview.IRequest.sort sort condition}.\n *\n * @param props.saleId Belonged sale's {@link IShoppingSale.id }\n * @param props.body Request info of pagination, searching and sorting\n * @path /shoppings/customers/sales/:saleId/reviews/abridges\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patchBySaleid(\n  connection: IConnection,\n  props: patchBySaleid.Props,\n): Promise<patchBySaleid.Response> {\n  return !!connection.simulate\n    ? patchBySaleid.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patchBySaleid.METADATA,\n          path: patchBySaleid.path(props),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace patchBySaleid {\n  export type Props = {\n    /** Belonged sale's {@link IShoppingSale.id } */\n    saleId: string & tags.Format<\"uuid\">;\n\n    /** Request info of pagination, searching and sorting */\n    body: IShoppingSaleReview.IRequest;\n  };\n  export type Body = IShoppingSaleReview.IRequest;\n  export type Response = IPageIShoppingSaleReview.IAbridge;\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/shoppings/customers/sales/:saleId/reviews/abridges\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Omit<Props, \"body\">) =>\n    `/shoppings/customers/sales/${encodeURIComponent(props.saleId ?? \"null\")}/reviews/abridges`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IPageIShoppingSaleReview.IAbridge =>\n    typia.random<IPageIShoppingSaleReview.IAbridge>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: patchBySaleid.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patchBySaleid.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"saleId\")(() => typia.assert(props.saleId));\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/customers/sales/snapshots/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IPage } from \"../../../../../structures/IPage\";\nimport { IPageIShoppingSaleSnapshot } from \"../../../../../structures/IPageIShoppingSaleSnapshot\";\nimport { IShoppingSaleSnapshot } from \"../../../../../structures/IShoppingSaleSnapshot\";\nexport * as flip from \"./flip\";\n\n/**\n * List up every snapshots.\n *\n * Whenever {@link IShoppingSeller seller} updates a {@link IShoppingSale sale},\n * the sale record is not updated but a new\n * {@link IShoppingSaleSnapshot snapshot} record is created to keep the integrity\n * of the sale history. This API function is for listing up such snapshot\n * records.\n *\n * Also, as you can see from the return type, returned snapshots are summarized,\n * not detailed. If you want to get the detailed information of a snapshot, use\n * {@link at} or {@link flipo} function for each snapshot.\n *\n * For reference, if you're a {@link IShoppingSeller seller}, you can only access\n * to the your own {@link IShoppingSale sale}'s snapshots. Otherwise, you can\n * access to every snapshots of the sales even though the sale has been closed\n * or suspended.\n *\n * @param props.saleId Target sale's {@link IShoppingSale.id }\n * @param props.body Requestion info of pagination\n * @path /shoppings/customers/sales/:saleId/snapshots\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patchBySaleid(\n  connection: IConnection,\n  props: patchBySaleid.Props,\n): Promise<patchBySaleid.Response> {\n  return !!connection.simulate\n    ? patchBySaleid.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patchBySaleid.METADATA,\n          path: patchBySaleid.path(props),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace patchBySaleid {\n  export type Props = {\n    /** Target sale's {@link IShoppingSale.id } */\n    saleId: string & tags.Format<\"uuid\">;\n\n    /** Requestion info of pagination */\n    body: IPage.IRequest;\n  };\n  export type Body = IPage.IRequest;\n  export type Response = IPageIShoppingSaleSnapshot.ISummary;\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/shoppings/customers/sales/:saleId/snapshots\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Omit<Props, \"body\">) =>\n    `/shoppings/customers/sales/${encodeURIComponent(props.saleId ?? \"null\")}/snapshots`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IPageIShoppingSaleSnapshot.ISummary =>\n    typia.random<IPageIShoppingSaleSnapshot.ISummary>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: patchBySaleid.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patchBySaleid.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"saleId\")(() => typia.assert(props.saleId));\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Get a snapshot info.\n *\n * Get a {@link IShoppingSaleSnapshot snapshot} with detailed information.\n *\n * As you can see from the return type, returned snapshot does not contain the\n * {@link IShoppingSale sale} info. If you want to get the sale info, use the\n * {@link flip} function instead.\n *\n * For reference, if you're a {@link IShoppingSeller seller}, you can only access\n * to the your own {@link IShoppingSale sale}'s snapshots. Otherwise, you can\n * access to every snapshots of the sales even though the sale has been closed\n * or suspended.\n *\n * @param props.saleId Belonged sale's {@link IShoppingSale.id }\n * @param props.id Target snapshot's {@link IShoppingSaleSnapshot.id }\n * @path /shoppings/customers/sales/:saleId/snapshots/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getBySaleidAndId(\n  connection: IConnection,\n  props: getBySaleidAndId.Props,\n): Promise<getBySaleidAndId.Response> {\n  return !!connection.simulate\n    ? getBySaleidAndId.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getBySaleidAndId.METADATA,\n          path: getBySaleidAndId.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace getBySaleidAndId {\n  export type Props = {\n    /** Belonged sale's {@link IShoppingSale.id } */\n    saleId: string & tags.Format<\"uuid\">;\n\n    /** Target snapshot's {@link IShoppingSaleSnapshot.id } */\n    id: string & tags.Format<\"uuid\">;\n  };\n  export type Response = IShoppingSaleSnapshot;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/shoppings/customers/sales/:saleId/snapshots/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/shoppings/customers/sales/${encodeURIComponent(props.saleId ?? \"null\")}/snapshots/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingSaleSnapshot => typia.random<IShoppingSaleSnapshot>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: getBySaleidAndId.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getBySaleidAndId.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"saleId\")(() => typia.assert(props.saleId));\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/customers/sales/snapshots/flip/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingSale } from \"../../../../../../structures/IShoppingSale\";\n\n/**\n * Get a flipped snapshot info.\n *\n * Get a {@link IShoppingSale sale} info of a flipped snapshot.\n *\n * As you can see from the return type, this function returns the\n * {@link IShoppingSale sale} info. By the way, the sale info is not the latest\n * one, but a flipped info in the snapshot side.\n *\n * Also, if you're a {@link IShoppingSeller seller}, you can only access to the\n * your own {@link IShoppingSale sale}'s snapshots. Otherwise, you can access to\n * every snapshots of the sales even though the sale has been closed or\n * suspended.\n *\n * @param props.saleId Belonged sale's {@link IShoppingSale.id }\n * @param props.id Target snapshot's {@link IShoppingSaleSnapshot.id }\n * @path /shoppings/customers/sales/:saleId/snapshots/:id/flip\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getBySaleidAndId(\n  connection: IConnection,\n  props: getBySaleidAndId.Props,\n): Promise<getBySaleidAndId.Response> {\n  return !!connection.simulate\n    ? getBySaleidAndId.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getBySaleidAndId.METADATA,\n          path: getBySaleidAndId.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace getBySaleidAndId {\n  export type Props = {\n    /** Belonged sale's {@link IShoppingSale.id } */\n    saleId: string & tags.Format<\"uuid\">;\n\n    /** Target snapshot's {@link IShoppingSaleSnapshot.id } */\n    id: string & tags.Format<\"uuid\">;\n  };\n  export type Response = IShoppingSale;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/shoppings/customers/sales/:saleId/snapshots/:id/flip\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/shoppings/customers/sales/${encodeURIComponent(props.saleId ?? \"null\")}/snapshots/${encodeURIComponent(props.id ?? \"null\")}/flip`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): IShoppingSale =>\n    typia.random<IShoppingSale>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: getBySaleidAndId.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getBySaleidAndId.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"saleId\")(() => typia.assert(props.saleId));\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/customers/systematic/channels/categories/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingChannelCategory } from \"../../../../../../structures/IShoppingChannelCategory\";\nexport * as invert from \"./invert\";\n\n/**\n * List up every categories with children records.\n *\n * List up every {@link IShoppingChannelCategory.IHierarchical categories} of a\n * {@link IShoppingChannel channel} with pagination. Returned categories contain\n * children categories, too.\n *\n * If you want, you can limit the result by configuring\n * {@link IShoppingChannelCategory.IRequest.search search condition} in the\n * request body. Also, it is possible to customize sequence order of records by\n * configuring {@link IShoppingChannelCategory.IRequest.sort sort condition}.\n *\n * @param props.channelCode Belonged channel's {@link IShoppingChannel.code }\n * @path /shoppings/customers/systematic/channels/:channelCode/categories\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patchByChannelcode(\n  connection: IConnection,\n  props: patchByChannelcode.Props,\n): Promise<void> {\n  return !!connection.simulate\n    ? patchByChannelcode.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patchByChannelcode.METADATA,\n          path: patchByChannelcode.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace patchByChannelcode {\n  export type Props = {\n    /** Belonged channel's {@link IShoppingChannel.code } */\n    channelCode: string;\n  };\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/shoppings/customers/systematic/channels/:channelCode/categories\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/shoppings/customers/systematic/channels/${encodeURIComponent(props.channelCode ?? \"null\")}/categories`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): void =>\n    typia.random<void>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: patchByChannelcode.Props,\n  ): void => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patchByChannelcode.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"channelCode\")(() => typia.assert(props.channelCode));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Get a category info.\n *\n * Get a detailed {@link IShoppingChannelCategory category} information.\n *\n * Returned category contains hierarchical children categories, and also\n * contains the recursive parent categories, too.\n *\n * @param props.channelCode Belonged channel's {@link IShoppingChannel.code }\n * @param props.id Target category's {@link IShoppingChannelCategory.id }\n * @path /shoppings/customers/systematic/channels/:channelCode/categories/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getByChannelcodeAndId(\n  connection: IConnection,\n  props: getByChannelcodeAndId.Props,\n): Promise<getByChannelcodeAndId.Response> {\n  return !!connection.simulate\n    ? getByChannelcodeAndId.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getByChannelcodeAndId.METADATA,\n          path: getByChannelcodeAndId.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace getByChannelcodeAndId {\n  export type Props = {\n    /** Belonged channel's {@link IShoppingChannel.code } */\n    channelCode: string;\n\n    /** Target category's {@link IShoppingChannelCategory.id } */\n    id: string & tags.Format<\"uuid\">;\n  };\n  export type Response = IShoppingChannelCategory;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/shoppings/customers/systematic/channels/:channelCode/categories/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/shoppings/customers/systematic/channels/${encodeURIComponent(props.channelCode ?? \"null\")}/categories/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingChannelCategory => typia.random<IShoppingChannelCategory>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: getByChannelcodeAndId.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getByChannelcodeAndId.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"channelCode\")(() => typia.assert(props.channelCode));\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/customers/systematic/channels/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingChannel } from \"../../../../../structures/IShoppingChannel\";\nimport { IPageIShoppingChannel } from \"../../../../../structures/IPageIShoppingChannel\";\nexport * as categories from \"./categories\";\nexport * as hierarchical from \"./hierarchical\";\nexport * as get from \"./get\";\n\n/**\n * List up every channels.\n *\n * List up every {@link IShoppingChannel channels} with pagination.\n *\n * If you want, you can limit the result by configuring\n * {@link IShoppingChannel.IRequest.search search condition} in the request body.\n * Also, it is possible to customize sequence order of records by configuring\n * {@link IShoppingChannel.IRequest.sort sort condition}.\n *\n * @param props.body Request info of pagination, searching and sorting\n * @path /shoppings/customers/systematic/channels\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patch(\n  connection: IConnection,\n  props: patch.Props,\n): Promise<patch.Response> {\n  return !!connection.simulate\n    ? patch.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patch.METADATA,\n          path: patch.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace patch {\n  export type Props = {\n    /** Request info of pagination, searching and sorting */\n    body: IShoppingChannel.IRequest;\n  };\n  export type Body = IShoppingChannel.IRequest;\n  export type Response = IPageIShoppingChannel;\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/shoppings/customers/systematic/channels\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/shoppings/customers/systematic/channels\";\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IPageIShoppingChannel => typia.random<IPageIShoppingChannel>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: patch.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patch.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Get a channel info.\n *\n * Get a detailed {@link IShoppingChannel.IHierarchical channel} information.\n *\n * Returned channel instance also contains the nested\n * {@link IShoppingChannelCategory.IHierarchical hierarchical category}\n * information.\n *\n * @param props.id Target channel's {@link IShoppingChannel.id }\n * @path /shoppings/customers/systematic/channels/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getById(\n  connection: IConnection,\n  props: getById.Props,\n): Promise<getById.Response> {\n  return !!connection.simulate\n    ? getById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getById.METADATA,\n          path: getById.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace getById {\n  export type Props = {\n    /** Target channel's {@link IShoppingChannel.id } */\n    id: string & tags.Format<\"uuid\">;\n  };\n  export type Response = IShoppingChannel.IHierarchical;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/shoppings/customers/systematic/channels/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/shoppings/customers/systematic/channels/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingChannel.IHierarchical =>\n    typia.random<IShoppingChannel.IHierarchical>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: getById.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/customers/systematic/index.ts": "export * as channels from \"./channels\";\nexport * as sections from \"./sections\";\n",
  "src/api/functional/shoppings/customers/systematic/channels/categories/invert/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingChannelCategory } from \"../../../../../../../structures/IShoppingChannelCategory\";\n\n/**\n * Get a category info of inverted.\n *\n * Get a inverted {@link IShoppingChannelCategory.IInvert category} information.\n *\n * Returned category contains the recursive parent categories, but not contains\n * the hierarchical children categories.\n *\n * @param props.channelCode Belonged channel's {@link IShoppingChannel.code }\n * @param props.id Target category's {@link IShoppingChannelCategory.id }\n * @path /shoppings/customers/systematic/channels/:channelCode/categories/:id/invert\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getByChannelcodeAndId(\n  connection: IConnection,\n  props: getByChannelcodeAndId.Props,\n): Promise<getByChannelcodeAndId.Response> {\n  return !!connection.simulate\n    ? getByChannelcodeAndId.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getByChannelcodeAndId.METADATA,\n          path: getByChannelcodeAndId.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace getByChannelcodeAndId {\n  export type Props = {\n    /** Belonged channel's {@link IShoppingChannel.code } */\n    channelCode: string;\n\n    /** Target category's {@link IShoppingChannelCategory.id } */\n    id: string & tags.Format<\"uuid\">;\n  };\n  export type Response = IShoppingChannelCategory.IInvert;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/shoppings/customers/systematic/channels/:channelCode/categories/:id/invert\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/shoppings/customers/systematic/channels/${encodeURIComponent(props.channelCode ?? \"null\")}/categories/${encodeURIComponent(props.id ?? \"null\")}/invert`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingChannelCategory.IInvert =>\n    typia.random<IShoppingChannelCategory.IInvert>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: getByChannelcodeAndId.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getByChannelcodeAndId.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"channelCode\")(() => typia.assert(props.channelCode));\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/customers/systematic/channels/hierarchical/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingChannel } from \"../../../../../../structures/IShoppingChannel\";\nimport { IPageIShoppingChannel } from \"../../../../../../structures/IPageIShoppingChannel\";\n\n/**\n * List up every channels with nested categories.\n *\n * List up every {@link IShoppingChannel.IHierarchical channels} with\n * {@link IPage pagination}. Returned channels contain nested hierarchical\n * {@link IShoppingChannelCategory.IHierarchical categories}.\n *\n * If you want, you can limit the result by configuring\n * {@link IShoppingChannel.IRequest.search search condition} in the request body.\n * Also, it is possible to customize sequence order of records by configuring\n * {@link IShoppingChannel.IRequest.sort sort condition}.\n *\n * @param props.body Request info of pagination, searching and sorting\n * @path /shoppings/customers/systematic/channels/hierarchical\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patch(\n  connection: IConnection,\n  props: patch.Props,\n): Promise<patch.Response> {\n  return !!connection.simulate\n    ? patch.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patch.METADATA,\n          path: patch.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace patch {\n  export type Props = {\n    /** Request info of pagination, searching and sorting */\n    body: IShoppingChannel.IRequest;\n  };\n  export type Body = IShoppingChannel.IRequest;\n  export type Response = IPageIShoppingChannel.IHierarchical;\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/shoppings/customers/systematic/channels/hierarchical\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () =>\n    \"/shoppings/customers/systematic/channels/hierarchical\";\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IPageIShoppingChannel.IHierarchical =>\n    typia.random<IPageIShoppingChannel.IHierarchical>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: patch.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patch.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/customers/systematic/channels/get/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingChannel } from \"../../../../../../structures/IShoppingChannel\";\n\n/**\n * Get a channel info by its code.\n *\n * Get a detailed {@link IShoppingChannel.IHierarchical channel} information by\n * its code.\n *\n * Returned channel instance also contains the nested\n * {@link IShoppingChannelCategory.IHierarchical hierarchical category}\n * information.\n *\n * @param props.code Target channel's {@link IShoppingChannel.code }\n * @path /shoppings/customers/systematic/channels/:code/get\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getByCode(\n  connection: IConnection,\n  props: getByCode.Props,\n): Promise<getByCode.Response> {\n  return !!connection.simulate\n    ? getByCode.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getByCode.METADATA,\n          path: getByCode.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace getByCode {\n  export type Props = {\n    /** Target channel's {@link IShoppingChannel.code } */\n    code: string;\n  };\n  export type Response = IShoppingChannel.IHierarchical;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/shoppings/customers/systematic/channels/:code/get\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/shoppings/customers/systematic/channels/${encodeURIComponent(props.code ?? \"null\")}/get`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingChannel.IHierarchical =>\n    typia.random<IShoppingChannel.IHierarchical>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: getByCode.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getByCode.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"code\")(() => typia.assert(props.code));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/customers/systematic/sections/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingSection } from \"../../../../../structures/IShoppingSection\";\nimport { IPageIShoppingSection } from \"../../../../../structures/IPageIShoppingSection\";\nexport * as get from \"./get\";\n\n/**\n * List up every sections.\n *\n * List up every {@link IShoppingSection sections} with pagination.\n *\n * If you want, you can limit the result by configuring\n * {@link IShoppingSection.IRequest.search search condition} in the request body.\n * Also, it is possible to customize sequence order of records by configuring\n * {@link IShoppingSection.IRequest.sort sort condition}.\n *\n * @param props.body Request info of pagination, searching and sorting\n * @path /shoppings/customers/systematic/sections\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patch(\n  connection: IConnection,\n  props: patch.Props,\n): Promise<patch.Response> {\n  return !!connection.simulate\n    ? patch.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patch.METADATA,\n          path: patch.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace patch {\n  export type Props = {\n    /** Request info of pagination, searching and sorting */\n    body: IShoppingSection.IRequest;\n  };\n  export type Body = IShoppingSection.IRequest;\n  export type Response = IPageIShoppingSection;\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/shoppings/customers/systematic/sections\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/shoppings/customers/systematic/sections\";\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IPageIShoppingSection => typia.random<IPageIShoppingSection>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: patch.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patch.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Get a section info.\n *\n * Get a detailed {@link IShoppingSection section} information.\n *\n * @param props.id Target section's {@link IShoppingSection.id }\n * @path /shoppings/customers/systematic/sections/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getById(\n  connection: IConnection,\n  props: getById.Props,\n): Promise<getById.Response> {\n  return !!connection.simulate\n    ? getById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getById.METADATA,\n          path: getById.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace getById {\n  export type Props = {\n    /** Target section's {@link IShoppingSection.id } */\n    id: string & tags.Format<\"uuid\">;\n  };\n  export type Response = IShoppingSection;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/shoppings/customers/systematic/sections/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/shoppings/customers/systematic/sections/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingSection => typia.random<IShoppingSection>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: getById.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/customers/systematic/sections/get/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingSection } from \"../../../../../../structures/IShoppingSection\";\n\n/**\n * Get a section info by its code.\n *\n * Get a detailed {@link IShoppingSection section} information by its code.\n *\n * @param props.code Target section's {@link IShoppingSection.code }\n * @path /shoppings/customers/systematic/sections/:code/get\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getByCode(\n  connection: IConnection,\n  props: getByCode.Props,\n): Promise<getByCode.Response> {\n  return !!connection.simulate\n    ? getByCode.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getByCode.METADATA,\n          path: getByCode.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace getByCode {\n  export type Props = {\n    /** Target section's {@link IShoppingSection.code } */\n    code: string;\n  };\n  export type Response = IShoppingSection;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/shoppings/customers/systematic/sections/:code/get\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/shoppings/customers/systematic/sections/${encodeURIComponent(props.code ?? \"null\")}/get`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingSection => typia.random<IShoppingSection>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: getByCode.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getByCode.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"code\")(() => typia.assert(props.code));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/sellers/authenticate/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingSeller } from \"../../../../structures/IShoppingSeller\";\nexport * as login from \"./login\";\n\n/**\n * Get seller information.\n *\n * Get {@link IShoppingSeller.IInvert seller} information of current\n * {@link IShoppingCustomer customer}.\n *\n * If current {@link IShoppingMember member} is not an seller, it throws 403\n * forbidden exception.\n *\n * @path /shoppings/sellers/authenticate\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function get(connection: IConnection): Promise<get.Response> {\n  return !!connection.simulate\n    ? get.simulate(connection)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...get.METADATA,\n          path: get.path(),\n          status: null,\n        },\n      );\n}\nexport namespace get {\n  export type Response = IShoppingSeller.IInvert;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/shoppings/sellers/authenticate\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/shoppings/sellers/authenticate\";\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingSeller.IInvert => typia.random<IShoppingSeller.IInvert>(g);\n  export const simulate = (connection: IConnection): Response => {\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Join as an seller.\n *\n * Join as an seller with {@link IShoppingSeller.IJoin joining info}.\n *\n * This method is allowed only when the {@link IShoppingCustomer customer}\n * already has joined the {@link IShoppingMember membership}. IF not, he (she)\n * must accomplish it before. If not, 403 forbidden exception would be thrown.\n *\n * @param props.body Joining request info\n * @path /shoppings/sellers/authenticate\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function post(\n  connection: IConnection,\n  props: post.Props,\n): Promise<post.Response> {\n  return !!connection.simulate\n    ? post.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...post.METADATA,\n          path: post.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace post {\n  export type Props = {\n    /** Joining request info */\n    body: IShoppingSeller.IJoin;\n  };\n  export type Body = IShoppingSeller.IJoin;\n  export type Response = IShoppingSeller.IInvert;\n\n  export const METADATA = {\n    method: \"POST\",\n    path: \"/shoppings/sellers/authenticate\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/shoppings/sellers/authenticate\";\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingSeller.IInvert => typia.random<IShoppingSeller.IInvert>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: post.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: post.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/sellers/index.ts": "export * as authenticate from \"./authenticate\";\nexport * as deliveries from \"./deliveries\";\nexport * as coupons from \"./coupons\";\nexport * as orders from \"./orders\";\nexport * as sales from \"./sales\";\nexport * as systematic from \"./systematic\";\n",
  "src/api/functional/shoppings/sellers/authenticate/login/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingMember } from \"../../../../../structures/IShoppingMember\";\nimport { IShoppingSeller } from \"../../../../../structures/IShoppingSeller\";\n\n/**\n * Login as an seller.\n *\n * Login as an seller with {@link IShoppingSeller.ILogin login info}.\n *\n * This method has exactly same effect with\n * {@link ShoppingApi.functional.customers.authenticate.login} function, but\n * returned type is a llttle different. The similar function returns\n * {@link IShoppingCustomer} type that starting from the customer information, so\n * that you have to access to the seller info through `customer.member.seller`.\n * In contrast with that, this method returns {@link IShoppingSeller.IInvert}\n * type that starting from the seller info, so that can access to the customer\n * info through `seller.customer`.\n *\n * Of course, to use this function, you had to {@link join} as an seller before.\n * If not, 403 forbidden exception would be thrown,\n *\n * @param props.body Login request info\n * @path /shoppings/sellers/authenticate/login\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function put(\n  connection: IConnection,\n  props: put.Props,\n): Promise<put.Response> {\n  return !!connection.simulate\n    ? put.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...put.METADATA,\n          path: put.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace put {\n  export type Props = {\n    /** Login request info */\n    body: IShoppingMember.ILogin;\n  };\n  export type Body = IShoppingMember.ILogin;\n  export type Response = IShoppingSeller.IInvert;\n\n  export const METADATA = {\n    method: \"PUT\",\n    path: \"/shoppings/sellers/authenticate/login\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/shoppings/sellers/authenticate/login\";\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingSeller.IInvert => typia.random<IShoppingSeller.IInvert>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: put.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: put.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/sellers/deliveries/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingDelivery } from \"../../../../structures/IShoppingDelivery\";\nimport { IPageIShoppingDelivery } from \"../../../../structures/IPageIShoppingDelivery\";\nexport * as incompletes from \"./incompletes\";\nexport * as journeys from \"./journeys\";\nexport * as shippers from \"./shippers\";\n\n/**\n * Create a delivery.\n *\n * Create a {@link IShoppingDelivery delivery} record targeting\n * {@link IShoppingOrder orders}, their {@link IShoppingOrderGood goods} and\n * {@link IShoppingSaleUnitStock stocks} ({@link IShoppingDeliveryPiece}) with\n * {@link IShoppingDeliveryJourney journeys} and\n * {@link IShoppingDeliveryShipper shippers} info.\n *\n * Note that, composition of the {@link IShoppingDeliveryPiece} must not over the\n * required. To identify which pieces are required, recommend to call the\n * {@link incompletes} function with target orders'\n * {@link IShoppingOrderPublish.id}s before calling this one.\n *\n * @param props.body Creation info of delivery\n * @path /shoppings/sellers/deliveries\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function post(\n  connection: IConnection,\n  props: post.Props,\n): Promise<post.Response> {\n  return !!connection.simulate\n    ? post.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...post.METADATA,\n          path: post.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace post {\n  export type Props = {\n    /** Creation info of delivery */\n    body: IShoppingDelivery.ICreate;\n  };\n  export type Body = IShoppingDelivery.ICreate;\n  export type Response = IShoppingDelivery;\n\n  export const METADATA = {\n    method: \"POST\",\n    path: \"/shoppings/sellers/deliveries\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/shoppings/sellers/deliveries\";\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingDelivery => typia.random<IShoppingDelivery>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: post.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: post.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Get list of deliveries.\n *\n * Get list of {@link IShoppingDelivery.IInvert deliveries} of current\n * {@link IShoppingSeller seller} with {@link IPage pagination}.\n *\n * For reference, returned deliveries are containing the target\n * {@link IShoppingOrder.IInvertFromDelivery order} information. Of course, only\n * related {@link IShoppingOrderGood goods} are contained in the orders.\n *\n * Additionally, you can limit the result by configuring\n * {@link IShoppingDelivery.IRequest.search search condition} in the request\n * body. Also, it is possible to customize sequence order of records by\n * configuring {@link IShoppingDelivery.IRequest.sort sort condition}.\n *\n * @param props.body Request info of pagination, searching and sorting\n * @path /shoppings/sellers/deliveries\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patch(\n  connection: IConnection,\n  props: patch.Props,\n): Promise<patch.Response> {\n  return !!connection.simulate\n    ? patch.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patch.METADATA,\n          path: patch.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace patch {\n  export type Props = {\n    /** Request info of pagination, searching and sorting */\n    body: IShoppingDelivery.IRequest;\n  };\n  export type Body = IShoppingDelivery.IRequest;\n  export type Response = IPageIShoppingDelivery.IInvert;\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/shoppings/sellers/deliveries\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/shoppings/sellers/deliveries\";\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IPageIShoppingDelivery.IInvert =>\n    typia.random<IPageIShoppingDelivery.IInvert>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: patch.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patch.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Get a delivery.\n *\n * Get a {@link IShoppingDelivery.IInvert delivery} information with its ID.\n *\n * For reference, returned delivery is containing the target\n * {@link IShoppingOrder.IInvertFromDelivery order} information. Of course, only\n * related {@link IShoppingOrderGood goods} are contained in the orders.\n *\n * @param props.id Target delivery's {@link IShoppingDelivery.id }\n * @path /shoppings/sellers/deliveries/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getById(\n  connection: IConnection,\n  props: getById.Props,\n): Promise<getById.Response> {\n  return !!connection.simulate\n    ? getById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getById.METADATA,\n          path: getById.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace getById {\n  export type Props = {\n    /** Target delivery's {@link IShoppingDelivery.id } */\n    id: string & tags.Format<\"uuid\">;\n  };\n  export type Response = IShoppingDelivery.IInvert;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/shoppings/sellers/deliveries/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/shoppings/sellers/deliveries/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingDelivery.IInvert => typia.random<IShoppingDelivery.IInvert>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: getById.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/sellers/deliveries/incompletes/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingDeliveryPiece } from \"../../../../../structures/IShoppingDeliveryPiece\";\n\n/**\n * Get list of incomplete pieces.\n *\n * Get list of {@link IShoppingDeliveryPiece incomplete pieces} of target orders'\n * {@link IShoppingOrderPublish.id}s.\n *\n * If you specify target orders' publish IDs, then this function returns\n * incompleted pieces of the orders with computation as an Array of\n * {@link IShoppingDeliveryPiece.ICreate} type.\n *\n * You can utillize the result to make a huge {@link IShoppingDelivery delivery}\n * for integrated delivering, and also possible to make multiple deliveries for\n * split delivering.\n *\n * @param props.body List of target orders'\n * @path /shoppings/sellers/deliveries/incompletes\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patch(\n  connection: IConnection,\n  props: patch.Props,\n): Promise<void> {\n  return !!connection.simulate\n    ? patch.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patch.METADATA,\n          path: patch.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace patch {\n  export type Props = {\n    /** List of target orders' */\n    body: IShoppingDeliveryPiece.IRequest;\n  };\n  export type Body = IShoppingDeliveryPiece.IRequest;\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/shoppings/sellers/deliveries/incompletes\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/shoppings/sellers/deliveries/incompletes\";\n  export const random = (g?: Partial<typia.IRandomGenerator>): void =>\n    typia.random<void>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: patch.Props,\n  ): void => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patch.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/sellers/deliveries/journeys/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingDeliveryJourney } from \"../../../../../structures/IShoppingDeliveryJourney\";\nexport * as complete from \"./complete\";\n\n/**\n * Create a new journey.\n *\n * Create a new {@link IShoppingDeliveryJourney journey} of the\n * {@link IShoppingDelivery delivery}.\n *\n * This action may change the related {@link IShoppingOrderGood.state}. Also, if\n * the target journey's type is \"delivering\", whether the property\n * {@link IShoppingDeliveryJourney.completed_at} is null or not affects to the\n * related goods' states. If the property is not null, the state becomes\n * \"arrived\". Otherwise, the state becomes \"delivering\".\n *\n * @param props.deliveryId Belonged delivery's {@link IShoppingDelivery.id }\n * @param props.body Creation info of the journey\n * @path /shoppings/sellers/deliveries/:deliveryId/journeys\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function postByDeliveryid(\n  connection: IConnection,\n  props: postByDeliveryid.Props,\n): Promise<postByDeliveryid.Response> {\n  return !!connection.simulate\n    ? postByDeliveryid.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...postByDeliveryid.METADATA,\n          path: postByDeliveryid.path(props),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace postByDeliveryid {\n  export type Props = {\n    /** Belonged delivery's {@link IShoppingDelivery.id } */\n    deliveryId: string & tags.Format<\"uuid\">;\n\n    /** Creation info of the journey */\n    body: IShoppingDeliveryJourney.ICreate;\n  };\n  export type Body = IShoppingDeliveryJourney.ICreate;\n  export type Response = IShoppingDeliveryJourney;\n\n  export const METADATA = {\n    method: \"POST\",\n    path: \"/shoppings/sellers/deliveries/:deliveryId/journeys\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Omit<Props, \"body\">) =>\n    `/shoppings/sellers/deliveries/${encodeURIComponent(props.deliveryId ?? \"null\")}/journeys`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingDeliveryJourney => typia.random<IShoppingDeliveryJourney>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: postByDeliveryid.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: postByDeliveryid.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"deliveryId\")(() => typia.assert(props.deliveryId));\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Erase a journey.\n *\n * Erase a {@link IShoppingDeliveryJourney journey} of the\n * {@link IShoppingDelivery delivery}.\n *\n * If erasing journey is the last one of the belonged delivery, this action may\n * change the related {@link IShoppingOrderGood.state}. By erasing the last\n * journey, the state rolls back to the previous.\n *\n * @param props.deliveryId Belonged delivery's {@link IShoppingDelivery.id }\n * @param props.id Target journey's {@link IShoppingDeliveryJourney.id }\n * @path /shoppings/sellers/deliveries/:deliveryId/journeys/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function eraseByDeliveryidAndId(\n  connection: IConnection,\n  props: eraseByDeliveryidAndId.Props,\n): Promise<void> {\n  return !!connection.simulate\n    ? eraseByDeliveryidAndId.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...eraseByDeliveryidAndId.METADATA,\n          path: eraseByDeliveryidAndId.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace eraseByDeliveryidAndId {\n  export type Props = {\n    /** Belonged delivery's {@link IShoppingDelivery.id } */\n    deliveryId: string & tags.Format<\"uuid\">;\n\n    /** Target journey's {@link IShoppingDeliveryJourney.id } */\n    id: string & tags.Format<\"uuid\">;\n  };\n\n  export const METADATA = {\n    method: \"DELETE\",\n    path: \"/shoppings/sellers/deliveries/:deliveryId/journeys/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/shoppings/sellers/deliveries/${encodeURIComponent(props.deliveryId ?? \"null\")}/journeys/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): void =>\n    typia.random<void>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: eraseByDeliveryidAndId.Props,\n  ): void => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: eraseByDeliveryidAndId.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"deliveryId\")(() => typia.assert(props.deliveryId));\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/sellers/deliveries/journeys/complete/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingDeliveryJourney } from \"../../../../../../structures/IShoppingDeliveryJourney\";\n\n/**\n * Complete a journey.\n *\n * Complete a {@link IShoppingDeliveryJourney journey} of the\n * {@link IShoppingDelivery delivery}. In other words, fills the\n * {@link IShoppingDeliveryJourney.completed_at} property with current time.\n *\n * If the target journey's type is \"delivering\", this action may change the\n * related {@link IShoppingOrderGood.state goods' states} to be \"arrived\".\n *\n * @param props.deliveryId Belonged delivery's {@link IShoppingDelivery.id }\n * @param props.id Target journey's {@link IShoppingDeliveryJourney.id }\n * @param props.body Completion time of the journey\n * @path /shoppings/sellers/deliveries/:deliveryId/journeys/:id/complete\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function putByDeliveryidAndId(\n  connection: IConnection,\n  props: putByDeliveryidAndId.Props,\n): Promise<void> {\n  return !!connection.simulate\n    ? putByDeliveryidAndId.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...putByDeliveryidAndId.METADATA,\n          path: putByDeliveryidAndId.path(props),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace putByDeliveryidAndId {\n  export type Props = {\n    /** Belonged delivery's {@link IShoppingDelivery.id } */\n    deliveryId: string & tags.Format<\"uuid\">;\n\n    /** Target journey's {@link IShoppingDeliveryJourney.id } */\n    id: string & tags.Format<\"uuid\">;\n\n    /** Completion time of the journey */\n    body: IShoppingDeliveryJourney.IComplete;\n  };\n  export type Body = IShoppingDeliveryJourney.IComplete;\n\n  export const METADATA = {\n    method: \"PUT\",\n    path: \"/shoppings/sellers/deliveries/:deliveryId/journeys/:id/complete\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Omit<Props, \"body\">) =>\n    `/shoppings/sellers/deliveries/${encodeURIComponent(props.deliveryId ?? \"null\")}/journeys/${encodeURIComponent(props.id ?? \"null\")}/complete`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): void =>\n    typia.random<void>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: putByDeliveryidAndId.Props,\n  ): void => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: putByDeliveryidAndId.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"deliveryId\")(() => typia.assert(props.deliveryId));\n      assert.param(\"id\")(() => typia.assert(props.id));\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/sellers/deliveries/shippers/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingDeliveryShipper } from \"../../../../../structures/IShoppingDeliveryShipper\";\n\n/**\n * Create a new shipper.\n *\n * Create a new {@link IShoppingDeliveryShipper shipper} of the\n * {@link IShoppingDelivery delivery}.\n *\n * This action does not affect to the related {@link IShoppingOrder orders} or\n * {@link IShoppingOrderGood goods} like {@link IShoppingDeliveryJourney} or\n * {@link IShoppingDeliveryPiece} case, but just informs to the\n * {@link IShoppingCustomer customer}.\n *\n * @param props.deliveryId Belonged delivery's {@link IShoppingDelivery.id }\n * @param props.body Creation info of the shipper\n * @path /shoppings/sellers/deliveries/:deliveryId/shippers\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function postByDeliveryid(\n  connection: IConnection,\n  props: postByDeliveryid.Props,\n): Promise<postByDeliveryid.Response> {\n  return !!connection.simulate\n    ? postByDeliveryid.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...postByDeliveryid.METADATA,\n          path: postByDeliveryid.path(props),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace postByDeliveryid {\n  export type Props = {\n    /** Belonged delivery's {@link IShoppingDelivery.id } */\n    deliveryId: string & tags.Format<\"uuid\">;\n\n    /** Creation info of the shipper */\n    body: IShoppingDeliveryShipper.ICreate;\n  };\n  export type Body = IShoppingDeliveryShipper.ICreate;\n  export type Response = IShoppingDeliveryShipper;\n\n  export const METADATA = {\n    method: \"POST\",\n    path: \"/shoppings/sellers/deliveries/:deliveryId/shippers\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Omit<Props, \"body\">) =>\n    `/shoppings/sellers/deliveries/${encodeURIComponent(props.deliveryId ?? \"null\")}/shippers`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingDeliveryShipper => typia.random<IShoppingDeliveryShipper>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: postByDeliveryid.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: postByDeliveryid.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"deliveryId\")(() => typia.assert(props.deliveryId));\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/sellers/coupons/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingCoupon } from \"../../../../structures/IShoppingCoupon\";\nimport { IPageIShoppingCoupon } from \"../../../../structures/IPageIShoppingCoupon\";\n\n/**\n * Create a new coupon.\n *\n * Create a new {@link IShoppingCoupon coupon} with given information.\n *\n * By the way, if you are a {@link IShoppingSeller seller}, you have to add\n * include direction's {@link IShoppingCouponSellerCriteria} or\n * {@link IShoppingCouponSaleCriteria} condition. This is because only\n * {@link IShoppingAdministrator administrators} can create a coupon which can be\n * used throughout the market. Seller must limit the usage range by his/her\n * {@link IShoppingSale sale(s)}.\n *\n * Of course, when administrator is planning to make a general coupon that can\n * be used throughout the market, the administrator must get agree from the\n * sellers who are going to be affected.\n *\n * @param props.body Creation info of the coupon\n * @path /shoppings/sellers/coupons\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function post(\n  connection: IConnection,\n  props: post.Props,\n): Promise<post.Response> {\n  return !!connection.simulate\n    ? post.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...post.METADATA,\n          path: post.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace post {\n  export type Props = {\n    /** Creation info of the coupon */\n    body: IShoppingCoupon.ICreate;\n  };\n  export type Body = IShoppingCoupon.ICreate;\n  export type Response = IShoppingCoupon;\n\n  export const METADATA = {\n    method: \"POST\",\n    path: \"/shoppings/sellers/coupons\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/shoppings/sellers/coupons\";\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingCoupon => typia.random<IShoppingCoupon>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: post.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: post.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * List up every coupons.\n *\n * List up every {@link IShoppingCoupon coupons} with pagination.\n *\n * If you want, you can limit the result by configuring\n * {@link IShoppingCoupon.IRequest.search search condition} in the request body.\n * Also, it is possible to customize sequence order of records by configuring\n * {@link IShoppingCoupon.IRequest.sort sort condition}.\n *\n * For reference, if you are a {@link IShoppingCustomer customer}, then only\n * {@link IShoppingCouponTicket ticketable} coupons would be listed up.\n * Otherwise, non-ticketable coupons would also be listed up.\n *\n * @param props.body Request info of pagination, searching and sorting\n * @path /shoppings/sellers/coupons\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patch(\n  connection: IConnection,\n  props: patch.Props,\n): Promise<patch.Response> {\n  return !!connection.simulate\n    ? patch.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patch.METADATA,\n          path: patch.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace patch {\n  export type Props = {\n    /** Request info of pagination, searching and sorting */\n    body: IShoppingCoupon.IRequest;\n  };\n  export type Body = IShoppingCoupon.IRequest;\n  export type Response = IPageIShoppingCoupon;\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/shoppings/sellers/coupons\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/shoppings/sellers/coupons\";\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IPageIShoppingCoupon => typia.random<IPageIShoppingCoupon>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: patch.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patch.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Get a coupon info.\n *\n * Get a {@link IShoppingCoupon coupon} information.\n *\n * If you are a {@link IShoppingCustomer customer}, then only\n * {@link IShoppingCouponTicket ticketable} coupons are accessible. Non\n * ticketable coupons cause 410 gone error. Otherwise you are a\n * {@link IShoppingSeller seller} or {@link IShoppingAdministrator administrator},\n * non-ticketable coupons are also accessible.\n *\n * @param props.id Target coupon's {@link IShoppingCoupon.id }\n * @path /shoppings/sellers/coupons/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getById(\n  connection: IConnection,\n  props: getById.Props,\n): Promise<getById.Response> {\n  return !!connection.simulate\n    ? getById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getById.METADATA,\n          path: getById.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace getById {\n  export type Props = {\n    /** Target coupon's {@link IShoppingCoupon.id } */\n    id: string;\n  };\n  export type Response = IShoppingCoupon;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/shoppings/sellers/coupons/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/shoppings/sellers/coupons/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingCoupon => typia.random<IShoppingCoupon>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: getById.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Erase a coupon.\n *\n * Erase a {@link IShoppingCoupon coupon} with given ID.\n *\n * For reference, if there're some {@link IShoppingCouponTicket tickets} which\n * are already issued from the target coupon, they would not be affected. Those\n * tickets are still valid until their expration time.\n *\n * @param props.id Target coupon's {@link IShoppingCoupon.id }\n * @path /shoppings/sellers/coupons/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function eraseById(\n  connection: IConnection,\n  props: eraseById.Props,\n): Promise<void> {\n  return !!connection.simulate\n    ? eraseById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...eraseById.METADATA,\n          path: eraseById.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace eraseById {\n  export type Props = {\n    /** Target coupon's {@link IShoppingCoupon.id } */\n    id: string;\n  };\n\n  export const METADATA = {\n    method: \"DELETE\",\n    path: \"/shoppings/sellers/coupons/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/shoppings/sellers/coupons/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): void =>\n    typia.random<void>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: eraseById.Props,\n  ): void => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: eraseById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/sellers/orders/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingOrder } from \"../../../../structures/IShoppingOrder\";\nimport { IPageIShoppingOrder } from \"../../../../structures/IPageIShoppingOrder\";\n\n/**\n * List up every orders.\n *\n * List up every {@link IShoppingOrder orders} with pagination.\n *\n * If you want, you can limit the result by configuring\n * {@link IShoppingOrder.IRequest.search search condition} in the request body.\n * Also, it is possible to customize sequence order of records by configuring\n * {@link IShoppingOrder.IRequest.sort sort condition}.\n *\n * For reference, if you are a {@link IShoppingCustomer customer}, then you can\n * list up your own orders, and it is not a matter whether the order has been\n * {@link IShoppingOrderPublish.paid_at paid} or not.\n *\n * Otherwise you are a {@link IShoppingSeller seller} or\n * {@link IShoppingAdministrator administrator}, then you can list up only paid\n * orders. Also, in the seller case, only related\n * {@link IShoppingOrder.goods goods} would be listed up in the order.\n *\n * @param props.body Request info of pagination, searching and sorting\n * @path /shoppings/sellers/orders\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patch(\n  connection: IConnection,\n  props: patch.Props,\n): Promise<patch.Response> {\n  return !!connection.simulate\n    ? patch.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patch.METADATA,\n          path: patch.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace patch {\n  export type Props = {\n    /** Request info of pagination, searching and sorting */\n    body: IShoppingOrder.IRequest;\n  };\n  export type Body = IShoppingOrder.IRequest;\n  export type Response = IPageIShoppingOrder;\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/shoppings/sellers/orders\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/shoppings/sellers/orders\";\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IPageIShoppingOrder => typia.random<IPageIShoppingOrder>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: patch.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patch.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Get an order info.\n *\n * Get a detailed {@link IShoppingOrder order} information.\n *\n * If you are not a {@link IShoppingCustomer customer}, then you can't access to\n * the order which has not been {@link IShoppingOrderPublish.paid_at paid} yet.\n * In that case, 404 not found error would be thrown.\n *\n * @param props.id Target order's {@link IShoppingOrder.id }\n * @path /shoppings/sellers/orders/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getById(\n  connection: IConnection,\n  props: getById.Props,\n): Promise<getById.Response> {\n  return !!connection.simulate\n    ? getById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getById.METADATA,\n          path: getById.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace getById {\n  export type Props = {\n    /** Target order's {@link IShoppingOrder.id } */\n    id: string & tags.Format<\"uuid\">;\n  };\n  export type Response = IShoppingOrder;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/shoppings/sellers/orders/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/shoppings/sellers/orders/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): IShoppingOrder =>\n    typia.random<IShoppingOrder>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: getById.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/sellers/sales/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingSale } from \"../../../../structures/IShoppingSale\";\nimport { IPageIShoppingSale } from \"../../../../structures/IPageIShoppingSale\";\nimport { IShoppingSaleSnapshot } from \"../../../../structures/IShoppingSaleSnapshot\";\nexport * as open from \"./open\";\nexport * as replica from \"./replica\";\nexport * as pause from \"./pause\";\nexport * as suspend from \"./suspend\";\nexport * as restore from \"./restore\";\nexport * as details from \"./details\";\nexport * as questions from \"./questions\";\nexport * as reviews from \"./reviews\";\nexport * as snapshots from \"./snapshots\";\nexport * as units from \"./units\";\n\n/**\n * Create a sale.\n *\n * {@link IShoppingSeller Seller} creates a new {@link IShoppingSale} for\n * operation.\n *\n * For reference, sale has complicate hierarchical structure that composing with\n * {@link IShoppingSaleUnit units}, {@link IShoppingSaleUnitOption options} and\n * {@link IShoppingSaleUnitStock stocks}. Therefore, I recommend you to read the\n * {@link IShoppingSale} and related DTOs' documents before creating a new sale.\n *\n * ERD (Entity Relationship Diagram) and its description document also would be\n * helpful, too.\n *\n * @param props.body Creation info of the sale\n * @path /shoppings/sellers/sales\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function post(\n  connection: IConnection,\n  props: post.Props,\n): Promise<post.Response> {\n  return !!connection.simulate\n    ? post.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...post.METADATA,\n          path: post.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace post {\n  export type Props = {\n    /** Creation info of the sale */\n    body: IShoppingSale.ICreate;\n  };\n  export type Body = IShoppingSale.ICreate;\n  export type Response = IShoppingSale;\n\n  export const METADATA = {\n    method: \"POST\",\n    path: \"/shoppings/sellers/sales\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/shoppings/sellers/sales\";\n  export const random = (g?: Partial<typia.IRandomGenerator>): IShoppingSale =>\n    typia.random<IShoppingSale>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: post.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: post.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * List up every summarized sales.\n *\n * List up every {@link IShoppingSale.ISummary summarized sales}.\n *\n * As you can see, returned sales are summarized, not detailed. It does not\n * contain the SKU (Stock Keeping Unit) information represented by the\n * {@link IShoppingSaleUnitOption} and {@link IShoppingSaleUnitStock} types. If\n * you want to get such detailed information of a sale, use `GET\n * /shoppings/customers/sales/{id}` operation for each sale.\n *\n * > If you're an A.I. chatbot, and the user wants to buy or compose\n * > {@link IShoppingCartCommodity shopping cart} from a sale, please call the `GET\n * > /shoppings/customers/sales/{id}` operation at least once to the target sale\n * > to get detailed SKU information about the sale. It needs to be run at least\n * > once for the next steps.\n *\n * @param props.body Request info of pagination, searching and sorting\n * @path /shoppings/sellers/sales\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patch(\n  connection: IConnection,\n  props: patch.Props,\n): Promise<patch.Response> {\n  return !!connection.simulate\n    ? patch.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patch.METADATA,\n          path: patch.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace patch {\n  export type Props = {\n    /** Request info of pagination, searching and sorting */\n    body: IShoppingSale.IRequest;\n  };\n  export type Body = IShoppingSale.IRequest;\n  export type Response = IPageIShoppingSale.ISummary;\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/shoppings/sellers/sales\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/shoppings/sellers/sales\";\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IPageIShoppingSale.ISummary =>\n    typia.random<IPageIShoppingSale.ISummary>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: patch.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patch.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Get a sale with detailed information.\n *\n * Get a {@link IShoppingSale sale} with detailed information including the SKU\n * (Stock Keeping Unit) information represented by the\n * {@link IShoppingSaleUnitOption} and {@link IShoppingSaleUnitStock} types.\n *\n * > If you're an A.I. chatbot, and the user wants to buy or compose a\n * > {@link IShoppingCartCommodity shopping cart} from a sale, please call this\n * > operation at least once to the target sale to get detailed SKU information\n * > about the sale.\n *\n * > It needs to be run at least once for the next steps. In other words, if you\n * > A.I. agent has called this operation to a specific sale, you don't need to\n * > call this operation again for the same sale.\n *\n * > Additionally, please do not summarize the SKU information. Just show the\n * > every options and stocks in the sale with detailed information.\n *\n * @param props.id Target sale's {@link IShoppingSale.id }\n * @path /shoppings/sellers/sales/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getById(\n  connection: IConnection,\n  props: getById.Props,\n): Promise<getById.Response> {\n  return !!connection.simulate\n    ? getById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getById.METADATA,\n          path: getById.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace getById {\n  export type Props = {\n    /** Target sale's {@link IShoppingSale.id } */\n    id: string & tags.Format<\"uuid\">;\n  };\n  export type Response = IShoppingSale;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/shoppings/sellers/sales/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/shoppings/sellers/sales/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): IShoppingSale =>\n    typia.random<IShoppingSale>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: getById.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Update a sale.\n *\n * Update a {@link IShoppingSale sale} with new information.\n *\n * By the way, the sale actually does not being modified, but just make a new\n * {@link IShoppingSaleSnapshot snapshot} record of the sale. Its 1st purpose is\n * to keeping the integrity of the sale, due to modification of the sale must\n * not affect to the {@link IShoppingOrder orders} that already had been applied\n * to the sale.\n *\n * The 2nd purpose is for the A/B tests. {@link IShoppingSeller Seller} needs to\n * demonstrate operating performance by changing price, content, and composition\n * of the product. This snapshot concept would be helpful for it.\n *\n * @param props.id Target sale's {@link IShoppingSale.id }\n * @param props.body New information of the sale\n * @path /shoppings/sellers/sales/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function putById(\n  connection: IConnection,\n  props: putById.Props,\n): Promise<putById.Response> {\n  return !!connection.simulate\n    ? putById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...putById.METADATA,\n          path: putById.path(props),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace putById {\n  export type Props = {\n    /** Target sale's {@link IShoppingSale.id } */\n    id: string & tags.Format<\"uuid\">;\n\n    /** New information of the sale */\n    body: IShoppingSaleSnapshot.ICreate;\n  };\n  export type Body = IShoppingSaleSnapshot.ICreate;\n  export type Response = IShoppingSale;\n\n  export const METADATA = {\n    method: \"PUT\",\n    path: \"/shoppings/sellers/sales/:id\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Omit<Props, \"body\">) =>\n    `/shoppings/sellers/sales/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): IShoppingSale =>\n    typia.random<IShoppingSale>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: putById.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: putById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/sellers/sales/open/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingSale } from \"../../../../../structures/IShoppingSale\";\n\n/**\n * Change opening and closing time of a sale.\n *\n * Update a {@link IShoppingSale sale}'s opening and closing time.\n *\n * By the way, if the sale still be opened or closed, it is not possible to\n * change the opening time. In contrary, if the sale already had been opened but\n * still not closed, it is possible to change the closing time.\n *\n * Of course, if closing time is less than opening time or not, 428\n * unprocessable entity error would be thrown.\n *\n * @param props.id Target sale's {@link IShoppingSale.id }\n * @param props.body New opening and closing time\n * @path /shoppings/sellers/sales/:id/open\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function putById(\n  connection: IConnection,\n  props: putById.Props,\n): Promise<void> {\n  return !!connection.simulate\n    ? putById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...putById.METADATA,\n          path: putById.path(props),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace putById {\n  export type Props = {\n    /** Target sale's {@link IShoppingSale.id } */\n    id: string & tags.Format<\"uuid\">;\n\n    /** New opening and closing time */\n    body: IShoppingSale.IUpdateOpeningTime;\n  };\n  export type Body = IShoppingSale.IUpdateOpeningTime;\n\n  export const METADATA = {\n    method: \"PUT\",\n    path: \"/shoppings/sellers/sales/:id/open\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Omit<Props, \"body\">) =>\n    `/shoppings/sellers/sales/${encodeURIComponent(props.id ?? \"null\")}/open`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): void =>\n    typia.random<void>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: putById.Props,\n  ): void => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: putById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/sellers/sales/replica/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingSale } from \"../../../../../structures/IShoppingSale\";\n\n/**\n * Get replica of a sale.\n *\n * Get a {@link IShoppingSale.ICreate} typed info of the target sale for\n * replication.\n *\n * It would be useful for creating a new replication {@link IShoppingSale sale}\n * with similar innformatiopn.\n *\n * @param props.id Target sale's {@link IShoppingSale.id }\n * @path /shoppings/sellers/sales/:id/replica\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function postById(\n  connection: IConnection,\n  props: postById.Props,\n): Promise<postById.Response> {\n  return !!connection.simulate\n    ? postById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...postById.METADATA,\n          path: postById.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace postById {\n  export type Props = {\n    /** Target sale's {@link IShoppingSale.id } */\n    id: string & tags.Format<\"uuid\">;\n  };\n  export type Response = IShoppingSale.ICreate;\n\n  export const METADATA = {\n    method: \"POST\",\n    path: \"/shoppings/sellers/sales/:id/replica\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/shoppings/sellers/sales/${encodeURIComponent(props.id ?? \"null\")}/replica`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingSale.ICreate => typia.random<IShoppingSale.ICreate>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: postById.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: postById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/sellers/sales/pause/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\n/**\n * Pause a sale.\n *\n * Pause a {@link IShoppingSale sale} from {@link open opened} state. Therefore,\n * the sale can not be operated again until it be {@link restore restored}. By\n * the way, {@link IShoppingCustomer customer} still can sale from the\n * {@link index} and {@link at} API endpoints, but \"paused\" label would be\n * attached.\n *\n * Also, customer no more can put into the shopping cart, either. Even the sale\n * already had been put into the shopping cart, the\n * {@link IShoppingCartCommodity commodity} will not be listed on the shopping\n * cart. Also, it is not possible to applying an {@link IShoppingOrder order}\n * with the paused sale's commodity, either.\n *\n * By the way, if the sale already had been applied to an order, the order can\n * be {@link IShoppingOrderPublish published} and {@link IShoppingSeller seller}\n * must {@link IShoppingDelivery deliver} the good to the customer.\n *\n * @param props.id Target sale's {@link IShoppingSale.id }\n * @path /shoppings/sellers/sales/:id/pause\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function eraseById(\n  connection: IConnection,\n  props: eraseById.Props,\n): Promise<void> {\n  return !!connection.simulate\n    ? eraseById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...eraseById.METADATA,\n          path: eraseById.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace eraseById {\n  export type Props = {\n    /** Target sale's {@link IShoppingSale.id } */\n    id: string & tags.Format<\"uuid\">;\n  };\n\n  export const METADATA = {\n    method: \"DELETE\",\n    path: \"/shoppings/sellers/sales/:id/pause\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/shoppings/sellers/sales/${encodeURIComponent(props.id ?? \"null\")}/pause`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): void =>\n    typia.random<void>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: eraseById.Props,\n  ): void => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: eraseById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/sellers/sales/suspend/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\n/**\n * Suspend a sale.\n *\n * Suspend a {@link IShoppingSale sale} from {@link open opened} state. Therefore,\n * the sale can not be operated again until it be {@link restore restored} and\n * {@link IShoppingCustomer customer} cannot see the sale from the {@link index}\n * and {@link at} API.\n *\n * Also, customer no more can put into the shopping cart, either. Even the sale\n * already had been put into the shopping cart, the\n * {@link IShoppingCartCommodity commodity} will not be listed on the shopping\n * cart. Also, it is not possible to applying an {@link IShoppingOrder order}\n * with the suspended sale's commodity, either.\n *\n * By the way, if the sale already had been applied to an order, the order can\n * be {@link IShoppingOrderPublish published} and {@link IShoppingSeller seller}\n * must {@link IShoppingDelivery deliver} the good to the customer.\n *\n * @param props.id Target sale's {@link IShoppingSale.id }\n * @path /shoppings/sellers/sales/:id/suspend\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function eraseById(\n  connection: IConnection,\n  props: eraseById.Props,\n): Promise<void> {\n  return !!connection.simulate\n    ? eraseById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...eraseById.METADATA,\n          path: eraseById.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace eraseById {\n  export type Props = {\n    /** Target sale's {@link IShoppingSale.id } */\n    id: string & tags.Format<\"uuid\">;\n  };\n\n  export const METADATA = {\n    method: \"DELETE\",\n    path: \"/shoppings/sellers/sales/:id/suspend\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/shoppings/sellers/sales/${encodeURIComponent(props.id ?? \"null\")}/suspend`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): void =>\n    typia.random<void>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: eraseById.Props,\n  ): void => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: eraseById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/sellers/sales/restore/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\n/**\n * Describe summary as much as possible with clear and concise words.\n *\n * Restore a sale\n *\n * Restore a {@link IShoppingSale sale} from {@link pause paused} or\n * {@link suspend suspended} state\n *\n * Therefore the sale can be operated again if its\n * {@link IShoppingSale.closed_at closing time} has not been reached. Also, if a\n * {@link IShoppingCustomer customer} had put the sale into the shopping cart\n * when being paused or suspended, the {@link IShoppingCartCommodity commodity}\n * will be listed again on the shopping cart.\n *\n * @param props.id Target sale's {@link IShoppingSale.id }\n * @path /shoppings/sellers/sales/:id/restore\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function putById(\n  connection: IConnection,\n  props: putById.Props,\n): Promise<void> {\n  return !!connection.simulate\n    ? putById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...putById.METADATA,\n          path: putById.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace putById {\n  export type Props = {\n    /** Target sale's {@link IShoppingSale.id } */\n    id: string & tags.Format<\"uuid\">;\n  };\n\n  export const METADATA = {\n    method: \"PUT\",\n    path: \"/shoppings/sellers/sales/:id/restore\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/shoppings/sellers/sales/${encodeURIComponent(props.id ?? \"null\")}/restore`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): void =>\n    typia.random<void>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: putById.Props,\n  ): void => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: putById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/sellers/sales/details/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingSale } from \"../../../../../structures/IShoppingSale\";\nimport { IPageIShoppingSale } from \"../../../../../structures/IPageIShoppingSale\";\n\n/**\n * List up every sales.\n *\n * List up every {@link IShoppingSale sales} with detailed information.\n *\n * As you can see, returned sales are detailed, not summarized. If you want to\n * get the summarized information of sale for a brief, use {@link index} function\n * instead.\n *\n * For reference, if you're a {@link IShoppingSeller seller}, you can only access\n * to the your own {@link IShoppingSale sale}s. Otherwise you're a\n * {@link IShoppingCustomer customer}, you can see only the operating sales in\n * the market. Instead, you can't see the unopened, closed, or suspended sales.\n *\n * > If you're an A.I. chatbot, please don't summarize the\n * > {@link IShoppingSaleUnitStock stock information}. Just list up the every\n * > stocks in the sale with detailed information.\n *\n * @param props.body Request info of pagination, searching and sorting\n * @path /shoppings/sellers/sales/details\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patch(\n  connection: IConnection,\n  props: patch.Props,\n): Promise<patch.Response> {\n  return !!connection.simulate\n    ? patch.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patch.METADATA,\n          path: patch.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace patch {\n  export type Props = {\n    /** Request info of pagination, searching and sorting */\n    body: IShoppingSale.IRequest;\n  };\n  export type Body = IShoppingSale.IRequest;\n  export type Response = IPageIShoppingSale;\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/shoppings/sellers/sales/details\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/shoppings/sellers/sales/details\";\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IPageIShoppingSale => typia.random<IPageIShoppingSale>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: patch.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patch.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/sellers/sales/questions/answer/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IBbsArticle } from \"../../../../../../structures/IBbsArticle\";\nimport { IShoppingSaleInquiryAnswer } from \"../../../../../../structures/IShoppingSaleInquiryAnswer\";\n\n/**\n * Write an answer article.\n *\n * Write a formal {@link IShoppingSaleInquiryAnswer answer article} to a specific\n * {@link IShoppingSaleInquiry question article} written by a\n * {@link IShoppingCustomer}.\n *\n * Note that, this is the formal answer that can be written only one per a\n * question article (but {@link update updatable}). Therefore, it needs to guide\n * the {@link IShoppingSeller seller} to write it carefully.\n *\n * Also, as seller can write {@link IShoppingSaleInquiryComment comments} to the\n * question article as many as he/she wants, it would be useful for additional\n * communication.\n *\n * @param props.saleId Belonged sale's {@link IShoppingSale.id }\n * @param props.questionId Target question's {@link IShoppingSaleQuestion.id }\n * @param props.body Creation info of the answer article\n * @path /shoppings/sellers/sales/:saleId/questions/:questionId/answer\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function postBySaleidAndQuestionid(\n  connection: IConnection,\n  props: postBySaleidAndQuestionid.Props,\n): Promise<postBySaleidAndQuestionid.Response> {\n  return !!connection.simulate\n    ? postBySaleidAndQuestionid.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...postBySaleidAndQuestionid.METADATA,\n          path: postBySaleidAndQuestionid.path(props),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace postBySaleidAndQuestionid {\n  export type Props = {\n    /** Belonged sale's {@link IShoppingSale.id } */\n    saleId: string & tags.Format<\"uuid\">;\n\n    /** Target question's {@link IShoppingSaleQuestion.id } */\n    questionId: string & tags.Format<\"uuid\">;\n\n    /** Creation info of the answer article */\n    body: IBbsArticle.ICreate;\n  };\n  export type Body = IBbsArticle.ICreate;\n  export type Response = IShoppingSaleInquiryAnswer;\n\n  export const METADATA = {\n    method: \"POST\",\n    path: \"/shoppings/sellers/sales/:saleId/questions/:questionId/answer\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Omit<Props, \"body\">) =>\n    `/shoppings/sellers/sales/${encodeURIComponent(props.saleId ?? \"null\")}/questions/${encodeURIComponent(props.questionId ?? \"null\")}/answer`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingSaleInquiryAnswer => typia.random<IShoppingSaleInquiryAnswer>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: postBySaleidAndQuestionid.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: postBySaleidAndQuestionid.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"saleId\")(() => typia.assert(props.saleId));\n      assert.param(\"questionId\")(() => typia.assert(props.questionId));\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Update an answer article.\n *\n * Update a formal {@link IShoppingSaleInquiryAnswer answer article} to a\n * specific {@link IShoppingSaleInquiry question article} written by a\n * {@link IShoppingCustomer}.\n *\n * By the way, as is the general policy of this shopping mall regarding\n * articles, modifying a question articles does not actually change the existing\n * content. Modified content is accumulated and recorded in the existing article\n * record as a new {@link IShoppingSaleInquiryAnswer.ISnapshot snapshot}. And\n * this is made public to everyone, including the\n * {@link IShoppingCustomer customer} and the {@link IShoppingSeller seller}, and\n * anyone who can view the article can also view the entire editing histories.\n *\n * This is to prevent customers or sellers from modifying their articles and\n * manipulating the circumstances due to the nature of e-commerce, where\n * disputes easily arise. That is, to preserve evidence.\n *\n * @param props.saleId Belonged sale's {@link IShoppingSale.id }\n * @param props.questionId Target question's {@link IShoppingSaleQuestion.id }\n * @param props.body Update info of the answer article\n * @path /shoppings/sellers/sales/:saleId/questions/:questionId/answer\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function putBySaleidAndQuestionid(\n  connection: IConnection,\n  props: putBySaleidAndQuestionid.Props,\n): Promise<putBySaleidAndQuestionid.Response> {\n  return !!connection.simulate\n    ? putBySaleidAndQuestionid.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...putBySaleidAndQuestionid.METADATA,\n          path: putBySaleidAndQuestionid.path(props),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace putBySaleidAndQuestionid {\n  export type Props = {\n    /** Belonged sale's {@link IShoppingSale.id } */\n    saleId: string & tags.Format<\"uuid\">;\n\n    /** Target question's {@link IShoppingSaleQuestion.id } */\n    questionId: string & tags.Format<\"uuid\">;\n\n    /** Update info of the answer article */\n    body: IBbsArticle.ICreate;\n  };\n  export type Body = IBbsArticle.ICreate;\n  export type Response = IShoppingSaleInquiryAnswer.ISnapshot;\n\n  export const METADATA = {\n    method: \"PUT\",\n    path: \"/shoppings/sellers/sales/:saleId/questions/:questionId/answer\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Omit<Props, \"body\">) =>\n    `/shoppings/sellers/sales/${encodeURIComponent(props.saleId ?? \"null\")}/questions/${encodeURIComponent(props.questionId ?? \"null\")}/answer`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingSaleInquiryAnswer.ISnapshot =>\n    typia.random<IShoppingSaleInquiryAnswer.ISnapshot>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: putBySaleidAndQuestionid.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: putBySaleidAndQuestionid.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"saleId\")(() => typia.assert(props.saleId));\n      assert.param(\"questionId\")(() => typia.assert(props.questionId));\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/sellers/sales/questions/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingSaleQuestion } from \"../../../../../structures/IShoppingSaleQuestion\";\nimport { IPageIShoppingSaleQuestion } from \"../../../../../structures/IPageIShoppingSaleQuestion\";\nexport * as answer from \"./answer\";\nexport * as comments from \"./comments\";\nexport * as abridges from \"./abridges\";\n\n/**\n * List up every summarized questions.\n *\n * List up every {@link IShoppingSaleQuestion.ISummary summarized questions} of a\n * {@link IShoppingSale sale}.\n *\n * As you can see, returned questions are summarized, not detailed. If you want\n * to get the detailed information of a question, use {@link adridges} function\n * or {@link at} function for each article.\n *\n * Also, returned question has {@link IShoppingSaleQuestion.ISummary.answer}\n * property which means the formal answer from the {@link IShoppingSeller}.\n * Additionally, returned question has another special property\n * {@link IShoppingSaleQuestion.ISummary.secret} with masking to other princple\n * properties, and it means only related actors can {@link at read} the\n * question.\n *\n * For reference, if you're a {@link IShoppingSeller seller}, you can only access\n * to the your own {@link IShoppingSale sale}'s questions. Otherwise, you can\n * access to every questions of the sales.\n *\n * By the way, if you want, you can limit the result by configuring\n * {@link IShoppingSaleQuestion.IRequest.search search condition} in the request\n * body. Also, it is possible to customize sequence order of records by\n * configuring {@link IShoppingSaleQuestion.IRequest.sort sort condition}.\n *\n * @param props.saleId Belonged sale's {@link IShoppingSale.id }\n * @param props.body Request info of pagination, searching and sorting\n * @path /shoppings/sellers/sales/:saleId/questions\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patchBySaleid(\n  connection: IConnection,\n  props: patchBySaleid.Props,\n): Promise<patchBySaleid.Response> {\n  return !!connection.simulate\n    ? patchBySaleid.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patchBySaleid.METADATA,\n          path: patchBySaleid.path(props),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace patchBySaleid {\n  export type Props = {\n    /** Belonged sale's {@link IShoppingSale.id } */\n    saleId: string & tags.Format<\"uuid\">;\n\n    /** Request info of pagination, searching and sorting */\n    body: IShoppingSaleQuestion.IRequest;\n  };\n  export type Body = IShoppingSaleQuestion.IRequest;\n  export type Response = IPageIShoppingSaleQuestion.ISummary;\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/shoppings/sellers/sales/:saleId/questions\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Omit<Props, \"body\">) =>\n    `/shoppings/sellers/sales/${encodeURIComponent(props.saleId ?? \"null\")}/questions`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IPageIShoppingSaleQuestion.ISummary =>\n    typia.random<IPageIShoppingSaleQuestion.ISummary>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: patchBySaleid.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patchBySaleid.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"saleId\")(() => typia.assert(props.saleId));\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Get a question info.\n *\n * Get a detailed {@link IShoppingSaleQuestion question} information of a\n * {@link IShoppingSale sale}.\n *\n * For reference, if you're a {@link IShoppingSeller seller}, you can only access\n * to the your own {@link IShoppingSale sale}'s question. Otherwise you are a\n * {@link IShoppingCustomer customer}, you can access to every questions of the\n * sales except the {@link IShoppingSaleQuestion.secret} value is `false`.\n *\n * @param props.saleId Belonged sale's {@link IShoppingSale.id }\n * @param props.id Target question's {@link IShoppingSaleQuestion.id }\n * @path /shoppings/sellers/sales/:saleId/questions/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getBySaleidAndId(\n  connection: IConnection,\n  props: getBySaleidAndId.Props,\n): Promise<getBySaleidAndId.Response> {\n  return !!connection.simulate\n    ? getBySaleidAndId.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getBySaleidAndId.METADATA,\n          path: getBySaleidAndId.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace getBySaleidAndId {\n  export type Props = {\n    /** Belonged sale's {@link IShoppingSale.id } */\n    saleId: string & tags.Format<\"uuid\">;\n\n    /** Target question's {@link IShoppingSaleQuestion.id } */\n    id: string & tags.Format<\"uuid\">;\n  };\n  export type Response = IShoppingSaleQuestion;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/shoppings/sellers/sales/:saleId/questions/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/shoppings/sellers/sales/${encodeURIComponent(props.saleId ?? \"null\")}/questions/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingSaleQuestion => typia.random<IShoppingSaleQuestion>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: getBySaleidAndId.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getBySaleidAndId.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"saleId\")(() => typia.assert(props.saleId));\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/sellers/sales/questions/comments/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingSaleInquiryComment } from \"../../../../../../structures/IShoppingSaleInquiryComment\";\nimport { IPageIShoppingSaleInquiryComment } from \"../../../../../../structures/IPageIShoppingSaleInquiryComment\";\n\n/**\n * Create an inquiry comment.\n *\n * Create an {@link IShoppingSaleInquiryComment inquiry comment} of a\n * {@link IShoppingSaleQuestion question} or {@link IShoppingSaleReview review}.\n *\n * For reference, if you're a {@link IShoppingSeller seller}, you can only create\n * an inquiry comment to your own {@link IShoppingSale sale}'s inquiry.\n * Otherwise, you can create an inquiry comment to every inquiries of the\n * sales.\n *\n * @param props.saleId Belonged sale's {@link IShoppingSale.id }\n * @param props.inquiryId Target inquiry's {@link IShoppingSaleInquiry.id }\n * @param props.body Creation info of the inquiry comment\n * @path /shoppings/sellers/sales/:saleId/questions/:inquiryId/comments\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function postBySaleidAndInquiryid(\n  connection: IConnection,\n  props: postBySaleidAndInquiryid.Props,\n): Promise<postBySaleidAndInquiryid.Response> {\n  return !!connection.simulate\n    ? postBySaleidAndInquiryid.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...postBySaleidAndInquiryid.METADATA,\n          path: postBySaleidAndInquiryid.path(props),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace postBySaleidAndInquiryid {\n  export type Props = {\n    /** Belonged sale's {@link IShoppingSale.id } */\n    saleId: string & tags.Format<\"uuid\">;\n\n    /** Target inquiry's {@link IShoppingSaleInquiry.id } */\n    inquiryId: string & tags.Format<\"uuid\">;\n\n    /** Creation info of the inquiry comment */\n    body: IShoppingSaleInquiryComment.ICreate;\n  };\n  export type Body = IShoppingSaleInquiryComment.ICreate;\n  export type Response = IShoppingSaleInquiryComment;\n\n  export const METADATA = {\n    method: \"POST\",\n    path: \"/shoppings/sellers/sales/:saleId/questions/:inquiryId/comments\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Omit<Props, \"body\">) =>\n    `/shoppings/sellers/sales/${encodeURIComponent(props.saleId ?? \"null\")}/questions/${encodeURIComponent(props.inquiryId ?? \"null\")}/comments`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingSaleInquiryComment =>\n    typia.random<IShoppingSaleInquiryComment>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: postBySaleidAndInquiryid.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: postBySaleidAndInquiryid.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"saleId\")(() => typia.assert(props.saleId));\n      assert.param(\"inquiryId\")(() => typia.assert(props.inquiryId));\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * List up every inquiry comments.\n *\n * List up every {@link IShoppingSaleInquiryComment inquiry comments} of a\n * {@link IShoppingSaleQuestion question} or {@link IShoppingSaleReview review}\n * with {@link IPage pagination}.\n *\n * If you want, you can limit the result by configuring\n * {@link IShoppingSaleInquiryComment.IRequest.search search condition} in the\n * request body. Also, it is possible to customize sequence order of records by\n * configuring {@link IShoppingSaleInquiryComment.IRequest.sort sort condition}.\n *\n * By the way, if you're a {@link IShoppingSeller seller}, you can only access to\n * the your own {@link IShoppingSale sale}'s inquiries. Otherwise, you can access\n * to every inquiries of the sales.\n *\n * @param props.saleId Belonged sale's {@link IShoppingSale.id }\n * @param props.inquiryId Belonged inquiry's {@link IShoppingSaleInquiry.id }\n * @param props.body Request info of pagination, searching and sorting\n * @path /shoppings/sellers/sales/:saleId/questions/:inquiryId/comments\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patchBySaleidAndInquiryid(\n  connection: IConnection,\n  props: patchBySaleidAndInquiryid.Props,\n): Promise<patchBySaleidAndInquiryid.Response> {\n  return !!connection.simulate\n    ? patchBySaleidAndInquiryid.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patchBySaleidAndInquiryid.METADATA,\n          path: patchBySaleidAndInquiryid.path(props),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace patchBySaleidAndInquiryid {\n  export type Props = {\n    /** Belonged sale's {@link IShoppingSale.id } */\n    saleId: string & tags.Format<\"uuid\">;\n\n    /** Belonged inquiry's {@link IShoppingSaleInquiry.id } */\n    inquiryId: string & tags.Format<\"uuid\">;\n\n    /** Request info of pagination, searching and sorting */\n    body: IShoppingSaleInquiryComment.IRequest;\n  };\n  export type Body = IShoppingSaleInquiryComment.IRequest;\n  export type Response = IPageIShoppingSaleInquiryComment;\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/shoppings/sellers/sales/:saleId/questions/:inquiryId/comments\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Omit<Props, \"body\">) =>\n    `/shoppings/sellers/sales/${encodeURIComponent(props.saleId ?? \"null\")}/questions/${encodeURIComponent(props.inquiryId ?? \"null\")}/comments`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IPageIShoppingSaleInquiryComment =>\n    typia.random<IPageIShoppingSaleInquiryComment>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: patchBySaleidAndInquiryid.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patchBySaleidAndInquiryid.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"saleId\")(() => typia.assert(props.saleId));\n      assert.param(\"inquiryId\")(() => typia.assert(props.inquiryId));\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Get an inquiry comment info.\n *\n * Get a detailed {@link IShoppingSaleInquiryComment inquiry comment} information\n * of a {@link IShoppingSaleQuestion question} or\n * {@link IShoppingSaleReview review}.\n *\n * For reference, if you're a {@link IShoppingSeller seller}, you can only access\n * to the your own {@link IShoppingSale sale}'s inquiry comment. Otherwise, you\n * can access to every inquiry comments of the sales.\n *\n * @param props.saleId Belonged sale's {@link IShoppingSale.id }\n * @param props.inquiryId Belonged inquiry's {@link IShoppingSaleInquiry.id }\n * @param props.id Target inquiry comment's\n *   {@link IShoppingSaleInquiryComment.id }\n * @path /shoppings/sellers/sales/:saleId/questions/:inquiryId/comments/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getBySaleidAndInquiryidAndId(\n  connection: IConnection,\n  props: getBySaleidAndInquiryidAndId.Props,\n): Promise<getBySaleidAndInquiryidAndId.Response> {\n  return !!connection.simulate\n    ? getBySaleidAndInquiryidAndId.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getBySaleidAndInquiryidAndId.METADATA,\n          path: getBySaleidAndInquiryidAndId.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace getBySaleidAndInquiryidAndId {\n  export type Props = {\n    /** Belonged sale's {@link IShoppingSale.id } */\n    saleId: string & tags.Format<\"uuid\">;\n\n    /** Belonged inquiry's {@link IShoppingSaleInquiry.id } */\n    inquiryId: string & tags.Format<\"uuid\">;\n\n    /** Target inquiry comment's {@link IShoppingSaleInquiryComment.id } */\n    id: string & tags.Format<\"uuid\">;\n  };\n  export type Response = IShoppingSaleInquiryComment;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/shoppings/sellers/sales/:saleId/questions/:inquiryId/comments/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/shoppings/sellers/sales/${encodeURIComponent(props.saleId ?? \"null\")}/questions/${encodeURIComponent(props.inquiryId ?? \"null\")}/comments/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingSaleInquiryComment =>\n    typia.random<IShoppingSaleInquiryComment>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: getBySaleidAndInquiryidAndId.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getBySaleidAndInquiryidAndId.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"saleId\")(() => typia.assert(props.saleId));\n      assert.param(\"inquiryId\")(() => typia.assert(props.inquiryId));\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Update an inquiry comment.\n *\n * Update an {@link IShoppingSaleInquiryComment inquiry comment} to a specific\n * {@link IShoppingSaleQuestion question} or {@link IShoppingSaleReview review}.\n *\n * By the way, as is the general policy of this shopping mall regarding\n * comments, modifying a comment does not actually change the existing content.\n * Modified content is accumulated and recorded in the existing comment record\n * as a new {@link IShoppingSaleInquiryComment.ISnapshot snapshot}. And this is\n * made public to everyone, who can read this inquiry comment.\n *\n * This is to prevent customers or sellers from modifying their comments and\n * manipulating the circumstances due to the nature of e-commerce, where\n * disputes easily arise. That is, to preserve evidence.\n *\n * @param props.saleId Belonged sale's {@link IShoppingSale.id }\n * @param props.inquiryId Belonged inquiry's {@link IShoppingSaleInquiry.id }\n * @param props.id Target inquiry comment's\n *   {@link IShoppingSaleInquiryComment.id }\n * @param props.body Update info of the inquiry comment\n * @path /shoppings/sellers/sales/:saleId/questions/:inquiryId/comments/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function putBySaleidAndInquiryidAndId(\n  connection: IConnection,\n  props: putBySaleidAndInquiryidAndId.Props,\n): Promise<putBySaleidAndInquiryidAndId.Response> {\n  return !!connection.simulate\n    ? putBySaleidAndInquiryidAndId.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...putBySaleidAndInquiryidAndId.METADATA,\n          path: putBySaleidAndInquiryidAndId.path(props),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace putBySaleidAndInquiryidAndId {\n  export type Props = {\n    /** Belonged sale's {@link IShoppingSale.id } */\n    saleId: string & tags.Format<\"uuid\">;\n\n    /** Belonged inquiry's {@link IShoppingSaleInquiry.id } */\n    inquiryId: string & tags.Format<\"uuid\">;\n\n    /** Target inquiry comment's {@link IShoppingSaleInquiryComment.id } */\n    id: string & tags.Format<\"uuid\">;\n\n    /** Update info of the inquiry comment */\n    body: IShoppingSaleInquiryComment.ICreate;\n  };\n  export type Body = IShoppingSaleInquiryComment.ICreate;\n  export type Response = IShoppingSaleInquiryComment.ISnapshot;\n\n  export const METADATA = {\n    method: \"PUT\",\n    path: \"/shoppings/sellers/sales/:saleId/questions/:inquiryId/comments/:id\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Omit<Props, \"body\">) =>\n    `/shoppings/sellers/sales/${encodeURIComponent(props.saleId ?? \"null\")}/questions/${encodeURIComponent(props.inquiryId ?? \"null\")}/comments/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingSaleInquiryComment.ISnapshot =>\n    typia.random<IShoppingSaleInquiryComment.ISnapshot>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: putBySaleidAndInquiryidAndId.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: putBySaleidAndInquiryidAndId.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"saleId\")(() => typia.assert(props.saleId));\n      assert.param(\"inquiryId\")(() => typia.assert(props.inquiryId));\n      assert.param(\"id\")(() => typia.assert(props.id));\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/sellers/sales/questions/abridges/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingSaleQuestion } from \"../../../../../../structures/IShoppingSaleQuestion\";\nimport { IPageIShoppingSaleQuestion } from \"../../../../../../structures/IPageIShoppingSaleQuestion\";\n\n/**\n * List up every abridged questions.\n *\n * List up every {@link IShoppingSaleQuestion.IAbridge abridged questions} of a\n * {@link IShoppingSale sale}.\n *\n * As you can see, returned questions are abridged, not detailed. If you want to\n * get the detailed information of a question, use {@link at} function for each\n * article.\n *\n * Also, returned question has {@link IShoppingSaleQuestion.IAridge.answer}\n * property which means the formal answer from the {@link IShoppingSeller}.\n * Additionally, returned question has another special property\n * {@link IShoppingSaleQuestion.IAridge.secret} with masking to other princple\n * properties, and it means only related actors can {@link at read} the\n * question.\n *\n * For reference, if you're a {@link IShoppingSeller seller}, you can only access\n * to the your own {@link IShoppingSale sale}'s questions. Otherwise, you can\n * access to every questions of the sales.\n *\n * By the way, if you want, you can limit the result by configuring\n * {@link IShoppingSaleQuestion.IRequest.search search condition} in the request\n * body. Also, it is possible to customize sequence order of records by\n * configuring {@link IShoppingSaleQuestion.IRequest.sort sort condition}.\n *\n * @param props.saleId Belonged sale's {@link IShoppingSale.id }\n * @param props.body Request info of pagination, searching and sorting\n * @path /shoppings/sellers/sales/:saleId/questions/abridges\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patchBySaleid(\n  connection: IConnection,\n  props: patchBySaleid.Props,\n): Promise<patchBySaleid.Response> {\n  return !!connection.simulate\n    ? patchBySaleid.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patchBySaleid.METADATA,\n          path: patchBySaleid.path(props),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace patchBySaleid {\n  export type Props = {\n    /** Belonged sale's {@link IShoppingSale.id } */\n    saleId: string & tags.Format<\"uuid\">;\n\n    /** Request info of pagination, searching and sorting */\n    body: IShoppingSaleQuestion.IRequest;\n  };\n  export type Body = IShoppingSaleQuestion.IRequest;\n  export type Response = IPageIShoppingSaleQuestion.IAbridge;\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/shoppings/sellers/sales/:saleId/questions/abridges\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Omit<Props, \"body\">) =>\n    `/shoppings/sellers/sales/${encodeURIComponent(props.saleId ?? \"null\")}/questions/abridges`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IPageIShoppingSaleQuestion.IAbridge =>\n    typia.random<IPageIShoppingSaleQuestion.IAbridge>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: patchBySaleid.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patchBySaleid.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"saleId\")(() => typia.assert(props.saleId));\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/sellers/sales/reviews/answer/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IBbsArticle } from \"../../../../../../structures/IBbsArticle\";\nimport { IShoppingSaleInquiryAnswer } from \"../../../../../../structures/IShoppingSaleInquiryAnswer\";\n\n/**\n * Write an answer article.\n *\n * Write a formal {@link IShoppingSaleInquiryAnswer answer article} to a specific\n * {@link IShoppingSaleInquiry review article} written by a\n * {@link IShoppingCustomer}.\n *\n * Note that, this is the formal answer that can be written only one per a\n * review article (but {@link update updatable}). Therefore, it needs to guide\n * the {@link IShoppingSeller seller} to write it carefully.\n *\n * Also, as seller can write {@link IShoppingSaleInquiryComment comments} to the\n * review article as many as he/she wants, it would be useful for additional\n * communication.\n *\n * @param props.saleId Belonged sale's {@link IShoppingSale.id }\n * @param props.reviewId Target review's {@link IShoppingSaleReview.id }\n * @param props.body Creation info of the answer article\n * @path /shoppings/sellers/sales/:saleId/reviews/:reviewId/answer\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function postBySaleidAndReviewid(\n  connection: IConnection,\n  props: postBySaleidAndReviewid.Props,\n): Promise<postBySaleidAndReviewid.Response> {\n  return !!connection.simulate\n    ? postBySaleidAndReviewid.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...postBySaleidAndReviewid.METADATA,\n          path: postBySaleidAndReviewid.path(props),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace postBySaleidAndReviewid {\n  export type Props = {\n    /** Belonged sale's {@link IShoppingSale.id } */\n    saleId: string & tags.Format<\"uuid\">;\n\n    /** Target review's {@link IShoppingSaleReview.id } */\n    reviewId: string & tags.Format<\"uuid\">;\n\n    /** Creation info of the answer article */\n    body: IBbsArticle.ICreate;\n  };\n  export type Body = IBbsArticle.ICreate;\n  export type Response = IShoppingSaleInquiryAnswer;\n\n  export const METADATA = {\n    method: \"POST\",\n    path: \"/shoppings/sellers/sales/:saleId/reviews/:reviewId/answer\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Omit<Props, \"body\">) =>\n    `/shoppings/sellers/sales/${encodeURIComponent(props.saleId ?? \"null\")}/reviews/${encodeURIComponent(props.reviewId ?? \"null\")}/answer`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingSaleInquiryAnswer => typia.random<IShoppingSaleInquiryAnswer>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: postBySaleidAndReviewid.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: postBySaleidAndReviewid.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"saleId\")(() => typia.assert(props.saleId));\n      assert.param(\"reviewId\")(() => typia.assert(props.reviewId));\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Update an answer article.\n *\n * Update a formal {@link IShoppingSaleInquiryAnswer answer article} to a\n * specific {@link IShoppingSaleInquiry review article} written by a\n * {@link IShoppingCustomer}.\n *\n * By the way, as is the general policy of this shopping mall regarding\n * articles, modifying a review articles does not actually change the existing\n * content. Modified content is accumulated and recorded in the existing article\n * record as a new {@link IShoppingSaleInquiryAnswer.ISnapshot snapshot}. And\n * this is made public to everyone, including the\n * {@link IShoppingCustomer customer} and the {@link IShoppingSeller seller}, and\n * anyone who can view the article can also view the entire editing histories.\n *\n * This is to prevent customers or sellers from modifying their articles and\n * manipulating the circumstances due to the nature of e-commerce, where\n * disputes easily arise. That is, to preserve evidence.\n *\n * @param props.saleId Belonged sale's {@link IShoppingSale.id }\n * @param props.reviewId Target review's {@link IShoppingSaleReview.id }\n * @param props.body Update info of the answer article\n * @path /shoppings/sellers/sales/:saleId/reviews/:reviewId/answer\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function putBySaleidAndReviewid(\n  connection: IConnection,\n  props: putBySaleidAndReviewid.Props,\n): Promise<putBySaleidAndReviewid.Response> {\n  return !!connection.simulate\n    ? putBySaleidAndReviewid.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...putBySaleidAndReviewid.METADATA,\n          path: putBySaleidAndReviewid.path(props),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace putBySaleidAndReviewid {\n  export type Props = {\n    /** Belonged sale's {@link IShoppingSale.id } */\n    saleId: string & tags.Format<\"uuid\">;\n\n    /** Target review's {@link IShoppingSaleReview.id } */\n    reviewId: string & tags.Format<\"uuid\">;\n\n    /** Update info of the answer article */\n    body: IBbsArticle.ICreate;\n  };\n  export type Body = IBbsArticle.ICreate;\n  export type Response = IShoppingSaleInquiryAnswer.ISnapshot;\n\n  export const METADATA = {\n    method: \"PUT\",\n    path: \"/shoppings/sellers/sales/:saleId/reviews/:reviewId/answer\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Omit<Props, \"body\">) =>\n    `/shoppings/sellers/sales/${encodeURIComponent(props.saleId ?? \"null\")}/reviews/${encodeURIComponent(props.reviewId ?? \"null\")}/answer`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingSaleInquiryAnswer.ISnapshot =>\n    typia.random<IShoppingSaleInquiryAnswer.ISnapshot>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: putBySaleidAndReviewid.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: putBySaleidAndReviewid.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"saleId\")(() => typia.assert(props.saleId));\n      assert.param(\"reviewId\")(() => typia.assert(props.reviewId));\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/sellers/sales/reviews/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingSaleReview } from \"../../../../../structures/IShoppingSaleReview\";\nimport { IPageIShoppingSaleReview } from \"../../../../../structures/IPageIShoppingSaleReview\";\nexport * as answer from \"./answer\";\nexport * as comments from \"./comments\";\nexport * as abridges from \"./abridges\";\n\n/**\n * List up every summarized reviews.\n *\n * List up every {@link IShoppingSaleReview.ISummary summarized reviews} of a\n * {@link IShoppingSale sale}.\n *\n * As you can see, returned reviews are summarized, not detailed. If you want to\n * get the detailed information of a review, use {@link adridges} function or\n * {@link at} function for each article.\n *\n * Also, returned review has {@link IShoppingSaleReview.ISummary.answer} property\n * which means the formal answer from the {@link IShoppingSeller}.\n *\n * For reference, if you're a {@link IShoppingSeller seller}, you can only access\n * to the your own {@link IShoppingSale sale}'s reviews. Otherwise, you can\n * access to every reviews of the sales.\n *\n * By the way, if you want, you can limit the result by configuring\n * {@link IShoppingSaleReview.IRequest.search search condition} in the request\n * body. Also, it is possible to customize sequence order of records by\n * configuring {@link IShoppingSaleReview.IRequest.sort sort condition}.\n *\n * @param props.saleId Belonged sale's {@link IShoppingSale.id }\n * @param props.body Request info of pagination, searching and sorting\n * @path /shoppings/sellers/sales/:saleId/reviews\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patchBySaleid(\n  connection: IConnection,\n  props: patchBySaleid.Props,\n): Promise<patchBySaleid.Response> {\n  return !!connection.simulate\n    ? patchBySaleid.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patchBySaleid.METADATA,\n          path: patchBySaleid.path(props),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace patchBySaleid {\n  export type Props = {\n    /** Belonged sale's {@link IShoppingSale.id } */\n    saleId: string & tags.Format<\"uuid\">;\n\n    /** Request info of pagination, searching and sorting */\n    body: IShoppingSaleReview.IRequest;\n  };\n  export type Body = IShoppingSaleReview.IRequest;\n  export type Response = IPageIShoppingSaleReview.ISummary;\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/shoppings/sellers/sales/:saleId/reviews\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Omit<Props, \"body\">) =>\n    `/shoppings/sellers/sales/${encodeURIComponent(props.saleId ?? \"null\")}/reviews`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IPageIShoppingSaleReview.ISummary =>\n    typia.random<IPageIShoppingSaleReview.ISummary>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: patchBySaleid.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patchBySaleid.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"saleId\")(() => typia.assert(props.saleId));\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Get a review info.\n *\n * Get a detailed {@link IShoppingSaleReview review} information of a\n * {@link IShoppingSale sale}.\n *\n * For reference, if you're a {@link IShoppingSeller seller}, you can only access\n * to the your own {@link IShoppingSale sale}'s review. Otherwise you are a\n * {@link IShoppingCustomer customer}, you can access to every reviews of the\n * sales.\n *\n * @param props.saleId Belonged sale's {@link IShoppingSale.id }\n * @param props.id Target review's {@link IShoppingSaleReview.id }\n * @path /shoppings/sellers/sales/:saleId/reviews/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getBySaleidAndId(\n  connection: IConnection,\n  props: getBySaleidAndId.Props,\n): Promise<getBySaleidAndId.Response> {\n  return !!connection.simulate\n    ? getBySaleidAndId.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getBySaleidAndId.METADATA,\n          path: getBySaleidAndId.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace getBySaleidAndId {\n  export type Props = {\n    /** Belonged sale's {@link IShoppingSale.id } */\n    saleId: string & tags.Format<\"uuid\">;\n\n    /** Target review's {@link IShoppingSaleReview.id } */\n    id: string & tags.Format<\"uuid\">;\n  };\n  export type Response = IShoppingSaleReview;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/shoppings/sellers/sales/:saleId/reviews/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/shoppings/sellers/sales/${encodeURIComponent(props.saleId ?? \"null\")}/reviews/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingSaleReview => typia.random<IShoppingSaleReview>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: getBySaleidAndId.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getBySaleidAndId.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"saleId\")(() => typia.assert(props.saleId));\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/sellers/sales/reviews/comments/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingSaleInquiryComment } from \"../../../../../../structures/IShoppingSaleInquiryComment\";\nimport { IPageIShoppingSaleInquiryComment } from \"../../../../../../structures/IPageIShoppingSaleInquiryComment\";\n\n/**\n * Create an inquiry comment.\n *\n * Create an {@link IShoppingSaleInquiryComment inquiry comment} of a\n * {@link IShoppingSaleQuestion question} or {@link IShoppingSaleReview review}.\n *\n * For reference, if you're a {@link IShoppingSeller seller}, you can only create\n * an inquiry comment to your own {@link IShoppingSale sale}'s inquiry.\n * Otherwise, you can create an inquiry comment to every inquiries of the\n * sales.\n *\n * @param props.saleId Belonged sale's {@link IShoppingSale.id }\n * @param props.inquiryId Target inquiry's {@link IShoppingSaleInquiry.id }\n * @param props.body Creation info of the inquiry comment\n * @path /shoppings/sellers/sales/:saleId/reviews/:inquiryId/comments\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function postBySaleidAndInquiryid(\n  connection: IConnection,\n  props: postBySaleidAndInquiryid.Props,\n): Promise<postBySaleidAndInquiryid.Response> {\n  return !!connection.simulate\n    ? postBySaleidAndInquiryid.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...postBySaleidAndInquiryid.METADATA,\n          path: postBySaleidAndInquiryid.path(props),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace postBySaleidAndInquiryid {\n  export type Props = {\n    /** Belonged sale's {@link IShoppingSale.id } */\n    saleId: string & tags.Format<\"uuid\">;\n\n    /** Target inquiry's {@link IShoppingSaleInquiry.id } */\n    inquiryId: string & tags.Format<\"uuid\">;\n\n    /** Creation info of the inquiry comment */\n    body: IShoppingSaleInquiryComment.ICreate;\n  };\n  export type Body = IShoppingSaleInquiryComment.ICreate;\n  export type Response = IShoppingSaleInquiryComment;\n\n  export const METADATA = {\n    method: \"POST\",\n    path: \"/shoppings/sellers/sales/:saleId/reviews/:inquiryId/comments\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Omit<Props, \"body\">) =>\n    `/shoppings/sellers/sales/${encodeURIComponent(props.saleId ?? \"null\")}/reviews/${encodeURIComponent(props.inquiryId ?? \"null\")}/comments`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingSaleInquiryComment =>\n    typia.random<IShoppingSaleInquiryComment>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: postBySaleidAndInquiryid.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: postBySaleidAndInquiryid.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"saleId\")(() => typia.assert(props.saleId));\n      assert.param(\"inquiryId\")(() => typia.assert(props.inquiryId));\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * List up every inquiry comments.\n *\n * List up every {@link IShoppingSaleInquiryComment inquiry comments} of a\n * {@link IShoppingSaleQuestion question} or {@link IShoppingSaleReview review}\n * with {@link IPage pagination}.\n *\n * If you want, you can limit the result by configuring\n * {@link IShoppingSaleInquiryComment.IRequest.search search condition} in the\n * request body. Also, it is possible to customize sequence order of records by\n * configuring {@link IShoppingSaleInquiryComment.IRequest.sort sort condition}.\n *\n * By the way, if you're a {@link IShoppingSeller seller}, you can only access to\n * the your own {@link IShoppingSale sale}'s inquiries. Otherwise, you can access\n * to every inquiries of the sales.\n *\n * @param props.saleId Belonged sale's {@link IShoppingSale.id }\n * @param props.inquiryId Belonged inquiry's {@link IShoppingSaleInquiry.id }\n * @param props.body Request info of pagination, searching and sorting\n * @path /shoppings/sellers/sales/:saleId/reviews/:inquiryId/comments\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patchBySaleidAndInquiryid(\n  connection: IConnection,\n  props: patchBySaleidAndInquiryid.Props,\n): Promise<patchBySaleidAndInquiryid.Response> {\n  return !!connection.simulate\n    ? patchBySaleidAndInquiryid.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patchBySaleidAndInquiryid.METADATA,\n          path: patchBySaleidAndInquiryid.path(props),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace patchBySaleidAndInquiryid {\n  export type Props = {\n    /** Belonged sale's {@link IShoppingSale.id } */\n    saleId: string & tags.Format<\"uuid\">;\n\n    /** Belonged inquiry's {@link IShoppingSaleInquiry.id } */\n    inquiryId: string & tags.Format<\"uuid\">;\n\n    /** Request info of pagination, searching and sorting */\n    body: IShoppingSaleInquiryComment.IRequest;\n  };\n  export type Body = IShoppingSaleInquiryComment.IRequest;\n  export type Response = IPageIShoppingSaleInquiryComment;\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/shoppings/sellers/sales/:saleId/reviews/:inquiryId/comments\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Omit<Props, \"body\">) =>\n    `/shoppings/sellers/sales/${encodeURIComponent(props.saleId ?? \"null\")}/reviews/${encodeURIComponent(props.inquiryId ?? \"null\")}/comments`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IPageIShoppingSaleInquiryComment =>\n    typia.random<IPageIShoppingSaleInquiryComment>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: patchBySaleidAndInquiryid.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patchBySaleidAndInquiryid.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"saleId\")(() => typia.assert(props.saleId));\n      assert.param(\"inquiryId\")(() => typia.assert(props.inquiryId));\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Get an inquiry comment info.\n *\n * Get a detailed {@link IShoppingSaleInquiryComment inquiry comment} information\n * of a {@link IShoppingSaleQuestion question} or\n * {@link IShoppingSaleReview review}.\n *\n * For reference, if you're a {@link IShoppingSeller seller}, you can only access\n * to the your own {@link IShoppingSale sale}'s inquiry comment. Otherwise, you\n * can access to every inquiry comments of the sales.\n *\n * @param props.saleId Belonged sale's {@link IShoppingSale.id }\n * @param props.inquiryId Belonged inquiry's {@link IShoppingSaleInquiry.id }\n * @param props.id Target inquiry comment's\n *   {@link IShoppingSaleInquiryComment.id }\n * @path /shoppings/sellers/sales/:saleId/reviews/:inquiryId/comments/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getBySaleidAndInquiryidAndId(\n  connection: IConnection,\n  props: getBySaleidAndInquiryidAndId.Props,\n): Promise<getBySaleidAndInquiryidAndId.Response> {\n  return !!connection.simulate\n    ? getBySaleidAndInquiryidAndId.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getBySaleidAndInquiryidAndId.METADATA,\n          path: getBySaleidAndInquiryidAndId.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace getBySaleidAndInquiryidAndId {\n  export type Props = {\n    /** Belonged sale's {@link IShoppingSale.id } */\n    saleId: string & tags.Format<\"uuid\">;\n\n    /** Belonged inquiry's {@link IShoppingSaleInquiry.id } */\n    inquiryId: string & tags.Format<\"uuid\">;\n\n    /** Target inquiry comment's {@link IShoppingSaleInquiryComment.id } */\n    id: string & tags.Format<\"uuid\">;\n  };\n  export type Response = IShoppingSaleInquiryComment;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/shoppings/sellers/sales/:saleId/reviews/:inquiryId/comments/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/shoppings/sellers/sales/${encodeURIComponent(props.saleId ?? \"null\")}/reviews/${encodeURIComponent(props.inquiryId ?? \"null\")}/comments/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingSaleInquiryComment =>\n    typia.random<IShoppingSaleInquiryComment>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: getBySaleidAndInquiryidAndId.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getBySaleidAndInquiryidAndId.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"saleId\")(() => typia.assert(props.saleId));\n      assert.param(\"inquiryId\")(() => typia.assert(props.inquiryId));\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Update an inquiry comment.\n *\n * Update an {@link IShoppingSaleInquiryComment inquiry comment} to a specific\n * {@link IShoppingSaleQuestion question} or {@link IShoppingSaleReview review}.\n *\n * By the way, as is the general policy of this shopping mall regarding\n * comments, modifying a comment does not actually change the existing content.\n * Modified content is accumulated and recorded in the existing comment record\n * as a new {@link IShoppingSaleInquiryComment.ISnapshot snapshot}. And this is\n * made public to everyone, who can read this inquiry comment.\n *\n * This is to prevent customers or sellers from modifying their comments and\n * manipulating the circumstances due to the nature of e-commerce, where\n * disputes easily arise. That is, to preserve evidence.\n *\n * @param props.saleId Belonged sale's {@link IShoppingSale.id }\n * @param props.inquiryId Belonged inquiry's {@link IShoppingSaleInquiry.id }\n * @param props.id Target inquiry comment's\n *   {@link IShoppingSaleInquiryComment.id }\n * @param props.body Update info of the inquiry comment\n * @path /shoppings/sellers/sales/:saleId/reviews/:inquiryId/comments/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function putBySaleidAndInquiryidAndId(\n  connection: IConnection,\n  props: putBySaleidAndInquiryidAndId.Props,\n): Promise<putBySaleidAndInquiryidAndId.Response> {\n  return !!connection.simulate\n    ? putBySaleidAndInquiryidAndId.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...putBySaleidAndInquiryidAndId.METADATA,\n          path: putBySaleidAndInquiryidAndId.path(props),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace putBySaleidAndInquiryidAndId {\n  export type Props = {\n    /** Belonged sale's {@link IShoppingSale.id } */\n    saleId: string & tags.Format<\"uuid\">;\n\n    /** Belonged inquiry's {@link IShoppingSaleInquiry.id } */\n    inquiryId: string & tags.Format<\"uuid\">;\n\n    /** Target inquiry comment's {@link IShoppingSaleInquiryComment.id } */\n    id: string & tags.Format<\"uuid\">;\n\n    /** Update info of the inquiry comment */\n    body: IShoppingSaleInquiryComment.ICreate;\n  };\n  export type Body = IShoppingSaleInquiryComment.ICreate;\n  export type Response = IShoppingSaleInquiryComment.ISnapshot;\n\n  export const METADATA = {\n    method: \"PUT\",\n    path: \"/shoppings/sellers/sales/:saleId/reviews/:inquiryId/comments/:id\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Omit<Props, \"body\">) =>\n    `/shoppings/sellers/sales/${encodeURIComponent(props.saleId ?? \"null\")}/reviews/${encodeURIComponent(props.inquiryId ?? \"null\")}/comments/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingSaleInquiryComment.ISnapshot =>\n    typia.random<IShoppingSaleInquiryComment.ISnapshot>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: putBySaleidAndInquiryidAndId.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: putBySaleidAndInquiryidAndId.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"saleId\")(() => typia.assert(props.saleId));\n      assert.param(\"inquiryId\")(() => typia.assert(props.inquiryId));\n      assert.param(\"id\")(() => typia.assert(props.id));\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/sellers/sales/reviews/abridges/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingSaleReview } from \"../../../../../../structures/IShoppingSaleReview\";\nimport { IPageIShoppingSaleReview } from \"../../../../../../structures/IPageIShoppingSaleReview\";\n\n/**\n * List up every abridged reviews.\n *\n * List up every {@link IShoppingSaleReview.IAbridge abridged reviews} of a\n * {@link IShoppingSale sale}.\n *\n * As you can see, returned reviews are abridged, not detailed. If you want to\n * get the detailed information of a review, use {@link at} function for each\n * article.\n *\n * Also, returned review has {@link IShoppingSaleReview.IAridge.answer} property\n * which means the formal answer from the {@link IShoppingSeller}.\n *\n * For reference, if you're a {@link IShoppingSeller seller}, you can only access\n * to the your own {@link IShoppingSale sale}'s reviews. Otherwise, you can\n * access to every reviews of the sales.\n *\n * By the way, if you want, you can limit the result by configuring\n * {@link IShoppingSaleReview.IRequest.search search condition} in the request\n * body. Also, it is possible to customize sequence order of records by\n * configuring {@link IShoppingSaleReview.IRequest.sort sort condition}.\n *\n * @param props.saleId Belonged sale's {@link IShoppingSale.id }\n * @param props.body Request info of pagination, searching and sorting\n * @path /shoppings/sellers/sales/:saleId/reviews/abridges\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patchBySaleid(\n  connection: IConnection,\n  props: patchBySaleid.Props,\n): Promise<patchBySaleid.Response> {\n  return !!connection.simulate\n    ? patchBySaleid.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patchBySaleid.METADATA,\n          path: patchBySaleid.path(props),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace patchBySaleid {\n  export type Props = {\n    /** Belonged sale's {@link IShoppingSale.id } */\n    saleId: string & tags.Format<\"uuid\">;\n\n    /** Request info of pagination, searching and sorting */\n    body: IShoppingSaleReview.IRequest;\n  };\n  export type Body = IShoppingSaleReview.IRequest;\n  export type Response = IPageIShoppingSaleReview.IAbridge;\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/shoppings/sellers/sales/:saleId/reviews/abridges\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Omit<Props, \"body\">) =>\n    `/shoppings/sellers/sales/${encodeURIComponent(props.saleId ?? \"null\")}/reviews/abridges`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IPageIShoppingSaleReview.IAbridge =>\n    typia.random<IPageIShoppingSaleReview.IAbridge>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: patchBySaleid.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patchBySaleid.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"saleId\")(() => typia.assert(props.saleId));\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/sellers/sales/snapshots/replica/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingSale } from \"../../../../../../structures/IShoppingSale\";\n\n/**\n * Get replica of a snapshot.\n *\n * Get a {@link IShoppingSale.ICreate} typed info of the target\n * {@link IShoppingSaleSnapshot snapshot} record for replication.\n *\n * It would be useful for creating a new replication {@link IShoppingSale sale}\n * from the old snapshot.\n *\n * @param props.saleId Belonged sale's {@link IShoppingSale.id }\n * @param props.id Target snapshot's {@link IShoppingSaleSnapshot.id }\n * @path /shoppings/sellers/sales/:saleId/snapshots/:id/replica\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function postBySaleidAndId(\n  connection: IConnection,\n  props: postBySaleidAndId.Props,\n): Promise<postBySaleidAndId.Response> {\n  return !!connection.simulate\n    ? postBySaleidAndId.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...postBySaleidAndId.METADATA,\n          path: postBySaleidAndId.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace postBySaleidAndId {\n  export type Props = {\n    /** Belonged sale's {@link IShoppingSale.id } */\n    saleId: string & tags.Format<\"uuid\">;\n\n    /** Target snapshot's {@link IShoppingSaleSnapshot.id } */\n    id: string & tags.Format<\"uuid\">;\n  };\n  export type Response = IShoppingSale.ICreate;\n\n  export const METADATA = {\n    method: \"POST\",\n    path: \"/shoppings/sellers/sales/:saleId/snapshots/:id/replica\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/shoppings/sellers/sales/${encodeURIComponent(props.saleId ?? \"null\")}/snapshots/${encodeURIComponent(props.id ?? \"null\")}/replica`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingSale.ICreate => typia.random<IShoppingSale.ICreate>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: postBySaleidAndId.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: postBySaleidAndId.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"saleId\")(() => typia.assert(props.saleId));\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/sellers/sales/snapshots/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IPage } from \"../../../../../structures/IPage\";\nimport { IPageIShoppingSaleSnapshot } from \"../../../../../structures/IPageIShoppingSaleSnapshot\";\nimport { IShoppingSaleSnapshot } from \"../../../../../structures/IShoppingSaleSnapshot\";\nexport * as replica from \"./replica\";\nexport * as flip from \"./flip\";\n\n/**\n * List up every snapshots.\n *\n * Whenever {@link IShoppingSeller seller} updates a {@link IShoppingSale sale},\n * the sale record is not updated but a new\n * {@link IShoppingSaleSnapshot snapshot} record is created to keep the integrity\n * of the sale history. This API function is for listing up such snapshot\n * records.\n *\n * Also, as you can see from the return type, returned snapshots are summarized,\n * not detailed. If you want to get the detailed information of a snapshot, use\n * {@link at} or {@link flipo} function for each snapshot.\n *\n * For reference, if you're a {@link IShoppingSeller seller}, you can only access\n * to the your own {@link IShoppingSale sale}'s snapshots. Otherwise, you can\n * access to every snapshots of the sales even though the sale has been closed\n * or suspended.\n *\n * @param props.saleId Target sale's {@link IShoppingSale.id }\n * @param props.body Requestion info of pagination\n * @path /shoppings/sellers/sales/:saleId/snapshots\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patchBySaleid(\n  connection: IConnection,\n  props: patchBySaleid.Props,\n): Promise<patchBySaleid.Response> {\n  return !!connection.simulate\n    ? patchBySaleid.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patchBySaleid.METADATA,\n          path: patchBySaleid.path(props),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace patchBySaleid {\n  export type Props = {\n    /** Target sale's {@link IShoppingSale.id } */\n    saleId: string & tags.Format<\"uuid\">;\n\n    /** Requestion info of pagination */\n    body: IPage.IRequest;\n  };\n  export type Body = IPage.IRequest;\n  export type Response = IPageIShoppingSaleSnapshot.ISummary;\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/shoppings/sellers/sales/:saleId/snapshots\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Omit<Props, \"body\">) =>\n    `/shoppings/sellers/sales/${encodeURIComponent(props.saleId ?? \"null\")}/snapshots`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IPageIShoppingSaleSnapshot.ISummary =>\n    typia.random<IPageIShoppingSaleSnapshot.ISummary>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: patchBySaleid.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patchBySaleid.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"saleId\")(() => typia.assert(props.saleId));\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Get a snapshot info.\n *\n * Get a {@link IShoppingSaleSnapshot snapshot} with detailed information.\n *\n * As you can see from the return type, returned snapshot does not contain the\n * {@link IShoppingSale sale} info. If you want to get the sale info, use the\n * {@link flip} function instead.\n *\n * For reference, if you're a {@link IShoppingSeller seller}, you can only access\n * to the your own {@link IShoppingSale sale}'s snapshots. Otherwise, you can\n * access to every snapshots of the sales even though the sale has been closed\n * or suspended.\n *\n * @param props.saleId Belonged sale's {@link IShoppingSale.id }\n * @param props.id Target snapshot's {@link IShoppingSaleSnapshot.id }\n * @path /shoppings/sellers/sales/:saleId/snapshots/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getBySaleidAndId(\n  connection: IConnection,\n  props: getBySaleidAndId.Props,\n): Promise<getBySaleidAndId.Response> {\n  return !!connection.simulate\n    ? getBySaleidAndId.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getBySaleidAndId.METADATA,\n          path: getBySaleidAndId.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace getBySaleidAndId {\n  export type Props = {\n    /** Belonged sale's {@link IShoppingSale.id } */\n    saleId: string & tags.Format<\"uuid\">;\n\n    /** Target snapshot's {@link IShoppingSaleSnapshot.id } */\n    id: string & tags.Format<\"uuid\">;\n  };\n  export type Response = IShoppingSaleSnapshot;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/shoppings/sellers/sales/:saleId/snapshots/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/shoppings/sellers/sales/${encodeURIComponent(props.saleId ?? \"null\")}/snapshots/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingSaleSnapshot => typia.random<IShoppingSaleSnapshot>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: getBySaleidAndId.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getBySaleidAndId.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"saleId\")(() => typia.assert(props.saleId));\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/sellers/sales/snapshots/flip/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingSale } from \"../../../../../../structures/IShoppingSale\";\n\n/**\n * Get a flipped snapshot info.\n *\n * Get a {@link IShoppingSale sale} info of a flipped snapshot.\n *\n * As you can see from the return type, this function returns the\n * {@link IShoppingSale sale} info. By the way, the sale info is not the latest\n * one, but a flipped info in the snapshot side.\n *\n * Also, if you're a {@link IShoppingSeller seller}, you can only access to the\n * your own {@link IShoppingSale sale}'s snapshots. Otherwise, you can access to\n * every snapshots of the sales even though the sale has been closed or\n * suspended.\n *\n * @param props.saleId Belonged sale's {@link IShoppingSale.id }\n * @param props.id Target snapshot's {@link IShoppingSaleSnapshot.id }\n * @path /shoppings/sellers/sales/:saleId/snapshots/:id/flip\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getBySaleidAndId(\n  connection: IConnection,\n  props: getBySaleidAndId.Props,\n): Promise<getBySaleidAndId.Response> {\n  return !!connection.simulate\n    ? getBySaleidAndId.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getBySaleidAndId.METADATA,\n          path: getBySaleidAndId.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace getBySaleidAndId {\n  export type Props = {\n    /** Belonged sale's {@link IShoppingSale.id } */\n    saleId: string & tags.Format<\"uuid\">;\n\n    /** Target snapshot's {@link IShoppingSaleSnapshot.id } */\n    id: string & tags.Format<\"uuid\">;\n  };\n  export type Response = IShoppingSale;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/shoppings/sellers/sales/:saleId/snapshots/:id/flip\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/shoppings/sellers/sales/${encodeURIComponent(props.saleId ?? \"null\")}/snapshots/${encodeURIComponent(props.id ?? \"null\")}/flip`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): IShoppingSale =>\n    typia.random<IShoppingSale>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: getBySaleidAndId.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getBySaleidAndId.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"saleId\")(() => typia.assert(props.saleId));\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/sellers/sales/units/stocks/supplements/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingSaleUnitStockSupplement } from \"../../../../../../../structures/IShoppingSaleUnitStockSupplement\";\nimport { IPageIShoppingSaleUnitStockSupplement } from \"../../../../../../../structures/IPageIShoppingSaleUnitStockSupplement\";\n\n/**\n * Create a supplement.\n *\n * Create a {@link IShoppingSaleUnitStockSupplement supplement history} of a\n * specific {@link IShoppingSaleUnitStock stock}.\n *\n * Therefore, {@link IShoppingSaleUnitStockInventory.income inventory} of the\n * target stock will be increased by the\n * {@link IShoppingSaleUnitStockSupplement.value supplement's value}.\n *\n * @param props.saleId Belonged sale's {@link IShoppingSale.id }\n * @param props.unitId Belonged unit's {@link IShoppingSaleUnit.id }\n * @param props.stockId Target stock's {@link IShoppingSaleUnitStock.id }\n * @param props.body Create info of the supplement\n * @path /shoppings/sellers/sales/:saleId/units/:unitId/stocks/:stockId/supplements\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function postBySaleidAndUnitidAndStockid(\n  connection: IConnection,\n  props: postBySaleidAndUnitidAndStockid.Props,\n): Promise<postBySaleidAndUnitidAndStockid.Response> {\n  return !!connection.simulate\n    ? postBySaleidAndUnitidAndStockid.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...postBySaleidAndUnitidAndStockid.METADATA,\n          path: postBySaleidAndUnitidAndStockid.path(props),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace postBySaleidAndUnitidAndStockid {\n  export type Props = {\n    /** Belonged sale's {@link IShoppingSale.id } */\n    saleId: string & tags.Format<\"uuid\">;\n\n    /** Belonged unit's {@link IShoppingSaleUnit.id } */\n    unitId: string & tags.Format<\"uuid\">;\n\n    /** Target stock's {@link IShoppingSaleUnitStock.id } */\n    stockId: string & tags.Format<\"uuid\">;\n\n    /** Create info of the supplement */\n    body: IShoppingSaleUnitStockSupplement.ICreate;\n  };\n  export type Body = IShoppingSaleUnitStockSupplement.ICreate;\n  export type Response = IShoppingSaleUnitStockSupplement;\n\n  export const METADATA = {\n    method: \"POST\",\n    path: \"/shoppings/sellers/sales/:saleId/units/:unitId/stocks/:stockId/supplements\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Omit<Props, \"body\">) =>\n    `/shoppings/sellers/sales/${encodeURIComponent(props.saleId ?? \"null\")}/units/${encodeURIComponent(props.unitId ?? \"null\")}/stocks/${encodeURIComponent(props.stockId ?? \"null\")}/supplements`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingSaleUnitStockSupplement =>\n    typia.random<IShoppingSaleUnitStockSupplement>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: postBySaleidAndUnitidAndStockid.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: postBySaleidAndUnitidAndStockid.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"saleId\")(() => typia.assert(props.saleId));\n      assert.param(\"unitId\")(() => typia.assert(props.unitId));\n      assert.param(\"stockId\")(() => typia.assert(props.stockId));\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * List up every supplements.\n *\n * List up every {@link IShoppingSaleUnitStockSupplement supplement histories} of\n * a specific {@link IShoppingSaleUnitStock stock}.\n *\n * If you want, you can limit the result by configuring\n * {@link IShoppingSaleUnitStockSupplement.IRequest.search search condition} in\n * the request body. Also, it is possible to customize sequence order of records\n * by configuring {@link IShoppingSaleUnitStockSupplement.IRequest.sort}\n * property.\n *\n * @param props.saleId Belonged sale's {@link IShoppingSale.id }\n * @param props.unitId Belonged unit's {@link IShoppingSaleUnit.id }\n * @param props.stockId Target stock's {@link IShoppingSaleUnitStock.id }\n * @param props.body Request info of pagination, searching and sorting\n * @path /shoppings/sellers/sales/:saleId/units/:unitId/stocks/:stockId/supplements\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patchBySaleidAndUnitidAndStockid(\n  connection: IConnection,\n  props: patchBySaleidAndUnitidAndStockid.Props,\n): Promise<patchBySaleidAndUnitidAndStockid.Response> {\n  return !!connection.simulate\n    ? patchBySaleidAndUnitidAndStockid.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patchBySaleidAndUnitidAndStockid.METADATA,\n          path: patchBySaleidAndUnitidAndStockid.path(props),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace patchBySaleidAndUnitidAndStockid {\n  export type Props = {\n    /** Belonged sale's {@link IShoppingSale.id } */\n    saleId: string & tags.Format<\"uuid\">;\n\n    /** Belonged unit's {@link IShoppingSaleUnit.id } */\n    unitId: string & tags.Format<\"uuid\">;\n\n    /** Target stock's {@link IShoppingSaleUnitStock.id } */\n    stockId: string & tags.Format<\"uuid\">;\n\n    /** Request info of pagination, searching and sorting */\n    body: IShoppingSaleUnitStockSupplement.IRequest;\n  };\n  export type Body = IShoppingSaleUnitStockSupplement.IRequest;\n  export type Response = IPageIShoppingSaleUnitStockSupplement;\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/shoppings/sellers/sales/:saleId/units/:unitId/stocks/:stockId/supplements\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Omit<Props, \"body\">) =>\n    `/shoppings/sellers/sales/${encodeURIComponent(props.saleId ?? \"null\")}/units/${encodeURIComponent(props.unitId ?? \"null\")}/stocks/${encodeURIComponent(props.stockId ?? \"null\")}/supplements`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IPageIShoppingSaleUnitStockSupplement =>\n    typia.random<IPageIShoppingSaleUnitStockSupplement>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: patchBySaleidAndUnitidAndStockid.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patchBySaleidAndUnitidAndStockid.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"saleId\")(() => typia.assert(props.saleId));\n      assert.param(\"unitId\")(() => typia.assert(props.unitId));\n      assert.param(\"stockId\")(() => typia.assert(props.stockId));\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Update a supplement.\n *\n * Update quantity value of a {@link IShoppingSaleUnitStockSupplement supplement}\n * of a specific {@link IShoppingSaleUnitStock stock}.\n *\n * Therefore, {@link IShoppingSaleUnitStockInventory.income inventory} of the\n * target stock will be changed by the\n * {@link IShoppingSaleUnitStockSupplement.value supplement's value}.\n *\n * @param props.saleId Belonged sale's {@link IShoppingSale.id }\n * @param props.unitId Belonged unit's {@link IShoppingSaleUnit.id }\n * @param props.stockId Target stock's {@link IShoppingSaleUnitStock.id }\n * @param props.id Target supplement's\n *   {@link IShoppingSaleUnitStockSupplement.id }\n * @param props.body Update info (quantity) of the supplement\n * @path /shoppings/sellers/sales/:saleId/units/:unitId/stocks/:stockId/supplements/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function putBySaleidAndUnitidAndStockidAndId(\n  connection: IConnection,\n  props: putBySaleidAndUnitidAndStockidAndId.Props,\n): Promise<void> {\n  return !!connection.simulate\n    ? putBySaleidAndUnitidAndStockidAndId.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...putBySaleidAndUnitidAndStockidAndId.METADATA,\n          path: putBySaleidAndUnitidAndStockidAndId.path(props),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace putBySaleidAndUnitidAndStockidAndId {\n  export type Props = {\n    /** Belonged sale's {@link IShoppingSale.id } */\n    saleId: string & tags.Format<\"uuid\">;\n\n    /** Belonged unit's {@link IShoppingSaleUnit.id } */\n    unitId: string & tags.Format<\"uuid\">;\n\n    /** Target stock's {@link IShoppingSaleUnitStock.id } */\n    stockId: string & tags.Format<\"uuid\">;\n\n    /** Target supplement's {@link IShoppingSaleUnitStockSupplement.id } */\n    id: string & tags.Format<\"uuid\">;\n\n    /** Update info (quantity) of the supplement */\n    body: IShoppingSaleUnitStockSupplement.ICreate;\n  };\n  export type Body = IShoppingSaleUnitStockSupplement.ICreate;\n\n  export const METADATA = {\n    method: \"PUT\",\n    path: \"/shoppings/sellers/sales/:saleId/units/:unitId/stocks/:stockId/supplements/:id\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Omit<Props, \"body\">) =>\n    `/shoppings/sellers/sales/${encodeURIComponent(props.saleId ?? \"null\")}/units/${encodeURIComponent(props.unitId ?? \"null\")}/stocks/${encodeURIComponent(props.stockId ?? \"null\")}/supplements/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): void =>\n    typia.random<void>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: putBySaleidAndUnitidAndStockidAndId.Props,\n  ): void => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: putBySaleidAndUnitidAndStockidAndId.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"saleId\")(() => typia.assert(props.saleId));\n      assert.param(\"unitId\")(() => typia.assert(props.unitId));\n      assert.param(\"stockId\")(() => typia.assert(props.stockId));\n      assert.param(\"id\")(() => typia.assert(props.id));\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Erase a supplement.\n *\n * Erase a {@link IShoppingSaleUnitStockSupplement supplement} of a specific\n * {@link IShoppingSaleUnitStock stock}.\n *\n * Therefore, {@link IShoppingSaleUnitStockInventory.income inventory} of the\n * target stock will be decreased by the\n * {@link IShoppingSaleUnitStockSupplement.value supplement's value}.\n *\n * @param props.saleId Belonged sale's {@link IShoppingSale.id }\n * @param props.unitId Belonged unit's {@link IShoppingSaleUnit.id }\n * @param props.stockId Target stock's {@link IShoppingSaleUnitStock.id }\n * @param props.id Target supplement's\n *   {@link IShoppingSaleUnitStockSupplement.id }\n * @path /shoppings/sellers/sales/:saleId/units/:unitId/stocks/:stockId/supplements/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function eraseBySaleidAndUnitidAndStockidAndId(\n  connection: IConnection,\n  props: eraseBySaleidAndUnitidAndStockidAndId.Props,\n): Promise<void> {\n  return !!connection.simulate\n    ? eraseBySaleidAndUnitidAndStockidAndId.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...eraseBySaleidAndUnitidAndStockidAndId.METADATA,\n          path: eraseBySaleidAndUnitidAndStockidAndId.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace eraseBySaleidAndUnitidAndStockidAndId {\n  export type Props = {\n    /** Belonged sale's {@link IShoppingSale.id } */\n    saleId: string & tags.Format<\"uuid\">;\n\n    /** Belonged unit's {@link IShoppingSaleUnit.id } */\n    unitId: string & tags.Format<\"uuid\">;\n\n    /** Target stock's {@link IShoppingSaleUnitStock.id } */\n    stockId: string & tags.Format<\"uuid\">;\n\n    /** Target supplement's {@link IShoppingSaleUnitStockSupplement.id } */\n    id: string & tags.Format<\"uuid\">;\n  };\n\n  export const METADATA = {\n    method: \"DELETE\",\n    path: \"/shoppings/sellers/sales/:saleId/units/:unitId/stocks/:stockId/supplements/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/shoppings/sellers/sales/${encodeURIComponent(props.saleId ?? \"null\")}/units/${encodeURIComponent(props.unitId ?? \"null\")}/stocks/${encodeURIComponent(props.stockId ?? \"null\")}/supplements/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): void =>\n    typia.random<void>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: eraseBySaleidAndUnitidAndStockidAndId.Props,\n  ): void => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: eraseBySaleidAndUnitidAndStockidAndId.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"saleId\")(() => typia.assert(props.saleId));\n      assert.param(\"unitId\")(() => typia.assert(props.unitId));\n      assert.param(\"stockId\")(() => typia.assert(props.stockId));\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/sellers/sales/units/stocks/index.ts": "export * as supplements from \"./supplements\";\n",
  "src/api/functional/shoppings/sellers/sales/units/index.ts": "export * as stocks from \"./stocks\";\n",
  "src/api/functional/shoppings/sellers/systematic/channels/categories/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingChannelCategory } from \"../../../../../../structures/IShoppingChannelCategory\";\nexport * as invert from \"./invert\";\n\n/**\n * List up every categories with children records.\n *\n * List up every {@link IShoppingChannelCategory.IHierarchical categories} of a\n * {@link IShoppingChannel channel} with pagination. Returned categories contain\n * children categories, too.\n *\n * If you want, you can limit the result by configuring\n * {@link IShoppingChannelCategory.IRequest.search search condition} in the\n * request body. Also, it is possible to customize sequence order of records by\n * configuring {@link IShoppingChannelCategory.IRequest.sort sort condition}.\n *\n * @param props.channelCode Belonged channel's {@link IShoppingChannel.code }\n * @path /shoppings/sellers/systematic/channels/:channelCode/categories\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patchByChannelcode(\n  connection: IConnection,\n  props: patchByChannelcode.Props,\n): Promise<void> {\n  return !!connection.simulate\n    ? patchByChannelcode.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patchByChannelcode.METADATA,\n          path: patchByChannelcode.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace patchByChannelcode {\n  export type Props = {\n    /** Belonged channel's {@link IShoppingChannel.code } */\n    channelCode: string;\n  };\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/shoppings/sellers/systematic/channels/:channelCode/categories\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/shoppings/sellers/systematic/channels/${encodeURIComponent(props.channelCode ?? \"null\")}/categories`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): void =>\n    typia.random<void>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: patchByChannelcode.Props,\n  ): void => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patchByChannelcode.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"channelCode\")(() => typia.assert(props.channelCode));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Get a category info.\n *\n * Get a detailed {@link IShoppingChannelCategory category} information.\n *\n * Returned category contains hierarchical children categories, and also\n * contains the recursive parent categories, too.\n *\n * @param props.channelCode Belonged channel's {@link IShoppingChannel.code }\n * @param props.id Target category's {@link IShoppingChannelCategory.id }\n * @path /shoppings/sellers/systematic/channels/:channelCode/categories/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getByChannelcodeAndId(\n  connection: IConnection,\n  props: getByChannelcodeAndId.Props,\n): Promise<getByChannelcodeAndId.Response> {\n  return !!connection.simulate\n    ? getByChannelcodeAndId.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getByChannelcodeAndId.METADATA,\n          path: getByChannelcodeAndId.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace getByChannelcodeAndId {\n  export type Props = {\n    /** Belonged channel's {@link IShoppingChannel.code } */\n    channelCode: string;\n\n    /** Target category's {@link IShoppingChannelCategory.id } */\n    id: string & tags.Format<\"uuid\">;\n  };\n  export type Response = IShoppingChannelCategory;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/shoppings/sellers/systematic/channels/:channelCode/categories/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/shoppings/sellers/systematic/channels/${encodeURIComponent(props.channelCode ?? \"null\")}/categories/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingChannelCategory => typia.random<IShoppingChannelCategory>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: getByChannelcodeAndId.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getByChannelcodeAndId.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"channelCode\")(() => typia.assert(props.channelCode));\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/sellers/systematic/channels/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingChannel } from \"../../../../../structures/IShoppingChannel\";\nimport { IPageIShoppingChannel } from \"../../../../../structures/IPageIShoppingChannel\";\nexport * as categories from \"./categories\";\nexport * as hierarchical from \"./hierarchical\";\nexport * as get from \"./get\";\n\n/**\n * List up every channels.\n *\n * List up every {@link IShoppingChannel channels} with pagination.\n *\n * If you want, you can limit the result by configuring\n * {@link IShoppingChannel.IRequest.search search condition} in the request body.\n * Also, it is possible to customize sequence order of records by configuring\n * {@link IShoppingChannel.IRequest.sort sort condition}.\n *\n * @param props.body Request info of pagination, searching and sorting\n * @path /shoppings/sellers/systematic/channels\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patch(\n  connection: IConnection,\n  props: patch.Props,\n): Promise<patch.Response> {\n  return !!connection.simulate\n    ? patch.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patch.METADATA,\n          path: patch.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace patch {\n  export type Props = {\n    /** Request info of pagination, searching and sorting */\n    body: IShoppingChannel.IRequest;\n  };\n  export type Body = IShoppingChannel.IRequest;\n  export type Response = IPageIShoppingChannel;\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/shoppings/sellers/systematic/channels\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/shoppings/sellers/systematic/channels\";\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IPageIShoppingChannel => typia.random<IPageIShoppingChannel>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: patch.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patch.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Get a channel info.\n *\n * Get a detailed {@link IShoppingChannel.IHierarchical channel} information.\n *\n * Returned channel instance also contains the nested\n * {@link IShoppingChannelCategory.IHierarchical hierarchical category}\n * information.\n *\n * @param props.id Target channel's {@link IShoppingChannel.id }\n * @path /shoppings/sellers/systematic/channels/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getById(\n  connection: IConnection,\n  props: getById.Props,\n): Promise<getById.Response> {\n  return !!connection.simulate\n    ? getById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getById.METADATA,\n          path: getById.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace getById {\n  export type Props = {\n    /** Target channel's {@link IShoppingChannel.id } */\n    id: string & tags.Format<\"uuid\">;\n  };\n  export type Response = IShoppingChannel.IHierarchical;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/shoppings/sellers/systematic/channels/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/shoppings/sellers/systematic/channels/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingChannel.IHierarchical =>\n    typia.random<IShoppingChannel.IHierarchical>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: getById.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/sellers/systematic/index.ts": "export * as channels from \"./channels\";\nexport * as sections from \"./sections\";\n",
  "src/api/functional/shoppings/sellers/systematic/channels/categories/invert/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingChannelCategory } from \"../../../../../../../structures/IShoppingChannelCategory\";\n\n/**\n * Get a category info of inverted.\n *\n * Get a inverted {@link IShoppingChannelCategory.IInvert category} information.\n *\n * Returned category contains the recursive parent categories, but not contains\n * the hierarchical children categories.\n *\n * @param props.channelCode Belonged channel's {@link IShoppingChannel.code }\n * @param props.id Target category's {@link IShoppingChannelCategory.id }\n * @path /shoppings/sellers/systematic/channels/:channelCode/categories/:id/invert\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getByChannelcodeAndId(\n  connection: IConnection,\n  props: getByChannelcodeAndId.Props,\n): Promise<getByChannelcodeAndId.Response> {\n  return !!connection.simulate\n    ? getByChannelcodeAndId.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getByChannelcodeAndId.METADATA,\n          path: getByChannelcodeAndId.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace getByChannelcodeAndId {\n  export type Props = {\n    /** Belonged channel's {@link IShoppingChannel.code } */\n    channelCode: string;\n\n    /** Target category's {@link IShoppingChannelCategory.id } */\n    id: string & tags.Format<\"uuid\">;\n  };\n  export type Response = IShoppingChannelCategory.IInvert;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/shoppings/sellers/systematic/channels/:channelCode/categories/:id/invert\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/shoppings/sellers/systematic/channels/${encodeURIComponent(props.channelCode ?? \"null\")}/categories/${encodeURIComponent(props.id ?? \"null\")}/invert`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingChannelCategory.IInvert =>\n    typia.random<IShoppingChannelCategory.IInvert>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: getByChannelcodeAndId.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getByChannelcodeAndId.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"channelCode\")(() => typia.assert(props.channelCode));\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/sellers/systematic/channels/hierarchical/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingChannel } from \"../../../../../../structures/IShoppingChannel\";\nimport { IPageIShoppingChannel } from \"../../../../../../structures/IPageIShoppingChannel\";\n\n/**\n * List up every channels with nested categories.\n *\n * List up every {@link IShoppingChannel.IHierarchical channels} with\n * {@link IPage pagination}. Returned channels contain nested hierarchical\n * {@link IShoppingChannelCategory.IHierarchical categories}.\n *\n * If you want, you can limit the result by configuring\n * {@link IShoppingChannel.IRequest.search search condition} in the request body.\n * Also, it is possible to customize sequence order of records by configuring\n * {@link IShoppingChannel.IRequest.sort sort condition}.\n *\n * @param props.body Request info of pagination, searching and sorting\n * @path /shoppings/sellers/systematic/channels/hierarchical\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patch(\n  connection: IConnection,\n  props: patch.Props,\n): Promise<patch.Response> {\n  return !!connection.simulate\n    ? patch.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patch.METADATA,\n          path: patch.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace patch {\n  export type Props = {\n    /** Request info of pagination, searching and sorting */\n    body: IShoppingChannel.IRequest;\n  };\n  export type Body = IShoppingChannel.IRequest;\n  export type Response = IPageIShoppingChannel.IHierarchical;\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/shoppings/sellers/systematic/channels/hierarchical\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () =>\n    \"/shoppings/sellers/systematic/channels/hierarchical\";\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IPageIShoppingChannel.IHierarchical =>\n    typia.random<IPageIShoppingChannel.IHierarchical>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: patch.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patch.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/sellers/systematic/channels/get/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingChannel } from \"../../../../../../structures/IShoppingChannel\";\n\n/**\n * Get a channel info by its code.\n *\n * Get a detailed {@link IShoppingChannel.IHierarchical channel} information by\n * its code.\n *\n * Returned channel instance also contains the nested\n * {@link IShoppingChannelCategory.IHierarchical hierarchical category}\n * information.\n *\n * @param props.code Target channel's {@link IShoppingChannel.code }\n * @path /shoppings/sellers/systematic/channels/:code/get\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getByCode(\n  connection: IConnection,\n  props: getByCode.Props,\n): Promise<getByCode.Response> {\n  return !!connection.simulate\n    ? getByCode.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getByCode.METADATA,\n          path: getByCode.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace getByCode {\n  export type Props = {\n    /** Target channel's {@link IShoppingChannel.code } */\n    code: string;\n  };\n  export type Response = IShoppingChannel.IHierarchical;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/shoppings/sellers/systematic/channels/:code/get\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/shoppings/sellers/systematic/channels/${encodeURIComponent(props.code ?? \"null\")}/get`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingChannel.IHierarchical =>\n    typia.random<IShoppingChannel.IHierarchical>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: getByCode.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getByCode.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"code\")(() => typia.assert(props.code));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/sellers/systematic/sections/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingSection } from \"../../../../../structures/IShoppingSection\";\nimport { IPageIShoppingSection } from \"../../../../../structures/IPageIShoppingSection\";\nexport * as get from \"./get\";\n\n/**\n * List up every sections.\n *\n * List up every {@link IShoppingSection sections} with pagination.\n *\n * If you want, you can limit the result by configuring\n * {@link IShoppingSection.IRequest.search search condition} in the request body.\n * Also, it is possible to customize sequence order of records by configuring\n * {@link IShoppingSection.IRequest.sort sort condition}.\n *\n * @param props.body Request info of pagination, searching and sorting\n * @path /shoppings/sellers/systematic/sections\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patch(\n  connection: IConnection,\n  props: patch.Props,\n): Promise<patch.Response> {\n  return !!connection.simulate\n    ? patch.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patch.METADATA,\n          path: patch.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace patch {\n  export type Props = {\n    /** Request info of pagination, searching and sorting */\n    body: IShoppingSection.IRequest;\n  };\n  export type Body = IShoppingSection.IRequest;\n  export type Response = IPageIShoppingSection;\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/shoppings/sellers/systematic/sections\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/shoppings/sellers/systematic/sections\";\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IPageIShoppingSection => typia.random<IPageIShoppingSection>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: patch.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patch.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Get a section info.\n *\n * Get a detailed {@link IShoppingSection section} information.\n *\n * @param props.id Target section's {@link IShoppingSection.id }\n * @path /shoppings/sellers/systematic/sections/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getById(\n  connection: IConnection,\n  props: getById.Props,\n): Promise<getById.Response> {\n  return !!connection.simulate\n    ? getById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getById.METADATA,\n          path: getById.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace getById {\n  export type Props = {\n    /** Target section's {@link IShoppingSection.id } */\n    id: string & tags.Format<\"uuid\">;\n  };\n  export type Response = IShoppingSection;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/shoppings/sellers/systematic/sections/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/shoppings/sellers/systematic/sections/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingSection => typia.random<IShoppingSection>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: getById.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "src/api/functional/shoppings/sellers/systematic/sections/get/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IShoppingSection } from \"../../../../../../structures/IShoppingSection\";\n\n/**\n * Get a section info by its code.\n *\n * Get a detailed {@link IShoppingSection section} information by its code.\n *\n * @param props.code Target section's {@link IShoppingSection.code }\n * @path /shoppings/sellers/systematic/sections/:code/get\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getByCode(\n  connection: IConnection,\n  props: getByCode.Props,\n): Promise<getByCode.Response> {\n  return !!connection.simulate\n    ? getByCode.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getByCode.METADATA,\n          path: getByCode.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace getByCode {\n  export type Props = {\n    /** Target section's {@link IShoppingSection.code } */\n    code: string;\n  };\n  export type Response = IShoppingSection;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/shoppings/sellers/systematic/sections/:code/get\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/shoppings/sellers/systematic/sections/${encodeURIComponent(props.code ?? \"null\")}/get`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IShoppingSection => typia.random<IShoppingSection>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: getByCode.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getByCode.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"code\")(() => typia.assert(props.code));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
  "packages/api/swagger.json": "{\n  \"openapi\": \"3.1.0\",\n  \"paths\": {\n    \"/monitors/health\": {\n      \"get\": {\n        \"summary\": \"Health check API\",\n        \"description\": \"Health check API.\",\n        \"parameters\": []\n      }\n    },\n    \"/monitors/performance\": {\n      \"get\": {\n        \"summary\": \"Get performance information\",\n        \"description\": \"Get performance information.\\n\\nGet perofmration information composed with CPU, memory and resource usage.\",\n        \"parameters\": [],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPerformance\"\n                }\n              }\n            },\n            \"description\": \"Performance info\"\n          }\n        }\n      }\n    },\n    \"/monitors/system\": {\n      \"get\": {\n        \"summary\": \"Get system information\",\n        \"description\": \"Get system information.\\n\\nGet system information with commit and package information.\\n\\nAs such information is a type of sensitive, response be encrypted.\",\n        \"parameters\": [],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/ISystem\"\n                }\n              }\n            },\n            \"description\": \"System info\"\n          }\n        }\n      }\n    },\n    \"/shoppings/admins/authenticate\": {\n      \"get\": {\n        \"summary\": \"Get administrator information\",\n        \"description\": \"Get administrator information.\\n\\nGet {@link IShoppingAdministrator.IInvert administrator} information of\\ncurrent {@link IShoppingCustomer customer}.\\n\\nIf current {@link IShoppingMember member} is not an administrator,\\nit throws 403 forbidden exception.\",\n        \"parameters\": [],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingAdministrator.IInvert\"\n                }\n              }\n            },\n            \"description\": \"Admin info\"\n          }\n        }\n      },\n      \"post\": {\n        \"summary\": \"Join as an administrator\",\n        \"description\": \"Join as an administrator.\\n\\nJoin as an administrator with {@link IShoppingAdministrator.IJoin joining info}.\\n\\nThis method is allowed only when the {@link IShoppingCustomer customer} already\\nhas joined the {@link IShoppingMember membership}. IF not, he (she) must\\naccomplish it before. If not, 403 forbidden exception would be thrown.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingAdministrator.IJoin\"\n              }\n            }\n          },\n          \"description\": \"Joining request info\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"201\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingAdministrator.IInvert\"\n                }\n              }\n            },\n            \"description\": \"Administrator info\"\n          }\n        }\n      }\n    },\n    \"/shoppings/admins/authenticate/login\": {\n      \"put\": {\n        \"summary\": \"Login as an administrator\",\n        \"description\": \"Login as an administrator.\\n\\nLogin as an administrator with {@link IShoppingAdministrator.ILogin login info}.\\n\\nThis method has exactly same effect with\\n{@link ShoppingApi.functional.customers.authenticate.login} function, but\\nreturned type is a llttle different. The similar function returns\\n{@link IShoppingCustomer} type that starting from the customer information, so\\nthat you have to access to the administrator info through\\n`customer.member.administrator`. In contrast with that, this method returns\\n{@link IShoppingAdministrator.IInvert} type that starting from the administrator\\ninfo, so that can access to the customer info through `administrator.customer`.\\n\\nOf course, to use this function, you had to {@link join} as an administrator\\nbefore. If not, 403 forbidden exception would be thrown,\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingMember.ILogin\"\n              }\n            }\n          },\n          \"description\": \"Login request info\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingAdministrator.IInvert\"\n                }\n              }\n            },\n            \"description\": \"Administrator info\"\n          }\n        }\n      }\n    },\n    \"/shoppings/admins/coupons\": {\n      \"post\": {\n        \"summary\": \"Create a new coupon\",\n        \"description\": \"Create a new coupon.\\n\\nCreate a new {@link IShoppingCoupon coupon} with given information.\\n\\nBy the way, if you are a {@link IShoppingSeller seller}, you have to\\nadd include direction's {@link IShoppingCouponSellerCriteria} or\\n{@link IShoppingCouponSaleCriteria} condition. This is because only\\n{@link IShoppingAdministrator administrators} can create a coupon\\nwhich can be used throughout the market. Seller must limit the usage\\nrange by his/her {@link IShoppingSale sale(s)}.\\n\\nOf course, when administrator is planning to make a general coupon\\nthat can be used throughout the market, the administrator must\\nget agree from the sellers who are going to be affected.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingCoupon.ICreate\"\n              }\n            }\n          },\n          \"description\": \"Creation info of the coupon\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"201\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingCoupon\"\n                }\n              }\n            },\n            \"description\": \"Newly created coupon\"\n          }\n        }\n      },\n      \"patch\": {\n        \"summary\": \"List up every coupons\",\n        \"description\": \"List up every coupons.\\n\\nList up every {@link IShoppingCoupon coupons} with pagination.\\n\\nIf you want, you can limit the result by configuring\\n{@link IShoppingCoupon.IRequest.search search condition} in the request\\nbody. Also, it is possible to customize sequence order of records by\\nconfiguring {@link IShoppingCoupon.IRequest.sort sort condition}.\\n\\nFor reference, if you are a {@link IShoppingCustomer customer}, then\\nonly {@link IShoppingCouponTicket ticketable} coupons would be listed up.\\nOtherwise, non-ticketable coupons would also be listed up.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingCoupon.IRequest\"\n              }\n            }\n          },\n          \"description\": \"Request info of pagination, searching and sorting\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPageIShoppingCoupon\"\n                }\n              }\n            },\n            \"description\": \"Paginated coupons\"\n          }\n        }\n      }\n    },\n    \"/shoppings/admins/coupons/{id}\": {\n      \"get\": {\n        \"summary\": \"Get a coupon info\",\n        \"description\": \"Get a coupon info.\\n\\nGet a {@link IShoppingCoupon coupon} information.\\n\\nIf you are a {@link IShoppingCustomer customer}, then only\\n{@link IShoppingCouponTicket ticketable} coupons are accessible. Non\\nticketable coupons cause 410 gone error. Otherwise you are a\\n{@link IShoppingSeller seller} or {@link IShoppingAdministrator administrator},\\nnon-ticketable coupons are also accessible.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\"\n            },\n            \"description\": \" Target coupon's {@link IShoppingCoupon.id }\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingCoupon\"\n                }\n              }\n            },\n            \"description\": \"Coupon info\"\n          }\n        }\n      },\n      \"delete\": {\n        \"summary\": \"Erase a coupon\",\n        \"description\": \"Erase a coupon.\\n\\nErase a {@link IShoppingCoupon coupon} with given ID.\\n\\nFor reference, if there're some {@link IShoppingCouponTicket tickets}\\nwhich are already issued from the target coupon, they would not be affected.\\nThose tickets are still valid until their expration time.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\"\n            },\n            \"description\": \" Target coupon's {@link IShoppingCoupon.id }\",\n            \"required\": true\n          }\n        ]\n      }\n    },\n    \"/shoppings/admins/deposits\": {\n      \"post\": {\n        \"summary\": \"Create a new deposit metadata\",\n        \"description\": \"Create a new deposit metadata.\\n\\nCreate a new {@link IShoppingDeposit deposit} metadata.\\n\\nThis action means that adding a new origin reason of deposit's income/outcome.\\nOf course, creating a new deposit record does not mean that automatically\\nincrease or decrease the {@link IShoppingCustomer customer}'s balance\\nfollowing the record's reason why. The logic must be developed manually\\nin the backend side.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingDeposit.ICreate\"\n              }\n            }\n          },\n          \"description\": \"Creation information of deposit metadata\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"201\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingDeposit\"\n                }\n              }\n            },\n            \"description\": \"Newly created deposit metadata\"\n          }\n        }\n      },\n      \"patch\": {\n        \"summary\": \"Get deposit metadata list\",\n        \"description\": \"Get deposit metadata list.\\n\\nList up every {@link IShoppingDeposit deposit} metadata information\\nwith {@link IPage pagination}.\\n\\nIf you want, you can limit the result by configuring\\n{@link IShoppingDeposit.IRequest.search search condition} in the request body.\\nAlso, it is possible to customize sequence order of records by configuring\\n{@link IShoppingDeposit.IRequest.sort sort condition}.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingDeposit.IRequest\"\n              }\n            }\n          },\n          \"description\": \"Request info of pagination, searching and sorting\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPageIShoppingDeposit\"\n                }\n              }\n            },\n            \"description\": \"Paginated deposit metadata list\"\n          }\n        }\n      }\n    },\n    \"/shoppings/admins/deposits/{id}\": {\n      \"get\": {\n        \"summary\": \"Get a deposit metadata\",\n        \"description\": \"Get a deposit metadata.\\n\\nGet a {@link IShoppingDeposit deposit} metadata information with its ID.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target deposit's {@link IShoppingDeposit.id }\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingDeposit\"\n                }\n              }\n            },\n            \"description\": \"Deposit metadata\"\n          }\n        }\n      },\n      \"delete\": {\n        \"summary\": \"Erase a deposit metadata\",\n        \"description\": \"Erase a deposit metadata.\\n\\nErase a {@link IShoppingDeposit deposit} metadata, so that no more\\n{@link IShoppingCustomer customer}'s balance does not be increased or\\ndecreased by the deposit's reason why.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target deposit's {@link IShoppingDeposit.id }\",\n            \"required\": true\n          }\n        ]\n      }\n    },\n    \"/shoppings/admins/deposits/{code}/get\": {\n      \"get\": {\n        \"summary\": \"Get a deposit metadata by its code\",\n        \"description\": \"Get a deposit metadata by its code.\\n\\nGet a {@link IShoppingDeposit deposit} metadata information with its code.\",\n        \"parameters\": [\n          {\n            \"name\": \"code\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\"\n            },\n            \"description\": \"Describe description as much as possible with clear and concise words.\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingDeposit\"\n                }\n              }\n            },\n            \"description\": \"Deposit metadata\"\n          }\n        }\n      }\n    },\n    \"/shoppings/admins/mileages\": {\n      \"post\": {\n        \"summary\": \"Create a new mileage metadata\",\n        \"description\": \"Create a new mileage metadata.\\n\\nCreate a new {@link IShoppingMileage mileage} metadata.\\n\\nThis action means that adding a new origin reason of mileage's income/outcome.\\nOf course, creating a new mileage record does not mean that automatically\\nincrease or decrease the {@link IShoppingCustomer customer}'s balance\\nfollowing the record's reason why. The logic must be developed manually\\nin the backend side.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingMileage.ICreate\"\n              }\n            }\n          },\n          \"description\": \"Creation information of mileage metadata\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"201\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingMileage\"\n                }\n              }\n            },\n            \"description\": \"Newly created mileage metadata\"\n          }\n        }\n      },\n      \"patch\": {\n        \"summary\": \"Get mileage metadata list\",\n        \"description\": \"Get mileage metadata list.\\n\\nList up every {@link IShoppingMileage mileage} metadata information\\nwith {@link IPage pagination}.\\n\\nIf you want, you can limit the result by configuring\\n{@link IShoppingMileage.IRequest.search search condition} in the request body.\\nAlso, it is possible to customize sequence order of records by configuring\\n{@link IShoppingMileage.IRequest.sort sort condition}.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingMileage.IRequest\"\n              }\n            }\n          },\n          \"description\": \"Request info of pagination, searching and sorting\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPageIShoppingMileage\"\n                }\n              }\n            },\n            \"description\": \"Paginated mileage metadata list\"\n          }\n        }\n      }\n    },\n    \"/shoppings/admins/mileages/{id}\": {\n      \"get\": {\n        \"summary\": \"Get a mileage metadata\",\n        \"description\": \"Get a mileage metadata.\\n\\nGet a {@link IShoppingMileage mileage} metadata information with its ID.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target mileage's {@link IShoppingMileage.id }\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingMileage\"\n                }\n              }\n            },\n            \"description\": \"Mileage metadata\"\n          }\n        }\n      },\n      \"delete\": {\n        \"summary\": \"Erase a mileage metadata\",\n        \"description\": \"Erase a mileage metadata.\\n\\nErase a {@link IShoppingMileage mileage} metadata, so that no more\\n{@link IShoppingCustomer customer}'s balance does not be increased or\\ndecreased by the mileage's reason why.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target mileage's {@link IShoppingMileage.id }\",\n            \"required\": true\n          }\n        ]\n      }\n    },\n    \"/shoppings/admins/mileages/{code}/get\": {\n      \"get\": {\n        \"summary\": \"Get a mileage metadata by its code\",\n        \"description\": \"Get a mileage metadata by its code.\\n\\nGet a {@link IShoppingMileage mileage} metadata information with its code.\",\n        \"parameters\": [\n          {\n            \"name\": \"code\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\"\n            },\n            \"description\": \"Describe description as much as possible with clear and concise words.\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingMileage\"\n                }\n              }\n            },\n            \"description\": \"Mileage metadata\"\n          }\n        }\n      }\n    },\n    \"/shoppings/admins/mileages/donations\": {\n      \"post\": {\n        \"summary\": \"Donate a mileage to a citizen\",\n        \"description\": \"Donate a mileage to a citizen.\\n\\nDonate a mileage to a specific {@link IShoppingCitizen citizen} from\\ncurrent {@link IShoppingAdministrator administrator}, with detailed\\nreason why.\\n\\nNote that, as donating mileage affects to the citizen's balance and\\ncurrent shopping mall's operating profit, administrator must archive\\nthe detailed reason why the mileage is donated.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingMileageDonation.ICreate\"\n              }\n            }\n          },\n          \"description\": \"Request info of mileage donation\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"201\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingMileageDonation\"\n                }\n              }\n            },\n            \"description\": \"Mileage donation history\"\n          }\n        }\n      },\n      \"patch\": {\n        \"summary\": \"List up every mileage donation histories\",\n        \"description\": \"List up every mileage donation histories.\\n\\nList up every {@link IShoppingMileageDonation mileage donation histories}\\nwith {@link IPage pagination}.\\n\\nIf you want, you can limit the result by configuring\\n{@link IShoppingMileageDonation.IRequest.search search condition} in\\nthe request body. Also, it is possible to customize sequence order of\\nrecords by configuring {@link IShoppingMileageDonation.IRequest.sort sort}.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingMileageDonation.IRequest\"\n              }\n            }\n          },\n          \"description\": \"Request info of pagination, searching and sorting\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPageIShoppingMileageDonation\"\n                }\n              }\n            },\n            \"description\": \"Paginated mileage donation history list\"\n          }\n        }\n      }\n    },\n    \"/shoppings/admins/mileages/donations/{id}\": {\n      \"get\": {\n        \"summary\": \"Get a mileage donation history\",\n        \"description\": \"Get a mileage donation history.\\n\\nGet a {@link IShoppingMileageDonation mileage donation history} with its ID.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target history's {@link IShoppingMileageDonation.id }\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingMileageDonation\"\n                }\n              }\n            },\n            \"description\": \"Mileage donation history\"\n          }\n        }\n      }\n    },\n    \"/shoppings/admins/orders\": {\n      \"patch\": {\n        \"summary\": \"List up every orders\",\n        \"description\": \"List up every orders.\\n\\nList up every {@link IShoppingOrder orders} with pagination.\\n\\nIf you want, you can limit the result by configuring\\n{@link IShoppingOrder.IRequest.search search condition} in the request\\nbody. Also, it is possible to customize sequence order of records by\\nconfiguring {@link IShoppingOrder.IRequest.sort sort condition}.\\n\\nFor reference, if you are a {@link IShoppingCustomer customer}, then\\nyou can list up your own orders, and it is not a matter whether the\\norder has been {@link IShoppingOrderPublish.paid_at paid} or not.\\n\\nOtherwise you are a {@link IShoppingSeller seller} or\\n{@link IShoppingAdministrator administrator}, then you can list up\\nonly paid orders. Also, in the seller case, only related\\n{@link IShoppingOrder.goods goods} would be listed up in the order.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingOrder.IRequest\"\n              }\n            }\n          },\n          \"description\": \"Request info of pagination, searching and sorting\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPageIShoppingOrder\"\n                }\n              }\n            },\n            \"description\": \"Paginated orders\"\n          }\n        }\n      }\n    },\n    \"/shoppings/admins/orders/{id}\": {\n      \"get\": {\n        \"summary\": \"Get an order info\",\n        \"description\": \"Get an order info.\\n\\nGet a detailed {@link IShoppingOrder order} information.\\n\\nIf you are not a {@link IShoppingCustomer customer}, then you can't\\naccess to the order which has not been\\n{@link IShoppingOrderPublish.paid_at paid} yet. In that case,\\n404 not found error would be thrown.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target order's {@link IShoppingOrder.id }\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingOrder\"\n                }\n              }\n            },\n            \"description\": \"Order info\"\n          }\n        }\n      }\n    },\n    \"/shoppings/admins/sales/details\": {\n      \"patch\": {\n        \"summary\": \"List up every sales\",\n        \"description\": \"List up every sales.\\n\\nList up every {@link IShoppingSale sales} with detailed information.\\n\\nAs you can see, returned sales are detailed, not summarized. If you want\\nto get the summarized information of sale for a brief, use {@link index}\\nfunction instead.\\n\\nFor reference, if you're a {@link IShoppingSeller seller}, you can only\\naccess to the your own {@link IShoppingSale sale}s. Otherwise you're a\\n{@link IShoppingCustomer customer}, you can see only the operating sales\\nin the market. Instead, you can't see the unopened, closed, or suspended\\nsales.\\n\\n> If you're an A.I. chatbot, please don't summarize the\\n> {@link IShoppingSaleUnitStock stock information}. Just list up the\\n> every stocks in the sale with detailed information.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingSale.IRequest\"\n              }\n            }\n          },\n          \"description\": \"Request info of pagination, searching and sorting\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPageIShoppingSale\"\n                }\n              }\n            },\n            \"description\": \"Paginated sales with detailed information\"\n          }\n        }\n      }\n    },\n    \"/shoppings/admins/sales\": {\n      \"patch\": {\n        \"summary\": \"List up every summarized sales\",\n        \"description\": \"List up every summarized sales.\\n\\nList up every {@link IShoppingSale.ISummary summarized sales}.\\n\\nAs you can see, returned sales are summarized, not detailed. It does not\\ncontain the SKU (Stock Keeping Unit) information represented by the\\n{@link IShoppingSaleUnitOption} and {@link IShoppingSaleUnitStock} types.\\nIf you want to get such detailed information of a sale, use\\n`GET /shoppings/customers/sales/{id}` operation for each sale.\\n\\n> If you're an A.I. chatbot, and the user wants to buy or compose\\n> {@link IShoppingCartCommodity shopping cart} from a sale, please\\n> call the `GET /shoppings/customers/sales/{id}` operation at least once\\n> to the target sale to get detailed SKU information about the sale.\\n> It needs to be run at least once for the next steps.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingSale.IRequest\"\n              }\n            }\n          },\n          \"description\": \"Request info of pagination, searching and sorting\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPageIShoppingSale.ISummary\"\n                }\n              }\n            },\n            \"description\": \"Paginated sales with summarized information\"\n          }\n        }\n      }\n    },\n    \"/shoppings/admins/sales/{id}\": {\n      \"get\": {\n        \"summary\": \"Get a sale with detailed information\",\n        \"description\": \"Get a sale with detailed information.\\n\\nGet a {@link IShoppingSale sale} with detailed information including\\nthe SKU (Stock Keeping Unit) information represented by the\\n{@link IShoppingSaleUnitOption} and {@link IShoppingSaleUnitStock} types.\\n\\n> If you're an A.I. chatbot, and the user wants to buy or compose a\\n> {@link IShoppingCartCommodity shopping cart} from a sale, please call\\n> this operation at least once to the target sale to get detailed SKU\\n> information about the sale.\\n>\\n> It needs to be run at least once for the next steps. In other words,\\n> if you A.I. agent has called this operation to a specific sale, you\\n> don't need to call this operation again for the same sale.\\n>\\n> Additionally, please do not summarize the SKU information. Just show\\n> the every options and stocks in the sale with detailed information.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target sale's {@link IShoppingSale.id }\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingSale\"\n                }\n              }\n            },\n            \"description\": \"Detailed sale information\"\n          }\n        }\n      }\n    },\n    \"/shoppings/admins/sales/{saleId}/questions/{inquiryId}/comments\": {\n      \"post\": {\n        \"summary\": \"Create an inquiry comment\",\n        \"description\": \"Create an inquiry comment.\\n\\nCreate an {@link IShoppingSaleInquiryComment inquiry comment} of a\\n{@link IShoppingSaleQuestion question} or {@link IShoppingSaleReview review}.\\n\\nFor reference, if you're a {@link IShoppingSeller seller}, you can only\\ncreate an inquiry comment to your own {@link IShoppingSale sale}'s inquiry.\\nOtherwise, you can create an inquiry comment to every inquiries of the sales.\",\n        \"parameters\": [\n          {\n            \"name\": \"saleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Belonged sale's {@link IShoppingSale.id }\",\n            \"required\": true\n          },\n          {\n            \"name\": \"inquiryId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target inquiry's {@link IShoppingSaleInquiry.id }\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingSaleInquiryComment.ICreate\"\n              }\n            }\n          },\n          \"description\": \"Creation info of the inquiry comment\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"201\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingSaleInquiryComment\"\n                }\n              }\n            },\n            \"description\": \"Newly created inquiry comment\"\n          }\n        }\n      },\n      \"patch\": {\n        \"summary\": \"List up every inquiry comments\",\n        \"description\": \"List up every inquiry comments.\\n\\nList up every {@link IShoppingSaleInquiryComment inquiry comments} of a\\n{@link IShoppingSaleQuestion question} or {@link IShoppingSaleReview review}\\nwith {@link IPage pagination}.\\n\\nIf you want, you can limit the result by configuring\\n{@link IShoppingSaleInquiryComment.IRequest.search search condition} in the\\nrequest body. Also, it is possible to customize sequence order of records\\nby configuring {@link IShoppingSaleInquiryComment.IRequest.sort sort condition}.\\n\\nBy the way, if you're a {@link IShoppingSeller seller}, you can only access\\nto the your own {@link IShoppingSale sale}'s inquiries. Otherwise, you\\ncan access to every inquiries of the sales.\",\n        \"parameters\": [\n          {\n            \"name\": \"saleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Belonged sale's {@link IShoppingSale.id }\",\n            \"required\": true\n          },\n          {\n            \"name\": \"inquiryId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Belonged inquiry's {@link IShoppingSaleInquiry.id }\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingSaleInquiryComment.IRequest\"\n              }\n            }\n          },\n          \"description\": \"Request info of pagination, searching and sorting\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPageIShoppingSaleInquiryComment\"\n                }\n              }\n            },\n            \"description\": \"Paginated inquiry comments\"\n          }\n        }\n      }\n    },\n    \"/shoppings/admins/sales/{saleId}/questions/{inquiryId}/comments/{id}\": {\n      \"get\": {\n        \"summary\": \"Get an inquiry comment info\",\n        \"description\": \"Get an inquiry comment info.\\n\\nGet a detailed {@link IShoppingSaleInquiryComment inquiry comment}\\ninformation of a {@link IShoppingSaleQuestion question} or\\n{@link IShoppingSaleReview review}.\\n\\nFor reference, if you're a {@link IShoppingSeller seller}, you can only\\naccess to the your own {@link IShoppingSale sale}'s inquiry comment.\\nOtherwise, you can access to every inquiry comments of the sales.\",\n        \"parameters\": [\n          {\n            \"name\": \"saleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Belonged sale's {@link IShoppingSale.id }\",\n            \"required\": true\n          },\n          {\n            \"name\": \"inquiryId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Belonged inquiry's {@link IShoppingSaleInquiry.id }\",\n            \"required\": true\n          },\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target inquiry comment's {@link IShoppingSaleInquiryComment.id }\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingSaleInquiryComment\"\n                }\n              }\n            },\n            \"description\": \"Detailed inquiry comment info\"\n          }\n        }\n      },\n      \"put\": {\n        \"summary\": \"Update an inquiry comment\",\n        \"description\": \"Update an inquiry comment.\\n\\nUpdate an {@link IShoppingSaleInquiryComment inquiry comment} to a specific\\n{@link IShoppingSaleQuestion question} or {@link IShoppingSaleReview review}.\\n\\nBy the way, as is the general policy of this shopping mall regarding\\ncomments, modifying a comment does not actually change the existing content.\\nModified content is accumulated and recorded in the existing comment record\\nas a new {@link IShoppingSaleInquiryComment.ISnapshot snapshot}. And this\\nis made public to everyone, who can read this inquiry comment.\\n\\nThis is to prevent customers or sellers from modifying their comments and\\nmanipulating the circumstances due to the nature of e-commerce, where\\ndisputes easily arise. That is, to preserve evidence.\",\n        \"parameters\": [\n          {\n            \"name\": \"saleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Belonged sale's {@link IShoppingSale.id }\",\n            \"required\": true\n          },\n          {\n            \"name\": \"inquiryId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Belonged inquiry's {@link IShoppingSaleInquiry.id }\",\n            \"required\": true\n          },\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target inquiry comment's {@link IShoppingSaleInquiryComment.id }\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingSaleInquiryComment.ICreate\"\n              }\n            }\n          },\n          \"description\": \"Update info of the inquiry comment\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingSaleInquiryComment.ISnapshot\"\n                }\n              }\n            },\n            \"description\": \"Newly created snapshot record of the inquiry comment\"\n          }\n        }\n      }\n    },\n    \"/shoppings/admins/sales/{saleId}/questions\": {\n      \"patch\": {\n        \"summary\": \"List up every summarized questions\",\n        \"description\": \"List up every summarized questions.\\n\\nList up every {@link IShoppingSaleQuestion.ISummary summarized questions} of a\\n{@link IShoppingSale sale}.\\n\\nAs you can see, returned questions are summarized, not detailed. If you want\\nto get the detailed information of a question, use {@link adridges} function\\nor {@link at} function for each article.\\n\\nAlso, returned question has {@link IShoppingSaleQuestion.ISummary.answer}\\nproperty which means the formal answer from the {@link IShoppingSeller}.\\nAdditionally, returned question has another special property\\n{@link IShoppingSaleQuestion.ISummary.secret} with masking to other\\nprincple properties, and it means only related actors can {@link at read}\\nthe question.\\n\\nFor reference, if you're a {@link IShoppingSeller seller}, you can only\\naccess to the your own {@link IShoppingSale sale}'s questions. Otherwise,\\nyou can access to every questions of the sales.\\n\\nBy the way, if you want, you can limit the result by configuring\\n{@link IShoppingSaleQuestion.IRequest.search search condition} in the\\nrequest body. Also, it is possible to customize sequence order of records\\nby configuring {@link IShoppingSaleQuestion.IRequest.sort sort condition}.\",\n        \"parameters\": [\n          {\n            \"name\": \"saleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Belonged sale's {@link IShoppingSale.id }\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingSaleQuestion.IRequest\"\n              }\n            }\n          },\n          \"description\": \"Request info of pagination, searching and sorting\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPageIShoppingSaleQuestion.ISummary\"\n                }\n              }\n            },\n            \"description\": \"Paginated questions with summarized information\"\n          }\n        }\n      }\n    },\n    \"/shoppings/admins/sales/{saleId}/questions/abridges\": {\n      \"patch\": {\n        \"summary\": \"List up every abridged questions\",\n        \"description\": \"List up every abridged questions.\\n\\nList up every {@link IShoppingSaleQuestion.IAbridge abridged questions} of\\na {@link IShoppingSale sale}.\\n\\nAs you can see, returned questions are abridged, not detailed. If you want\\nto get the detailed information of a question, use {@link at} function\\nfor each article.\\n\\nAlso, returned question has {@link IShoppingSaleQuestion.IAridge.answer}\\nproperty which means the formal answer from the {@link IShoppingSeller}.\\nAdditionally, returned question has another special property\\n{@link IShoppingSaleQuestion.IAridge.secret} with masking to other\\nprincple properties, and it means only related actors can {@link at read}\\nthe question.\\n\\nFor reference, if you're a {@link IShoppingSeller seller}, you can only\\naccess to the your own {@link IShoppingSale sale}'s questions. Otherwise,\\nyou can access to every questions of the sales.\\n\\nBy the way, if you want, you can limit the result by configuring\\n{@link IShoppingSaleQuestion.IRequest.search search condition} in the\\nrequest body. Also, it is possible to customize sequence order of records\\nby configuring {@link IShoppingSaleQuestion.IRequest.sort sort condition}.\",\n        \"parameters\": [\n          {\n            \"name\": \"saleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Belonged sale's {@link IShoppingSale.id }\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingSaleQuestion.IRequest\"\n              }\n            }\n          },\n          \"description\": \"Request info of pagination, searching and sorting\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPageIShoppingSaleQuestion.IAbridge\"\n                }\n              }\n            },\n            \"description\": \"Paginated questions with abridged information\"\n          }\n        }\n      }\n    },\n    \"/shoppings/admins/sales/{saleId}/questions/{id}\": {\n      \"get\": {\n        \"summary\": \"Get a question info\",\n        \"description\": \"Get a question info.\\n\\nGet a detailed {@link IShoppingSaleQuestion question} information of a\\n{@link IShoppingSale sale}.\\n\\nFor reference, if you're a {@link IShoppingSeller seller}, you can only\\naccess to the your own {@link IShoppingSale sale}'s question. Otherwise\\nyou are a {@link IShoppingCustomer customer}, you can access to every\\nquestions of the sales except the {@link IShoppingSaleQuestion.secret}\\nvalue is `false`.\",\n        \"parameters\": [\n          {\n            \"name\": \"saleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Belonged sale's {@link IShoppingSale.id }\",\n            \"required\": true\n          },\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target question's {@link IShoppingSaleQuestion.id }\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingSaleQuestion\"\n                }\n              }\n            },\n            \"description\": \"Detailed question info\"\n          }\n        }\n      }\n    },\n    \"/shoppings/admins/sales/{saleId}/reviews/{inquiryId}/comments\": {\n      \"post\": {\n        \"summary\": \"Create an inquiry comment\",\n        \"description\": \"Create an inquiry comment.\\n\\nCreate an {@link IShoppingSaleInquiryComment inquiry comment} of a\\n{@link IShoppingSaleQuestion question} or {@link IShoppingSaleReview review}.\\n\\nFor reference, if you're a {@link IShoppingSeller seller}, you can only\\ncreate an inquiry comment to your own {@link IShoppingSale sale}'s inquiry.\\nOtherwise, you can create an inquiry comment to every inquiries of the sales.\",\n        \"parameters\": [\n          {\n            \"name\": \"saleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Belonged sale's {@link IShoppingSale.id }\",\n            \"required\": true\n          },\n          {\n            \"name\": \"inquiryId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target inquiry's {@link IShoppingSaleInquiry.id }\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingSaleInquiryComment.ICreate\"\n              }\n            }\n          },\n          \"description\": \"Creation info of the inquiry comment\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"201\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingSaleInquiryComment\"\n                }\n              }\n            },\n            \"description\": \"Newly created inquiry comment\"\n          }\n        }\n      },\n      \"patch\": {\n        \"summary\": \"List up every inquiry comments\",\n        \"description\": \"List up every inquiry comments.\\n\\nList up every {@link IShoppingSaleInquiryComment inquiry comments} of a\\n{@link IShoppingSaleQuestion question} or {@link IShoppingSaleReview review}\\nwith {@link IPage pagination}.\\n\\nIf you want, you can limit the result by configuring\\n{@link IShoppingSaleInquiryComment.IRequest.search search condition} in the\\nrequest body. Also, it is possible to customize sequence order of records\\nby configuring {@link IShoppingSaleInquiryComment.IRequest.sort sort condition}.\\n\\nBy the way, if you're a {@link IShoppingSeller seller}, you can only access\\nto the your own {@link IShoppingSale sale}'s inquiries. Otherwise, you\\ncan access to every inquiries of the sales.\",\n        \"parameters\": [\n          {\n            \"name\": \"saleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Belonged sale's {@link IShoppingSale.id }\",\n            \"required\": true\n          },\n          {\n            \"name\": \"inquiryId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Belonged inquiry's {@link IShoppingSaleInquiry.id }\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingSaleInquiryComment.IRequest\"\n              }\n            }\n          },\n          \"description\": \"Request info of pagination, searching and sorting\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPageIShoppingSaleInquiryComment\"\n                }\n              }\n            },\n            \"description\": \"Paginated inquiry comments\"\n          }\n        }\n      }\n    },\n    \"/shoppings/admins/sales/{saleId}/reviews/{inquiryId}/comments/{id}\": {\n      \"get\": {\n        \"summary\": \"Get an inquiry comment info\",\n        \"description\": \"Get an inquiry comment info.\\n\\nGet a detailed {@link IShoppingSaleInquiryComment inquiry comment}\\ninformation of a {@link IShoppingSaleQuestion question} or\\n{@link IShoppingSaleReview review}.\\n\\nFor reference, if you're a {@link IShoppingSeller seller}, you can only\\naccess to the your own {@link IShoppingSale sale}'s inquiry comment.\\nOtherwise, you can access to every inquiry comments of the sales.\",\n        \"parameters\": [\n          {\n            \"name\": \"saleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Belonged sale's {@link IShoppingSale.id }\",\n            \"required\": true\n          },\n          {\n            \"name\": \"inquiryId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Belonged inquiry's {@link IShoppingSaleInquiry.id }\",\n            \"required\": true\n          },\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target inquiry comment's {@link IShoppingSaleInquiryComment.id }\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingSaleInquiryComment\"\n                }\n              }\n            },\n            \"description\": \"Detailed inquiry comment info\"\n          }\n        }\n      },\n      \"put\": {\n        \"summary\": \"Update an inquiry comment\",\n        \"description\": \"Update an inquiry comment.\\n\\nUpdate an {@link IShoppingSaleInquiryComment inquiry comment} to a specific\\n{@link IShoppingSaleQuestion question} or {@link IShoppingSaleReview review}.\\n\\nBy the way, as is the general policy of this shopping mall regarding\\ncomments, modifying a comment does not actually change the existing content.\\nModified content is accumulated and recorded in the existing comment record\\nas a new {@link IShoppingSaleInquiryComment.ISnapshot snapshot}. And this\\nis made public to everyone, who can read this inquiry comment.\\n\\nThis is to prevent customers or sellers from modifying their comments and\\nmanipulating the circumstances due to the nature of e-commerce, where\\ndisputes easily arise. That is, to preserve evidence.\",\n        \"parameters\": [\n          {\n            \"name\": \"saleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Belonged sale's {@link IShoppingSale.id }\",\n            \"required\": true\n          },\n          {\n            \"name\": \"inquiryId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Belonged inquiry's {@link IShoppingSaleInquiry.id }\",\n            \"required\": true\n          },\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target inquiry comment's {@link IShoppingSaleInquiryComment.id }\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingSaleInquiryComment.ICreate\"\n              }\n            }\n          },\n          \"description\": \"Update info of the inquiry comment\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingSaleInquiryComment.ISnapshot\"\n                }\n              }\n            },\n            \"description\": \"Newly created snapshot record of the inquiry comment\"\n          }\n        }\n      }\n    },\n    \"/shoppings/admins/sales/{saleId}/reviews\": {\n      \"patch\": {\n        \"summary\": \"List up every summarized reviews\",\n        \"description\": \"List up every summarized reviews.\\n\\nList up every {@link IShoppingSaleReview.ISummary summarized reviews} of a\\n{@link IShoppingSale sale}.\\n\\nAs you can see, returned reviews are summarized, not detailed. If you want\\nto get the detailed information of a review, use {@link adridges} function\\nor {@link at} function for each article.\\n\\nAlso, returned review has {@link IShoppingSaleReview.ISummary.answer}\\nproperty which means the formal answer from the {@link IShoppingSeller}.\\n\\nFor reference, if you're a {@link IShoppingSeller seller}, you can only\\naccess to the your own {@link IShoppingSale sale}'s reviews. Otherwise,\\nyou can access to every reviews of the sales.\\n\\nBy the way, if you want, you can limit the result by configuring\\n{@link IShoppingSaleReview.IRequest.search search condition} in the\\nrequest body. Also, it is possible to customize sequence order of records\\nby configuring {@link IShoppingSaleReview.IRequest.sort sort condition}.\",\n        \"parameters\": [\n          {\n            \"name\": \"saleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Belonged sale's {@link IShoppingSale.id }\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingSaleReview.IRequest\"\n              }\n            }\n          },\n          \"description\": \"Request info of pagination, searching and sorting\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPageIShoppingSaleReview.ISummary\"\n                }\n              }\n            },\n            \"description\": \"Paginated reviews with summarized information\"\n          }\n        }\n      }\n    },\n    \"/shoppings/admins/sales/{saleId}/reviews/abridges\": {\n      \"patch\": {\n        \"summary\": \"List up every abridged reviews\",\n        \"description\": \"List up every abridged reviews.\\n\\nList up every {@link IShoppingSaleReview.IAbridge abridged reviews} of\\na {@link IShoppingSale sale}.\\n\\nAs you can see, returned reviews are abridged, not detailed. If you want\\nto get the detailed information of a review, use {@link at} function\\nfor each article.\\n\\nAlso, returned review has {@link IShoppingSaleReview.IAridge.answer}\\nproperty which means the formal answer from the {@link IShoppingSeller}.\\n\\nFor reference, if you're a {@link IShoppingSeller seller}, you can only\\naccess to the your own {@link IShoppingSale sale}'s reviews. Otherwise,\\nyou can access to every reviews of the sales.\\n\\nBy the way, if you want, you can limit the result by configuring\\n{@link IShoppingSaleReview.IRequest.search search condition} in the\\nrequest body. Also, it is possible to customize sequence order of records\\nby configuring {@link IShoppingSaleReview.IRequest.sort sort condition}.\",\n        \"parameters\": [\n          {\n            \"name\": \"saleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Belonged sale's {@link IShoppingSale.id }\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingSaleReview.IRequest\"\n              }\n            }\n          },\n          \"description\": \"Request info of pagination, searching and sorting\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPageIShoppingSaleReview.IAbridge\"\n                }\n              }\n            },\n            \"description\": \"Paginated reviews with abridged information\"\n          }\n        }\n      }\n    },\n    \"/shoppings/admins/sales/{saleId}/reviews/{id}\": {\n      \"get\": {\n        \"summary\": \"Get a review info\",\n        \"description\": \"Get a review info.\\n\\nGet a detailed {@link IShoppingSaleReview review} information of a\\n{@link IShoppingSale sale}.\\n\\nFor reference, if you're a {@link IShoppingSeller seller}, you can only\\naccess to the your own {@link IShoppingSale sale}'s review. Otherwise\\nyou are a {@link IShoppingCustomer customer}, you can access to every\\nreviews of the sales.\",\n        \"parameters\": [\n          {\n            \"name\": \"saleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Belonged sale's {@link IShoppingSale.id }\",\n            \"required\": true\n          },\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target review's {@link IShoppingSaleReview.id }\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingSaleReview\"\n                }\n              }\n            },\n            \"description\": \"Detailed review info\"\n          }\n        }\n      }\n    },\n    \"/shoppings/admins/sales/{saleId}/snapshots\": {\n      \"patch\": {\n        \"summary\": \"List up every snapshots\",\n        \"description\": \"List up every snapshots.\\n\\nWhenever {@link IShoppingSeller seller} updates a\\n{@link IShoppingSale sale}, the sale record is not updated but a new\\n{@link IShoppingSaleSnapshot snapshot} record is created to keep the\\nintegrity of the sale history. This API function is for listing up\\nsuch snapshot records.\\n\\nAlso, as you can see from the return type, returned snapshots are\\nsummarized, not detailed. If you want to get the detailed information\\nof a snapshot, use {@link at} or {@link flipo} function for each snapshot.\\n\\nFor reference, if you're a {@link IShoppingSeller seller}, you can only\\naccess to the your own {@link IShoppingSale sale}'s snapshots. Otherwise,\\nyou can access to every snapshots of the sales even though the sale has\\nbeen closed or suspended.\",\n        \"parameters\": [\n          {\n            \"name\": \"saleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target sale's {@link IShoppingSale.id }\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IPage.IRequest\"\n              }\n            }\n          },\n          \"description\": \"Requestion info of pagination\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPageIShoppingSaleSnapshot.ISummary\"\n                }\n              }\n            },\n            \"description\": \"Paginated snapshots with summarized information\"\n          }\n        }\n      }\n    },\n    \"/shoppings/admins/sales/{saleId}/snapshots/{id}\": {\n      \"get\": {\n        \"summary\": \"Get a snapshot info\",\n        \"description\": \"Get a snapshot info.\\n\\nGet a {@link IShoppingSaleSnapshot snapshot} with detailed information.\\n\\nAs you can see from the return type, returned snapshot does not contain\\nthe {@link IShoppingSale sale} info. If you want to get the sale info,\\nuse the {@link flip} function instead.\\n\\nFor reference, if you're a {@link IShoppingSeller seller}, you can only\\naccess to the your own {@link IShoppingSale sale}'s snapshots. Otherwise,\\nyou can access to every snapshots of the sales even though the sale has\\nbeen closed or suspended.\",\n        \"parameters\": [\n          {\n            \"name\": \"saleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Belonged sale's {@link IShoppingSale.id }\",\n            \"required\": true\n          },\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target snapshot's {@link IShoppingSaleSnapshot.id }\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingSaleSnapshot\"\n                }\n              }\n            },\n            \"description\": \"Detailed information of the snapshot\"\n          }\n        }\n      }\n    },\n    \"/shoppings/admins/sales/{saleId}/snapshots/{id}/flip\": {\n      \"get\": {\n        \"summary\": \"Get a flipped snapshot info\",\n        \"description\": \"Get a flipped snapshot info.\\n\\nGet a {@link IShoppingSale sale} info of a flipped snapshot.\\n\\nAs you can see from the return type, this function returns the\\n{@link IShoppingSale sale} info. By the way, the sale info is not the\\nlatest one, but a flipped info in the snapshot side.\\n\\nAlso, if you're a {@link IShoppingSeller seller}, you can only access to\\nthe your own {@link IShoppingSale sale}'s snapshots. Otherwise, you can\\naccess to every snapshots of the sales even though the sale has been\\nclosed or suspended.\",\n        \"parameters\": [\n          {\n            \"name\": \"saleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Belonged sale's {@link IShoppingSale.id }\",\n            \"required\": true\n          },\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target snapshot's {@link IShoppingSaleSnapshot.id }\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingSale\"\n                }\n              }\n            },\n            \"description\": \"Detailed sale information in the snapshot side\"\n          }\n        }\n      }\n    },\n    \"/shoppings/admins/systematic/channels/{channelCode}/categories\": {\n      \"post\": {\n        \"summary\": \"Create a new category\",\n        \"description\": \"Create a new category.\\n\\nCreate a new {@link IShoppingChannelCategory category} of a\\n{@link IShoppingChannel channel} with given name. If required, it is\\npossible to specify the parent category by its ID.\",\n        \"parameters\": [\n          {\n            \"name\": \"channelCode\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\"\n            },\n            \"description\": \" Belonged channel's {@link IShoppingChannel.code }\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingChannelCategory.ICreate\"\n              }\n            }\n          },\n          \"description\": \"Creation info of the category\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"201\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingChannelCategory\"\n                }\n              }\n            },\n            \"description\": \"Newly created category\"\n          }\n        }\n      },\n      \"patch\": {\n        \"summary\": \"List up every categories with children records\",\n        \"description\": \"List up every categories with children records.\\n\\nList up every {@link IShoppingChannelCategory.IHierarchical categories}\\nof a {@link IShoppingChannel channel} with pagination. Returned categories\\ncontain children categories, too.\\n\\nIf you want, you can limit the result by configuring\\n{@link IShoppingChannelCategory.IRequest.search search condition} in the\\nrequest body. Also, it is possible to customize sequence order of records\\nby configuring {@link IShoppingChannelCategory.IRequest.sort sort condition}.\",\n        \"parameters\": [\n          {\n            \"name\": \"channelCode\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\"\n            },\n            \"description\": \" Belonged channel's {@link IShoppingChannel.code }\",\n            \"required\": true\n          }\n        ]\n      }\n    },\n    \"/shoppings/admins/systematic/channels/{channelCode}/categories/{id}\": {\n      \"get\": {\n        \"summary\": \"Get a category info\",\n        \"description\": \"Get a category info.\\n\\nGet a detailed {@link IShoppingChannelCategory category} information.\\n\\nReturned category contains hierarchical children categories, and also\\ncontains the recursive parent categories, too.\",\n        \"parameters\": [\n          {\n            \"name\": \"channelCode\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\"\n            },\n            \"description\": \" Belonged channel's {@link IShoppingChannel.code }\",\n            \"required\": true\n          },\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target category's {@link IShoppingChannelCategory.id }\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingChannelCategory\"\n                }\n              }\n            },\n            \"description\": \"Detailed category info\"\n          }\n        }\n      },\n      \"put\": {\n        \"summary\": \"Update a category\",\n        \"description\": \"Update a category.\\n\\nUpdate a {@link IShoppingChannelCategory category}'s name. If required,\\nit is possible to change the parent category by its ID. Of course, detaching\\nfrom the parent category so that becoming the root category is also possible.\",\n        \"parameters\": [\n          {\n            \"name\": \"channelCode\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\"\n            },\n            \"description\": \" Belonged channel's {@link IShoppingChannel.code }\",\n            \"required\": true\n          },\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\"\n            },\n            \"description\": \" Target category's {@link IShoppingChannelCategory.id }\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingChannelCategory.ICreate\"\n              }\n            }\n          },\n          \"description\": \"Update info of the category\",\n          \"required\": true\n        }\n      }\n    },\n    \"/shoppings/admins/systematic/channels/{channelCode}/categories/merge\": {\n      \"delete\": {\n        \"summary\": \"Merge multiple categories into one\",\n        \"description\": \"Merge multiple categories into one.\\n\\nIn this shopping mall system, it is not possible to delete a\\n{@link IShoppingChannelCategory category}, because it is a systematic\\nentity affecting to all other core entities like\\n{@link IShoppingSale sales}. Instead of deleting, you can merge multiple\\ncategories into one.\\n\\nIf you specify a category to absorb others, then all of other categories\\nwill be merged into the specified one. Also, subsidiary entities of\\ncategories also be merged and their references also be merged cascadingly.\",\n        \"parameters\": [\n          {\n            \"name\": \"channelCode\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\"\n            },\n            \"description\": \" Belonged channel's {@link IShoppingChannel.code }\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IRecordMerge\"\n              }\n            }\n          },\n          \"description\": \"Merge info of the categories\",\n          \"required\": true\n        }\n      }\n    },\n    \"/shoppings/admins/systematic/channels/{channelCode}/categories/{id}/invert\": {\n      \"get\": {\n        \"summary\": \"Get a category info of inverted\",\n        \"description\": \"Get a category info of inverted.\\n\\nGet a inverted {@link IShoppingChannelCategory.IInvert category} information.\\n\\nReturned category contains the recursive parent categories, but not contains\\nthe hierarchical children categories.\",\n        \"parameters\": [\n          {\n            \"name\": \"channelCode\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\"\n            },\n            \"description\": \" Belonged channel's {@link IShoppingChannel.code }\",\n            \"required\": true\n          },\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target category's {@link IShoppingChannelCategory.id }\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingChannelCategory.IInvert\"\n                }\n              }\n            },\n            \"description\": \"Detailed category info\"\n          }\n        }\n      }\n    },\n    \"/shoppings/admins/systematic/channels\": {\n      \"post\": {\n        \"summary\": \"Create a new channel\",\n        \"description\": \"Create a new channel.\\n\\nCreate a new {@link IShoppingChannel channel} with given code and name.\\n\\nAs channel means an individual market,\\n{@link IShoppingAdministrator administrator} should perform this action\\nonly when a new application being registered.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingChannel.ICreate\"\n              }\n            }\n          },\n          \"description\": \"Creation info of the channel\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"201\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingChannel\"\n                }\n              }\n            },\n            \"description\": \"Newly created channel\"\n          }\n        }\n      },\n      \"patch\": {\n        \"summary\": \"List up every channels\",\n        \"description\": \"List up every channels.\\n\\nList up every {@link IShoppingChannel channels} with pagination.\\n\\nIf you want, you can limit the result by configuring\\n{@link IShoppingChannel.IRequest.search search condition} in the request\\nbody. Also, it is possible to customize sequence order of records by\\nconfiguring {@link IShoppingChannel.IRequest.sort sort condition}.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingChannel.IRequest\"\n              }\n            }\n          },\n          \"description\": \"Request info of pagination, searching and sorting\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPageIShoppingChannel\"\n                }\n              }\n            },\n            \"description\": \"Paginated channels\"\n          }\n        }\n      }\n    },\n    \"/shoppings/admins/systematic/channels/{id}\": {\n      \"get\": {\n        \"summary\": \"Get a channel info\",\n        \"description\": \"Get a channel info.\\n\\nGet a detailed {@link IShoppingChannel.IHierarchical channel} information.\\n\\nReturned channel instance also contains the nested\\n{@link IShoppingChannelCategory.IHierarchical hierarchical category}\\ninformation.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target channel's {@link IShoppingChannel.id }\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingChannel.IHierarchical\"\n                }\n              }\n            },\n            \"description\": \"Detailed channel info\"\n          }\n        }\n      },\n      \"put\": {\n        \"summary\": \"Update a channel\",\n        \"description\": \"Update a channel.\\n\\nUpdate a {@link IShoppingChannel channel}'s name.\\n\\nNote that, it is not possible to change the channel's code. If you want to\\nto do it forcibly, then {@link create} new one and {@link merge} with it.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target channel's {@link IShoppingChannel.code }\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingChannel.IUpdate\"\n              }\n            }\n          },\n          \"description\": \"Update info of the channel\",\n          \"required\": true\n        }\n      }\n    },\n    \"/shoppings/admins/systematic/channels/merge\": {\n      \"delete\": {\n        \"summary\": \"Merge multiple channels into one\",\n        \"description\": \"Merge multiple channels into one.\\n\\nIn this shopping mall system, it is not possible to delete a\\n{@link IShoppingChannel channel}, because it is a systematic entity\\naffecting to all other core entities like customers, members and\\nsales. Instead of deleting, you can merge multiple channels into one.\\n\\nIf you specify a channel to absorb others, then all of other channels\\nwill be merged into the specified one. Also, subsidiary entities of\\nchannels also be merged and their references also be merged cascadingly.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IRecordMerge\"\n              }\n            }\n          },\n          \"description\": \"Request info of the merge\",\n          \"required\": true\n        }\n      }\n    },\n    \"/shoppings/admins/systematic/channels/hierarchical\": {\n      \"patch\": {\n        \"summary\": \"List up every channels with nested categories\",\n        \"description\": \"List up every channels with nested categories.\\n\\nList up every {@link IShoppingChannel.IHierarchical channels} with\\n{@link IPage pagination}. Returned channels contain nested hierarchical\\n{@link IShoppingChannelCategory.IHierarchical categories}.\\n\\nIf you want, you can limit the result by configuring\\n{@link IShoppingChannel.IRequest.search search condition} in the request\\nbody. Also, it is possible to customize sequence order of records by\\nconfiguring {@link IShoppingChannel.IRequest.sort sort condition}.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingChannel.IRequest\"\n              }\n            }\n          },\n          \"description\": \"Request info of pagination, searching and sorting\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPageIShoppingChannel.IHierarchical\"\n                }\n              }\n            },\n            \"description\": \"Paginated channels with nested categories\"\n          }\n        }\n      }\n    },\n    \"/shoppings/admins/systematic/channels/{code}/get\": {\n      \"get\": {\n        \"summary\": \"Get a channel info by its code\",\n        \"description\": \"Get a channel info by its code.\\n\\nGet a detailed {@link IShoppingChannel.IHierarchical channel} information\\nby its code.\\n\\nReturned channel instance also contains the nested\\n{@link IShoppingChannelCategory.IHierarchical hierarchical category}\\ninformation.\",\n        \"parameters\": [\n          {\n            \"name\": \"code\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\"\n            },\n            \"description\": \" Target channel's {@link IShoppingChannel.code }\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingChannel.IHierarchical\"\n                }\n              }\n            },\n            \"description\": \"Detailed channel info\"\n          }\n        }\n      }\n    },\n    \"/shoppings/admins/systematic/sections\": {\n      \"post\": {\n        \"summary\": \"Create a new section\",\n        \"description\": \"Create a new section.\\n\\nCreate a new {@link IShoppingSection section} with given code and name.\\n\\nAs section means a spatial unit of a market that handling different type\\nof products with other section, {@link IShoppingAdministrator administrator}\\nshould perform this action only when a new section being required.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingSection.ICreate\"\n              }\n            }\n          },\n          \"description\": \"Creation info of the section\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"201\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingSection\"\n                }\n              }\n            },\n            \"description\": \"Newly created section\"\n          }\n        }\n      },\n      \"patch\": {\n        \"summary\": \"List up every sections\",\n        \"description\": \"List up every sections.\\n\\nList up every {@link IShoppingSection sections} with pagination.\\n\\nIf you want, you can limit the result by configuring\\n{@link IShoppingSection.IRequest.search search condition} in the request\\nbody. Also, it is possible to customize sequence order of records by\\nconfiguring {@link IShoppingSection.IRequest.sort sort condition}.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingSection.IRequest\"\n              }\n            }\n          },\n          \"description\": \"Request info of pagination, searching and sorting\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPageIShoppingSection\"\n                }\n              }\n            },\n            \"description\": \"Paginated sections\"\n          }\n        }\n      }\n    },\n    \"/shoppings/admins/systematic/sections/{id}\": {\n      \"get\": {\n        \"summary\": \"Get a section info\",\n        \"description\": \"Get a section info.\\n\\nGet a detailed {@link IShoppingSection section} information.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target section's {@link IShoppingSection.id }\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingSection\"\n                }\n              }\n            },\n            \"description\": \"Detailed section info\"\n          }\n        }\n      },\n      \"put\": {\n        \"summary\": \"Update a section\",\n        \"description\": \"Update a section.\\n\\nUpdate a {@link IShoppingSection section}'s name.\\n\\nNote that, it is not possible to change the section's code. If you want to\\nto do it forcibly, then {@link create} new one and {@link merge} with it.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target section's {@link IShoppingSection.code }\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingSection.IUpdate\"\n              }\n            }\n          },\n          \"description\": \"Update info of the section\",\n          \"required\": true\n        }\n      }\n    },\n    \"/shoppings/admins/systematic/sections/merge\": {\n      \"delete\": {\n        \"summary\": \"Merge multiple sections into one\",\n        \"description\": \"Merge multiple sections into one.\\n\\nIn this shopping mall system, it is not possible to delete a\\n{@link IShoppingSection section}, because it is a systematic entity\\naffecting to all other core entities like {@link IShoppingSale sales}.\\nInstead of deleting, you can merge multiple sections into one.\\n\\nIf you specify a section to absorb others, then all of other sections\\nwill be merged into the specified one. Also, subsidiary entities of\\nsections also be merged and their references also be merged cascadingly.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IRecordMerge\"\n              }\n            }\n          },\n          \"description\": \"input Request info of the merge\",\n          \"required\": true\n        }\n      }\n    },\n    \"/shoppings/admins/systematic/sections/{code}/get\": {\n      \"get\": {\n        \"summary\": \"Get a section info by its code\",\n        \"description\": \"Get a section info by its code.\\n\\nGet a detailed {@link IShoppingSection section} information by its code.\",\n        \"parameters\": [\n          {\n            \"name\": \"code\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\"\n            },\n            \"description\": \" Target section's {@link IShoppingSection.code }\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingSection\"\n                }\n              }\n            },\n            \"description\": \"Detailed section info\"\n          }\n        }\n      }\n    },\n    \"/shoppings/customers/authenticate/refresh\": {\n      \"patch\": {\n        \"summary\": \"Refresh the authentication token\",\n        \"description\": \"Refresh the authentication token.\\n\\nCreate a new {@link IShoppingCustomer.IToken.access access token} of a\\n{@link IShoppingCustomer customer} with the pre-issued\\n{@link IShoppingCustomer.IToken.refresh refresh} token.\\n\\nNote that, this function is available until the\\n{@link IShoppingCustomer.IToken.refreshable_until} value.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingCustomer.IRefresh\"\n              }\n            }\n          },\n          \"description\": \"Refresh token.\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingCustomer.IAuthorized\"\n                }\n              }\n            },\n            \"description\": \"Customer information with new token\"\n          }\n        }\n      }\n    },\n    \"/shoppings/customers/authenticate\": {\n      \"get\": {\n        \"summary\": \"Get current customer info\",\n        \"description\": \"Get current customer info.\\n\\nGet current {@link IShoppingCustomer customer} information from the\\n{@link IShoppingCustomer.IToken.access access token}.\",\n        \"parameters\": [],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingCustomer\"\n                }\n              }\n            },\n            \"description\": \"Current customer information\"\n          }\n        }\n      },\n      \"post\": {\n        \"summary\": \"Create a new customer record\",\n        \"description\": \"Create a new customer record.\\n\\nThis shopping mall system defines everyone participating in this market as\\na \\\"customer\\\". And the customer records are not archived based on individual\\n{@link IShoppingCitizen people}, but based on the unit of connection.\\nTherefore, even if it is the same person, a new {@link IShoppingCustomer}\\nrecord is created every time a connection is made.\\n\\nTherefore, all Client Applications that access this service must first call\\nthis function, report the customer's inflow path to the server, and create\\nan {@link IShoppingCustomer.IToken.access access token}. If you skip this\\nfunction call, all the other API functions would be prohibited. There is no\\nexception, even if you want to {@link activate} your citizenship or\\n{@link login} with your {@link IShoppingMember member account}. Before\\nauthenticating yourself or logging in, be sure to call this function first.\\nThis also applies when an {@link IShoppingAdministrator administrator} or\\n{@link IShoppingSeller seller} logs in.\\n\\nAlso, the authentication token has an\\n{@link IShoppingCustomer.IToken.expired_at expiration time}\\nand cannot be used permanently. For reference, the authentication token is\\nvalid for 3 hours, and if you want to maintain customer authentication even\\nafter 3 hours, you must call the {@link refresh} function.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingCustomer.ICreate\"\n              }\n            }\n          },\n          \"description\": \"Creation information of the customer.\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"201\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingCustomer.IAuthorized\"\n                }\n              }\n            },\n            \"description\": \"Created customer information with token.\"\n          }\n        }\n      }\n    },\n    \"/shoppings/customers/authenticate/join\": {\n      \"post\": {\n        \"summary\": \"Join membership\",\n        \"description\": \"Join membership.\\n\\n{@link IShoppingCustomer Customer} signs up for\\n{@link IShoppingMember membership} of current shopping mall system.\\n\\nIf you've performed the {@link IShoppingCitizen citizenship}\\n{@link activate activation} too, then you can skip the {@link activate}\\nfunction calling everytime you log in from now on. Also, if the person had\\n{@link IShoppingOrder purchased} with {@link activate} and {@link external}\\nfunction calling, you can also access to the order history too. In other\\nwords, activity details prior to membership registration can also be\\naccessed with continuity.\\n\\nFor reference, as described in the {@link create} function, before calling\\nthis `join` function, you must first create a customer record and token by\\ncalling the {@link create} function.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingMember.IJoin\"\n              }\n            }\n          },\n          \"description\": \"Join information of the member\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"201\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingCustomer\"\n                }\n              }\n            },\n            \"description\": \"Joined customer information\"\n          }\n        }\n      }\n    },\n    \"/shoppings/customers/authenticate/login\": {\n      \"put\": {\n        \"summary\": \"Membership login\",\n        \"description\": \"Membership login.\\n\\n{@link IShoppingCustomer Customer} logs in with his/her\\n{@link IShoppingMember membership} account with the email and password.\\n\\nIf the {@link IShoppingMember member} has previously performed\\n{@link activate citizenship activation}, the {@link IShoppingCustomer.citizen}\\nvalue would be filled in accordingly. And if the member has also signed up\\nas an {@link IShoppingAdministrator administrator} or\\n{@link IShoppingSeller seller}, the relevant information is also entered\\naccordingly.\\n\\nFor reference, as described in the {@link create} function, before calling\\nthis `login` function, you must first create a customer record and token by\\ncalling the {@link create} function.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingMember.ILogin\"\n              }\n            }\n          },\n          \"description\": \"Login request info\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingCustomer\"\n                }\n              }\n            },\n            \"description\": \"Logged in Customer information\"\n          }\n        }\n      }\n    },\n    \"/shoppings/customers/authenticate/activate\": {\n      \"post\": {\n        \"summary\": \"Activate citizenship\",\n        \"description\": \"Activate citizenship.\\n\\n{@link IShoppingCustomer Customer} activates his/her\\n{@link IShoppingCitizen citizenship} with mobile number and real name.\\n\\nIf the custommer already {@link join joined} to the\\n{@link IShoppingMember membership}, then you can skip the citizenship\\n{@link activation} function calling everytime you log in from now on.\\nOf course, such story would be same to the {@link external} function, too.\\n\\nFor reference, as described in the {@link create} function, before calling\\nthis `activate` function, you must first create a customer record and token\\nby calling the {@link create} function.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingCitizen.ICreate\"\n              }\n            }\n          },\n          \"description\": \"Activation information of the citizenship\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"201\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingCustomer\"\n                }\n              }\n            },\n            \"description\": \"Activated customer information\"\n          }\n        }\n      }\n    },\n    \"/shoppings/customers/authenticate/external\": {\n      \"post\": {\n        \"summary\": \"Enroll external user info\",\n        \"description\": \"Enroll external user info.\\n\\n{@link IShoppingCustomer Customer} enrolls his/her\\n{@link IShoppingExternalUser external user} information from other service.\\n\\nIt has similar effect with the {@link join membership joining} function,\\nso that if you've performed the {@link IShoppingCitizen citizenship}\\n{@link activate activation} too, then you can skip the {@link activate}\\nfunction calling everytime you call this `external` function with same\\ninfo from now on. Also, if the person had\\n{@link IShoppingOrder purchased} with {@link activate} and {@link join}\\nfunction calling, you can also access to the order history too. In other\\nwords, activity details prior to external server registration can also be\\naccessed with continuity.\\n\\nFor reference, as described in the {@link create} function, before calling\\nthis `external` function, you must first create a customer record and token\\nby calling the {@link create} function.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingExternalUser.ICreate\"\n              }\n            }\n          },\n          \"description\": \"Enroll information of the external user\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"201\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingCustomer\"\n                }\n              }\n            },\n            \"description\": \"External user enrolled customer information\"\n          }\n        }\n      }\n    },\n    \"/shoppings/customers/authenticate/password/change\": {\n      \"put\": {\n        \"summary\": \"Change password\",\n        \"description\": \"Change password.\\n\\nChange password of {@link IShoppingMember member} with the current password.\\n\\nThe reason why the current password is required is for security.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingMember.IPasswordChange\"\n              }\n            }\n          },\n          \"description\": \"New password and current password\",\n          \"required\": true\n        }\n      }\n    },\n    \"/shoppings/customers/coupons\": {\n      \"patch\": {\n        \"summary\": \"List up every coupons\",\n        \"description\": \"List up every coupons.\\n\\nList up every {@link IShoppingCoupon coupons} with pagination.\\n\\nIf you want, you can limit the result by configuring\\n{@link IShoppingCoupon.IRequest.search search condition} in the request\\nbody. Also, it is possible to customize sequence order of records by\\nconfiguring {@link IShoppingCoupon.IRequest.sort sort condition}.\\n\\nFor reference, if you are a {@link IShoppingCustomer customer}, then\\nonly {@link IShoppingCouponTicket ticketable} coupons would be listed up.\\nOtherwise, non-ticketable coupons would also be listed up.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingCoupon.IRequest\"\n              }\n            }\n          },\n          \"description\": \"Request info of pagination, searching and sorting\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPageIShoppingCoupon\"\n                }\n              }\n            },\n            \"description\": \"Paginated coupons\"\n          }\n        }\n      }\n    },\n    \"/shoppings/customers/coupons/{id}\": {\n      \"get\": {\n        \"summary\": \"Get a coupon info\",\n        \"description\": \"Get a coupon info.\\n\\nGet a {@link IShoppingCoupon coupon} information.\\n\\nIf you are a {@link IShoppingCustomer customer}, then only\\n{@link IShoppingCouponTicket ticketable} coupons are accessible. Non\\nticketable coupons cause 410 gone error. Otherwise you are a\\n{@link IShoppingSeller seller} or {@link IShoppingAdministrator administrator},\\nnon-ticketable coupons are also accessible.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\"\n            },\n            \"description\": \" Target coupon's {@link IShoppingCoupon.id }\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingCoupon\"\n                }\n              }\n            },\n            \"description\": \"Coupon info\"\n          }\n        }\n      }\n    },\n    \"/shoppings/customers/coupons/tickets\": {\n      \"post\": {\n        \"summary\": \"Create a new coupon ticket\",\n        \"description\": \"Create a new coupon ticket.\\n\\nCreate a new {@link IShoppingCouponTicket coupon ticket} of a specific\\n{@link IShoppingCoupon coupon} for the {@link IShoppingCustomer customer}.\\n\\nBy the way, if the target coupon has been\\n{@link IShoppingCoupon.expired_at expired} or\\n{@link IShoppingCoupon.IInventory.volume out of stock} or\\n{@link IShoppingCoupon.IInventory.volume_per_citizen exhausted for him/her},\\n410 gone exception would be thrown.\\n\\nAlso, even though succeeded to create a new coupon ticket from the target\\ncoupon, if the coupon has expiration day or date, the newly created ticket\\nalso has {@link IShoppingCouponTicket.expired_at expiration time}, and it\\nwould be disabled after the expiration time.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingCouponTicket.ICreate\"\n              }\n            }\n          },\n          \"description\": \"Creation info of coupon ticket\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"201\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingCouponTicket\"\n                }\n              }\n            },\n            \"description\": \"Newly created coupon ticket\"\n          }\n        }\n      },\n      \"patch\": {\n        \"summary\": \"List up every coupon tickets\",\n        \"description\": \"List up every coupon tickets.\\n\\nList up every {@link IShoppingCouponTicket coupon tickets} of the\\n{@link IShoppingCustomer customer} with {@link IPage pagination}.\\n\\nFor reference, coupon ticket means that a {@link IShoppingCoupon coupon}\\nhas been taken by a customer. If the target coupon has expiration day or\\ndate, the coupon ticket also has\\n{@link IShoppingCouponTicket.expired_at expiration time}, and such expired\\ntickets would not be listed up. Likewise, tickets used to\\n{@link IShoppingCouponTicketPayment pay} for the {@link IShoppingOrder order}\\nwould not be listed up, either.\\n\\nAdditionally, you can limit the result by configuring\\n{@link IShoppingCouponTicket.IRequest.search search condition} in the request\\nbody. Also, it is possible to customize sequence order of records by\\nconfiguring {@link IShoppingCouponTicket.IRequest.sort sort condition}.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingCouponTicket.IRequest\"\n              }\n            }\n          },\n          \"description\": \"Request info of pagination, searching and sorting\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPageIShoppingCouponTicket\"\n                }\n              }\n            },\n            \"description\": \"Paginated coupon tickets\"\n          }\n        }\n      }\n    },\n    \"/shoppings/customers/coupons/tickets/{id}\": {\n      \"get\": {\n        \"summary\": \"Get a coupon ticket\",\n        \"description\": \"Get a coupon ticket.\\n\\nGet a {@link IShoppingCouponTicket coupon ticket} information with its ID.\\n\\nBy the way, if the target coupon ticket has been\\n{@link IShoppingCouponTicket.expired_at expired} or used to\\n{@link IShoppingCouponTicketPayment pay} for the {@link IShoppingOrder order},\\n410 gone exception would be thrown.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target coupon ticket's {@link IShoppingCouponTicket.id }\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingCouponTicket\"\n                }\n              }\n            },\n            \"description\": \"Coupon ticket info\"\n          }\n        }\n      }\n    },\n    \"/shoppings/customers/deposits/charges\": {\n      \"post\": {\n        \"summary\": \"Create a new deposit charge application\",\n        \"description\": \"Create a new deposit charge application.\\n\\nCreate a new {@link IShoppingDepositCharge deposit charge application}.\\n\\nBy the way, this function does not mean completion the deposit charge, but\\nmeans just {@link IShoppingCustomer customer} is applying the deposit charge.\\nThe deposit charge be completed only when customer\\n{@link IShoppingDepositChargePublish.publish pay} the deposit charge.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingDepositCharge.ICreate\"\n              }\n            }\n          },\n          \"description\": \"Creation info of the deposit charge\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"201\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingDepositCharge\"\n                }\n              }\n            },\n            \"description\": \"Newly created deposit charge\"\n          }\n        }\n      },\n      \"patch\": {\n        \"summary\": \"List up every deposit charges\",\n        \"description\": \"List up every deposit charges.\\n\\nList up every {@link IShoppingDepositCharge deposit charges} of the\\n{@link IShoppingCustomer customer} with {@link IPage pagination}.\\n\\nIf you want, you can limit the result by configuring\\n{@link IShoppingDepositCharge.IRequest.search search condition} in the\\nrequest body. Also, it is possible to customize sequence order of records\\nby configuring {@link IShoppingDepositCharge.IRequest.sort sort condition}.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingDepositCharge.IRequest\"\n              }\n            }\n          },\n          \"description\": \"Request info of pagination, searching and sorting\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPageIShoppingDepositCharge\"\n                }\n              }\n            },\n            \"description\": \"Paginated deposit charges\"\n          }\n        }\n      }\n    },\n    \"/shoppings/customers/deposits/charges/{id}\": {\n      \"get\": {\n        \"summary\": \"Get a deposit charge info\",\n        \"description\": \"Get a deposit charge info.\\n\\nGet a {@link IShoppingDepositCharge deposit charge} information.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\"\n            },\n            \"description\": \" Target deposit charge's {@link IShoppingDepositCharge.id }\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingDepositCharge\"\n                }\n              }\n            },\n            \"description\": \"Deposit charge info\"\n          }\n        }\n      },\n      \"put\": {\n        \"summary\": \"Update a deposit charge application\",\n        \"description\": \"Update a deposit charge application.\\n\\nUpdate value of a {@link IShoppingDepositCharge deposit charge application}\\nthat has been applied by the {@link IShoppingCustomer}.\\n\\nIf the charge has been {@link IShoppingDepositChargePublish published},\\nthen it is not possible to update the deposit charge. Only 410 gone exception\\nwould be thrown.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\"\n            },\n            \"description\": \" Target deposit charge's {@link IShoppingDepositCharge.id }\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingDepositCharge.ICreate\"\n              }\n            }\n          },\n          \"description\": \"Value to change\",\n          \"required\": true\n        }\n      },\n      \"delete\": {\n        \"summary\": \"Erase a deposit charge application\",\n        \"description\": \"Erase a deposit charge application.\\n\\nErase a {@link IShoppingDepositCharge deposit charge application} that has been\\napplied by the {@link IShoppingCustomer}.\\n\\nIf the charge has been {@link IShoppingDepositChargePublish published}, then\\nit is not possible to erase the deposit charge. In that case, you've to cancel\\nthe payment by calling the {@link publish.cancel} function.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\"\n            },\n            \"description\": \" Target deposit charge's {@link IShoppingDepositCharge.id }\",\n            \"required\": true\n          }\n        ]\n      }\n    },\n    \"/shoppings/customers/deposits/charges/{chargeId}/publish/able\": {\n      \"get\": {\n        \"summary\": \"Check publishable\",\n        \"description\": \"Check publishable.\\n\\nTest whether the {@link IShoppingDepositCharge charge} is publishable or not.\\n\\nIf the charge has not been {@link IShoppingDepositChargePublish published} and\\nnot deleted yet, then it is possible to publish the charge\",\n        \"parameters\": [\n          {\n            \"name\": \"chargeId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target charge's {@link IShoppingDepositCharge.id }\",\n            \"required\": true\n          }\n        ]\n      }\n    },\n    \"/shoppings/customers/deposits/charges/{chargeId}/publish\": {\n      \"post\": {\n        \"summary\": \"Publish a charge\",\n        \"description\": \"Publish a charge.\\n\\n{@link IShoppingDepositChargePublish Publish} a\\n{@link IShoppingDepositCharge charge} that has been applied by the\\n{@link IShoppingCustomer} with payment information gotten from the\\npayment vendor system.\\n\\nAlso, the payment time can be different with the publish time. For example,\\nif the payment method is manual bank account transfer, then the payment\\nwould be delayed until the customer actually transfer the money. In that\\ncase, {@link IShoppingDepositChargePublish.paid_at} would be `null` value,\\nso that you have to check it after calling this publish function.\",\n        \"parameters\": [\n          {\n            \"name\": \"chargeId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target charge's {@link IShoppingDepositCharge.id }\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingDepositChargePublish.ICreate\"\n              }\n            }\n          },\n          \"description\": \"Creation info of the publish\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"201\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingDepositChargePublish\"\n                }\n              }\n            },\n            \"description\": \"Newly created publish\"\n          }\n        }\n      }\n    },\n    \"/shoppings/customers/deposits/histories\": {\n      \"patch\": {\n        \"summary\": \"List up every deposit histories\",\n        \"description\": \"List up every deposit histories.\\n\\nList up every {@link IShoppingDepositHistory deposit histories} of the\\n{@link IShoppingCustomer customer} with {@link IPage pagination}.\\n\\nIf you want, you can limit the result by configuring\\n{@link IShoppingDepositHistory.IRequest.search search condition} in the\\nrequest body. Also, it is possible to customize sequence order of records\\nby configuring {@link IShoppingDepositHistory.IRequest.sort sort condition}.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingDepositHistory.IRequest\"\n              }\n            }\n          },\n          \"description\": \"Request info of pagination, searching and sorting\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPageIShoppingDepositHistory\"\n                }\n              }\n            },\n            \"description\": \"Paginated deposit histories\"\n          }\n        }\n      }\n    },\n    \"/shoppings/customers/deposits/histories/{id}\": {\n      \"get\": {\n        \"summary\": \"Get a deposit history info\",\n        \"description\": \"Get a deposit history info.\\n\\nGet a {@link IShoppingDepositHistory deposit history} information.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Describe description as much as possible with clear and concise words.\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingDepositHistory\"\n                }\n              }\n            },\n            \"description\": \"Deposit history info\"\n          }\n        }\n      }\n    },\n    \"/shoppings/customers/deposits/histories/balance\": {\n      \"get\": {\n        \"summary\": \"Get balance of the deposit\",\n        \"description\": \"Get balance of the deposit.\\n\\nGet current balance of the deposit of the {@link IShoppingCustomer customer}.\",\n        \"parameters\": []\n      }\n    },\n    \"/shoppings/customers/mileages/histories\": {\n      \"patch\": {\n        \"summary\": \"List up every mileage histories\",\n        \"description\": \"List up every mileage histories.\\n\\nList up every {@link IShoppingMileageHistory mileage histories} of the\\n{@link IShoppingCustomer customer} with {@link IPage pagination}.\\n\\nIf you want, you can limit the result by configuring\\n{@link IShoppingMileageHistory.IRequest.search search condition} in the\\nrequest body. Also, it is possible to customize sequence order of records\\nby configuring {@link IShoppingMileageHistory.IRequest.sort sort condition}.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingMileageHistory.IRequest\"\n              }\n            }\n          },\n          \"description\": \"Request info of pagination, searching and sorting\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPageIShoppingMileageHistory\"\n                }\n              }\n            },\n            \"description\": \"Paginated mileage histories\"\n          }\n        }\n      }\n    },\n    \"/shoppings/customers/mileages/histories/{id}\": {\n      \"get\": {\n        \"summary\": \"Get a mileage history info\",\n        \"description\": \"Get a mileage history info.\\n\\nGet a {@link IShoppingMileageHistory mileage history} information.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target mileage history's {@link IShoppingMileageHistory.id }\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingMileageHistory\"\n                }\n              }\n            },\n            \"description\": \"Mileage history info\"\n          }\n        }\n      }\n    },\n    \"/shoppings/customers/mileages/histories/balance\": {\n      \"get\": {\n        \"summary\": \"Get balance of the mileage\",\n        \"description\": \"Get balance of the mileage.\\n\\nGet current balance of the mileage of the {@link IShoppingCustomer customer}.\",\n        \"parameters\": []\n      }\n    },\n    \"/shoppings/customers/carts/commodities\": {\n      \"post\": {\n        \"summary\": \"Create a new commodity\",\n        \"description\": \"Create a new commodity.\\n\\nCreate a new {@link IShoppingCartCommodity commodity} into a specific\\nshopping cart.\\n\\nIf {@link IShoppingCartCommodity.ICreate.accumulate} has `true` value\\nand there's some same commodity that composed with same\\n{@link IShoppingSaleUnitStock.IInvert stocks and quantities},\\nthen new commodity would not be created but the volume would be accumulated.\\n\\nBy the way, if the target {@link IShoppingSale sale} has been suspended or\\n{@link IShoppingSaleUnitStockInventory out of stock}, then 410 gone error\\nwould be thrown. Therefore, it would better to check the target sale and\\n{@link IShoppingSaleUnitStock stock}'s status before.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingCartCommodity.ICreate\"\n              }\n            }\n          },\n          \"description\": \"Creation info of the commodity\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"201\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingCartCommodity\"\n                }\n              }\n            },\n            \"description\": \"Newly created commodity\"\n          }\n        }\n      },\n      \"patch\": {\n        \"summary\": \"List of every commodities\",\n        \"description\": \"List of every commodities.\\n\\nList up every {@link IShoppingCartCommodity commodities} in the\\nshopping cart with {@link IPage pagination}.\\n\\nYou can limit the result by configuring\\n{@link IShoppingCartCommodity.IRequest.search search condition} in the\\nrequest body. Furthermore, it is possible to customize sequence order of\\nrecords by configuring {@link IShoppingCartCommodity.IRequest.sort}.\\n\\nFor reference, when some commodity be {@link IShoppingOrder ordered} and\\n{@link IShoppingOrderPublish published}, then it would not be appread in\\nthe shopping cart more. Otherwise, the order has not been published yet,\\nit would be appread in the shopping cart and still enable to create a new\\n{@link IShoppingOrder order application} with the same commodity.\\n\\nOf course, if the target {@link IShoppingSale sale} has been suspended, or\\n{@link IShoppingSaleUnitStockInventory out of stock}, then it would not be\\nappread in the shopping cart more, either.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingCartCommodity.IRequest\"\n              }\n            }\n          },\n          \"description\": \"Request info of pagination, searching and sorting\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPageIShoppingCartCommodity\"\n                }\n              }\n            },\n            \"description\": \"Paginated commodities\"\n          }\n        }\n      }\n    },\n    \"/shoppings/customers/carts/commodities/{id}\": {\n      \"get\": {\n        \"summary\": \"Get a commodity\",\n        \"description\": \"Get a commodity.\\n\\nGet a {@link IShoppingCartCommodity commodity} record of the shopping cart.\\n\\nIf target {@link IShoppingSale sale} has been suspended or\\n{@link IShoppingSaleUnitStockInventory out of stock}, then 410 gone error\\nwould be thrown. Therefore, even if you've created a commodity successfully\\nwith the {@link create} method, it still can be failed when you access the\\ncommodity with this {@link at} method.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target commodity's {@link IShoppingCartCommodity.id }\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingCartCommodity\"\n                }\n              }\n            },\n            \"description\": \"Detailed commodity info\"\n          }\n        }\n      },\n      \"put\": {\n        \"summary\": \"Update a commodity (volume)\",\n        \"description\": \"Update a commodity (volume).\\n\\nUpdate a {@link IShoppingCartCommodity commodity}'s volume in the\\nshopping cart.\\n\\nIf target {@link IShoppingSale sale} has been suspended or\\n{@link IShoppingSaleUnitStockInventory out of stock} suddenly, then 410\\ngone error would be thrown, either.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target commodity's {@link IShoppingCartCommodity.id }\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingCartCommodity.IUpdate\"\n              }\n            }\n          },\n          \"description\": \"Update info of the commodity (volume)\",\n          \"required\": true\n        }\n      },\n      \"delete\": {\n        \"summary\": \"Erase a commodity\",\n        \"description\": \"Erase a commodity.\\n\\nErase a {@link IShoppingCartCommodity commodity} from the shopping cart.\\n\\nIf the commodity is on an {@link IShoppingOrder order} process, it is not\\npossible to erase it. Instead, if the order has been\\n{@link IShoppingOrderPublish published}, then it would not be appread in\\nthe shopping cart more. If the order be erased, then you also can continue\\nerasinng the commodity, neither.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target commodity's {@link IShoppingCartCommodity.id }\",\n            \"required\": true\n          }\n        ]\n      }\n    },\n    \"/shoppings/customers/carts/commodities/{id}/replica\": {\n      \"get\": {\n        \"summary\": \"Get replica of a commodity\",\n        \"description\": \"Get replica of a commodity.\\n\\nGet a {@link IShoppingCartCommodity.ICreate} typed info of the target\\ncommodity for replication.\\n\\nIf target {@link IShoppingSale sale} has been suspended or\\n{@link IShoppingSaleUnitStockInventory out of stock} suddenly,\\nthen 410 gone error would be thrown, either.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target commodity's {@link IShoppingCartCommodity.id }\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingCartCommodity.ICreate\"\n                }\n              }\n            },\n            \"description\": \"Creation info of the commodity for replication\"\n          }\n        }\n      }\n    },\n    \"/shoppings/customers/carts/commodities/discountable\": {\n      \"patch\": {\n        \"summary\": \"Get discountable info\",\n        \"description\": \"Get discountable info.\\n\\nCompute discountable features about the\\n {@link IShoppingCartCommodity shopping cart} even including\\nnon-carted {@link IShoppingSale sales}.\\n\\nReturned {@link IShoppingCartDiscountable} contains including\\ncombinations of adjustable {@link IShoppingCoupon coupons},\\nwithdrawable {@link IShoppingDepositHistory deposits} and\\n{@link IShoppingMileageHistory mileages}.\\n\\nIf you want to know the discountable info about some specific sales\\nthat have not been carted yet, specify the sales to the\\n{@link IShoppingCartDiscountable.pseudos} property with composing\\n{@link IShoppingCartCommodity.ICreate creation info of the commodities}.\\nThen, they would be included in the discountable info.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingCartDiscountable.IRequest\"\n              }\n            }\n          },\n          \"description\": \"Request info for discountable\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingCartDiscountable\"\n                }\n              }\n            },\n            \"description\": \"Discountable info\"\n          }\n        }\n      }\n    },\n    \"/shoppings/customers/orders\": {\n      \"post\": {\n        \"summary\": \"Create a new order application\",\n        \"description\": \"Create a new order application.\\n\\nCreate a new {@link IShoppingOrder order application} from a\\n{@link IShoppingCartCommodity shopping cart} that has been composed by the\\n{@link IShoppingCustomer}. Of course, do not need to put every commodities\\nto the order, but possible to select some of them by the customer.\\n\\nBy the way, this function does not mean completion the order, but means\\njust customer is applying the order. The order be completed only when customer\\n{@link IShoppingOrderPublish.paid_at pays} the order.\\n\\n> If you are an A.I. chatbot, don't take a mistake that writing\\n> the `commodity_id` with the user selected stock ID. The\\n> `commodity_id` is the ID of the shopping cart commodity, not the\\n> stock ID. The stock ID is already included in the shopping cart\\n> commodity.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingOrder.ICreate\"\n              }\n            }\n          },\n          \"description\": \"Creation info of the order\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"201\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingOrder\"\n                }\n              }\n            },\n            \"description\": \"Newly created order\"\n          }\n        }\n      },\n      \"patch\": {\n        \"summary\": \"List up every orders\",\n        \"description\": \"List up every orders.\\n\\nList up every {@link IShoppingOrder orders} with pagination.\\n\\nIf you want, you can limit the result by configuring\\n{@link IShoppingOrder.IRequest.search search condition} in the request\\nbody. Also, it is possible to customize sequence order of records by\\nconfiguring {@link IShoppingOrder.IRequest.sort sort condition}.\\n\\nFor reference, if you are a {@link IShoppingCustomer customer}, then\\nyou can list up your own orders, and it is not a matter whether the\\norder has been {@link IShoppingOrderPublish.paid_at paid} or not.\\n\\nOtherwise you are a {@link IShoppingSeller seller} or\\n{@link IShoppingAdministrator administrator}, then you can list up\\nonly paid orders. Also, in the seller case, only related\\n{@link IShoppingOrder.goods goods} would be listed up in the order.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingOrder.IRequest\"\n              }\n            }\n          },\n          \"description\": \"Request info of pagination, searching and sorting\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPageIShoppingOrder\"\n                }\n              }\n            },\n            \"description\": \"Paginated orders\"\n          }\n        }\n      }\n    },\n    \"/shoppings/customers/orders/direct\": {\n      \"post\": {\n        \"summary\": \"Create a new order application without a shopping cart\",\n        \"description\": \"Create a new order application without a shopping cart.\\n\\nCarete a new {@link IShoppingOrder order application} without a\\n{@link IShoppingCartCommodity shopping cart commodity} composition.\\nIf you're an A.I. chatbot and user wants to directly purchase a product,\\nthen select and call this function.\\n\\nBy the way, this function does not mean completion the order, but means\\njust customer is applying the order. The order be completed only when customer\\n{@link IShoppingOrderPublish.paid_at pays} the order.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingCartCommodity.ICreate\"\n              }\n            }\n          },\n          \"description\": \"Creation info of the order without a shopping cart composition\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"201\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingOrder\"\n                }\n              }\n            },\n            \"description\": \"Newly created order\"\n          }\n        }\n      }\n    },\n    \"/shoppings/customers/orders/{id}\": {\n      \"get\": {\n        \"summary\": \"Get an order info\",\n        \"description\": \"Get an order info.\\n\\nGet a detailed {@link IShoppingOrder order} information.\\n\\nIf you are not a {@link IShoppingCustomer customer}, then you can't\\naccess to the order which has not been\\n{@link IShoppingOrderPublish.paid_at paid} yet. In that case,\\n404 not found error would be thrown.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target order's {@link IShoppingOrder.id }\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingOrder\"\n                }\n              }\n            },\n            \"description\": \"Order info\"\n          }\n        }\n      },\n      \"delete\": {\n        \"summary\": \"Erase an order application\",\n        \"description\": \"Erase an order application.\\n\\nErase an order application that has been applied by the\\n{@link IShoppingCustomer}.\\n\\nIf the order has been {@link IShoppingOrderPublish published}, then it is\\nnot possible to erase the order. In that case, you've to cancel the\\npayment by calling the {@link publish.cancel} function.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target order's {@link IShoppingOrder.id }\",\n            \"required\": true\n          }\n        ]\n      }\n    },\n    \"/shoppings/customers/orders/{id}/price\": {\n      \"get\": {\n        \"summary\": \"Get price of the order\",\n        \"description\": \"Get price of the order.\\n\\nGet detailed price information of the {@link IShoppingOrder order}.\\n\\nReturned price info contains not only the amount of the order, but also\\ncontains the discount amount by {@link IShoppingCoupono coupons},\\n{@link IShoppingDepositHistory deposits} and\\n{@link IShoppingMileageHistory mileages}.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target order's {@link IShoppingOrder.id }\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingOrderPrice\"\n                }\n              }\n            },\n            \"description\": \"Detailed price info with discount\"\n          }\n        }\n      }\n    },\n    \"/shoppings/customers/orders/{id}/discountable\": {\n      \"patch\": {\n        \"summary\": \"Get discountable info\",\n        \"description\": \"Get discountable info.\\n\\nCompute discountable features about the {@link IShoppingOrder}.\\n\\nReturned {@link IShoppingOrderDiscountable} contains including\\ncombinations of adjustable {@link IShoppingCoupon coupons},\\nwithdrawable {@link IShoppingDepositHistory deposits}\\nand {@link IShoppingMileageHistory mileages}.\\n\\nOf course, returned features are valid only when the order has not\\nbeen {@link IShoppingOrderPublish published} yet. If the order has\\nalready been published, then no way to discount the price more.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target order's {@link IShoppingOrder.id }\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingOrderDiscountable.IRequest\"\n              }\n            }\n          },\n          \"description\": \"Request info for discountable\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingOrderDiscountable\"\n                }\n              }\n            },\n            \"description\": \"Discountable info\"\n          }\n        }\n      }\n    },\n    \"/shoppings/customers/orders/{id}/discount\": {\n      \"put\": {\n        \"summary\": \"Discount the order\",\n        \"description\": \"Discount the order.\\n\\nDiscount total price of the {@link IShoppingOrder} by adjusting\\n{@link IShoppingCoupon coupons}, {@link IShoppingDepositHistory deposits}\\nand {@link IShoppingMileageHistory mileages}. If amount of discount\\nfeatures are equal to the total price of the order, it is possible to\\n{@link IShoppingOrderPublish publish} it without any cash.\\n\\nBy the way, the discounting features must be valid. If not, 428\\nunprocessable entity error would be thrown. To know which features are\\nadjustable or withdrawable, call the {@link discountable} function\\nbefore.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target order's {@link IShoppingOrder.id }\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingOrderPrice.ICreate\"\n              }\n            }\n          },\n          \"description\": \"Discount info\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingOrderPrice\"\n                }\n              }\n            },\n            \"description\": \"Detailed price info with discount\"\n          }\n        }\n      }\n    },\n    \"/shoppings/customers/orders/{orderId}/goods/{id}/confirm\": {\n      \"put\": {\n        \"summary\": \"Confirm an order good\",\n        \"description\": \"Confirm an order good.\\n\\nConfirm an {@link IShoppingOrderGood order good} that has been\\ncompleted {@link IShoppingDelivery delivering} to the\\n{@link IShoppingCustomer customer}.\\n\\nIn other words, belonged {@link IShoppingOrder order} must be\\n{@link IShoppingPublish.paid_at published, paid} and delivery of\\nthe good must be {@link IShoppingDeliveryJourney arrived} to the\\ncustomer. If not, 428 unprocessable entity error would be thrown.\",\n        \"parameters\": [\n          {\n            \"name\": \"orderId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Belonged order's {@link IShoppingOrder.id }\",\n            \"required\": true\n          },\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target good's {@link IShoppingOrderGood.id }\",\n            \"required\": true\n          }\n        ]\n      }\n    },\n    \"/shoppings/customers/orders/{orderId}/publish/able\": {\n      \"get\": {\n        \"summary\": \"Check publishable\",\n        \"description\": \"Check publishable.\\n\\nTest whether the {@link IShoppingOrder order} is publishable or not.\\n\\nIf the order has not been {@link IShoppingOrderPublish published} and\\nnot deleted yet, then it is possible to publish the order. Even thouogh\\ntarget {@link IShoppingSale sale} is suspended or\\n{@link IShoppingSaleUnitStockInventory out of stock}, it is still possible\\nto publish because the order already has been applied.\",\n        \"parameters\": [\n          {\n            \"name\": \"orderId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target order's {@link IShoppingOrder.id }\",\n            \"required\": true\n          }\n        ]\n      }\n    },\n    \"/shoppings/customers/orders/{orderId}/publish\": {\n      \"post\": {\n        \"summary\": \"Publish an order\",\n        \"description\": \"Publish an order.\\n\\n{@link IShoppingOrderPublish Publish} an {@link IShoppingOrder order} that\\nhas been applied by the {@link IShoppingCustomer} with\\n{@link IShoppingAddress address} to delivery and payment information gotten\\nfrom the payment vendor system.\\n\\nIf the order has been discounted for entire order price, then no need\\nto send payment vendor info. Instead, only address info is required.\\n\\nAlso, the payment time can be different with the publish time. For example,\\nif the payment method is manual bank account transfer, then the payment\\nwould be delayed until the customer actually transfer the money. In that\\ncase, {@link IShoppingOrderPublish.paid_at} would be `null` value, so\\nthat you have to check it after calling this publish function.\",\n        \"parameters\": [\n          {\n            \"name\": \"orderId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target order's {@link IShoppingOrder.id }\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingOrderPublish.ICreate\"\n              }\n            }\n          },\n          \"description\": \"Creation info of the publish\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"201\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingOrderPublish\"\n                }\n              }\n            },\n            \"description\": \"Newly created publish\"\n          }\n        }\n      },\n      \"delete\": {\n        \"summary\": \"Cancel the publish (payment)\",\n        \"description\": \"Cancel the publish (payment).\\n\\nCancel payment of an {@link IShoppingOrder order} that has been\\n{@link IShoppingOrderPublish published}.\\n\\nIf target publish's payment method is manual bank account transfer,\\nthen it would be cancelled directly. If not, then payment cancel\\nrequest would be sent to the payment vendor system.\",\n        \"parameters\": [\n          {\n            \"name\": \"orderId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target order's {@link IShoppingOrder.id }\",\n            \"required\": true\n          }\n        ]\n      }\n    },\n    \"/shoppings/customers/sales/details\": {\n      \"patch\": {\n        \"summary\": \"List up every sales\",\n        \"description\": \"List up every sales.\\n\\nList up every {@link IShoppingSale sales} with detailed information.\\n\\nAs you can see, returned sales are detailed, not summarized. If you want\\nto get the summarized information of sale for a brief, use {@link index}\\nfunction instead.\\n\\nFor reference, if you're a {@link IShoppingSeller seller}, you can only\\naccess to the your own {@link IShoppingSale sale}s. Otherwise you're a\\n{@link IShoppingCustomer customer}, you can see only the operating sales\\nin the market. Instead, you can't see the unopened, closed, or suspended\\nsales.\\n\\n> If you're an A.I. chatbot, please don't summarize the\\n> {@link IShoppingSaleUnitStock stock information}. Just list up the\\n> every stocks in the sale with detailed information.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingSale.IRequest\"\n              }\n            }\n          },\n          \"description\": \"Request info of pagination, searching and sorting\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPageIShoppingSale\"\n                }\n              }\n            },\n            \"description\": \"Paginated sales with detailed information\"\n          }\n        }\n      }\n    },\n    \"/shoppings/customers/sales\": {\n      \"patch\": {\n        \"summary\": \"List up every summarized sales\",\n        \"description\": \"List up every summarized sales.\\n\\nList up every {@link IShoppingSale.ISummary summarized sales}.\\n\\nAs you can see, returned sales are summarized, not detailed. It does not\\ncontain the SKU (Stock Keeping Unit) information represented by the\\n{@link IShoppingSaleUnitOption} and {@link IShoppingSaleUnitStock} types.\\nIf you want to get such detailed information of a sale, use\\n`GET /shoppings/customers/sales/{id}` operation for each sale.\\n\\n> If you're an A.I. chatbot, and the user wants to buy or compose\\n> {@link IShoppingCartCommodity shopping cart} from a sale, please\\n> call the `GET /shoppings/customers/sales/{id}` operation at least once\\n> to the target sale to get detailed SKU information about the sale.\\n> It needs to be run at least once for the next steps.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingSale.IRequest\"\n              }\n            }\n          },\n          \"description\": \"Request info of pagination, searching and sorting\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPageIShoppingSale.ISummary\"\n                }\n              }\n            },\n            \"description\": \"Paginated sales with summarized information\"\n          }\n        }\n      }\n    },\n    \"/shoppings/customers/sales/{id}\": {\n      \"get\": {\n        \"summary\": \"Get a sale with detailed information\",\n        \"description\": \"Get a sale with detailed information.\\n\\nGet a {@link IShoppingSale sale} with detailed information including\\nthe SKU (Stock Keeping Unit) information represented by the\\n{@link IShoppingSaleUnitOption} and {@link IShoppingSaleUnitStock} types.\\n\\n> If you're an A.I. chatbot, and the user wants to buy or compose a\\n> {@link IShoppingCartCommodity shopping cart} from a sale, please call\\n> this operation at least once to the target sale to get detailed SKU\\n> information about the sale.\\n>\\n> It needs to be run at least once for the next steps. In other words,\\n> if you A.I. agent has called this operation to a specific sale, you\\n> don't need to call this operation again for the same sale.\\n>\\n> Additionally, please do not summarize the SKU information. Just show\\n> the every options and stocks in the sale with detailed information.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target sale's {@link IShoppingSale.id }\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingSale\"\n                }\n              }\n            },\n            \"description\": \"Detailed sale information\"\n          }\n        }\n      }\n    },\n    \"/shoppings/customers/sales/{saleId}/questions/{inquiryId}/comments\": {\n      \"post\": {\n        \"summary\": \"Create an inquiry comment\",\n        \"description\": \"Create an inquiry comment.\\n\\nCreate an {@link IShoppingSaleInquiryComment inquiry comment} of a\\n{@link IShoppingSaleQuestion question} or {@link IShoppingSaleReview review}.\\n\\nFor reference, if you're a {@link IShoppingSeller seller}, you can only\\ncreate an inquiry comment to your own {@link IShoppingSale sale}'s inquiry.\\nOtherwise, you can create an inquiry comment to every inquiries of the sales.\",\n        \"parameters\": [\n          {\n            \"name\": \"saleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Belonged sale's {@link IShoppingSale.id }\",\n            \"required\": true\n          },\n          {\n            \"name\": \"inquiryId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target inquiry's {@link IShoppingSaleInquiry.id }\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingSaleInquiryComment.ICreate\"\n              }\n            }\n          },\n          \"description\": \"Creation info of the inquiry comment\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"201\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingSaleInquiryComment\"\n                }\n              }\n            },\n            \"description\": \"Newly created inquiry comment\"\n          }\n        }\n      },\n      \"patch\": {\n        \"summary\": \"List up every inquiry comments\",\n        \"description\": \"List up every inquiry comments.\\n\\nList up every {@link IShoppingSaleInquiryComment inquiry comments} of a\\n{@link IShoppingSaleQuestion question} or {@link IShoppingSaleReview review}\\nwith {@link IPage pagination}.\\n\\nIf you want, you can limit the result by configuring\\n{@link IShoppingSaleInquiryComment.IRequest.search search condition} in the\\nrequest body. Also, it is possible to customize sequence order of records\\nby configuring {@link IShoppingSaleInquiryComment.IRequest.sort sort condition}.\\n\\nBy the way, if you're a {@link IShoppingSeller seller}, you can only access\\nto the your own {@link IShoppingSale sale}'s inquiries. Otherwise, you\\ncan access to every inquiries of the sales.\",\n        \"parameters\": [\n          {\n            \"name\": \"saleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Belonged sale's {@link IShoppingSale.id }\",\n            \"required\": true\n          },\n          {\n            \"name\": \"inquiryId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Belonged inquiry's {@link IShoppingSaleInquiry.id }\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingSaleInquiryComment.IRequest\"\n              }\n            }\n          },\n          \"description\": \"Request info of pagination, searching and sorting\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPageIShoppingSaleInquiryComment\"\n                }\n              }\n            },\n            \"description\": \"Paginated inquiry comments\"\n          }\n        }\n      }\n    },\n    \"/shoppings/customers/sales/{saleId}/questions/{inquiryId}/comments/{id}\": {\n      \"get\": {\n        \"summary\": \"Get an inquiry comment info\",\n        \"description\": \"Get an inquiry comment info.\\n\\nGet a detailed {@link IShoppingSaleInquiryComment inquiry comment}\\ninformation of a {@link IShoppingSaleQuestion question} or\\n{@link IShoppingSaleReview review}.\\n\\nFor reference, if you're a {@link IShoppingSeller seller}, you can only\\naccess to the your own {@link IShoppingSale sale}'s inquiry comment.\\nOtherwise, you can access to every inquiry comments of the sales.\",\n        \"parameters\": [\n          {\n            \"name\": \"saleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Belonged sale's {@link IShoppingSale.id }\",\n            \"required\": true\n          },\n          {\n            \"name\": \"inquiryId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Belonged inquiry's {@link IShoppingSaleInquiry.id }\",\n            \"required\": true\n          },\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target inquiry comment's {@link IShoppingSaleInquiryComment.id }\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingSaleInquiryComment\"\n                }\n              }\n            },\n            \"description\": \"Detailed inquiry comment info\"\n          }\n        }\n      },\n      \"put\": {\n        \"summary\": \"Update an inquiry comment\",\n        \"description\": \"Update an inquiry comment.\\n\\nUpdate an {@link IShoppingSaleInquiryComment inquiry comment} to a specific\\n{@link IShoppingSaleQuestion question} or {@link IShoppingSaleReview review}.\\n\\nBy the way, as is the general policy of this shopping mall regarding\\ncomments, modifying a comment does not actually change the existing content.\\nModified content is accumulated and recorded in the existing comment record\\nas a new {@link IShoppingSaleInquiryComment.ISnapshot snapshot}. And this\\nis made public to everyone, who can read this inquiry comment.\\n\\nThis is to prevent customers or sellers from modifying their comments and\\nmanipulating the circumstances due to the nature of e-commerce, where\\ndisputes easily arise. That is, to preserve evidence.\",\n        \"parameters\": [\n          {\n            \"name\": \"saleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Belonged sale's {@link IShoppingSale.id }\",\n            \"required\": true\n          },\n          {\n            \"name\": \"inquiryId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Belonged inquiry's {@link IShoppingSaleInquiry.id }\",\n            \"required\": true\n          },\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target inquiry comment's {@link IShoppingSaleInquiryComment.id }\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingSaleInquiryComment.ICreate\"\n              }\n            }\n          },\n          \"description\": \"Update info of the inquiry comment\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingSaleInquiryComment.ISnapshot\"\n                }\n              }\n            },\n            \"description\": \"Newly created snapshot record of the inquiry comment\"\n          }\n        }\n      }\n    },\n    \"/shoppings/customers/sales/{saleId}/questions\": {\n      \"post\": {\n        \"summary\": \"Write a question article\",\n        \"description\": \"Write a question article.\\n\\nWhen a {@link IShoppingCustomer customer} wants to ask something about\\na specific {@link IShoppingSale sale}, he/she can ask it by writing a\\nnew {@link IShoppingSaleQuestion question article}.\\n\\nIf the customer does not want to reveal his/her identify and question,\\nhe/she can write the question as a secret article. In that case, only\\nthe customer and the related {@link IShoppingSeller seller} can see\\nthe {@link at detailed content}. Also, such secret question's title and\\nwriter name would be masked with `*` characters in the\\n{@link index pagiation API}.\",\n        \"parameters\": [\n          {\n            \"name\": \"saleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Belonged sale's {@link IShoppingSale.id }\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingSaleQuestion.ICreate\"\n              }\n            }\n          },\n          \"description\": \"Creation info of the question\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"201\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingSaleQuestion\"\n                }\n              }\n            },\n            \"description\": \"Newly created question\"\n          }\n        }\n      },\n      \"patch\": {\n        \"summary\": \"List up every summarized questions\",\n        \"description\": \"List up every summarized questions.\\n\\nList up every {@link IShoppingSaleQuestion.ISummary summarized questions} of a\\n{@link IShoppingSale sale}.\\n\\nAs you can see, returned questions are summarized, not detailed. If you want\\nto get the detailed information of a question, use {@link adridges} function\\nor {@link at} function for each article.\\n\\nAlso, returned question has {@link IShoppingSaleQuestion.ISummary.answer}\\nproperty which means the formal answer from the {@link IShoppingSeller}.\\nAdditionally, returned question has another special property\\n{@link IShoppingSaleQuestion.ISummary.secret} with masking to other\\nprincple properties, and it means only related actors can {@link at read}\\nthe question.\\n\\nFor reference, if you're a {@link IShoppingSeller seller}, you can only\\naccess to the your own {@link IShoppingSale sale}'s questions. Otherwise,\\nyou can access to every questions of the sales.\\n\\nBy the way, if you want, you can limit the result by configuring\\n{@link IShoppingSaleQuestion.IRequest.search search condition} in the\\nrequest body. Also, it is possible to customize sequence order of records\\nby configuring {@link IShoppingSaleQuestion.IRequest.sort sort condition}.\",\n        \"parameters\": [\n          {\n            \"name\": \"saleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Belonged sale's {@link IShoppingSale.id }\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingSaleQuestion.IRequest\"\n              }\n            }\n          },\n          \"description\": \"Request info of pagination, searching and sorting\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPageIShoppingSaleQuestion.ISummary\"\n                }\n              }\n            },\n            \"description\": \"Paginated questions with summarized information\"\n          }\n        }\n      }\n    },\n    \"/shoppings/customers/sales/{saleId}/questions/{id}\": {\n      \"get\": {\n        \"summary\": \"Get a question info\",\n        \"description\": \"Get a question info.\\n\\nGet a detailed {@link IShoppingSaleQuestion question} information of a\\n{@link IShoppingSale sale}.\\n\\nFor reference, if you're a {@link IShoppingSeller seller}, you can only\\naccess to the your own {@link IShoppingSale sale}'s question. Otherwise\\nyou are a {@link IShoppingCustomer customer}, you can access to every\\nquestions of the sales except the {@link IShoppingSaleQuestion.secret}\\nvalue is `false`.\",\n        \"parameters\": [\n          {\n            \"name\": \"saleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Belonged sale's {@link IShoppingSale.id }\",\n            \"required\": true\n          },\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target question's {@link IShoppingSaleQuestion.id }\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingSaleQuestion\"\n                }\n              }\n            },\n            \"description\": \"Detailed question info\"\n          }\n        }\n      },\n      \"post\": {\n        \"summary\": \"Update a question\",\n        \"description\": \"Update a question.\\n\\nUpdate a {@link IShoppingSaleQuestion question}'s content.\\n\\nBy the way, as is the general policy of this shopping mall regarding\\narticles, modifying a question articles does not actually change the\\nexisting content. Modified content is accumulated and recorded in the\\nexisting article record as a new\\n{@link IShoppingSaleQuestion.ISnapshot snapshot}. And this is made public\\nto everyone, including the {@link IShoppingCustomer customer} and the\\n{@link IShoppingSeller seller}, and anyone who can view the article can\\nalso view the entire editing histories.\\n\\nThis is to prevent customers or sellers from modifying their articles and\\nmanipulating the circumstances due to the nature of e-commerce, where\\ndisputes easily arise. That is, to preserve evidence.\",\n        \"parameters\": [\n          {\n            \"name\": \"saleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Belonged sale's {@link IShoppingSale.id }\",\n            \"required\": true\n          },\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target question's {@link IShoppingSaleQuestion.id }\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IBbsArticle.ICreate\"\n              }\n            }\n          },\n          \"description\": \"Update info of the question\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"201\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IBbsArticle.ISnapshot\"\n                }\n              }\n            },\n            \"description\": \"Newly created snapshot record of the question\"\n          }\n        }\n      }\n    },\n    \"/shoppings/customers/sales/{saleId}/questions/abridges\": {\n      \"patch\": {\n        \"summary\": \"List up every abridged questions\",\n        \"description\": \"List up every abridged questions.\\n\\nList up every {@link IShoppingSaleQuestion.IAbridge abridged questions} of\\na {@link IShoppingSale sale}.\\n\\nAs you can see, returned questions are abridged, not detailed. If you want\\nto get the detailed information of a question, use {@link at} function\\nfor each article.\\n\\nAlso, returned question has {@link IShoppingSaleQuestion.IAridge.answer}\\nproperty which means the formal answer from the {@link IShoppingSeller}.\\nAdditionally, returned question has another special property\\n{@link IShoppingSaleQuestion.IAridge.secret} with masking to other\\nprincple properties, and it means only related actors can {@link at read}\\nthe question.\\n\\nFor reference, if you're a {@link IShoppingSeller seller}, you can only\\naccess to the your own {@link IShoppingSale sale}'s questions. Otherwise,\\nyou can access to every questions of the sales.\\n\\nBy the way, if you want, you can limit the result by configuring\\n{@link IShoppingSaleQuestion.IRequest.search search condition} in the\\nrequest body. Also, it is possible to customize sequence order of records\\nby configuring {@link IShoppingSaleQuestion.IRequest.sort sort condition}.\",\n        \"parameters\": [\n          {\n            \"name\": \"saleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Belonged sale's {@link IShoppingSale.id }\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingSaleQuestion.IRequest\"\n              }\n            }\n          },\n          \"description\": \"Request info of pagination, searching and sorting\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPageIShoppingSaleQuestion.IAbridge\"\n                }\n              }\n            },\n            \"description\": \"Paginated questions with abridged information\"\n          }\n        }\n      }\n    },\n    \"/shoppings/customers/sales/{saleId}/reviews/{inquiryId}/comments\": {\n      \"post\": {\n        \"summary\": \"Create an inquiry comment\",\n        \"description\": \"Create an inquiry comment.\\n\\nCreate an {@link IShoppingSaleInquiryComment inquiry comment} of a\\n{@link IShoppingSaleQuestion question} or {@link IShoppingSaleReview review}.\\n\\nFor reference, if you're a {@link IShoppingSeller seller}, you can only\\ncreate an inquiry comment to your own {@link IShoppingSale sale}'s inquiry.\\nOtherwise, you can create an inquiry comment to every inquiries of the sales.\",\n        \"parameters\": [\n          {\n            \"name\": \"saleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Belonged sale's {@link IShoppingSale.id }\",\n            \"required\": true\n          },\n          {\n            \"name\": \"inquiryId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target inquiry's {@link IShoppingSaleInquiry.id }\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingSaleInquiryComment.ICreate\"\n              }\n            }\n          },\n          \"description\": \"Creation info of the inquiry comment\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"201\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingSaleInquiryComment\"\n                }\n              }\n            },\n            \"description\": \"Newly created inquiry comment\"\n          }\n        }\n      },\n      \"patch\": {\n        \"summary\": \"List up every inquiry comments\",\n        \"description\": \"List up every inquiry comments.\\n\\nList up every {@link IShoppingSaleInquiryComment inquiry comments} of a\\n{@link IShoppingSaleQuestion question} or {@link IShoppingSaleReview review}\\nwith {@link IPage pagination}.\\n\\nIf you want, you can limit the result by configuring\\n{@link IShoppingSaleInquiryComment.IRequest.search search condition} in the\\nrequest body. Also, it is possible to customize sequence order of records\\nby configuring {@link IShoppingSaleInquiryComment.IRequest.sort sort condition}.\\n\\nBy the way, if you're a {@link IShoppingSeller seller}, you can only access\\nto the your own {@link IShoppingSale sale}'s inquiries. Otherwise, you\\ncan access to every inquiries of the sales.\",\n        \"parameters\": [\n          {\n            \"name\": \"saleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Belonged sale's {@link IShoppingSale.id }\",\n            \"required\": true\n          },\n          {\n            \"name\": \"inquiryId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Belonged inquiry's {@link IShoppingSaleInquiry.id }\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingSaleInquiryComment.IRequest\"\n              }\n            }\n          },\n          \"description\": \"Request info of pagination, searching and sorting\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPageIShoppingSaleInquiryComment\"\n                }\n              }\n            },\n            \"description\": \"Paginated inquiry comments\"\n          }\n        }\n      }\n    },\n    \"/shoppings/customers/sales/{saleId}/reviews/{inquiryId}/comments/{id}\": {\n      \"get\": {\n        \"summary\": \"Get an inquiry comment info\",\n        \"description\": \"Get an inquiry comment info.\\n\\nGet a detailed {@link IShoppingSaleInquiryComment inquiry comment}\\ninformation of a {@link IShoppingSaleQuestion question} or\\n{@link IShoppingSaleReview review}.\\n\\nFor reference, if you're a {@link IShoppingSeller seller}, you can only\\naccess to the your own {@link IShoppingSale sale}'s inquiry comment.\\nOtherwise, you can access to every inquiry comments of the sales.\",\n        \"parameters\": [\n          {\n            \"name\": \"saleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Belonged sale's {@link IShoppingSale.id }\",\n            \"required\": true\n          },\n          {\n            \"name\": \"inquiryId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Belonged inquiry's {@link IShoppingSaleInquiry.id }\",\n            \"required\": true\n          },\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target inquiry comment's {@link IShoppingSaleInquiryComment.id }\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingSaleInquiryComment\"\n                }\n              }\n            },\n            \"description\": \"Detailed inquiry comment info\"\n          }\n        }\n      },\n      \"put\": {\n        \"summary\": \"Update an inquiry comment\",\n        \"description\": \"Update an inquiry comment.\\n\\nUpdate an {@link IShoppingSaleInquiryComment inquiry comment} to a specific\\n{@link IShoppingSaleQuestion question} or {@link IShoppingSaleReview review}.\\n\\nBy the way, as is the general policy of this shopping mall regarding\\ncomments, modifying a comment does not actually change the existing content.\\nModified content is accumulated and recorded in the existing comment record\\nas a new {@link IShoppingSaleInquiryComment.ISnapshot snapshot}. And this\\nis made public to everyone, who can read this inquiry comment.\\n\\nThis is to prevent customers or sellers from modifying their comments and\\nmanipulating the circumstances due to the nature of e-commerce, where\\ndisputes easily arise. That is, to preserve evidence.\",\n        \"parameters\": [\n          {\n            \"name\": \"saleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Belonged sale's {@link IShoppingSale.id }\",\n            \"required\": true\n          },\n          {\n            \"name\": \"inquiryId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Belonged inquiry's {@link IShoppingSaleInquiry.id }\",\n            \"required\": true\n          },\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target inquiry comment's {@link IShoppingSaleInquiryComment.id }\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingSaleInquiryComment.ICreate\"\n              }\n            }\n          },\n          \"description\": \"Update info of the inquiry comment\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingSaleInquiryComment.ISnapshot\"\n                }\n              }\n            },\n            \"description\": \"Newly created snapshot record of the inquiry comment\"\n          }\n        }\n      }\n    },\n    \"/shoppings/customers/sales/{saleId}/reviews\": {\n      \"post\": {\n        \"summary\": \"Write a review article\",\n        \"description\": \"Write a review article.\\n\\nWhen a {@link IShoppingCustomer customer} has purchased a specific\\n{@link IShoppingSale sale} and get {@link IShoppingDelivery delivered} it,\\nhe/she can write a {@link IShoppingSaleReview review} article about the sale.\\n\\nIf try to write a review article without purchasing or the delivery has not\\nbeen completed, 428 unprocessable entity error would be thrown. Also, the\\ncustomer can write multiple review articles per an order, but the next\\narticle can be written after 2 weeks from the previous article. If not,\\n428 unprocessable entity error would be thrown, either.\",\n        \"parameters\": [\n          {\n            \"name\": \"saleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Belonged sale's {@link IShoppingSale.id }\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingSaleReview.ICreate\"\n              }\n            }\n          },\n          \"description\": \"Creation info of the review\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"201\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingSaleReview\"\n                }\n              }\n            },\n            \"description\": \"Newly created review\"\n          }\n        }\n      },\n      \"patch\": {\n        \"summary\": \"List up every summarized reviews\",\n        \"description\": \"List up every summarized reviews.\\n\\nList up every {@link IShoppingSaleReview.ISummary summarized reviews} of a\\n{@link IShoppingSale sale}.\\n\\nAs you can see, returned reviews are summarized, not detailed. If you want\\nto get the detailed information of a review, use {@link adridges} function\\nor {@link at} function for each article.\\n\\nAlso, returned review has {@link IShoppingSaleReview.ISummary.answer}\\nproperty which means the formal answer from the {@link IShoppingSeller}.\\n\\nFor reference, if you're a {@link IShoppingSeller seller}, you can only\\naccess to the your own {@link IShoppingSale sale}'s reviews. Otherwise,\\nyou can access to every reviews of the sales.\\n\\nBy the way, if you want, you can limit the result by configuring\\n{@link IShoppingSaleReview.IRequest.search search condition} in the\\nrequest body. Also, it is possible to customize sequence order of records\\nby configuring {@link IShoppingSaleReview.IRequest.sort sort condition}.\",\n        \"parameters\": [\n          {\n            \"name\": \"saleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Belonged sale's {@link IShoppingSale.id }\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingSaleReview.IRequest\"\n              }\n            }\n          },\n          \"description\": \"Request info of pagination, searching and sorting\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPageIShoppingSaleReview.ISummary\"\n                }\n              }\n            },\n            \"description\": \"Paginated reviews with summarized information\"\n          }\n        }\n      }\n    },\n    \"/shoppings/customers/sales/{saleId}/reviews/{id}\": {\n      \"get\": {\n        \"summary\": \"Get a review info\",\n        \"description\": \"Get a review info.\\n\\nGet a detailed {@link IShoppingSaleReview review} information of a\\n{@link IShoppingSale sale}.\\n\\nFor reference, if you're a {@link IShoppingSeller seller}, you can only\\naccess to the your own {@link IShoppingSale sale}'s review. Otherwise\\nyou are a {@link IShoppingCustomer customer}, you can access to every\\nreviews of the sales.\",\n        \"parameters\": [\n          {\n            \"name\": \"saleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Belonged sale's {@link IShoppingSale.id }\",\n            \"required\": true\n          },\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target review's {@link IShoppingSaleReview.id }\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingSaleReview\"\n                }\n              }\n            },\n            \"description\": \"Detailed review info\"\n          }\n        }\n      },\n      \"post\": {\n        \"summary\": \"Update a review\",\n        \"description\": \"Update a review.\\n\\nUpdadte a {@link IShoppingSaleReview review}'s content and score.\\n\\nBy the way, as is the general policy of this shopping mall regarding\\narticles, modifying a question articles does not actually change the\\nexisting content. Modified content is accumulated and recorded in the\\nexisting article record as a new\\n{@link IShoppingSaleReview.ISnapshot snapshot}. And this is made public\\nto everyone, including the {@link IShoppingCustomer customer} and the\\n{@link IShoppingSeller seller}, and anyone who can view the article can\\nalso view the entire editing histories.\\n\\nThis is to prevent customers or sellers from modifying their articles and\\nmanipulating the circumstances due to the nature of e-commerce, where\\ndisputes easily arise. That is, to preserve evidence.\",\n        \"parameters\": [\n          {\n            \"name\": \"saleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Belonged sale's {@link IShoppingSale.id }\",\n            \"required\": true\n          },\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target review's {@link IShoppingSaleReview.id }\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingSaleReview.IUpdate\"\n              }\n            }\n          },\n          \"description\": \"Update info of the review\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"201\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingSaleReview.ISnapshot\"\n                }\n              }\n            },\n            \"description\": \"Newly created snapshot record of the review\"\n          }\n        }\n      }\n    },\n    \"/shoppings/customers/sales/{saleId}/reviews/abridges\": {\n      \"patch\": {\n        \"summary\": \"List up every abridged reviews\",\n        \"description\": \"List up every abridged reviews.\\n\\nList up every {@link IShoppingSaleReview.IAbridge abridged reviews} of\\na {@link IShoppingSale sale}.\\n\\nAs you can see, returned reviews are abridged, not detailed. If you want\\nto get the detailed information of a review, use {@link at} function\\nfor each article.\\n\\nAlso, returned review has {@link IShoppingSaleReview.IAridge.answer}\\nproperty which means the formal answer from the {@link IShoppingSeller}.\\n\\nFor reference, if you're a {@link IShoppingSeller seller}, you can only\\naccess to the your own {@link IShoppingSale sale}'s reviews. Otherwise,\\nyou can access to every reviews of the sales.\\n\\nBy the way, if you want, you can limit the result by configuring\\n{@link IShoppingSaleReview.IRequest.search search condition} in the\\nrequest body. Also, it is possible to customize sequence order of records\\nby configuring {@link IShoppingSaleReview.IRequest.sort sort condition}.\",\n        \"parameters\": [\n          {\n            \"name\": \"saleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Belonged sale's {@link IShoppingSale.id }\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingSaleReview.IRequest\"\n              }\n            }\n          },\n          \"description\": \"Request info of pagination, searching and sorting\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPageIShoppingSaleReview.IAbridge\"\n                }\n              }\n            },\n            \"description\": \"Paginated reviews with abridged information\"\n          }\n        }\n      }\n    },\n    \"/shoppings/customers/sales/{saleId}/snapshots\": {\n      \"patch\": {\n        \"summary\": \"List up every snapshots\",\n        \"description\": \"List up every snapshots.\\n\\nWhenever {@link IShoppingSeller seller} updates a\\n{@link IShoppingSale sale}, the sale record is not updated but a new\\n{@link IShoppingSaleSnapshot snapshot} record is created to keep the\\nintegrity of the sale history. This API function is for listing up\\nsuch snapshot records.\\n\\nAlso, as you can see from the return type, returned snapshots are\\nsummarized, not detailed. If you want to get the detailed information\\nof a snapshot, use {@link at} or {@link flipo} function for each snapshot.\\n\\nFor reference, if you're a {@link IShoppingSeller seller}, you can only\\naccess to the your own {@link IShoppingSale sale}'s snapshots. Otherwise,\\nyou can access to every snapshots of the sales even though the sale has\\nbeen closed or suspended.\",\n        \"parameters\": [\n          {\n            \"name\": \"saleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target sale's {@link IShoppingSale.id }\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IPage.IRequest\"\n              }\n            }\n          },\n          \"description\": \"Requestion info of pagination\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPageIShoppingSaleSnapshot.ISummary\"\n                }\n              }\n            },\n            \"description\": \"Paginated snapshots with summarized information\"\n          }\n        }\n      }\n    },\n    \"/shoppings/customers/sales/{saleId}/snapshots/{id}\": {\n      \"get\": {\n        \"summary\": \"Get a snapshot info\",\n        \"description\": \"Get a snapshot info.\\n\\nGet a {@link IShoppingSaleSnapshot snapshot} with detailed information.\\n\\nAs you can see from the return type, returned snapshot does not contain\\nthe {@link IShoppingSale sale} info. If you want to get the sale info,\\nuse the {@link flip} function instead.\\n\\nFor reference, if you're a {@link IShoppingSeller seller}, you can only\\naccess to the your own {@link IShoppingSale sale}'s snapshots. Otherwise,\\nyou can access to every snapshots of the sales even though the sale has\\nbeen closed or suspended.\",\n        \"parameters\": [\n          {\n            \"name\": \"saleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Belonged sale's {@link IShoppingSale.id }\",\n            \"required\": true\n          },\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target snapshot's {@link IShoppingSaleSnapshot.id }\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingSaleSnapshot\"\n                }\n              }\n            },\n            \"description\": \"Detailed information of the snapshot\"\n          }\n        }\n      }\n    },\n    \"/shoppings/customers/sales/{saleId}/snapshots/{id}/flip\": {\n      \"get\": {\n        \"summary\": \"Get a flipped snapshot info\",\n        \"description\": \"Get a flipped snapshot info.\\n\\nGet a {@link IShoppingSale sale} info of a flipped snapshot.\\n\\nAs you can see from the return type, this function returns the\\n{@link IShoppingSale sale} info. By the way, the sale info is not the\\nlatest one, but a flipped info in the snapshot side.\\n\\nAlso, if you're a {@link IShoppingSeller seller}, you can only access to\\nthe your own {@link IShoppingSale sale}'s snapshots. Otherwise, you can\\naccess to every snapshots of the sales even though the sale has been\\nclosed or suspended.\",\n        \"parameters\": [\n          {\n            \"name\": \"saleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Belonged sale's {@link IShoppingSale.id }\",\n            \"required\": true\n          },\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target snapshot's {@link IShoppingSaleSnapshot.id }\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingSale\"\n                }\n              }\n            },\n            \"description\": \"Detailed sale information in the snapshot side\"\n          }\n        }\n      }\n    },\n    \"/shoppings/customers/systematic/channels/{channelCode}/categories\": {\n      \"patch\": {\n        \"summary\": \"List up every categories with children records\",\n        \"description\": \"List up every categories with children records.\\n\\nList up every {@link IShoppingChannelCategory.IHierarchical categories}\\nof a {@link IShoppingChannel channel} with pagination. Returned categories\\ncontain children categories, too.\\n\\nIf you want, you can limit the result by configuring\\n{@link IShoppingChannelCategory.IRequest.search search condition} in the\\nrequest body. Also, it is possible to customize sequence order of records\\nby configuring {@link IShoppingChannelCategory.IRequest.sort sort condition}.\",\n        \"parameters\": [\n          {\n            \"name\": \"channelCode\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\"\n            },\n            \"description\": \" Belonged channel's {@link IShoppingChannel.code }\",\n            \"required\": true\n          }\n        ]\n      }\n    },\n    \"/shoppings/customers/systematic/channels/{channelCode}/categories/{id}\": {\n      \"get\": {\n        \"summary\": \"Get a category info\",\n        \"description\": \"Get a category info.\\n\\nGet a detailed {@link IShoppingChannelCategory category} information.\\n\\nReturned category contains hierarchical children categories, and also\\ncontains the recursive parent categories, too.\",\n        \"parameters\": [\n          {\n            \"name\": \"channelCode\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\"\n            },\n            \"description\": \" Belonged channel's {@link IShoppingChannel.code }\",\n            \"required\": true\n          },\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target category's {@link IShoppingChannelCategory.id }\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingChannelCategory\"\n                }\n              }\n            },\n            \"description\": \"Detailed category info\"\n          }\n        }\n      }\n    },\n    \"/shoppings/customers/systematic/channels/{channelCode}/categories/{id}/invert\": {\n      \"get\": {\n        \"summary\": \"Get a category info of inverted\",\n        \"description\": \"Get a category info of inverted.\\n\\nGet a inverted {@link IShoppingChannelCategory.IInvert category} information.\\n\\nReturned category contains the recursive parent categories, but not contains\\nthe hierarchical children categories.\",\n        \"parameters\": [\n          {\n            \"name\": \"channelCode\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\"\n            },\n            \"description\": \" Belonged channel's {@link IShoppingChannel.code }\",\n            \"required\": true\n          },\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target category's {@link IShoppingChannelCategory.id }\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingChannelCategory.IInvert\"\n                }\n              }\n            },\n            \"description\": \"Detailed category info\"\n          }\n        }\n      }\n    },\n    \"/shoppings/customers/systematic/channels\": {\n      \"patch\": {\n        \"summary\": \"List up every channels\",\n        \"description\": \"List up every channels.\\n\\nList up every {@link IShoppingChannel channels} with pagination.\\n\\nIf you want, you can limit the result by configuring\\n{@link IShoppingChannel.IRequest.search search condition} in the request\\nbody. Also, it is possible to customize sequence order of records by\\nconfiguring {@link IShoppingChannel.IRequest.sort sort condition}.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingChannel.IRequest\"\n              }\n            }\n          },\n          \"description\": \"Request info of pagination, searching and sorting\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPageIShoppingChannel\"\n                }\n              }\n            },\n            \"description\": \"Paginated channels\"\n          }\n        }\n      }\n    },\n    \"/shoppings/customers/systematic/channels/hierarchical\": {\n      \"patch\": {\n        \"summary\": \"List up every channels with nested categories\",\n        \"description\": \"List up every channels with nested categories.\\n\\nList up every {@link IShoppingChannel.IHierarchical channels} with\\n{@link IPage pagination}. Returned channels contain nested hierarchical\\n{@link IShoppingChannelCategory.IHierarchical categories}.\\n\\nIf you want, you can limit the result by configuring\\n{@link IShoppingChannel.IRequest.search search condition} in the request\\nbody. Also, it is possible to customize sequence order of records by\\nconfiguring {@link IShoppingChannel.IRequest.sort sort condition}.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingChannel.IRequest\"\n              }\n            }\n          },\n          \"description\": \"Request info of pagination, searching and sorting\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPageIShoppingChannel.IHierarchical\"\n                }\n              }\n            },\n            \"description\": \"Paginated channels with nested categories\"\n          }\n        }\n      }\n    },\n    \"/shoppings/customers/systematic/channels/{id}\": {\n      \"get\": {\n        \"summary\": \"Get a channel info\",\n        \"description\": \"Get a channel info.\\n\\nGet a detailed {@link IShoppingChannel.IHierarchical channel} information.\\n\\nReturned channel instance also contains the nested\\n{@link IShoppingChannelCategory.IHierarchical hierarchical category}\\ninformation.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target channel's {@link IShoppingChannel.id }\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingChannel.IHierarchical\"\n                }\n              }\n            },\n            \"description\": \"Detailed channel info\"\n          }\n        }\n      }\n    },\n    \"/shoppings/customers/systematic/channels/{code}/get\": {\n      \"get\": {\n        \"summary\": \"Get a channel info by its code\",\n        \"description\": \"Get a channel info by its code.\\n\\nGet a detailed {@link IShoppingChannel.IHierarchical channel} information\\nby its code.\\n\\nReturned channel instance also contains the nested\\n{@link IShoppingChannelCategory.IHierarchical hierarchical category}\\ninformation.\",\n        \"parameters\": [\n          {\n            \"name\": \"code\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\"\n            },\n            \"description\": \" Target channel's {@link IShoppingChannel.code }\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingChannel.IHierarchical\"\n                }\n              }\n            },\n            \"description\": \"Detailed channel info\"\n          }\n        }\n      }\n    },\n    \"/shoppings/customers/systematic/sections\": {\n      \"patch\": {\n        \"summary\": \"List up every sections\",\n        \"description\": \"List up every sections.\\n\\nList up every {@link IShoppingSection sections} with pagination.\\n\\nIf you want, you can limit the result by configuring\\n{@link IShoppingSection.IRequest.search search condition} in the request\\nbody. Also, it is possible to customize sequence order of records by\\nconfiguring {@link IShoppingSection.IRequest.sort sort condition}.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingSection.IRequest\"\n              }\n            }\n          },\n          \"description\": \"Request info of pagination, searching and sorting\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPageIShoppingSection\"\n                }\n              }\n            },\n            \"description\": \"Paginated sections\"\n          }\n        }\n      }\n    },\n    \"/shoppings/customers/systematic/sections/{id}\": {\n      \"get\": {\n        \"summary\": \"Get a section info\",\n        \"description\": \"Get a section info.\\n\\nGet a detailed {@link IShoppingSection section} information.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target section's {@link IShoppingSection.id }\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingSection\"\n                }\n              }\n            },\n            \"description\": \"Detailed section info\"\n          }\n        }\n      }\n    },\n    \"/shoppings/customers/systematic/sections/{code}/get\": {\n      \"get\": {\n        \"summary\": \"Get a section info by its code\",\n        \"description\": \"Get a section info by its code.\\n\\nGet a detailed {@link IShoppingSection section} information by its code.\",\n        \"parameters\": [\n          {\n            \"name\": \"code\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\"\n            },\n            \"description\": \" Target section's {@link IShoppingSection.code }\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingSection\"\n                }\n              }\n            },\n            \"description\": \"Detailed section info\"\n          }\n        }\n      }\n    },\n    \"/shoppings/sellers/authenticate\": {\n      \"get\": {\n        \"summary\": \"Get seller information\",\n        \"description\": \"Get seller information.\\n\\nGet {@link IShoppingSeller.IInvert seller} information of\\ncurrent {@link IShoppingCustomer customer}.\\n\\nIf current {@link IShoppingMember member} is not an seller,\\nit throws 403 forbidden exception.\",\n        \"parameters\": [],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingSeller.IInvert\"\n                }\n              }\n            },\n            \"description\": \"Seller info\"\n          }\n        }\n      },\n      \"post\": {\n        \"summary\": \"Join as an seller\",\n        \"description\": \"Join as an seller.\\n\\nJoin as an seller with {@link IShoppingSeller.IJoin joining info}.\\n\\nThis method is allowed only when the {@link IShoppingCustomer customer} already\\nhas joined the {@link IShoppingMember membership}. IF not, he (she) must\\naccomplish it before. If not, 403 forbidden exception would be thrown.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingSeller.IJoin\"\n              }\n            }\n          },\n          \"description\": \"Joining request info\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"201\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingSeller.IInvert\"\n                }\n              }\n            },\n            \"description\": \"Seller info\"\n          }\n        }\n      }\n    },\n    \"/shoppings/sellers/authenticate/login\": {\n      \"put\": {\n        \"summary\": \"Login as an seller\",\n        \"description\": \"Login as an seller.\\n\\nLogin as an seller with {@link IShoppingSeller.ILogin login info}.\\n\\nThis method has exactly same effect with\\n{@link ShoppingApi.functional.customers.authenticate.login} function, but\\nreturned type is a llttle different. The similar function returns\\n{@link IShoppingCustomer} type that starting from the customer information, so\\nthat you have to access to the seller info through\\n`customer.member.seller`. In contrast with that, this method returns\\n{@link IShoppingSeller.IInvert} type that starting from the seller\\ninfo, so that can access to the customer info through `seller.customer`.\\n\\nOf course, to use this function, you had to {@link join} as an seller\\nbefore. If not, 403 forbidden exception would be thrown,\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingMember.ILogin\"\n              }\n            }\n          },\n          \"description\": \"Login request info\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingSeller.IInvert\"\n                }\n              }\n            },\n            \"description\": \"Seller info\"\n          }\n        }\n      }\n    },\n    \"/shoppings/sellers/deliveries\": {\n      \"post\": {\n        \"summary\": \"Create a delivery\",\n        \"description\": \"Create a delivery.\\n\\nCreate a {@link IShoppingDelivery delivery} record targeting\\n{@link IShoppingOrder orders}, their {@link IShoppingOrderGood goods} and\\n{@link IShoppingSaleUnitStock stocks} ({@link IShoppingDeliveryPiece}) with\\n{@link IShoppingDeliveryJourney journeys} and\\n{@link IShoppingDeliveryShipper shippers} info.\\n\\nNote that, composition of the {@link IShoppingDeliveryPiece} must not over\\nthe required. To identify which pieces are required, recommend to call\\nthe {@link incompletes} function with target orders'\\n{@link IShoppingOrderPublish.id}s before calling this one.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingDelivery.ICreate\"\n              }\n            }\n          },\n          \"description\": \"Creation info of delivery\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"201\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingDelivery\"\n                }\n              }\n            },\n            \"description\": \"Newly created delivery\"\n          }\n        }\n      },\n      \"patch\": {\n        \"summary\": \"Get list of deliveries\",\n        \"description\": \"Get list of deliveries.\\n\\nGet list of {@link IShoppingDelivery.IInvert deliveries} of current\\n{@link IShoppingSeller seller} with {@link IPage pagination}.\\n\\nFor reference, returned deliveries are containing the target\\n{@link IShoppingOrder.IInvertFromDelivery order} information. Of course,\\nonly related {@link IShoppingOrderGood goods} are contained in the orders.\\n\\nAdditionally, you can limit the result by configuring\\n{@link IShoppingDelivery.IRequest.search search condition} in the request\\nbody. Also, it is possible to customize sequence order of records by\\nconfiguring {@link IShoppingDelivery.IRequest.sort sort condition}.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingDelivery.IRequest\"\n              }\n            }\n          },\n          \"description\": \"Request info of pagination, searching and sorting\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPageIShoppingDelivery.IInvert\"\n                }\n              }\n            },\n            \"description\": \"Paginated deliveries\"\n          }\n        }\n      }\n    },\n    \"/shoppings/sellers/deliveries/{id}\": {\n      \"get\": {\n        \"summary\": \"Get a delivery\",\n        \"description\": \"Get a delivery.\\n\\nGet a {@link IShoppingDelivery.IInvert delivery} information with its ID.\\n\\nFor reference, returned delivery is containing the target\\n{@link IShoppingOrder.IInvertFromDelivery order} information. Of course,\\nonly related {@link IShoppingOrderGood goods} are contained in the orders.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target delivery's {@link IShoppingDelivery.id }\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingDelivery.IInvert\"\n                }\n              }\n            },\n            \"description\": \"Delivery info with target orders\"\n          }\n        }\n      }\n    },\n    \"/shoppings/sellers/deliveries/incompletes\": {\n      \"patch\": {\n        \"summary\": \"Get list of incomplete pieces\",\n        \"description\": \"Get list of incomplete pieces.\\n\\nGet list of {@link IShoppingDeliveryPiece incomplete pieces} of target\\norders' {@link IShoppingOrderPublish.id}s.\\n\\nIf you specify target orders' publish IDs, then this function returns\\nincompleted pieces of the orders with computation as an Array of\\n{@link IShoppingDeliveryPiece.ICreate} type.\\n\\nYou can utillize the result to make a huge {@link IShoppingDelivery delivery}\\nfor integrated delivering, and also possible to make multiple deliveries for\\nsplit delivering.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingDeliveryPiece.IRequest\"\n              }\n            }\n          },\n          \"description\": \"List of target orders' \",\n          \"required\": true\n        }\n      }\n    },\n    \"/shoppings/sellers/deliveries/{deliveryId}/journeys\": {\n      \"post\": {\n        \"summary\": \"Create a new journey\",\n        \"description\": \"Create a new journey.\\n\\nCreate a new {@link IShoppingDeliveryJourney journey} of the\\n{@link IShoppingDelivery delivery}.\\n\\nThis action may change the related {@link IShoppingOrderGood.state}.\\nAlso, if the target journey's type is \\\"delivering\\\", whether the property\\n{@link IShoppingDeliveryJourney.completed_at} is null or not affects to\\nthe related goods' states. If the property is not null, the state becomes\\n\\\"arrived\\\". Otherwise, the state becomes \\\"delivering\\\".\",\n        \"parameters\": [\n          {\n            \"name\": \"deliveryId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Belonged delivery's {@link IShoppingDelivery.id }\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingDeliveryJourney.ICreate\"\n              }\n            }\n          },\n          \"description\": \"Creation info of the journey\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"201\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingDeliveryJourney\"\n                }\n              }\n            },\n            \"description\": \"Newly created journey\"\n          }\n        }\n      }\n    },\n    \"/shoppings/sellers/deliveries/{deliveryId}/journeys/{id}/complete\": {\n      \"put\": {\n        \"summary\": \"Complete a journey\",\n        \"description\": \"Complete a journey.\\n\\nComplete a {@link IShoppingDeliveryJourney journey} of the\\n{@link IShoppingDelivery delivery}. In other words, fills the\\n{@link IShoppingDeliveryJourney.completed_at} property with current time.\\n\\nIf the target journey's type is \\\"delivering\\\", this action may change\\nthe related {@link IShoppingOrderGood.state goods' states} to be \\\"arrived\\\".\",\n        \"parameters\": [\n          {\n            \"name\": \"deliveryId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Belonged delivery's {@link IShoppingDelivery.id }\",\n            \"required\": true\n          },\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target journey's {@link IShoppingDeliveryJourney.id }\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingDeliveryJourney.IComplete\"\n              }\n            }\n          },\n          \"description\": \"Completion time of the journey\",\n          \"required\": true\n        }\n      }\n    },\n    \"/shoppings/sellers/deliveries/{deliveryId}/journeys/{id}\": {\n      \"delete\": {\n        \"summary\": \"Erase a journey\",\n        \"description\": \"Erase a journey.\\n\\nErase a {@link IShoppingDeliveryJourney journey} of the\\n{@link IShoppingDelivery delivery}.\\n\\nIf erasing journey is the last one of the belonged delivery, this action\\nmay change the related {@link IShoppingOrderGood.state}. By erasing the last\\njourney, the state rolls back to the previous.\",\n        \"parameters\": [\n          {\n            \"name\": \"deliveryId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Belonged delivery's {@link IShoppingDelivery.id }\",\n            \"required\": true\n          },\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target journey's {@link IShoppingDeliveryJourney.id }\",\n            \"required\": true\n          }\n        ]\n      }\n    },\n    \"/shoppings/sellers/deliveries/{deliveryId}/shippers\": {\n      \"post\": {\n        \"summary\": \"Create a new shipper\",\n        \"description\": \"Create a new shipper.\\n\\nCreate a new {@link IShoppingDeliveryShipper shipper} of the\\n{@link IShoppingDelivery delivery}.\\n\\nThis action does not affect to the related {@link IShoppingOrder orders} or\\n{@link IShoppingOrderGood goods} like {@link IShoppingDeliveryJourney}\\nor {@link IShoppingDeliveryPiece} case, but just informs to the\\n{@link IShoppingCustomer customer}.\",\n        \"parameters\": [\n          {\n            \"name\": \"deliveryId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Belonged delivery's {@link IShoppingDelivery.id }\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingDeliveryShipper.ICreate\"\n              }\n            }\n          },\n          \"description\": \"Creation info of the shipper\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"201\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingDeliveryShipper\"\n                }\n              }\n            },\n            \"description\": \"Newly created shipper\"\n          }\n        }\n      }\n    },\n    \"/shoppings/sellers/coupons\": {\n      \"post\": {\n        \"summary\": \"Create a new coupon\",\n        \"description\": \"Create a new coupon.\\n\\nCreate a new {@link IShoppingCoupon coupon} with given information.\\n\\nBy the way, if you are a {@link IShoppingSeller seller}, you have to\\nadd include direction's {@link IShoppingCouponSellerCriteria} or\\n{@link IShoppingCouponSaleCriteria} condition. This is because only\\n{@link IShoppingAdministrator administrators} can create a coupon\\nwhich can be used throughout the market. Seller must limit the usage\\nrange by his/her {@link IShoppingSale sale(s)}.\\n\\nOf course, when administrator is planning to make a general coupon\\nthat can be used throughout the market, the administrator must\\nget agree from the sellers who are going to be affected.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingCoupon.ICreate\"\n              }\n            }\n          },\n          \"description\": \"Creation info of the coupon\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"201\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingCoupon\"\n                }\n              }\n            },\n            \"description\": \"Newly created coupon\"\n          }\n        }\n      },\n      \"patch\": {\n        \"summary\": \"List up every coupons\",\n        \"description\": \"List up every coupons.\\n\\nList up every {@link IShoppingCoupon coupons} with pagination.\\n\\nIf you want, you can limit the result by configuring\\n{@link IShoppingCoupon.IRequest.search search condition} in the request\\nbody. Also, it is possible to customize sequence order of records by\\nconfiguring {@link IShoppingCoupon.IRequest.sort sort condition}.\\n\\nFor reference, if you are a {@link IShoppingCustomer customer}, then\\nonly {@link IShoppingCouponTicket ticketable} coupons would be listed up.\\nOtherwise, non-ticketable coupons would also be listed up.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingCoupon.IRequest\"\n              }\n            }\n          },\n          \"description\": \"Request info of pagination, searching and sorting\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPageIShoppingCoupon\"\n                }\n              }\n            },\n            \"description\": \"Paginated coupons\"\n          }\n        }\n      }\n    },\n    \"/shoppings/sellers/coupons/{id}\": {\n      \"get\": {\n        \"summary\": \"Get a coupon info\",\n        \"description\": \"Get a coupon info.\\n\\nGet a {@link IShoppingCoupon coupon} information.\\n\\nIf you are a {@link IShoppingCustomer customer}, then only\\n{@link IShoppingCouponTicket ticketable} coupons are accessible. Non\\nticketable coupons cause 410 gone error. Otherwise you are a\\n{@link IShoppingSeller seller} or {@link IShoppingAdministrator administrator},\\nnon-ticketable coupons are also accessible.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\"\n            },\n            \"description\": \" Target coupon's {@link IShoppingCoupon.id }\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingCoupon\"\n                }\n              }\n            },\n            \"description\": \"Coupon info\"\n          }\n        }\n      },\n      \"delete\": {\n        \"summary\": \"Erase a coupon\",\n        \"description\": \"Erase a coupon.\\n\\nErase a {@link IShoppingCoupon coupon} with given ID.\\n\\nFor reference, if there're some {@link IShoppingCouponTicket tickets}\\nwhich are already issued from the target coupon, they would not be affected.\\nThose tickets are still valid until their expration time.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\"\n            },\n            \"description\": \" Target coupon's {@link IShoppingCoupon.id }\",\n            \"required\": true\n          }\n        ]\n      }\n    },\n    \"/shoppings/sellers/orders\": {\n      \"patch\": {\n        \"summary\": \"List up every orders\",\n        \"description\": \"List up every orders.\\n\\nList up every {@link IShoppingOrder orders} with pagination.\\n\\nIf you want, you can limit the result by configuring\\n{@link IShoppingOrder.IRequest.search search condition} in the request\\nbody. Also, it is possible to customize sequence order of records by\\nconfiguring {@link IShoppingOrder.IRequest.sort sort condition}.\\n\\nFor reference, if you are a {@link IShoppingCustomer customer}, then\\nyou can list up your own orders, and it is not a matter whether the\\norder has been {@link IShoppingOrderPublish.paid_at paid} or not.\\n\\nOtherwise you are a {@link IShoppingSeller seller} or\\n{@link IShoppingAdministrator administrator}, then you can list up\\nonly paid orders. Also, in the seller case, only related\\n{@link IShoppingOrder.goods goods} would be listed up in the order.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingOrder.IRequest\"\n              }\n            }\n          },\n          \"description\": \"Request info of pagination, searching and sorting\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPageIShoppingOrder\"\n                }\n              }\n            },\n            \"description\": \"Paginated orders\"\n          }\n        }\n      }\n    },\n    \"/shoppings/sellers/orders/{id}\": {\n      \"get\": {\n        \"summary\": \"Get an order info\",\n        \"description\": \"Get an order info.\\n\\nGet a detailed {@link IShoppingOrder order} information.\\n\\nIf you are not a {@link IShoppingCustomer customer}, then you can't\\naccess to the order which has not been\\n{@link IShoppingOrderPublish.paid_at paid} yet. In that case,\\n404 not found error would be thrown.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target order's {@link IShoppingOrder.id }\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingOrder\"\n                }\n              }\n            },\n            \"description\": \"Order info\"\n          }\n        }\n      }\n    },\n    \"/shoppings/sellers/sales\": {\n      \"post\": {\n        \"summary\": \"Create a sale\",\n        \"description\": \"Create a sale.\\n\\n{@link IShoppingSeller Seller} creates a new {@link IShoppingSale} for\\noperation.\\n\\nFor reference, sale has complicate hierarchical structure that composing\\nwith {@link IShoppingSaleUnit units}, {@link IShoppingSaleUnitOption options}\\nand {@link IShoppingSaleUnitStock stocks}. Therefore, I recommend you to\\nread the {@link IShoppingSale} and related DTOs' documents before creating\\na new sale.\\n\\nERD (Entity Relationship Diagram) and its description document also would\\nbe helpful, too.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingSale.ICreate\"\n              }\n            }\n          },\n          \"description\": \"Creation info of the sale\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"201\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingSale\"\n                }\n              }\n            },\n            \"description\": \"Newly created sale\"\n          }\n        }\n      },\n      \"patch\": {\n        \"summary\": \"List up every summarized sales\",\n        \"description\": \"List up every summarized sales.\\n\\nList up every {@link IShoppingSale.ISummary summarized sales}.\\n\\nAs you can see, returned sales are summarized, not detailed. It does not\\ncontain the SKU (Stock Keeping Unit) information represented by the\\n{@link IShoppingSaleUnitOption} and {@link IShoppingSaleUnitStock} types.\\nIf you want to get such detailed information of a sale, use\\n`GET /shoppings/customers/sales/{id}` operation for each sale.\\n\\n> If you're an A.I. chatbot, and the user wants to buy or compose\\n> {@link IShoppingCartCommodity shopping cart} from a sale, please\\n> call the `GET /shoppings/customers/sales/{id}` operation at least once\\n> to the target sale to get detailed SKU information about the sale.\\n> It needs to be run at least once for the next steps.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingSale.IRequest\"\n              }\n            }\n          },\n          \"description\": \"Request info of pagination, searching and sorting\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPageIShoppingSale.ISummary\"\n                }\n              }\n            },\n            \"description\": \"Paginated sales with summarized information\"\n          }\n        }\n      }\n    },\n    \"/shoppings/sellers/sales/{id}\": {\n      \"get\": {\n        \"summary\": \"Get a sale with detailed information\",\n        \"description\": \"Get a sale with detailed information.\\n\\nGet a {@link IShoppingSale sale} with detailed information including\\nthe SKU (Stock Keeping Unit) information represented by the\\n{@link IShoppingSaleUnitOption} and {@link IShoppingSaleUnitStock} types.\\n\\n> If you're an A.I. chatbot, and the user wants to buy or compose a\\n> {@link IShoppingCartCommodity shopping cart} from a sale, please call\\n> this operation at least once to the target sale to get detailed SKU\\n> information about the sale.\\n>\\n> It needs to be run at least once for the next steps. In other words,\\n> if you A.I. agent has called this operation to a specific sale, you\\n> don't need to call this operation again for the same sale.\\n>\\n> Additionally, please do not summarize the SKU information. Just show\\n> the every options and stocks in the sale with detailed information.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target sale's {@link IShoppingSale.id }\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingSale\"\n                }\n              }\n            },\n            \"description\": \"Detailed sale information\"\n          }\n        }\n      },\n      \"put\": {\n        \"summary\": \"Update a sale\",\n        \"description\": \"Update a sale.\\n\\nUpdate a {@link IShoppingSale sale} with new information.\\n\\nBy the way, the sale actually does not being modified, but just make a new\\n{@link IShoppingSaleSnapshot snapshot} record of the sale. Its 1st purpose\\nis to keeping the integrity of the sale, due to modification of the sale\\nmust not affect to the {@link IShoppingOrder orders} that already had been\\napplied to the sale.\\n\\nThe 2nd purpose is for the A/B tests. {@link IShoppingSeller Seller} needs\\nto demonstrate operating performance by changing price, content, and\\ncomposition of the product. This snapshot concept would be helpful for it.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target sale's {@link IShoppingSale.id }\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingSaleSnapshot.ICreate\"\n              }\n            }\n          },\n          \"description\": \"New information of the sale\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingSale\"\n                }\n              }\n            },\n            \"description\": \"Updated sale with new snapshot\"\n          }\n        }\n      }\n    },\n    \"/shoppings/sellers/sales/{id}/open\": {\n      \"put\": {\n        \"summary\": \"Change opening and closing time of a sale\",\n        \"description\": \"Change opening and closing time of a sale.\\n\\nUpdate a {@link IShoppingSale sale}'s opening and closing time.\\n\\nBy the way, if the sale still be opened or closed, it is not possible to\\nchange the opening time. In contrary, if the sale already had been opened\\nbut still not closed, it is possible to change the closing time.\\n\\nOf course, if closing time is less than opening time or not,\\n428 unprocessable entity error would be thrown.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target sale's {@link IShoppingSale.id }\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingSale.IUpdateOpeningTime\"\n              }\n            }\n          },\n          \"description\": \"New opening and closing time\",\n          \"required\": true\n        }\n      }\n    },\n    \"/shoppings/sellers/sales/{id}/replica\": {\n      \"post\": {\n        \"summary\": \"Get replica of a sale\",\n        \"description\": \"Get replica of a sale.\\n\\nGet a {@link IShoppingSale.ICreate} typed info of the target sale for\\nreplication.\\n\\nIt would be useful for creating a new replication\\n{@link IShoppingSale sale} with similar innformatiopn.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target sale's {@link IShoppingSale.id }\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"201\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingSale.ICreate\"\n                }\n              }\n            },\n            \"description\": \"Creation info of the sale for replication\"\n          }\n        }\n      }\n    },\n    \"/shoppings/sellers/sales/{id}/pause\": {\n      \"delete\": {\n        \"summary\": \"Pause a sale\",\n        \"description\": \"Pause a sale.\\n\\nPause a {@link IShoppingSale sale} from {@link open opened} state.\\nTherefore, the sale can not be operated again until it be\\n{@link restore restored}. By the way, {@link IShoppingCustomer customer}\\nstill can sale from the {@link index} and {@link at} API endpoints, but\\n\\\"paused\\\" label would be attached.\\n\\nAlso, customer no more can put into the shopping cart, either.\\nEven the sale already had been put into the shopping cart, the\\n{@link IShoppingCartCommodity commodity} will not be listed on the\\nshopping cart. Also, it is not possible to applying an\\n{@link IShoppingOrder order} with the paused sale's commodity, either.\\n\\nBy the way, if the sale already had been applied to an order, the order\\ncan be {@link IShoppingOrderPublish published} and\\n{@link IShoppingSeller seller} must {@link IShoppingDelivery deliver} the\\ngood to the customer.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target sale's {@link IShoppingSale.id }\",\n            \"required\": true\n          }\n        ]\n      }\n    },\n    \"/shoppings/sellers/sales/{id}/suspend\": {\n      \"delete\": {\n        \"summary\": \"Suspend a sale\",\n        \"description\": \"Suspend a sale.\\n\\nSuspend a {@link IShoppingSale sale} from {@link open opened} state.\\nTherefore, the sale can not be operated again until it be\\n{@link restore restored} and {@link IShoppingCustomer customer} cannot\\nsee the sale from the {@link index} and {@link at} API.\\n\\nAlso, customer no more can put into the shopping cart, either.\\nEven the sale already had been put into the shopping cart, the\\n{@link IShoppingCartCommodity commodity} will not be listed on the\\nshopping cart. Also, it is not possible to applying an\\n{@link IShoppingOrder order} with the suspended sale's commodity, either.\\n\\nBy the way, if the sale already had been applied to an order, the order\\ncan be {@link IShoppingOrderPublish published} and\\n{@link IShoppingSeller seller} must {@link IShoppingDelivery deliver} the\\ngood to the customer.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target sale's {@link IShoppingSale.id }\",\n            \"required\": true\n          }\n        ]\n      }\n    },\n    \"/shoppings/sellers/sales/{id}/restore\": {\n      \"put\": {\n        \"summary\": \"Describe summary as much as possible with clear and concise words.\",\n        \"description\": \"Restore a sale\\n\\nRestore a {@link IShoppingSale sale} from {@link pause paused} or\\n{@link suspend suspended} state\\n\\nTherefore the sale can be operated again if its\\n{@link IShoppingSale.closed_at closing time} has not been reached.\\nAlso, if a {@link IShoppingCustomer customer} had put the sale into the\\nshopping cart when being paused or suspended, the\\n{@link IShoppingCartCommodity commodity} will be listed again on the\\nshopping cart.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target sale's {@link IShoppingSale.id }\",\n            \"required\": true\n          }\n        ]\n      }\n    },\n    \"/shoppings/sellers/sales/details\": {\n      \"patch\": {\n        \"summary\": \"List up every sales\",\n        \"description\": \"List up every sales.\\n\\nList up every {@link IShoppingSale sales} with detailed information.\\n\\nAs you can see, returned sales are detailed, not summarized. If you want\\nto get the summarized information of sale for a brief, use {@link index}\\nfunction instead.\\n\\nFor reference, if you're a {@link IShoppingSeller seller}, you can only\\naccess to the your own {@link IShoppingSale sale}s. Otherwise you're a\\n{@link IShoppingCustomer customer}, you can see only the operating sales\\nin the market. Instead, you can't see the unopened, closed, or suspended\\nsales.\\n\\n> If you're an A.I. chatbot, please don't summarize the\\n> {@link IShoppingSaleUnitStock stock information}. Just list up the\\n> every stocks in the sale with detailed information.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingSale.IRequest\"\n              }\n            }\n          },\n          \"description\": \"Request info of pagination, searching and sorting\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPageIShoppingSale\"\n                }\n              }\n            },\n            \"description\": \"Paginated sales with detailed information\"\n          }\n        }\n      }\n    },\n    \"/shoppings/sellers/sales/{saleId}/questions/{questionId}/answer\": {\n      \"post\": {\n        \"summary\": \"Write an answer article\",\n        \"description\": \"Write an answer article.\\n\\nWrite a formal {@link IShoppingSaleInquiryAnswer answer article} to a\\nspecific {@link IShoppingSaleInquiry question article} written by a\\n{@link IShoppingCustomer}.\\n\\nNote that, this is the formal answer that can be written only one per\\na question article (but {@link update updatable}). Therefore, it needs to\\nguide the {@link IShoppingSeller seller} to write it carefully.\\n\\nAlso, as seller can write {@link IShoppingSaleInquiryComment comments} to\\nthe question article as many as he/she wants, it would be useful for\\nadditional communication.\",\n        \"parameters\": [\n          {\n            \"name\": \"saleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Belonged sale's {@link IShoppingSale.id }\",\n            \"required\": true\n          },\n          {\n            \"name\": \"questionId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target question's {@link IShoppingSaleQuestion.id }\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IBbsArticle.ICreate\"\n              }\n            }\n          },\n          \"description\": \"Creation info of the answer article\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"201\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingSaleInquiryAnswer\"\n                }\n              }\n            },\n            \"description\": \"Newly created answer article\"\n          }\n        }\n      },\n      \"put\": {\n        \"summary\": \"Update an answer article\",\n        \"description\": \"Update an answer article.\\n\\nUpdate a formal {@link IShoppingSaleInquiryAnswer answer article} to a\\nspecific {@link IShoppingSaleInquiry question article} written by a\\n{@link IShoppingCustomer}.\\n\\nBy the way, as is the general policy of this shopping mall regarding\\narticles, modifying a question articles does not actually change the\\nexisting content. Modified content is accumulated and recorded in the\\nexisting article record as a new\\n{@link IShoppingSaleInquiryAnswer.ISnapshot snapshot}. And this is made\\npublic to everyone, including the {@link IShoppingCustomer customer} and the\\n{@link IShoppingSeller seller}, and anyone who can view the article can\\nalso view the entire editing histories.\\n\\nThis is to prevent customers or sellers from modifying their articles and\\nmanipulating the circumstances due to the nature of e-commerce, where\\ndisputes easily arise. That is, to preserve evidence.\",\n        \"parameters\": [\n          {\n            \"name\": \"saleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Belonged sale's {@link IShoppingSale.id }\",\n            \"required\": true\n          },\n          {\n            \"name\": \"questionId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target question's {@link IShoppingSaleQuestion.id }\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IBbsArticle.ICreate\"\n              }\n            }\n          },\n          \"description\": \"Update info of the answer article\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingSaleInquiryAnswer.ISnapshot\"\n                }\n              }\n            },\n            \"description\": \"Newly created snapshot record of the answer article\"\n          }\n        }\n      }\n    },\n    \"/shoppings/sellers/sales/{saleId}/questions/{inquiryId}/comments\": {\n      \"post\": {\n        \"summary\": \"Create an inquiry comment\",\n        \"description\": \"Create an inquiry comment.\\n\\nCreate an {@link IShoppingSaleInquiryComment inquiry comment} of a\\n{@link IShoppingSaleQuestion question} or {@link IShoppingSaleReview review}.\\n\\nFor reference, if you're a {@link IShoppingSeller seller}, you can only\\ncreate an inquiry comment to your own {@link IShoppingSale sale}'s inquiry.\\nOtherwise, you can create an inquiry comment to every inquiries of the sales.\",\n        \"parameters\": [\n          {\n            \"name\": \"saleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Belonged sale's {@link IShoppingSale.id }\",\n            \"required\": true\n          },\n          {\n            \"name\": \"inquiryId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target inquiry's {@link IShoppingSaleInquiry.id }\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingSaleInquiryComment.ICreate\"\n              }\n            }\n          },\n          \"description\": \"Creation info of the inquiry comment\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"201\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingSaleInquiryComment\"\n                }\n              }\n            },\n            \"description\": \"Newly created inquiry comment\"\n          }\n        }\n      },\n      \"patch\": {\n        \"summary\": \"List up every inquiry comments\",\n        \"description\": \"List up every inquiry comments.\\n\\nList up every {@link IShoppingSaleInquiryComment inquiry comments} of a\\n{@link IShoppingSaleQuestion question} or {@link IShoppingSaleReview review}\\nwith {@link IPage pagination}.\\n\\nIf you want, you can limit the result by configuring\\n{@link IShoppingSaleInquiryComment.IRequest.search search condition} in the\\nrequest body. Also, it is possible to customize sequence order of records\\nby configuring {@link IShoppingSaleInquiryComment.IRequest.sort sort condition}.\\n\\nBy the way, if you're a {@link IShoppingSeller seller}, you can only access\\nto the your own {@link IShoppingSale sale}'s inquiries. Otherwise, you\\ncan access to every inquiries of the sales.\",\n        \"parameters\": [\n          {\n            \"name\": \"saleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Belonged sale's {@link IShoppingSale.id }\",\n            \"required\": true\n          },\n          {\n            \"name\": \"inquiryId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Belonged inquiry's {@link IShoppingSaleInquiry.id }\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingSaleInquiryComment.IRequest\"\n              }\n            }\n          },\n          \"description\": \"Request info of pagination, searching and sorting\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPageIShoppingSaleInquiryComment\"\n                }\n              }\n            },\n            \"description\": \"Paginated inquiry comments\"\n          }\n        }\n      }\n    },\n    \"/shoppings/sellers/sales/{saleId}/questions/{inquiryId}/comments/{id}\": {\n      \"get\": {\n        \"summary\": \"Get an inquiry comment info\",\n        \"description\": \"Get an inquiry comment info.\\n\\nGet a detailed {@link IShoppingSaleInquiryComment inquiry comment}\\ninformation of a {@link IShoppingSaleQuestion question} or\\n{@link IShoppingSaleReview review}.\\n\\nFor reference, if you're a {@link IShoppingSeller seller}, you can only\\naccess to the your own {@link IShoppingSale sale}'s inquiry comment.\\nOtherwise, you can access to every inquiry comments of the sales.\",\n        \"parameters\": [\n          {\n            \"name\": \"saleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Belonged sale's {@link IShoppingSale.id }\",\n            \"required\": true\n          },\n          {\n            \"name\": \"inquiryId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Belonged inquiry's {@link IShoppingSaleInquiry.id }\",\n            \"required\": true\n          },\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target inquiry comment's {@link IShoppingSaleInquiryComment.id }\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingSaleInquiryComment\"\n                }\n              }\n            },\n            \"description\": \"Detailed inquiry comment info\"\n          }\n        }\n      },\n      \"put\": {\n        \"summary\": \"Update an inquiry comment\",\n        \"description\": \"Update an inquiry comment.\\n\\nUpdate an {@link IShoppingSaleInquiryComment inquiry comment} to a specific\\n{@link IShoppingSaleQuestion question} or {@link IShoppingSaleReview review}.\\n\\nBy the way, as is the general policy of this shopping mall regarding\\ncomments, modifying a comment does not actually change the existing content.\\nModified content is accumulated and recorded in the existing comment record\\nas a new {@link IShoppingSaleInquiryComment.ISnapshot snapshot}. And this\\nis made public to everyone, who can read this inquiry comment.\\n\\nThis is to prevent customers or sellers from modifying their comments and\\nmanipulating the circumstances due to the nature of e-commerce, where\\ndisputes easily arise. That is, to preserve evidence.\",\n        \"parameters\": [\n          {\n            \"name\": \"saleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Belonged sale's {@link IShoppingSale.id }\",\n            \"required\": true\n          },\n          {\n            \"name\": \"inquiryId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Belonged inquiry's {@link IShoppingSaleInquiry.id }\",\n            \"required\": true\n          },\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target inquiry comment's {@link IShoppingSaleInquiryComment.id }\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingSaleInquiryComment.ICreate\"\n              }\n            }\n          },\n          \"description\": \"Update info of the inquiry comment\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingSaleInquiryComment.ISnapshot\"\n                }\n              }\n            },\n            \"description\": \"Newly created snapshot record of the inquiry comment\"\n          }\n        }\n      }\n    },\n    \"/shoppings/sellers/sales/{saleId}/questions\": {\n      \"patch\": {\n        \"summary\": \"List up every summarized questions\",\n        \"description\": \"List up every summarized questions.\\n\\nList up every {@link IShoppingSaleQuestion.ISummary summarized questions} of a\\n{@link IShoppingSale sale}.\\n\\nAs you can see, returned questions are summarized, not detailed. If you want\\nto get the detailed information of a question, use {@link adridges} function\\nor {@link at} function for each article.\\n\\nAlso, returned question has {@link IShoppingSaleQuestion.ISummary.answer}\\nproperty which means the formal answer from the {@link IShoppingSeller}.\\nAdditionally, returned question has another special property\\n{@link IShoppingSaleQuestion.ISummary.secret} with masking to other\\nprincple properties, and it means only related actors can {@link at read}\\nthe question.\\n\\nFor reference, if you're a {@link IShoppingSeller seller}, you can only\\naccess to the your own {@link IShoppingSale sale}'s questions. Otherwise,\\nyou can access to every questions of the sales.\\n\\nBy the way, if you want, you can limit the result by configuring\\n{@link IShoppingSaleQuestion.IRequest.search search condition} in the\\nrequest body. Also, it is possible to customize sequence order of records\\nby configuring {@link IShoppingSaleQuestion.IRequest.sort sort condition}.\",\n        \"parameters\": [\n          {\n            \"name\": \"saleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Belonged sale's {@link IShoppingSale.id }\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingSaleQuestion.IRequest\"\n              }\n            }\n          },\n          \"description\": \"Request info of pagination, searching and sorting\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPageIShoppingSaleQuestion.ISummary\"\n                }\n              }\n            },\n            \"description\": \"Paginated questions with summarized information\"\n          }\n        }\n      }\n    },\n    \"/shoppings/sellers/sales/{saleId}/questions/abridges\": {\n      \"patch\": {\n        \"summary\": \"List up every abridged questions\",\n        \"description\": \"List up every abridged questions.\\n\\nList up every {@link IShoppingSaleQuestion.IAbridge abridged questions} of\\na {@link IShoppingSale sale}.\\n\\nAs you can see, returned questions are abridged, not detailed. If you want\\nto get the detailed information of a question, use {@link at} function\\nfor each article.\\n\\nAlso, returned question has {@link IShoppingSaleQuestion.IAridge.answer}\\nproperty which means the formal answer from the {@link IShoppingSeller}.\\nAdditionally, returned question has another special property\\n{@link IShoppingSaleQuestion.IAridge.secret} with masking to other\\nprincple properties, and it means only related actors can {@link at read}\\nthe question.\\n\\nFor reference, if you're a {@link IShoppingSeller seller}, you can only\\naccess to the your own {@link IShoppingSale sale}'s questions. Otherwise,\\nyou can access to every questions of the sales.\\n\\nBy the way, if you want, you can limit the result by configuring\\n{@link IShoppingSaleQuestion.IRequest.search search condition} in the\\nrequest body. Also, it is possible to customize sequence order of records\\nby configuring {@link IShoppingSaleQuestion.IRequest.sort sort condition}.\",\n        \"parameters\": [\n          {\n            \"name\": \"saleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Belonged sale's {@link IShoppingSale.id }\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingSaleQuestion.IRequest\"\n              }\n            }\n          },\n          \"description\": \"Request info of pagination, searching and sorting\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPageIShoppingSaleQuestion.IAbridge\"\n                }\n              }\n            },\n            \"description\": \"Paginated questions with abridged information\"\n          }\n        }\n      }\n    },\n    \"/shoppings/sellers/sales/{saleId}/questions/{id}\": {\n      \"get\": {\n        \"summary\": \"Get a question info\",\n        \"description\": \"Get a question info.\\n\\nGet a detailed {@link IShoppingSaleQuestion question} information of a\\n{@link IShoppingSale sale}.\\n\\nFor reference, if you're a {@link IShoppingSeller seller}, you can only\\naccess to the your own {@link IShoppingSale sale}'s question. Otherwise\\nyou are a {@link IShoppingCustomer customer}, you can access to every\\nquestions of the sales except the {@link IShoppingSaleQuestion.secret}\\nvalue is `false`.\",\n        \"parameters\": [\n          {\n            \"name\": \"saleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Belonged sale's {@link IShoppingSale.id }\",\n            \"required\": true\n          },\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target question's {@link IShoppingSaleQuestion.id }\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingSaleQuestion\"\n                }\n              }\n            },\n            \"description\": \"Detailed question info\"\n          }\n        }\n      }\n    },\n    \"/shoppings/sellers/sales/{saleId}/reviews/{reviewId}/answer\": {\n      \"post\": {\n        \"summary\": \"Write an answer article\",\n        \"description\": \"Write an answer article.\\n\\nWrite a formal {@link IShoppingSaleInquiryAnswer answer article} to a\\nspecific {@link IShoppingSaleInquiry review article} written by a\\n{@link IShoppingCustomer}.\\n\\nNote that, this is the formal answer that can be written only one per\\na review article (but {@link update updatable}). Therefore, it needs to\\nguide the {@link IShoppingSeller seller} to write it carefully.\\n\\nAlso, as seller can write {@link IShoppingSaleInquiryComment comments} to\\nthe review article as many as he/she wants, it would be useful for\\nadditional communication.\",\n        \"parameters\": [\n          {\n            \"name\": \"saleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Belonged sale's {@link IShoppingSale.id }\",\n            \"required\": true\n          },\n          {\n            \"name\": \"reviewId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target review's {@link IShoppingSaleReview.id }\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IBbsArticle.ICreate\"\n              }\n            }\n          },\n          \"description\": \"Creation info of the answer article\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"201\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingSaleInquiryAnswer\"\n                }\n              }\n            },\n            \"description\": \"Newly created answer article\"\n          }\n        }\n      },\n      \"put\": {\n        \"summary\": \"Update an answer article\",\n        \"description\": \"Update an answer article.\\n\\nUpdate a formal {@link IShoppingSaleInquiryAnswer answer article} to a\\nspecific {@link IShoppingSaleInquiry review article} written by a\\n{@link IShoppingCustomer}.\\n\\nBy the way, as is the general policy of this shopping mall regarding\\narticles, modifying a review articles does not actually change the\\nexisting content. Modified content is accumulated and recorded in the\\nexisting article record as a new\\n{@link IShoppingSaleInquiryAnswer.ISnapshot snapshot}. And this is made\\npublic to everyone, including the {@link IShoppingCustomer customer} and the\\n{@link IShoppingSeller seller}, and anyone who can view the article can\\nalso view the entire editing histories.\\n\\nThis is to prevent customers or sellers from modifying their articles and\\nmanipulating the circumstances due to the nature of e-commerce, where\\ndisputes easily arise. That is, to preserve evidence.\",\n        \"parameters\": [\n          {\n            \"name\": \"saleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Belonged sale's {@link IShoppingSale.id }\",\n            \"required\": true\n          },\n          {\n            \"name\": \"reviewId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target review's {@link IShoppingSaleReview.id }\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IBbsArticle.ICreate\"\n              }\n            }\n          },\n          \"description\": \"Update info of the answer article\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingSaleInquiryAnswer.ISnapshot\"\n                }\n              }\n            },\n            \"description\": \"Newly created snapshot record of the answer article\"\n          }\n        }\n      }\n    },\n    \"/shoppings/sellers/sales/{saleId}/reviews/{inquiryId}/comments\": {\n      \"post\": {\n        \"summary\": \"Create an inquiry comment\",\n        \"description\": \"Create an inquiry comment.\\n\\nCreate an {@link IShoppingSaleInquiryComment inquiry comment} of a\\n{@link IShoppingSaleQuestion question} or {@link IShoppingSaleReview review}.\\n\\nFor reference, if you're a {@link IShoppingSeller seller}, you can only\\ncreate an inquiry comment to your own {@link IShoppingSale sale}'s inquiry.\\nOtherwise, you can create an inquiry comment to every inquiries of the sales.\",\n        \"parameters\": [\n          {\n            \"name\": \"saleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Belonged sale's {@link IShoppingSale.id }\",\n            \"required\": true\n          },\n          {\n            \"name\": \"inquiryId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target inquiry's {@link IShoppingSaleInquiry.id }\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingSaleInquiryComment.ICreate\"\n              }\n            }\n          },\n          \"description\": \"Creation info of the inquiry comment\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"201\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingSaleInquiryComment\"\n                }\n              }\n            },\n            \"description\": \"Newly created inquiry comment\"\n          }\n        }\n      },\n      \"patch\": {\n        \"summary\": \"List up every inquiry comments\",\n        \"description\": \"List up every inquiry comments.\\n\\nList up every {@link IShoppingSaleInquiryComment inquiry comments} of a\\n{@link IShoppingSaleQuestion question} or {@link IShoppingSaleReview review}\\nwith {@link IPage pagination}.\\n\\nIf you want, you can limit the result by configuring\\n{@link IShoppingSaleInquiryComment.IRequest.search search condition} in the\\nrequest body. Also, it is possible to customize sequence order of records\\nby configuring {@link IShoppingSaleInquiryComment.IRequest.sort sort condition}.\\n\\nBy the way, if you're a {@link IShoppingSeller seller}, you can only access\\nto the your own {@link IShoppingSale sale}'s inquiries. Otherwise, you\\ncan access to every inquiries of the sales.\",\n        \"parameters\": [\n          {\n            \"name\": \"saleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Belonged sale's {@link IShoppingSale.id }\",\n            \"required\": true\n          },\n          {\n            \"name\": \"inquiryId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Belonged inquiry's {@link IShoppingSaleInquiry.id }\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingSaleInquiryComment.IRequest\"\n              }\n            }\n          },\n          \"description\": \"Request info of pagination, searching and sorting\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPageIShoppingSaleInquiryComment\"\n                }\n              }\n            },\n            \"description\": \"Paginated inquiry comments\"\n          }\n        }\n      }\n    },\n    \"/shoppings/sellers/sales/{saleId}/reviews/{inquiryId}/comments/{id}\": {\n      \"get\": {\n        \"summary\": \"Get an inquiry comment info\",\n        \"description\": \"Get an inquiry comment info.\\n\\nGet a detailed {@link IShoppingSaleInquiryComment inquiry comment}\\ninformation of a {@link IShoppingSaleQuestion question} or\\n{@link IShoppingSaleReview review}.\\n\\nFor reference, if you're a {@link IShoppingSeller seller}, you can only\\naccess to the your own {@link IShoppingSale sale}'s inquiry comment.\\nOtherwise, you can access to every inquiry comments of the sales.\",\n        \"parameters\": [\n          {\n            \"name\": \"saleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Belonged sale's {@link IShoppingSale.id }\",\n            \"required\": true\n          },\n          {\n            \"name\": \"inquiryId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Belonged inquiry's {@link IShoppingSaleInquiry.id }\",\n            \"required\": true\n          },\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target inquiry comment's {@link IShoppingSaleInquiryComment.id }\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingSaleInquiryComment\"\n                }\n              }\n            },\n            \"description\": \"Detailed inquiry comment info\"\n          }\n        }\n      },\n      \"put\": {\n        \"summary\": \"Update an inquiry comment\",\n        \"description\": \"Update an inquiry comment.\\n\\nUpdate an {@link IShoppingSaleInquiryComment inquiry comment} to a specific\\n{@link IShoppingSaleQuestion question} or {@link IShoppingSaleReview review}.\\n\\nBy the way, as is the general policy of this shopping mall regarding\\ncomments, modifying a comment does not actually change the existing content.\\nModified content is accumulated and recorded in the existing comment record\\nas a new {@link IShoppingSaleInquiryComment.ISnapshot snapshot}. And this\\nis made public to everyone, who can read this inquiry comment.\\n\\nThis is to prevent customers or sellers from modifying their comments and\\nmanipulating the circumstances due to the nature of e-commerce, where\\ndisputes easily arise. That is, to preserve evidence.\",\n        \"parameters\": [\n          {\n            \"name\": \"saleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Belonged sale's {@link IShoppingSale.id }\",\n            \"required\": true\n          },\n          {\n            \"name\": \"inquiryId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Belonged inquiry's {@link IShoppingSaleInquiry.id }\",\n            \"required\": true\n          },\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target inquiry comment's {@link IShoppingSaleInquiryComment.id }\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingSaleInquiryComment.ICreate\"\n              }\n            }\n          },\n          \"description\": \"Update info of the inquiry comment\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingSaleInquiryComment.ISnapshot\"\n                }\n              }\n            },\n            \"description\": \"Newly created snapshot record of the inquiry comment\"\n          }\n        }\n      }\n    },\n    \"/shoppings/sellers/sales/{saleId}/reviews\": {\n      \"patch\": {\n        \"summary\": \"List up every summarized reviews\",\n        \"description\": \"List up every summarized reviews.\\n\\nList up every {@link IShoppingSaleReview.ISummary summarized reviews} of a\\n{@link IShoppingSale sale}.\\n\\nAs you can see, returned reviews are summarized, not detailed. If you want\\nto get the detailed information of a review, use {@link adridges} function\\nor {@link at} function for each article.\\n\\nAlso, returned review has {@link IShoppingSaleReview.ISummary.answer}\\nproperty which means the formal answer from the {@link IShoppingSeller}.\\n\\nFor reference, if you're a {@link IShoppingSeller seller}, you can only\\naccess to the your own {@link IShoppingSale sale}'s reviews. Otherwise,\\nyou can access to every reviews of the sales.\\n\\nBy the way, if you want, you can limit the result by configuring\\n{@link IShoppingSaleReview.IRequest.search search condition} in the\\nrequest body. Also, it is possible to customize sequence order of records\\nby configuring {@link IShoppingSaleReview.IRequest.sort sort condition}.\",\n        \"parameters\": [\n          {\n            \"name\": \"saleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Belonged sale's {@link IShoppingSale.id }\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingSaleReview.IRequest\"\n              }\n            }\n          },\n          \"description\": \"Request info of pagination, searching and sorting\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPageIShoppingSaleReview.ISummary\"\n                }\n              }\n            },\n            \"description\": \"Paginated reviews with summarized information\"\n          }\n        }\n      }\n    },\n    \"/shoppings/sellers/sales/{saleId}/reviews/abridges\": {\n      \"patch\": {\n        \"summary\": \"List up every abridged reviews\",\n        \"description\": \"List up every abridged reviews.\\n\\nList up every {@link IShoppingSaleReview.IAbridge abridged reviews} of\\na {@link IShoppingSale sale}.\\n\\nAs you can see, returned reviews are abridged, not detailed. If you want\\nto get the detailed information of a review, use {@link at} function\\nfor each article.\\n\\nAlso, returned review has {@link IShoppingSaleReview.IAridge.answer}\\nproperty which means the formal answer from the {@link IShoppingSeller}.\\n\\nFor reference, if you're a {@link IShoppingSeller seller}, you can only\\naccess to the your own {@link IShoppingSale sale}'s reviews. Otherwise,\\nyou can access to every reviews of the sales.\\n\\nBy the way, if you want, you can limit the result by configuring\\n{@link IShoppingSaleReview.IRequest.search search condition} in the\\nrequest body. Also, it is possible to customize sequence order of records\\nby configuring {@link IShoppingSaleReview.IRequest.sort sort condition}.\",\n        \"parameters\": [\n          {\n            \"name\": \"saleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Belonged sale's {@link IShoppingSale.id }\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingSaleReview.IRequest\"\n              }\n            }\n          },\n          \"description\": \"Request info of pagination, searching and sorting\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPageIShoppingSaleReview.IAbridge\"\n                }\n              }\n            },\n            \"description\": \"Paginated reviews with abridged information\"\n          }\n        }\n      }\n    },\n    \"/shoppings/sellers/sales/{saleId}/reviews/{id}\": {\n      \"get\": {\n        \"summary\": \"Get a review info\",\n        \"description\": \"Get a review info.\\n\\nGet a detailed {@link IShoppingSaleReview review} information of a\\n{@link IShoppingSale sale}.\\n\\nFor reference, if you're a {@link IShoppingSeller seller}, you can only\\naccess to the your own {@link IShoppingSale sale}'s review. Otherwise\\nyou are a {@link IShoppingCustomer customer}, you can access to every\\nreviews of the sales.\",\n        \"parameters\": [\n          {\n            \"name\": \"saleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Belonged sale's {@link IShoppingSale.id }\",\n            \"required\": true\n          },\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target review's {@link IShoppingSaleReview.id }\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingSaleReview\"\n                }\n              }\n            },\n            \"description\": \"Detailed review info\"\n          }\n        }\n      }\n    },\n    \"/shoppings/sellers/sales/{saleId}/snapshots/{id}/replica\": {\n      \"post\": {\n        \"summary\": \"Get replica of a snapshot\",\n        \"description\": \"Get replica of a snapshot.\\n\\nGet a {@link IShoppingSale.ICreate} typed info of the target\\n{@link IShoppingSaleSnapshot snapshot} record for replication.\\n\\nIt would be useful for creating a new replication {@link IShoppingSale sale}\\nfrom the old snapshot.\",\n        \"parameters\": [\n          {\n            \"name\": \"saleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Belonged sale's {@link IShoppingSale.id }\",\n            \"required\": true\n          },\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target snapshot's {@link IShoppingSaleSnapshot.id }\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"201\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingSale.ICreate\"\n                }\n              }\n            },\n            \"description\": \"Creation info of the sale for replication\"\n          }\n        }\n      }\n    },\n    \"/shoppings/sellers/sales/{saleId}/snapshots\": {\n      \"patch\": {\n        \"summary\": \"List up every snapshots\",\n        \"description\": \"List up every snapshots.\\n\\nWhenever {@link IShoppingSeller seller} updates a\\n{@link IShoppingSale sale}, the sale record is not updated but a new\\n{@link IShoppingSaleSnapshot snapshot} record is created to keep the\\nintegrity of the sale history. This API function is for listing up\\nsuch snapshot records.\\n\\nAlso, as you can see from the return type, returned snapshots are\\nsummarized, not detailed. If you want to get the detailed information\\nof a snapshot, use {@link at} or {@link flipo} function for each snapshot.\\n\\nFor reference, if you're a {@link IShoppingSeller seller}, you can only\\naccess to the your own {@link IShoppingSale sale}'s snapshots. Otherwise,\\nyou can access to every snapshots of the sales even though the sale has\\nbeen closed or suspended.\",\n        \"parameters\": [\n          {\n            \"name\": \"saleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target sale's {@link IShoppingSale.id }\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IPage.IRequest\"\n              }\n            }\n          },\n          \"description\": \"Requestion info of pagination\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPageIShoppingSaleSnapshot.ISummary\"\n                }\n              }\n            },\n            \"description\": \"Paginated snapshots with summarized information\"\n          }\n        }\n      }\n    },\n    \"/shoppings/sellers/sales/{saleId}/snapshots/{id}\": {\n      \"get\": {\n        \"summary\": \"Get a snapshot info\",\n        \"description\": \"Get a snapshot info.\\n\\nGet a {@link IShoppingSaleSnapshot snapshot} with detailed information.\\n\\nAs you can see from the return type, returned snapshot does not contain\\nthe {@link IShoppingSale sale} info. If you want to get the sale info,\\nuse the {@link flip} function instead.\\n\\nFor reference, if you're a {@link IShoppingSeller seller}, you can only\\naccess to the your own {@link IShoppingSale sale}'s snapshots. Otherwise,\\nyou can access to every snapshots of the sales even though the sale has\\nbeen closed or suspended.\",\n        \"parameters\": [\n          {\n            \"name\": \"saleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Belonged sale's {@link IShoppingSale.id }\",\n            \"required\": true\n          },\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target snapshot's {@link IShoppingSaleSnapshot.id }\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingSaleSnapshot\"\n                }\n              }\n            },\n            \"description\": \"Detailed information of the snapshot\"\n          }\n        }\n      }\n    },\n    \"/shoppings/sellers/sales/{saleId}/snapshots/{id}/flip\": {\n      \"get\": {\n        \"summary\": \"Get a flipped snapshot info\",\n        \"description\": \"Get a flipped snapshot info.\\n\\nGet a {@link IShoppingSale sale} info of a flipped snapshot.\\n\\nAs you can see from the return type, this function returns the\\n{@link IShoppingSale sale} info. By the way, the sale info is not the\\nlatest one, but a flipped info in the snapshot side.\\n\\nAlso, if you're a {@link IShoppingSeller seller}, you can only access to\\nthe your own {@link IShoppingSale sale}'s snapshots. Otherwise, you can\\naccess to every snapshots of the sales even though the sale has been\\nclosed or suspended.\",\n        \"parameters\": [\n          {\n            \"name\": \"saleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Belonged sale's {@link IShoppingSale.id }\",\n            \"required\": true\n          },\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target snapshot's {@link IShoppingSaleSnapshot.id }\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingSale\"\n                }\n              }\n            },\n            \"description\": \"Detailed sale information in the snapshot side\"\n          }\n        }\n      }\n    },\n    \"/shoppings/sellers/sales/{saleId}/units/{unitId}/stocks/{stockId}/supplements\": {\n      \"post\": {\n        \"summary\": \"Create a supplement\",\n        \"description\": \"Create a supplement.\\n\\nCreate a {@link IShoppingSaleUnitStockSupplement supplement history} of a\\nspecific {@link IShoppingSaleUnitStock stock}.\\n\\nTherefore, {@link IShoppingSaleUnitStockInventory.income inventory} of the\\ntarget stock will be increased by the\\n{@link IShoppingSaleUnitStockSupplement.value supplement's value}.\",\n        \"parameters\": [\n          {\n            \"name\": \"saleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Belonged sale's {@link IShoppingSale.id }\",\n            \"required\": true\n          },\n          {\n            \"name\": \"unitId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Belonged unit's {@link IShoppingSaleUnit.id }\",\n            \"required\": true\n          },\n          {\n            \"name\": \"stockId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target stock's {@link IShoppingSaleUnitStock.id }\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingSaleUnitStockSupplement.ICreate\"\n              }\n            }\n          },\n          \"description\": \"Create info of the supplement\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"201\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingSaleUnitStockSupplement\"\n                }\n              }\n            },\n            \"description\": \"Created supplement\"\n          }\n        }\n      },\n      \"patch\": {\n        \"summary\": \"List up every supplements\",\n        \"description\": \"List up every supplements.\\n\\nList up every {@link IShoppingSaleUnitStockSupplement supplement histories}\\nof a specific {@link IShoppingSaleUnitStock stock}.\\n\\nIf you want, you can limit the result by configuring\\n{@link IShoppingSaleUnitStockSupplement.IRequest.search search condition} in\\nthe request body. Also, it is possible to customize sequence order of\\nrecords by configuring {@link IShoppingSaleUnitStockSupplement.IRequest.sort}\\nproperty.\",\n        \"parameters\": [\n          {\n            \"name\": \"saleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Belonged sale's {@link IShoppingSale.id }\",\n            \"required\": true\n          },\n          {\n            \"name\": \"unitId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Belonged unit's {@link IShoppingSaleUnit.id }\",\n            \"required\": true\n          },\n          {\n            \"name\": \"stockId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target stock's {@link IShoppingSaleUnitStock.id }\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingSaleUnitStockSupplement.IRequest\"\n              }\n            }\n          },\n          \"description\": \"Request info of pagination, searching and sorting\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPageIShoppingSaleUnitStockSupplement\"\n                }\n              }\n            },\n            \"description\": \"Paginated supplements\"\n          }\n        }\n      }\n    },\n    \"/shoppings/sellers/sales/{saleId}/units/{unitId}/stocks/{stockId}/supplements/{id}\": {\n      \"put\": {\n        \"summary\": \"Update a supplement\",\n        \"description\": \"Update a supplement.\\n\\nUpdate quantity value of a {@link IShoppingSaleUnitStockSupplement supplement}\\nof a specific {@link IShoppingSaleUnitStock stock}.\\n\\nTherefore, {@link IShoppingSaleUnitStockInventory.income inventory} of the\\ntarget stock will be changed by the\\n{@link IShoppingSaleUnitStockSupplement.value supplement's value}.\",\n        \"parameters\": [\n          {\n            \"name\": \"saleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Belonged sale's {@link IShoppingSale.id }\",\n            \"required\": true\n          },\n          {\n            \"name\": \"unitId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Belonged unit's {@link IShoppingSaleUnit.id }\",\n            \"required\": true\n          },\n          {\n            \"name\": \"stockId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target stock's {@link IShoppingSaleUnitStock.id }\",\n            \"required\": true\n          },\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target supplement's {@link IShoppingSaleUnitStockSupplement.id }\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingSaleUnitStockSupplement.ICreate\"\n              }\n            }\n          },\n          \"description\": \"Update info (quantity) of the supplement\",\n          \"required\": true\n        }\n      },\n      \"delete\": {\n        \"summary\": \"Erase a supplement\",\n        \"description\": \"Erase a supplement.\\n\\nErase a {@link IShoppingSaleUnitStockSupplement supplement} of a specific\\n{@link IShoppingSaleUnitStock stock}.\\n\\nTherefore, {@link IShoppingSaleUnitStockInventory.income inventory} of the\\ntarget stock will be decreased by the\\n{@link IShoppingSaleUnitStockSupplement.value supplement's value}.\",\n        \"parameters\": [\n          {\n            \"name\": \"saleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Belonged sale's {@link IShoppingSale.id }\",\n            \"required\": true\n          },\n          {\n            \"name\": \"unitId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Belonged unit's {@link IShoppingSaleUnit.id }\",\n            \"required\": true\n          },\n          {\n            \"name\": \"stockId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target stock's {@link IShoppingSaleUnitStock.id }\",\n            \"required\": true\n          },\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target supplement's {@link IShoppingSaleUnitStockSupplement.id }\",\n            \"required\": true\n          }\n        ]\n      }\n    },\n    \"/shoppings/sellers/systematic/channels/{channelCode}/categories\": {\n      \"patch\": {\n        \"summary\": \"List up every categories with children records\",\n        \"description\": \"List up every categories with children records.\\n\\nList up every {@link IShoppingChannelCategory.IHierarchical categories}\\nof a {@link IShoppingChannel channel} with pagination. Returned categories\\ncontain children categories, too.\\n\\nIf you want, you can limit the result by configuring\\n{@link IShoppingChannelCategory.IRequest.search search condition} in the\\nrequest body. Also, it is possible to customize sequence order of records\\nby configuring {@link IShoppingChannelCategory.IRequest.sort sort condition}.\",\n        \"parameters\": [\n          {\n            \"name\": \"channelCode\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\"\n            },\n            \"description\": \" Belonged channel's {@link IShoppingChannel.code }\",\n            \"required\": true\n          }\n        ]\n      }\n    },\n    \"/shoppings/sellers/systematic/channels/{channelCode}/categories/{id}\": {\n      \"get\": {\n        \"summary\": \"Get a category info\",\n        \"description\": \"Get a category info.\\n\\nGet a detailed {@link IShoppingChannelCategory category} information.\\n\\nReturned category contains hierarchical children categories, and also\\ncontains the recursive parent categories, too.\",\n        \"parameters\": [\n          {\n            \"name\": \"channelCode\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\"\n            },\n            \"description\": \" Belonged channel's {@link IShoppingChannel.code }\",\n            \"required\": true\n          },\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target category's {@link IShoppingChannelCategory.id }\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingChannelCategory\"\n                }\n              }\n            },\n            \"description\": \"Detailed category info\"\n          }\n        }\n      }\n    },\n    \"/shoppings/sellers/systematic/channels/{channelCode}/categories/{id}/invert\": {\n      \"get\": {\n        \"summary\": \"Get a category info of inverted\",\n        \"description\": \"Get a category info of inverted.\\n\\nGet a inverted {@link IShoppingChannelCategory.IInvert category} information.\\n\\nReturned category contains the recursive parent categories, but not contains\\nthe hierarchical children categories.\",\n        \"parameters\": [\n          {\n            \"name\": \"channelCode\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\"\n            },\n            \"description\": \" Belonged channel's {@link IShoppingChannel.code }\",\n            \"required\": true\n          },\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target category's {@link IShoppingChannelCategory.id }\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingChannelCategory.IInvert\"\n                }\n              }\n            },\n            \"description\": \"Detailed category info\"\n          }\n        }\n      }\n    },\n    \"/shoppings/sellers/systematic/channels\": {\n      \"patch\": {\n        \"summary\": \"List up every channels\",\n        \"description\": \"List up every channels.\\n\\nList up every {@link IShoppingChannel channels} with pagination.\\n\\nIf you want, you can limit the result by configuring\\n{@link IShoppingChannel.IRequest.search search condition} in the request\\nbody. Also, it is possible to customize sequence order of records by\\nconfiguring {@link IShoppingChannel.IRequest.sort sort condition}.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingChannel.IRequest\"\n              }\n            }\n          },\n          \"description\": \"Request info of pagination, searching and sorting\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPageIShoppingChannel\"\n                }\n              }\n            },\n            \"description\": \"Paginated channels\"\n          }\n        }\n      }\n    },\n    \"/shoppings/sellers/systematic/channels/hierarchical\": {\n      \"patch\": {\n        \"summary\": \"List up every channels with nested categories\",\n        \"description\": \"List up every channels with nested categories.\\n\\nList up every {@link IShoppingChannel.IHierarchical channels} with\\n{@link IPage pagination}. Returned channels contain nested hierarchical\\n{@link IShoppingChannelCategory.IHierarchical categories}.\\n\\nIf you want, you can limit the result by configuring\\n{@link IShoppingChannel.IRequest.search search condition} in the request\\nbody. Also, it is possible to customize sequence order of records by\\nconfiguring {@link IShoppingChannel.IRequest.sort sort condition}.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingChannel.IRequest\"\n              }\n            }\n          },\n          \"description\": \"Request info of pagination, searching and sorting\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPageIShoppingChannel.IHierarchical\"\n                }\n              }\n            },\n            \"description\": \"Paginated channels with nested categories\"\n          }\n        }\n      }\n    },\n    \"/shoppings/sellers/systematic/channels/{id}\": {\n      \"get\": {\n        \"summary\": \"Get a channel info\",\n        \"description\": \"Get a channel info.\\n\\nGet a detailed {@link IShoppingChannel.IHierarchical channel} information.\\n\\nReturned channel instance also contains the nested\\n{@link IShoppingChannelCategory.IHierarchical hierarchical category}\\ninformation.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target channel's {@link IShoppingChannel.id }\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingChannel.IHierarchical\"\n                }\n              }\n            },\n            \"description\": \"Detailed channel info\"\n          }\n        }\n      }\n    },\n    \"/shoppings/sellers/systematic/channels/{code}/get\": {\n      \"get\": {\n        \"summary\": \"Get a channel info by its code\",\n        \"description\": \"Get a channel info by its code.\\n\\nGet a detailed {@link IShoppingChannel.IHierarchical channel} information\\nby its code.\\n\\nReturned channel instance also contains the nested\\n{@link IShoppingChannelCategory.IHierarchical hierarchical category}\\ninformation.\",\n        \"parameters\": [\n          {\n            \"name\": \"code\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\"\n            },\n            \"description\": \" Target channel's {@link IShoppingChannel.code }\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingChannel.IHierarchical\"\n                }\n              }\n            },\n            \"description\": \"Detailed channel info\"\n          }\n        }\n      }\n    },\n    \"/shoppings/sellers/systematic/sections\": {\n      \"patch\": {\n        \"summary\": \"List up every sections\",\n        \"description\": \"List up every sections.\\n\\nList up every {@link IShoppingSection sections} with pagination.\\n\\nIf you want, you can limit the result by configuring\\n{@link IShoppingSection.IRequest.search search condition} in the request\\nbody. Also, it is possible to customize sequence order of records by\\nconfiguring {@link IShoppingSection.IRequest.sort sort condition}.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IShoppingSection.IRequest\"\n              }\n            }\n          },\n          \"description\": \"Request info of pagination, searching and sorting\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPageIShoppingSection\"\n                }\n              }\n            },\n            \"description\": \"Paginated sections\"\n          }\n        }\n      }\n    },\n    \"/shoppings/sellers/systematic/sections/{id}\": {\n      \"get\": {\n        \"summary\": \"Get a section info\",\n        \"description\": \"Get a section info.\\n\\nGet a detailed {@link IShoppingSection section} information.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \" Target section's {@link IShoppingSection.id }\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingSection\"\n                }\n              }\n            },\n            \"description\": \"Detailed section info\"\n          }\n        }\n      }\n    },\n    \"/shoppings/sellers/systematic/sections/{code}/get\": {\n      \"get\": {\n        \"summary\": \"Get a section info by its code\",\n        \"description\": \"Get a section info by its code.\\n\\nGet a detailed {@link IShoppingSection section} information by its code.\",\n        \"parameters\": [\n          {\n            \"name\": \"code\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\"\n            },\n            \"description\": \" Target section's {@link IShoppingSection.code }\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IShoppingSection\"\n                }\n              }\n            },\n            \"description\": \"Detailed section info\"\n          }\n        }\n      }\n    }\n  },\n  \"components\": {\n    \"schemas\": {\n      \"IPerformance\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"cpu\": {\n            \"$ref\": \"#/components/schemas/process.global.NodeJS.CpuUsage\"\n          },\n          \"memory\": {\n            \"$ref\": \"#/components/schemas/process.global.NodeJS.MemoryUsage\"\n          },\n          \"resource\": {\n            \"$ref\": \"#/components/schemas/process.global.NodeJS.ResourceUsage\"\n          }\n        },\n        \"required\": [\n          \"cpu\",\n          \"memory\",\n          \"resource\"\n        ]\n      },\n      \"process.global.NodeJS.CpuUsage\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"user\": {\n            \"type\": \"number\"\n          },\n          \"system\": {\n            \"type\": \"number\"\n          }\n        },\n        \"required\": [\n          \"user\",\n          \"system\"\n        ]\n      },\n      \"process.global.NodeJS.MemoryUsage\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"rss\": {\n            \"type\": \"number\",\n            \"description\": \"Resident Set Size, is the amount of space occupied in the main memory device (that is a subset of the total allocated memory) for the\\nprocess, including all C++ and JavaScript objects and code.\"\n          },\n          \"heapTotal\": {\n            \"type\": \"number\",\n            \"title\": \"Refers to V8's memory usage\",\n            \"description\": \"Refers to V8's memory usage.\"\n          },\n          \"heapUsed\": {\n            \"type\": \"number\",\n            \"title\": \"Refers to V8's memory usage\",\n            \"description\": \"Refers to V8's memory usage.\"\n          },\n          \"external\": {\n            \"type\": \"number\"\n          },\n          \"arrayBuffers\": {\n            \"type\": \"number\",\n            \"description\": \"Refers to memory allocated for `ArrayBuffer`s and `SharedArrayBuffer`s, including all Node.js Buffers. This is also included\\nin the external value. When Node.js is used as an embedded library, this value may be `0` because allocations for `ArrayBuffer`s\\nmay not be tracked in that case.\"\n          }\n        },\n        \"required\": [\n          \"rss\",\n          \"heapTotal\",\n          \"heapUsed\",\n          \"external\",\n          \"arrayBuffers\"\n        ]\n      },\n      \"process.global.NodeJS.ResourceUsage\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"fsRead\": {\n            \"type\": \"number\"\n          },\n          \"fsWrite\": {\n            \"type\": \"number\"\n          },\n          \"involuntaryContextSwitches\": {\n            \"type\": \"number\"\n          },\n          \"ipcReceived\": {\n            \"type\": \"number\"\n          },\n          \"ipcSent\": {\n            \"type\": \"number\"\n          },\n          \"majorPageFault\": {\n            \"type\": \"number\"\n          },\n          \"maxRSS\": {\n            \"type\": \"number\"\n          },\n          \"minorPageFault\": {\n            \"type\": \"number\"\n          },\n          \"sharedMemorySize\": {\n            \"type\": \"number\"\n          },\n          \"signalsCount\": {\n            \"type\": \"number\"\n          },\n          \"swappedOut\": {\n            \"type\": \"number\"\n          },\n          \"systemCPUTime\": {\n            \"type\": \"number\"\n          },\n          \"unsharedDataSize\": {\n            \"type\": \"number\"\n          },\n          \"unsharedStackSize\": {\n            \"type\": \"number\"\n          },\n          \"userCPUTime\": {\n            \"type\": \"number\"\n          },\n          \"voluntaryContextSwitches\": {\n            \"type\": \"number\"\n          }\n        },\n        \"required\": [\n          \"fsRead\",\n          \"fsWrite\",\n          \"involuntaryContextSwitches\",\n          \"ipcReceived\",\n          \"ipcSent\",\n          \"majorPageFault\",\n          \"maxRSS\",\n          \"minorPageFault\",\n          \"sharedMemorySize\",\n          \"signalsCount\",\n          \"swappedOut\",\n          \"systemCPUTime\",\n          \"unsharedDataSize\",\n          \"unsharedStackSize\",\n          \"userCPUTime\",\n          \"voluntaryContextSwitches\"\n        ]\n      },\n      \"ISystem\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"uid\": {\n            \"type\": \"number\",\n            \"title\": \"Random Unique ID\",\n            \"description\": \"Random Unique ID.\"\n          },\n          \"arguments\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"type\": \"string\"\n            },\n            \"description\": \"`process.argv`\"\n          },\n          \"commit\": {\n            \"$ref\": \"#/components/schemas/ISystem.ICommit\",\n            \"title\": \"Git commit info\",\n            \"description\": \"Git commit info.\"\n          },\n          \"package\": {\n            \"$ref\": \"#/components/schemas/ISystem.IPackage\",\n            \"description\": \"`package.json`\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"title\": \"Creation time of this server\",\n            \"description\": \"Creation time of this server.\"\n          }\n        },\n        \"required\": [\n          \"uid\",\n          \"arguments\",\n          \"commit\",\n          \"package\",\n          \"created_at\"\n        ],\n        \"description\": \"System Information.\"\n      },\n      \"ISystem.ICommit\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"shortHash\": {\n            \"type\": \"string\"\n          },\n          \"branch\": {\n            \"type\": \"string\"\n          },\n          \"hash\": {\n            \"type\": \"string\"\n          },\n          \"subject\": {\n            \"type\": \"string\"\n          },\n          \"sanitizedSubject\": {\n            \"type\": \"string\"\n          },\n          \"body\": {\n            \"type\": \"string\"\n          },\n          \"author\": {\n            \"$ref\": \"#/components/schemas/ISystem.ICommit.IUser\"\n          },\n          \"committer\": {\n            \"$ref\": \"#/components/schemas/ISystem.ICommit.IUser\"\n          },\n          \"authored_at\": {\n            \"type\": \"string\"\n          },\n          \"committed_at\": {\n            \"type\": \"string\"\n          },\n          \"notes\": {\n            \"type\": \"string\"\n          },\n          \"tags\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"type\": \"string\"\n            }\n          }\n        },\n        \"required\": [\n          \"shortHash\",\n          \"branch\",\n          \"hash\",\n          \"subject\",\n          \"sanitizedSubject\",\n          \"body\",\n          \"author\",\n          \"committer\",\n          \"authored_at\",\n          \"committed_at\",\n          \"tags\"\n        ],\n        \"description\": \"Git commit info.\"\n      },\n      \"ISystem.ICommit.IUser\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"name\": {\n            \"type\": \"string\"\n          },\n          \"email\": {\n            \"type\": \"string\"\n          }\n        },\n        \"required\": [\n          \"name\",\n          \"email\"\n        ],\n        \"description\": \"Git user account info.\"\n      },\n      \"ISystem.IPackage\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"name\": {\n            \"type\": \"string\"\n          },\n          \"version\": {\n            \"type\": \"string\"\n          },\n          \"description\": {\n            \"type\": \"string\"\n          },\n          \"main\": {\n            \"type\": \"string\"\n          },\n          \"typings\": {\n            \"type\": \"string\"\n          },\n          \"scripts\": {\n            \"$ref\": \"#/components/schemas/Recordstringstring\"\n          },\n          \"repository\": {\n            \"type\": \"object\",\n            \"properties\": {\n              \"type\": {\n                \"const\": \"git\"\n              },\n              \"url\": {\n                \"type\": \"string\"\n              }\n            },\n            \"required\": [\n              \"type\",\n              \"url\"\n            ]\n          },\n          \"author\": {\n            \"type\": \"string\"\n          },\n          \"license\": {\n            \"type\": \"string\"\n          },\n          \"bugs\": {\n            \"type\": \"object\",\n            \"properties\": {\n              \"url\": {\n                \"type\": \"string\"\n              }\n            },\n            \"required\": [\n              \"url\"\n            ]\n          },\n          \"homepage\": {\n            \"type\": \"string\"\n          },\n          \"devDependencies\": {\n            \"$ref\": \"#/components/schemas/Recordstringstring\"\n          },\n          \"dependencies\": {\n            \"$ref\": \"#/components/schemas/Recordstringstring\"\n          },\n          \"publishConfig\": {\n            \"type\": \"object\",\n            \"properties\": {\n              \"registry\": {\n                \"type\": \"string\"\n              }\n            },\n            \"required\": [\n              \"registry\"\n            ]\n          },\n          \"files\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"type\": \"string\"\n            }\n          }\n        },\n        \"required\": [\n          \"name\",\n          \"version\",\n          \"description\",\n          \"scripts\",\n          \"repository\",\n          \"author\",\n          \"license\",\n          \"bugs\",\n          \"homepage\",\n          \"dependencies\"\n        ],\n        \"description\": \"NPM package info.\"\n      },\n      \"Recordstringstring\": {\n        \"type\": \"object\",\n        \"properties\": {},\n        \"required\": [],\n        \"description\": \"Construct a type with a set of properties K of type T\",\n        \"additionalProperties\": {\n          \"type\": \"string\"\n        }\n      },\n      \"IShoppingAdministrator.IInvert\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"type\": {\n            \"const\": \"administrator\",\n            \"title\": \"Discriminant for the type of customer\",\n            \"description\": \"Discriminant for the type of customer.\"\n          },\n          \"member\": {\n            \"$ref\": \"#/components/schemas/IShoppingMember.IInvert\",\n            \"title\": \"Membership joining information\",\n            \"description\": \"Membership joining information.\"\n          },\n          \"customer\": {\n            \"$ref\": \"#/components/schemas/IShoppingCustomer.IInvert\",\n            \"title\": \"Customer, the connection information\",\n            \"description\": \"Customer, the connection information.\"\n          },\n          \"citizen\": {\n            \"$ref\": \"#/components/schemas/IShoppingCitizen\",\n            \"title\": \"Real-name and mobile number authentication information\",\n            \"description\": \"Real-name and mobile number authentication information.\"\n          },\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"title\": \"Primary Key\",\n            \"description\": \"Primary Key.\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"title\": \"Creation time of record\",\n            \"description\": \"Creation time of record.\\n\\nAnother words, the time when the administrator has signed up.\"\n          }\n        },\n        \"required\": [\n          \"type\",\n          \"member\",\n          \"customer\",\n          \"citizen\",\n          \"id\",\n          \"created_at\"\n        ],\n        \"description\": \"Invert information starting from administrator info.\\n\\nInstead of accessing to the administrator information from the\\n{@link IShoppingCustomer.member} -> {@link IShoppingMember.administrator},\\n`IShoppingAdministrator.IInvert` starts from the administrator information\\nand access to the customer, member and {@link IShoppingCitizen citizen}\\ninformation inversely.\"\n      },\n      \"IShoppingMember.IInvert\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"title\": \"Primary Key\",\n            \"description\": \"Primary Key.\"\n          },\n          \"nickname\": {\n            \"type\": \"string\",\n            \"title\": \"Nickname that uniquely identifies the member\",\n            \"description\": \"Nickname that uniquely identifies the member.\"\n          },\n          \"emails\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IShoppingMemberEmail\"\n            },\n            \"title\": \"List of emails\",\n            \"description\": \"List of emails.\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"title\": \"Creation time of record\",\n            \"description\": \"Creation time of record.\\n\\nAnother words, the time when the member has signed up.\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"nickname\",\n          \"emails\",\n          \"created_at\"\n        ],\n        \"description\": \"Invert information of member.\\n\\nThis invert member information has been designed to be used for another\\ninvert information of sellers and administrators like below.\\n\\n- {@link IShoppingSeller.IInvert}\\n- {@link IShoppingAdministrator.IInvert}\"\n      },\n      \"IShoppingMemberEmail\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"title\": \"Primary Key\",\n            \"description\": \"Primary Key.\"\n          },\n          \"value\": {\n            \"type\": \"string\",\n            \"format\": \"email\",\n            \"title\": \"Email address value\",\n            \"description\": \"Email address value.\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"title\": \"Creation time of record\",\n            \"description\": \"Creation time of record.\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"value\",\n          \"created_at\"\n        ],\n        \"description\": \"Email address of member.\\n\\nThis shopping mall system allows multiple email addresses to be\\nregistered for one {@link IShoppingMember member}. If you don't have to\\nplan such multiple email addresses, just use only one.\"\n      },\n      \"IShoppingCustomer.IInvert\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"title\": \"Primary Key\",\n            \"description\": \"Primary Key.\"\n          },\n          \"channel\": {\n            \"$ref\": \"#/components/schemas/IShoppingChannel\",\n            \"title\": \"Belonged channel\",\n            \"description\": \"Belonged channel.\"\n          },\n          \"external_user\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"$ref\": \"#/components/schemas/IShoppingExternalUser\"\n              }\n            ],\n            \"title\": \"External user information\",\n            \"description\": \"External user information.\\n\\nWhen the customer has come from an external service.\"\n          },\n          \"href\": {\n            \"type\": \"string\",\n            \"format\": \"uri\",\n            \"title\": \"Connection address\",\n            \"description\": \"Connection address.\\n\\nSame with {@link window.location.href} of client.\"\n          },\n          \"referrer\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\",\n                \"format\": \"uri\"\n              },\n              {\n                \"type\": \"string\",\n                \"maxLength\": 0\n              }\n            ],\n            \"title\": \"Referrer address\",\n            \"description\": \"Referrer address.\\n\\nSame with {@link window.document.referrer} of client.\"\n          },\n          \"ip\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"format\": \"ipv4\"\n              },\n              {\n                \"type\": \"string\",\n                \"format\": \"ipv6\"\n              }\n            ],\n            \"title\": \"Connection IP Address\",\n            \"description\": \"Connection IP Address.\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"title\": \"Creation time of the connection record\",\n            \"description\": \"Creation time of the connection record.\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"channel\",\n          \"external_user\",\n          \"href\",\n          \"referrer\",\n          \"ip\",\n          \"created_at\"\n        ],\n        \"description\": \"Inverted customer information.\\n\\nThis inverted customer information has been designed to be used for\\nanother invert information of sellers and administrators like below.\\n\\n- {@link IShoppingSeller.IInvert}\\n- {@link IShoppingAdministrator.IInvert}\"\n      },\n      \"IShoppingChannel\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"title\": \"Primary Key\",\n            \"description\": \"Primary Key.\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"title\": \"Creation time of record\",\n            \"description\": \"Creation time of record.\"\n          },\n          \"code\": {\n            \"type\": \"string\",\n            \"title\": \"Identifier code\",\n            \"description\": \"Identifier code.\"\n          },\n          \"name\": {\n            \"type\": \"string\",\n            \"title\": \"Name of the channel\",\n            \"description\": \"Name of the channel.\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"created_at\",\n          \"code\",\n          \"name\"\n        ],\n        \"description\": \"Channel information.\\n\\n`IShoppingChannel` is a concept that shapes the distribution channel in the\\nmarket. Therefore, the difference in the channel in this e-commerce system\\nmeans that it is another site or application.\\n\\nBy the way, if your shopping mall system requires only one channel, then\\njust use only one. This concept is designed to be expandable in the future.\"\n      },\n      \"IShoppingExternalUser\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"title\": \"Primary Key\",\n            \"description\": \"Primary Key.\"\n          },\n          \"citizen\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"$ref\": \"#/components/schemas/IShoppingCitizen\"\n              }\n            ],\n            \"title\": \"Citizen activation info\",\n            \"description\": \"Citizen activation info.\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"title\": \"Creation time of record\",\n            \"description\": \"Creation time of record.\\n\\nAnother word, first time when the external user connected.\"\n          },\n          \"uid\": {\n            \"type\": \"string\",\n            \"title\": \"Identifier key of external user from the external system\",\n            \"description\": \"Identifier key of external user from the external system.\"\n          },\n          \"application\": {\n            \"type\": \"string\",\n            \"title\": \"Identifier code of the external service\",\n            \"description\": \"Identifier code of the external service.\\n\\nIt can be same with {@link IShoppingChannel.code} in common.\"\n          },\n          \"nickname\": {\n            \"type\": \"string\",\n            \"title\": \"Nickname of external user in the external system\",\n            \"description\": \"Nickname of external user in the external system.\"\n          },\n          \"data\": {\n            \"description\": \"Additional information about external user from the external\\nsystem.\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"citizen\",\n          \"created_at\",\n          \"uid\",\n          \"application\",\n          \"nickname\",\n          \"data\"\n        ],\n        \"description\": \"External user information.\\n\\n`IShoppingExternalUser` is an entity dsigned for when this system needs\\nto connect with external services and welcome their users as\\n{@link IShoppingCustomer customers} of this service.\\n\\nFor reference, customers who connect from an external service must have\\nthis record, and the external service user is identified through the two\\nattributes {@link application} and {@link uid}. If a customer connected\\nfrom an external service completes\\n{@link IShoppingCitizen real-name authentication} from this service, each\\ntime the external service user reconnects to this service and issues a\\nnew customer authentication token, real-name authentication begins with\\ncompleted.\\n\\nAnd {@link password} is the password issued to the user by the external\\nservice system (the so-called permanent user authentication token), and\\nis never the actual user password. However, for customers who entered the\\nsame application and uid as the current external system user, this is to\\ndetermine whether to view this as a correct external system user or a\\nviolation.\\n\\nIn addition, additional information received from external services can\\nbe recorded in the data field in JSON format.\"\n      },\n      \"IShoppingCitizen\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"title\": \"Primary Key\",\n            \"description\": \"Primary Key.\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"title\": \"Creation time of record\",\n            \"description\": \"Creation time of record.\"\n          },\n          \"mobile\": {\n            \"type\": \"string\",\n            \"pattern\": \"^[0-9]*$\",\n            \"x-wrtn-payment-order-mobile\": true,\n            \"title\": \"Mobile number\",\n            \"description\": \"Mobile number.\"\n          },\n          \"name\": {\n            \"type\": \"string\",\n            \"x-wrtn-payment-order-citizen\": true,\n            \"title\": \"Real name, or equivalent nickname\",\n            \"description\": \"Real name, or equivalent nickname.\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"created_at\",\n          \"mobile\",\n          \"name\"\n        ],\n        \"description\": \"Citizen verification information.\\n\\n`IShoppingCitizen` is an entity that records the user's\\n{@link name real name} and {@link mobile} input information.\\n\\nFor reference, in South Korea, real name authentication is required for\\ne-commerce participants, so the name attribute is important. However, the\\nsituation is different overseas, so in reality, mobile attributes are the\\nmost important, and identification of individual person is also done based\\non this mobile.\\n\\nOf course, real name and mobile phone authentication information are\\nencrypted and stored.\"\n      },\n      \"IShoppingAdministrator.IJoin\": {\n        \"type\": \"object\",\n        \"properties\": {},\n        \"required\": [],\n        \"description\": \"Joining request info.\"\n      },\n      \"IShoppingMember.ILogin\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"email\": {\n            \"type\": \"string\",\n            \"format\": \"email\",\n            \"title\": \"Email address of member\",\n            \"description\": \"Email address of member.\\n\\nIf the member has multiple email addresses, just use one of them.\"\n          },\n          \"password\": {\n            \"type\": \"string\",\n            \"title\": \"Password of the member account\",\n            \"description\": \"Password of the member account.\"\n          }\n        },\n        \"required\": [\n          \"email\",\n          \"password\"\n        ],\n        \"description\": \"Login request info.\"\n      },\n      \"IShoppingCoupon\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"title\": \"Primary Key\",\n            \"description\": \"Primary Key.\"\n          },\n          \"designer\": {\n            \"oneOf\": [\n              {\n                \"$ref\": \"#/components/schemas/IShoppingAdministrator\"\n              },\n              {\n                \"$ref\": \"#/components/schemas/IShoppingSeller\"\n              }\n            ],\n            \"title\": \"Designer who've made the coupon\",\n            \"description\": \"Designer who've made the coupon.\"\n          },\n          \"inventory\": {\n            \"$ref\": \"#/components/schemas/IShoppingCouponInventory\",\n            \"title\": \"Inventory information\",\n            \"description\": \"Inventory information.\"\n          },\n          \"criterias\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"oneOf\": [\n                {\n                  \"$ref\": \"#/components/schemas/IShoppingCouponSectionCriteria\"\n                },\n                {\n                  \"$ref\": \"#/components/schemas/IShoppingCouponSellerCriteria\"\n                },\n                {\n                  \"$ref\": \"#/components/schemas/IShoppingCouponSaleCriteria\"\n                },\n                {\n                  \"$ref\": \"#/components/schemas/IShoppingCouponFunnelCriteria\"\n                }\n              ]\n            },\n            \"title\": \"List of criteria information\",\n            \"description\": \"List of criteria information.\"\n          },\n          \"discount\": {\n            \"oneOf\": [\n              {\n                \"$ref\": \"#/components/schemas/IShoppingCouponDiscount.IAmount\"\n              },\n              {\n                \"$ref\": \"#/components/schemas/IShoppingCouponDiscount.IPercent\"\n              }\n            ],\n            \"title\": \"Discount information\",\n            \"description\": \"Discount information.\"\n          },\n          \"restriction\": {\n            \"$ref\": \"#/components/schemas/IShoppingCouponRestriction\",\n            \"title\": \"Restriction information\",\n            \"description\": \"Restriction information.\"\n          },\n          \"name\": {\n            \"type\": \"string\",\n            \"title\": \"Representative name of the coupon\",\n            \"description\": \"Representative name of the coupon.\"\n          },\n          \"opened_at\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\",\n                \"format\": \"date-time\"\n              }\n            ],\n            \"title\": \"Opening time of the coupon\",\n            \"description\": \"Opening time of the coupon.\"\n          },\n          \"closed_at\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\",\n                \"format\": \"date-time\"\n              }\n            ],\n            \"title\": \"Closing time of the coupon\",\n            \"description\": \"Closing time of the coupon.\\n\\nTickets cannot be issued after this time.\\n\\nHowever, previously issued tickets can still be used until their\\nexpiration date.\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"title\": \"Creation tie of the record\",\n            \"description\": \"Creation tie of the record.\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"designer\",\n          \"inventory\",\n          \"criterias\",\n          \"discount\",\n          \"restriction\",\n          \"name\",\n          \"opened_at\",\n          \"closed_at\",\n          \"created_at\"\n        ],\n        \"description\": \"Discount coupon.\\n\\n`IShoppingCoupon` is an entity that symbolizes discount coupons at\\na shopping mall.\\n\\nNote that, `IShoppingCoupon` only contains specification information\\nabout discount coupons. Please keep in mind that this is a different\\nconcept from {@link IShoppingCouponTicket}, which refers to the issuance\\nof a discount coupon, or {@link IShoppingCouponTicketPayment}, which\\nrefers to its payment.\\n\\nAdditionally, discount coupons are applied on an order-by-order basis,\\nbut each has its own unique restrictions. For example, a coupon with\\n{@link IShoppingCouponSellerCriteria} may or may not be used only for\\n{@link IShoppingSale} of listings registered by the {@link IShoppingSeller}.\\nAlso, there are restrictions such as\\n{@link IShoppingCouponDiscount.threshold minimum amount restrictions} for\\nusing discount coupons and\\n{@link IShoppingCouponDiscount.limit maximum discount amount limits}.\\n\\nIn addition, you can set whether to issue discount coupons publicly or\\ngive them only to people who know the specific issuing code. In addition,\\nthere are restrictions such as issued discount coupons having an\\n{@link IShoppingCouponRestriction.expired_at expiration date} or being\\nissued only to customers who came in through a\\n{@link IShoppingCouponFunnelCriteria specific funnel}.\\n\\nFor more information, please refer to the properties below and the\\nsubsidiary entities described later.\"\n      },\n      \"IShoppingAdministrator\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"title\": \"Primary Key\",\n            \"description\": \"Primary Key.\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"title\": \"Creation time of record\",\n            \"description\": \"Creation time of record.\\n\\nAnother words, the time when the administrator has signed up.\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"created_at\"\n        ],\n        \"description\": \"Administrator account.\\n\\n`IShoppingAdministrator` is an entity that embodies a person who manages\\nthe shopping mall system, with {@link IShoppingMember membership} joining.\\n\\nFor reference, unlike {@link IShoppingCustomer customers} which can participate\\neven without membership joining, administrator must join membership to operate\\nmanagements. Also, administrator must perform the\\n{@link IShoppingCitizen real-name and mobile authentication}, too.\"\n      },\n      \"IShoppingSeller\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"title\": \"Primary Key\",\n            \"description\": \"Primary Key.\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"title\": \"Creation tmie of record\",\n            \"description\": \"Creation tmie of record.\\n\\nAnother words, the time when the seller has signed up.\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"created_at\"\n        ],\n        \"description\": \"Seller information.\\n\\n`IShoppingSeller` is an entity that embodies a person who registers\\n{@link IShoppingSale sales} to operate selling activities, with\\n{@link IShoppingMember membership} joining.\\n\\nFor reference, unlike {@link IShoppingCustomer customers} which can\\nparticipate even without membership joining, seller must join membership\\nto operate sales. Also, seller must do the\\n{@link IShoppingCitizen real-name and mobile authentication}, too.\"\n      },\n      \"IShoppingCouponInventory\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"volume\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"integer\",\n                \"minimum\": 0\n              }\n            ],\n            \"title\": \"Remaining volume for everyone\",\n            \"description\": \"Remaining volume for everyone.\\n\\nIf there is a limit to the quantity issued, it becomes impossible to\\nissue tickets exceeding this value.\\n\\nIn other words, the concept of N coupons being issued on a first-come,\\nfirst-served basis is created.\"\n          },\n          \"volume_per_citizen\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"integer\",\n                \"minimum\": 0\n              }\n            ],\n            \"title\": \"Remaining volume per citizen\",\n            \"description\": \"Remaining volume per citizen.\\n\\nAs a limit to the total amount of issuance per person, it is common to\\nassign 1 to limit duplicate issuance to the same citizen, or to use the\\n`nul`` value to set no limit.\\n\\nOf course, by assigning a value of N, the total amount issued to the\\nsame citizen can be limited.\"\n          }\n        },\n        \"required\": [\n          \"volume\",\n          \"volume_per_citizen\"\n        ],\n        \"description\": \"Inventory information of the coupon.\\n\\nIf a {@link IShoppingCoupon coupon} has been designed with limited\\ninventory, this `IShoppingCouponInventory` structure represents the\\nremaining inventory information.\"\n      },\n      \"IShoppingCouponSectionCriteria\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"sections\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IShoppingSection\"\n            },\n            \"minItems\": 1,\n            \"title\": \"Target sections to include or exclude\",\n            \"description\": \"Target sections to include or exclude.\"\n          },\n          \"type\": {\n            \"const\": \"section\",\n            \"title\": \"Descrimanator type\",\n            \"description\": \"Descrimanator type.\"\n          },\n          \"direction\": {\n            \"oneOf\": [\n              {\n                \"const\": \"include\"\n              },\n              {\n                \"const\": \"exclude\"\n              }\n            ],\n            \"title\": \"Direction of the criteria\",\n            \"description\": \"Direction of the criteria.\"\n          }\n        },\n        \"required\": [\n          \"sections\",\n          \"type\",\n          \"direction\"\n        ],\n        \"description\": \"Conditions for sections of discount coupons.\\n\\n`IShoppingCouponSectionCriteria` is a subtype entity of\\n{@link IShoppingCouponCriteriaBase} and is used when setting conditions\\nfor a specific {@link IShoppingSection section}.\\n\\nIf the {@link direction} value is \\\"include\\\", the coupon can only be used\\nfor the target {@link sections}. Conversely, if it is \\\"exclude\\\", the\\ncoupon cannot be used.\"\n      },\n      \"IShoppingSection\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"title\": \"Primary Key\",\n            \"description\": \"Primary Key.\"\n          },\n          \"code\": {\n            \"type\": \"string\",\n            \"title\": \"Identifier code\",\n            \"description\": \"Identifier code.\"\n          },\n          \"name\": {\n            \"type\": \"string\",\n            \"title\": \"Representative name of the section\",\n            \"description\": \"Representative name of the section.\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"title\": \"Creation time of record\",\n            \"description\": \"Creation time of record.\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"code\",\n          \"name\",\n          \"created_at\"\n        ],\n        \"description\": \"Section information.\\n\\n`IShoppingSection` is a concept that refers to the spatial information of\\nthe market.\\n\\nIf we compare the section mentioned here to the offline market, it means a\\nspatially separated area within the store, such as the \\\"fruit corner\\\" or\\n\\\"butcher corner\\\". Therefore, in the {@link IShoppingSale sale} entity, it is\\nnot possible to classify multiple sections simultaneously, but only one section\\ncan be classified.\\n\\nBy the way, if your shopping mall system requires only one section, then just\\nuse only one. This concept is designed to be expandable in the future.\"\n      },\n      \"IShoppingCouponSellerCriteria\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"sellers\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IShoppingSeller\"\n            },\n            \"minItems\": 1,\n            \"title\": \"Target sellers to include or exclude\",\n            \"description\": \"Target sellers to include or exclude.\"\n          },\n          \"type\": {\n            \"const\": \"seller\",\n            \"title\": \"Descrimanator type\",\n            \"description\": \"Descrimanator type.\"\n          },\n          \"direction\": {\n            \"oneOf\": [\n              {\n                \"const\": \"include\"\n              },\n              {\n                \"const\": \"exclude\"\n              }\n            ],\n            \"title\": \"Direction of the criteria\",\n            \"description\": \"Direction of the criteria.\"\n          }\n        },\n        \"required\": [\n          \"sellers\",\n          \"type\",\n          \"direction\"\n        ],\n        \"description\": \"Conditions for sellers of discount coupons.\\n\\n`IShoppingCouponSellerCriteria` is a subtype entity of\\n{@link IShoppingCouponCriteriaBase} and is used when setting conditions\\nfor a specific {@link IShoppingSeller seller}.\\n\\nIf the {@link direction} value is \\\"include\\\", the coupon can only be used\\nfor the target {@link sellers}. Conversely, if it is \\\"exclude\\\", the\\ncoupon cannot be used.\"\n      },\n      \"IShoppingCouponSaleCriteria\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"sales\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IShoppingSale.ISummary\"\n            },\n            \"minItems\": 1,\n            \"title\": \"Target sales to include or exclude\",\n            \"description\": \"Target sales to include or exclude.\"\n          },\n          \"type\": {\n            \"const\": \"sale\",\n            \"title\": \"Descrimanator type\",\n            \"description\": \"Descrimanator type.\"\n          },\n          \"direction\": {\n            \"oneOf\": [\n              {\n                \"const\": \"include\"\n              },\n              {\n                \"const\": \"exclude\"\n              }\n            ],\n            \"title\": \"Direction of the criteria\",\n            \"description\": \"Direction of the criteria.\"\n          }\n        },\n        \"required\": [\n          \"sales\",\n          \"type\",\n          \"direction\"\n        ],\n        \"description\": \"Conditions for sales of discount coupons.\\n\\n`IShoppingCouponSaleCriteria` is a subtype entity of\\n{@link IShoppingCouponCriteriaBase} and is used when setting conditions\\nfor a specific {@link IShoppingSale sale}.\\n\\nIf the {@link direction} value is \\\"include\\\", the coupon can only be used\\nfor the target {@link sales}. Conversely, if it is \\\"exclude\\\", the\\ncoupon cannot be used.\"\n      },\n      \"IShoppingSale.ISummary\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"section\": {\n            \"$ref\": \"#/components/schemas/IShoppingSection\",\n            \"title\": \"Belonged section\",\n            \"description\": \"Belonged section.\"\n          },\n          \"seller\": {\n            \"$ref\": \"#/components/schemas/IShoppingSeller.ISummary\",\n            \"title\": \"Seller who has registered the sale\",\n            \"description\": \"Seller who has registered the sale.\"\n          },\n          \"price_range\": {\n            \"$ref\": \"#/components/schemas/IShoppingSalePriceRange\",\n            \"title\": \"Price range of the unit\",\n            \"description\": \"Price range of the unit.\"\n          },\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"title\": \"Primary Key of Sale\",\n            \"description\": \"Primary Key of Sale.\"\n          },\n          \"snapshot_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"title\": \"Primary Key of Snapshot\",\n            \"description\": \"Primary Key of Snapshot.\"\n          },\n          \"latest\": {\n            \"type\": \"boolean\",\n            \"title\": \"Whether the snapshot is the latest one or not\",\n            \"description\": \"Whether the snapshot is the latest one or not.\"\n          },\n          \"content\": {\n            \"$ref\": \"#/components/schemas/IShoppingSaleContent.IInvert\",\n            \"title\": \"Description and image content describing the sale\",\n            \"description\": \"Description and image content describing the sale.\"\n          },\n          \"categories\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IShoppingChannelCategory.IInvert\"\n            },\n            \"title\": \"List of categories\",\n            \"description\": \"List of categories.\\n\\nWhich categories the sale is registered to.\"\n          },\n          \"tags\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"type\": \"string\"\n            },\n            \"title\": \"List of search tags\",\n            \"description\": \"List of search tags.\"\n          },\n          \"units\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IShoppingSaleUnit.ISummary\"\n            },\n            \"minItems\": 1,\n            \"title\": \"List of units\",\n            \"description\": \"List of units.\\n\\nRecords about individual product composition information that are sold\\nin the sale. Each {@link IShoppingSaleUnit unit} record has configurable\\n{@link IShoppingSaleUnitOption options},\\n{@link IShoppingSaleUnitOptionCandidate candidate} values for each\\noption, and {@link IShoppingSaleUnitStock final stocks} determined by\\nselecting every candidate values of each option.\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"title\": \"Creation time of the record\",\n            \"description\": \"Creation time of the record.\\n\\nNote that, this property is different with {@link opened_at},\\nwhich means the timepoint of the sale is opened.\"\n          },\n          \"updated_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"title\": \"Last updated time of the record\",\n            \"description\": \"Last updated time of the record.\\n\\nIn another words, creation time of the last snapshot.\"\n          },\n          \"paused_at\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\",\n                \"format\": \"date-time\"\n              }\n            ],\n            \"title\": \"Paused time of the sale\",\n            \"description\": \"Paused time of the sale.\\n\\nThe sale is paused by the seller, for some reason.\\n\\n{@link IShoppingCustomer Customers} can still see the sale on the\\nboth list and detail pages, but the sale has a warning label\\n\\\"The sale is paused by the seller\\\".\"\n          },\n          \"suspended_at\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\",\n                \"format\": \"date-time\"\n              }\n            ],\n            \"title\": \"Suspended time of the sale\",\n            \"description\": \"Suspended time of the sale.\\n\\nThe sale is suspended by the seller, for some reason.\\n\\n{@link IShoppingCustomer Customers} cannot see the sale on the\\nboth list and detail pages. It is almost same with soft delettion,\\nbut there's a little bit difference that the owner\\n{@link IShoppingSeller seller} can still see the sale and resume it.\\n\\nOf course, the {@link IShoppingCustomer customers} who have\\nalready purchased the sale can still see the sale on the\\n{@link IShoppingOrder order} page.\"\n          },\n          \"opened_at\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\",\n                \"format\": \"date-time\"\n              }\n            ],\n            \"title\": \"Opening time of the sale\",\n            \"description\": \"Opening time of the sale.\"\n          },\n          \"closed_at\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\",\n                \"format\": \"date-time\"\n              }\n            ],\n            \"title\": \"Closing time of the sale\",\n            \"description\": \"Closing time of the sale.\\n\\nIf this value is `null`, the sale be continued forever.\"\n          }\n        },\n        \"required\": [\n          \"section\",\n          \"seller\",\n          \"price_range\",\n          \"id\",\n          \"snapshot_id\",\n          \"latest\",\n          \"content\",\n          \"categories\",\n          \"tags\",\n          \"units\",\n          \"created_at\",\n          \"updated_at\",\n          \"paused_at\",\n          \"suspended_at\",\n          \"opened_at\",\n          \"closed_at\"\n        ],\n        \"description\": \"Summarized information of sale.\\n\\nThis summarized information being used for pagination.\"\n      },\n      \"IShoppingSeller.ISummary\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"type\": {\n            \"const\": \"seller\",\n            \"title\": \"Discriminant for the type of seller\",\n            \"description\": \"Discriminant for the type of seller.\"\n          },\n          \"member\": {\n            \"$ref\": \"#/components/schemas/IShoppingMember.IInvert\",\n            \"title\": \"Membership joining information\",\n            \"description\": \"Membership joining information.\"\n          },\n          \"citizen\": {\n            \"$ref\": \"#/components/schemas/IShoppingCitizen\",\n            \"title\": \"Real-name and mobile number authentication information\",\n            \"description\": \"Real-name and mobile number authentication information.\"\n          },\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"title\": \"Primary Key\",\n            \"description\": \"Primary Key.\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"title\": \"Creation tmie of record\",\n            \"description\": \"Creation tmie of record.\\n\\nAnother words, the time when the seller has signed up.\"\n          }\n        },\n        \"required\": [\n          \"type\",\n          \"member\",\n          \"citizen\",\n          \"id\",\n          \"created_at\"\n        ],\n        \"description\": \"Summary of seller information.\"\n      },\n      \"IShoppingSalePriceRange\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"lowest\": {\n            \"$ref\": \"#/components/schemas/IShoppingPrice\"\n          },\n          \"highest\": {\n            \"$ref\": \"#/components/schemas/IShoppingPrice\"\n          }\n        },\n        \"required\": [\n          \"lowest\",\n          \"highest\"\n        ]\n      },\n      \"IShoppingPrice\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"nominal\": {\n            \"type\": \"number\",\n            \"minimum\": 0,\n            \"title\": \"Nominal price\",\n            \"description\": \"Nominal price.\\n\\nThis is not {@link real real price} to pay, but just a nominal price to show.\\nIf this value is greater than the {@link real real price}, it would be shown\\nlike {@link IShoppingSeller seller} is giving a discount.\"\n          },\n          \"real\": {\n            \"type\": \"number\",\n            \"minimum\": 0,\n            \"title\": \"Real price to pay\",\n            \"description\": \"Real price to pay.\"\n          }\n        },\n        \"required\": [\n          \"nominal\",\n          \"real\"\n        ],\n        \"description\": \"Shopping price interface.\"\n      },\n      \"IShoppingSaleContent.IInvert\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\"\n          },\n          \"title\": {\n            \"type\": \"string\"\n          },\n          \"thumbnails\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IAttachmentFile\"\n            }\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"title\",\n          \"thumbnails\"\n        ]\n      },\n      \"IAttachmentFile\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"title\": \"Primary Key\",\n            \"description\": \"Primary Key.\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"title\": \"Creation time of attachment file\",\n            \"description\": \"Creation time of attachment file.\"\n          },\n          \"name\": {\n            \"type\": \"string\",\n            \"maxLength\": 255,\n            \"title\": \"File name, except extension\",\n            \"description\": \"File name, except extension.\\n\\nIf there's file `.gitignore`, then its name is an empty string.\"\n          },\n          \"extension\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\",\n                \"minLength\": 1,\n                \"maxLength\": 8\n              }\n            ],\n            \"title\": \"Extension\",\n            \"description\": \"Extension.\\n\\nPossible to omit like `README` case.\"\n          },\n          \"url\": {\n            \"type\": \"string\",\n            \"format\": \"uri\",\n            \"contentMediaType\": \"image/*\",\n            \"title\": \"URL path of the real file\",\n            \"description\": \"URL path of the real file.\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"created_at\",\n          \"name\",\n          \"extension\",\n          \"url\"\n        ],\n        \"description\": \"Attachment File.\\n\\nEvery attachment files that are managed in current system.\\n\\nFor reference, it is possible to omit one of file {@link name}\\nor {@link extension} like `.gitignore` or `README` case, but not\\npossible to omit both of them.\"\n      },\n      \"IShoppingChannelCategory.IInvert\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"parent\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"$ref\": \"#/components/schemas/IShoppingChannelCategory.IInvert\"\n              }\n            ],\n            \"title\": \"Parent category info with recursive structure\",\n            \"description\": \"Parent category info with recursive structure.\\n\\nIf no parent exists, then be `null`.\"\n          },\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"title\": \"Primary Key\",\n            \"description\": \"Primary Key.\"\n          },\n          \"code\": {\n            \"type\": \"string\",\n            \"title\": \"Identifier code of the category\",\n            \"description\": \"Identifier code of the category.\\n\\nThe code must be unique in the channel.\"\n          },\n          \"parent_id\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\",\n                \"format\": \"uuid\"\n              }\n            ],\n            \"title\": \"Parent category's ID\",\n            \"description\": \"Parent category's ID.\"\n          },\n          \"name\": {\n            \"type\": \"string\",\n            \"title\": \"Representative name of the category\",\n            \"description\": \"Representative name of the category.\\n\\nThe name must be unique within the parent category. If no parent exists,\\nthen the name must be unique within the channel between no parent\\ncategories.\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"title\": \"Creation time of record\",\n            \"description\": \"Creation time of record.\"\n          }\n        },\n        \"required\": [\n          \"parent\",\n          \"id\",\n          \"code\",\n          \"parent_id\",\n          \"name\",\n          \"created_at\"\n        ],\n        \"description\": \"Invert category information with parent category.\"\n      },\n      \"IShoppingSaleUnit.ISummary\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"price_range\": {\n            \"$ref\": \"#/components/schemas/IShoppingSalePriceRange\"\n          },\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"title\": \"Primary Key\",\n            \"description\": \"Primary Key.\"\n          },\n          \"name\": {\n            \"type\": \"string\",\n            \"title\": \"Representative name of the unit\",\n            \"description\": \"Representative name of the unit.\"\n          },\n          \"primary\": {\n            \"type\": \"boolean\",\n            \"title\": \"Whether the unit is primary or not\",\n            \"description\": \"Whether the unit is primary or not.\\n\\nJust a labeling value.\"\n          },\n          \"required\": {\n            \"type\": \"boolean\",\n            \"title\": \"Whether the unit is required or not\",\n            \"description\": \"Whether the unit is required or not.\\n\\nWhen the unit is required, the customer must select the unit. If do not\\nselect, customer can't buy it.\\n\\nFor example, if there's a sale \\\"Macbook Set\\\" and one of the unit is the\\n\\\"Main Body\\\", is it possible to buy the \\\"Macbook Set\\\" without the\\n\\\"Main Body\\\" unit? This property is for that case.\"\n          }\n        },\n        \"required\": [\n          \"price_range\",\n          \"id\",\n          \"name\",\n          \"primary\",\n          \"required\"\n        ]\n      },\n      \"IShoppingCouponFunnelCriteria\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"funnels\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"oneOf\": [\n                {\n                  \"$ref\": \"#/components/schemas/IShoppingCouponFunnelCriteria.IValueFunnel\"\n                },\n                {\n                  \"$ref\": \"#/components/schemas/IShoppingCouponFunnelCriteria.IVariableFunnel\"\n                }\n              ]\n            },\n            \"minItems\": 1,\n            \"title\": \"List of target funnels\",\n            \"description\": \"List of target funnels.\"\n          },\n          \"type\": {\n            \"const\": \"funnel\",\n            \"title\": \"Descrimanator type\",\n            \"description\": \"Descrimanator type.\"\n          },\n          \"direction\": {\n            \"oneOf\": [\n              {\n                \"const\": \"include\"\n              },\n              {\n                \"const\": \"exclude\"\n              }\n            ],\n            \"title\": \"Direction of the criteria\",\n            \"description\": \"Direction of the criteria.\"\n          }\n        },\n        \"required\": [\n          \"funnels\",\n          \"type\",\n          \"direction\"\n        ],\n        \"description\": \"Limit the funnel of discount coupons.\\n\\n`ishoppingcouponfunnelcriteria` is a subtype entity of\\n{@link IShoppingCouponCriteria}, and is used when you want to issue or\\nexclude discount coupons only to {@link IShoppingCustomer customers} who\\ncame from a specific path.\\n\\nAnd funnel restrictions are possible in 3 ways: The first is\\n{@link IShoppingCustomer.referrer}, and by parsing\\n{@link IShoppingCustomer.href}, which records the customer's access\\naddress, restrictions can be made in units of specific URLs or variables.\"\n      },\n      \"IShoppingCouponFunnelCriteria.IValueFunnel\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"kind\": {\n            \"oneOf\": [\n              {\n                \"const\": \"url\"\n              },\n              {\n                \"const\": \"referrer\"\n              }\n            ],\n            \"title\": \"Kind of funnel restriction\",\n            \"description\": \"Kind of funnel restriction.\"\n          },\n          \"value\": {\n            \"type\": \"string\",\n            \"title\": \"Target value\",\n            \"description\": \"Target value.\"\n          }\n        },\n        \"required\": [\n          \"kind\",\n          \"value\"\n        ],\n        \"description\": \"Kind of funnel restriction by a value.\"\n      },\n      \"IShoppingCouponFunnelCriteria.IVariableFunnel\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"kind\": {\n            \"const\": \"variable\",\n            \"title\": \"Kind of funnel restriction\",\n            \"description\": \"Kind of funnel restriction.\"\n          },\n          \"key\": {\n            \"type\": \"string\",\n            \"title\": \"Target variable's key\",\n            \"description\": \"Target variable's key.\"\n          },\n          \"value\": {\n            \"type\": \"string\",\n            \"title\": \"Target variable's value\",\n            \"description\": \"Target variable's value.\"\n          }\n        },\n        \"required\": [\n          \"kind\",\n          \"key\",\n          \"value\"\n        ],\n        \"description\": \"Kind of funnel restriction by a variable.\"\n      },\n      \"IShoppingCouponDiscount.IAmount\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"unit\": {\n            \"const\": \"amount\",\n            \"title\": \"Discount unit as amount\",\n            \"description\": \"Discount unit as amount.\\n\\nIt means the order price would be discounted by the amount value.\"\n          },\n          \"value\": {\n            \"type\": \"number\",\n            \"title\": \"Discount value as amount\",\n            \"description\": \"Discount value as amount.\"\n          },\n          \"threshold\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"number\",\n                \"minimum\": 0\n              }\n            ],\n            \"title\": \"Minimum purchase amount for discount\",\n            \"description\": \"Minimum purchase amount for discount.\\n\\nWhen setting this value, discount coupons cannot be applied to\\norder totals that are less than this value.\"\n          },\n          \"limit\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"number\",\n                \"exclusiveMinimum\": 0\n              }\n            ],\n            \"title\": \"Maximum amount available for discount\",\n            \"description\": \"Maximum amount available for discount.\\n\\nWhen this value is set, no further discount will be given no\\nmatter how much you order. This property would be meaningful\\nonly when the {@link multiplicative} is `true`.\"\n          },\n          \"multiplicative\": {\n            \"type\": \"boolean\",\n            \"title\": \"Multiplicative or not\",\n            \"description\": \"Multiplicative or not.\\n\\nIf this property is `true`, the discount value would be multiplied\\nto the {@link IShoppingCartCommodity.volume} or\\n{@link IShoppingOrderGood.volume} value. Also, in that case,\\nthe {@link limit} property would be meaningful.\"\n          }\n        },\n        \"required\": [\n          \"unit\",\n          \"value\",\n          \"threshold\",\n          \"limit\",\n          \"multiplicative\"\n        ],\n        \"description\": \"Discount information with amount unit.\"\n      },\n      \"IShoppingCouponDiscount.IPercent\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"unit\": {\n            \"const\": \"percent\",\n            \"title\": \"Discount unit as percent\",\n            \"description\": \"Discount unit as percent.\\n\\nIt means the order price would be discounted by the percent value.\"\n          },\n          \"value\": {\n            \"type\": \"number\",\n            \"minimum\": 0,\n            \"maximum\": 100,\n            \"title\": \"Discount value as percent\",\n            \"description\": \"Discount value as percent.\"\n          },\n          \"threshold\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"number\",\n                \"minimum\": 0\n              }\n            ],\n            \"title\": \"Minimum purchase amount for discount\",\n            \"description\": \"Minimum purchase amount for discount.\\n\\nWhen setting this value, discount coupons cannot be applied to\\norder totals that are less than this value.\"\n          },\n          \"limit\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"number\",\n                \"exclusiveMinimum\": 0\n              }\n            ],\n            \"title\": \"Maximum amount available for discount\",\n            \"description\": \"Maximum amount available for discount.\\n\\nWhen this value is set, no further discount will be given no\\nmatter how much you order.\"\n          }\n        },\n        \"required\": [\n          \"unit\",\n          \"value\",\n          \"threshold\",\n          \"limit\"\n        ],\n        \"description\": \"Discount information with percent unit.\"\n      },\n      \"IShoppingCouponRestriction\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"access\": {\n            \"oneOf\": [\n              {\n                \"const\": \"public\"\n              },\n              {\n                \"const\": \"private\"\n              }\n            ],\n            \"title\": \"Access level of coupon\",\n            \"description\": \"Access level of coupon.\\n\\n- public: possible to find from public API\\n- private: unable to find from public API\\n  - arbitrarily assigned by the seller or administrator\\n  - issued from one-time link\"\n          },\n          \"exclusive\": {\n            \"type\": \"boolean\",\n            \"title\": \"Exclusivity or not\",\n            \"description\": \"Exclusivity or not.\\n\\nAn exclusive discount coupon refers to a discount coupon that has an\\nexclusive relationship with other discount coupons and can only be\\nused alone. That is, when an exclusive discount coupon is used, no\\nother discount coupon can be used for the same\\n{@link IShoppingOrder order} or {@link IShoppingOrderGood good}.\\n\\nPlease note that this exclusive attribute is a very different concept\\nfrom multiplicative, which means whether the same coupon can be\\nmultiplied and applied to multiple coupons of the same order, so\\nplease do not confuse them.\"\n          },\n          \"volume\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"integer\",\n                \"minimum\": 0\n              }\n            ],\n            \"title\": \"Limited quantity issued\",\n            \"description\": \"Limited quantity issued.\\n\\nIf there is a limit to the quantity issued, it becomes impossible\\nto issue tickets exceeding this value.\\n\\nIn other words, the concept of N coupons being issued on\\na first-come, first-served basis is created.\"\n          },\n          \"volume_per_citizen\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"integer\",\n                \"minimum\": 0\n              }\n            ],\n            \"title\": \"Limited quantity issued per person\",\n            \"description\": \"Limited quantity issued per person.\\n\\nAs a limit to the total amount of issuance per person, it is\\ncommon to assign 1 to limit duplicate issuance to the same citizen,\\nor to use the NULL value to set no limit.\\n\\nOf course, by assigning a value of N, the total amount issued\\nto the same citizen can be limited.\"\n          },\n          \"expired_in\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"integer\",\n                \"minimum\": 0\n              }\n            ],\n            \"title\": \"Expiration day(s) value\",\n            \"description\": \"Expiration day(s) value.\\n\\nThe concept of expiring N days after a discount coupon ticket is issued.\\n\\nTherefore, customers must use the ticket within N days, if possible,\\nfrom the time it is issued.\"\n          },\n          \"expired_at\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\",\n                \"format\": \"date-time\"\n              }\n            ],\n            \"title\": \"Expiration date\",\n            \"description\": \"Expiration date.\\n\\nA concept that expires after YYYY-MM-DD after a discount coupon ticket\\nis issued.\\n\\nDouble restrictions are possible with expired_in, of which the one\\nwith the shorter expiration date is used.\"\n          }\n        },\n        \"required\": [\n          \"access\",\n          \"exclusive\",\n          \"volume\",\n          \"volume_per_citizen\",\n          \"expired_in\",\n          \"expired_at\"\n        ],\n        \"description\": \"Restriction information of the coupon.\"\n      },\n      \"IShoppingCoupon.ICreate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"discount\": {\n            \"oneOf\": [\n              {\n                \"$ref\": \"#/components/schemas/IShoppingCouponDiscount.IAmount\"\n              },\n              {\n                \"$ref\": \"#/components/schemas/IShoppingCouponDiscount.IPercent\"\n              }\n            ],\n            \"title\": \"Discount information\",\n            \"description\": \"Discount information.\"\n          },\n          \"restriction\": {\n            \"$ref\": \"#/components/schemas/IShoppingCouponRestriction\",\n            \"title\": \"Restriction information\",\n            \"description\": \"Restriction information.\"\n          },\n          \"criterias\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"oneOf\": [\n                {\n                  \"$ref\": \"#/components/schemas/IShoppingCouponSectionCriteria.ICreate\"\n                },\n                {\n                  \"$ref\": \"#/components/schemas/IShoppingCouponSellerCriteria.ICreate\"\n                },\n                {\n                  \"$ref\": \"#/components/schemas/IShoppingCouponSaleCriteria.ICreate\"\n                },\n                {\n                  \"$ref\": \"#/components/schemas/IShoppingCouponFunnelCriteria.ICreate\"\n                }\n              ]\n            },\n            \"title\": \"List of criteria information\",\n            \"description\": \"List of criteria information.\"\n          },\n          \"disposable_codes\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"type\": \"string\"\n            },\n            \"title\": \"Disposable codes for the coupon\",\n            \"description\": \"Disposable codes for the coupon.\"\n          },\n          \"name\": {\n            \"type\": \"string\",\n            \"title\": \"Representative name of the coupon\",\n            \"description\": \"Representative name of the coupon.\"\n          },\n          \"opened_at\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\",\n                \"format\": \"date-time\"\n              }\n            ],\n            \"title\": \"Opening time of the coupon\",\n            \"description\": \"Opening time of the coupon.\"\n          },\n          \"closed_at\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\",\n                \"format\": \"date-time\"\n              }\n            ],\n            \"title\": \"Closing time of the coupon\",\n            \"description\": \"Closing time of the coupon.\\n\\nTickets cannot be issued after this time.\\n\\nHowever, previously issued tickets can still be used until their\\nexpiration date.\"\n          }\n        },\n        \"required\": [\n          \"discount\",\n          \"restriction\",\n          \"criterias\",\n          \"disposable_codes\",\n          \"name\",\n          \"opened_at\",\n          \"closed_at\"\n        ],\n        \"description\": \"Creation information of the coupon.\"\n      },\n      \"IShoppingCouponSectionCriteria.ICreate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"section_codes\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"type\": \"string\"\n            },\n            \"minItems\": 1,\n            \"title\": \"List of target section's {@link IShoppingSection.code}s\",\n            \"description\": \"List of target section's {@link IShoppingSection.code}s.\"\n          },\n          \"type\": {\n            \"const\": \"section\"\n          },\n          \"direction\": {\n            \"oneOf\": [\n              {\n                \"const\": \"include\"\n              },\n              {\n                \"const\": \"exclude\"\n              }\n            ]\n          }\n        },\n        \"required\": [\n          \"section_codes\",\n          \"type\",\n          \"direction\"\n        ],\n        \"description\": \"Creation information of the section criteria.\"\n      },\n      \"IShoppingCouponSellerCriteria.ICreate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"seller_ids\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"minItems\": 1,\n            \"title\": \"List of target seller's {@link IShoppingSeller.id}s\",\n            \"description\": \"List of target seller's {@link IShoppingSeller.id}s.\"\n          },\n          \"type\": {\n            \"const\": \"seller\"\n          },\n          \"direction\": {\n            \"oneOf\": [\n              {\n                \"const\": \"include\"\n              },\n              {\n                \"const\": \"exclude\"\n              }\n            ]\n          }\n        },\n        \"required\": [\n          \"seller_ids\",\n          \"type\",\n          \"direction\"\n        ],\n        \"description\": \"Creation information of the seller criteria.\"\n      },\n      \"IShoppingCouponSaleCriteria.ICreate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"sale_ids\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"minItems\": 1,\n            \"title\": \"List of target sale's {@link IShoppingSale.id}s\",\n            \"description\": \"List of target sale's {@link IShoppingSale.id}s.\"\n          },\n          \"type\": {\n            \"const\": \"sale\"\n          },\n          \"direction\": {\n            \"oneOf\": [\n              {\n                \"const\": \"include\"\n              },\n              {\n                \"const\": \"exclude\"\n              }\n            ]\n          }\n        },\n        \"required\": [\n          \"sale_ids\",\n          \"type\",\n          \"direction\"\n        ],\n        \"description\": \"Creation information of the sale criteria.\"\n      },\n      \"IShoppingCouponFunnelCriteria.ICreate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"funnels\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"oneOf\": [\n                {\n                  \"$ref\": \"#/components/schemas/IShoppingCouponFunnelCriteria.IValueFunnel\"\n                },\n                {\n                  \"$ref\": \"#/components/schemas/IShoppingCouponFunnelCriteria.IVariableFunnel\"\n                }\n              ]\n            },\n            \"minItems\": 1,\n            \"title\": \"List of target funnels\",\n            \"description\": \"List of target funnels.\"\n          },\n          \"type\": {\n            \"const\": \"funnel\"\n          },\n          \"direction\": {\n            \"oneOf\": [\n              {\n                \"const\": \"include\"\n              },\n              {\n                \"const\": \"exclude\"\n              }\n            ]\n          }\n        },\n        \"required\": [\n          \"funnels\",\n          \"type\",\n          \"direction\"\n        ],\n        \"description\": \"Creation information of the funnel criteria.\"\n      },\n      \"IPageIShoppingCoupon\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"pagination\": {\n            \"$ref\": \"#/components/schemas/IPage.IPagination\",\n            \"title\": \"Page information\",\n            \"description\": \"Page information.\"\n          },\n          \"data\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IShoppingCoupon\"\n            },\n            \"title\": \"List of records\",\n            \"description\": \"List of records.\"\n          }\n        },\n        \"required\": [\n          \"pagination\",\n          \"data\"\n        ],\n        \"description\": \"A page.\\n\\nCollection of records with pagination indformation.\"\n      },\n      \"IPage.IPagination\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"current\": {\n            \"type\": \"integer\",\n            \"minimum\": 0,\n            \"title\": \"Current page number\",\n            \"description\": \"Current page number.\"\n          },\n          \"limit\": {\n            \"type\": \"integer\",\n            \"minimum\": 0,\n            \"title\": \"Limitation of records per a page\",\n            \"description\": \"Limitation of records per a page.\"\n          },\n          \"records\": {\n            \"type\": \"integer\",\n            \"minimum\": 0,\n            \"title\": \"Total records in the database\",\n            \"description\": \"Total records in the database.\"\n          },\n          \"pages\": {\n            \"type\": \"integer\",\n            \"minimum\": 0,\n            \"title\": \"Total pages\",\n            \"description\": \"Total pages.\\n\\nEqual to {@link records} / {@link limit} with ceiling.\"\n          }\n        },\n        \"required\": [\n          \"current\",\n          \"limit\",\n          \"records\",\n          \"pages\"\n        ],\n        \"description\": \"Page information.\"\n      },\n      \"IShoppingCoupon.IRequest\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"search\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"$ref\": \"#/components/schemas/IShoppingCoupon.IRequest.ISearch\"\n              }\n            ]\n          },\n          \"sort\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"array\",\n                \"items\": {\n                  \"oneOf\": [\n                    {\n                      \"const\": \"-coupon.name\"\n                    },\n                    {\n                      \"const\": \"-coupon.unit\"\n                    },\n                    {\n                      \"const\": \"-coupon.value\"\n                    },\n                    {\n                      \"const\": \"-coupon.created_at\"\n                    },\n                    {\n                      \"const\": \"-coupon.opened_at\"\n                    },\n                    {\n                      \"const\": \"-coupon.closed_at\"\n                    },\n                    {\n                      \"const\": \"+coupon.name\"\n                    },\n                    {\n                      \"const\": \"+coupon.unit\"\n                    },\n                    {\n                      \"const\": \"+coupon.value\"\n                    },\n                    {\n                      \"const\": \"+coupon.created_at\"\n                    },\n                    {\n                      \"const\": \"+coupon.opened_at\"\n                    },\n                    {\n                      \"const\": \"+coupon.closed_at\"\n                    }\n                  ]\n                }\n              }\n            ]\n          },\n          \"page\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"integer\",\n                \"minimum\": 0\n              }\n            ],\n            \"title\": \"Page number\",\n            \"description\": \"Page number.\"\n          },\n          \"limit\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"integer\",\n                \"minimum\": 0\n              }\n            ],\n            \"title\": \"Limitation of records per a page\",\n            \"description\": \"Limitation of records per a page.\"\n          }\n        },\n        \"required\": []\n      },\n      \"IShoppingCoupon.IRequest.ISearch\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"name\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\"\n              }\n            ]\n          }\n        },\n        \"required\": []\n      },\n      \"IPageIShoppingDeposit\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"pagination\": {\n            \"$ref\": \"#/components/schemas/IPage.IPagination\",\n            \"title\": \"Page information\",\n            \"description\": \"Page information.\"\n          },\n          \"data\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IShoppingDeposit\"\n            },\n            \"title\": \"List of records\",\n            \"description\": \"List of records.\"\n          }\n        },\n        \"required\": [\n          \"pagination\",\n          \"data\"\n        ],\n        \"description\": \"A page.\\n\\nCollection of records with pagination indformation.\"\n      },\n      \"IShoppingDeposit\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\"\n          },\n          \"code\": {\n            \"type\": \"string\"\n          },\n          \"source\": {\n            \"type\": \"string\"\n          },\n          \"direction\": {\n            \"oneOf\": [\n              {\n                \"const\": -1\n              },\n              {\n                \"const\": 1\n              }\n            ]\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"created_at\",\n          \"code\",\n          \"source\",\n          \"direction\"\n        ]\n      },\n      \"IShoppingDeposit.IRequest\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"search\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"$ref\": \"#/components/schemas/IShoppingDeposit.IRequest.ISearch\"\n              }\n            ]\n          },\n          \"sort\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"array\",\n                \"items\": {\n                  \"oneOf\": [\n                    {\n                      \"const\": \"-deposit.source\"\n                    },\n                    {\n                      \"const\": \"-deposit.code\"\n                    },\n                    {\n                      \"const\": \"-deposit.direction\"\n                    },\n                    {\n                      \"const\": \"+deposit.source\"\n                    },\n                    {\n                      \"const\": \"+deposit.code\"\n                    },\n                    {\n                      \"const\": \"+deposit.direction\"\n                    }\n                  ]\n                }\n              }\n            ]\n          },\n          \"page\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"integer\",\n                \"minimum\": 0\n              }\n            ],\n            \"title\": \"Page number\",\n            \"description\": \"Page number.\"\n          },\n          \"limit\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"integer\",\n                \"minimum\": 0\n              }\n            ],\n            \"title\": \"Limitation of records per a page\",\n            \"description\": \"Limitation of records per a page.\"\n          }\n        },\n        \"required\": []\n      },\n      \"IShoppingDeposit.IRequest.ISearch\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"source\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\"\n              }\n            ]\n          },\n          \"code\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\"\n              }\n            ]\n          },\n          \"direction\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"const\": -1\n              },\n              {\n                \"const\": 1\n              }\n            ]\n          }\n        },\n        \"required\": []\n      },\n      \"IShoppingDeposit.ICreate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"code\": {\n            \"type\": \"string\"\n          },\n          \"source\": {\n            \"type\": \"string\"\n          },\n          \"direction\": {\n            \"oneOf\": [\n              {\n                \"const\": -1\n              },\n              {\n                \"const\": 1\n              }\n            ]\n          }\n        },\n        \"required\": [\n          \"code\",\n          \"source\",\n          \"direction\"\n        ]\n      },\n      \"IPageIShoppingMileage\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"pagination\": {\n            \"$ref\": \"#/components/schemas/IPage.IPagination\",\n            \"title\": \"Page information\",\n            \"description\": \"Page information.\"\n          },\n          \"data\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IShoppingMileage\"\n            },\n            \"title\": \"List of records\",\n            \"description\": \"List of records.\"\n          }\n        },\n        \"required\": [\n          \"pagination\",\n          \"data\"\n        ],\n        \"description\": \"A page.\\n\\nCollection of records with pagination indformation.\"\n      },\n      \"IShoppingMileage\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\"\n          },\n          \"value\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"number\"\n              }\n            ]\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\"\n          },\n          \"code\": {\n            \"type\": \"string\"\n          },\n          \"source\": {\n            \"type\": \"string\"\n          },\n          \"direction\": {\n            \"oneOf\": [\n              {\n                \"const\": -1\n              },\n              {\n                \"const\": 1\n              }\n            ]\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"value\",\n          \"created_at\",\n          \"code\",\n          \"source\",\n          \"direction\"\n        ]\n      },\n      \"IShoppingMileage.IRequest\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"search\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"$ref\": \"#/components/schemas/IShoppingMileage.IRequest.ISearch\"\n              }\n            ]\n          },\n          \"sort\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"array\",\n                \"items\": {\n                  \"oneOf\": [\n                    {\n                      \"const\": \"-mileage.source\"\n                    },\n                    {\n                      \"const\": \"-mileage.code\"\n                    },\n                    {\n                      \"const\": \"-mileage.direction\"\n                    },\n                    {\n                      \"const\": \"+mileage.source\"\n                    },\n                    {\n                      \"const\": \"+mileage.code\"\n                    },\n                    {\n                      \"const\": \"+mileage.direction\"\n                    }\n                  ]\n                }\n              }\n            ]\n          },\n          \"page\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"integer\",\n                \"minimum\": 0\n              }\n            ],\n            \"title\": \"Page number\",\n            \"description\": \"Page number.\"\n          },\n          \"limit\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"integer\",\n                \"minimum\": 0\n              }\n            ],\n            \"title\": \"Limitation of records per a page\",\n            \"description\": \"Limitation of records per a page.\"\n          }\n        },\n        \"required\": []\n      },\n      \"IShoppingMileage.IRequest.ISearch\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"source\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\"\n              }\n            ]\n          },\n          \"code\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\"\n              }\n            ]\n          },\n          \"direction\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"const\": -1\n              },\n              {\n                \"const\": 1\n              }\n            ]\n          }\n        },\n        \"required\": []\n      },\n      \"IShoppingMileage.ICreate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"code\": {\n            \"type\": \"string\"\n          },\n          \"source\": {\n            \"type\": \"string\"\n          },\n          \"direction\": {\n            \"oneOf\": [\n              {\n                \"const\": -1\n              },\n              {\n                \"const\": 1\n              }\n            ]\n          },\n          \"value\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"number\"\n              }\n            ]\n          }\n        },\n        \"required\": [\n          \"code\",\n          \"source\",\n          \"direction\",\n          \"value\"\n        ]\n      },\n      \"IPageIShoppingMileageDonation\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"pagination\": {\n            \"$ref\": \"#/components/schemas/IPage.IPagination\",\n            \"title\": \"Page information\",\n            \"description\": \"Page information.\"\n          },\n          \"data\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IShoppingMileageDonation\"\n            },\n            \"title\": \"List of records\",\n            \"description\": \"List of records.\"\n          }\n        },\n        \"required\": [\n          \"pagination\",\n          \"data\"\n        ],\n        \"description\": \"A page.\\n\\nCollection of records with pagination indformation.\"\n      },\n      \"IShoppingMileageDonation\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\"\n          },\n          \"administrator\": {\n            \"$ref\": \"#/components/schemas/IShoppingAdministrator.IInvert\"\n          },\n          \"citizen\": {\n            \"$ref\": \"#/components/schemas/IShoppingCitizen\"\n          },\n          \"value\": {\n            \"type\": \"number\"\n          },\n          \"reason\": {\n            \"type\": \"string\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"administrator\",\n          \"citizen\",\n          \"value\",\n          \"reason\",\n          \"created_at\"\n        ]\n      },\n      \"IShoppingMileageDonation.IRequest\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"search\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"$ref\": \"#/components/schemas/IShoppingMileageDonation.IRequest.ISearch\"\n              }\n            ]\n          },\n          \"sort\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"array\",\n                \"items\": {\n                  \"oneOf\": [\n                    {\n                      \"const\": \"-donation.created_at\"\n                    },\n                    {\n                      \"const\": \"-donation.value\"\n                    },\n                    {\n                      \"const\": \"-donation.reason\"\n                    },\n                    {\n                      \"const\": \"+donation.created_at\"\n                    },\n                    {\n                      \"const\": \"+donation.value\"\n                    },\n                    {\n                      \"const\": \"+donation.reason\"\n                    }\n                  ]\n                }\n              }\n            ]\n          },\n          \"page\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"integer\",\n                \"minimum\": 0\n              }\n            ],\n            \"title\": \"Page number\",\n            \"description\": \"Page number.\"\n          },\n          \"limit\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"integer\",\n                \"minimum\": 0\n              }\n            ],\n            \"title\": \"Limitation of records per a page\",\n            \"description\": \"Limitation of records per a page.\"\n          }\n        },\n        \"required\": []\n      },\n      \"IShoppingMileageDonation.IRequest.ISearch\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"citizen\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"$ref\": \"#/components/schemas/IShoppingCitizen.IRequest.ISearch\"\n              }\n            ]\n          },\n          \"minimum\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"number\",\n                \"minimum\": 0\n              }\n            ]\n          },\n          \"maximum\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"number\",\n                \"minimum\": 0\n              }\n            ]\n          },\n          \"from\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\",\n                \"format\": \"date-time\"\n              }\n            ]\n          },\n          \"to\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\",\n                \"format\": \"date-time\"\n              }\n            ]\n          }\n        },\n        \"required\": []\n      },\n      \"IShoppingCitizen.IRequest.ISearch\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"mobile\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\",\n                \"pattern\": \"^[0-9]*$\"\n              }\n            ]\n          },\n          \"name\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\"\n              }\n            ]\n          }\n        },\n        \"required\": []\n      },\n      \"IShoppingMileageDonation.ICreate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"citizen_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\"\n          },\n          \"value\": {\n            \"type\": \"number\"\n          },\n          \"reason\": {\n            \"type\": \"string\"\n          }\n        },\n        \"required\": [\n          \"citizen_id\",\n          \"value\",\n          \"reason\"\n        ]\n      },\n      \"IPageIShoppingOrder\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"pagination\": {\n            \"$ref\": \"#/components/schemas/IPage.IPagination\",\n            \"title\": \"Page information\",\n            \"description\": \"Page information.\"\n          },\n          \"data\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IShoppingOrder\"\n            },\n            \"title\": \"List of records\",\n            \"description\": \"List of records.\"\n          }\n        },\n        \"required\": [\n          \"pagination\",\n          \"data\"\n        ],\n        \"description\": \"A page.\\n\\nCollection of records with pagination indformation.\"\n      },\n      \"IShoppingOrder\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"x-wrtn-payment-order-id\": true,\n            \"title\": \"Primary Key\",\n            \"description\": \"Primary Key.\"\n          },\n          \"name\": {\n            \"type\": \"string\",\n            \"x-wrtn-payment-order-name\": true,\n            \"title\": \"Representative name of the order\",\n            \"description\": \"Representative name of the order.\"\n          },\n          \"customer\": {\n            \"$ref\": \"#/components/schemas/IShoppingCustomer\",\n            \"title\": \"Customer who've applied for the order\",\n            \"description\": \"Customer who've applied for the order.\"\n          },\n          \"goods\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IShoppingOrderGood\"\n            },\n            \"minItems\": 1,\n            \"title\": \"List of goods in the order\",\n            \"description\": \"List of goods in the order.\"\n          },\n          \"price\": {\n            \"$ref\": \"#/components/schemas/IShoppingOrderPrice\",\n            \"title\": \"Price information including discounts\",\n            \"description\": \"Price information including discounts.\\n\\nFor reference, this price value has multiplied by the {@link volume} value.\\nTherefore, even if {@link volume} value is equal to the target\\n{@link IShoppingCartCommodity.volume}, this price value can be different\\nwith the {@link IShoppingCartCommodity.price} value.\"\n          },\n          \"publish\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"$ref\": \"#/components/schemas/IShoppingOrderPublish\"\n              }\n            ],\n            \"title\": \"Order completion and payment information\",\n            \"description\": \"Order completion and payment information.\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"title\": \"Creation time of the record\",\n            \"description\": \"Creation time of the record.\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"name\",\n          \"customer\",\n          \"goods\",\n          \"price\",\n          \"publish\",\n          \"created_at\"\n        ],\n        \"description\": \"Order application information.\\n\\n`IShoppingOrder` is an entity that embodies {@link IShoppingCustomer customer}'s\\norder application information. However, please note that at this time, you are\\nstill at the \\\"order application\\\" stage and not the \\\"order confirmation\\\" stage.\\n\\nAnd as soon as a customer applies for an order, all\\n{@link IShoppingCartCommodity commodities} in the target shopping cart are\\npromoted to {@link IShoppingOrderGood goods}, and those good records are created\\nunder this `IShoppingOrder`.\\n\\nOf course, not all commodities in the target shopping cart become\\n{@link IShoppingOrderGood}, but only those selected by the customer become the\\n{@link IShoppingOrderGood}.\"\n      },\n      \"IShoppingCustomer\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"type\": {\n            \"const\": \"customer\",\n            \"title\": \"Discriminant for the type of customer\",\n            \"description\": \"Discriminant for the type of customer.\"\n          },\n          \"member\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"$ref\": \"#/components/schemas/IShoppingMember\"\n              }\n            ],\n            \"title\": \"Membership information\",\n            \"description\": \"Membership information.\\n\\nIf the customer has joined as a member.\"\n          },\n          \"citizen\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"$ref\": \"#/components/schemas/IShoppingCitizen\"\n              }\n            ],\n            \"title\": \"Citizen information\",\n            \"description\": \"Citizen information.\\n\\nIf the customer has verified his real name and mobile number.\"\n          },\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"title\": \"Primary Key\",\n            \"description\": \"Primary Key.\"\n          },\n          \"channel\": {\n            \"$ref\": \"#/components/schemas/IShoppingChannel\",\n            \"title\": \"Belonged channel\",\n            \"description\": \"Belonged channel.\"\n          },\n          \"external_user\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"$ref\": \"#/components/schemas/IShoppingExternalUser\"\n              }\n            ],\n            \"title\": \"External user information\",\n            \"description\": \"External user information.\\n\\nWhen the customer has come from an external service.\"\n          },\n          \"href\": {\n            \"type\": \"string\",\n            \"format\": \"uri\",\n            \"title\": \"Connection address\",\n            \"description\": \"Connection address.\\n\\nSame with {@link window.location.href} of client.\"\n          },\n          \"referrer\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\",\n                \"format\": \"uri\"\n              },\n              {\n                \"type\": \"string\",\n                \"maxLength\": 0\n              }\n            ],\n            \"title\": \"Referrer address\",\n            \"description\": \"Referrer address.\\n\\nSame with {@link window.document.referrer} of client.\"\n          },\n          \"ip\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"format\": \"ipv4\"\n              },\n              {\n                \"type\": \"string\",\n                \"format\": \"ipv6\"\n              }\n            ],\n            \"title\": \"Connection IP Address\",\n            \"description\": \"Connection IP Address.\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"title\": \"Creation time of the connection record\",\n            \"description\": \"Creation time of the connection record.\"\n          }\n        },\n        \"required\": [\n          \"type\",\n          \"member\",\n          \"citizen\",\n          \"id\",\n          \"channel\",\n          \"external_user\",\n          \"href\",\n          \"referrer\",\n          \"ip\",\n          \"created_at\"\n        ],\n        \"description\": \"Customer information, but not a person but a connection basis.\\n\\n`IShoppingCustomer` is an entity that literally embodies the information of\\nthose who participated in the market as customers. By the way, the\\n`IShoppingCustomer` does not mean a person, but a connection basis. Therefore,\\neven if the same person connects to the shopping mall multiple, multiple\\nrecords are created in `IShoppingCustomer`.\\n\\nThe first purpose of this is to track the customer's inflow path in detail,\\nand it is for cases where the same person enters as a non-member,\\n{@link IShoppingCartCommodity puts items in the shopping cart} in advance,\\nand only authenticates their {@link IShoppingCitizen real name} or\\nregisters/logs in at the moment of {@link IShoppingOrderPublish payment}.\\nIt is the second. Lastly, it is to accurately track the activities that\\na person performs at the shopping mall in various ways like below.\\n\\n- Same person comes from an {@link IShoppingExternalUser external service}\\n- Same person creates multiple accounts\\n- Same person makes a {@link IShoppingOrderPublish purchase} as a non-member with only {@link IShoppingCitizen real name authentication}\\n- Same person acts both {@link IShoppingSeller seller} and {@link IShoppingAdministrator admin} at the same time\\n\\nTherefore, `IShoppingCustomer` can have multiple records with the same\\n{@link IShoppingCitizen}, {@link IShoppingMember}, and\\n{@link IShoppingExternalUser}. Additionally, if a customer signs up for\\nmembership after verifying their real name or signs up for our service after\\nbeing a user of an external service, all related records are changed at once.\\nTherefore, identification and tracking of customers can be done very\\nsystematically.\"\n      },\n      \"IShoppingMember\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"citizen\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"$ref\": \"#/components/schemas/IShoppingCitizen\"\n              }\n            ],\n            \"title\": \"Citizen information\",\n            \"description\": \"Citizen information.\\n\\nOnly when has verified as a citizen, with mobile number and real name.\\n\\nFor reference, if the member has signed up as a seller or administrator,\\nthis citizen information must be.\"\n          },\n          \"seller\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"$ref\": \"#/components/schemas/IShoppingSeller\"\n              }\n            ],\n            \"title\": \"Seller information\",\n            \"description\": \"Seller information.\\n\\nIf the member also signed up as a seller.\"\n          },\n          \"administrator\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"$ref\": \"#/components/schemas/IShoppingAdministrator\"\n              }\n            ],\n            \"title\": \"Administrator information\",\n            \"description\": \"Administrator information.\\n\\nIf the member also signed up as an administrator.\"\n          },\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"title\": \"Primary Key\",\n            \"description\": \"Primary Key.\"\n          },\n          \"nickname\": {\n            \"type\": \"string\",\n            \"title\": \"Nickname that uniquely identifies the member\",\n            \"description\": \"Nickname that uniquely identifies the member.\"\n          },\n          \"emails\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IShoppingMemberEmail\"\n            },\n            \"title\": \"List of emails\",\n            \"description\": \"List of emails.\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"title\": \"Creation time of record\",\n            \"description\": \"Creation time of record.\\n\\nAnother words, the time when the member has signed up.\"\n          }\n        },\n        \"required\": [\n          \"citizen\",\n          \"seller\",\n          \"administrator\",\n          \"id\",\n          \"nickname\",\n          \"emails\",\n          \"created_at\"\n        ],\n        \"description\": \"Member Account.\\n\\n`IShoppingMember` is an entity that symbolizes the case when a\\n{@link IShoppingCustomer} signs up as a member of this shopping mall\\nsystem.\\n\\nIf a `IShoppingMember` has seller or administrator property. it means that\\nthe {@link IShoppingCustomer} has acting as a {@link IShoppingSeller seller}\\nor {@link IShoppingAdministrator administrator} at the same time.\"\n      },\n      \"IShoppingOrderGood\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"title\": \"Primary Key\",\n            \"description\": \"Primary Key.\"\n          },\n          \"commodity\": {\n            \"$ref\": \"#/components/schemas/IShoppingCartCommodity\",\n            \"title\": \"Commodity that is the basis of the good\",\n            \"description\": \"Commodity that is the basis of the good.\"\n          },\n          \"volume\": {\n            \"type\": \"integer\",\n            \"minimum\": 0,\n            \"title\": \"Volume of the good\",\n            \"description\": \"Volume of the good.\\n\\nThe value multiplied to {@link IShoppingCartCommodityStock.quantity}.\\nIt's purpose is exactly same with {@link IShoppingCartCommodity.volume},\\nbut rewritten because the {@link IShoppingCartCommodity} records are reusable\\nuntil payment.\"\n          },\n          \"price\": {\n            \"$ref\": \"#/components/schemas/IShoppingOrderPrice.ISummary\",\n            \"title\": \"Price information including discounts and multiplied volume\",\n            \"description\": \"Price information including discounts and multiplied volume.\"\n          },\n          \"state\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"const\": \"none\"\n              },\n              {\n                \"const\": \"underway\"\n              },\n              {\n                \"const\": \"preparing\"\n              },\n              {\n                \"const\": \"manufacturing\"\n              },\n              {\n                \"const\": \"shipping\"\n              },\n              {\n                \"const\": \"delivering\"\n              },\n              {\n                \"const\": \"arrived\"\n              }\n            ],\n            \"title\": \"State of delivery about the good\",\n            \"description\": \"State of delivery about the good.\"\n          },\n          \"confirmed_at\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\",\n                \"format\": \"date-time\"\n              }\n            ],\n            \"title\": \"Confirmation time of order good\",\n            \"description\": \"Confirmation time of order good.\\n\\nWhen be confirmed, customer can't request refund or exchange.\\n\\nThe confirmation be accomplished by following cases.\\n\\n- Customer does it directly.\\n- 14 days after the delivery.\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"commodity\",\n          \"volume\",\n          \"price\",\n          \"state\",\n          \"confirmed_at\"\n        ],\n        \"description\": \"Information about the individual goods that make up your order.\\n\\n`IShoppingOrderGood` is an entity that represents each good ordered by a\\n{@link IShoppingCustomer customer}, and the record is created in the process\\nof upgrading the product {@link IShoppingCartCommodity commodity} in the\\nshopping cart to a good due to the customer's {@link IShoppingOrder order}\\nrequest.\\n\\nAnd `IShoppingOrderGood`, like {@link IShoppingCartCommodity}, is a concept\\nthat corresponds to the listing {@link IShoppingSaleSnapshot sale snapshot}.\\n\\nFor reference, `IShoppingOrderGood` also contains {@link volume} information\\nseparately from the belonging {@link IShoppingCartCommodity.volume}. This is\\nbecause there are some cases where you put 3 books in your shopping cart and\\nthen change them to 4 during the actual order application process. This is to\\nincrease the reusability of the shopping cart by changing the volume attribute\\nof the current entity rather than directly changing the commodity information.\\n\\nIn addition, `IShoppingOrderGood` becomes the most basic unit for the post-order\\nprocess, that is, after service (A/S). For example, after receiving a\\ncustomer's product, confirming the order is recorded in the {@link confirmed_at}\\nattribute. Additionally, `IShoppingOrderGood` is the unit in which customers\\nissues or request exchanges or refunds for ordered products.\"\n      },\n      \"IShoppingCartCommodity\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"title\": \"Primary Key\",\n            \"description\": \"Primary Key.\\n\\nIf you want to continue to the order the commodity, then use this ID to order.\"\n          },\n          \"sale\": {\n            \"$ref\": \"#/components/schemas/IShoppingSaleSnapshot.IInvert\",\n            \"title\": \"Invert information of the sale (snapshot), in the perspective of commodity\",\n            \"description\": \"Invert information of the sale (snapshot), in the perspective of commodity.\"\n          },\n          \"orderable\": {\n            \"type\": \"boolean\",\n            \"title\": \"Whether current commodity is orderable or not\",\n            \"description\": \"Whether current commodity is orderable or not.\\n\\nIf this attribute is `false`, then the commodity is not orderable, because\\nit has already been ordered.\"\n          },\n          \"pseudo\": {\n            \"type\": \"boolean\",\n            \"title\": \"Whether current commodity is pseudo or not\",\n            \"description\": \"Whether current commodity is pseudo or not.\\n\\nWhen this attribute is `true`, then the commodity is not the real one,\\nbut just fake information only for calculating the discount effect by\\n{@link IShoppingCoupon coupons}.\"\n          },\n          \"volume\": {\n            \"type\": \"integer\",\n            \"minimum\": 1,\n            \"title\": \"Volume of the commodity to purchase\",\n            \"description\": \"Volume of the commodity to purchase.\\n\\nA value indicating how many sets would be multiplied to the children\\n{@link IShoppingSaleUnitStock.IInvert.quantity} values.\"\n          },\n          \"price\": {\n            \"$ref\": \"#/components/schemas/IShoppingPrice\",\n            \"title\": \"Price of the commodity\",\n            \"description\": \"Price of the commodity.\\n\\nFor reference, this price value has not been multiplied by the\\n{@link volume} value. It just sumed up the prices of the children\\n{@link IShoppingSaleUnitStock.IInvert.price} values.\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"title\": \"Creation time of the record\",\n            \"description\": \"Creation time of the record.\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"sale\",\n          \"orderable\",\n          \"pseudo\",\n          \"volume\",\n          \"price\",\n          \"created_at\"\n        ],\n        \"description\": \"Item in a shopping cart.\\n\\n`IShoppingCartCommodity` is an entity that represents a\\n{@link IShoppingSaleSnapshot snapshot} of the items that\\n{@link IShoppingCustomer customer} has placed into his shopping cart with a\\n{@link IShoppingOrder purchase} in mind. And if the customer continues this\\ninto an actual order in the future, `IShoppingCartCommodity` be changed to\\n{@link IShoppingOrderGood}.\\n\\nAnd while adding a sale snapshot to the shopping cart, the customer inevitably\\nselects specific {@link IShoppingSaleUnit units} and\\n{@link IShoppingSaleUnitStock final stocks} within the listing snapshot.\\nInformation about these units and stocks is recorded in the subsidiary entity\\n{@link IShoppingCartCommodityStock}. Also, there is an attribute {@link volume}\\nthat indicates how many sets of snapshots of the target commodity will be\\npurchased. This \\\"volume\\\" is a value that will be multiplied by\\n{@link IShoppingSaleUnitStock.IInvert.quantity}, the quantity for each\\ncomponent.\"\n      },\n      \"IShoppingSaleSnapshot.IInvert\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"section\": {\n            \"$ref\": \"#/components/schemas/IShoppingSection\",\n            \"title\": \"Belonged section's information\",\n            \"description\": \"Belonged section's information.\"\n          },\n          \"seller\": {\n            \"$ref\": \"#/components/schemas/IShoppingSeller.IInvert\",\n            \"title\": \"Seller who've registered the sale\",\n            \"description\": \"Seller who've registered the sale.\"\n          },\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"title\": \"Primary Key of Sale\",\n            \"description\": \"Primary Key of Sale.\"\n          },\n          \"snapshot_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"title\": \"Primary Key of Snapshot\",\n            \"description\": \"Primary Key of Snapshot.\"\n          },\n          \"latest\": {\n            \"type\": \"boolean\",\n            \"title\": \"Whether the snapshot is the latest one or not\",\n            \"description\": \"Whether the snapshot is the latest one or not.\"\n          },\n          \"content\": {\n            \"$ref\": \"#/components/schemas/IShoppingSaleContent.IInvert\",\n            \"title\": \"Description and image content describing the sale\",\n            \"description\": \"Description and image content describing the sale.\"\n          },\n          \"categories\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IShoppingChannelCategory.IInvert\"\n            },\n            \"title\": \"List of categories\",\n            \"description\": \"List of categories.\\n\\nWhich categories the sale is registered to.\"\n          },\n          \"tags\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"type\": \"string\"\n            },\n            \"title\": \"List of search tags\",\n            \"description\": \"List of search tags.\"\n          },\n          \"units\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IShoppingSaleUnit.IInvert\"\n            },\n            \"minItems\": 1,\n            \"title\": \"List of units\",\n            \"description\": \"List of units.\\n\\nRecords about individual product composition information that are sold\\nin the sale. Each {@link IShoppingSaleUnit unit} record has configurable\\n{@link IShoppingSaleUnitOption options},\\n{@link IShoppingSaleUnitOptionCandidate candidate} values for each\\noption, and {@link IShoppingSaleUnitStock final stocks} determined by\\nselecting every candidate values of each option.\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"title\": \"Creation time of the record\",\n            \"description\": \"Creation time of the record.\\n\\nNote that, this property is different with {@link opened_at},\\nwhich means the timepoint of the sale is opened.\"\n          },\n          \"updated_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"title\": \"Last updated time of the record\",\n            \"description\": \"Last updated time of the record.\\n\\nIn another words, creation time of the last snapshot.\"\n          },\n          \"paused_at\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\",\n                \"format\": \"date-time\"\n              }\n            ],\n            \"title\": \"Paused time of the sale\",\n            \"description\": \"Paused time of the sale.\\n\\nThe sale is paused by the seller, for some reason.\\n\\n{@link IShoppingCustomer Customers} can still see the sale on the\\nboth list and detail pages, but the sale has a warning label\\n\\\"The sale is paused by the seller\\\".\"\n          },\n          \"suspended_at\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\",\n                \"format\": \"date-time\"\n              }\n            ],\n            \"title\": \"Suspended time of the sale\",\n            \"description\": \"Suspended time of the sale.\\n\\nThe sale is suspended by the seller, for some reason.\\n\\n{@link IShoppingCustomer Customers} cannot see the sale on the\\nboth list and detail pages. It is almost same with soft delettion,\\nbut there's a little bit difference that the owner\\n{@link IShoppingSeller seller} can still see the sale and resume it.\\n\\nOf course, the {@link IShoppingCustomer customers} who have\\nalready purchased the sale can still see the sale on the\\n{@link IShoppingOrder order} page.\"\n          },\n          \"opened_at\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\",\n                \"format\": \"date-time\"\n              }\n            ],\n            \"title\": \"Opening time of the sale\",\n            \"description\": \"Opening time of the sale.\"\n          },\n          \"closed_at\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\",\n                \"format\": \"date-time\"\n              }\n            ],\n            \"title\": \"Closing time of the sale\",\n            \"description\": \"Closing time of the sale.\\n\\nIf this value is `null`, the sale be continued forever.\"\n          }\n        },\n        \"required\": [\n          \"section\",\n          \"seller\",\n          \"id\",\n          \"snapshot_id\",\n          \"latest\",\n          \"content\",\n          \"categories\",\n          \"tags\",\n          \"units\",\n          \"created_at\",\n          \"updated_at\",\n          \"paused_at\",\n          \"suspended_at\",\n          \"opened_at\",\n          \"closed_at\"\n        ],\n        \"description\": \"Invert information of the sale snapshot, in the perspective of commodity.\\n\\n`IShoppingSaleSnapshot.IInvert` is a structure used to represent a\\nsnapshot in the perspective of a {@link IShoppingCommodity}, corresponding\\nto an {@link IShoppingCartCommodityStock} entity.\\n\\nTherefore, `IShoppingSaleSnapshot.IInvert` does not contain every\\n{@link IShoppingSaleUnit units} and {@link IShoppingSaleUnitStock stocks}\\nof the snapshot records, but only some of the records which are put\\ninto the {@link IShoppingCartCommodity shopping cart}.\"\n      },\n      \"IShoppingSeller.IInvert\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"type\": {\n            \"const\": \"seller\",\n            \"title\": \"Discriminant for the type of seller\",\n            \"description\": \"Discriminant for the type of seller.\"\n          },\n          \"member\": {\n            \"$ref\": \"#/components/schemas/IShoppingMember.IInvert\",\n            \"title\": \"Membership joining information\",\n            \"description\": \"Membership joining information.\"\n          },\n          \"customer\": {\n            \"$ref\": \"#/components/schemas/IShoppingCustomer.IInvert\",\n            \"title\": \"Customer, the connection information\",\n            \"description\": \"Customer, the connection information.\"\n          },\n          \"citizen\": {\n            \"$ref\": \"#/components/schemas/IShoppingCitizen\",\n            \"title\": \"Real-name and mobile number authentication information\",\n            \"description\": \"Real-name and mobile number authentication information.\"\n          },\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"title\": \"Primary Key\",\n            \"description\": \"Primary Key.\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"title\": \"Creation tmie of record\",\n            \"description\": \"Creation tmie of record.\\n\\nAnother words, the time when the seller has signed up.\"\n          }\n        },\n        \"required\": [\n          \"type\",\n          \"member\",\n          \"customer\",\n          \"citizen\",\n          \"id\",\n          \"created_at\"\n        ],\n        \"description\": \"Invert information starting from seller info.\\n\\nInstead of accessing to the seller information from the\\n{@link IShoppingCustomer.member} -> {@link IShoppingMember.seller},\\n`IShoppingSeller.IInvert` starts from the seller information\\nand access to the customer, member and {@link IShoppingCitizen citizen}\\ninformation inversely.\"\n      },\n      \"IShoppingSaleUnit.IInvert\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"stocks\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IShoppingSaleUnitStock.IInvert\"\n            },\n            \"minItems\": 1,\n            \"title\": \"List of final stocks\",\n            \"description\": \"List of final stocks.\"\n          },\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"title\": \"Primary Key\",\n            \"description\": \"Primary Key.\"\n          },\n          \"name\": {\n            \"type\": \"string\",\n            \"title\": \"Representative name of the unit\",\n            \"description\": \"Representative name of the unit.\"\n          },\n          \"primary\": {\n            \"type\": \"boolean\",\n            \"title\": \"Whether the unit is primary or not\",\n            \"description\": \"Whether the unit is primary or not.\\n\\nJust a labeling value.\"\n          },\n          \"required\": {\n            \"type\": \"boolean\",\n            \"title\": \"Whether the unit is required or not\",\n            \"description\": \"Whether the unit is required or not.\\n\\nWhen the unit is required, the customer must select the unit. If do not\\nselect, customer can't buy it.\\n\\nFor example, if there's a sale \\\"Macbook Set\\\" and one of the unit is the\\n\\\"Main Body\\\", is it possible to buy the \\\"Macbook Set\\\" without the\\n\\\"Main Body\\\" unit? This property is for that case.\"\n          }\n        },\n        \"required\": [\n          \"stocks\",\n          \"id\",\n          \"name\",\n          \"primary\",\n          \"required\"\n        ]\n      },\n      \"IShoppingSaleUnitStock.IInvert\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"title\": \"Primary Key\",\n            \"description\": \"Primary Key.\"\n          },\n          \"name\": {\n            \"type\": \"string\",\n            \"title\": \"Representative name of the stock\",\n            \"description\": \"Representative name of the stock.\"\n          },\n          \"price\": {\n            \"$ref\": \"#/components/schemas/IShoppingPrice\",\n            \"title\": \"Price of the stock\",\n            \"description\": \"Price of the stock.\"\n          },\n          \"quantity\": {\n            \"type\": \"integer\",\n            \"minimum\": 1,\n            \"title\": \"Quantity of the stock in the cart\",\n            \"description\": \"Quantity of the stock in the cart.\"\n          },\n          \"inventory\": {\n            \"$ref\": \"#/components/schemas/IShoppingSaleUnitStockInventory\",\n            \"title\": \"Current inventory status of the stock\",\n            \"description\": \"Current inventory status of the stock.\"\n          },\n          \"choices\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IShoppingSaleUnitStockChoice.IInvert\"\n            },\n            \"title\": \"List of choices\",\n            \"description\": \"List of choices.\\n\\nWhich values being written for each option.\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"name\",\n          \"price\",\n          \"quantity\",\n          \"inventory\",\n          \"choices\"\n        ],\n        \"description\": \"Invert information from the cart.\"\n      },\n      \"IShoppingSaleUnitStockInventory\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"income\": {\n            \"type\": \"integer\",\n            \"minimum\": 0,\n            \"title\": \"Total income quantity\",\n            \"description\": \"Total income quantity.\"\n          },\n          \"outcome\": {\n            \"type\": \"integer\",\n            \"minimum\": 0,\n            \"title\": \"Total outcome quantity\",\n            \"description\": \"Total outcome quantity.\"\n          }\n        },\n        \"required\": [\n          \"income\",\n          \"outcome\"\n        ],\n        \"description\": \"Inventory information of a final stock.\"\n      },\n      \"IShoppingSaleUnitStockChoice.IInvert\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"title\": \"Primary Key\",\n            \"description\": \"Primary Key.\"\n          },\n          \"option\": {\n            \"oneOf\": [\n              {\n                \"$ref\": \"#/components/schemas/IShoppingSaleUnitSelectableOption.IInvert\"\n              },\n              {\n                \"$ref\": \"#/components/schemas/IShoppingSaleUnitDescriptiveOption\"\n              }\n            ],\n            \"title\": \"Target option\",\n            \"description\": \"Target option.\"\n          },\n          \"candidate\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"$ref\": \"#/components/schemas/IShoppingSaleUnitOptionCandidate\"\n              }\n            ],\n            \"title\": \"Selected candidate value\",\n            \"description\": \"Selected candidate value.\"\n          },\n          \"value\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\"\n              },\n              {\n                \"type\": \"number\"\n              },\n              {\n                \"type\": \"boolean\"\n              }\n            ],\n            \"title\": \"Written value\",\n            \"description\": \"Written value.\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"option\",\n          \"candidate\",\n          \"value\"\n        ],\n        \"description\": \"Invert information from the cart.\"\n      },\n      \"IShoppingSaleUnitSelectableOption.IInvert\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"title\": \"Primary Key\",\n            \"description\": \"Primary Key.\"\n          },\n          \"type\": {\n            \"const\": \"select\",\n            \"title\": \"Discriminant for the type of selectable option\",\n            \"description\": \"Discriminant for the type of selectable option.\"\n          },\n          \"name\": {\n            \"type\": \"string\",\n            \"title\": \"Represents the name of the option\",\n            \"description\": \"Represents the name of the option.\"\n          },\n          \"variable\": {\n            \"type\": \"boolean\",\n            \"title\": \"Whether the option is variable or not\",\n            \"description\": \"Whether the option is variable or not.\\n\\nWhen type of current option is \\\"select\\\", this attribute means whether\\nselecting different candidate value affects the final stock or not.\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"type\",\n          \"name\",\n          \"variable\"\n        ]\n      },\n      \"IShoppingSaleUnitDescriptiveOption\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"title\": \"Primary Key\",\n            \"description\": \"Primary Key.\"\n          },\n          \"type\": {\n            \"oneOf\": [\n              {\n                \"const\": \"string\"\n              },\n              {\n                \"const\": \"number\"\n              },\n              {\n                \"const\": \"boolean\"\n              }\n            ],\n            \"title\": \"Type of descriptive option\",\n            \"description\": \"Type of descriptive option.\\n\\nWhich typed value should be written when purchasing.\"\n          },\n          \"name\": {\n            \"type\": \"string\",\n            \"title\": \"Readable name of the option\",\n            \"description\": \"Readable name of the option.\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"type\",\n          \"name\"\n        ],\n        \"description\": \"Descriptive option.\\n\\nWhen type of the option not `\\\"select\\\"`, it means the option is descriptive\\nthat requiring {@link IShoppingCustomer customers} to write some value to\\n{@link IShoppingOrder purchase}. Also, whatever customer writes about the\\noption, it does not affect the {@link IShoppingSaleUnitStock final stock}.\\n\\nAnother words, the descriptive option is just for information transfer.\"\n      },\n      \"IShoppingSaleUnitOptionCandidate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"title\": \"Primary Key\",\n            \"description\": \"Primary Key.\"\n          },\n          \"name\": {\n            \"type\": \"string\",\n            \"title\": \"Represents the name of the candidate value\",\n            \"description\": \"Represents the name of the candidate value.\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"name\"\n        ],\n        \"description\": \"Selectable candidate values within an option.\\n\\n`IShoppingSaleUnitOptionCandidate` is an entity that represents individual\\ncandidate values that can be selected from\\n{@link IShoppingSaleUnitSelectableOption options of the \\\"select\\\" type}.\\n\\n- Example\\n  - RAM: 8GB, 16GB, 32GB\\n  - GPU: RTX 3060, RTX 4080, TESLA\\n  - License: Private, Commercial, Educatiion\\n\\nBy the way, if belonged option is not \\\"select\\\" type, this entity never\\nbeing used.\"\n      },\n      \"IShoppingOrderPrice.ISummary\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"cash\": {\n            \"type\": \"number\",\n            \"minimum\": 0,\n            \"x-wrtn-payment-price\": true,\n            \"title\": \"Amount of the cash payment\",\n            \"description\": \"Amount of the cash payment.\"\n          },\n          \"deposit\": {\n            \"type\": \"number\",\n            \"minimum\": 0,\n            \"title\": \"Amount of the deposit payment\",\n            \"description\": \"Amount of the deposit payment.\"\n          },\n          \"mileage\": {\n            \"type\": \"number\",\n            \"minimum\": 0,\n            \"title\": \"Amount of the mileage payment\",\n            \"description\": \"Amount of the mileage payment.\"\n          },\n          \"ticket\": {\n            \"type\": \"number\",\n            \"minimum\": 0,\n            \"title\": \"Amount of the discount coupon ticket payment\",\n            \"description\": \"Amount of the discount coupon ticket payment.\"\n          },\n          \"nominal\": {\n            \"type\": \"number\",\n            \"minimum\": 0,\n            \"title\": \"Nominal price\",\n            \"description\": \"Nominal price.\\n\\nThis is not {@link real real price} to pay, but just a nominal price to show.\\nIf this value is greater than the {@link real real price}, it would be shown\\nlike {@link IShoppingSeller seller} is giving a discount.\"\n          },\n          \"real\": {\n            \"type\": \"number\",\n            \"minimum\": 0,\n            \"title\": \"Real price to pay\",\n            \"description\": \"Real price to pay.\"\n          }\n        },\n        \"required\": [\n          \"cash\",\n          \"deposit\",\n          \"mileage\",\n          \"ticket\",\n          \"nominal\",\n          \"real\"\n        ],\n        \"description\": \"Summarized information of the order price.\"\n      },\n      \"IShoppingOrderPrice\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"ticket_payments\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IShoppingCouponTicketPayment\"\n            },\n            \"title\": \"List of discount coupon ticket payments\",\n            \"description\": \"List of discount coupon ticket payments.\"\n          },\n          \"cash\": {\n            \"type\": \"number\",\n            \"minimum\": 0,\n            \"x-wrtn-payment-price\": true,\n            \"title\": \"Amount of the cash payment\",\n            \"description\": \"Amount of the cash payment.\"\n          },\n          \"deposit\": {\n            \"type\": \"number\",\n            \"minimum\": 0,\n            \"title\": \"Amount of the deposit payment\",\n            \"description\": \"Amount of the deposit payment.\"\n          },\n          \"mileage\": {\n            \"type\": \"number\",\n            \"minimum\": 0,\n            \"title\": \"Amount of the mileage payment\",\n            \"description\": \"Amount of the mileage payment.\"\n          },\n          \"ticket\": {\n            \"type\": \"number\",\n            \"minimum\": 0,\n            \"title\": \"Amount of the discount coupon ticket payment\",\n            \"description\": \"Amount of the discount coupon ticket payment.\"\n          },\n          \"nominal\": {\n            \"type\": \"number\",\n            \"minimum\": 0,\n            \"title\": \"Nominal price\",\n            \"description\": \"Nominal price.\\n\\nThis is not {@link real real price} to pay, but just a nominal price to show.\\nIf this value is greater than the {@link real real price}, it would be shown\\nlike {@link IShoppingSeller seller} is giving a discount.\"\n          },\n          \"real\": {\n            \"type\": \"number\",\n            \"minimum\": 0,\n            \"title\": \"Real price to pay\",\n            \"description\": \"Real price to pay.\"\n          }\n        },\n        \"required\": [\n          \"ticket_payments\",\n          \"cash\",\n          \"deposit\",\n          \"mileage\",\n          \"ticket\",\n          \"nominal\",\n          \"real\"\n        ],\n        \"description\": \"Price information of the order including discounts.\"\n      },\n      \"IShoppingCouponTicketPayment\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"title\": \"Primary Key\",\n            \"description\": \"Primary Key.\"\n          },\n          \"ticket\": {\n            \"$ref\": \"#/components/schemas/IShoppingCouponTicket\",\n            \"title\": \"Target ticket\",\n            \"description\": \"Target ticket.\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"title\": \"Creation time of the record\",\n            \"description\": \"Creation time of the record.\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"ticket\",\n          \"created_at\"\n        ],\n        \"description\": \"Discount coupon ticket payment details.\\n\\n`IShoppingCouponTicketPayment` is an entity that embodies the payment\\ninformation for the {@link IShoppingOrder order} of\\n{@link IShoppingCouponTicket}, and is used when a consumer uses the\\ndiscount coupon ticket he or she was issued to order and has the payment\\namount deducted.\\n\\nAnd since {@link IShoppingOrder} itself is not an entity used in\\nsituations where an order is completed, but rather an entity designed to\\nexpress an order request, the creation of this\\n`IShoppingCouponTicketPayment` record does not actually mean that the\\nattached ticket disappears. Until the {@link IShoppingCustomer customer}\\n{@link IShoppingOrderPublish.paid_at completes the payment} and confirms\\nthe order, the ticket can be understood as a kind of deposit.\\n\\nAdditionally, this record can be deleted by the customer reversing the\\npayment of the ticket, but it can also be deleted when the attribution\\norder itself is cancelled.\"\n      },\n      \"IShoppingCouponTicket\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"title\": \"Primary Key\",\n            \"description\": \"Primary Key.\"\n          },\n          \"customer\": {\n            \"$ref\": \"#/components/schemas/IShoppingCustomer\",\n            \"title\": \"Customer who've taken the coupon ticket\",\n            \"description\": \"Customer who've taken the coupon ticket.\"\n          },\n          \"coupon\": {\n            \"$ref\": \"#/components/schemas/IShoppingCoupon\",\n            \"title\": \"Target coupon\",\n            \"description\": \"Target coupon.\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"title\": \"Creation time of the record\",\n            \"description\": \"Creation time of the record.\"\n          },\n          \"expired_at\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\",\n                \"format\": \"date-time\"\n              }\n            ],\n            \"title\": \"Expiration time of the ticket\",\n            \"description\": \"Expiration time of the ticket.\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"customer\",\n          \"coupon\",\n          \"created_at\",\n          \"expired_at\"\n        ],\n        \"description\": \"Discount coupon ticket issuance details.\\n\\n`IShoppingCouponTicket` is an entity that symbolizes\\n{@link IShoppingCoupon discount coupon} tickets issued by\\n{@link IShoppingCustomer customers}.\\n\\nAnd if the target discount coupon specification itself has an expiration\\ndate, the expiration date is recorded in expired_at and is automatically\\ndiscarded after that expiration date. Of course, it doesn't matter if you\\nuse the discount coupon for your order within the deadline.\"\n      },\n      \"IShoppingOrderPublish\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"deliveries\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IShoppingDelivery\"\n            },\n            \"title\": \"List of deliveries\",\n            \"description\": \"List of deliveries.\\n\\nAn {@link IShoppingOrder order} can be delivered in multiple times.\\nOf course, the opposite case is also possible, that a\\n{@link IShoppingDelivery delivery} can be composed of multiple orders.\"\n          },\n          \"state\": {\n            \"oneOf\": [\n              {\n                \"const\": \"none\"\n              },\n              {\n                \"const\": \"underway\"\n              },\n              {\n                \"const\": \"preparing\"\n              },\n              {\n                \"const\": \"manufacturing\"\n              },\n              {\n                \"const\": \"shipping\"\n              },\n              {\n                \"const\": \"delivering\"\n              },\n              {\n                \"const\": \"arrived\"\n              }\n            ],\n            \"title\": \"State of the order, about the deliveries\",\n            \"description\": \"State of the order, about the deliveries.\"\n          },\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"title\": \"Primary Key\",\n            \"description\": \"Primary Key.\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"title\": \"Creation time of the record\",\n            \"description\": \"Creation time of the record.\"\n          },\n          \"paid_at\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\",\n                \"format\": \"date-time\"\n              }\n            ],\n            \"title\": \"Time when the order was paid\",\n            \"description\": \"Time when the order was paid.\"\n          },\n          \"cancelled_at\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\",\n                \"format\": \"date-time\"\n              }\n            ],\n            \"title\": \"Time when the payment was cancelled\",\n            \"description\": \"Time when the payment was cancelled.\"\n          },\n          \"address\": {\n            \"$ref\": \"#/components/schemas/IShoppingAddress\",\n            \"title\": \"Address where the {@link IShoppingOrderGood goods} to be delivered\",\n            \"description\": \"Address where the {@link IShoppingOrderGood goods} to be delivered.\"\n          }\n        },\n        \"required\": [\n          \"deliveries\",\n          \"state\",\n          \"id\",\n          \"created_at\",\n          \"paid_at\",\n          \"cancelled_at\",\n          \"address\"\n        ],\n        \"description\": \"Order completion and payment information.\\n\\n`IShoppingOrderPublish` is an entity that embodies the series of processes\\nin which a {@link IShoppingCustomer customer} pays for his or her\\n{@link IShoppingOrder order}, thereby completing the order. And only after\\nthe order is {@link paid_at completed}, can the {@link IShoppingSeller seller}\\nrecognize that the customer has purchased his product.\\n\\nBy the way, please note that just because the `IShoppingOrderPublish` record\\nexists, it does not mean that the payment has been completed. Of course, with\\n\\\"credit cards\\\" and \\\"Google Pay\\\", payment application and payment occur at the\\nsame time. However, there are some cases where payment is made after the\\npayment application, such as \\\"bank transfer\\\" or \\\"virtual account payment\\\".\\nTherefore, to see the completion of payment, be sure to check the\\n{@link paid_at} property.\\n\\nIn addition, even after payment has been made, there may be cases where it is\\nsuddenly cancelled, so please be aware of this as well.\"\n      },\n      \"IShoppingDelivery\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"title\": \"Primary Key\",\n            \"description\": \"Primary Key.\"\n          },\n          \"seller\": {\n            \"$ref\": \"#/components/schemas/IShoppingSeller\",\n            \"title\": \"Seller who've delivered the goods\",\n            \"description\": \"Seller who've delivered the goods.\"\n          },\n          \"journeys\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IShoppingDeliveryJourney\"\n            },\n            \"title\": \"List of journeys of the delivery\",\n            \"description\": \"List of journeys of the delivery.\"\n          },\n          \"pieces\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IShoppingDeliveryPiece\"\n            },\n            \"minItems\": 1,\n            \"title\": \"List of pieces of the delivery\",\n            \"description\": \"List of pieces of the delivery.\"\n          },\n          \"shippers\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IShoppingDeliveryShipper\"\n            },\n            \"title\": \"List of shippers of the delivery\",\n            \"description\": \"List of shippers of the delivery.\"\n          },\n          \"state\": {\n            \"oneOf\": [\n              {\n                \"const\": \"none\"\n              },\n              {\n                \"const\": \"underway\"\n              },\n              {\n                \"const\": \"preparing\"\n              },\n              {\n                \"const\": \"manufacturing\"\n              },\n              {\n                \"const\": \"shipping\"\n              },\n              {\n                \"const\": \"delivering\"\n              },\n              {\n                \"const\": \"arrived\"\n              }\n            ],\n            \"title\": \"State of the delivery\",\n            \"description\": \"State of the delivery.\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"title\": \"Creation time of the record\",\n            \"description\": \"Creation time of the record.\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"seller\",\n          \"journeys\",\n          \"pieces\",\n          \"shippers\",\n          \"state\",\n          \"created_at\"\n        ],\n        \"description\": \"Delivery information.\\n\\nWhen delivering {@link IShoppingOrderGood goods} to\\n{@link IShoppingCustomer customer}, {@link IShoppingSeller seller} can deliver\\nmultiple {@link IShoppingSaleUnitStock stocks}, goods at once. Also, it is\\npossible to deliver a stock or good in multiple times due to physical restriction\\nlike volume or weight problem.\\n\\nAs you can see from above, the relationship between delivery with\\n{@link IShoppingOrder order} (or {@link IShoppingOrderGood good}) is not 1: 1 or\\nN: 1, but M: N. Entity `IShoppingDelivery` has been designed to represent such\\nrelationship, by referencing target stocks or goods through subsidiary entity\\n{@link IShoppingDeliveryPiece}.\\n\\nAlso, delivery does not end with only one step. It has multiple processes like\\nmanufacturing, planning, shipping and delivering. Those steps are represented by\\nanother subsidiary entity {@link IShoppingDeliveryJourney}.\"\n      },\n      \"IShoppingDeliveryJourney\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"title\": \"Primary Key\",\n            \"description\": \"Primary Key.\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"title\": \"Creation time of the record\",\n            \"description\": \"Creation time of the record.\"\n          },\n          \"deleted_at\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\",\n                \"format\": \"date-time\"\n              }\n            ],\n            \"title\": \"Deletion time of the record\",\n            \"description\": \"Deletion time of the record.\"\n          },\n          \"type\": {\n            \"oneOf\": [\n              {\n                \"const\": \"preparing\"\n              },\n              {\n                \"const\": \"manufacturing\"\n              },\n              {\n                \"const\": \"shipping\"\n              },\n              {\n                \"const\": \"delivering\"\n              }\n            ],\n            \"title\": \"Type of journey\",\n            \"description\": \"Type of journey.\\n\\n- preparing\\n- manufacturing\\n- shipping\\n- delivering\"\n          },\n          \"title\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\"\n              }\n            ],\n            \"title\": \"Title of journey\",\n            \"description\": \"Title of journey.\"\n          },\n          \"description\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\"\n              }\n            ],\n            \"title\": \"Description of journey\",\n            \"description\": \"Description of journey.\"\n          },\n          \"started_at\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\",\n                \"format\": \"date-time\"\n              }\n            ],\n            \"title\": \"Start time of the journey\",\n            \"description\": \"Start time of the journey.\"\n          },\n          \"completed_at\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\",\n                \"format\": \"date-time\"\n              }\n            ],\n            \"title\": \"Completion time of the journey\",\n            \"description\": \"Completion time of the journey.\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"created_at\",\n          \"deleted_at\",\n          \"type\",\n          \"title\",\n          \"description\",\n          \"started_at\",\n          \"completed_at\"\n        ],\n        \"description\": \"Journey of delivery.\\n\\n`IShoppingDeliveryJourney` is a subsidiary entity of {@link IShoppingDelivery},\\ndescribing each journey of the delivery. For reference, the word journey\\nmeans each step of the delivery process, such as preparing, shipping, and\\ndelivering {@link IShoppingOrderGood goods} to the\\n{@link IShoppingCustomer customer}.\"\n      },\n      \"IShoppingDeliveryPiece\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"title\": \"Primary Key\",\n            \"description\": \"Primary Key.\"\n          },\n          \"publish_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"title\": \"Target order's {@link IShoppingOrderPublish.id}\",\n            \"description\": \"Target order's {@link IShoppingOrderPublish.id}.\"\n          },\n          \"good_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"title\": \"Target good's {@link IShoppingOrderGood.id}\",\n            \"description\": \"Target good's {@link IShoppingOrderGood.id}.\"\n          },\n          \"stock_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"title\": \"Target stock's {@link IShoppingSaleUnitStock.id}\",\n            \"description\": \"Target stock's {@link IShoppingSaleUnitStock.id}.\"\n          },\n          \"quantity\": {\n            \"type\": \"number\",\n            \"minimum\": 0,\n            \"title\": \"Quantity of the stock\",\n            \"description\": \"Quantity of the stock.\\n\\nIt can be precision value to express split shipping.\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"publish_id\",\n          \"good_id\",\n          \"stock_id\",\n          \"quantity\"\n        ],\n        \"description\": \"Which stocks are delivered.\\n\\n`IShoppingDeliveryPiece` is a subsidiary entity of {@link IShoppingDelivery},\\ndescribing how much quantity is delivered for each\\n{@link IShoppingSaleUnitStock stock} in {@link IShoppingOrder}.\\n\\nFor reference, as an order can be delivered in multiple times due to volume\\nor weight problem, it is possible to have multiple `IShoppingDeliveryPiece`\\nrecords for a single stock.\"\n      },\n      \"IShoppingDeliveryShipper\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\"\n          },\n          \"company\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\"\n              }\n            ]\n          },\n          \"name\": {\n            \"type\": \"string\"\n          },\n          \"mobile\": {\n            \"type\": \"string\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"created_at\",\n          \"company\",\n          \"name\",\n          \"mobile\"\n        ]\n      },\n      \"IShoppingAddress\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"title\": \"Primary Key\",\n            \"description\": \"Primary Key.\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"title\": \"Creation time of record\",\n            \"description\": \"Creation time of record.\"\n          },\n          \"mobile\": {\n            \"type\": \"string\",\n            \"pattern\": \"^[0-9]*$\",\n            \"title\": \"Mobile number to contact\",\n            \"description\": \"Mobile number to contact.\"\n          },\n          \"name\": {\n            \"type\": \"string\",\n            \"title\": \"Representative name of the address\",\n            \"description\": \"Representative name of the address.\\n\\nSometimes be receiver's name, and sometimes be place name.\"\n          },\n          \"country\": {\n            \"type\": \"string\",\n            \"title\": \"Country name\",\n            \"description\": \"Country name.\"\n          },\n          \"province\": {\n            \"type\": \"string\",\n            \"title\": \"Province name\",\n            \"description\": \"Province name.\"\n          },\n          \"city\": {\n            \"type\": \"string\",\n            \"title\": \"City name\",\n            \"description\": \"City name.\"\n          },\n          \"department\": {\n            \"type\": \"string\",\n            \"title\": \"Department name\",\n            \"description\": \"Department name.\"\n          },\n          \"possession\": {\n            \"type\": \"string\",\n            \"title\": \"Detailed address containing street name, building number, and room number\",\n            \"description\": \"Detailed address containing street name, building number, and room number.\"\n          },\n          \"zip_code\": {\n            \"type\": \"string\",\n            \"title\": \"Zip code, or postal code\",\n            \"description\": \"Zip code, or postal code.\"\n          },\n          \"special_note\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\"\n              }\n            ],\n            \"title\": \"Special description if required\",\n            \"description\": \"Special description if required.\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"created_at\",\n          \"mobile\",\n          \"name\",\n          \"country\",\n          \"province\",\n          \"city\",\n          \"department\",\n          \"possession\",\n          \"zip_code\",\n          \"special_note\"\n        ],\n        \"description\": \"The address information.\"\n      },\n      \"IShoppingOrder.IRequest\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"search\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"$ref\": \"#/components/schemas/IShoppingOrder.IRequest.ISearch\"\n              }\n            ]\n          },\n          \"sort\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"array\",\n                \"items\": {\n                  \"oneOf\": [\n                    {\n                      \"const\": \"-order.price\"\n                    },\n                    {\n                      \"const\": \"-order.quantity\"\n                    },\n                    {\n                      \"const\": \"-order.created_at\"\n                    },\n                    {\n                      \"const\": \"-order.publish.paid_at\"\n                    },\n                    {\n                      \"const\": \"+order.price\"\n                    },\n                    {\n                      \"const\": \"+order.quantity\"\n                    },\n                    {\n                      \"const\": \"+order.created_at\"\n                    },\n                    {\n                      \"const\": \"+order.publish.paid_at\"\n                    }\n                  ]\n                }\n              }\n            ]\n          },\n          \"page\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"integer\",\n                \"minimum\": 0\n              }\n            ],\n            \"title\": \"Page number\",\n            \"description\": \"Page number.\"\n          },\n          \"limit\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"integer\",\n                \"minimum\": 0\n              }\n            ],\n            \"title\": \"Limitation of records per a page\",\n            \"description\": \"Limitation of records per a page.\"\n          }\n        },\n        \"required\": [],\n        \"description\": \"Request of orders with pagination and searching/sorting conditions.\"\n      },\n      \"IShoppingOrder.IRequest.ISearch\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"min_price\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"number\"\n              }\n            ]\n          },\n          \"max_price\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"number\"\n              }\n            ]\n          },\n          \"paid\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"boolean\"\n              }\n            ]\n          },\n          \"sale\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"$ref\": \"#/components/schemas/IShoppingSale.IRequest.ISearch\"\n              }\n            ]\n          }\n        },\n        \"required\": []\n      },\n      \"IShoppingSale.IRequest.ISearch\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"show_paused\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"boolean\"\n              }\n            ]\n          },\n          \"show_suspended\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"const\": \"only\"\n              },\n              {\n                \"type\": \"boolean\"\n              }\n            ]\n          },\n          \"title\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\"\n              }\n            ]\n          },\n          \"content\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\"\n              }\n            ]\n          },\n          \"title_or_content\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\"\n              }\n            ]\n          },\n          \"price\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"$ref\": \"#/components/schemas/IShoppingPrice.ISearch\"\n              }\n            ]\n          },\n          \"review\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"$ref\": \"#/components/schemas/IShoppingSaleReview.IInvertSearch\"\n              }\n            ]\n          },\n          \"section_codes\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"array\",\n                \"items\": {\n                  \"type\": \"string\"\n                }\n              }\n            ]\n          },\n          \"channel_category_ids\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"array\",\n                \"items\": {\n                  \"type\": \"string\"\n                }\n              }\n            ]\n          },\n          \"tags\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"array\",\n                \"items\": {\n                  \"type\": \"string\"\n                }\n              }\n            ]\n          },\n          \"seller\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"$ref\": \"#/components/schemas/IShoppingSeller.IRequest.ISearch\"\n              }\n            ]\n          }\n        },\n        \"required\": []\n      },\n      \"IShoppingPrice.ISearch\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"minimum\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"number\"\n              }\n            ]\n          },\n          \"maximum\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"number\"\n              }\n            ]\n          }\n        },\n        \"required\": []\n      },\n      \"IShoppingSaleReview.IInvertSearch\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"score\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"$ref\": \"#/components/schemas/IShoppingSaleReview.IInvertSearch.IScoreRange\"\n              }\n            ]\n          },\n          \"count\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"$ref\": \"#/components/schemas/IShoppingSaleReview.IInvertSearch.ICountRange\"\n              }\n            ]\n          }\n        },\n        \"required\": []\n      },\n      \"IShoppingSaleReview.IInvertSearch.IScoreRange\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"minimum\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"number\",\n                \"minimum\": 0,\n                \"maximum\": 100\n              }\n            ]\n          },\n          \"maximum\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"number\",\n                \"minimum\": 0,\n                \"maximum\": 100\n              }\n            ]\n          }\n        },\n        \"required\": []\n      },\n      \"IShoppingSaleReview.IInvertSearch.ICountRange\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"minimum\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"integer\",\n                \"minimum\": 0\n              }\n            ]\n          },\n          \"maximum\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"integer\",\n                \"minimum\": 0\n              }\n            ]\n          }\n        },\n        \"required\": []\n      },\n      \"IShoppingSeller.IRequest.ISearch\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\",\n                \"format\": \"uuid\"\n              }\n            ]\n          },\n          \"mobile\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\",\n                \"pattern\": \"^[0-9]*$\"\n              }\n            ]\n          },\n          \"name\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\"\n              }\n            ]\n          },\n          \"email\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\",\n                \"format\": \"email\"\n              }\n            ]\n          },\n          \"nickname\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\"\n              }\n            ]\n          }\n        },\n        \"required\": []\n      },\n      \"IPageIShoppingSale\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"pagination\": {\n            \"$ref\": \"#/components/schemas/IPage.IPagination\",\n            \"title\": \"Page information\",\n            \"description\": \"Page information.\"\n          },\n          \"data\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IShoppingSale\"\n            },\n            \"title\": \"List of records\",\n            \"description\": \"List of records.\"\n          }\n        },\n        \"required\": [\n          \"pagination\",\n          \"data\"\n        ],\n        \"description\": \"A page.\\n\\nCollection of records with pagination indformation.\"\n      },\n      \"IShoppingSale\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"section\": {\n            \"$ref\": \"#/components/schemas/IShoppingSection\",\n            \"title\": \"Belonged section\",\n            \"description\": \"Belonged section.\"\n          },\n          \"seller\": {\n            \"$ref\": \"#/components/schemas/IShoppingSeller.IInvert\",\n            \"title\": \"Seller who has registered the sale\",\n            \"description\": \"Seller who has registered the sale.\"\n          },\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"title\": \"Primary Key of Sale\",\n            \"description\": \"Primary Key of Sale.\"\n          },\n          \"snapshot_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"title\": \"Primary Key of Snapshot\",\n            \"description\": \"Primary Key of Snapshot.\"\n          },\n          \"latest\": {\n            \"type\": \"boolean\",\n            \"title\": \"Whether the snapshot is the latest one or not\",\n            \"description\": \"Whether the snapshot is the latest one or not.\"\n          },\n          \"content\": {\n            \"$ref\": \"#/components/schemas/IShoppingSaleContent\",\n            \"title\": \"Description and image content describing the sale\",\n            \"description\": \"Description and image content describing the sale.\"\n          },\n          \"categories\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IShoppingChannelCategory.IInvert\"\n            },\n            \"title\": \"List of categories\",\n            \"description\": \"List of categories.\\n\\nWhich categories the sale is registered to.\"\n          },\n          \"tags\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"type\": \"string\"\n            },\n            \"title\": \"List of search tags\",\n            \"description\": \"List of search tags.\"\n          },\n          \"units\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IShoppingSaleUnit\"\n            },\n            \"minItems\": 1,\n            \"title\": \"List of units\",\n            \"description\": \"List of units.\\n\\nRecords about individual product composition information that are sold\\nin the sale. Each {@link IShoppingSaleUnit unit} record has configurable\\n{@link IShoppingSaleUnitOption options},\\n{@link IShoppingSaleUnitOptionCandidate candidate} values for each\\noption, and {@link IShoppingSaleUnitStock final stocks} determined by\\nselecting every candidate values of each option.\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"title\": \"Creation time of the record\",\n            \"description\": \"Creation time of the record.\\n\\nNote that, this property is different with {@link opened_at},\\nwhich means the timepoint of the sale is opened.\"\n          },\n          \"updated_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"title\": \"Last updated time of the record\",\n            \"description\": \"Last updated time of the record.\\n\\nIn another words, creation time of the last snapshot.\"\n          },\n          \"paused_at\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\",\n                \"format\": \"date-time\"\n              }\n            ],\n            \"title\": \"Paused time of the sale\",\n            \"description\": \"Paused time of the sale.\\n\\nThe sale is paused by the seller, for some reason.\\n\\n{@link IShoppingCustomer Customers} can still see the sale on the\\nboth list and detail pages, but the sale has a warning label\\n\\\"The sale is paused by the seller\\\".\"\n          },\n          \"suspended_at\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\",\n                \"format\": \"date-time\"\n              }\n            ],\n            \"title\": \"Suspended time of the sale\",\n            \"description\": \"Suspended time of the sale.\\n\\nThe sale is suspended by the seller, for some reason.\\n\\n{@link IShoppingCustomer Customers} cannot see the sale on the\\nboth list and detail pages. It is almost same with soft delettion,\\nbut there's a little bit difference that the owner\\n{@link IShoppingSeller seller} can still see the sale and resume it.\\n\\nOf course, the {@link IShoppingCustomer customers} who have\\nalready purchased the sale can still see the sale on the\\n{@link IShoppingOrder order} page.\"\n          },\n          \"opened_at\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\",\n                \"format\": \"date-time\"\n              }\n            ],\n            \"title\": \"Opening time of the sale\",\n            \"description\": \"Opening time of the sale.\"\n          },\n          \"closed_at\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\",\n                \"format\": \"date-time\"\n              }\n            ],\n            \"title\": \"Closing time of the sale\",\n            \"description\": \"Closing time of the sale.\\n\\nIf this value is `null`, the sale be continued forever.\"\n          }\n        },\n        \"required\": [\n          \"section\",\n          \"seller\",\n          \"id\",\n          \"snapshot_id\",\n          \"latest\",\n          \"content\",\n          \"categories\",\n          \"tags\",\n          \"units\",\n          \"created_at\",\n          \"updated_at\",\n          \"paused_at\",\n          \"suspended_at\",\n          \"opened_at\",\n          \"closed_at\"\n        ],\n        \"description\": \"Seller sales products.\\n\\n`IShoppingSale` is an entity that embodies \\\"product sales\\\" (sales)\\ninformation registered by the {@link ISoppingSeller seller}. And the main\\ninformation of the sale is recorded in the sub {@link IShoppingSaleSnapshot},\\nnot in the main `IShoppingSale`. When a seller changes a previously registered\\nitem, the existing `IShoppingSale` record is not changed, but a new\\n{@link IShoppingSaleSnapshot snapshot} record be created.\\n\\nThis is to preserve the {@link IShoppingCustomer customer}'s\\n{@link IShoppingOrder purchase history} flawlessly after the customer\\npurchases a specific item, even if the seller changes the components or\\nprice of the item. It is also intended to support sellers in so-called A/B\\ntesting, which involves changing components or prices and measuring the\\nperformance in each case.\"\n      },\n      \"IShoppingSaleContent\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"title\": \"Primary Key\",\n            \"description\": \"Primary Key.\"\n          },\n          \"title\": {\n            \"type\": \"string\",\n            \"title\": \"Title of the content\",\n            \"description\": \"Title of the content.\"\n          },\n          \"format\": {\n            \"oneOf\": [\n              {\n                \"const\": \"html\"\n              },\n              {\n                \"const\": \"md\"\n              },\n              {\n                \"const\": \"txt\"\n              }\n            ],\n            \"title\": \"Format of the body content\",\n            \"description\": \"Format of the body content.\\n\\nSame meaning with file extension like `html`, `md`, and `txt`.\"\n          },\n          \"body\": {\n            \"type\": \"string\",\n            \"title\": \"The main body content\",\n            \"description\": \"The main body content.\\n\\nFormat follows the {@link format}, and default is `md` (markdown).\"\n          },\n          \"files\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IAttachmentFile\"\n            },\n            \"title\": \"List of attached files\",\n            \"description\": \"List of attached files.\"\n          },\n          \"thumbnails\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IAttachmentFile\"\n            },\n            \"title\": \"List of thumbnails\",\n            \"description\": \"List of thumbnails.\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"title\",\n          \"format\",\n          \"body\",\n          \"files\",\n          \"thumbnails\"\n        ],\n        \"description\": \"Content information of sale snapshot.\\n\\n`IShoppingSaleContent` is an entity embodies the description contents\\nof {@link IShoppingSale}.\"\n      },\n      \"IShoppingSaleUnit\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"options\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"oneOf\": [\n                {\n                  \"$ref\": \"#/components/schemas/IShoppingSaleUnitSelectableOption\"\n                },\n                {\n                  \"$ref\": \"#/components/schemas/IShoppingSaleUnitDescriptiveOption\"\n                }\n              ]\n            },\n            \"title\": \"List of options\",\n            \"description\": \"List of options.\"\n          },\n          \"stocks\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IShoppingSaleUnitStock\"\n            },\n            \"minItems\": 1,\n            \"title\": \"List of final stocks\",\n            \"description\": \"List of final stocks.\"\n          },\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"title\": \"Primary Key\",\n            \"description\": \"Primary Key.\"\n          },\n          \"name\": {\n            \"type\": \"string\",\n            \"title\": \"Representative name of the unit\",\n            \"description\": \"Representative name of the unit.\"\n          },\n          \"primary\": {\n            \"type\": \"boolean\",\n            \"title\": \"Whether the unit is primary or not\",\n            \"description\": \"Whether the unit is primary or not.\\n\\nJust a labeling value.\"\n          },\n          \"required\": {\n            \"type\": \"boolean\",\n            \"title\": \"Whether the unit is required or not\",\n            \"description\": \"Whether the unit is required or not.\\n\\nWhen the unit is required, the customer must select the unit. If do not\\nselect, customer can't buy it.\\n\\nFor example, if there's a sale \\\"Macbook Set\\\" and one of the unit is the\\n\\\"Main Body\\\", is it possible to buy the \\\"Macbook Set\\\" without the\\n\\\"Main Body\\\" unit? This property is for that case.\"\n          }\n        },\n        \"required\": [\n          \"options\",\n          \"stocks\",\n          \"id\",\n          \"name\",\n          \"primary\",\n          \"required\"\n        ],\n        \"description\": \"Product composition information handled in the sale.\\n\\n`IShoppingSaleUnit` is an entity that embodies the \\\"individual product\\\"\\ninformation handled in the {@link IShoppingSale sale}.\\n\\nFor reference, the reason why `IShoppingSaleUnit` is separated from\\n{@link IShoppingSaleSnapshot} by an algebraic relationship of 1: N is because\\nthere are some cases where multiple products are sold in one listing. This is\\nthe case with so-called \\\"bundled products\\\".\\n\\n- Bundle from regular product (Mackbook Set)\\n  - Main Body\\n  - Keyboard\\n  - Mouse\\n  - Apple Care (Free A/S Voucher)\\n\\nAnd again, `IShoppingSaleUnit` does not in itself refer to the\\n{@link IShoppingSaleUnitStock final stock} that the\\n{@link IShoppingCustomer customer} will {@link IShoppingOrder purchase}.\\nThe final stock can be found only after selecting all given\\n{@link IShoppingSaleUnitOption options} and their\\n{@link IShoppingSaleUnitOptionCandidate candidate values}.\\n\\nFor example, even if you buy a Macbook, the final stocks are determined only\\nafter selecting all the options (CPU / RAM / SSD), etc.\"\n      },\n      \"IShoppingSaleUnitSelectableOption\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"candidates\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IShoppingSaleUnitOptionCandidate\"\n            },\n            \"minItems\": 1,\n            \"title\": \"List of candidate values\",\n            \"description\": \"List of candidate values.\"\n          },\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"title\": \"Primary Key\",\n            \"description\": \"Primary Key.\"\n          },\n          \"type\": {\n            \"const\": \"select\",\n            \"title\": \"Discriminant for the type of selectable option\",\n            \"description\": \"Discriminant for the type of selectable option.\"\n          },\n          \"name\": {\n            \"type\": \"string\",\n            \"title\": \"Represents the name of the option\",\n            \"description\": \"Represents the name of the option.\"\n          },\n          \"variable\": {\n            \"type\": \"boolean\",\n            \"title\": \"Whether the option is variable or not\",\n            \"description\": \"Whether the option is variable or not.\\n\\nWhen type of current option is \\\"select\\\", this attribute means whether\\nselecting different candidate value affects the final stock or not.\"\n          }\n        },\n        \"required\": [\n          \"candidates\",\n          \"id\",\n          \"type\",\n          \"name\",\n          \"variable\"\n        ],\n        \"description\": \"Individual option information on units for sale.\\n\\n`IShoppingSaleUnitSelectableOption` is a subsidiary entity of\\n{@link IShoppingSaleUnit} that represents individual products in the\\n{@link IShoppingSale sale}, and is an entity designed to represent individual\\nselectable option information for the unit.\\n\\n- Examples of Options\\n  - selectable options\\n    - Computer: CPU, RAM, SSD, etc.\\n    - Clothes: size, color, style, etc.\\n  - descriptive options\\n    - Engrave\\n    - Simple question\\n\\nIf the {@link variable} property value is `true`, the final stock that the\\n{@link IShoppingCustomer customer} will purchase changes depending on the\\nselection of the {@link IShoppingSaleUnitOptionCandidate candidate value}.\\n\\nConversely, if it is a type other than \\\"select\\\", or if the {@link variable}\\nproperty value is \\\"false\\\", , this is an option that has no meaning beyond\\nsimple information transfer. Therefore, no matter what value the customer\\nchooses when purchasing it, the option in this case does not affect the\\n{@link IShoppingSaleUnitStock final stock}.\"\n      },\n      \"IShoppingSaleUnitStock\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"title\": \"Primary Key\",\n            \"description\": \"Primary Key.\"\n          },\n          \"name\": {\n            \"type\": \"string\",\n            \"title\": \"Representative name of the stock\",\n            \"description\": \"Representative name of the stock.\"\n          },\n          \"price\": {\n            \"$ref\": \"#/components/schemas/IShoppingPrice\",\n            \"title\": \"Price of the stock\",\n            \"description\": \"Price of the stock.\"\n          },\n          \"inventory\": {\n            \"$ref\": \"#/components/schemas/IShoppingSaleUnitStockInventory\",\n            \"title\": \"Current inventory status of the stock\",\n            \"description\": \"Current inventory status of the stock.\"\n          },\n          \"choices\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IShoppingSaleUnitStockChoice\"\n            },\n            \"title\": \"List of choices\",\n            \"description\": \"List of choices.\\n\\nWhich candidate values being chosen for each option.\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"name\",\n          \"price\",\n          \"inventory\",\n          \"choices\"\n        ],\n        \"description\": \"Final component information on units for sale.\\n\\n`IShoppingSaleUnitStock` is a subsidiary entity of {@link IShoppingSaleUnit}\\nthat represents a product catalog for sale, and is a kind of final stock that is\\nconstructed by selecting all {@link IShoppingSaleUnitSelectableOption options}\\n(variable \\\"select\\\" type) and their\\n{@link IShoppingSaleUnitOptionCandidate candidate} values in the belonging unit.\\nIt is the \\\"good\\\" itself that customers actually purchase.\\n\\n- Product Name) MacBook\\n  - Options\\n    - CPU: { i3, i5, i7, i9 }\\n    - RAM: { 8GB, 16GB, 32GB, 64GB, 96GB }\\n    - SSD: { 256GB, 512GB, 1TB }\\n  - Number of final stocks: 4 * 5 * 3 = 60\\n\\nFor reference, the total number of `IShoppingSaleUnitStock` records in an\\nattribution unit can be obtained using Cartesian Product. In other words, the\\nvalue obtained by multiplying all the candidate values that each\\n(variable \\\"select\\\" type) option can have by the number of cases is the total\\nnumber of final stocks in the unit.\\n\\nOf course, without a single variable \\\"select\\\" type option, the final stocks\\ncount in the unit is only 1.\"\n      },\n      \"IShoppingSaleUnitStockChoice\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"title\": \"Primary Key\",\n            \"description\": \"Primary Key.\"\n          },\n          \"option_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"Target option's {@link IShoppingSaleUnitOption.id}\"\n          },\n          \"candidate_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"Target candidate's {@link IShoppingSaleUnitOptionCandidate.id}\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"option_id\",\n          \"candidate_id\"\n        ],\n        \"description\": \"Selection information of final stock.\\n\\n`IShoppingSaleUnitStockChoice` is an entity that represents which\\n{@link IShoppingSaleUnitSelectableOption option} of each variable \\\"select\\\"\\ntype was selected for each {@link IShoppingSaleUnitStock stock} and which\\n{@link IShoppingSaleUnitOptionCandidate candidate value} was selected within\\nit.\\n\\nOf course, if the bound {@link IShoppingSaleUnit unit} does not have any\\noptions, this entity can also be ignored.\"\n      },\n      \"IShoppingSale.IRequest\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"sort\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"array\",\n                \"items\": {\n                  \"oneOf\": [\n                    {\n                      \"const\": \"-seller.created_at\"\n                    },\n                    {\n                      \"const\": \"-seller.goods.payments.real\"\n                    },\n                    {\n                      \"const\": \"-seller.goods.publish_count\"\n                    },\n                    {\n                      \"const\": \"-seller.reviews.average\"\n                    },\n                    {\n                      \"const\": \"-seller.reviews.count\"\n                    },\n                    {\n                      \"const\": \"-goods.publish_count\"\n                    },\n                    {\n                      \"const\": \"-goods.payments.real\"\n                    },\n                    {\n                      \"const\": \"-reviews.average\"\n                    },\n                    {\n                      \"const\": \"-reviews.count\"\n                    },\n                    {\n                      \"const\": \"-sale.created_at\"\n                    },\n                    {\n                      \"const\": \"-sale.updated_at\"\n                    },\n                    {\n                      \"const\": \"-sale.opened_at\"\n                    },\n                    {\n                      \"const\": \"-sale.closed_at\"\n                    },\n                    {\n                      \"const\": \"-sale.content.title\"\n                    },\n                    {\n                      \"const\": \"-sale.price_range.lowest.real\"\n                    },\n                    {\n                      \"const\": \"-sale.price_range.highest.real\"\n                    },\n                    {\n                      \"const\": \"+seller.created_at\"\n                    },\n                    {\n                      \"const\": \"+seller.goods.payments.real\"\n                    },\n                    {\n                      \"const\": \"+seller.goods.publish_count\"\n                    },\n                    {\n                      \"const\": \"+seller.reviews.average\"\n                    },\n                    {\n                      \"const\": \"+seller.reviews.count\"\n                    },\n                    {\n                      \"const\": \"+goods.publish_count\"\n                    },\n                    {\n                      \"const\": \"+goods.payments.real\"\n                    },\n                    {\n                      \"const\": \"+reviews.average\"\n                    },\n                    {\n                      \"const\": \"+reviews.count\"\n                    },\n                    {\n                      \"const\": \"+sale.created_at\"\n                    },\n                    {\n                      \"const\": \"+sale.updated_at\"\n                    },\n                    {\n                      \"const\": \"+sale.opened_at\"\n                    },\n                    {\n                      \"const\": \"+sale.closed_at\"\n                    },\n                    {\n                      \"const\": \"+sale.content.title\"\n                    },\n                    {\n                      \"const\": \"+sale.price_range.lowest.real\"\n                    },\n                    {\n                      \"const\": \"+sale.price_range.highest.real\"\n                    }\n                  ]\n                }\n              }\n            ],\n            \"title\": \"Sorting conditions\",\n            \"description\": \"Sorting conditions.\"\n          },\n          \"page\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"integer\",\n                \"minimum\": 0\n              }\n            ],\n            \"title\": \"Page number\",\n            \"description\": \"Page number.\"\n          },\n          \"limit\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"integer\",\n                \"minimum\": 0\n              }\n            ],\n            \"title\": \"Limitation of records per a page\",\n            \"description\": \"Limitation of records per a page.\"\n          }\n        },\n        \"required\": [],\n        \"description\": \"Request of summarized sales with pagination and searching/sorting options.\"\n      },\n      \"IPageIShoppingSale.ISummary\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"pagination\": {\n            \"$ref\": \"#/components/schemas/IPage.IPagination\",\n            \"title\": \"Page information\",\n            \"description\": \"Page information.\"\n          },\n          \"data\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IShoppingSale.ISummary\"\n            },\n            \"title\": \"List of records\",\n            \"description\": \"List of records.\"\n          }\n        },\n        \"required\": [\n          \"pagination\",\n          \"data\"\n        ],\n        \"description\": \"A page.\\n\\nCollection of records with pagination indformation.\"\n      },\n      \"IPageIShoppingSaleInquiryComment\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"pagination\": {\n            \"$ref\": \"#/components/schemas/IPage.IPagination\",\n            \"title\": \"Page information\",\n            \"description\": \"Page information.\"\n          },\n          \"data\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IShoppingSaleInquiryComment\"\n            },\n            \"title\": \"List of records\",\n            \"description\": \"List of records.\"\n          }\n        },\n        \"required\": [\n          \"pagination\",\n          \"data\"\n        ],\n        \"description\": \"A page.\\n\\nCollection of records with pagination indformation.\"\n      },\n      \"IShoppingSaleInquiryComment\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"writer\": {\n            \"oneOf\": [\n              {\n                \"$ref\": \"#/components/schemas/IShoppingAdministrator.IInvert\"\n              },\n              {\n                \"$ref\": \"#/components/schemas/IShoppingCustomer\"\n              },\n              {\n                \"$ref\": \"#/components/schemas/IShoppingSeller.IInvert\"\n              }\n            ],\n            \"title\": \"Writer of the comment\",\n            \"description\": \"Writer of the comment.\\n\\nBoth customer and seller can write comment on the sale inquiry.\\n\\nBy the way, no restriction on the customer, but seller must be the\\nperson who've registered the sale.\"\n          },\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"title\": \"Primary Key\",\n            \"description\": \"Primary Key.\"\n          },\n          \"parent_id\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\",\n                \"format\": \"uuid\"\n              }\n            ],\n            \"title\": \"Parent comment's ID\",\n            \"description\": \"Parent comment's ID.\"\n          },\n          \"snapshots\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IBbsArticleComment.ISnapshot\"\n            },\n            \"minItems\": 1,\n            \"title\": \"List of snapshot contents\",\n            \"description\": \"List of snapshot contents.\\n\\nIt is created for the first time when a comment being created, and is\\naccumulated every time the comment is modified.\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"title\": \"Creation time of comment\",\n            \"description\": \"Creation time of comment.\"\n          }\n        },\n        \"required\": [\n          \"writer\",\n          \"id\",\n          \"parent_id\",\n          \"snapshots\",\n          \"created_at\"\n        ],\n        \"description\": \"A comment written on an inquiry article.\\n\\n`IShoppingSaleInquiryComment` is a subtype entity of {@link IBbsArticleComment},\\nand is used when you want to communicate with multiple people about an\\n{@link IShoppingSaleInquiry inquiry} written by a\\n{@link IShoppingCustomer customer}.\\n\\nFor reference, only related parties can write comments for\\n{@link IShoppingSeller sellers}, but there is no limit to\\n{@link IShoppingCustomer customers}. In other words, anyone customer can\\nfreely write a comment, even if they are not the person who wrote the inquiry.\"\n      },\n      \"IBbsArticleComment.ISnapshot\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"title\": \"Primary Key\",\n            \"description\": \"Primary Key.\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"title\": \"Creation time of snapshot record\",\n            \"description\": \"Creation time of snapshot record.\\n\\nIn other words, creation time or update time or comment.\"\n          },\n          \"format\": {\n            \"oneOf\": [\n              {\n                \"const\": \"html\"\n              },\n              {\n                \"const\": \"md\"\n              },\n              {\n                \"const\": \"txt\"\n              }\n            ],\n            \"title\": \"Format of body\",\n            \"description\": \"Format of body.\\n\\nSame meaning with extension like `html`, `md`, `txt`.\"\n          },\n          \"body\": {\n            \"type\": \"string\",\n            \"title\": \"Content body of comment\",\n            \"description\": \"Content body of comment.\"\n          },\n          \"files\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IAttachmentFile.ICreate\"\n            },\n            \"title\": \"List of attachment files\",\n            \"description\": \"List of attachment files.\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"created_at\",\n          \"format\",\n          \"body\",\n          \"files\"\n        ],\n        \"description\": \"Snapshot of comment.\\n\\n`IBbsArticleComment.ISnapshot` is a snapshot entity that contains\\nthe contents of the comment.\\n\\nAs mentioned in {@link IBbsArticleComment}, designed to keep evidence\\nand prevent fraud.\"\n      },\n      \"IAttachmentFile.ICreate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"name\": {\n            \"type\": \"string\",\n            \"maxLength\": 255,\n            \"title\": \"File name, except extension\",\n            \"description\": \"File name, except extension.\\n\\nIf there's file `.gitignore`, then its name is an empty string.\"\n          },\n          \"extension\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\",\n                \"minLength\": 1,\n                \"maxLength\": 8\n              }\n            ],\n            \"title\": \"Extension\",\n            \"description\": \"Extension.\\n\\nPossible to omit like `README` case.\"\n          },\n          \"url\": {\n            \"type\": \"string\",\n            \"format\": \"uri\",\n            \"contentMediaType\": \"image/*\",\n            \"title\": \"URL path of the real file\",\n            \"description\": \"URL path of the real file.\"\n          }\n        },\n        \"required\": [\n          \"name\",\n          \"extension\",\n          \"url\"\n        ]\n      },\n      \"IShoppingSaleInquiryComment.IRequest\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"search\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"$ref\": \"#/components/schemas/IShoppingSaleInquiryComment.IRequest.ISearch\"\n              }\n            ]\n          },\n          \"sort\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"array\",\n                \"items\": {\n                  \"oneOf\": [\n                    {\n                      \"const\": \"-created_at\"\n                    },\n                    {\n                      \"const\": \"+created_at\"\n                    }\n                  ]\n                }\n              }\n            ]\n          },\n          \"page\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"integer\",\n                \"minimum\": 0\n              }\n            ],\n            \"title\": \"Page number\",\n            \"description\": \"Page number.\"\n          },\n          \"limit\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"integer\",\n                \"minimum\": 0\n              }\n            ],\n            \"title\": \"Limitation of records per a page\",\n            \"description\": \"Limitation of records per a page.\"\n          }\n        },\n        \"required\": [],\n        \"description\": \"Request of the comments with pagination and searching/sorting options.\"\n      },\n      \"IShoppingSaleInquiryComment.IRequest.ISearch\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"name\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\"\n              }\n            ]\n          },\n          \"nickname\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\"\n              }\n            ]\n          },\n          \"body\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\"\n              }\n            ]\n          }\n        },\n        \"required\": []\n      },\n      \"IShoppingSaleInquiryComment.ICreate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"format\": {\n            \"oneOf\": [\n              {\n                \"const\": \"html\"\n              },\n              {\n                \"const\": \"md\"\n              },\n              {\n                \"const\": \"txt\"\n              }\n            ],\n            \"title\": \"Format of body\",\n            \"description\": \"Format of body.\\n\\nSame meaning with extension like `html`, `md`, `txt`.\"\n          },\n          \"body\": {\n            \"type\": \"string\",\n            \"title\": \"Content body of comment\",\n            \"description\": \"Content body of comment.\"\n          },\n          \"files\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IAttachmentFile.ICreate\"\n            },\n            \"title\": \"List of attachment files\",\n            \"description\": \"List of attachment files.\"\n          }\n        },\n        \"required\": [\n          \"format\",\n          \"body\",\n          \"files\"\n        ],\n        \"description\": \"Creation information of the comment.\"\n      },\n      \"IShoppingSaleInquiryComment.ISnapshot\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"title\": \"Primary Key\",\n            \"description\": \"Primary Key.\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"title\": \"Creation time of snapshot record\",\n            \"description\": \"Creation time of snapshot record.\\n\\nIn other words, creation time or update time or comment.\"\n          },\n          \"format\": {\n            \"oneOf\": [\n              {\n                \"const\": \"html\"\n              },\n              {\n                \"const\": \"md\"\n              },\n              {\n                \"const\": \"txt\"\n              }\n            ],\n            \"title\": \"Format of body\",\n            \"description\": \"Format of body.\\n\\nSame meaning with extension like `html`, `md`, `txt`.\"\n          },\n          \"body\": {\n            \"type\": \"string\",\n            \"title\": \"Content body of comment\",\n            \"description\": \"Content body of comment.\"\n          },\n          \"files\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IAttachmentFile.ICreate\"\n            },\n            \"title\": \"List of attachment files\",\n            \"description\": \"List of attachment files.\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"created_at\",\n          \"format\",\n          \"body\",\n          \"files\"\n        ],\n        \"description\": \"Snapshot content of the comment.\"\n      },\n      \"IPageIShoppingSaleQuestion.ISummary\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"pagination\": {\n            \"$ref\": \"#/components/schemas/IPage.IPagination\",\n            \"title\": \"Page information\",\n            \"description\": \"Page information.\"\n          },\n          \"data\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IShoppingSaleQuestion.ISummary\"\n            },\n            \"title\": \"List of records\",\n            \"description\": \"List of records.\"\n          }\n        },\n        \"required\": [\n          \"pagination\",\n          \"data\"\n        ],\n        \"description\": \"A page.\\n\\nCollection of records with pagination indformation.\"\n      },\n      \"IShoppingSaleQuestion.ISummary\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"secret\": {\n            \"type\": \"boolean\",\n            \"title\": \"Whether the question article is secret or not\",\n            \"description\": \"Whether the question article is secret or not.\\n\\nIf secret article, only the writer customer and related seller can see\\nthe detailed content.\"\n          },\n          \"customer\": {\n            \"$ref\": \"#/components/schemas/IShoppingCustomer\",\n            \"title\": \"Customer who wrote the inquiry\",\n            \"description\": \"Customer who wrote the inquiry.\"\n          },\n          \"answer\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"$ref\": \"#/components/schemas/IShoppingSaleInquiryAnswer.ISummary\"\n              }\n            ],\n            \"title\": \"Formal answer for the inquiry by the seller\",\n            \"description\": \"Formal answer for the inquiry by the seller.\"\n          },\n          \"read_by_seller\": {\n            \"type\": \"boolean\",\n            \"title\": \"Whether the seller has viewed the inquiry or not\",\n            \"description\": \"Whether the seller has viewed the inquiry or not.\"\n          },\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"title\": \"Primary Key\",\n            \"description\": \"Primary Key.\"\n          },\n          \"title\": {\n            \"type\": \"string\",\n            \"title\": \"Title of the last snapshot\",\n            \"description\": \"Title of the last snapshot.\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"title\": \"Creation time of the article\",\n            \"description\": \"Creation time of the article.\"\n          },\n          \"updated_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"title\": \"Modification time of the article\",\n            \"description\": \"Modification time of the article.\\n\\nIn other words, the time when the last snapshot was created.\"\n          }\n        },\n        \"required\": [\n          \"secret\",\n          \"customer\",\n          \"answer\",\n          \"read_by_seller\",\n          \"id\",\n          \"title\",\n          \"created_at\",\n          \"updated_at\"\n        ],\n        \"description\": \"Summarized information of the question.\"\n      },\n      \"IShoppingSaleInquiryAnswer.ISummary\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"seller\": {\n            \"$ref\": \"#/components/schemas/IShoppingSeller\"\n          },\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"title\": \"Primary Key\",\n            \"description\": \"Primary Key.\"\n          },\n          \"title\": {\n            \"type\": \"string\",\n            \"title\": \"Title of the last snapshot\",\n            \"description\": \"Title of the last snapshot.\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"title\": \"Creation time of the article\",\n            \"description\": \"Creation time of the article.\"\n          },\n          \"updated_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"title\": \"Modification time of the article\",\n            \"description\": \"Modification time of the article.\\n\\nIn other words, the time when the last snapshot was created.\"\n          }\n        },\n        \"required\": [\n          \"seller\",\n          \"id\",\n          \"title\",\n          \"created_at\",\n          \"updated_at\"\n        ]\n      },\n      \"IShoppingSaleQuestion.IRequest\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"search\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"$ref\": \"#/components/schemas/IShoppingSaleInquiry.IRequest.ISearch\"\n              }\n            ],\n            \"title\": \"Search conditions\",\n            \"description\": \"Search conditions.\"\n          },\n          \"sort\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"array\",\n                \"items\": {\n                  \"oneOf\": [\n                    {\n                      \"const\": \"-nickname\"\n                    },\n                    {\n                      \"const\": \"-answered_at\"\n                    },\n                    {\n                      \"const\": \"-created_at\"\n                    },\n                    {\n                      \"const\": \"-updated_at\"\n                    },\n                    {\n                      \"const\": \"-title\"\n                    },\n                    {\n                      \"const\": \"+nickname\"\n                    },\n                    {\n                      \"const\": \"+answered_at\"\n                    },\n                    {\n                      \"const\": \"+created_at\"\n                    },\n                    {\n                      \"const\": \"+updated_at\"\n                    },\n                    {\n                      \"const\": \"+title\"\n                    }\n                  ]\n                }\n              }\n            ],\n            \"title\": \"Sorting conditions\",\n            \"description\": \"Sorting conditions.\"\n          },\n          \"page\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"integer\",\n                \"minimum\": 0\n              }\n            ],\n            \"title\": \"Page number\",\n            \"description\": \"Page number.\"\n          },\n          \"limit\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"integer\",\n                \"minimum\": 0\n              }\n            ],\n            \"title\": \"Limitation of records per a page\",\n            \"description\": \"Limitation of records per a page.\"\n          }\n        },\n        \"required\": [],\n        \"description\": \"Request of summarized information with pagination searching/sorting options.\"\n      },\n      \"IShoppingSaleInquiry.IRequest.ISearch\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"name\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\"\n              }\n            ]\n          },\n          \"nickname\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\"\n              }\n            ]\n          },\n          \"answered\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"boolean\"\n              }\n            ]\n          },\n          \"title\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\"\n              }\n            ]\n          },\n          \"body\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\"\n              }\n            ]\n          },\n          \"title_or_body\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\"\n              }\n            ]\n          },\n          \"from\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\",\n                \"format\": \"date-time\"\n              }\n            ]\n          },\n          \"to\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\",\n                \"format\": \"date-time\"\n              }\n            ]\n          }\n        },\n        \"required\": []\n      },\n      \"IPageIShoppingSaleQuestion.IAbridge\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"pagination\": {\n            \"$ref\": \"#/components/schemas/IPage.IPagination\",\n            \"title\": \"Page information\",\n            \"description\": \"Page information.\"\n          },\n          \"data\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IShoppingSaleQuestion.IAbridge\"\n            },\n            \"title\": \"List of records\",\n            \"description\": \"List of records.\"\n          }\n        },\n        \"required\": [\n          \"pagination\",\n          \"data\"\n        ],\n        \"description\": \"A page.\\n\\nCollection of records with pagination indformation.\"\n      },\n      \"IShoppingSaleQuestion.IAbridge\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"secret\": {\n            \"type\": \"boolean\",\n            \"title\": \"Whether the question article is secret or not\",\n            \"description\": \"Whether the question article is secret or not.\\n\\nIf secret article, only the writer customer and related seller can see\\nthe detailed content.\"\n          },\n          \"customer\": {\n            \"$ref\": \"#/components/schemas/IShoppingCustomer\",\n            \"title\": \"Customer who wrote the inquiry\",\n            \"description\": \"Customer who wrote the inquiry.\"\n          },\n          \"answer\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"$ref\": \"#/components/schemas/IShoppingSaleInquiryAnswer.IAbridge\"\n              }\n            ],\n            \"title\": \"Formal answer for the inquiry by the seller\",\n            \"description\": \"Formal answer for the inquiry by the seller.\"\n          },\n          \"read_by_seller\": {\n            \"type\": \"boolean\",\n            \"title\": \"Whether the seller has viewed the inquiry or not\",\n            \"description\": \"Whether the seller has viewed the inquiry or not.\"\n          },\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"title\": \"Primary Key\",\n            \"description\": \"Primary Key.\"\n          },\n          \"title\": {\n            \"type\": \"string\",\n            \"title\": \"Title of the last snapshot\",\n            \"description\": \"Title of the last snapshot.\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"title\": \"Creation time of the article\",\n            \"description\": \"Creation time of the article.\"\n          },\n          \"updated_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"title\": \"Modification time of the article\",\n            \"description\": \"Modification time of the article.\\n\\nIn other words, the time when the last snapshot was created.\"\n          },\n          \"format\": {\n            \"oneOf\": [\n              {\n                \"const\": \"html\"\n              },\n              {\n                \"const\": \"md\"\n              },\n              {\n                \"const\": \"txt\"\n              }\n            ],\n            \"title\": \"Format of body\",\n            \"description\": \"Format of body.\\n\\nSame meaning with extension like `html`, `md`, `txt`.\"\n          },\n          \"body\": {\n            \"type\": \"string\",\n            \"title\": \"Content body of article\",\n            \"description\": \"Content body of article.\"\n          },\n          \"files\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IAttachmentFile.ICreate\"\n            },\n            \"title\": \"List of attachment files\",\n            \"description\": \"List of attachment files.\"\n          }\n        },\n        \"required\": [\n          \"secret\",\n          \"customer\",\n          \"answer\",\n          \"read_by_seller\",\n          \"id\",\n          \"title\",\n          \"created_at\",\n          \"updated_at\",\n          \"format\",\n          \"body\",\n          \"files\"\n        ],\n        \"description\": \"Abridged information of the question.\"\n      },\n      \"IShoppingSaleInquiryAnswer.IAbridge\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"seller\": {\n            \"$ref\": \"#/components/schemas/IShoppingSeller\"\n          },\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"title\": \"Primary Key\",\n            \"description\": \"Primary Key.\"\n          },\n          \"title\": {\n            \"type\": \"string\",\n            \"title\": \"Title of the last snapshot\",\n            \"description\": \"Title of the last snapshot.\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"title\": \"Creation time of the article\",\n            \"description\": \"Creation time of the article.\"\n          },\n          \"updated_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"title\": \"Modification time of the article\",\n            \"description\": \"Modification time of the article.\\n\\nIn other words, the time when the last snapshot was created.\"\n          },\n          \"format\": {\n            \"oneOf\": [\n              {\n                \"const\": \"html\"\n              },\n              {\n                \"const\": \"md\"\n              },\n              {\n                \"const\": \"txt\"\n              }\n            ],\n            \"title\": \"Format of body\",\n            \"description\": \"Format of body.\\n\\nSame meaning with extension like `html`, `md`, `txt`.\"\n          },\n          \"body\": {\n            \"type\": \"string\",\n            \"title\": \"Content body of article\",\n            \"description\": \"Content body of article.\"\n          },\n          \"files\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IAttachmentFile.ICreate\"\n            },\n            \"title\": \"List of attachment files\",\n            \"description\": \"List of attachment files.\"\n          }\n        },\n        \"required\": [\n          \"seller\",\n          \"id\",\n          \"title\",\n          \"created_at\",\n          \"updated_at\",\n          \"format\",\n          \"body\",\n          \"files\"\n        ]\n      },\n      \"IShoppingSaleQuestion\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"secret\": {\n            \"type\": \"boolean\",\n            \"title\": \"Whether the question article is secret or not\",\n            \"description\": \"Whether the question article is secret or not.\\n\\nIf secret article, only the writer customer and related seller can see\\nthe detailed content.\"\n          },\n          \"type\": {\n            \"const\": \"question\",\n            \"title\": \"Type of the derived inquiry\",\n            \"description\": \"Type of the derived inquiry.\\n\\n- `question`: {@link IShoppingSaleQuestion}\\n- `review`: {@link IShoppingSaleReview}\"\n          },\n          \"customer\": {\n            \"$ref\": \"#/components/schemas/IShoppingCustomer\",\n            \"title\": \"Customer who wrote the inquiry\",\n            \"description\": \"Customer who wrote the inquiry.\"\n          },\n          \"answer\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"$ref\": \"#/components/schemas/IShoppingSaleInquiryAnswer\"\n              }\n            ],\n            \"title\": \"Formal answer for the inquiry by the seller\",\n            \"description\": \"Formal answer for the inquiry by the seller.\"\n          },\n          \"read_by_seller\": {\n            \"type\": \"boolean\",\n            \"title\": \"Whether the seller has viewed the inquiry or not\",\n            \"description\": \"Whether the seller has viewed the inquiry or not.\"\n          },\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"title\": \"Primary Key\",\n            \"description\": \"Primary Key.\"\n          },\n          \"snapshots\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IBbsArticle.ISnapshot\"\n            },\n            \"minItems\": 1,\n            \"title\": \"List of snapshot contents\",\n            \"description\": \"List of snapshot contents.\\n\\nIt is created for the first time when an article is created, and is\\naccumulated every time the article is modified.\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"title\": \"Creation time of article\",\n            \"description\": \"Creation time of article.\"\n          }\n        },\n        \"required\": [\n          \"secret\",\n          \"type\",\n          \"customer\",\n          \"answer\",\n          \"read_by_seller\",\n          \"id\",\n          \"snapshots\",\n          \"created_at\"\n        ],\n        \"description\": \"Question about sale snapshot.\\n\\n`IShoppingSaleQuestion` is a subtype entity of {@link IShoppingSaleInquiry},\\nand is used when a {@link IShoppingCustomer customer} wants to ask something\\nabout a {@link IShoppingSale sale} ({@link IShoppingSaleSnapshot snapshot} at\\nthe time) registered by the {@link IShoppingSeller seller}.\\n\\nAnd, like most shopping malls, `IShoppingSaleQuestion` also provides\\na {@link secret} attribute, allowing you to create a \\\"secret message\\\" that can\\nonly be viewed by the seller and the customer who wrote the question.\"\n      },\n      \"IShoppingSaleInquiryAnswer\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"seller\": {\n            \"$ref\": \"#/components/schemas/IShoppingSeller\",\n            \"title\": \"Seller who've written the answer\",\n            \"description\": \"Seller who've written the answer.\"\n          },\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"title\": \"Primary Key\",\n            \"description\": \"Primary Key.\"\n          },\n          \"snapshots\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IBbsArticle.ISnapshot\"\n            },\n            \"minItems\": 1,\n            \"title\": \"List of snapshot contents\",\n            \"description\": \"List of snapshot contents.\\n\\nIt is created for the first time when an article is created, and is\\naccumulated every time the article is modified.\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"title\": \"Creation time of article\",\n            \"description\": \"Creation time of article.\"\n          }\n        },\n        \"required\": [\n          \"seller\",\n          \"id\",\n          \"snapshots\",\n          \"created_at\"\n        ],\n        \"description\": \"Answers to questions about sale snapshots.\\n\\n`IShoppingSaleInquiryAnswer` is an entity that embodies the official\\nanswer written by the {@link IShoppingSeller seller} to the\\n{@link IShoppingSaleInquiry inquiry} written by the\\n{@link IShoppingCustomer customer}.\\n\\nOf course, in addition to writing an official response like this, it is\\nalso possible for the seller to communicate with the inqjuiry written\\ncustomer and multiple customers through\\n{@link IShoppingSaleInquiryComment comments} in the attribution inquiry.\\n\\nFor reference, it is not possible to write comments on this answer.\\nEncourage people to write comments on the inquiry article. This is to\\nprevent comments from being scattered in both inquiry and answer\\narticles.\"\n      },\n      \"IBbsArticle.ISnapshot\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"title\": \"Primary Key\",\n            \"description\": \"Primary Key.\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"title\": \"Creation time of snapshot record\",\n            \"description\": \"Creation time of snapshot record.\\n\\nIn other words, creation time or update time or article.\"\n          },\n          \"format\": {\n            \"oneOf\": [\n              {\n                \"const\": \"html\"\n              },\n              {\n                \"const\": \"md\"\n              },\n              {\n                \"const\": \"txt\"\n              }\n            ],\n            \"title\": \"Format of body\",\n            \"description\": \"Format of body.\\n\\nSame meaning with extension like `html`, `md`, `txt`.\"\n          },\n          \"title\": {\n            \"type\": \"string\",\n            \"title\": \"Title of article\",\n            \"description\": \"Title of article.\"\n          },\n          \"body\": {\n            \"type\": \"string\",\n            \"title\": \"Content body of article\",\n            \"description\": \"Content body of article.\"\n          },\n          \"files\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IAttachmentFile.ICreate\"\n            },\n            \"title\": \"List of attachment files\",\n            \"description\": \"List of attachment files.\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"created_at\",\n          \"format\",\n          \"title\",\n          \"body\",\n          \"files\"\n        ],\n        \"description\": \"Snapshot of article.\\n\\n`IBbsArticle.ISnapshot` is a snapshot entity that contains the contents of\\nthe article, as mentioned in {@link IBbsArticle}, the contents of the article\\nare separated from the article record to keep evidence and prevent fraud.\"\n      },\n      \"IPageIShoppingSaleReview.ISummary\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"pagination\": {\n            \"$ref\": \"#/components/schemas/IPage.IPagination\",\n            \"title\": \"Page information\",\n            \"description\": \"Page information.\"\n          },\n          \"data\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IShoppingSaleReview.ISummary\"\n            },\n            \"title\": \"List of records\",\n            \"description\": \"List of records.\"\n          }\n        },\n        \"required\": [\n          \"pagination\",\n          \"data\"\n        ],\n        \"description\": \"A page.\\n\\nCollection of records with pagination indformation.\"\n      },\n      \"IShoppingSaleReview.ISummary\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"score\": {\n            \"type\": \"number\",\n            \"title\": \"Score of the review\",\n            \"description\": \"Score of the review.\"\n          },\n          \"customer\": {\n            \"$ref\": \"#/components/schemas/IShoppingCustomer\",\n            \"title\": \"Customer who wrote the inquiry\",\n            \"description\": \"Customer who wrote the inquiry.\"\n          },\n          \"answer\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"$ref\": \"#/components/schemas/IShoppingSaleInquiryAnswer.ISummary\"\n              }\n            ],\n            \"title\": \"Formal answer for the inquiry by the seller\",\n            \"description\": \"Formal answer for the inquiry by the seller.\"\n          },\n          \"read_by_seller\": {\n            \"type\": \"boolean\",\n            \"title\": \"Whether the seller has viewed the inquiry or not\",\n            \"description\": \"Whether the seller has viewed the inquiry or not.\"\n          },\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"title\": \"Primary Key\",\n            \"description\": \"Primary Key.\"\n          },\n          \"title\": {\n            \"type\": \"string\",\n            \"title\": \"Title of the last snapshot\",\n            \"description\": \"Title of the last snapshot.\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"title\": \"Creation time of the article\",\n            \"description\": \"Creation time of the article.\"\n          },\n          \"updated_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"title\": \"Modification time of the article\",\n            \"description\": \"Modification time of the article.\\n\\nIn other words, the time when the last snapshot was created.\"\n          }\n        },\n        \"required\": [\n          \"score\",\n          \"customer\",\n          \"answer\",\n          \"read_by_seller\",\n          \"id\",\n          \"title\",\n          \"created_at\",\n          \"updated_at\"\n        ],\n        \"description\": \"Summarized information of the review.\"\n      },\n      \"IShoppingSaleReview.IRequest\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"search\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"$ref\": \"#/components/schemas/IShoppingSaleReview.IRequest.ISearch\"\n              }\n            ],\n            \"title\": \"Search conditions\",\n            \"description\": \"Search conditions.\"\n          },\n          \"sort\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"array\",\n                \"items\": {\n                  \"oneOf\": [\n                    {\n                      \"const\": \"-nickname\"\n                    },\n                    {\n                      \"const\": \"-answered_at\"\n                    },\n                    {\n                      \"const\": \"-created_at\"\n                    },\n                    {\n                      \"const\": \"-updated_at\"\n                    },\n                    {\n                      \"const\": \"-title\"\n                    },\n                    {\n                      \"const\": \"-score\"\n                    },\n                    {\n                      \"const\": \"+nickname\"\n                    },\n                    {\n                      \"const\": \"+answered_at\"\n                    },\n                    {\n                      \"const\": \"+created_at\"\n                    },\n                    {\n                      \"const\": \"+updated_at\"\n                    },\n                    {\n                      \"const\": \"+title\"\n                    },\n                    {\n                      \"const\": \"+score\"\n                    }\n                  ]\n                }\n              }\n            ],\n            \"title\": \"Sorting conditions\",\n            \"description\": \"Sorting conditions.\"\n          },\n          \"page\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"integer\",\n                \"minimum\": 0\n              }\n            ],\n            \"title\": \"Page number\",\n            \"description\": \"Page number.\"\n          },\n          \"limit\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"integer\",\n                \"minimum\": 0\n              }\n            ],\n            \"title\": \"Limitation of records per a page\",\n            \"description\": \"Limitation of records per a page.\"\n          }\n        },\n        \"required\": [],\n        \"description\": \"Request of summarized information with pagination searching/sorting options.\"\n      },\n      \"IShoppingSaleReview.IRequest.ISearch\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"name\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\"\n              }\n            ]\n          },\n          \"nickname\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\"\n              }\n            ]\n          },\n          \"answered\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"boolean\"\n              }\n            ]\n          },\n          \"title\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\"\n              }\n            ]\n          },\n          \"body\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\"\n              }\n            ]\n          },\n          \"title_or_body\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\"\n              }\n            ]\n          },\n          \"from\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\",\n                \"format\": \"date-time\"\n              }\n            ]\n          },\n          \"to\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\",\n                \"format\": \"date-time\"\n              }\n            ]\n          },\n          \"minimum\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"number\",\n                \"minimum\": 0,\n                \"maximum\": 100\n              }\n            ]\n          },\n          \"maximum\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"number\",\n                \"minimum\": 0,\n                \"maximum\": 100\n              }\n            ]\n          }\n        },\n        \"required\": []\n      },\n      \"IPageIShoppingSaleReview.IAbridge\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"pagination\": {\n            \"$ref\": \"#/components/schemas/IPage.IPagination\",\n            \"title\": \"Page information\",\n            \"description\": \"Page information.\"\n          },\n          \"data\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IShoppingSaleReview.IAbridge\"\n            },\n            \"title\": \"List of records\",\n            \"description\": \"List of records.\"\n          }\n        },\n        \"required\": [\n          \"pagination\",\n          \"data\"\n        ],\n        \"description\": \"A page.\\n\\nCollection of records with pagination indformation.\"\n      },\n      \"IShoppingSaleReview.IAbridge\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"score\": {\n            \"type\": \"number\",\n            \"minimum\": 0,\n            \"maximum\": 100,\n            \"title\": \"Score of the review\",\n            \"description\": \"Score of the review.\"\n          },\n          \"customer\": {\n            \"$ref\": \"#/components/schemas/IShoppingCustomer\",\n            \"title\": \"Customer who wrote the inquiry\",\n            \"description\": \"Customer who wrote the inquiry.\"\n          },\n          \"answer\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"$ref\": \"#/components/schemas/IShoppingSaleInquiryAnswer.IAbridge\"\n              }\n            ],\n            \"title\": \"Formal answer for the inquiry by the seller\",\n            \"description\": \"Formal answer for the inquiry by the seller.\"\n          },\n          \"read_by_seller\": {\n            \"type\": \"boolean\",\n            \"title\": \"Whether the seller has viewed the inquiry or not\",\n            \"description\": \"Whether the seller has viewed the inquiry or not.\"\n          },\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"title\": \"Primary Key\",\n            \"description\": \"Primary Key.\"\n          },\n          \"title\": {\n            \"type\": \"string\",\n            \"title\": \"Title of the last snapshot\",\n            \"description\": \"Title of the last snapshot.\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"title\": \"Creation time of the article\",\n            \"description\": \"Creation time of the article.\"\n          },\n          \"updated_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"title\": \"Modification time of the article\",\n            \"description\": \"Modification time of the article.\\n\\nIn other words, the time when the last snapshot was created.\"\n          },\n          \"format\": {\n            \"oneOf\": [\n              {\n                \"const\": \"html\"\n              },\n              {\n                \"const\": \"md\"\n              },\n              {\n                \"const\": \"txt\"\n              }\n            ],\n            \"title\": \"Format of body\",\n            \"description\": \"Format of body.\\n\\nSame meaning with extension like `html`, `md`, `txt`.\"\n          },\n          \"body\": {\n            \"type\": \"string\",\n            \"title\": \"Content body of article\",\n            \"description\": \"Content body of article.\"\n          },\n          \"files\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IAttachmentFile.ICreate\"\n            },\n            \"title\": \"List of attachment files\",\n            \"description\": \"List of attachment files.\"\n          }\n        },\n        \"required\": [\n          \"score\",\n          \"customer\",\n          \"answer\",\n          \"read_by_seller\",\n          \"id\",\n          \"title\",\n          \"created_at\",\n          \"updated_at\",\n          \"format\",\n          \"body\",\n          \"files\"\n        ],\n        \"description\": \"Abridged information of the review.\"\n      },\n      \"IShoppingSaleReview\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"type\": {\n            \"const\": \"review\",\n            \"title\": \"Type of the derived inquiry\",\n            \"description\": \"Type of the derived inquiry.\\n\\n- `question`: {@link IShoppingSaleQuestion}\\n- `review`: {@link IShoppingSaleReview}\"\n          },\n          \"customer\": {\n            \"$ref\": \"#/components/schemas/IShoppingCustomer\",\n            \"title\": \"Customer who wrote the inquiry\",\n            \"description\": \"Customer who wrote the inquiry.\"\n          },\n          \"answer\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"$ref\": \"#/components/schemas/IShoppingSaleInquiryAnswer\"\n              }\n            ],\n            \"title\": \"Formal answer for the inquiry by the seller\",\n            \"description\": \"Formal answer for the inquiry by the seller.\"\n          },\n          \"read_by_seller\": {\n            \"type\": \"boolean\",\n            \"title\": \"Whether the seller has viewed the inquiry or not\",\n            \"description\": \"Whether the seller has viewed the inquiry or not.\"\n          },\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"title\": \"Primary Key\",\n            \"description\": \"Primary Key.\"\n          },\n          \"snapshots\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IShoppingSaleReview.ISnapshot\"\n            },\n            \"minItems\": 1,\n            \"title\": \"List of snapshot contents\",\n            \"description\": \"List of snapshot contents.\\n\\nIt is created for the first time when an article is created, and is\\naccumulated every time the article is modified.\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"title\": \"Creation time of article\",\n            \"description\": \"Creation time of article.\"\n          }\n        },\n        \"required\": [\n          \"type\",\n          \"customer\",\n          \"answer\",\n          \"read_by_seller\",\n          \"id\",\n          \"snapshots\",\n          \"created_at\"\n        ],\n        \"description\": \"Reviews for sale snapshots.\\n\\n`IShoppingSaleReview` is a subtype entity of {@link IShoppingSaleInquiry},\\nand is used when a {@link IShoppingCustomer customer} purchases a\\n{@link IShoppingSale sale} ({@link IShoppingSaleSnapshot snapshot} at the time)\\nregistered by the {@link IShoppingSeller seller} as a product and leaves a\\nreview and rating for it.\\n\\nFor reference, `IShoppingSaleReview` and\\n{@link IShoppingOrderGod shopping_order_goods} have a logarithmic relationship\\nof N: 1, but this does not mean that customers can continue to write reviews\\nfor the same product indefinitely. Wouldn't there be restrictions, such as\\nif you write a review once, you can write an additional review a month later?\"\n      },\n      \"IShoppingSaleReview.ISnapshot\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"score\": {\n            \"type\": \"number\",\n            \"minimum\": 0,\n            \"maximum\": 100,\n            \"title\": \"Score of the review\",\n            \"description\": \"Score of the review.\"\n          },\n          \"id\": {\n            \"type\": \"string\",\n            \"title\": \"Primary Key\",\n            \"description\": \"Primary Key.\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"title\": \"Creation time of snapshot record\",\n            \"description\": \"Creation time of snapshot record.\\n\\nIn other words, creation time or update time or article.\"\n          },\n          \"format\": {\n            \"oneOf\": [\n              {\n                \"const\": \"html\"\n              },\n              {\n                \"const\": \"md\"\n              },\n              {\n                \"const\": \"txt\"\n              }\n            ],\n            \"title\": \"Format of body\",\n            \"description\": \"Format of body.\\n\\nSame meaning with extension like `html`, `md`, `txt`.\"\n          },\n          \"title\": {\n            \"type\": \"string\",\n            \"title\": \"Title of article\",\n            \"description\": \"Title of article.\"\n          },\n          \"body\": {\n            \"type\": \"string\",\n            \"title\": \"Content body of article\",\n            \"description\": \"Content body of article.\"\n          },\n          \"files\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IAttachmentFile.ICreate\"\n            },\n            \"title\": \"List of attachment files\",\n            \"description\": \"List of attachment files.\"\n          }\n        },\n        \"required\": [\n          \"score\",\n          \"id\",\n          \"created_at\",\n          \"format\",\n          \"title\",\n          \"body\",\n          \"files\"\n        ],\n        \"description\": \"Snapshot content of the review article.\"\n      },\n      \"IPageIShoppingSaleSnapshot.ISummary\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"pagination\": {\n            \"$ref\": \"#/components/schemas/IPage.IPagination\",\n            \"title\": \"Page information\",\n            \"description\": \"Page information.\"\n          },\n          \"data\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IShoppingSaleSnapshot.ISummary\"\n            },\n            \"title\": \"List of records\",\n            \"description\": \"List of records.\"\n          }\n        },\n        \"required\": [\n          \"pagination\",\n          \"data\"\n        ],\n        \"description\": \"A page.\\n\\nCollection of records with pagination indformation.\"\n      },\n      \"IShoppingSaleSnapshot.ISummary\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"price_range\": {\n            \"$ref\": \"#/components/schemas/IShoppingSalePriceRange\",\n            \"title\": \"Price range of the unit\",\n            \"description\": \"Price range of the unit.\"\n          },\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"title\": \"Primary Key of Sale\",\n            \"description\": \"Primary Key of Sale.\"\n          },\n          \"snapshot_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"title\": \"Primary Key of Snapshot\",\n            \"description\": \"Primary Key of Snapshot.\"\n          },\n          \"latest\": {\n            \"type\": \"boolean\",\n            \"title\": \"Whether the snapshot is the latest one or not\",\n            \"description\": \"Whether the snapshot is the latest one or not.\"\n          },\n          \"content\": {\n            \"$ref\": \"#/components/schemas/IShoppingSaleContent.IInvert\",\n            \"title\": \"Description and image content describing the sale\",\n            \"description\": \"Description and image content describing the sale.\"\n          },\n          \"categories\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IShoppingChannelCategory.IInvert\"\n            },\n            \"title\": \"List of categories\",\n            \"description\": \"List of categories.\\n\\nWhich categories the sale is registered to.\"\n          },\n          \"tags\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"type\": \"string\"\n            },\n            \"title\": \"List of search tags\",\n            \"description\": \"List of search tags.\"\n          },\n          \"units\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IShoppingSaleUnit.ISummary\"\n            },\n            \"minItems\": 1,\n            \"title\": \"List of units\",\n            \"description\": \"List of units.\\n\\nRecords about individual product composition information that are sold\\nin the sale. Each {@link IShoppingSaleUnit unit} record has configurable\\n{@link IShoppingSaleUnitOption options},\\n{@link IShoppingSaleUnitOptionCandidate candidate} values for each\\noption, and {@link IShoppingSaleUnitStock final stocks} determined by\\nselecting every candidate values of each option.\"\n          }\n        },\n        \"required\": [\n          \"price_range\",\n          \"id\",\n          \"snapshot_id\",\n          \"latest\",\n          \"content\",\n          \"categories\",\n          \"tags\",\n          \"units\"\n        ],\n        \"description\": \"Summarized information of the sale snapshot.\"\n      },\n      \"IPage.IRequest\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"page\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"integer\",\n                \"minimum\": 0\n              }\n            ],\n            \"title\": \"Page number\",\n            \"description\": \"Page number.\"\n          },\n          \"limit\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"integer\",\n                \"minimum\": 0\n              }\n            ],\n            \"title\": \"Limitation of records per a page\",\n            \"description\": \"Limitation of records per a page.\"\n          }\n        },\n        \"required\": [],\n        \"description\": \"Page request data\"\n      },\n      \"IShoppingSaleSnapshot\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"title\": \"Primary Key of Sale\",\n            \"description\": \"Primary Key of Sale.\"\n          },\n          \"snapshot_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"title\": \"Primary Key of Snapshot\",\n            \"description\": \"Primary Key of Snapshot.\"\n          },\n          \"latest\": {\n            \"type\": \"boolean\",\n            \"title\": \"Whether the snapshot is the latest one or not\",\n            \"description\": \"Whether the snapshot is the latest one or not.\"\n          },\n          \"content\": {\n            \"$ref\": \"#/components/schemas/IShoppingSaleContent\",\n            \"title\": \"Description and image content describing the sale\",\n            \"description\": \"Description and image content describing the sale.\"\n          },\n          \"categories\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IShoppingChannelCategory.IInvert\"\n            },\n            \"title\": \"List of categories\",\n            \"description\": \"List of categories.\\n\\nWhich categories the sale is registered to.\"\n          },\n          \"tags\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"type\": \"string\"\n            },\n            \"title\": \"List of search tags\",\n            \"description\": \"List of search tags.\"\n          },\n          \"units\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IShoppingSaleUnit\"\n            },\n            \"minItems\": 1,\n            \"title\": \"List of units\",\n            \"description\": \"List of units.\\n\\nRecords about individual product composition information that are sold\\nin the sale. Each {@link IShoppingSaleUnit unit} record has configurable\\n{@link IShoppingSaleUnitOption options},\\n{@link IShoppingSaleUnitOptionCandidate candidate} values for each\\noption, and {@link IShoppingSaleUnitStock final stocks} determined by\\nselecting every candidate values of each option.\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"snapshot_id\",\n          \"latest\",\n          \"content\",\n          \"categories\",\n          \"tags\",\n          \"units\"\n        ],\n        \"description\": \"Snapshot record of sale.\\n\\n`IShoppingSaleSnapshot` is an entity that embodies a snapshot of a sale,\\nand the ERD (Entity Relationship Diagram) describes the role of the\\n`shopping_sale_snapshots` table as follows:\\n\\n> {@link IShoppingSale shopping_sales} is an entity that embodies\\n> \\\"product sales\\\" (sales) information registered by the\\n> {@link IShoppingSeller seller}. And the main information of the sale is\\n> recorded in the sub `shopping_sale_snapshots`, not in the main\\n> {@link IShoppingSale shopping_sales}. When a seller changes a previously\\n> registered item, the existing {@link IShoppingSale shopping_sales} record\\n> is not changed, but a new snapshot record is created.\\n>\\n> This is to preserve the {@link IShoppingCustomer customer}'s\\n> {@link IShoppingOrder purchase history} flawlessly after the customer\\n> purchases a specific item, even if the seller changes the components or price\\n> of the item. It is also intended to support sellers in so-called A/B testing,\\n> which involves changing components or prices and measuring the performance\\n> in each case.\\n\\nBy the way, DTO (Data Transfer Object) level used by the front-end developer,\\nit does not distinguish {@link IShoppingSale} and `IShoppingSaleSnapshot`\\nstrictly, and generally handles {@link IShoppingSale} and snapshot together.\\n\\nBut even though the DTO level does not strictly distinguish them, the word and\\nconcept of \\\"snapshot\\\" is still important, so it is recommended to understand\\nthe concept of \\\"snapshot\\\" properly.\"\n      },\n      \"IShoppingChannelCategory\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"parent\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"$ref\": \"#/components/schemas/IShoppingChannelCategory.IInvert\"\n              }\n            ],\n            \"title\": \"Parent category info\",\n            \"description\": \"Parent category info.\"\n          },\n          \"children\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IShoppingChannelCategory.IHierarchical\"\n            },\n            \"title\": \"List of children categories with hierarchical structure\",\n            \"description\": \"List of children categories with hierarchical structure.\"\n          },\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"title\": \"Primary Key\",\n            \"description\": \"Primary Key.\"\n          },\n          \"code\": {\n            \"type\": \"string\",\n            \"title\": \"Identifier code of the category\",\n            \"description\": \"Identifier code of the category.\\n\\nThe code must be unique in the channel.\"\n          },\n          \"parent_id\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\",\n                \"format\": \"uuid\"\n              }\n            ],\n            \"title\": \"Parent category's ID\",\n            \"description\": \"Parent category's ID.\"\n          },\n          \"name\": {\n            \"type\": \"string\",\n            \"title\": \"Representative name of the category\",\n            \"description\": \"Representative name of the category.\\n\\nThe name must be unique within the parent category. If no parent exists,\\nthen the name must be unique within the channel between no parent\\ncategories.\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"title\": \"Creation time of record\",\n            \"description\": \"Creation time of record.\"\n          }\n        },\n        \"required\": [\n          \"parent\",\n          \"children\",\n          \"id\",\n          \"code\",\n          \"parent_id\",\n          \"name\",\n          \"created_at\"\n        ],\n        \"description\": \"Category of channel.\\n\\n`IShoppingChannelCategory` is a concept that refers to classification\\ncategories within a specific {@link IShoppingChannel channel}, and is exactly\\nthe same as the concept commonly referred to as \\\"category\\\" in shopping malls.\\n\\nAnd `IShoppingChannelCategory` is different with {@link IShoppingSection}.\\n{@link IShoppingSection} refers to a \\\"corner\\\" that is independent spatial\\ninformation in the offline market, which cannot simultaneously classified in\\na {@link IShoppingSale sale}. Besides, `IShoppingChannelCategory` can be\\nclassified into multiple categories in a sale simultaneously.\\n\\nProduct\\t| Section (corner) | Categories\\n---------|------------------|-----------------------------------\\nBeef\\t    | Butcher corner   | Frozen food, Meat, Favorite food\\nGrape    | Fruit corner     | Fresh food, Favorite food\\n\\nIn addition, as `IShoppingChannelCategory` has 1:N self recursive relationship,\\nit is possible to express below hierarchical structures. Thus, each channel\\ncan set their own category classification as they want.\\n\\n- Food > Meat > Frozen\\n- Electronics > Notebook > 15 inches\\n- Miscellaneous > Wallet\\n\\nFurthermore, `IShoppingChannelCategory` is designed to merge between themselves,\\nso there is no burden to edit the category at any time.\"\n      },\n      \"IShoppingChannelCategory.IHierarchical\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"children\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IShoppingChannelCategory.IHierarchical\"\n            },\n            \"title\": \"List of children categories with hierarchical structure\",\n            \"description\": \"List of children categories with hierarchical structure.\"\n          },\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"title\": \"Primary Key\",\n            \"description\": \"Primary Key.\"\n          },\n          \"code\": {\n            \"type\": \"string\",\n            \"title\": \"Identifier code of the category\",\n            \"description\": \"Identifier code of the category.\\n\\nThe code must be unique in the channel.\"\n          },\n          \"parent_id\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\",\n                \"format\": \"uuid\"\n              }\n            ],\n            \"title\": \"Parent category's ID\",\n            \"description\": \"Parent category's ID.\"\n          },\n          \"name\": {\n            \"type\": \"string\",\n            \"title\": \"Representative name of the category\",\n            \"description\": \"Representative name of the category.\\n\\nThe name must be unique within the parent category. If no parent exists,\\nthen the name must be unique within the channel between no parent\\ncategories.\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"title\": \"Creation time of record\",\n            \"description\": \"Creation time of record.\"\n          }\n        },\n        \"required\": [\n          \"children\",\n          \"id\",\n          \"code\",\n          \"parent_id\",\n          \"name\",\n          \"created_at\"\n        ],\n        \"description\": \"Hierarchical category information with children categories.\"\n      },\n      \"IShoppingChannelCategory.ICreate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"parent_id\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\",\n                \"format\": \"uuid\"\n              }\n            ],\n            \"title\": \"Parent category's ID\",\n            \"description\": \"Parent category's ID.\"\n          },\n          \"code\": {\n            \"type\": \"string\",\n            \"title\": \"Identifier code of the category\",\n            \"description\": \"Identifier code of the category.\\n\\nThe code must be unique in the channel.\"\n          },\n          \"name\": {\n            \"type\": \"string\",\n            \"title\": \"Representative name of the category\",\n            \"description\": \"Representative name of the category.\\n\\nThe name must be unique within the parent category. If no parent exists,\\nthen the name must be unique within the channel between no parent\\ncategories.\"\n          }\n        },\n        \"required\": [\n          \"parent_id\",\n          \"code\",\n          \"name\"\n        ],\n        \"description\": \"Creation information of the category.\"\n      },\n      \"IRecordMerge\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"keep\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"title\": \"Target record to keep after merging\",\n            \"description\": \"Target record to keep after merging.\\n\\nAfter merge process, {@link absorbed} records would be merged into\\nthis {@link keep} record.\"\n          },\n          \"absorbed\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"title\": \"To be absorbed to {@link keep} after merging\",\n            \"description\": \"To be absorbed to {@link keep} after merging.\"\n          }\n        },\n        \"required\": [\n          \"keep\",\n          \"absorbed\"\n        ],\n        \"description\": \"Record Merge DTO.\\n\\n`IRecordMerge` is a structure for merging records.\\n\\nThe `merge` means that merging multiple {@link IRecordMerge.absorbed}\\nrecords into {@link IRecordMerge.keep} instead of deleting\\n{@link IRecordMerge.absorbed} records.\\n\\nIf there're some dependent tables of the target `table` having\\nunique constraint on foreign key column, such dependent tables\\nalso perform the merge process, too.\\n\\nOf course, if there're another dependent tables under those\\ndependents, they also perform the merge process recursively as well.\\nSuch recursive merge process still works for self-recursive\\n(tree-structured) tables.\"\n      },\n      \"IShoppingChannel.ICreate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"code\": {\n            \"type\": \"string\",\n            \"title\": \"Identifier code\",\n            \"description\": \"Identifier code.\"\n          },\n          \"name\": {\n            \"type\": \"string\",\n            \"title\": \"Name of the channel\",\n            \"description\": \"Name of the channel.\"\n          }\n        },\n        \"required\": [\n          \"code\",\n          \"name\"\n        ],\n        \"description\": \"Creation information of the channel.\"\n      },\n      \"IShoppingChannel.IUpdate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"name\": {\n            \"type\": \"string\",\n            \"title\": \"Name of the channel\",\n            \"description\": \"Name of the channel.\"\n          }\n        },\n        \"required\": [\n          \"name\"\n        ],\n        \"description\": \"Updating information of the channel.\"\n      },\n      \"IPageIShoppingChannel\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"pagination\": {\n            \"$ref\": \"#/components/schemas/IPage.IPagination\",\n            \"title\": \"Page information\",\n            \"description\": \"Page information.\"\n          },\n          \"data\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IShoppingChannel\"\n            },\n            \"title\": \"List of records\",\n            \"description\": \"List of records.\"\n          }\n        },\n        \"required\": [\n          \"pagination\",\n          \"data\"\n        ],\n        \"description\": \"A page.\\n\\nCollection of records with pagination indformation.\"\n      },\n      \"IShoppingChannel.IRequest\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"search\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"$ref\": \"#/components/schemas/IShoppingChannel.IRequest.ISearch\"\n              }\n            ]\n          },\n          \"sort\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"array\",\n                \"items\": {\n                  \"oneOf\": [\n                    {\n                      \"const\": \"-channel.code\"\n                    },\n                    {\n                      \"const\": \"-channel.name\"\n                    },\n                    {\n                      \"const\": \"-channel.created_at\"\n                    },\n                    {\n                      \"const\": \"+channel.code\"\n                    },\n                    {\n                      \"const\": \"+channel.name\"\n                    },\n                    {\n                      \"const\": \"+channel.created_at\"\n                    }\n                  ]\n                }\n              }\n            ]\n          },\n          \"page\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"integer\",\n                \"minimum\": 0\n              }\n            ],\n            \"title\": \"Page number\",\n            \"description\": \"Page number.\"\n          },\n          \"limit\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"integer\",\n                \"minimum\": 0\n              }\n            ],\n            \"title\": \"Limitation of records per a page\",\n            \"description\": \"Limitation of records per a page.\"\n          }\n        },\n        \"required\": [],\n        \"description\": \"Request of the channels with pagination and searching/sorting options.\"\n      },\n      \"IShoppingChannel.IRequest.ISearch\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"code\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\"\n              }\n            ]\n          },\n          \"name\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\"\n              }\n            ]\n          }\n        },\n        \"required\": []\n      },\n      \"IPageIShoppingChannel.IHierarchical\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"pagination\": {\n            \"$ref\": \"#/components/schemas/IPage.IPagination\",\n            \"title\": \"Page information\",\n            \"description\": \"Page information.\"\n          },\n          \"data\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IShoppingChannel.IHierarchical\"\n            },\n            \"title\": \"List of records\",\n            \"description\": \"List of records.\"\n          }\n        },\n        \"required\": [\n          \"pagination\",\n          \"data\"\n        ],\n        \"description\": \"A page.\\n\\nCollection of records with pagination indformation.\"\n      },\n      \"IShoppingChannel.IHierarchical\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"categories\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IShoppingChannelCategory.IHierarchical\"\n            },\n            \"title\": \"Children categories with hierarchical structure\",\n            \"description\": \"Children categories with hierarchical structure.\"\n          },\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"title\": \"Primary Key\",\n            \"description\": \"Primary Key.\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"title\": \"Creation time of record\",\n            \"description\": \"Creation time of record.\"\n          },\n          \"code\": {\n            \"type\": \"string\",\n            \"title\": \"Identifier code\",\n            \"description\": \"Identifier code.\"\n          },\n          \"name\": {\n            \"type\": \"string\",\n            \"title\": \"Name of the channel\",\n            \"description\": \"Name of the channel.\"\n          }\n        },\n        \"required\": [\n          \"categories\",\n          \"id\",\n          \"created_at\",\n          \"code\",\n          \"name\"\n        ],\n        \"description\": \"Hierarchical channel information with children categories.\"\n      },\n      \"IShoppingSection.ICreate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"code\": {\n            \"type\": \"string\",\n            \"title\": \"Identifier code\",\n            \"description\": \"Identifier code.\"\n          },\n          \"name\": {\n            \"type\": \"string\",\n            \"title\": \"Representative name of the section\",\n            \"description\": \"Representative name of the section.\"\n          }\n        },\n        \"required\": [\n          \"code\",\n          \"name\"\n        ],\n        \"description\": \"Creation information of the section.\"\n      },\n      \"IShoppingSection.IUpdate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"name\": {\n            \"type\": \"string\",\n            \"title\": \"Representative name of the section\",\n            \"description\": \"Representative name of the section.\"\n          }\n        },\n        \"required\": [\n          \"name\"\n        ],\n        \"description\": \"Updating information of the section.\"\n      },\n      \"IPageIShoppingSection\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"pagination\": {\n            \"$ref\": \"#/components/schemas/IPage.IPagination\",\n            \"title\": \"Page information\",\n            \"description\": \"Page information.\"\n          },\n          \"data\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IShoppingSection\"\n            },\n            \"title\": \"List of records\",\n            \"description\": \"List of records.\"\n          }\n        },\n        \"required\": [\n          \"pagination\",\n          \"data\"\n        ],\n        \"description\": \"A page.\\n\\nCollection of records with pagination indformation.\"\n      },\n      \"IShoppingSection.IRequest\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"search\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"$ref\": \"#/components/schemas/IShoppingSection.IRequest.ISearch\"\n              }\n            ]\n          },\n          \"sort\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"array\",\n                \"items\": {\n                  \"oneOf\": [\n                    {\n                      \"const\": \"-section.code\"\n                    },\n                    {\n                      \"const\": \"-section.name\"\n                    },\n                    {\n                      \"const\": \"-section.created_at\"\n                    },\n                    {\n                      \"const\": \"+section.code\"\n                    },\n                    {\n                      \"const\": \"+section.name\"\n                    },\n                    {\n                      \"const\": \"+section.created_at\"\n                    }\n                  ]\n                }\n              }\n            ]\n          },\n          \"page\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"integer\",\n                \"minimum\": 0\n              }\n            ],\n            \"title\": \"Page number\",\n            \"description\": \"Page number.\"\n          },\n          \"limit\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"integer\",\n                \"minimum\": 0\n              }\n            ],\n            \"title\": \"Limitation of records per a page\",\n            \"description\": \"Limitation of records per a page.\"\n          }\n        },\n        \"required\": [],\n        \"description\": \"Request of the sections with pagination and searching/sorting options.\"\n      },\n      \"IShoppingSection.IRequest.ISearch\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"code\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\"\n              }\n            ]\n          },\n          \"name\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\"\n              }\n            ]\n          }\n        },\n        \"required\": []\n      },\n      \"IShoppingCustomer.IAuthorized\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"setHeaders\": {\n            \"type\": \"object\",\n            \"properties\": {\n              \"Authorization\": {\n                \"type\": \"string\"\n              }\n            },\n            \"required\": [\n              \"Authorization\"\n            ]\n          },\n          \"token\": {\n            \"$ref\": \"#/components/schemas/IShoppingCustomer.IToken\"\n          },\n          \"type\": {\n            \"const\": \"customer\",\n            \"title\": \"Discriminant for the type of customer\",\n            \"description\": \"Discriminant for the type of customer.\"\n          },\n          \"member\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"$ref\": \"#/components/schemas/IShoppingMember\"\n              }\n            ],\n            \"title\": \"Membership information\",\n            \"description\": \"Membership information.\\n\\nIf the customer has joined as a member.\"\n          },\n          \"citizen\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"$ref\": \"#/components/schemas/IShoppingCitizen\"\n              }\n            ],\n            \"title\": \"Citizen information\",\n            \"description\": \"Citizen information.\\n\\nIf the customer has verified his real name and mobile number.\"\n          },\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"title\": \"Primary Key\",\n            \"description\": \"Primary Key.\"\n          },\n          \"channel\": {\n            \"$ref\": \"#/components/schemas/IShoppingChannel\",\n            \"title\": \"Belonged channel\",\n            \"description\": \"Belonged channel.\"\n          },\n          \"external_user\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"$ref\": \"#/components/schemas/IShoppingExternalUser\"\n              }\n            ],\n            \"title\": \"External user information\",\n            \"description\": \"External user information.\\n\\nWhen the customer has come from an external service.\"\n          },\n          \"href\": {\n            \"type\": \"string\",\n            \"format\": \"uri\",\n            \"title\": \"Connection address\",\n            \"description\": \"Connection address.\\n\\nSame with {@link window.location.href} of client.\"\n          },\n          \"referrer\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\",\n                \"format\": \"uri\"\n              },\n              {\n                \"type\": \"string\",\n                \"maxLength\": 0\n              }\n            ],\n            \"title\": \"Referrer address\",\n            \"description\": \"Referrer address.\\n\\nSame with {@link window.document.referrer} of client.\"\n          },\n          \"ip\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"format\": \"ipv4\"\n              },\n              {\n                \"type\": \"string\",\n                \"format\": \"ipv6\"\n              }\n            ],\n            \"title\": \"Connection IP Address\",\n            \"description\": \"Connection IP Address.\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"title\": \"Creation time of the connection record\",\n            \"description\": \"Creation time of the connection record.\"\n          }\n        },\n        \"required\": [\n          \"setHeaders\",\n          \"token\",\n          \"type\",\n          \"member\",\n          \"citizen\",\n          \"id\",\n          \"channel\",\n          \"external_user\",\n          \"href\",\n          \"referrer\",\n          \"ip\",\n          \"created_at\"\n        ]\n      },\n      \"IShoppingCustomer.IToken\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"access\": {\n            \"type\": \"string\"\n          },\n          \"refresh\": {\n            \"type\": \"string\"\n          },\n          \"expired_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\"\n          },\n          \"refreshable_until\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\"\n          }\n        },\n        \"required\": [\n          \"access\",\n          \"refresh\",\n          \"expired_at\",\n          \"refreshable_until\"\n        ]\n      },\n      \"IShoppingCustomer.IRefresh\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"value\": {\n            \"type\": \"string\"\n          }\n        },\n        \"required\": [\n          \"value\"\n        ]\n      },\n      \"IShoppingCustomer.ICreate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"channel_code\": {\n            \"type\": \"string\",\n            \"title\": \"Belonged channel's {@link IShoppingChannel.code}\",\n            \"description\": \"Belonged channel's {@link IShoppingChannel.code}.\"\n          },\n          \"external_user\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"$ref\": \"#/components/schemas/IShoppingExternalUser.ICreate\"\n              }\n            ],\n            \"title\": \"External user information\",\n            \"description\": \"External user information.\\n\\nWhen the customer has come from an external service.\"\n          },\n          \"href\": {\n            \"type\": \"string\",\n            \"format\": \"uri\",\n            \"title\": \"Connection address\",\n            \"description\": \"Connection address.\\n\\nSame with {@link window.location.href} of client.\"\n          },\n          \"referrer\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\",\n                \"format\": \"uri\"\n              },\n              {\n                \"type\": \"string\",\n                \"maxLength\": 0\n              }\n            ],\n            \"title\": \"Referrer address\",\n            \"description\": \"Referrer address.\\n\\nSame with {@link window.document.referrer} of client.\"\n          },\n          \"ip\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\",\n                \"format\": \"ipv4\"\n              },\n              {\n                \"type\": \"string\",\n                \"format\": \"ipv6\"\n              }\n            ],\n            \"title\": \"Connection IP Address\",\n            \"description\": \"Connection IP Address.\"\n          }\n        },\n        \"required\": [\n          \"channel_code\",\n          \"external_user\",\n          \"href\",\n          \"referrer\"\n        ]\n      },\n      \"IShoppingExternalUser.ICreate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"citizen\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"$ref\": \"#/components/schemas/IShoppingCitizen.ICreate\"\n              }\n            ],\n            \"title\": \"Citizen activation info\",\n            \"description\": \"Citizen activation info.\"\n          },\n          \"application\": {\n            \"type\": \"string\",\n            \"title\": \"Identifier code of the external service\",\n            \"description\": \"Identifier code of the external service.\\n\\nIt can be same with {@link IShoppingChannel.code} in common.\"\n          },\n          \"uid\": {\n            \"type\": \"string\",\n            \"title\": \"Identifier key of external user from the external system\",\n            \"description\": \"Identifier key of external user from the external system.\"\n          },\n          \"nickname\": {\n            \"type\": \"string\",\n            \"title\": \"Nickname of external user in the external system\",\n            \"description\": \"Nickname of external user in the external system.\"\n          },\n          \"password\": {\n            \"type\": \"string\",\n            \"title\": \"Password of external user from the external system\",\n            \"description\": \"Password of external user from the external system.\\n\\nThis is a password issued to the user by an external service,\\nand is by no means the actual user password. However, for\\n{@link IShoppingCustomer customers} who entered the same\\napplication and code as the current external system user, this is\\nto determine whether to view this as a correct external system\\nuser or a violation.\"\n          },\n          \"data\": {\n            \"description\": \"Additional information about external user from the external\\nsystem.\"\n          }\n        },\n        \"required\": [\n          \"citizen\",\n          \"application\",\n          \"uid\",\n          \"nickname\",\n          \"password\",\n          \"data\"\n        ],\n        \"description\": \"Creation information of external user.\"\n      },\n      \"IShoppingCitizen.ICreate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"mobile\": {\n            \"type\": \"string\",\n            \"pattern\": \"^[0-9]*$\",\n            \"x-wrtn-payment-order-mobile\": true,\n            \"title\": \"Mobile number\",\n            \"description\": \"Mobile number.\"\n          },\n          \"name\": {\n            \"type\": \"string\",\n            \"x-wrtn-payment-order-citizen\": true,\n            \"title\": \"Real name, or equivalent nickname\",\n            \"description\": \"Real name, or equivalent nickname.\"\n          }\n        },\n        \"required\": [\n          \"mobile\",\n          \"name\"\n        ],\n        \"description\": \"Creation information of citizen verification.\"\n      },\n      \"IShoppingMember.IJoin\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"nickname\": {\n            \"type\": \"string\",\n            \"title\": \"Nickname that uniquely identifies the member\",\n            \"description\": \"Nickname that uniquely identifies the member.\"\n          },\n          \"citizen\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"$ref\": \"#/components/schemas/IShoppingCitizen.ICreate\"\n              }\n            ],\n            \"title\": \"Citizen information\",\n            \"description\": \"Citizen information.\"\n          },\n          \"email\": {\n            \"type\": \"string\",\n            \"format\": \"email\",\n            \"title\": \"Email address of member\",\n            \"description\": \"Email address of member.\\n\\nIf the member has multiple email addresses, just use one of them.\"\n          },\n          \"password\": {\n            \"type\": \"string\",\n            \"title\": \"Password of the member account\",\n            \"description\": \"Password of the member account.\"\n          }\n        },\n        \"required\": [\n          \"nickname\",\n          \"citizen\",\n          \"email\",\n          \"password\"\n        ],\n        \"description\": \"Joining request info.\"\n      },\n      \"IShoppingMember.IPasswordChange\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"oldbie\": {\n            \"type\": \"string\",\n            \"title\": \"Current password\",\n            \"description\": \"Current password.\"\n          },\n          \"newbie\": {\n            \"type\": \"string\",\n            \"title\": \"The new password to change\",\n            \"description\": \"The new password to change.\"\n          }\n        },\n        \"required\": [\n          \"oldbie\",\n          \"newbie\"\n        ],\n        \"description\": \"Request info of password change.\"\n      },\n      \"IPageIShoppingCouponTicket\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"pagination\": {\n            \"$ref\": \"#/components/schemas/IPage.IPagination\",\n            \"title\": \"Page information\",\n            \"description\": \"Page information.\"\n          },\n          \"data\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IShoppingCouponTicket\"\n            },\n            \"title\": \"List of records\",\n            \"description\": \"List of records.\"\n          }\n        },\n        \"required\": [\n          \"pagination\",\n          \"data\"\n        ],\n        \"description\": \"A page.\\n\\nCollection of records with pagination indformation.\"\n      },\n      \"IShoppingCouponTicket.IRequest\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"sort\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"array\",\n                \"items\": {\n                  \"oneOf\": [\n                    {\n                      \"const\": \"-ticket.created_at\"\n                    },\n                    {\n                      \"const\": \"-ticket.expired_at\"\n                    },\n                    {\n                      \"const\": \"+ticket.created_at\"\n                    },\n                    {\n                      \"const\": \"+ticket.expired_at\"\n                    }\n                  ]\n                }\n              }\n            ]\n          },\n          \"page\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"integer\",\n                \"minimum\": 0\n              }\n            ],\n            \"title\": \"Page number\",\n            \"description\": \"Page number.\"\n          },\n          \"limit\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"integer\",\n                \"minimum\": 0\n              }\n            ],\n            \"title\": \"Limitation of records per a page\",\n            \"description\": \"Limitation of records per a page.\"\n          }\n        },\n        \"required\": []\n      },\n      \"IShoppingCouponTicket.ICreate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"coupon_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\"\n          }\n        },\n        \"required\": [\n          \"coupon_id\"\n        ]\n      },\n      \"IPageIShoppingDepositCharge\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"pagination\": {\n            \"$ref\": \"#/components/schemas/IPage.IPagination\",\n            \"title\": \"Page information\",\n            \"description\": \"Page information.\"\n          },\n          \"data\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IShoppingDepositCharge\"\n            },\n            \"title\": \"List of records\",\n            \"description\": \"List of records.\"\n          }\n        },\n        \"required\": [\n          \"pagination\",\n          \"data\"\n        ],\n        \"description\": \"A page.\\n\\nCollection of records with pagination indformation.\"\n      },\n      \"IShoppingDepositCharge\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\"\n          },\n          \"customer\": {\n            \"$ref\": \"#/components/schemas/IShoppingCustomer\"\n          },\n          \"publish\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"$ref\": \"#/components/schemas/IShoppingDepositChargePublish\"\n              }\n            ]\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\"\n          },\n          \"value\": {\n            \"type\": \"number\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"customer\",\n          \"publish\",\n          \"created_at\",\n          \"value\"\n        ]\n      },\n      \"IShoppingDepositChargePublish\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\"\n          },\n          \"paid_at\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\",\n                \"format\": \"date-time\"\n              }\n            ]\n          },\n          \"cancelled_at\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\",\n                \"format\": \"date-time\"\n              }\n            ]\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"created_at\",\n          \"paid_at\",\n          \"cancelled_at\"\n        ]\n      },\n      \"IShoppingDepositCharge.IRequest\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"search\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"$ref\": \"#/components/schemas/IShoppingDepositCharge.IRequest.ISearch\"\n              }\n            ]\n          },\n          \"sort\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"array\",\n                \"items\": {\n                  \"oneOf\": [\n                    {\n                      \"const\": \"-created_at\"\n                    },\n                    {\n                      \"const\": \"+created_at\"\n                    },\n                    {\n                      \"const\": \"-value\"\n                    },\n                    {\n                      \"const\": \"-publish.created_at\"\n                    },\n                    {\n                      \"const\": \"-publish.paid_at\"\n                    },\n                    {\n                      \"const\": \"+value\"\n                    },\n                    {\n                      \"const\": \"+publish.created_at\"\n                    },\n                    {\n                      \"const\": \"+publish.paid_at\"\n                    }\n                  ]\n                }\n              }\n            ]\n          },\n          \"page\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"integer\",\n                \"minimum\": 0\n              }\n            ],\n            \"title\": \"Page number\",\n            \"description\": \"Page number.\"\n          },\n          \"limit\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"integer\",\n                \"minimum\": 0\n              }\n            ],\n            \"title\": \"Limitation of records per a page\",\n            \"description\": \"Limitation of records per a page.\"\n          }\n        },\n        \"required\": []\n      },\n      \"IShoppingDepositCharge.IRequest.ISearch\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"from\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\",\n                \"format\": \"date-time\"\n              }\n            ]\n          },\n          \"to\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\",\n                \"format\": \"date-time\"\n              }\n            ]\n          },\n          \"minimum\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"number\"\n              }\n            ]\n          },\n          \"maximum\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"number\"\n              }\n            ]\n          },\n          \"state\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"const\": \"paid\"\n              },\n              {\n                \"const\": \"published\"\n              },\n              {\n                \"const\": \"pending\"\n              },\n              {\n                \"const\": \"cancelled\"\n              }\n            ]\n          },\n          \"publish\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"object\",\n                \"properties\": {\n                  \"from\": {\n                    \"oneOf\": [\n                      {\n                        \"type\": \"null\"\n                      },\n                      {\n                        \"type\": \"string\",\n                        \"format\": \"date-time\"\n                      }\n                    ]\n                  },\n                  \"to\": {\n                    \"oneOf\": [\n                      {\n                        \"type\": \"null\"\n                      },\n                      {\n                        \"type\": \"string\",\n                        \"format\": \"date-time\"\n                      }\n                    ]\n                  },\n                  \"payment\": {\n                    \"oneOf\": [\n                      {\n                        \"type\": \"null\"\n                      },\n                      {\n                        \"type\": \"object\",\n                        \"properties\": {\n                          \"from\": {\n                            \"oneOf\": [\n                              {\n                                \"type\": \"null\"\n                              },\n                              {\n                                \"type\": \"string\",\n                                \"format\": \"date-time\"\n                              }\n                            ]\n                          },\n                          \"to\": {\n                            \"oneOf\": [\n                              {\n                                \"type\": \"null\"\n                              },\n                              {\n                                \"type\": \"string\",\n                                \"format\": \"date-time\"\n                              }\n                            ]\n                          }\n                        },\n                        \"required\": []\n                      }\n                    ]\n                  }\n                },\n                \"required\": []\n              }\n            ]\n          }\n        },\n        \"required\": [\n          \"state\"\n        ]\n      },\n      \"IShoppingDepositCharge.ICreate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"value\": {\n            \"type\": \"number\"\n          }\n        },\n        \"required\": [\n          \"value\"\n        ]\n      },\n      \"IShoppingDepositChargePublish.ICreate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"vendor\": {\n            \"type\": \"string\"\n          },\n          \"uid\": {\n            \"type\": \"string\"\n          }\n        },\n        \"required\": [\n          \"vendor\",\n          \"uid\"\n        ]\n      },\n      \"IPageIShoppingDepositHistory\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"pagination\": {\n            \"$ref\": \"#/components/schemas/IPage.IPagination\",\n            \"title\": \"Page information\",\n            \"description\": \"Page information.\"\n          },\n          \"data\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IShoppingDepositHistory\"\n            },\n            \"title\": \"List of records\",\n            \"description\": \"List of records.\"\n          }\n        },\n        \"required\": [\n          \"pagination\",\n          \"data\"\n        ],\n        \"description\": \"A page.\\n\\nCollection of records with pagination indformation.\"\n      },\n      \"IShoppingDepositHistory\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\"\n          },\n          \"citizen\": {\n            \"$ref\": \"#/components/schemas/IShoppingCitizen\"\n          },\n          \"deposit\": {\n            \"$ref\": \"#/components/schemas/IShoppingDeposit\"\n          },\n          \"source_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\"\n          },\n          \"value\": {\n            \"type\": \"number\"\n          },\n          \"balance\": {\n            \"type\": \"number\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"citizen\",\n          \"deposit\",\n          \"source_id\",\n          \"value\",\n          \"balance\",\n          \"created_at\"\n        ]\n      },\n      \"IShoppingDepositHistory.IRequest\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"search\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"$ref\": \"#/components/schemas/IShoppingDepositHistory.IRequest.ISearch\"\n              }\n            ]\n          },\n          \"sort\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"array\",\n                \"items\": {\n                  \"oneOf\": [\n                    {\n                      \"const\": \"-deposit.source\"\n                    },\n                    {\n                      \"const\": \"-deposit.code\"\n                    },\n                    {\n                      \"const\": \"-deposit.direction\"\n                    },\n                    {\n                      \"const\": \"+deposit.source\"\n                    },\n                    {\n                      \"const\": \"+deposit.code\"\n                    },\n                    {\n                      \"const\": \"+deposit.direction\"\n                    },\n                    {\n                      \"const\": \"-history.value\"\n                    },\n                    {\n                      \"const\": \"-history.created_at\"\n                    },\n                    {\n                      \"const\": \"+history.value\"\n                    },\n                    {\n                      \"const\": \"+history.created_at\"\n                    }\n                  ]\n                }\n              }\n            ]\n          },\n          \"page\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"integer\",\n                \"minimum\": 0\n              }\n            ],\n            \"title\": \"Page number\",\n            \"description\": \"Page number.\"\n          },\n          \"limit\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"integer\",\n                \"minimum\": 0\n              }\n            ],\n            \"title\": \"Limitation of records per a page\",\n            \"description\": \"Limitation of records per a page.\"\n          }\n        },\n        \"required\": []\n      },\n      \"IShoppingDepositHistory.IRequest.ISearch\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"deposit\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"$ref\": \"#/components/schemas/IShoppingDeposit.IRequest.ISearch\"\n              }\n            ]\n          },\n          \"citizen_id\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\",\n                \"format\": \"uuid\"\n              }\n            ]\n          },\n          \"from\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\",\n                \"format\": \"date-time\"\n              }\n            ]\n          },\n          \"to\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\",\n                \"format\": \"date-time\"\n              }\n            ]\n          },\n          \"minimum\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"number\",\n                \"minimum\": 0\n              }\n            ]\n          },\n          \"maximum\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"number\",\n                \"minimum\": 0\n              }\n            ]\n          }\n        },\n        \"required\": []\n      },\n      \"IPageIShoppingMileageHistory\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"pagination\": {\n            \"$ref\": \"#/components/schemas/IPage.IPagination\",\n            \"title\": \"Page information\",\n            \"description\": \"Page information.\"\n          },\n          \"data\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IShoppingMileageHistory\"\n            },\n            \"title\": \"List of records\",\n            \"description\": \"List of records.\"\n          }\n        },\n        \"required\": [\n          \"pagination\",\n          \"data\"\n        ],\n        \"description\": \"A page.\\n\\nCollection of records with pagination indformation.\"\n      },\n      \"IShoppingMileageHistory\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\"\n          },\n          \"citizen\": {\n            \"$ref\": \"#/components/schemas/IShoppingCitizen\"\n          },\n          \"mileage\": {\n            \"$ref\": \"#/components/schemas/IShoppingMileage\"\n          },\n          \"source_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\"\n          },\n          \"value\": {\n            \"type\": \"number\"\n          },\n          \"balance\": {\n            \"type\": \"number\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"citizen\",\n          \"mileage\",\n          \"source_id\",\n          \"value\",\n          \"balance\",\n          \"created_at\"\n        ]\n      },\n      \"IShoppingMileageHistory.IRequest\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"search\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"$ref\": \"#/components/schemas/IShoppingMileageHistory.IRequest.ISearch\"\n              }\n            ]\n          },\n          \"sort\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"array\",\n                \"items\": {\n                  \"oneOf\": [\n                    {\n                      \"const\": \"-mileage.source\"\n                    },\n                    {\n                      \"const\": \"-mileage.code\"\n                    },\n                    {\n                      \"const\": \"-mileage.direction\"\n                    },\n                    {\n                      \"const\": \"+mileage.source\"\n                    },\n                    {\n                      \"const\": \"+mileage.code\"\n                    },\n                    {\n                      \"const\": \"+mileage.direction\"\n                    },\n                    {\n                      \"const\": \"-history.value\"\n                    },\n                    {\n                      \"const\": \"-history.created_at\"\n                    },\n                    {\n                      \"const\": \"+history.value\"\n                    },\n                    {\n                      \"const\": \"+history.created_at\"\n                    }\n                  ]\n                }\n              }\n            ]\n          },\n          \"page\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"integer\",\n                \"minimum\": 0\n              }\n            ],\n            \"title\": \"Page number\",\n            \"description\": \"Page number.\"\n          },\n          \"limit\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"integer\",\n                \"minimum\": 0\n              }\n            ],\n            \"title\": \"Limitation of records per a page\",\n            \"description\": \"Limitation of records per a page.\"\n          }\n        },\n        \"required\": []\n      },\n      \"IShoppingMileageHistory.IRequest.ISearch\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"mileage\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"$ref\": \"#/components/schemas/IShoppingMileage.IRequest.ISearch\"\n              }\n            ]\n          },\n          \"citizen_id\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\",\n                \"format\": \"uuid\"\n              }\n            ]\n          },\n          \"from\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\",\n                \"format\": \"date-time\"\n              }\n            ]\n          },\n          \"to\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\",\n                \"format\": \"date-time\"\n              }\n            ]\n          },\n          \"minimum\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"number\",\n                \"minimum\": 0\n              }\n            ]\n          },\n          \"maximum\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"number\",\n                \"minimum\": 0\n              }\n            ]\n          }\n        },\n        \"required\": []\n      },\n      \"IPageIShoppingCartCommodity\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"pagination\": {\n            \"$ref\": \"#/components/schemas/IPage.IPagination\",\n            \"title\": \"Page information\",\n            \"description\": \"Page information.\"\n          },\n          \"data\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IShoppingCartCommodity\"\n            },\n            \"title\": \"List of records\",\n            \"description\": \"List of records.\"\n          }\n        },\n        \"required\": [\n          \"pagination\",\n          \"data\"\n        ],\n        \"description\": \"A page.\\n\\nCollection of records with pagination indformation.\"\n      },\n      \"IShoppingCartCommodity.IRequest\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"search\": {\n            \"$ref\": \"#/components/schemas/IShoppingCartCommodity.IRequest.ISearch\"\n          },\n          \"sort\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"oneOf\": [\n                {\n                  \"const\": \"-seller.created_at\"\n                },\n                {\n                  \"const\": \"-seller.goods.payments.real\"\n                },\n                {\n                  \"const\": \"-seller.goods.publish_count\"\n                },\n                {\n                  \"const\": \"-seller.reviews.average\"\n                },\n                {\n                  \"const\": \"-seller.reviews.count\"\n                },\n                {\n                  \"const\": \"-goods.publish_count\"\n                },\n                {\n                  \"const\": \"-goods.payments.real\"\n                },\n                {\n                  \"const\": \"-reviews.average\"\n                },\n                {\n                  \"const\": \"-reviews.count\"\n                },\n                {\n                  \"const\": \"-sale.created_at\"\n                },\n                {\n                  \"const\": \"-sale.updated_at\"\n                },\n                {\n                  \"const\": \"-sale.opened_at\"\n                },\n                {\n                  \"const\": \"-sale.closed_at\"\n                },\n                {\n                  \"const\": \"-sale.content.title\"\n                },\n                {\n                  \"const\": \"-sale.price_range.lowest.real\"\n                },\n                {\n                  \"const\": \"-sale.price_range.highest.real\"\n                },\n                {\n                  \"const\": \"+seller.created_at\"\n                },\n                {\n                  \"const\": \"+seller.goods.payments.real\"\n                },\n                {\n                  \"const\": \"+seller.goods.publish_count\"\n                },\n                {\n                  \"const\": \"+seller.reviews.average\"\n                },\n                {\n                  \"const\": \"+seller.reviews.count\"\n                },\n                {\n                  \"const\": \"+goods.publish_count\"\n                },\n                {\n                  \"const\": \"+goods.payments.real\"\n                },\n                {\n                  \"const\": \"+reviews.average\"\n                },\n                {\n                  \"const\": \"+reviews.count\"\n                },\n                {\n                  \"const\": \"+sale.created_at\"\n                },\n                {\n                  \"const\": \"+sale.updated_at\"\n                },\n                {\n                  \"const\": \"+sale.opened_at\"\n                },\n                {\n                  \"const\": \"+sale.closed_at\"\n                },\n                {\n                  \"const\": \"+sale.content.title\"\n                },\n                {\n                  \"const\": \"+sale.price_range.lowest.real\"\n                },\n                {\n                  \"const\": \"+sale.price_range.highest.real\"\n                },\n                {\n                  \"const\": \"-commodity.price\"\n                },\n                {\n                  \"const\": \"-commodity.volume\"\n                },\n                {\n                  \"const\": \"-commodity.volumed_price\"\n                },\n                {\n                  \"const\": \"-commodity.created_at\"\n                },\n                {\n                  \"const\": \"+commodity.price\"\n                },\n                {\n                  \"const\": \"+commodity.volume\"\n                },\n                {\n                  \"const\": \"+commodity.volumed_price\"\n                },\n                {\n                  \"const\": \"+commodity.created_at\"\n                }\n              ]\n            }\n          },\n          \"page\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"integer\",\n                \"minimum\": 0\n              }\n            ],\n            \"title\": \"Page number\",\n            \"description\": \"Page number.\"\n          },\n          \"limit\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"integer\",\n                \"minimum\": 0\n              }\n            ],\n            \"title\": \"Limitation of records per a page\",\n            \"description\": \"Limitation of records per a page.\"\n          }\n        },\n        \"required\": []\n      },\n      \"IShoppingCartCommodity.IRequest.ISearch\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"min_price\": {\n            \"type\": \"number\"\n          },\n          \"max_price\": {\n            \"type\": \"number\"\n          },\n          \"min_volumed_price\": {\n            \"type\": \"number\"\n          },\n          \"max_volumed_price\": {\n            \"type\": \"number\"\n          },\n          \"sale\": {\n            \"$ref\": \"#/components/schemas/IShoppingSale.IRequest.ISearch\"\n          }\n        },\n        \"required\": []\n      },\n      \"IShoppingCartCommodity.ICreate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"sale_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"title\": \"Target sale's {@link IShoppingSale.id}\",\n            \"description\": \"Target sale's {@link IShoppingSale.id}.\"\n          },\n          \"stocks\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IShoppingCartCommodityStock.ICreate\"\n            },\n            \"minItems\": 1,\n            \"title\": \"List of the stocks to be purchased\",\n            \"description\": \"List of the stocks to be purchased.\"\n          },\n          \"volume\": {\n            \"type\": \"integer\",\n            \"minimum\": 1,\n            \"title\": \"Volume of the commodity to purchase\",\n            \"description\": \"Volume of the commodity to purchase.\\n\\nA value indicating how many sets would be multiplied to the children\\n{@link IShoppingSaleUnitStock.IInvert.quantity} values.\"\n          },\n          \"accumulate\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"boolean\"\n              }\n            ],\n            \"title\": \"Whether to accumulate the volume or not\",\n            \"description\": \"Whether to accumulate the volume or not.\\n\\nIf this attribute is not `false` and there's same commodity that\\ncomposed with same stocks and options, then the volume will be\\naccumulated to the existed one.\\n\\nOtherwise, duplicated commodity would be newly created.\"\n          }\n        },\n        \"required\": [\n          \"sale_id\",\n          \"stocks\",\n          \"volume\"\n        ],\n        \"description\": \"Creation information of a shopping cart commodity.\"\n      },\n      \"IShoppingCartCommodityStock.ICreate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"unit_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"title\": \"Target unit's {@link IShoppingSaleUnit.id}\",\n            \"description\": \"Target unit's {@link IShoppingSaleUnit.id}.\"\n          },\n          \"stock_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"title\": \"Target stock's {@link IShoppingSaleUnitStock.id}\",\n            \"description\": \"Target stock's {@link IShoppingSaleUnitStock.id}.\\n\\nIt must be matched with the {@link choices} property.\"\n          },\n          \"choices\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IShoppingCartCommodityStockChoice.ICreate\"\n            },\n            \"title\": \"Creation information of the choices for each descriptive option\",\n            \"description\": \"Creation information of the choices for each descriptive option.\\n\\nIf target option is not of descriptive but of selective, then\\nthis property must be an empty array.\"\n          },\n          \"quantity\": {\n            \"type\": \"integer\",\n            \"minimum\": 1,\n            \"title\": \"Quantity of the stock to purchase\",\n            \"description\": \"Quantity of the stock to purchase.\\n\\nThis value is multiplied by the {@link IShoppingCartCommodity.volume}.\"\n          }\n        },\n        \"required\": [\n          \"unit_id\",\n          \"stock_id\",\n          \"choices\",\n          \"quantity\"\n        ],\n        \"description\": \"Creation information of the commodity stock of shopping cart.\\n\\nWhen record being created, its corresponding structure would be\\n{@link IShoppingSaleSnapshotUnit.IInvert} and\\n{@link IShoppingSaleSnapshotUnitStock.IInvert}.\"\n      },\n      \"IShoppingCartCommodityStockChoice.ICreate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"option_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"title\": \"Target option's {@link IShoppingSaleUnitOption.id}\",\n            \"description\": \"Target option's {@link IShoppingSaleUnitOption.id}.\"\n          },\n          \"value\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\"\n              },\n              {\n                \"type\": \"number\"\n              },\n              {\n                \"type\": \"boolean\"\n              }\n            ],\n            \"title\": \"Written value about the option\",\n            \"description\": \"Written value about the option.\\n\\nWhen target option's type is 'descriptive', then you have to\\nfill this property with the written value by the customer.\"\n          }\n        },\n        \"required\": [\n          \"option_id\",\n          \"value\"\n        ],\n        \"description\": \"Creation information of the choice for each option (of descriptive).\\n\\nWhen target option is {@link IShoppingSaleUnitDescriptiveOption}\\ntype, then you have to compose this choice structure with\\n{@link value} specification.\\n\\nOtherwise when target option is {@link IShoppingSaleUnitSelectableOption}\\ntype, you don't need to compose this choice structure. Just fill only\\nthe {@link IShoppingCartCommodityStock.ICreate.stock_id} property.\"\n      },\n      \"IShoppingCartCommodity.IUpdate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"volume\": {\n            \"type\": \"integer\",\n            \"minimum\": 1,\n            \"title\": \"Volume of the commodity to purchase\",\n            \"description\": \"Volume of the commodity to purchase.\\n\\nA value indicating how many sets would be multiplied to the children\\n{@link IShoppingSaleUnitStock.IInvert.quantity} values.\"\n          }\n        },\n        \"required\": [\n          \"volume\"\n        ],\n        \"description\": \"Update information of a shopping cart commodity.\"\n      },\n      \"IShoppingCartDiscountable\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"deposit\": {\n            \"type\": \"number\"\n          },\n          \"mileage\": {\n            \"type\": \"number\"\n          },\n          \"combinations\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IShoppingCartDiscountable.ICombination\"\n            }\n          }\n        },\n        \"required\": [\n          \"deposit\",\n          \"mileage\",\n          \"combinations\"\n        ]\n      },\n      \"IShoppingCartDiscountable.ICombination\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"coupons\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IShoppingCoupon\"\n            }\n          },\n          \"tickets\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IShoppingCouponTicket\"\n            }\n          },\n          \"entries\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IShoppingCartDiscountable.IEntry\"\n            }\n          },\n          \"amount\": {\n            \"type\": \"number\"\n          }\n        },\n        \"required\": [\n          \"coupons\",\n          \"tickets\",\n          \"entries\",\n          \"amount\"\n        ]\n      },\n      \"IShoppingCartDiscountable.IEntry\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"commodity_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\"\n          },\n          \"pseudo\": {\n            \"type\": \"boolean\"\n          },\n          \"coupon_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\"\n          },\n          \"amount\": {\n            \"type\": \"number\"\n          }\n        },\n        \"required\": [\n          \"commodity_id\",\n          \"pseudo\",\n          \"coupon_id\",\n          \"amount\"\n        ]\n      },\n      \"IShoppingCartDiscountable.IRequest\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"commodity_ids\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"array\",\n                \"items\": {\n                  \"type\": \"string\",\n                  \"format\": \"uuid\"\n                }\n              }\n            ]\n          },\n          \"pseudos\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IShoppingCartCommodity.ICreate\"\n            }\n          }\n        },\n        \"required\": [\n          \"commodity_ids\",\n          \"pseudos\"\n        ]\n      },\n      \"IShoppingOrder.ICreate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"goods\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IShoppingOrderGood.ICreate\"\n            },\n            \"minItems\": 1,\n            \"title\": \"List of goods in the order\",\n            \"description\": \"List of goods in the order.\"\n          },\n          \"name\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\"\n              }\n            ],\n            \"title\": \"Representative name of the order\",\n            \"description\": \"Representative name of the order.\\n\\nIf omit, the name will be generated automatically.\"\n          }\n        },\n        \"required\": [\n          \"goods\"\n        ],\n        \"description\": \"Creation information of the order appliance.\"\n      },\n      \"IShoppingOrderGood.ICreate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"commodity_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"title\": \"Target shopping cart commodity's {@link IShoppingCartCommodity.id}\",\n            \"description\": \"Target shopping cart commodity's {@link IShoppingCartCommodity.id}.\\n\\n`commodity_id` is the primary key of the {@link IShoppingCartCommodity}\\nentity, which is the basis of the good to be created. In other words,\\nit is the primary key of the shopping cart commodity that the customer\\nhas selected and applied for the order.\"\n          },\n          \"volume\": {\n            \"type\": \"integer\",\n            \"minimum\": 0,\n            \"title\": \"Volume of the good\",\n            \"description\": \"Volume of the good.\\n\\nThe value multiplied to {@link IShoppingCartCommodityStock.quantity}.\\nIt's purpose is exactly same with {@link IShoppingCartCommodity.volume},\\nbut rewritten because the {@link IShoppingCartCommodity} records are reusable\\nuntil payment.\"\n          }\n        },\n        \"required\": [\n          \"commodity_id\",\n          \"volume\"\n        ],\n        \"description\": \"Creation information of the good.\"\n      },\n      \"IShoppingOrderDiscountable\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"deposit\": {\n            \"type\": \"number\"\n          },\n          \"mileage\": {\n            \"type\": \"number\"\n          },\n          \"combinations\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IShoppingOrderDiscountable.ICombination\"\n            }\n          }\n        },\n        \"required\": [\n          \"deposit\",\n          \"mileage\",\n          \"combinations\"\n        ]\n      },\n      \"IShoppingOrderDiscountable.ICombination\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"coupons\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IShoppingCoupon\"\n            }\n          },\n          \"tickets\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IShoppingCouponTicket\"\n            }\n          },\n          \"entries\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IShoppingOrderDiscountable.IEntry\"\n            }\n          },\n          \"amount\": {\n            \"type\": \"number\"\n          }\n        },\n        \"required\": [\n          \"coupons\",\n          \"tickets\",\n          \"entries\",\n          \"amount\"\n        ]\n      },\n      \"IShoppingOrderDiscountable.IEntry\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"good_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\"\n          },\n          \"coupon_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\"\n          },\n          \"amount\": {\n            \"type\": \"number\"\n          }\n        },\n        \"required\": [\n          \"good_id\",\n          \"coupon_id\",\n          \"amount\"\n        ]\n      },\n      \"IShoppingOrderDiscountable.IRequest\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"good_ids\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"array\",\n                \"items\": {\n                  \"type\": \"string\",\n                  \"format\": \"uuid\"\n                }\n              }\n            ]\n          }\n        },\n        \"required\": [\n          \"good_ids\"\n        ]\n      },\n      \"IShoppingOrderPrice.ICreate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"deposit\": {\n            \"type\": \"number\"\n          },\n          \"mileage\": {\n            \"type\": \"number\"\n          },\n          \"coupon_ids\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            }\n          }\n        },\n        \"required\": [\n          \"deposit\",\n          \"mileage\",\n          \"coupon_ids\"\n        ]\n      },\n      \"IShoppingOrderPublish.ICreate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"address\": {\n            \"$ref\": \"#/components/schemas/IShoppingAddress.ICreate\",\n            \"title\": \"Address to receive\",\n            \"description\": \"Address to receive.\"\n          },\n          \"vendor\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"$ref\": \"#/components/schemas/IShoppingOrderPublish.IPaymentIdentifier\"\n              }\n            ],\n            \"title\": \"Payment identifier from the payment vendor service\",\n            \"description\": \"Payment identifier from the payment vendor service.\\n\\nIf the order has been discounted for entire order price, then no need\\nto send payment vendor info. Instead, you just configure the `null`\\nvalue to this property.\"\n          }\n        },\n        \"required\": [\n          \"address\",\n          \"vendor\"\n        ],\n        \"description\": \"Creation info of the publish.\"\n      },\n      \"IShoppingAddress.ICreate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"mobile\": {\n            \"type\": \"string\",\n            \"pattern\": \"^[0-9]*$\",\n            \"title\": \"Mobile number to contact\",\n            \"description\": \"Mobile number to contact.\"\n          },\n          \"name\": {\n            \"type\": \"string\",\n            \"title\": \"Representative name of the address\",\n            \"description\": \"Representative name of the address.\\n\\nSometimes be receiver's name, and sometimes be place name.\"\n          },\n          \"country\": {\n            \"type\": \"string\",\n            \"title\": \"Country name\",\n            \"description\": \"Country name.\"\n          },\n          \"province\": {\n            \"type\": \"string\",\n            \"title\": \"Province name\",\n            \"description\": \"Province name.\"\n          },\n          \"city\": {\n            \"type\": \"string\",\n            \"title\": \"City name\",\n            \"description\": \"City name.\"\n          },\n          \"department\": {\n            \"type\": \"string\",\n            \"title\": \"Department name\",\n            \"description\": \"Department name.\"\n          },\n          \"possession\": {\n            \"type\": \"string\",\n            \"title\": \"Detailed address containing street name, building number, and room number\",\n            \"description\": \"Detailed address containing street name, building number, and room number.\"\n          },\n          \"zip_code\": {\n            \"type\": \"string\",\n            \"title\": \"Zip code, or postal code\",\n            \"description\": \"Zip code, or postal code.\"\n          },\n          \"special_note\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\"\n              }\n            ],\n            \"title\": \"Special description if required\",\n            \"description\": \"Special description if required.\"\n          }\n        },\n        \"required\": [\n          \"mobile\",\n          \"name\",\n          \"country\",\n          \"province\",\n          \"city\",\n          \"department\",\n          \"possession\",\n          \"zip_code\",\n          \"special_note\"\n        ]\n      },\n      \"IShoppingOrderPublish.IPaymentIdentifier\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"code\": {\n            \"type\": \"string\",\n            \"x-wrtn-payment-vendor\": true,\n            \"title\": \"The vendor code who will receive the payment\",\n            \"description\": \"The vendor code who will receive the payment.\"\n          },\n          \"uid\": {\n            \"type\": \"string\",\n            \"x-wrtn-payment-uid\": true,\n            \"title\": \"The payment uid\",\n            \"description\": \"The payment uid.\"\n          }\n        },\n        \"required\": [\n          \"code\",\n          \"uid\"\n        ],\n        \"description\": \"Payment identifier from the payment vendor service.\"\n      },\n      \"IShoppingSaleQuestion.ICreate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"secret\": {\n            \"type\": \"boolean\",\n            \"title\": \"Whether the question article is secret or not\",\n            \"description\": \"Whether the question article is secret or not.\\n\\nIf secret article, only the writer customer and related seller can see\\nthe detailed content.\"\n          },\n          \"format\": {\n            \"oneOf\": [\n              {\n                \"const\": \"html\"\n              },\n              {\n                \"const\": \"md\"\n              },\n              {\n                \"const\": \"txt\"\n              }\n            ],\n            \"title\": \"Format of body\",\n            \"description\": \"Format of body.\\n\\nSame meaning with extension like `html`, `md`, `txt`.\"\n          },\n          \"title\": {\n            \"type\": \"string\",\n            \"title\": \"Title of article\",\n            \"description\": \"Title of article.\"\n          },\n          \"body\": {\n            \"type\": \"string\",\n            \"title\": \"Content body of article\",\n            \"description\": \"Content body of article.\"\n          },\n          \"files\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IAttachmentFile.ICreate\"\n            },\n            \"title\": \"List of attachment files\",\n            \"description\": \"List of attachment files.\"\n          }\n        },\n        \"required\": [\n          \"secret\",\n          \"format\",\n          \"title\",\n          \"body\",\n          \"files\"\n        ],\n        \"description\": \"Creation information of the question.\"\n      },\n      \"IBbsArticle.ICreate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"format\": {\n            \"oneOf\": [\n              {\n                \"const\": \"html\"\n              },\n              {\n                \"const\": \"md\"\n              },\n              {\n                \"const\": \"txt\"\n              }\n            ],\n            \"title\": \"Format of body\",\n            \"description\": \"Format of body.\\n\\nSame meaning with extension like `html`, `md`, `txt`.\"\n          },\n          \"title\": {\n            \"type\": \"string\",\n            \"title\": \"Title of article\",\n            \"description\": \"Title of article.\"\n          },\n          \"body\": {\n            \"type\": \"string\",\n            \"title\": \"Content body of article\",\n            \"description\": \"Content body of article.\"\n          },\n          \"files\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IAttachmentFile.ICreate\"\n            },\n            \"title\": \"List of attachment files\",\n            \"description\": \"List of attachment files.\"\n          }\n        },\n        \"required\": [\n          \"format\",\n          \"title\",\n          \"body\",\n          \"files\"\n        ],\n        \"description\": \"Creation information of the article.\"\n      },\n      \"IShoppingSaleReview.ICreate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"good_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"title\": \"Target good's {@link IShoppingOrderGood.id}\",\n            \"description\": \"Target good's {@link IShoppingOrderGood.id}.\"\n          },\n          \"score\": {\n            \"type\": \"number\",\n            \"minimum\": 0,\n            \"maximum\": 100,\n            \"title\": \"Score of the review\",\n            \"description\": \"Score of the review.\"\n          },\n          \"format\": {\n            \"oneOf\": [\n              {\n                \"const\": \"html\"\n              },\n              {\n                \"const\": \"md\"\n              },\n              {\n                \"const\": \"txt\"\n              }\n            ],\n            \"title\": \"Format of body\",\n            \"description\": \"Format of body.\\n\\nSame meaning with extension like `html`, `md`, `txt`.\"\n          },\n          \"title\": {\n            \"type\": \"string\",\n            \"title\": \"Title of article\",\n            \"description\": \"Title of article.\"\n          },\n          \"body\": {\n            \"type\": \"string\",\n            \"title\": \"Content body of article\",\n            \"description\": \"Content body of article.\"\n          },\n          \"files\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IAttachmentFile.ICreate\"\n            },\n            \"title\": \"List of attachment files\",\n            \"description\": \"List of attachment files.\"\n          }\n        },\n        \"required\": [\n          \"good_id\",\n          \"score\",\n          \"format\",\n          \"title\",\n          \"body\",\n          \"files\"\n        ],\n        \"description\": \"Creation information of the review.\"\n      },\n      \"IShoppingSaleReview.IUpdate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"score\": {\n            \"type\": \"number\",\n            \"minimum\": 0,\n            \"maximum\": 100,\n            \"title\": \"Score of the review\",\n            \"description\": \"Score of the review.\"\n          },\n          \"format\": {\n            \"oneOf\": [\n              {\n                \"const\": \"html\"\n              },\n              {\n                \"const\": \"md\"\n              },\n              {\n                \"const\": \"txt\"\n              }\n            ],\n            \"title\": \"Format of body\",\n            \"description\": \"Format of body.\\n\\nSame meaning with extension like `html`, `md`, `txt`.\"\n          },\n          \"title\": {\n            \"type\": \"string\",\n            \"title\": \"Title of article\",\n            \"description\": \"Title of article.\"\n          },\n          \"body\": {\n            \"type\": \"string\",\n            \"title\": \"Content body of article\",\n            \"description\": \"Content body of article.\"\n          },\n          \"files\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IAttachmentFile.ICreate\"\n            },\n            \"title\": \"List of attachment files\",\n            \"description\": \"List of attachment files.\"\n          }\n        },\n        \"required\": [\n          \"score\",\n          \"format\",\n          \"title\",\n          \"body\",\n          \"files\"\n        ],\n        \"description\": \"Updating information of the review.\"\n      },\n      \"IShoppingSeller.IJoin\": {\n        \"type\": \"object\",\n        \"properties\": {},\n        \"required\": []\n      },\n      \"IPageIShoppingDelivery.IInvert\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"pagination\": {\n            \"$ref\": \"#/components/schemas/IPage.IPagination\",\n            \"title\": \"Page information\",\n            \"description\": \"Page information.\"\n          },\n          \"data\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IShoppingDelivery.IInvert\"\n            },\n            \"title\": \"List of records\",\n            \"description\": \"List of records.\"\n          }\n        },\n        \"required\": [\n          \"pagination\",\n          \"data\"\n        ],\n        \"description\": \"A page.\\n\\nCollection of records with pagination indformation.\"\n      },\n      \"IShoppingDelivery.IInvert\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"orders\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IShoppingOrder.IInvertFromDelivery\"\n            },\n            \"minItems\": 1,\n            \"title\": \"List of orders of the delivery\",\n            \"description\": \"List of orders of the delivery.\"\n          },\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"title\": \"Primary Key\",\n            \"description\": \"Primary Key.\"\n          },\n          \"seller\": {\n            \"$ref\": \"#/components/schemas/IShoppingSeller\",\n            \"title\": \"Seller who've delivered the goods\",\n            \"description\": \"Seller who've delivered the goods.\"\n          },\n          \"journeys\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IShoppingDeliveryJourney\"\n            },\n            \"title\": \"List of journeys of the delivery\",\n            \"description\": \"List of journeys of the delivery.\"\n          },\n          \"pieces\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IShoppingDeliveryPiece\"\n            },\n            \"minItems\": 1,\n            \"title\": \"List of pieces of the delivery\",\n            \"description\": \"List of pieces of the delivery.\"\n          },\n          \"shippers\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IShoppingDeliveryShipper\"\n            },\n            \"title\": \"List of shippers of the delivery\",\n            \"description\": \"List of shippers of the delivery.\"\n          },\n          \"state\": {\n            \"oneOf\": [\n              {\n                \"const\": \"none\"\n              },\n              {\n                \"const\": \"underway\"\n              },\n              {\n                \"const\": \"preparing\"\n              },\n              {\n                \"const\": \"manufacturing\"\n              },\n              {\n                \"const\": \"shipping\"\n              },\n              {\n                \"const\": \"delivering\"\n              },\n              {\n                \"const\": \"arrived\"\n              }\n            ],\n            \"title\": \"State of the delivery\",\n            \"description\": \"State of the delivery.\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"title\": \"Creation time of the record\",\n            \"description\": \"Creation time of the record.\"\n          }\n        },\n        \"required\": [\n          \"orders\",\n          \"id\",\n          \"seller\",\n          \"journeys\",\n          \"pieces\",\n          \"shippers\",\n          \"state\",\n          \"created_at\"\n        ],\n        \"description\": \"Invert information of the delivery.\"\n      },\n      \"IShoppingOrder.IInvertFromDelivery\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"title\": \"Primary Key\",\n            \"description\": \"Primary Key.\"\n          },\n          \"customer\": {\n            \"$ref\": \"#/components/schemas/IShoppingCustomer\",\n            \"title\": \"Customer who've applied for the order\",\n            \"description\": \"Customer who've applied for the order.\"\n          },\n          \"goods\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IShoppingOrderGood\"\n            },\n            \"minItems\": 1,\n            \"title\": \"List of goods in the order\",\n            \"description\": \"List of goods in the order.\"\n          },\n          \"price\": {\n            \"$ref\": \"#/components/schemas/IShoppingOrderPrice\",\n            \"title\": \"Price information including discounts\",\n            \"description\": \"Price information including discounts.\"\n          },\n          \"publish\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"$ref\": \"#/components/schemas/IShoppingOrderPublish.IInvertFromDelivery\"\n              }\n            ],\n            \"title\": \"Order completion and payment information\",\n            \"description\": \"Order completion and payment information.\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"title\": \"Creation time of the record\",\n            \"description\": \"Creation time of the record.\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"customer\",\n          \"goods\",\n          \"price\",\n          \"publish\",\n          \"created_at\"\n        ],\n        \"description\": \"Invert information from delivery.\"\n      },\n      \"IShoppingOrderPublish.IInvertFromDelivery\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"title\": \"Primary Key\",\n            \"description\": \"Primary Key.\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"title\": \"Creation time of the record\",\n            \"description\": \"Creation time of the record.\"\n          },\n          \"paid_at\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\",\n                \"format\": \"date-time\"\n              }\n            ],\n            \"title\": \"Time when the order was paid\",\n            \"description\": \"Time when the order was paid.\"\n          },\n          \"cancelled_at\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\",\n                \"format\": \"date-time\"\n              }\n            ],\n            \"title\": \"Time when the payment was cancelled\",\n            \"description\": \"Time when the payment was cancelled.\"\n          },\n          \"address\": {\n            \"$ref\": \"#/components/schemas/IShoppingAddress\",\n            \"title\": \"Address where the {@link IShoppingOrderGood goods} to be delivered\",\n            \"description\": \"Address where the {@link IShoppingOrderGood goods} to be delivered.\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"created_at\",\n          \"paid_at\",\n          \"cancelled_at\",\n          \"address\"\n        ],\n        \"description\": \"Invert information from the delivery.\"\n      },\n      \"IShoppingDelivery.IRequest\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"sort\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"array\",\n                \"items\": {\n                  \"oneOf\": [\n                    {\n                      \"const\": \"-delivery.created_at\"\n                    },\n                    {\n                      \"const\": \"+delivery.created_at\"\n                    }\n                  ]\n                }\n              }\n            ]\n          },\n          \"page\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"integer\",\n                \"minimum\": 0\n              }\n            ],\n            \"title\": \"Page number\",\n            \"description\": \"Page number.\"\n          },\n          \"limit\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"integer\",\n                \"minimum\": 0\n              }\n            ],\n            \"title\": \"Limitation of records per a page\",\n            \"description\": \"Limitation of records per a page.\"\n          }\n        },\n        \"required\": []\n      },\n      \"IShoppingDelivery.ICreate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"pieces\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IShoppingDeliveryPiece.ICreate\"\n            },\n            \"minItems\": 1,\n            \"title\": \"List of pieces of the delivery\",\n            \"description\": \"List of pieces of the delivery.\"\n          },\n          \"journeys\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IShoppingDeliveryJourney.ICreate\"\n            },\n            \"title\": \"List of journeys of the delivery\",\n            \"description\": \"List of journeys of the delivery.\\n\\nThis is initial data, and it is also possible to accumulate journey data\\nafter the delivery creation.\"\n          },\n          \"shippers\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IShoppingDeliveryShipper.ICreate\"\n            },\n            \"title\": \"List of shippers of the delivery\",\n            \"description\": \"List of shippers of the delivery.\"\n          }\n        },\n        \"required\": [\n          \"pieces\",\n          \"journeys\",\n          \"shippers\"\n        ],\n        \"description\": \"Creation information of the delivery.\"\n      },\n      \"IShoppingDeliveryPiece.ICreate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"publish_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"title\": \"Target order's {@link IShoppingOrderPublish.id}\",\n            \"description\": \"Target order's {@link IShoppingOrderPublish.id}.\"\n          },\n          \"good_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"title\": \"Target good's {@link IShoppingOrderGood.id}\",\n            \"description\": \"Target good's {@link IShoppingOrderGood.id}.\"\n          },\n          \"stock_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"title\": \"Target stock's {@link IShoppingSaleUnitStock.id}\",\n            \"description\": \"Target stock's {@link IShoppingSaleUnitStock.id}.\"\n          },\n          \"quantity\": {\n            \"type\": \"number\",\n            \"minimum\": 0,\n            \"title\": \"Quantity of the stock\",\n            \"description\": \"Quantity of the stock.\\n\\nIt can be precision value to express split shipping.\"\n          }\n        },\n        \"required\": [\n          \"publish_id\",\n          \"good_id\",\n          \"stock_id\",\n          \"quantity\"\n        ],\n        \"description\": \"Creation information of the delivery piece.\"\n      },\n      \"IShoppingDeliveryJourney.ICreate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"type\": {\n            \"oneOf\": [\n              {\n                \"const\": \"preparing\"\n              },\n              {\n                \"const\": \"manufacturing\"\n              },\n              {\n                \"const\": \"shipping\"\n              },\n              {\n                \"const\": \"delivering\"\n              }\n            ],\n            \"title\": \"Type of journey\",\n            \"description\": \"Type of journey.\\n\\n- preparing\\n- manufacturing\\n- shipping\\n- delivering\"\n          },\n          \"title\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\"\n              }\n            ],\n            \"title\": \"Title of journey\",\n            \"description\": \"Title of journey.\"\n          },\n          \"description\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\"\n              }\n            ],\n            \"title\": \"Description of journey\",\n            \"description\": \"Description of journey.\"\n          },\n          \"started_at\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\",\n                \"format\": \"date-time\"\n              }\n            ],\n            \"title\": \"Start time of the journey\",\n            \"description\": \"Start time of the journey.\"\n          },\n          \"completed_at\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\",\n                \"format\": \"date-time\"\n              }\n            ],\n            \"title\": \"Completion time of the journey\",\n            \"description\": \"Completion time of the journey.\"\n          }\n        },\n        \"required\": [\n          \"type\",\n          \"title\",\n          \"description\",\n          \"started_at\",\n          \"completed_at\"\n        ],\n        \"description\": \"Creation information of the delivery journey.\"\n      },\n      \"IShoppingDeliveryShipper.ICreate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"company\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\"\n              }\n            ]\n          },\n          \"name\": {\n            \"type\": \"string\"\n          },\n          \"mobile\": {\n            \"type\": \"string\"\n          }\n        },\n        \"required\": [\n          \"company\",\n          \"name\",\n          \"mobile\"\n        ]\n      },\n      \"IShoppingDeliveryPiece.IRequest\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"publish_ids\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            }\n          }\n        },\n        \"required\": [\n          \"publish_ids\"\n        ]\n      },\n      \"IShoppingDeliveryJourney.IComplete\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"completed_at\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\",\n                \"format\": \"date-time\"\n              }\n            ],\n            \"title\": \"Completion time of the journey\",\n            \"description\": \"Completion time of the journey.\"\n          }\n        },\n        \"required\": [\n          \"completed_at\"\n        ],\n        \"description\": \"Completion information of the delivery journey.\"\n      },\n      \"IShoppingSale.ICreate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"section_code\": {\n            \"type\": \"string\",\n            \"title\": \"Belonged section's {@link IShoppingSection.code}\",\n            \"description\": \"Belonged section's {@link IShoppingSection.code}.\"\n          },\n          \"status\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"const\": \"paused\"\n              },\n              {\n                \"const\": \"suspended\"\n              }\n            ],\n            \"title\": \"Initial status of the sale\",\n            \"description\": \"Initial status of the sale.\\n\\n`null` or `undefined`: No restriction\\n`paused`: Starts with {@link ITimestamps.paused_at paused} status\\n`suspended`: Starts with {@link ITimestamps.suspended_at suspended} status\"\n          },\n          \"opened_at\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\",\n                \"format\": \"date-time\"\n              }\n            ],\n            \"title\": \"Opening time of the sale\",\n            \"description\": \"Opening time of the sale.\"\n          },\n          \"closed_at\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\",\n                \"format\": \"date-time\"\n              }\n            ],\n            \"title\": \"Closing time of the sale\",\n            \"description\": \"Closing time of the sale.\\n\\nIf this value is `null`, the sale be continued forever.\"\n          },\n          \"content\": {\n            \"$ref\": \"#/components/schemas/IShoppingSaleContent.ICreate\",\n            \"title\": \"Description and image content describing the sale\",\n            \"description\": \"Description and image content describing the sale.\"\n          },\n          \"units\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IShoppingSaleUnit.ICreate\"\n            },\n            \"minItems\": 1,\n            \"title\": \"List of units\",\n            \"description\": \"List of units.\"\n          },\n          \"tags\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"type\": \"string\"\n            },\n            \"title\": \"List of search tags\",\n            \"description\": \"List of search tags.\"\n          },\n          \"category_codes\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"type\": \"string\"\n            },\n            \"title\": \"List of target categories' {@link IShoppingChannelCategory.code}s\",\n            \"description\": \"List of target categories' {@link IShoppingChannelCategory.code}s.\\n\\nIf empty, it means all categories of the channel is listing the sale.\"\n          }\n        },\n        \"required\": [\n          \"section_code\",\n          \"opened_at\",\n          \"closed_at\",\n          \"content\",\n          \"units\",\n          \"tags\",\n          \"category_codes\"\n        ],\n        \"description\": \"Creation information of sale.\"\n      },\n      \"IShoppingSaleContent.ICreate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"title\": {\n            \"type\": \"string\"\n          },\n          \"format\": {\n            \"oneOf\": [\n              {\n                \"const\": \"html\"\n              },\n              {\n                \"const\": \"md\"\n              },\n              {\n                \"const\": \"txt\"\n              }\n            ]\n          },\n          \"body\": {\n            \"type\": \"string\"\n          },\n          \"files\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IAttachmentFile.ICreate\"\n            }\n          },\n          \"thumbnails\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IAttachmentFile.ICreate\"\n            }\n          }\n        },\n        \"required\": [\n          \"title\",\n          \"format\",\n          \"body\",\n          \"files\",\n          \"thumbnails\"\n        ]\n      },\n      \"IShoppingSaleUnit.ICreate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"options\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"oneOf\": [\n                {\n                  \"$ref\": \"#/components/schemas/IShoppingSaleUnitSelectableOption.ICreate\"\n                },\n                {\n                  \"$ref\": \"#/components/schemas/IShoppingSaleUnitDescriptiveOption.ICreate\"\n                }\n              ]\n            },\n            \"title\": \"List of options\",\n            \"description\": \"List of options.\"\n          },\n          \"stocks\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IShoppingSaleUnitStock.ICreate\"\n            },\n            \"minItems\": 1,\n            \"title\": \"List of final stocks\",\n            \"description\": \"List of final stocks.\"\n          },\n          \"name\": {\n            \"type\": \"string\",\n            \"title\": \"Representative name of the unit\",\n            \"description\": \"Representative name of the unit.\"\n          },\n          \"primary\": {\n            \"type\": \"boolean\",\n            \"title\": \"Whether the unit is primary or not\",\n            \"description\": \"Whether the unit is primary or not.\\n\\nJust a labeling value.\"\n          },\n          \"required\": {\n            \"type\": \"boolean\",\n            \"title\": \"Whether the unit is required or not\",\n            \"description\": \"Whether the unit is required or not.\\n\\nWhen the unit is required, the customer must select the unit. If do not\\nselect, customer can't buy it.\\n\\nFor example, if there's a sale \\\"Macbook Set\\\" and one of the unit is the\\n\\\"Main Body\\\", is it possible to buy the \\\"Macbook Set\\\" without the\\n\\\"Main Body\\\" unit? This property is for that case.\"\n          }\n        },\n        \"required\": [\n          \"options\",\n          \"stocks\",\n          \"name\",\n          \"primary\",\n          \"required\"\n        ],\n        \"description\": \"Creation information of sale unit.\"\n      },\n      \"IShoppingSaleUnitSelectableOption.ICreate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"type\": {\n            \"const\": \"select\",\n            \"title\": \"Discriminant for the type of selectable option\",\n            \"description\": \"Discriminant for the type of selectable option.\"\n          },\n          \"name\": {\n            \"type\": \"string\",\n            \"title\": \"Represents the name of the option\",\n            \"description\": \"Represents the name of the option.\"\n          },\n          \"variable\": {\n            \"type\": \"boolean\",\n            \"title\": \"Whether the option is variable or not\",\n            \"description\": \"Whether the option is variable or not.\\n\\nWhen type of current option is \\\"select\\\", this attribute means whether\\nselecting different candidate value affects the final stock or not.\"\n          },\n          \"candidates\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IShoppingSaleUnitOptionCandidate.ICreate\"\n            },\n            \"minItems\": 1,\n            \"title\": \"List of candidate values\",\n            \"description\": \"List of candidate values.\"\n          }\n        },\n        \"required\": [\n          \"type\",\n          \"name\",\n          \"variable\",\n          \"candidates\"\n        ],\n        \"description\": \"Creation information of the selectable option.\"\n      },\n      \"IShoppingSaleUnitOptionCandidate.ICreate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"name\": {\n            \"type\": \"string\",\n            \"title\": \"Represents the name of the candidate value\",\n            \"description\": \"Represents the name of the candidate value.\"\n          }\n        },\n        \"required\": [\n          \"name\"\n        ],\n        \"description\": \"Creation information of the candidate value.\"\n      },\n      \"IShoppingSaleUnitDescriptiveOption.ICreate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"type\": {\n            \"oneOf\": [\n              {\n                \"const\": \"string\"\n              },\n              {\n                \"const\": \"number\"\n              },\n              {\n                \"const\": \"boolean\"\n              }\n            ],\n            \"title\": \"Type of descriptive option\",\n            \"description\": \"Type of descriptive option.\\n\\nWhich typed value should be written when purchasing.\"\n          },\n          \"name\": {\n            \"type\": \"string\",\n            \"title\": \"Readable name of the option\",\n            \"description\": \"Readable name of the option.\"\n          }\n        },\n        \"required\": [\n          \"type\",\n          \"name\"\n        ],\n        \"description\": \"Creation information of the descriptive option.\"\n      },\n      \"IShoppingSaleUnitStock.ICreate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"name\": {\n            \"type\": \"string\",\n            \"title\": \"Representative name of the stock\",\n            \"description\": \"Representative name of the stock.\"\n          },\n          \"price\": {\n            \"$ref\": \"#/components/schemas/IShoppingPrice\",\n            \"title\": \"Price of the stock\",\n            \"description\": \"Price of the stock.\"\n          },\n          \"quantity\": {\n            \"type\": \"integer\",\n            \"minimum\": 1,\n            \"title\": \"Initial inventory quantity\",\n            \"description\": \"Initial inventory quantity.\"\n          },\n          \"choices\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IShoppingSaleUnitStockChoice.ICreate\"\n            },\n            \"title\": \"List of choices\",\n            \"description\": \"List of choices.\\n\\nWhich candidate values being chosen for each option.\"\n          }\n        },\n        \"required\": [\n          \"name\",\n          \"price\",\n          \"quantity\",\n          \"choices\"\n        ],\n        \"description\": \"Creation information of the stock.\"\n      },\n      \"IShoppingSaleUnitStockChoice.ICreate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"option_index\": {\n            \"type\": \"integer\",\n            \"minimum\": 0,\n            \"description\": \"Target option's index number in\\n{@link IShoppingSaleUnit.ICreate.options}.\"\n          },\n          \"candidate_index\": {\n            \"type\": \"integer\",\n            \"minimum\": 0,\n            \"description\": \"Target candidate's index number in\\n{@link IShoppingSaleUnitSelectableOption.ICreate.candidates}.\"\n          }\n        },\n        \"required\": [\n          \"option_index\",\n          \"candidate_index\"\n        ],\n        \"description\": \"Creation information of stock choice.\"\n      },\n      \"IShoppingSaleSnapshot.ICreate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"content\": {\n            \"$ref\": \"#/components/schemas/IShoppingSaleContent.ICreate\",\n            \"title\": \"Description and image content describing the sale\",\n            \"description\": \"Description and image content describing the sale.\"\n          },\n          \"units\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IShoppingSaleUnit.ICreate\"\n            },\n            \"minItems\": 1,\n            \"title\": \"List of units\",\n            \"description\": \"List of units.\"\n          },\n          \"tags\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"type\": \"string\"\n            },\n            \"title\": \"List of search tags\",\n            \"description\": \"List of search tags.\"\n          },\n          \"category_codes\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"type\": \"string\"\n            },\n            \"title\": \"List of target categories' {@link IShoppingChannelCategory.code}s\",\n            \"description\": \"List of target categories' {@link IShoppingChannelCategory.code}s.\\n\\nIf empty, it means all categories of the channel is listing the sale.\"\n          }\n        },\n        \"required\": [\n          \"content\",\n          \"units\",\n          \"tags\",\n          \"category_codes\"\n        ],\n        \"description\": \"Creation information of the snapshot.\"\n      },\n      \"IShoppingSale.IUpdateOpeningTime\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"opened_at\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\",\n                \"format\": \"date-time\"\n              }\n            ],\n            \"title\": \"Opening time of the sale\",\n            \"description\": \"Opening time of the sale.\"\n          },\n          \"closed_at\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"string\",\n                \"format\": \"date-time\"\n              }\n            ],\n            \"title\": \"Closing time of the sale\",\n            \"description\": \"Closing time of the sale.\\n\\nIf this value is `null`, the sale be continued forever.\"\n          }\n        },\n        \"required\": [\n          \"opened_at\",\n          \"closed_at\"\n        ],\n        \"description\": \"Update opening time information of sale.\"\n      },\n      \"IShoppingSaleInquiryAnswer.ISnapshot\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"title\": \"Primary Key\",\n            \"description\": \"Primary Key.\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"title\": \"Creation time of snapshot record\",\n            \"description\": \"Creation time of snapshot record.\\n\\nIn other words, creation time or update time or article.\"\n          },\n          \"format\": {\n            \"oneOf\": [\n              {\n                \"const\": \"html\"\n              },\n              {\n                \"const\": \"md\"\n              },\n              {\n                \"const\": \"txt\"\n              }\n            ],\n            \"title\": \"Format of body\",\n            \"description\": \"Format of body.\\n\\nSame meaning with extension like `html`, `md`, `txt`.\"\n          },\n          \"title\": {\n            \"type\": \"string\",\n            \"title\": \"Title of article\",\n            \"description\": \"Title of article.\"\n          },\n          \"body\": {\n            \"type\": \"string\",\n            \"title\": \"Content body of article\",\n            \"description\": \"Content body of article.\"\n          },\n          \"files\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IAttachmentFile.ICreate\"\n            },\n            \"title\": \"List of attachment files\",\n            \"description\": \"List of attachment files.\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"created_at\",\n          \"format\",\n          \"title\",\n          \"body\",\n          \"files\"\n        ]\n      },\n      \"IPageIShoppingSaleUnitStockSupplement\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"pagination\": {\n            \"$ref\": \"#/components/schemas/IPage.IPagination\",\n            \"title\": \"Page information\",\n            \"description\": \"Page information.\"\n          },\n          \"data\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IShoppingSaleUnitStockSupplement\"\n            },\n            \"title\": \"List of records\",\n            \"description\": \"List of records.\"\n          }\n        },\n        \"required\": [\n          \"pagination\",\n          \"data\"\n        ],\n        \"description\": \"A page.\\n\\nCollection of records with pagination indformation.\"\n      },\n      \"IShoppingSaleUnitStockSupplement\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"title\": \"Primary Key\",\n            \"description\": \"Primary Key.\"\n          },\n          \"value\": {\n            \"type\": \"integer\",\n            \"minimum\": 0,\n            \"title\": \"Supplemented quantity\",\n            \"description\": \"Supplemented quantity.\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"title\": \"Creation time of the record\",\n            \"description\": \"Creation time of the record.\\n\\nAnother words, the time when inventory of the stock being supplemented.\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"value\",\n          \"created_at\"\n        ],\n        \"description\": \"Supplementation of inventory quantity of stock.\\n\\nYou know what? If a {@link IShoppingSaleUnitStock stock} has been sold over\\nits {@link IShoppingSaleUnitStock.ICreate.quantity initial inventory quantity},\\nthe stock can't be sold anymore, because of out of stock. In that case, how the\\n{@link IShoppingSeller} should do?\\n\\nWhen the sotck is sold out, seller can supplement the inventory record by\\nregistering this `IShoppingSaleUnitStockSupplement` record. Right, this\\n`IShoppingSaleUnitStockSupplement` is an entity that embodies the\\nsupplementation of the inventory quantity of the belonged stock.\"\n      },\n      \"IShoppingSaleUnitStockSupplement.IRequest\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"sort\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"array\",\n                \"items\": {\n                  \"oneOf\": [\n                    {\n                      \"const\": \"-created_at\"\n                    },\n                    {\n                      \"const\": \"+created_at\"\n                    }\n                  ]\n                }\n              }\n            ],\n            \"title\": \"Sortable columns\",\n            \"description\": \"Sortable columns.\"\n          },\n          \"page\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"integer\",\n                \"minimum\": 0\n              }\n            ],\n            \"title\": \"Page number\",\n            \"description\": \"Page number.\"\n          },\n          \"limit\": {\n            \"oneOf\": [\n              {\n                \"type\": \"null\"\n              },\n              {\n                \"type\": \"integer\",\n                \"minimum\": 0\n              }\n            ],\n            \"title\": \"Limitation of records per a page\",\n            \"description\": \"Limitation of records per a page.\"\n          }\n        },\n        \"required\": [],\n        \"description\": \"Request information of the stock supplement list.\"\n      },\n      \"IShoppingSaleUnitStockSupplement.ICreate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"value\": {\n            \"type\": \"integer\",\n            \"minimum\": 0,\n            \"title\": \"Supplemented quantity\",\n            \"description\": \"Supplemented quantity.\"\n          }\n        },\n        \"required\": [\n          \"value\"\n        ],\n        \"description\": \"Creation information of the supplement.\"\n      }\n    }\n  },\n  \"x-samchon-emended-v4\": true\n}",
  "test/features/api/delivery/test_create_delivery_journey_with_valid_and_invalid_data.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport { IShoppingDelivery } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingDelivery\";\nimport { IShoppingDeliveryJourney } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingDeliveryJourney\";\nimport { IShoppingDeliveryPiece } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingDeliveryPiece\";\nimport { IShoppingDeliveryShipper } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingDeliveryShipper\";\n\nexport async function test_api_create_delivery_journey_with_valid_and_invalid_data(connection: api.IConnection): Promise<void> {\n    // 1. 정상 케이스: 배송 생성 후 여정 추가\n    const deliveryInput = {\n        pieces: [\n            {\n                publish_id: \"00000000-0000-0000-0000-000000000001\",\n                good_id: \"00000000-0000-0000-0000-000000000002\",\n                stock_id: \"00000000-0000-0000-0000-000000000003\",\n                quantity: 1\n            },\n        ],\n        journeys: [\n            {\n                type: \"preparing\",\n                title: \"Preparation\",\n                description: \"Preparing goods\",\n                started_at: new Date().toISOString(),\n                completed_at: null,\n            }\n        ],\n        shippers: [\n            {\n                company: \"배송회사\",\n                name: \"홍길동\",\n                mobile: \"01012345678\"\n            }\n        ]\n    };\n\n    const delivery: IShoppingDelivery = await api.functional.shoppings.sellers.deliveries.post(connection, deliveryInput);\n    typia.assert<IShoppingDelivery>(delivery);\n\n    // 최소 valid 정보로 journey 생성\n    const journeyInput = {\n        type: \"manufacturing\",\n        title: \"제조중\",\n        description: \"생산 중\",\n        started_at: new Date().toISOString(),\n        completed_at: null\n    };\n    const journey = await api.functional.shoppings.sellers.deliveries.journeys.post(connection, delivery.id, journeyInput);\n    typia.assert<IShoppingDeliveryJourney>(journey);\n    TestValidator.equals(\"journey type\")(journeyInput.type)(journey.type);\n    TestValidator.equals(\"journey title\")(journeyInput.title)(journey.title);\n    TestValidator.equals(\"journey description\")(journeyInput.description)(journey.description);\n\n    // 2. 잘못된 데이터 케이스 - type 누락\n    const invalidJourneyInput = Object.assign({}, journeyInput);\n    // @ts-expect-error 뻔한 타입 깨기\n    delete invalidJourneyInput.type;\n    await TestValidator.httpError(\"type 누락 시 400\")(400)(async () => {\n        await api.functional.shoppings.sellers.deliveries.journeys.post(connection, delivery.id, invalidJourneyInput as any);\n    });\n\n    // 2. 잘못된 데이터 케이스 - type 잘못된 값\n    const wrongTypeJourneyInput = { ...journeyInput, type: \"unknown\" };\n    await TestValidator.httpError(\"type 잘못된 값 400\")(400)(async () => {\n        await api.functional.shoppings.sellers.deliveries.journeys.post(connection, delivery.id, wrongTypeJourneyInput as any);\n    });\n\n    // 3. 완료된 배송에 journey 추가 시도\n    const arrivedDeliveryInput = {\n        pieces: [\n            {\n                publish_id: \"00000000-0000-0000-0000-000000000011\",\n                good_id: \"00000000-0000-0000-0000-000000000012\",\n                stock_id: \"00000000-0000-0000-0000-000000000013\",\n                quantity: 1\n            },\n        ],\n        journeys: [\n            {\n                type: \"delivering\",\n                title: \"배송완료여정\",\n                description: \"배송이 완료됨\",\n                started_at: new Date().toISOString(),\n                completed_at: new Date().toISOString(), // completed_at not null -> arrived 처리\n            }\n        ],\n        shippers: [\n            {\n                company: \"완료회사\",\n                name: \"임꺽정\",\n                mobile: \"01087654321\"\n            }\n        ]\n    };\n    const arrivedDelivery: IShoppingDelivery = await api.functional.shoppings.sellers.deliveries.post(connection, arrivedDeliveryInput);\n    typia.assert<IShoppingDelivery>(arrivedDelivery);\n    // 이 상태의 배송(delivery)은 이미 arrived 상태여야 함\n\n    const addJourneyInput = {\n        type: \"delivering\",\n        title: \"추가배송\",\n        description: \"이미 완료된 배송에 추가\",\n        started_at: new Date().toISOString(),\n        completed_at: null\n    };\n    await TestValidator.httpError(\"arrived 배송에 추가시 409\")(409)(async () => {\n        await api.functional.shoppings.sellers.deliveries.journeys.post(connection, arrivedDelivery.id, addJourneyInput);\n    });\n}\n",
  "test/features/api/shopping-delivery-journey/test_create_delivery_journey_with_nonexistent_delivery_id.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingDeliveryJourney } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingDeliveryJourney\";\nimport typia from \"typia\";\n\nexport async function test_api_create_delivery_journey_with_nonexistent_delivery_id(\n  connection: api.IConnection\n): Promise<void> {\n  // 존재하지 않는 UUID를 사용\n  const invalidDeliveryId = \"00000000-0000-0000-0000-000000000000\";\n\n  // 최소 유효 데이터 준비\n  const input: IShoppingDeliveryJourney.ICreate = {\n    type: \"preparing\",\n    title: \"Test Journey\",\n    description: \"Trying to create with nonexistent deliveryId\",\n    started_at: new Date().toISOString(),\n    completed_at: new Date().toISOString(),\n  };\n\n  await TestValidator.httpError(\"Should fail for nonexistent delivery ID\")(404, 409, 400)(async () => {\n    await api.functional.shoppings.sellers.deliveries.journeys.post(\n      connection,\n      invalidDeliveryId,\n      input\n    );\n  });\n}\n",
  "test/features/api/section/test_get_section_info_by_id_exists_and_not_exists.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingSection } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSection\";\nimport typia from \"typia\";\nimport { v4 as uuidv4 } from \"uuid\";\n\nexport async function test_api_get_section_info_by_id_exists_and_not_exists(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. 테스트 데이터 준비 및 섹션 생성\n  const input = {\n    code: `TEST-CODE-${Date.now()}`,\n    name: \"테스트 섹션\",\n  };\n  const created: IShoppingSection = await api.functional.shoppings.admins.systematic.sections.post(\n    connection, { body: input },\n  );\n  typia.assert<IShoppingSection>(created);\n  TestValidator.equals(\"created section fields\")<IShoppingSection>(\n    {\n      id: created.id,\n      code: input.code,\n      name: input.name,\n      created_at: created.created_at,\n    },\n  )(created);\n\n  // 2. 생성된 id로 정상 조회\n  const found: IShoppingSection = await api.functional.shoppings.admins.systematic.sections.get(\n    connection, created.id,\n  );\n  typia.assert<IShoppingSection>(found);\n  TestValidator.equals(\"found section equals created\")<IShoppingSection>(created)(found);\n\n  // 3. 비존재 id로 조회 시 404 처리\n  const nonExistId = uuidv4();\n  await TestValidator.httpError(\"section not found should return 404\")(404)(\n    () => api.functional.shoppings.admins.systematic.sections.get(\n      connection,\n      nonExistId,\n    )\n  );\n}\n",
  "test/features/api/section/test_update_section_info_valid_and_invalid.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingSection } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSection\";\nimport typia from \"typia\";\n\nexport async function test_update_section_info_valid_and_invalid(connection: api.IConnection): Promise<void> {\n  // 1. 새로운 섹션 생성\n  const createInput: IShoppingSection.ICreate = {\n    code: `test-section-${Date.now()}`,\n    name: \"테스트 섹션\"\n  };\n  const section: IShoppingSection = await api.functional.shoppings.admins.systematic.sections.post(connection, createInput);\n  typia.assert<IShoppingSection>(section);\n  TestValidator.equals(\"section.name\")(createInput.name)(section.name);\n\n  // 2. 이름 정상 업데이트\n  const updateInput: IShoppingSection.IUpdate = {\n    name: \"변경된 섹션 이름\"\n  };\n  await api.functional.shoppings.admins.systematic.sections.put(connection, section.id, updateInput);\n  // 재조회 대신 바로 응답이 없으므로, id와 이름이 매칭되는지 별도 조회 API 미제공 시 응답 변수 활용 불가\n\n  // 3. 잘못된 ID (없는 UUID)로 업데이트 시도 – 404 에러 확인\n  const invalidId = \"6f36e2a3-2cd8-495c-84ec-76e25c701234\";\n  await TestValidator.httpError(\"not found\")(404)(() =>\n    api.functional.shoppings.admins.systematic.sections.put(connection, invalidId, updateInput)\n  );\n\n  // 4. 잘못된 데이터(빈 문자열)로 업데이트 시도 – 400 에러 확인\n  const invalidUpdate: IShoppingSection.IUpdate = {\n    name: \"\"\n  };\n  await TestValidator.httpError(\"empty section name should fail\")(400)(() =>\n    api.functional.shoppings.admins.systematic.sections.put(connection, section.id, invalidUpdate)\n  );\n}\n",
  "test/features/api/shopping-section/test_merge_multiple_sections_valid_and_invalid.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingSection } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSection\";\nimport { IRecordMerge } from \"@ORGANIZATION/PROJECT-api/lib/structures/IRecordMerge\";\nimport typia from \"typia\";\n\nexport async function test_merge_multiple_sections_valid_and_invalid(\n    connection: api.IConnection,\n): Promise<void> {\n    // 1. 섹션 2개 이상 생성\n    const section1 = await api.functional.shoppings.admins.systematic.sections.post(connection, { code: \"fruit-corner\", name: \"Fruit Corner\" });\n    const section2 = await api.functional.shoppings.admins.systematic.sections.post(connection, { code: \"butcher-corner\", name: \"Butcher Corner\" });\n    typia.assert<IShoppingSection>(section1);\n    typia.assert<IShoppingSection>(section2);\n\n    // 2. 정상 머지: section1에 section2를 absorbed 시킴\n    const mergeInput: IRecordMerge = {\n        keep: section1.id,\n        absorbed: [section2.id],\n    };\n    await api.functional.shoppings.admins.systematic.sections.merge(connection, mergeInput);\n\n    // 3. 머지 후 keep 섹션 정상 조회\n    const keptSection = await api.functional.shoppings.admins.systematic.sections.at(connection, section1.id);\n    typia.assert<IShoppingSection>(keptSection);\n    TestValidator.equals(\"keep section still valid\")<IShoppingSection>(section1)(keptSection);\n\n    // 4. 머지된(흡수된) section2는 접근시 404 등의 오류 발생\n    await TestValidator.httpError(\"absorbed section must not exist after merge\")(404)(\n        () => api.functional.shoppings.admins.systematic.sections.at(connection, section2.id)\n    );\n\n    // 5. 존재하지 않는 id로 merge 시도시 오류\n    const nonExistId = \"00000000-0000-4000-8000-000000000001\";\n    const invalidInput: IRecordMerge = {\n        keep: section1.id,\n        absorbed: [nonExistId],\n    };\n    await TestValidator.httpError(\"merging with non-existing section id must fail\")(404)(\n        () => api.functional.shoppings.admins.systematic.sections.merge(connection, invalidInput)\n    );\n\n    // 6. 이미 머지된 section2를 다시 머지 대상으로 포함할 시 오류\n    const repeatMergeInput: IRecordMerge = {\n        keep: section1.id,\n        absorbed: [section2.id],\n    };\n    await TestValidator.httpError(\"merging already-absorbed section id must fail\")(404)(\n        () => api.functional.shoppings.admins.systematic.sections.merge(connection, repeatMergeInput)\n    );\n}\n",
  "test/features/api/section/test_get_section_info_by_code_exists_and_not_exists.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingSection } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSection\";\nimport { IShoppingSection as IShoppingSectionNS } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSection\";\nimport typia from \"typia\";\n\nexport async function test_api_section_get_by_code_exists_and_not_exists(\n    connection: api.IConnection,\n): Promise<void> {\n    // 1. 신규 섹션 생성\n    const sectionInput: IShoppingSectionNS.ICreate = {\n        code: `TEST_CODE_${Date.now()}`,\n        name: \"테스트 섹션\"\n    };\n    const created: IShoppingSection = await api.functional.shoppings.admins.systematic.sections.post(\n        connection,\n        { body: sectionInput },\n    );\n    typia.assert<IShoppingSection>(created);\n    TestValidator.equals(\"created section code\")<string>(sectionInput.code)(created.code);\n    TestValidator.equals(\"created section name\")<string>(sectionInput.name)(created.name);\n\n    // 2. 올바른 code로 정상 조회\n    const fetched: IShoppingSection = await api.functional.shoppings.admins.systematic.sections.get.get(\n        connection,\n        created.code,\n    );\n    typia.assert<IShoppingSection>(fetched);\n    TestValidator.equals(\"fetched section matches created\")<IShoppingSection>(created)(fetched);\n\n    // 3. 존재하지 않는 code로 404 확인\n    await TestValidator.httpError(\"Invalid code returns 404\")(404)(async () => {\n        await api.functional.shoppings.admins.systematic.sections.get.get(\n            connection,\n            \"INVALID_CODE_\" + Date.now(),\n        );\n    });\n}\n",
  "test/features/api/auth/test_refresh_token_with_valid_and_invalid_token.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport { IShoppingCustomer } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCustomer\";\n\nexport async function test_refresh_token_with_valid_and_invalid_token(connection: api.IConnection): Promise<void> {\n    // 1. 신규 고객 생성 및 유효 토큰 획득\n    const createInput: IShoppingCustomer.ICreate = {\n        channel_code: \"default-channel\",\n        href: \"https://localhost/path\",\n        referrer: null,\n        ip: \"127.0.0.1\",\n        external_user: null,\n    };\n    const authorized = await api.functional.shoppings.customers.authenticate.post(connection, { body: createInput });\n    typia.assert<IShoppingCustomer.IAuthorized>(authorized);\n    const oldToken = authorized.token;\n\n    // 2. 유효한 리프레시 토큰으로 갱신\n    const refreshInput: IShoppingCustomer.IRefresh = {\n        value: oldToken.refresh,\n    };\n    const refreshed = await api.functional.shoppings.customers.authenticate.refresh.patch(connection, { body: refreshInput });\n    typia.assert<IShoppingCustomer.IAuthorized>(refreshed);\n    TestValidator.predicate(\"access/refresh are newly issued\")(refreshed.token.access !== oldToken.access && refreshed.token.refresh !== oldToken.refresh);\n    TestValidator.predicate(\"type is customer\")(refreshed.type === \"customer\");\n\n    // 3. 잘못된 토큰 - 완전히 엉뚱한 값\n    const badRefresh: IShoppingCustomer.IRefresh = { value: \"__invalid_token__\" };\n    await TestValidator.httpError(\"invalid refresh token should fail\")(401, 403)(\n        () => api.functional.shoppings.customers.authenticate.refresh.patch(connection, { body: badRefresh })\n    );\n\n    // 4. 조작된(만료된) refresh 토큰 사용 시 시뮬레이션 (refreshable_until이 과거로 가정, 하지만 실제 서버에서 거절된다고 가정, 실제 만료 토큰을 얻을 수 없으니 임의값 지정)\n    const expiredRefresh: IShoppingCustomer.IRefresh = { value: \"eyJhbGciOi...expired\" };\n    await TestValidator.httpError(\"expired refresh token should fail\")(401, 403)(\n        () => api.functional.shoppings.customers.authenticate.refresh.patch(connection, { body: expiredRefresh })\n    );\n}\n",
  "test/features/api/customer/test_get_current_customer_info_authenticated_and_unauthenticated.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingCustomer } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCustomer\";\nimport { IShoppingCustomer as IShoppingCustomerNS } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCustomer\";\nimport typia from \"typia\";\n\nexport async function test_api_get_current_customer_info_authenticated_and_unauthenticated(connection: api.IConnection): Promise<void> {\n    // 1. Create a random IShoppingCustomer.ICreate input\n    const customerInput: IShoppingCustomerNS.ICreate = {\n        channel_code: \"main-channel\",\n        external_user: null,\n        href: \"https://shop.example.com/onboarding\",\n        referrer: null,\n        ip: null\n    };\n\n    // 2. Authenticate the customer to receive token\n    const auth = await api.functional.shoppings.customers.authenticate.post(\n        connection,\n        customerInput\n    );\n    typia.assert<IShoppingCustomerNS.IAuthorized>(auth);\n\n    // 3. Use authenticated token to get current customer info\n    const authedConnection: api.IConnection = {\n        ...connection,\n        headers: {\n            ...connection.headers,\n            Authorization: auth.setHeaders.Authorization\n        }\n    };\n    const customer = await api.functional.shoppings.customers.authenticate.get(\n        authedConnection\n    );\n    typia.assert<IShoppingCustomer>(customer);\n    TestValidator.equals(\"customer.id matches authorized\")(auth.id)(customer.id);\n\n    // 4. Try unauthenticated access -- must fail\n    await TestValidator.httpError(\"unauthenticated GET must fail\")(401)(async () => {\n        await api.functional.shoppings.customers.authenticate.get(connection);\n    });\n}\n",
  "test/features/api/customer/test_create_new_customer_valid_duplicate_missing_fields.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingCustomer } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCustomer\";\nimport { IShoppingExternalUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingExternalUser\";\nimport typia from \"typia\";\n\nexport async function test_create_new_customer_valid_duplicate_missing_fields(\n  connection: api.IConnection,\n): Promise<void> {\n  // 테스트용 고정 데이터(실제 환경에서는 랜덤화 가능)\n  const channel_code = \"test-channel\";\n  const href = \"https://test.example.com/page\";\n  const referrer = \"https://referrer.example.com\";\n  const external_user_uid = \"external-uid-123\";\n  const external_application = \"external-app-001\";\n  const external_nickname = \"Tester_Nick\";\n  const external_password = \"EXTERNAL_PASS_TEST\";\n  const external_data = { extra: \"meta\" };\n\n  // ----- [1] 정상 케이스: 모든 필수값 포함 -----\n  const valid_input: IShoppingCustomer.ICreate = {\n    channel_code,\n    href,\n    referrer,\n    external_user: {\n      citizen: {\n        mobile: \"01012341234\",\n        name: \"홍길동\",\n      },\n      application: external_application,\n      uid: external_user_uid,\n      nickname: external_nickname,\n      password: external_password,\n      data: external_data,\n    },\n  };\n\n  const firstRes = await api.functional.shoppings.customers.authenticate(\n    connection,\n    valid_input,\n  );\n  // 응답 타입 및 주요 필드 검증\n  typia.assert<IShoppingCustomer.IAuthorized>(firstRes);\n  TestValidator.equals(\"customer type\")(\"customer\")(firstRes.type);\n  TestValidator.equals(\"external_user uid 확인\")(\n    external_user_uid,\n  )(firstRes.external_user?.uid ?? \"\");\n\n  // ----- [2] 중복 케이스: 동일 외부 사용자 정보 재사용 -----\n  await TestValidator.httpError(\"Already exists - duplicate external_user uid\")(409)(\n    () =>\n      api.functional.shoppings.customers.authenticate(\n        connection,\n        valid_input,\n      ),\n  );\n\n  // ----- [3] 필수값 누락: 하나씩 누락하며 요청 -----\n  // 3-1) channel_code 누락\n  const missing_channel: IShoppingCustomer.ICreate = {\n    ...valid_input,\n    // @ts-expect-error channel_code intentionally missing\n  };\n  await TestValidator.httpError(\"channel_code missing - 400\")(400)(() =>\n    api.functional.shoppings.customers.authenticate(connection, {\n      ...missing_channel,\n      channel_code: undefined as any,\n    }),\n  );\n  // 3-2) external_user 누락\n  await TestValidator.httpError(\"external_user missing - 400\")(400)(() =>\n    api.functional.shoppings.customers.authenticate(connection, {\n      ...valid_input,\n      external_user: undefined as any,\n    }),\n  );\n  // 3-3) href 누락\n  await TestValidator.httpError(\"href missing - 400\")(400)(() =>\n    api.functional.shoppings.customers.authenticate(connection, {\n      ...valid_input,\n      href: undefined as any,\n    }),\n  );\n  // 3-4) referrer 누락\n  await TestValidator.httpError(\"referrer missing - 400\")(400)(() =>\n    api.functional.shoppings.customers.authenticate(connection, {\n      ...valid_input,\n      referrer: undefined as any,\n    }),\n  );\n}\n",
  "test/features/api/member/test_join_membership_success_and_duplicate_and_missing_fields.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingMember } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingMember\";\nimport { IShoppingCustomer } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCustomer\";\nimport { IShoppingMember as IJoin, IShoppingMember } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingMember\";\nimport { IShoppingCitizen } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCitizen\";\nimport typia from \"typia\";\n\nexport async function test_join_membership_success_and_duplicate_and_missing_fields(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. 정상 회원가입 요청\n  const joinInput = {\n    nickname: `user_${Date.now()}`,\n    email: `test_${Date.now()}@example.com`,\n    password: \"TestPassword1!\",\n    citizen: {\n      name: \"홍길동\",\n      mobile: \"01012341234\",\n    },\n  };\n\n  const input: IJoin.IJoin = {\n    nickname: joinInput.nickname,\n    email: joinInput.email,\n    password: joinInput.password,\n    citizen: joinInput.citizen,\n  };\n\n  const joined = await api.functional.shoppings.customers.authenticate.join(\n    connection,\n    input,\n  );\n  typia.assert<IShoppingCustomer>(joined);\n  TestValidator.equals(\"nickname match\")(input.nickname)((joined.member && joined.member.nickname) || \"\");\n  TestValidator.predicate(\"joined id exists\")(() => Boolean(joined.id));\n\n  // 2. 동일 정보로 재가입 시도 -> 중복 오류\n  await TestValidator.httpError(\"duplicate join should fail\")(409)(async () => {\n    await api.functional.shoppings.customers.authenticate.join(connection, input);\n  });\n\n  // 3. 필수항목 누락 테스트\n  const requiredFields: Array<keyof IJoin.IJoin> = [\n    \"nickname\",\n    \"email\",\n    \"password\",\n    \"citizen\",\n  ];\n  for (const field of requiredFields) {\n    const invalidInput = { ...input };\n    // @ts-ignore\n    delete invalidInput[field];\n    await TestValidator.httpError(`Missing required field: ${field}`)(400)(async () => {\n      await api.functional.shoppings.customers.authenticate.join(\n        connection,\n        invalidInput as any,\n      );\n    });\n  }\n}\n",
  "test/features/api/auth/test_membership_login_valid_invalid_and_blocked_account.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport { IShoppingCustomer } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCustomer\";\nimport { IShoppingCustomer_ICreate } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCustomer.ICreate\";\nimport { IShoppingCustomer_IAuthorized } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCustomer.IAuthorized\";\nimport { IShoppingMember_ILogin } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingMember.ILogin\";\n\nexport async function test_membership_login_valid_invalid_and_blocked_account(connection: api.IConnection): Promise<void> {\n  // 1. 테스트 데이터를 위한 이메일/비밀번호/차단&비차단 계정 준비\n  const normalEmail = \"normal-user@example.com\";\n  const normalPassword = \"P@ssw0rd123\";\n  const blockedEmail = \"blocked-user@example.com\";\n  const blockedPassword = \"B1ockedP@ss!!\";\n  const wrongPassword = \"wrongpassword\";\n  const notExistEmail = \"nobody@example.com\";\n\n  // 1-1. 고객(정상계정) 생성 및 토큰 획득\n  const normalCustomerInput: IShoppingCustomer_ICreate = {\n    channel_code: \"SHOP\",\n    href: \"https://shop.com/welcome\",\n    referrer: null,\n    external_user: null,\n    ip: \"127.0.0.1\"\n  };\n  const normalCustomerAuth: IShoppingCustomer_IAuthorized = await api.functional.shoppings.customers.authenticate.post(connection, { ...normalCustomerInput });\n  typia.assert<IShoppingCustomer_IAuthorized>(normalCustomerAuth);\n\n  // (가정) 별도의 API 또는 DB 조작으로 normalEmail/normalPassword 해당 멤버십이 가입된 상태여야 함.\n  // (동일 과정으로 차단 계정 생성, 실제 차단은 별도 사전 세팅 가정)\n  const blockedCustomerInput: IShoppingCustomer_ICreate = {\n    channel_code: \"SHOP\",\n    href: \"https://shop.com/blocked\",\n    referrer: null,\n    external_user: null,\n    ip: \"127.0.0.2\"\n  };\n  const blockedCustomerAuth: IShoppingCustomer_IAuthorized = await api.functional.shoppings.customers.authenticate.post(connection, { ...blockedCustomerInput });\n  typia.assert<IShoppingCustomer_IAuthorized>(blockedCustomerAuth);\n\n  // (가정) blockedEmail/blockedPassword 해당 멤버십이 가입+차단 처리된 상태여야 함.\n\n  // 2. 정상 로그인\n  const loginReq: IShoppingMember_ILogin = {\n    email: normalEmail,\n    password: normalPassword\n  };\n  const loginResp: IShoppingCustomer = await api.functional.shoppings.customers.authenticate.login.put(connection, { ...loginReq });\n  typia.assert<IShoppingCustomer>(loginResp);\n  TestValidator.predicate(\"Membership login success - customer id match\")(() => loginResp.id !== undefined && loginResp.type === \"customer\");\n  TestValidator.equals(\"Membership login - email\")(\n    loginReq.email\n  )(loginResp.member?.emails[0]?.value ?? \"\");\n\n  // 3. 잘못된 비밀번호 로그인 시도 (실패 예상)\n  await TestValidator.httpError(\"Membership login failed - wrong password\")(401)(async () =>\n    api.functional.shoppings.customers.authenticate.login.put(connection, {\n      email: normalEmail,\n      password: wrongPassword\n    })\n  );\n\n  // 4. 미존재 계정(email) 로그인 시도 (실패 예상)\n  await TestValidator.httpError(\"Membership login failed - not exist email\")(404, 401)(async () =>\n    api.functional.shoppings.customers.authenticate.login.put(connection, {\n      email: notExistEmail,\n      password: \"doesntmatter\"\n    })\n  );\n\n  // 5. 차단된 계정 로그인 시도\n  await TestValidator.httpError(\"Membership login failed - blocked account\")(403, 401)(async () =>\n    api.functional.shoppings.customers.authenticate.login.put(connection, {\n      email: blockedEmail,\n      password: blockedPassword\n    })\n  );\n}\n",
  "test/features/api/customer/test_activate_citizenship_success_and_already_activated.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingCustomer } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCustomer\";\nimport { IShoppingCustomer as IShoppingCustomerNS } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCustomer\";\nimport { IShoppingCitizen } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCitizen\";\nimport typia from \"typia\";\n\nexport async function test_api_customer_citizenship_activate_success_and_already_activated(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. 신규 고객 인증 및 토큰 발급\n  const customerInput: IShoppingCustomerNS.ICreate = {\n    channel_code: \"test-channel\",\n    external_user: null,\n    href: \"https://test.example.com\",\n    referrer: null,\n    ip: \"127.0.0.1\",\n  };\n\n  const authorized = await api.functional.shoppings.customers.authenticate.post(\n    connection,\n    { body: customerInput },\n  );\n  typia.assert<IShoppingCustomerNS.IAuthorized>(authorized);\n  TestValidator.predicate(\"access token must exist\")(() =>\n    Boolean(authorized.token?.access),\n  );\n\n  // 2. 시민 활성화 정상 케이스\n  const citizenInput: IShoppingCitizen.ICreate = {\n    mobile: \"01012345678\",\n    name: \"홍길동\",\n  };\n  const activated = await api.functional.shoppings.customers.authenticate.activate.post(\n    { ...connection, headers: { Authorization: authorized.token.access } },\n    { body: citizenInput },\n  );\n  typia.assert<IShoppingCustomer>(activated);\n  TestValidator.equals(\"citizen.mobile\")(<string>citizenInput.mobile)(\n    activated.citizen && activated.citizen.mobile,\n  );\n  TestValidator.equals(\"citizen.name\")(<string>citizenInput.name)(\n    activated.citizen && activated.citizen.name,\n  );\n\n  // 3. 중복 활성화 시도 및 오류 검증\n  await TestValidator.httpError(\"중복 시민 활성화 시 HTTP 오류(409 등) 발생해야 함\")(\n    409,\n    400,\n  )(async () => {\n    await api.functional.shoppings.customers.authenticate.activate.post(\n      { ...connection, headers: { Authorization: authorized.token.access } },\n      { body: citizenInput },\n    );\n  });\n}\n",
  "test/features/api/customer/test_enroll_external_user_info_success_and_duplicate.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingExternalUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingExternalUser\";\nimport { IShoppingCustomer } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCustomer\";\nimport { IShoppingCitizen } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCitizen\";\nimport typia from \"typia\";\n\nexport async function test_api_customer_enroll_external_user_info_success_and_duplicate(\n  connection: api.IConnection,\n): Promise<void> {\n  // 외부 인증 정보 생성\n  const citizen: IShoppingCitizen.ICreate = {\n    name: \"홍길동\",\n    mobile: \"01012345678\"\n  };\n  const input: IShoppingExternalUser.ICreate = {\n    citizen,\n    application: \"EXTERNAL_APP\",\n    uid: \"unique-uid-001\",\n    nickname: \"externaluser1\",\n    password: \"external-app-password\",\n    data: { extra: \"some extra data\" }\n  };\n\n  // 1차 정상 등록/인증 요청\n  const customer = await api.functional.shoppings.customers.authenticate.external.post(\n    connection,\n    input\n  );\n  \n  // 응답 타입 검증\n  typia.assert<IShoppingCustomer>(customer);\n  TestValidator.predicate(\"customer must include external_user\")(\n    () => customer.external_user !== null\n  );\n  TestValidator.equals(\"external_user.uid matches\")(\n    (input.uid)\n  )((customer.external_user as any).uid);\n  TestValidator.equals(\"external_user.application matches\")(\n    (input.application)\n  )((customer.external_user as any).application);\n\n  // 동일 외부 인증 정보로 재등록 시도 - 오류 발생 확인\n  await TestValidator.httpError(\"duplicate external user should fail\")(400 /* 중복 등록 오류시 통상 400 */)(\n    () => api.functional.shoppings.customers.authenticate.external.post(\n      connection,\n      input\n    )\n  );\n}\n",
  "test/features/api/auth/test_change_password_success_and_wrong_current_password.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingCustomer } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCustomer\";\nimport { IShoppingExternalUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingExternalUser\";\nimport { IShoppingMember } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingMember\";\nimport typia from \"typia\";\n\nexport async function test_change_password_success_and_wrong_current_password(connection: api.IConnection): Promise<void> {\n    // 1. 회원 사전생성: 고객 인증 요청\n    const customerInput: IShoppingCustomer.ICreate = {\n        channel_code: \"test-channel\",\n        href: \"https://test.local/entry\",\n        referrer: null,\n        ip: \"127.0.0.1\",\n        external_user: {\n            citizen: null,\n            application: \"external-test-app\",\n            uid: `testuser-${Date.now()}`,\n            nickname: \"패스변경테스터\",\n            password: \"initPassword123!@#\",\n            data: {}\n        }\n    };\n    const auth: IShoppingCustomer.IAuthorized = await api.functional.shoppings.customers.authenticate.post(connection, customerInput);\n    typia.assert<IShoppingCustomer.IAuthorized>(auth);\n    TestValidator.predicate(\"토큰 형식 올바름\")(!!auth.token.access && !!auth.token.refresh);\n\n    // 2. 정상 비밀번호 변경\n    // 비밀번호를 변경해본다\n    const successInput: IShoppingMember.IPasswordChange = {\n        oldbie: \"initPassword123!@#\",\n        newbie: \"newPassword!2345\"\n    };\n    await TestValidator.error(\"비밀번호 변경 성공 시 오류 없어야 함\")(async () => {\n        await api.functional.shoppings.customers.authenticate.password.change.put(connection, successInput);\n    });\n\n    // 3. 잘못된 기존 비밀번호로 변경 시도\n    const failInput: IShoppingMember.IPasswordChange = {\n        oldbie: \"wrongPassword000\",\n        newbie: \"newPassword999!\"\n    };\n    await TestValidator.httpError(\"잘못된 기존 비밀번호 오류 응답\")(400, 401)(async () => {\n        await api.functional.shoppings.customers.authenticate.password.change.put(connection, failInput);\n    });\n}\n",
  "test/features/api/coupon/test_list_customer_coupons_with_and_without_coupons.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingCustomer } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCustomer\";\nimport { IShoppingCoupon } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCoupon\";\nimport { IShoppingCoupon_IRequest } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCoupon.IRequest\";\nimport { IPageIShoppingCoupon } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIShoppingCoupon\";\nimport typia from \"typia\";\n\nexport async function test_list_customer_coupons_with_and_without_coupons(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. 고객 A/B 인증(신규 토큰 발급)\n  const customerInputA: IShoppingCustomer.ICreate = {\n    channel_code: \"default-channel\",\n    external_user: null,\n    href: \"https://test-customer-a.example.com/\",\n    referrer: null,\n    ip: null,\n  };\n  const customerInputB: IShoppingCustomer.ICreate = {\n    channel_code: \"default-channel\",\n    external_user: null,\n    href: \"https://test-customer-b.example.com/\",\n    referrer: null,\n    ip: null,\n  };\n  const authA = await api.functional.shoppings.customers.authenticate(\n    connection,\n    customerInputA,\n  );\n  const authB = await api.functional.shoppings.customers.authenticate(\n    connection,\n    customerInputB,\n  );\n  typia.assert<IShoppingCustomer.IAuthorized>(authA);\n  typia.assert<IShoppingCustomer.IAuthorized>(authB);\n\n  // (사전 조건) customerA에만 쿠폰이 있다고 가정\n  // 실제 연동 테스트 환경에서는 customerA에만 테스트 쿠폰을 주입해야 함\n  // 만약 쿠폰 발급 API가 없다면, 최소한 조회 결과가 0, 1개 모두 검증\n\n  // 2. customerA 쿠폰 목록 조회 (쿠폰 1개 이상 존재 가정)\n  const req: IShoppingCoupon_IRequest = {};\n  const respA = await api.functional.shoppings.customers.coupons.patch(\n    { ...connection, headers: { Authorization: authA.setHeaders.Authorization } },\n    req,\n  );\n  typia.assert<IPageIShoppingCoupon>(respA);\n  TestValidator.predicate(\"customerA coupon list is non-empty\")(\n    respA.data.length > 0,\n  );\n  respA.data.forEach((coupon) => typia.assert<IShoppingCoupon>(coupon));\n\n  // 3. customerB 쿠폰 목록 조회 (쿠폰 없음 가정)\n  const respB = await api.functional.shoppings.customers.coupons.patch(\n    { ...connection, headers: { Authorization: authB.setHeaders.Authorization } },\n    req,\n  );\n  typia.assert<IPageIShoppingCoupon>(respB);\n  TestValidator.equals(\"customerB has no coupon\")(<IShoppingCoupon[]>([]))(respB.data);\n}\n",
  "test/features/api/coupon/test_get_coupon_info_by_id_normal_and_invalid_access.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport { IShoppingCoupon } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCoupon\";\nimport { IShoppingCouponTicket } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCouponTicket\";\nimport { IShoppingCouponTicket_ICreate } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCouponTicket.ICreate\";\n\nimport { v4 as uuidv4 } from \"uuid\";\n\nexport async function test_api_coupon_ticket_access_permission(\n    connection: api.IConnection,\n    anotherConnection: api.IConnection,\n): Promise<void> {\n    // 1. 내 보유 쿠폰 티켓 발급 및 ID 확보\n    const ticketInput: IShoppingCouponTicket_ICreate = { coupon_id: \"my-coupon-id\" };\n    const myTicket: IShoppingCouponTicket = await api.functional.shoppings.customers.coupons.tickets.post(connection, ticketInput);\n\n    // 2. 본인 쿠폰 정보 정상 조회\n    const coupon: IShoppingCoupon = await api.functional.shoppings.customers.coupons.get(connection, myTicket.coupon.id);\n    typia.assert<IShoppingCoupon>(coupon);\n    TestValidator.equals(\"my coupon.id\")(myTicket.coupon.id)(coupon.id);\n\n    // 3. 다른 사용자 접속으로 쿠폰 티켓 발급 (겹치지 않는 쿠폰이어야 정상 검증)\n    const ticketInputAnother: IShoppingCouponTicket_ICreate = { coupon_id: \"another-coupon-id\" };\n    const anotherTicket: IShoppingCouponTicket = await api.functional.shoppings.customers.coupons.tickets.post(anotherConnection, ticketInputAnother);\n\n    // 4. 다른 사용자의 쿠폰 ID로 내 계정에서 조회 시 권한/존재/권한 오류 반환 확인\n    await TestValidator.httpError(\"다른 유저의 쿠폰 ID로 접근 404 or 403\")(403, 404)(() =>\n        api.functional.shoppings.customers.coupons.get(connection, anotherTicket.coupon.id)\n    );\n    \n    // 5. 존재하지 않는 쿠폰 ID로 조회 시 404 오류\n    const invalidId = uuidv4();\n    await TestValidator.httpError(\"존재하지 않는 쿠폰 ID 404\")(404)(() =>\n        api.functional.shoppings.customers.coupons.get(connection, invalidId)\n    );\n}\n",
  "test/features/api/coupon/test_create_coupon_ticket_valid_and_invalid_code.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingCouponTicket } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCouponTicket\";\nimport { IShoppingCouponTicket_ICreate } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCouponTicket.ICreate\";\nimport { IShoppingCustomer_ICreate } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCustomer.ICreate\";\nimport typia from \"typia\";\nimport { v4 as uuidv4 } from \"uuid\";\n\nexport async function test_create_coupon_ticket_valid_and_invalid_code(connection: api.IConnection): Promise<void> {\n    // 1. 고객 인증 토큰 발급 (고객 생성)\n    const customerInput: IShoppingCustomer_ICreate = {\n        channel_code: \"test-channel\",\n        href: \"https://testmall.com\",\n        referrer: null,\n        external_user: null,\n        ip: null\n    };\n    const auth = await api.functional.shoppings.customers.authenticate(connection, { body: customerInput });\n    // 인증 토큰 헤더로 재설정\n    const customerConnection = { ...connection, headers: { ...(connection.headers ?? {}), Authorization: auth.setHeaders.Authorization } };\n\n    // 2. 유효한 쿠폰 coupon_id 필요 (가정: 테스트용 coupon_id가 이미 있다고 가정)\n    // 실제 환경에서는 별도 쿠폰 발급 후 진행해야 함. 여기선 예시로 uuid 사용\n    const validCouponId = uuidv4(); // 실제로는 사전에 생성된 쿠폰 ID를 주입받아야 함\n    const ticketInput: IShoppingCouponTicket_ICreate = { coupon_id: validCouponId };\n\n    // 2-1. 정상 쿠폰 발급 (1회차): 성공\n    let issuedTicket: IShoppingCouponTicket | undefined = undefined;\n    await TestValidator.error(\"정상 쿠폰 발급 시도에 실패하면 안 된다.\")(\n      async () => {\n        issuedTicket = await api.functional.shoppings.customers.coupons.tickets.post(customerConnection, { body: ticketInput });\n      }\n    );\n    typia.assert<IShoppingCouponTicket>(issuedTicket);\n\n    // 2-2. 동일 coupon_id로 쿠폰이 이미 발급된 경우 (2회차): 410 Gone 오류 등 기대\n    await TestValidator.httpError(\"이미 발급된 쿠폰 재발급은 410 오류여야 한다.\")(410)(\n      async () => {\n        await api.functional.shoppings.customers.coupons.tickets.post(customerConnection, { body: ticketInput });\n      }\n    );\n\n    // 3. 유효하지 않은 coupon_id로 쿠폰 발급 시도: 404 Not Found 또는 410 Gone 등 기대\n    const invalidTicketInput: IShoppingCouponTicket_ICreate = { coupon_id: uuidv4() };\n    await TestValidator.httpError(\"유효하지 않은 coupon_id 사용 시 404 또는 410이어야 한다.\")(404, 410)(\n      async () => {\n        await api.functional.shoppings.customers.coupons.tickets.post(customerConnection, { body: invalidTicketInput });\n      }\n    );\n}\n",
  "test/features/api/coupon/test_list_coupon_tickets_with_and_without_tickets.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingCustomer } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCustomer\";\nimport { IShoppingCustomer_ICreate } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCustomer.ICreate\";\nimport { IShoppingCustomer_IAuthorized } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCustomer.IAuthorized\";\nimport { IPageIShoppingCouponTicket } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIShoppingCouponTicket\";\nimport typia from \"typia\";\n\nexport async function test_list_coupon_tickets_with_and_without_tickets(connection: api.IConnection): Promise<void> {\n    // 1. Authenticate customer (no tickets yet)\n    const input: IShoppingCustomer_ICreate = {\n        channel_code: \"test-channel\",\n        external_user: null,\n        href: \"https://test.example.com\",\n        referrer: null,\n        ip: \"127.0.0.1\"\n    };\n    const authorized: IShoppingCustomer_IAuthorized = await api.functional.shoppings.customers.authenticate.post(connection, input);\n    typia.assert<IShoppingCustomer_IAuthorized>(authorized);\n\n    // 2. Query coupon tickets (should have none)\n    const req = {};\n    const result: IPageIShoppingCouponTicket = await api.functional.shoppings.customers.coupons.tickets.patch(connection, req);\n    typia.assert<IPageIShoppingCouponTicket>(result);\n    TestValidator.equals(\"empty coupon tickets\")( [] as IPageIShoppingCouponTicket[\"data\"] )(result.data);\n\n    // 3. (Cannot simulate presence of tickets with current API set)\n    // If there was a way to issue/own a ticket, would add and re-test here\n}\n",
  "test/features/api/coupon/test_get_coupon_ticket_info_by_id_and_access_control.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingCouponTicket } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCouponTicket\";\nimport { IShoppingCouponTicket as ICreate } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCouponTicket.ICreate\";\nimport typia from \"typia\";\n\nexport async function test_api_coupon_ticket_info_access_control(\n    connectionA: api.IConnection,\n    connectionB: api.IConnection,\n    validCouponId: string,\n): Promise<void> {\n    // 1. 발급용 요청 생성\n    const createInput: ICreate.ICreate = {\n        coupon_id: validCouponId,\n    };\n\n    // 2. 고객A로 쿠폰 티켓 발급\n    const createdTicket = await api.functional.shoppings.customers.coupons.tickets.post(\n        connectionA,\n        createInput,\n    );\n    typia.assert<IShoppingCouponTicket>(createdTicket);\n\n    // 3. 본인(고객A)으로 티켓 정보 조회\n    const fetched = await api.functional.shoppings.customers.coupons.tickets.get(\n        connectionA,\n        createdTicket.id,\n    );\n    typia.assert<IShoppingCouponTicket>(fetched);\n    TestValidator.equals(\"coupon ticket self fetch\")(createdTicket)(fetched);\n\n    // 4. 타인(고객B)로 티켓 정보 조회 시 권한에러 검증\n    await TestValidator.httpError(\"Not my coupon ticket - access control\")(403, 404)(async () => {\n        await api.functional.shoppings.customers.coupons.tickets.get(\n            connectionB,\n            createdTicket.id,\n        );\n    });\n}\n",
  "test/features/api/deposit/test_create_deposit_charge_application_valid_and_invalid.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingCustomer } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCustomer\";\nimport { IShoppingCustomer as IShoppingCustomerNS } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCustomer\";\nimport { IShoppingExternalUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingExternalUser\";\nimport { IShoppingCitizen } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCitizen\";\nimport { IShoppingDepositCharge } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingDepositCharge\";\nimport { IShoppingDepositCharge as IShoppingDepositChargeNS } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingDepositCharge\";\nimport typia from \"typia\";\n\nexport async function test_create_deposit_charge_application_valid_and_invalid(\n  connection: api.IConnection,\n): Promise<void> {\n  // Step 1: 고객 인증 (access token 획득)\n  const authInput: IShoppingCustomerNS.ICreate = {\n    channel_code: \"test-channel\",\n    external_user: {\n      citizen: {\n        mobile: \"01012345678\",\n        name: \"홍길동\",\n      },\n      application: \"app-test\",\n      uid: \"user-001\",\n      nickname: \"홍테스터\",\n      password: \"external-secret\",\n      data: {},\n    },\n    href: \"https://test-client.com/path\",\n    referrer: null,\n    ip: \"127.0.0.1\",\n  };\n  const authorized = await api.functional.shoppings.customers.authenticate(\n    connection,\n    { body: authInput },\n  );\n  typia.assert<IShoppingCustomerNS.IAuthorized>(authorized);\n\n  // Step 2: 정상적인 예치금 충전 신청\n  const validChargeInput: IShoppingDepositChargeNS.ICreate = {\n    value: 10000,\n  };\n  const newCharge = await api.functional.shoppings.customers.deposits.charges(\n    connection,\n    { body: validChargeInput },\n  );\n  typia.assert<IShoppingDepositCharge>(newCharge);\n  TestValidator.predicate(\"예치금 신청 값이 맞음\")(\n    () => newCharge.value === validChargeInput.value,\n  );\n\n  // Step 3: 필수값 누락(빈 객체)\n  await TestValidator.httpError(\"value 필수값 누락은 400 반환\")(400)(async () =>\n    api.functional.shoppings.customers.deposits.charges(connection, { body: {} as any }),\n  );\n\n  // Step 4: 잘못된 타입 전달 (value 문자열)\n  await TestValidator.httpError(\"value 잘못된 타입은 400 반환\")(400)(async () =>\n    api.functional.shoppings.customers.deposits.charges(connection, { body: { value: \"십만원\" } as any }),\n  );\n\n  // Step 5: 음수 값 전달\n  await TestValidator.httpError(\"음수 값도 400 반환\")(400)(async () =>\n    api.functional.shoppings.customers.deposits.charges(connection, { body: { value: -5000 } as any }),\n  );\n}\n",
  "test/features/api/deposit-charge/test_list_deposit_charge_applications_with_and_without_records.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport { IShoppingCustomer } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCustomer\";\nimport { IShoppingCustomer_ICreate } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCustomer.ICreate\";\nimport { IPageIShoppingDepositCharge } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIShoppingDepositCharge\";\nimport { IShoppingDepositCharge_IRequest } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingDepositCharge.IRequest\";\n\nexport async function test_list_deposit_charge_applications_with_and_without_records(connection: api.IConnection): Promise<void> {\n    // 1. 신규 고객 인증 (토큰 발급)\n    const customerInput: IShoppingCustomer_ICreate = {\n        channel_code: \"test-channel\",\n        external_user: {\n            citizen: null,\n            application: \"test-app\",\n            uid: \"user-\" + Math.random().toString(36).substring(2, 10),\n            nickname: \"테스트사용자\",\n            password: \"pw\" + Math.random().toString(36).substring(2, 8),\n            data: {info: \"dummy\"},\n        },\n        href: \"https://localhost/test\",\n        referrer: null,\n        ip: \"127.0.0.1\"\n    };\n    const auth = await api.functional.shoppings.customers.authenticate(connection, customerInput);\n    typia.assert(auth);\n    TestValidator.predicate(\"customer token exists\")(() => !!auth?.token?.access);\n\n    // 2. 예치금 충전 내역 (기록 없음)\n    const depositChargeReq: IShoppingDepositCharge_IRequest = {};\n    const res = await api.functional.shoppings.customers.deposits.charges.patch(\n        { ...connection, headers: { Authorization: auth.setHeaders.Authorization } },\n        depositChargeReq\n    );\n    typia.assert<IPageIShoppingDepositCharge>(res);\n    // 내역이 없어야 함\n    TestValidator.equals(\"empty array\")<IPageIShoppingDepositCharge[\"data\"]>([])(res.data);\n    // pagination 검증 (기본값 기반 판단)\n    TestValidator.predicate(\"pagination.records 0\")(() => res.pagination.records === 0);\n    TestValidator.predicate(\"pagination.pages 0 or 1\")(() => res.pagination.pages === 0 || res.pagination.pages === 1);\n\n    // 3. 인증 없이 호출 시 에러반환\n    await TestValidator.httpError(\"no auth error\")(401)(() =>\n        api.functional.shoppings.customers.deposits.charges.patch(connection, depositChargeReq),\n    );\n}",
  "test/features/api/deposit/test_get_deposit_charge_info_by_id_and_access_control.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingDepositCharge } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingDepositCharge\";\nimport { IShoppingDepositCharge as ICreateDepositCharge } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingDepositCharge.ICreate\";\nimport typia from \"typia\";\n\nexport async function test_get_deposit_charge_info_by_id_and_access_control(\n  connection: api.IConnection,\n  otherConnection: api.IConnection,\n): Promise<void> {\n  // 1. 예치금 충전 신청 생성\n  const createInput: ICreateDepositCharge = { value: 10000 };\n  const charge: IShoppingDepositCharge = await api.functional.shoppings.customers.deposits.charges.post(\n    connection,\n    createInput,\n  );\n  typia.assert<IShoppingDepositCharge>(charge);\n  TestValidator.equals(\"예치금 신청 금액\")(createInput.value)(charge.value);\n\n  // 2. 생성한 충전 ID로 정상 상세 조회\n  const detail: IShoppingDepositCharge = await api.functional.shoppings.customers.deposits.charges.get(\n    connection,\n    charge.id,\n  );\n  typia.assert<IShoppingDepositCharge>(detail);\n  TestValidator.equals(\"충전 내역 상세 동일\")(charge)(detail);\n\n  // 3. 타 사용자로 동일 ID 접근 제한 확인\n  await TestValidator.httpError(\"타 사용자 접근금지\")(403, 401)(async () => {\n    await api.functional.shoppings.customers.deposits.charges.get(\n      otherConnection,\n      charge.id,\n    );\n  });\n\n  // 4. 잘못된 ID 사용시 404\n  await TestValidator.httpError(\"존재하지 않는 ID 404\")(404)(async () => {\n    await api.functional.shoppings.customers.deposits.charges.get(\n      connection,\n      \"00000000-0000-0000-0000-000000000000\",\n    );\n  });\n}\n",
  "test/features/api/deposit-charge/test_update_deposit_charge_application_by_owner_and_not_owner.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingDepositCharge } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingDepositCharge\";\nimport { IShoppingDepositCharge as IShoppingDepositChargeNS } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingDepositCharge\";\nimport typia from \"typia\";\n\nexport async function test_update_deposit_charge_application_by_owner_and_not_owner(\n  ownerConnection: api.IConnection,\n  notOwnerConnection: api.IConnection\n): Promise<void> {\n  // 1. Owner creates a deposit charge application\n  const chargeInput: IShoppingDepositChargeNS.ICreate = {\n    value: 10000,\n  };\n\n  const created: IShoppingDepositCharge = await api.functional.shoppings.customers.deposits.charges.post(\n    ownerConnection,\n    { body: chargeInput }\n  );\n  typia.assert<IShoppingDepositCharge>(created);\n  TestValidator.equals(\"created.value\")<number>(chargeInput.value)(created.value);\n\n  // 2. Owner updates the deposit charge\n  const updateInput: IShoppingDepositChargeNS.ICreate = {\n    value: 30000,\n  };\n  let updateError: Error | null = null;\n  let updated: IShoppingDepositCharge | null = null;\n  try {\n    updated = await api.functional.shoppings.customers.deposits.charges.put(\n      ownerConnection,\n      created.id,\n      { body: updateInput }\n    );\n  } catch (err) {\n    updateError = err as Error;\n  }\n\n  // 2a. Check if update success or rejected due to \"published\"\n  if (updated) {\n    typia.assert<IShoppingDepositCharge>(updated);\n    TestValidator.equals(\"updated.value\")<number>(updateInput.value)(updated.value);\n    TestValidator.equals(\"id stays same\")(created.id)(updated.id);\n  } else {\n    TestValidator.predicate(\"Update failed due to publication or error\")(\n      () => !!updateError && updateError instanceof Error\n    );\n  }\n\n  // 3. Not owner attempts update and must get error\n  await TestValidator.error(\"should not allow not-owner to update deposit charge\")(\n    async () => {\n      await api.functional.shoppings.customers.deposits.charges.put(\n        notOwnerConnection,\n        created.id,\n        { body: updateInput }\n      );\n    }\n  );\n}\n",
  "test/features/api/deposit-charge/test_delete_deposit_charge_application_normal_and_invalid_cases.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingDepositCharge } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingDepositCharge\";\nimport { IShoppingDepositCharge as ICreate } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingDepositCharge.ICreate\";\nimport typia from \"typia\";\n\nexport async function test_delete_deposit_charge_application_normal_and_invalid_cases(\n  connection: api.IConnection,\n  otherConnection: api.IConnection\n): Promise<void> {\n  // 1. 본인A로 예치금 충전 신청 생성\n  const createInput: ICreate = { value: 10000 };\n  const charge: IShoppingDepositCharge = await api.functional.shoppings.customers.deposits.charges.post(\n    connection,\n    createInput\n  );\n  typia.assert<IShoppingDepositCharge>(charge);\n\n  // 2. 본인A가 정상적으로 삭제\n  await TestValidator.error(\"Should delete successfully\")(\n    async () => {\n      await api.functional.shoppings.customers.deposits.charges.delete(\n        connection,\n        charge.id\n      );\n    }\n  ); // error 검증이 의미 없으니 직접 await 처리\n  await api.functional.shoppings.customers.deposits.charges.delete(\n    connection,\n    charge.id\n  ); // 삭제 시도 (must succeed)\n\n  // 3. 동일한 id로 본인A가 재삭제 시도 (404 등 오류 응답)\n  await TestValidator.httpError(\"Delete again should fail\")(404)(\n    async () => {\n      await api.functional.shoppings.customers.deposits.charges.delete(\n        connection,\n        charge.id\n      );\n    }\n  );\n\n  // 4. 본인B가 타인의(이미 삭제됨) charge에 삭제 요청 (403 또는 404)\n  await TestValidator.httpError(\"Other user delete should fail\")(403, 404)(\n    async () => {\n      await api.functional.shoppings.customers.deposits.charges.delete(\n        otherConnection,\n        charge.id\n      );\n    }\n  );\n}\n",
  "test/features/api/deposit-charge/test_check_deposit_charge_publishable_status.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingDepositCharge } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingDepositCharge\";\nimport { IShoppingDepositCharge as IShoppingDepositChargeNamespace } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingDepositCharge\";\nimport typia from \"typia\";\n\nexport async function test_api_check_deposit_charge_publishable_status(connection: api.IConnection): Promise<void> {\n    // 1. 충전 신청(Charge) 생성\n    const chargeInput: IShoppingDepositChargeNamespace.ICreate = { value: 10000 };\n    const charge: IShoppingDepositCharge = await api.functional.shoppings.customers.deposits.charges.post(connection, chargeInput);\n    typia.assert<IShoppingDepositCharge>(charge);\n    TestValidator.predicate(\"충전신청 id 존재\")(() => typeof charge.id === \"string\" && charge.id.length > 0);\n    // 2. 정상: 아직 발행 전 상태에서 publish/able 호출 시 200 OK, 에러 없음\n    await TestValidator.predicate(\"publish/able 정상 응답\")(() =>\n        api.functional.shoppings.customers.deposits.charges.publish.able.get(connection, charge.id).then(() => true)\n    );\n\n    // 3. Negative case - 결격 사유: 상태 조작 불가(예: 이미 publish 되었거나 삭제된 상태 등) API 미제공시 검증 skip 주석\n    // 예시: publish 상태로 만드는 API 미제공이므로 skip\n    // await TestValidator.httpError(\"이미 publish된 charge는 불가\")(403)(async () =>\n    //     api.functional.shoppings.customers.deposits.charges.publish.able.get(connection, publishedChargeId)\n    // );\n}\n",
  "test/features/api/deposit-charge/test_publish_deposit_charge_application_and_double_publish.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingDepositCharge } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingDepositCharge\";\nimport { IShoppingDepositChargePublish } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingDepositChargePublish\";\nimport { IShoppingDepositChargePublish as ICreatePublish } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingDepositChargePublish.ICreate\";\nimport { IShoppingDepositCharge as ICreateCharge } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingDepositCharge.ICreate\";\nimport typia from \"typia\";\n\nexport async function test_api_deposit_charge_publish_and_double_publish(connection: api.IConnection): Promise<void> {\n  // 1. 충전 신청 내역을 생성\n  const chargeInput: ICreateCharge = {\n    value: 10000\n  };\n  const charge: IShoppingDepositCharge = await api.functional.shoppings.customers.deposits.charges.post(\n    connection,\n    { body: chargeInput }\n  );\n  typia.assert<IShoppingDepositCharge>(charge);\n\n  // 2. 첫 번째 발행 요청\n  const publishInput: ICreatePublish = {\n    vendor: \"test-vendor\",\n    uid: \"test-uid-1234\"\n  };\n  const publish: IShoppingDepositChargePublish = await api.functional.shoppings.customers.deposits.charges.publish(\n    connection,\n    charge.id,\n    { body: publishInput }\n  );\n  typia.assert<IShoppingDepositChargePublish>(publish);\n\n  // 3. 두 번째(중복) 발행 요청 시도 및 오류 검증\n  await TestValidator.httpError(\"중복 발행 요청시 400 오류\")(400)(async () => {\n    await api.functional.shoppings.customers.deposits.charges.publish(\n      connection,\n      charge.id,\n      { body: publishInput }\n    );\n  });\n}\n",
  "test/features/api/deposit-history/test_list_deposit_histories_with_and_without_records.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingCustomer } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCustomer\";\nimport { IShoppingCustomer as IShoppingCustomerNS } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCustomer\";\nimport { IShoppingCustomer as IShoppingCustomerTypes } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCustomer\";\nimport { IShoppingDepositHistory } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingDepositHistory\";\nimport { IShoppingDepositHistory as IShoppingDepositHistoryNS } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingDepositHistory\";\nimport { IPageIShoppingDepositHistory } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIShoppingDepositHistory\";\nimport typia from \"typia\";\n\nexport async function test_api_list_deposit_histories_with_and_without_records(connection: api.IConnection): Promise<void> {\n    // Step 1: Authenticate (create) a new customer\n    const customerInput: IShoppingCustomerNS.ICreate = {\n        channel_code: \"test-channel\",\n        external_user: {\n            citizen: null,\n            application: \"test-application\",\n            uid: `uid-${Math.random().toString(36).substring(2,15)}`,\n            nickname: \"test-user\",\n            password: \"test-password\",\n            data: {}\n        },\n        href: \"https://test-client.local/\",\n        referrer: null,\n        ip: null,\n    };\n    const auth: IShoppingCustomerNS.IAuthorized = await api.functional.shoppings.customers.authenticate(connection, customerInput);\n    typia.assert<IShoppingCustomerNS.IAuthorized>(auth);\n    TestValidator.predicate(\"Authenticated customer must have type 'customer'\")(() => auth.type === \"customer\");\n    \n    // Step 2: Query deposit histories (should be empty)\n    const historiesInput = {};\n    const histories: IPageIShoppingDepositHistory = await api.functional.shoppings.customers.deposits.histories.patch(connection, historiesInput);\n    typia.assert<IPageIShoppingDepositHistory>(histories);\n    TestValidator.equals(\"Returned history list should be an empty array\")([] as IShoppingDepositHistory[])(histories.data);\n    // Step 3: Validate pagination structure\n    TestValidator.predicate(\"Pagination current page is 0\")(() => histories.pagination.current === 0);\n    TestValidator.predicate(\"Records count should be 0\")(() => histories.pagination.records === 0);\n}",
  "test/features/api/deposit-history/test_get_deposit_history_info_by_id_and_access_control.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingDepositHistory } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingDepositHistory\";\nimport typia from \"typia\";\n\nexport async function test_api_deposit_history_get_by_id_and_access_control(\n  connection: api.IConnection,\n  otherConnection: api.IConnection\n): Promise<void> {\n  // 1. 예치금 거래 내역을 생성\n  const createInput = {\n    // 실제 DTO에 맞는 최소 입력값이 필요 (입력 타입 추가 정보 필요)\n    // 예: value, source_id 등 필수값 입력\n    value: 10000,\n    source_id: \"test-source-id-123\",\n    // 기타 필수 필드 구성 필요\n  };\n  // 예치금 거래 내역을 생성하는 API 필요, 미정의 시 아래 라인 수정 요망\n  const created: IShoppingDepositHistory = await api.functional.shoppings.customers.deposits.histories.post(\n    connection,\n    createInput as any\n  );\n\n  // 2. 생성된 거래 내역 단건 정상 조회 (본인 연결)\n  const gotten = await api.functional.shoppings.customers.deposits.histories.get(\n    connection,\n    created.id\n  );\n  typia.assert<IShoppingDepositHistory>(gotten);\n  TestValidator.equals(\"own deposit history\")(created)(gotten);\n\n  // 3. 타인 계정으로 동일 거래 내역 조회 (권한 에러 발생 기대)\n  await TestValidator.httpError(\"other user forbidden\")(403,404)(async () => {\n    await api.functional.shoppings.customers.deposits.histories.get(\n      otherConnection,\n      created.id\n    );\n  });\n\n  // 4. 존재하지 않는 ID로 조회 (not found 에러 검증)\n  const unknownId = \"00000000-0000-4000-8000-000000000999\";\n  await TestValidator.httpError(\"not found\")(404)(async () => {\n    await api.functional.shoppings.customers.deposits.histories.get(\n      connection,\n      unknownId\n    );\n  });\n}\n",
  "test/features/api/deposit/test_get_deposit_balance_authenticated_and_unauthenticated.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingCustomer } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCustomer\";\nimport typia from \"typia\";\n\nexport async function test_get_deposit_balance_authenticated_and_unauthenticated(connection: api.IConnection): Promise<void> {\n    // 1. Authenticate customer\n    const customerInput: IShoppingCustomer.ICreate = {\n        channel_code: \"default-channel\",\n        external_user: {\n            citizen: null,\n            application: \"external-app\",\n            uid: \"user-uid-001\",\n            nickname: \"johndoe\",\n            password: \"secure-token-123\",\n            data: {}\n        },\n        href: \"https://test.example.com\",\n        referrer: null,\n        ip: \"127.0.0.1\"\n    };\n    const auth = await api.functional.shoppings.customers.authenticate.post(connection, customerInput);\n    typia.assert<IShoppingCustomer.IAuthorized>(auth);\n    TestValidator.predicate(\"token set\")(!!auth.token.access);\n\n    // 2. Query deposit balance (authenticated)\n    const authenticatedConn = { ...connection, headers: { ...connection.headers, Authorization: `Bearer ${auth.token.access}` } };\n    const balance = await api.functional.shoppings.customers.deposits.histories.balance.get(authenticatedConn);\n    // 응답 타입명 미지정(스키마에 정의 없음)이므로 단순 존재성 체크\n    TestValidator.predicate(\"balance response exists\")(balance !== undefined);\n\n    // 3. Query deposit balance without token (unauthenticated)\n    await TestValidator.httpError(\"no token should fail\")(401, 403)(async () => {\n        await api.functional.shoppings.customers.deposits.histories.balance.get(connection);\n    });\n}\n",
  "test/features/api/mileage-history/test_list_mileage_histories_with_and_without_records.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingCustomer } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCustomer\";\nimport { IShoppingMileageHistory } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingMileageHistory\";\nimport { IShoppingMileageHistory_IRequest } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingMileageHistory.IRequest\";\nimport { IPageIShoppingMileageHistory } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIShoppingMileageHistory\";\nimport typia from \"typia\";\n\nexport async function test_list_mileage_histories_with_and_without_records(connection: api.IConnection): Promise<void> {\n  // 1. 새로운 고객 생성 (인증)\n  const customerInput: IShoppingCustomer.ICreate = {\n    channel_code: \"test-channel\",\n    external_user: {\n      citizen: null,\n      application: \"test-app\",\n      uid: \"test-uid-1\",\n      nickname: \"test-user\",\n      password: \"test-password\",\n      data: {}\n    },\n    href: \"https://test.example.com/\",\n    referrer: null,\n    ip: \"127.0.0.1\"\n  };\n  const auth: IShoppingCustomer.IAuthorized = await api.functional.shoppings.customers.authenticate.post(connection, customerInput);\n  typia.assert<IShoppingCustomer.IAuthorized>(auth);\n  TestValidator.predicate(\"customer id present\")(() => typeof auth.id === \"string\" && auth.id.length > 0);\n\n  // 2. (내역 생성 API 없음, 빈 내역만 검증)\n  const req: IShoppingMileageHistory_IRequest = {};\n  const page: IPageIShoppingMileageHistory = await api.functional.shoppings.customers.mileages.histories.patch(connection, req);\n  typia.assert<IPageIShoppingMileageHistory>(page);\n\n  // 3. 거래 내역이 비어있는 경우 (신규 고객)\n  TestValidator.equals(\"mileage history empty\", (key) => false)([] as IShoppingMileageHistory[])(page.data);\n}\n",
  "test/features/api/mileage-history/test_get_mileage_history_info_by_id_and_access_control.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingMileageHistory } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingMileageHistory\";\nimport typia from \"typia\";\n\nexport async function test_api_mileage_history_get_by_id_and_access_control(\n  connection: api.IConnection,\n  foreignConnection: api.IConnection\n): Promise<void> {\n  // 1. 사전 마일리지 거래 이력 생성 (본인)\n  const input = {\n    // 실제 구조에 맞게 필수 필드 입력 필요 (예시)\n    // mileageId, value, sourceId 등\n  };\n  const history: IShoppingMileageHistory = await api.functional.shoppings.customers.mileages.histories.post(\n    connection,\n    input\n  );\n  typia.assert<IShoppingMileageHistory>(history);\n  // 2. 본인 거래 내역 ID로 정상 조회\n  const gotten = await api.functional.shoppings.customers.mileages.histories.get(\n    connection,\n    history.id\n  );\n  typia.assert<IShoppingMileageHistory>(gotten);\n  TestValidator.equals(\"get own mileage history\")(history)(gotten);\n\n  // 3. 타인 내역 생성 및 본인이 접근 (혹은 본인 내역에 타인 접근 시도)\n  const foreignInput = {\n    // 타인용 거래 이력 입력 (예시)\n  };\n  const foreignHistory: IShoppingMileageHistory = await api.functional.shoppings.customers.mileages.histories.post(\n    foreignConnection,\n    foreignInput\n  );\n  typia.assert<IShoppingMileageHistory>(foreignHistory);\n\n  await TestValidator.httpError(\"access denied for foreign mileage history\")(403, 404)(\n    () => api.functional.shoppings.customers.mileages.histories.get(\n      connection,\n      foreignHistory.id\n    )\n  );\n}\n",
  "test/features/api/customer/test_get_mileage_balance_authenticated_and_unauthenticated.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingCustomer } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCustomer\";\nimport typia from \"typia\";\n\nexport async function test_get_mileage_balance_authenticated_and_unauthenticated(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. 고객 인증 (AccessToken 확보)\n  const channel_code = \"test-channel\";\n  const input: IShoppingCustomer.ICreate = {\n    channel_code,\n    external_user: {\n      citizen: null,\n      application: channel_code,\n      uid: \"externaluser-\" + Date.now(),\n      nickname: \"test-user\",\n      password: \"pass1234\",\n      data: {},\n    },\n    href: \"https://localhost/auth-test\",\n    referrer: null,\n    ip: null,\n  };\n  const authorized = await api.functional.shoppings.customers.authenticate(\n    connection,\n    input,\n  );\n  typia.assert<IShoppingCustomer.IAuthorized>(authorized);\n  TestValidator.predicate(\"must issue access token\")(\n    () => Boolean(authorized.token?.access),\n  );\n\n  // 2. 인증 토큰으로 마일리지 잔액 정상 조회\n  const authedConnection: api.IConnection = {\n    ...connection,\n    headers: {\n      ...(connection.headers ?? {}),\n      Authorization: authorized.setHeaders.Authorization,\n    },\n  };\n  const balance = await api.functional.shoppings.customers.mileages.histories.balance(\n    authedConnection,\n  );\n  // 결과 타입은 명확히 제공된 schema가 없으므로, 결과가 존재하는지만 체크\n  TestValidator.predicate(\"should return balance/no error\")(!!balance || balance === 0);\n\n  // 3. 인증 없이 호출 시 401 오류 체크\n  await TestValidator.httpError(\"must be unauthorized\")(401)(async () => {\n    await api.functional.shoppings.customers.mileages.histories.balance(\n      connection,\n    );\n  });\n}\n",
  "test/features/api/review/test_update_review_answer_success_and_error_cases.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport { IBbsArticle } from \"@ORGANIZATION/PROJECT-api/lib/structures/IBbsArticle\";\nimport { IBbsArticle_ICreate } from \"@ORGANIZATION/PROJECT-api/lib/structures/IBbsArticle.ICreate\";\nimport { IShoppingSaleInquiryAnswer_ISnapshot } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryAnswer.ISnapshot\";\nimport { IShoppingSaleReview } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleReview\";\n\nexport async function test_update_review_answer_success_and_error_cases(connection: api.IConnection): Promise<void> {\n  // 미리 리뷰 정보 준비 (실제로는 리뷰 ID와 saleId가 생성되어 있어야 함)\n  const saleId = \"00000000-0000-4000-8000-000000000001\"; // 테스트용 샘플 UUID\n  const reviewId = \"00000000-0000-4000-8000-000000000002\";\n\n  // 1. 답변 최초 등록\n  const answerInput: IBbsArticle_ICreate = {\n    format: \"md\",\n    title: \"첫 답변 등록\",\n    body: \"리뷰에 대한 판매자의 첫 답변입니다.\",\n    files: [],\n  };\n  const snapshot1 = await api.functional.shoppings.sellers.sales.reviews.answer.put(\n    connection, saleId, reviewId, answerInput\n  );\n  typia.assert<IShoppingSaleInquiryAnswer_ISnapshot>(snapshot1);\n  TestValidator.equals(\"답변 최초 등록 검증\", undefined)({\n    format: answerInput.format,\n    title: answerInput.title,\n    body: answerInput.body,\n    files: answerInput.files,\n  })({\n    format: snapshot1.format,\n    title: snapshot1.title,\n    body: snapshot1.body,\n    files: snapshot1.files,\n  });\n\n  // 2. 답변 수정\n  const answerInput2: IBbsArticle_ICreate = {\n    format: \"md\",\n    title: \"답변 제목 수정\",\n    body: \"리뷰 답변의 수정 내용입니다.\",\n    files: [],\n  };\n  const snapshot2 = await api.functional.shoppings.sellers.sales.reviews.answer.put(\n    connection, saleId, reviewId, answerInput2\n  );\n  typia.assert<IShoppingSaleInquiryAnswer_ISnapshot>(snapshot2);\n  // 새 ISnapshot이 생성되었음을 확인 (id 또는 created_at이 변경됨)\n  TestValidator.predicate(\"답변 수정 후 created_at 변화 체크\")(\n    snapshot2.created_at !== snapshot1.created_at\n  );\n  TestValidator.equals(\"답변 수정 내용 체크\", undefined)({\n    format: answerInput2.format,\n    title: answerInput2.title,\n    body: answerInput2.body,\n    files: answerInput2.files,\n  })({\n    format: snapshot2.format,\n    title: snapshot2.title,\n    body: snapshot2.body,\n    files: snapshot2.files,\n  });\n\n  // 3. 비정상 케이스: 존재하지 않는 리뷰ID\n  const invalidReviewId = \"00000000-0000-4000-8000-FFFFFFFFFFFF\";\n  await TestValidator.httpError(\"없는 리뷰에 대한 답변 등록\", 404)(async () => {\n    await api.functional.shoppings.sellers.sales.reviews.answer.put(\n      connection, saleId, invalidReviewId, answerInput\n    );\n  });\n\n  // 4. 비정상 케이스: 권한 없는 판매자(다른 판매자의 리뷰)\n  const otherSaleId = \"00000000-0000-4000-8000-CCCCCCCCCCCC\";\n  const otherReviewId = \"00000000-0000-4000-8000-DDDDDDDDDDDD\";\n  await TestValidator.httpError(\"권한 없는 리뷰 답변 시도\", 403, 404)(async () => {\n    await api.functional.shoppings.sellers.sales.reviews.answer.put(\n      connection, otherSaleId, otherReviewId, answerInput\n    );\n  });\n}\n",
  "test/features/api/review/test_create_review_comment_success_and_permission_errors.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingSaleInquiryComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment\";\nimport { IShoppingSaleInquiryComment as IShoppingSaleInquiryCommentNamespace } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment\";\nimport typia from \"typia\";\n\nexport async function test_create_review_comment_success_and_permission_errors(connection: api.IConnection): Promise<void> {\n    // 선행: 리뷰/세일/판매자/권한없는판매자 생성(generated, pseudo-code helpers)\n    const sale = await generate_test_sale(connection); // 본인 소유 sale\n    const review = await generate_test_review_inquiry(connection, sale.id); // 해당 sale 연결된 리뷰(inquiry)\n    const seller = await generate_test_seller_login(connection, sale.sellerId); // sale의 seller로 로그인\n    const otherSeller = await generate_another_seller_login(connection); // 권한 없는 판매자 로그인\n\n    // 기존 코멘트 확인(GET API 이용, 중복/상태확인만 목적)\n    const existingComments = await api.functional.shoppings.sellers.sales.reviews.comments.get(\n        seller,\n        sale.id,\n        review.id\n    );\n    typia.assert<IShoppingSaleInquiryComment[]>(existingComments);\n\n    // 정상 케이스 - 판매자 본인이 코멘트 작성\n    const validReq: IShoppingSaleInquiryCommentNamespace.ICreate = {\n        format: \"md\",\n        body: \"리뷰 코멘트 작성 테스트\",\n        files: [\n            {\n                name: \"sample\",\n                extension: \"txt\",\n                url: \"https://cdn.example.com/file1.txt\"\n            }\n        ]\n    };\n    const created = await api.functional.shoppings.sellers.sales.reviews.comments.post(\n        seller,\n        sale.id,\n        review.id,\n        validReq\n    );\n    typia.assert<IShoppingSaleInquiryComment>(created);\n    TestValidator.equals(\"작성된 코멘트 포맷\", (key) => key === \"created_at\" || key === \"id\" || key === \"writer\")(\n        {\n            writer: created.writer,\n            parent_id: created.parent_id,\n            snapshots: created.snapshots,\n        }\n    )({\n        writer: created.writer,\n        parent_id: created.parent_id,\n        snapshots: created.snapshots,\n    });\n\n    // 실패 케이스1: 필수값 누락\n    const invalidReq: Partial<IShoppingSaleInquiryCommentNamespace.ICreate> = {\n        body: \"필수값 누락 테스트\"\n        // format, files 누락\n    };\n    await TestValidator.httpError(\"필수 데이터 누락 시 400 에러\")(400)(async () => {\n        // @ts-expect-error 일부 필드 빠진 입력 intentionally\n        await api.functional.shoppings.sellers.sales.reviews.comments.post(\n            seller,\n            sale.id,\n            review.id,\n            invalidReq as any\n        );\n    });\n\n    // 실패 케이스2: 권한 없는 판매자\n    await TestValidator.httpError(\"권한 없는 판매자의 요청은 403\")(403)(async () => {\n        await api.functional.shoppings.sellers.sales.reviews.comments.post(\n            otherSeller,\n            sale.id,\n            review.id,\n            validReq\n        );\n    });\n}\n",
  "test/features/api/review/test_list_review_comments_with_paging_and_permissions.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport { IShoppingSaleInquiryComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment\";\nimport { IShoppingSaleInquiryComment as IShoppingSaleInquiryCommentRequest } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment.IRequest\";\nimport { IPageIShoppingSaleInquiryComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIShoppingSaleInquiryComment\";\n\nexport async function test_api_review_list_review_comments_with_paging_and_permissions(\n  connection: api.IConnection,\n  saleId: string,\n  inquiryId: string,\n  anotherSellerConnection: api.IConnection,\n): Promise<void> {\n  // 1. 기본 조회 (권한 있는 판매자)\n  const basicInput: Partial<IShoppingSaleInquiryCommentRequest> = {};\n  const basicRes = await api.functional.shoppings.sellers.sales.reviews.comments.patch(\n    connection,\n    saleId,\n    inquiryId,\n    basicInput,\n  );\n  typia.assert<IPageIShoppingSaleInquiryComment>(basicRes);\n  TestValidator.predicate(\"기본 리스트: 데이터 또는 빈 배열, pagination 존재\")(\n    () => Array.isArray(basicRes.data) && basicRes.pagination !== undefined,\n  );\n\n  // 2. 페이징/limit 조합\n  const pageInput: Partial<IShoppingSaleInquiryCommentRequest> = {\n    page: 0,\n    limit: 2,\n  };\n  const pagedRes = await api.functional.shoppings.sellers.sales.reviews.comments.patch(\n    connection,\n    saleId,\n    inquiryId,\n    pageInput,\n  );\n  typia.assert<IPageIShoppingSaleInquiryComment>(pagedRes);\n  TestValidator.predicate(\"paged: limit 반영되고 페이지 정상\")(\n    () => pagedRes.pagination.limit === 2 && pagedRes.pagination.current === 0,\n  );\n\n  // 3. search 조건 nickname, body 등 (아무 조건이나 한 번은 통과하는 값)\n  if (basicRes.data.length > 0 && basicRes.data[0].writer)\n  {\n    const nickname = basicRes.data[0].writer.member?.nickname ?? undefined;\n    const body = basicRes.data[0].snapshots[0]?.body ?? undefined;\n    if (nickname) {\n      const resByNickname = await api.functional.shoppings.sellers.sales.reviews.comments.patch(\n        connection,\n        saleId,\n        inquiryId,\n        {\n          search: { nickname },\n        },\n      );\n      typia.assert<IPageIShoppingSaleInquiryComment>(resByNickname);\n      TestValidator.predicate(\"nickname으로 검색시 결과 존재\")(\n        () => resByNickname.data.some(\n          (c) => c.writer.member?.nickname === nickname,\n        ),\n      );\n    }\n    if (body) {\n      const resByBody = await api.functional.shoppings.sellers.sales.reviews.comments.patch(\n        connection,\n        saleId,\n        inquiryId,\n        {\n          search: { body },\n        },\n      );\n      typia.assert<IPageIShoppingSaleInquiryComment>(resByBody);\n      TestValidator.predicate(\"body로 검색시 결과 존재\")(\n        () => resByBody.data.some(\n          (c) =>\n            c.snapshots.some((s) => s.body === body),\n        ),\n      );\n    }\n  }\n\n  // 4. 존재하지 않는 필터(닉네임/body 등) -> 빈 결과\n  const nonExistRes = await api.functional.shoppings.sellers.sales.reviews.comments.patch(\n    connection,\n    saleId,\n    inquiryId,\n    { search: { nickname: \"__NOT_EXIST__NICKNAME__\" } },\n  );\n  typia.assert<IPageIShoppingSaleInquiryComment>(nonExistRes);\n  TestValidator.equals(\"존재하지 않는 닉네임 검색시 빈 배열\")([] as IShoppingSaleInquiryComment[])(\n    nonExistRes.data,\n  );\n\n  // 5. 존재하지 않는 saleId/inquiryId\n  await TestValidator.httpError(\"존재하지 않는 saleId/inquiryId\")(\n    404,\n  )(() =>\n    api.functional.shoppings.sellers.sales.reviews.comments.patch(\n      connection,\n      \"00000000-0000-0000-0000-000000000000\",\n      \"00000000-0000-0000-0000-000000000000\",\n      {},\n    ),\n  );\n\n  // 6. 접근 권한 없는 판매자\n  await TestValidator.httpError(\"권한 없는 판매자 에러\", 403)(() =>\n    api.functional.shoppings.sellers.sales.reviews.comments.patch(\n      anotherSellerConnection,\n      saleId,\n      inquiryId,\n      {},\n    ),\n  );\n}\n",
  "test/features/api/review/test_get_review_comment_detail_id_not_found_or_not_owned.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingSaleInquiryComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment\";\nimport typia from \"typia\";\n\nimport { v4 as uuidv4 } from \"uuid\";\n\n/*\n 이 테스트는 다음 시나리오를 모두 다룹니다.\n - 정상적 코멘트 상세 정보 조회 (본인/판매자)\n - 존재하지 않는 코멘트ID 조회 시 404\n - 타인(본인 소유 아님) 코멘트ID 조회 시 403\n*/\n\nexport async function test_api_get_review_comment_detail_id_not_found_or_not_owned(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. 준비: 테스트용 saleId, inquiryId, commentId를 할당합니다.\n  // 실제 코멘트/리뷰/판매 생성 API가 없다면 임의 값 사용합니다.\n  const saleId = uuidv4();\n  const inquiryId = uuidv4();\n  const myCommentId = uuidv4();\n  const otherCommentId = uuidv4(); // 타인 소유 코멘트(예시)\n  const notFoundCommentId = uuidv4(); // 존재하지 않는 코멘트ID\n\n  // 2. 정상적 상세 조회 (실제 데이터가 없어 가상의 응답을 예상한다고 가정)\n  /*\n  // 만약 실제 사전 데이터 생성이 가능한 경우 아래처럼 처리:\n  const created = await api.functional.shoppings.sellers.sales.reviews.comments.create(connection, { ... });\n  const saleId = created.saleId;\n  const inquiryId = created.inquiryId;\n  const myCommentId = created.id;\n  */\n\n  // 정상 케이스: 올바른 정보로 상세 조회 요청\n  // (응답 모킹 또는 실제 데이터 필요)\n  // 테스트 실행 환경에서 실제로 아래 호출이 성공해서 값이 리턴되어야 합니다.\n  // 없는 데이터에선 실패할 수 있습니다.\n  await TestValidator.httpError(\"코멘트 미존재 404\")(404)(async () => {\n    await api.functional.shoppings.sellers.sales.reviews.comments.at(\n      connection,\n      saleId,\n      inquiryId,\n      notFoundCommentId,\n    );\n  });\n\n  await TestValidator.httpError(\"타인 소유시 403\")(403)(async () => {\n    await api.functional.shoppings.sellers.sales.reviews.comments.at(\n      connection,\n      saleId,\n      inquiryId,\n      otherCommentId,\n    );\n  });\n\n  // 실제 정상 데이터가 준비되어 있을 때만 아래 블록이 정상 동작합니다.\n  // 그렇지 않으면 skip, 또는 환경 셋업 필요\n  // 정상 시, 타입/값 검증\n  /*\n  const result = await api.functional.shoppings.sellers.sales.reviews.comments.at(\n    connection,\n    saleId,\n    inquiryId,\n    myCommentId,\n  );\n  typia.assert<IShoppingSaleInquiryComment>(result);\n  // 상세 데이터 검증은 상황에 맞춰 기대값 지정해 비교합니다.\n  TestValidator.equals(\"코멘트 상세\", () => true)(expectedComment)(result);\n  */\n}\n",
  "test/features/api/review-comment/test_update_review_comment_success_and_not_owner_or_invalid_id.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingSaleInquiryComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment\";\nimport { IShoppingSaleInquiryComment as InquiryComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment\";\nimport typia from \"typia\";\n\nexport async function test_update_review_comment_success_and_not_owner_or_invalid_id(\n  connection: api.IConnection\n): Promise<void> {\n  // 가정: 아래 값들은 사전 fixture 또는 테스트 환경에서 유효하게 준비되어 있다고 본다.\n  // 실제 환경에서는 별도 생성 API 사용 또는 fixture 활용 권장\n  const ownerSaleId = \"00000000-0000-0000-0000-000000000001\";\n  const notOwnerSaleId = \"00000000-0000-0000-0000-000000000002\";\n  const inquiryId = \"00000000-0000-0000-0000-000000001000\";\n  const commentId = \"00000000-0000-0000-0000-000010000000\";\n  const invalidCommentId = \"ffffffff-ffff-ffff-ffff-ffffffffffff\";\n\n  // 1. 수정 전 코멘트 조회 및 실제로 리소스 소유권(판매자) 검증\n  const before = await api.functional.shoppings.sellers.sales.reviews.comments.get(\n    connection,\n    ownerSaleId,\n    inquiryId,\n    commentId\n  );\n  typia.assert<InquiryComment>(before);\n  TestValidator.equals(\"before.id = commentId\")<string>(commentId)(before.id);\n  // 코멘트 snapshots 개수 기억\n  const prevSnapshotsLength = before.snapshots.length;\n\n  // 2. 정상 수정 - 본인 소유 리뷰 코멘트\n  const update: InquiryComment.ICreate = {\n    format: \"txt\",\n    body: \"수정된 내 코멘트 내용\",\n    files: [],\n  };\n  const updated = await api.functional.shoppings.sellers.sales.reviews.comments.put(\n    connection,\n    ownerSaleId,\n    inquiryId,\n    commentId,\n    update\n  );\n  typia.assert<InquiryComment.ISnapshot>(updated);\n  TestValidator.equals(\"body updated\")<string>(update.body)(updated.body);\n  // snapshot 이 1개 추가되었는지 재확인\n  const after = await api.functional.shoppings.sellers.sales.reviews.comments.get(\n    connection,\n    ownerSaleId,\n    inquiryId,\n    commentId\n  );\n  typia.assert<InquiryComment>(after);\n  TestValidator.equals(\"snapshots length increased by 1\")<number>(prevSnapshotsLength + 1)(after.snapshots.length);\n\n  // 3. 소유권 없는 판매자가 동일 코멘트 수정 시도 -> 403/404 에러 기대\n  await TestValidator.httpError(\"not owner forbidden or not found\")(403,404)(async () =>\n    api.functional.shoppings.sellers.sales.reviews.comments.put(\n      connection,\n      notOwnerSaleId,\n      inquiryId,\n      commentId,\n      update\n    )\n  );\n\n  // 4. 잘못된/존재하지 않는 코멘트 id로 PUT 시도 -> 404 에러 예상\n  await TestValidator.httpError(\"invalid comment id\")(404,400)(async () =>\n    api.functional.shoppings.sellers.sales.reviews.comments.put(\n      connection,\n      ownerSaleId,\n      inquiryId,\n      invalidCommentId,\n      update\n    )\n  );\n}\n",
  "test/features/api/review/test_list_all_reviews_of_sale_success_and_permission_filtering.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport { IShoppingSaleReview } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleReview\";\nimport { IPageIShoppingSaleReview } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIShoppingSaleReview\";\n\nexport async function test_list_all_reviews_of_sale_success_and_permission_filtering(connection: api.IConnection): Promise<void> {\n  // 사전에 유효한 saleId와 임의로 리뷰가 여러 개 존재하는 상태를 가정\n  const saleId = \"some-valid-sale-uuid\"; // 실제로는 fixture나 사전생성 필요\n\n  // 1. 기본 호출(파라미터 최소)\n  const baseReq: IShoppingSaleReview.IRequest = {};\n  const basicRes = await api.functional.shoppings.sellers.sales.reviews.patch(connection, saleId, baseReq);\n  typia.assert<IPageIShoppingSaleReview.ISummary>(basicRes);\n  TestValidator.predicate(\"data length matches records\")(() => basicRes.data.length <= basicRes.pagination.records);\n\n  // 2. page/limit 조정\n  const pageLimitReq: IShoppingSaleReview.IRequest = { page: 0, limit: 2 };\n  const pagingRes = await api.functional.shoppings.sellers.sales.reviews.patch(connection, saleId, pageLimitReq);\n  typia.assert<IPageIShoppingSaleReview.ISummary>(pagingRes);\n  TestValidator.predicate(\"limit respected\")(() => pagingRes.data.length <= 2);\n  TestValidator.equals(\"current page matches\")(0)(pagingRes.pagination.current);\n\n  // 3. 검색(search) 조합\n  const searchReq: IShoppingSaleReview.IRequest = { search: { score: null, title: \"\" } };\n  const searchRes = await api.functional.shoppings.sellers.sales.reviews.patch(connection, saleId, searchReq);\n  typia.assert<IPageIShoppingSaleReview.ISummary>(searchRes);\n  TestValidator.equals(\"search data check\")(\n    searchRes.data.filter(r => !!r.title && r.title.includes(\"\")).length\n  )(searchRes.data.length);\n\n  // 4. 정렬(sort) 테스트\n  const sortReq: IShoppingSaleReview.IRequest = { sort: [\"-created_at\"] };\n  const sortRes = await api.functional.shoppings.sellers.sales.reviews.patch(connection, saleId, sortReq);\n  typia.assert<IPageIShoppingSaleReview.ISummary>(sortRes);\n  const sorted = [...sortRes.data].sort((a, b) => b.created_at.localeCompare(a.created_at));\n  TestValidator.equals(\"sorted descending by created_at\")(sorted)(sortRes.data);\n\n  // 5. 비인가 사용자 (권한 없음)\n  await TestValidator.httpError(\"permission denied\")(403)(async () => {\n    const anonConn = { ...connection, accessToken: \"invalid-token\" };\n    await api.functional.shoppings.sellers.sales.reviews.patch(anonConn, saleId, baseReq);\n  });\n\n  // 6. 부적합 파라미터(limit < 0)\n  await TestValidator.httpError(\"invalid parameter\")(400)(async () => {\n    await api.functional.shoppings.sellers.sales.reviews.patch(connection, saleId, { limit: -1 });\n  });\n}\n",
  "test/features/api/review/test_list_abridged_reviews_of_sale_with_various_conditions.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingSaleReview } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleReview\";\nimport { IPageIShoppingSaleReview } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIShoppingSaleReview\";\nimport typia from \"typia\";\n\nexport async function test_api_review_abridge_list_conditions(connection: api.IConnection): Promise<void> {\n  // Prerequisite: Assume a valid saleId and seller connection (sellerConn), and a non-seller connection (visitorConn) exist.\n  const saleId = \"00000000-0000-0000-0000-000000000001\"; // Use actual or mocked saleId\n\n  // 기본 조회 - 첫 페이지, 디폴트 limit, 정렬 없음\n  const req1: IShoppingSaleReview.IRequest = { page: 0, limit: 10, search: null, sort: null };\n  const page1 = await api.functional.shoppings.sellers.sales.reviews.abridges.patch(connection, saleId, req1);\n  typia.assert<IPageIShoppingSaleReview.IAbridge>(page1);\n  TestValidator.predicate(\"pagination valid\")(page1.pagination.pages >= 1);\n  TestValidator.predicate(\"data array valid\")(Array.isArray(page1.data));\n  page1.data.forEach((review) => typia.assert<IShoppingSaleReview.IAbridge>(review));\n\n  // 페이징: limit 변경\n  const req2: IShoppingSaleReview.IRequest = { page: 0, limit: 5 /* half */, search: null, sort: null };\n  const page2 = await api.functional.shoppings.sellers.sales.reviews.abridges.patch(connection, saleId, req2);\n  typia.assert<IPageIShoppingSaleReview.IAbridge>(page2);\n  TestValidator.predicate(\"limit respected\")(page2.data.length <= 5);\n\n  // 정렬: score 내림차순\n  const req3: IShoppingSaleReview.IRequest = { page: 0, limit: 10, search: null, sort: [\"-score\"] };\n  const page3 = await api.functional.shoppings.sellers.sales.reviews.abridges.patch(connection, saleId, req3);\n  typia.assert<IPageIShoppingSaleReview.IAbridge>(page3);\n  if (page3.data.length > 1) {\n    for (let i = 1; i < page3.data.length; ++i) {\n      TestValidator.predicate(\"desc score order\")(page3.data[i - 1].score >= page3.data[i].score);\n    }\n  }\n\n  // 검색: answered filter(답변 여부)\n  const req4: IShoppingSaleReview.IRequest = {\n    page: 0, limit: 10,\n    search: { answered: true, name: null, nickname: null, title: null, body: null, title_or_body: null, from: null, to: null, minimum: null, maximum: null },\n    sort: null\n  };\n  const page4 = await api.functional.shoppings.sellers.sales.reviews.abridges.patch(connection, saleId, req4);\n  typia.assert<IPageIShoppingSaleReview.IAbridge>(page4);\n  page4.data.forEach((review) => TestValidator.predicate(\"answered review\")(!!review.answer));\n\n  // 권한 없는 연동(DB: visitorConn), 접근 거부 허용(403 or 401)\n  const visitorConn = { ...connection, token: \"forbidden-visitor\" } as api.IConnection;\n  await TestValidator.httpError(\"no seller access\")(401, 403)(() =>\n    api.functional.shoppings.sellers.sales.reviews.abridges.patch(visitorConn, saleId, req1)\n  );\n}\n",
  "test/features/api/review/test_get_review_detail_success_and_error_cases.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport { IShoppingSaleReview } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleReview\";\n\nexport async function test_get_review_detail_success_and_error_cases(connection: api.IConnection): Promise<void> {\n    // 준비: 판매자/리뷰/타 판매자 연결(Assume helper create functions exist)\n    const sellerConnection = await prepare_seller_connection();\n    const otherSellerConnection = await prepare_other_seller_connection();\n    const { saleId, reviewId } = await prepare_review_with_sale_and_ids(sellerConnection);\n\n    // --- 성공 케이스: 올바른 리뷰 상세 조회 ---\n    const review = await api.functional.shoppings.sellers.sales.reviews.get(\n      sellerConnection, saleId, reviewId\n    );\n    typia.assert<IShoppingSaleReview>(review);\n    TestValidator.equals(\"review.id\")(reviewId)(review.id);\n    TestValidator.equals(\"review.sale id 존재 여부\")(true)(!!saleId);\n    TestValidator.predicate(\"snapshots의 최소 1건 존재\")(() => Array.isArray(review.snapshots) && review.snapshots.length > 0);\n\n    // --- 실패 케이스: 존재하지 않는 리뷰로 조회 시 404 반환 ---\n    await TestValidator.httpError(\"존재하지 않는 리뷰 404\")(404)(\n      () => api.functional.shoppings.sellers.sales.reviews.get(\n        sellerConnection,\n        \"00000000-0000-0000-0000-000000000000\",\n        \"11111111-1111-1111-1111-111111111111\"\n      )\n    );\n\n    // --- 실패 케이스: 다른 판매자가 타인의 리뷰 조회 시 403 반환 ---\n    await TestValidator.httpError(\"타판매자 접근 403\")(403)(\n      () => api.functional.shoppings.sellers.sales.reviews.get(\n        otherSellerConnection, saleId, reviewId\n      )\n    );\n}\n\n// assume these helpers are implemented properly in test base:\n// async function prepare_seller_connection(): Promise<api.IConnection>\n// async function prepare_other_seller_connection(): Promise<api.IConnection>\n// async function prepare_review_with_sale_and_ids(connection: api.IConnection): Promise<{saleId: string, reviewId: string}>\n",
  "test/features/api/shopping-sale-snapshot/test_create_snapshot_replica_success_already_exists_and_permission.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingSaleSnapshot } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleSnapshot\";\nimport { IShoppingSale } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSale\";\nimport typia from \"typia\";\n\nexport async function test_create_snapshot_replica_success_already_exists_and_permission(\n  connection: api.IConnection,\n  saleId: string,\n  snapshotId: string,\n  unauthorizedConnection: api.IConnection\n): Promise<void> {\n  // Step 1: 존재 확인 (사전 조건)\n  const snapshot = await api.functional.shoppings.sellers.sales.snapshots.get(\n    connection, saleId, snapshotId\n  );\n  typia.assert<IShoppingSaleSnapshot>(snapshot);\n\n  // Step 2: 정상 복제 요청\n  const replica = await api.functional.shoppings.sellers.sales.snapshots.replica.post(\n    connection, saleId, snapshotId\n  );\n  // 복제는 신규 sale 생성 타이핑 정보를 반환한다\n  typia.assert<IShoppingSale.ICreate>(replica);\n  TestValidator.predicate(\"replica must match type\")(() => typeof replica.section_code === \"string\");\n\n  // Step 3: 이미 복제한 스냅샷으로 재요청하면 에러 기대\n  await TestValidator.httpError(\"duplicate snapshot replica prevents re-creation\")(409)( // 409 Conflict\n    () => api.functional.shoppings.sellers.sales.snapshots.replica.post(\n      connection, saleId, snapshotId\n    )\n  );\n\n  // Step 4: 권한 없는 판매자가 요청할 때 에러 기대\n  await TestValidator.httpError(\"no permission to replicate snapshot\")(403, 401)( // 403 Forbidden, 401 Unauthorized\n    () => api.functional.shoppings.sellers.sales.snapshots.replica.post(\n      unauthorizedConnection, saleId, snapshotId\n    )\n  );\n}\n",
  "test/features/api/shopping-sale-snapshot/test_list_snapshots_of_sale_with_paging_and_permissions.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport { IPageIShoppingSaleSnapshot } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIShoppingSaleSnapshot\";\nimport { IPage } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPage\";\n\nexport async function test_api_list_snapshots_of_sale_with_paging_and_permissions(connection: api.IConnection): Promise<void> {\n    // 1. 정상 케이스: 권한 있는 판매자의 saleId와 여러 스냅샷을 준비\n    const validSaleId = \"11111111-1111-1111-1111-111111111111\";\n    // 여러 스냅샷이 있는 sale라고 가정하여 진행\n    // 실제 환경에서는 sale 생성/스냅샷 생성 보장 필요 (여기서는 값 하드코딩)\n    // 기본 페이지 요청\n    const basicPageReq: IPage.IRequest = { page: 0, limit: 10 };\n    const res = await api.functional.shoppings.sellers.sales.snapshots.patch(\n        connection,\n        validSaleId,\n        basicPageReq\n    );\n    typia.assert<IPageIShoppingSaleSnapshot.ISummary>(res);\n    TestValidator.equals(\"pagination.current\")(0)(res.pagination.current);\n    TestValidator.equals(\"pagination.limit\")(10)(res.pagination.limit);\n    TestValidator.predicate(\"at least 2 snapshots\")(() => res.data.length >= 2);\n    TestValidator.predicate(\"all saleId match\")(() => res.data.every(s => s.id === validSaleId));\n\n    // 2. 페이징 검증: 다른 limit/page 조합, null 등\n    const pageReq1: IPage.IRequest = { page: 1, limit: 1 };\n    const res2 = await api.functional.shoppings.sellers.sales.snapshots.patch(\n        connection,\n        validSaleId,\n        pageReq1\n    );\n    typia.assert<IPageIShoppingSaleSnapshot.ISummary>(res2);\n    TestValidator.equals(\"pagination.current\")(1)(res2.pagination.current);\n    TestValidator.equals(\"pagination.limit\")(1)(res2.pagination.limit);\n    TestValidator.predicate(\"one snapshot on limit 1\")(() => res2.data.length === 1);\n\n    // 3. page/limit null 처리\n    const nullReq: IPage.IRequest = { page: null, limit: null };\n    const res3 = await api.functional.shoppings.sellers.sales.snapshots.patch(\n        connection,\n        validSaleId,\n        nullReq\n    );\n    typia.assert<IPageIShoppingSaleSnapshot.ISummary>(res3);\n    TestValidator.predicate(\"saleId match and response exists\")(() => res3.data.every(s => s.id === validSaleId));\n\n    // 4. 비정상 입력: 음수, 0 limit\n    const badReq: IPage.IRequest = { page: -1, limit: -10 };\n    await TestValidator.httpError(\"negative page/limit should fail\")(400)(\n        () => api.functional.shoppings.sellers.sales.snapshots.patch(connection, validSaleId, badReq)\n    );\n    // 0 limit도 보장 (혹은 최소값이 1인지 환경에 따라 검증 추가)\n    const zeroLimitReq: IPage.IRequest = { page: 0, limit: 0 };\n    await TestValidator.httpError(\"zero limit should fail\")(400)(\n        () => api.functional.shoppings.sellers.sales.snapshots.patch(connection, validSaleId, zeroLimitReq)\n    );\n\n    // 5. 권한 없는 판매자(타 판매자) 혹은 일반 사용자/비로그인 연결로 접근\n    // 다른 판매자 connection, 비로그인 connection 은 별도 준비 가정됨\n    const otherSellerConnection = { ...connection, headers: { authorization: \"Bearer other-seller-token\" } };\n    await TestValidator.httpError(\"other seller forbidden\")(403, 401)(\n        () => api.functional.shoppings.sellers.sales.snapshots.patch(otherSellerConnection as any, validSaleId, basicPageReq)\n    );\n    const noLoginConnection = { ...connection, headers: {} };\n    await TestValidator.httpError(\"unauthorized\")(401)(\n        () => api.functional.shoppings.sellers.sales.snapshots.patch(noLoginConnection as any, validSaleId, basicPageReq)\n    );\n\n    // 6. 데이터 없음(page beyond range)\n    const tooHighPageReq: IPage.IRequest = { page: 99, limit: 10 };\n    const res4 = await api.functional.shoppings.sellers.sales.snapshots.patch(\n        connection,\n        validSaleId,\n        tooHighPageReq\n    );\n    typia.assert<IPageIShoppingSaleSnapshot.ISummary>(res4);\n    TestValidator.equals(\"empty result on out-of-range page\")([] as typeof res4.data)(res4.data);\n}\n",
  "test/features/api/shopping-sale-snapshot/test_get_snapshot_detail_success_and_invalid_cases.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport { IShoppingSaleSnapshot } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleSnapshot\";\n\nexport async function test_get_snapshot_detail_success_and_invalid_cases(connection: api.IConnection): Promise<void> {\n    // 📌 1. 선행데이터 생성: 판매자 및 세일, 실제 스냅샷\n    // 전제: 테스트 환경에서 아래 두 helper는 반드시 존재한다 가정\n    const sellerConnection = await generate_seller_connection();\n    const otherSellerConnection = await generate_seller_connection();\n    const { saleId, snapshotId, snapshotData } = await create_sale_and_snapshot(sellerConnection);\n\n    // 📌 2. 정상 케이스: 판매자가 본인 세일의 스냅샷 상세조회\n    const result = await api.functional.shoppings.sellers.sales.snapshots.get(\n        sellerConnection, saleId, snapshotId\n    );\n    typia.assert<IShoppingSaleSnapshot>(result);\n    TestValidator.equals(\"snapshot detail: main fields\")((key) => false)(result)(snapshotData);\n    // 주요 필드값 일치 검증 (id, latest, content, units 등)\n    TestValidator.equals(\"snapshot.id\")(result.id)(snapshotId);\n    TestValidator.equals(\"snapshot.saleId\")(result.id)(snapshotData.id);\n    TestValidator.equals(\"snapshot.latest\")(result.latest)(snapshotData.latest);\n    // Content 필드 객체\n    typia.assert<IShoppingSaleSnapshot[\"content\"]>(result.content);\n    \n    // 📌 3-1. 비정상: 존재하지 않는 snapshot id로 조회 (404)\n    const invalidSnapshotId = \"00000000-0000-0000-0000-000000000000\";\n    await TestValidator.httpError(\"not found, invalid snapshot id\")(404)(() => \n        api.functional.shoppings.sellers.sales.snapshots.get(\n            sellerConnection, saleId, invalidSnapshotId\n        )\n    );\n\n    // 📌 3-2. 비정상: 다른 판매자가 본인 snapshot에 접근 (403 또는 404)\n    await TestValidator.httpError(\"forbidden/404 other seller cannot access snapshot\")(403,404)(() => \n        api.functional.shoppings.sellers.sales.snapshots.get(\n            otherSellerConnection, saleId, snapshotId\n        )\n    );\n}\n",
  "test/features/api/shopping-sale-snapshot/test_get_flipped_snapshot_info_success_and_error.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingSale } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSale\";\nimport { IShoppingSaleSnapshot } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleSnapshot\";\nimport typia from \"typia\";\n\nexport async function test_api_get_flipped_snapshot_info_success_and_error(connection: api.IConnection): Promise<void> {\n    // 가정: 테스트용 saleId/snapshotId 확보 (fixture 또는 사전 등록 자료)\n    // 일반적으로는 테스트 setup 함수에서 필요한 saleId/snapshotId를 준비\n    const validSaleId = \"11111111-1111-1111-1111-111111111111\";\n    const validSnapshotId = \"22222222-2222-2222-2222-222222222222\";\n\n    // 1. 의존성 체크: 스냅샷이 실제 존재하는지 확인\n    const snapshot = await api.functional.shoppings.sellers.sales.snapshots.at(\n        connection, validSaleId, validSnapshotId\n    );\n    typia.assert<IShoppingSaleSnapshot>(snapshot);\n\n    // 2. 정상 플립 정보 요청\n    const flipped = await api.functional.shoppings.sellers.sales.snapshots.flip(\n        connection, validSaleId, validSnapshotId\n    );\n    typia.assert<IShoppingSale>(flipped);\n\n    // 키 일부 제외 후 비교용 함수(주요 필드만)\n    const exceptKeys = (key: string) =>\n        key === \"created_at\" || key === \"updated_at\" || key === \"paused_at\" || key === \"suspended_at\" || key === \"opened_at\" || key === \"closed_at\";\n    TestValidator.predicate(\"flipped sale id matches snapshot sale id\")(() => flipped.id === snapshot.id);\n    TestValidator.predicate(\"flipped snapshot_id matches snapshot id\")(() => flipped.snapshot_id === snapshot.snapshot_id);\n\n    // 3. 잘못된 saleId, snapshotId 조합(404)\n    const wrongSaleId = \"deadbeef-dead-beef-dead-beefdeadbeef\";\n    const wrongSnapshotId = \"cafebabe-cafe-babe-cafe-babecafebabe\";\n    await TestValidator.httpError(\"invalid saleId returns 404\")(404)(() =>\n        api.functional.shoppings.sellers.sales.snapshots.flip(\n            connection, wrongSaleId, validSnapshotId));\n    await TestValidator.httpError(\"invalid snapshotId returns 404\")(404)(() =>\n        api.functional.shoppings.sellers.sales.snapshots.flip(\n            connection, validSaleId, wrongSnapshotId));\n\n    // 4. 권한 없는 경우\n    // (scope 상, 별도 connection이 필요—생략 또는 mock user 활용)\n    // await TestValidator.httpError(\"unauthorized access returns 403\")(403)(() =>\n    //     api.functional.shoppings.sellers.sales.snapshots.flip(otherUserConnection, validSaleId, validSnapshotId));\n}\n",
  "test/features/api/shopping/test_create_supplement_for_stock_unit_success_duplicate_error_permission.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport { IShoppingSaleSnapshot } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleSnapshot\";\nimport { IShoppingSaleUnitStockSupplement } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleUnitStockSupplement\";\n\nexport async function test_create_supplement_for_stock_unit_success_duplicate_error_permission(\n  sellerConnection: api.IConnection,\n  unauthorizedConnection: api.IConnection,\n  params: {\n    saleId: string;\n    unitId: string;\n    stockId: string;\n    snapshotId: string;\n  },\n): Promise<void> {\n  // Precondition: Ensure the stock and snapshot exist\n  const snapshot = await api.functional.shoppings.sellers.sales.snapshots.get(\n    sellerConnection,\n    params.saleId,\n    params.snapshotId,\n  );\n  typia.assert<IShoppingSaleSnapshot>(snapshot);\n  TestValidator.predicate(\"snapshot.units 존재 확인\")(\n    Array.isArray(snapshot.units) && snapshot.units.length > 0,\n  );\n  const foundUnit = snapshot.units.find((u) => u.id === params.unitId);\n  TestValidator.predicate(\"unit 존재 확인\")(!!foundUnit);\n  const foundStock = foundUnit?.stocks.find((s) => s.id === params.stockId);\n  TestValidator.predicate(\"stock 존재 확인\")(!!foundStock);\n\n  // 1. 정상 supplement 등록\n  const supplementInput: IShoppingSaleUnitStockSupplement.ICreate = {\n    value: 10,\n  };\n  const created = await api.functional.shoppings.sellers.sales.units.stocks.supplements.post(\n    sellerConnection,\n    params.saleId,\n    params.unitId,\n    params.stockId,\n    { body: supplementInput },\n  );\n  typia.assert<IShoppingSaleUnitStockSupplement>(created);\n  TestValidator.equals(\"supplement value 동일성 확인\")(\n    supplementInput.value,\n  )(created.value);\n\n  // 2. 중복 supplement 등록(같은 값)\n  await TestValidator.httpError(\"supplement 중복 등록 에러 발생\")(409)(\n    async () =>\n      await api.functional.shoppings.sellers.sales.units.stocks.supplements.post(\n        sellerConnection,\n        params.saleId,\n        params.unitId,\n        params.stockId,\n        { body: supplementInput },\n      ),\n  );\n\n  // 3. 권한 없는 사용자 supplement 등록 시도\n  await TestValidator.httpError(\"권한 없는 사용자 supplement 생성 실패\")(403)(\n    async () =>\n      await api.functional.shoppings.sellers.sales.units.stocks.supplements.post(\n        unauthorizedConnection,\n        params.saleId,\n        params.unitId,\n        params.stockId,\n        { body: supplementInput },\n      ),\n  );\n}\n",
  "test/features/api/shopping/test_list_all_supplements_for_stock_unit_with_conditions.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport { IPageIShoppingSaleUnitStockSupplement } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIShoppingSaleUnitStockSupplement\";\nimport { IShoppingSaleUnitStockSupplement } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleUnitStockSupplement\";\nimport { IShoppingSaleUnitStockSupplement_IRequest } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleUnitStockSupplement.IRequest\";\n\nexport async function test_api_list_all_supplements_for_stock_unit_with_conditions(connection: api.IConnection): Promise<void> {\n    // Prerequisites: Assume existence of saleId/unitId/stockId with at least two supplements\n    const saleId = \"test-sale-id-1234\";\n    const unitId = \"test-unit-id-1234\";\n    const stockId = \"test-stock-id-1234\";\n\n    // 1. List all supplements (no filter)\n    const resAll = await api.functional.shoppings.sellers.sales.units.stocks.supplements.patch(\n        connection,\n        saleId,\n        unitId,\n        stockId,\n        {\n            sort: null,\n            page: null,\n            limit: null,\n        } as IShoppingSaleUnitStockSupplement_IRequest\n    );\n    typia.assert<IPageIShoppingSaleUnitStockSupplement>(resAll);\n    TestValidator.predicate(\"should have supplements\")(() => Array.isArray(resAll.data));\n\n    // 2. Pagination: limit 1\n    const resPage = await api.functional.shoppings.sellers.sales.units.stocks.supplements.patch(\n        connection,\n        saleId,\n        unitId,\n        stockId,\n        {\n            sort: null,\n            page: 0,\n            limit: 1,\n        }\n    );\n    typia.assert<IPageIShoppingSaleUnitStockSupplement>(resPage);\n    TestValidator.equals(\"limit = 1 should return a single record\")<IShoppingSaleUnitStockSupplement[]>(\n        [resAll.data[0]]\n    )(resPage.data);\n    TestValidator.equals(\"pagination info: current page\")(\n        0\n    )(resPage.pagination.current);\n    TestValidator.equals(\"pagination info: limit\")(\n        1\n    )(resPage.pagination.limit);\n\n    // 3. Sorting: descending by created_at\n    const resSorted = await api.functional.shoppings.sellers.sales.units.stocks.supplements.patch(\n        connection,\n        saleId,\n        unitId,\n        stockId,\n        {\n            sort: [\"-created_at\"],\n            page: 0,\n            limit: null,\n        }\n    );\n    typia.assert<IPageIShoppingSaleUnitStockSupplement>(resSorted);\n    // Check that first item's created_at >= second if more than one record\n    if (resSorted.data.length > 1) {\n        TestValidator.predicate(\"Sorted descending by created_at\")(\n            () => new Date(resSorted.data[0].created_at) >= new Date(resSorted.data[1].created_at),\n        );\n    }\n\n    // 4. Unauthorized access: simulate with connection lacking seller rights\n    await TestValidator.httpError(\"Unauthorized access should fail\")(401)(async () => {\n        const fakeConnection = { ...connection, headers: { ...connection.headers, authorization: \"Bearer invalid\" } };\n        await api.functional.shoppings.sellers.sales.units.stocks.supplements.patch(\n            // @ts-expect-error - purposely pass bad connection\n            fakeConnection,\n            saleId,\n            unitId,\n            stockId,\n            { sort: null, page: null, limit: null }\n        );\n    });\n\n    // 5. Empty result: stockId with no supplements\n    const emptyStockId = \"test-stock-no-supplement\";\n    const resEmpty = await api.functional.shoppings.sellers.sales.units.stocks.supplements.patch(\n        connection,\n        saleId,\n        unitId,\n        emptyStockId,\n        { sort: null, page: null, limit: null }\n    );\n    typia.assert<IPageIShoppingSaleUnitStockSupplement>(resEmpty);\n    TestValidator.equals(\"should be empty array\")<IShoppingSaleUnitStockSupplement[]>(\n        [] as IShoppingSaleUnitStockSupplement[]\n    )(resEmpty.data);\n}\n",
  "test/features/api/supplement/test_update_supplement_success_not_owner_error_not_found.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport { IShoppingSaleUnitStockSupplement } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleUnitStockSupplement\";\n\nexport async function test_api_update_supplement_success_not_owner_error_not_found(connection: api.IConnection): Promise<void> {\n  // 테스트 대상 supplement 정보 준비 (본인 소유)\n  const saleId = \"11111111-1111-1111-1111-111111111111\";\n  const unitId = \"22222222-2222-2222-2222-222222222222\";\n  const stockId = \"33333333-3333-3333-3333-333333333333\";\n  const supplementId = \"44444444-4444-4444-4444-444444444444\";\n\n  // GET: 사전 supplement 정보 가져오기 (존재 및 본인 소유권 확인)\n  let supplement: IShoppingSaleUnitStockSupplement | null = null;\n  try {\n    supplement = await api.functional.shoppings.sellers.sales.units.stocks.supplements.get(\n      connection,\n      saleId,\n      unitId,\n      stockId,\n      supplementId\n    );\n  } catch(e) {\n    // 데이터 없으면 대상 supplement 추가 필요 (setup 영역, 실제로는 fixture/from API 필요)\n    throw new Error(\"사전 데이터가 존재해야 합니다.\");\n  }\n  typia.assert<IShoppingSaleUnitStockSupplement>(supplement);\n\n  // 1) 정상 put (본인 supplement)\n  const updateInput: IShoppingSaleUnitStockSupplement.ICreate = { value: (supplement.value || 1) + 7 };\n  await api.functional.shoppings.sellers.sales.units.stocks.supplements.put(\n    connection,\n    saleId,\n    unitId,\n    stockId,\n    supplementId,\n    updateInput\n  );\n  // PUT 응답은 body 없음 (204 expected)\n  // 실제 값 변경 확인 (GET)\n  const after = await api.functional.shoppings.sellers.sales.units.stocks.supplements.get(\n    connection,\n    saleId,\n    unitId,\n    stockId,\n    supplementId\n  );\n  TestValidator.equals(\"value 변경됨\")<number>(updateInput.value)(after.value);\n\n  // 2) 타인 소유 supplement 인 경우 (saleId 등만 변경한다고 가정)\n  const otherSaleId = \"55555555-5555-5555-5555-555555555555\";\n  const otherUnitId = \"66666666-6666-6666-6666-666666666666\";\n  const otherStockId = \"77777777-7777-7777-7777-777777777777\";\n  const otherSuppId = \"88888888-8888-8888-8888-888888888888\";\n\n  await TestValidator.httpError(\"본인 supplement가 아니면 권한 오류여야 함\")(401, 403)(async () => {\n    await api.functional.shoppings.sellers.sales.units.stocks.supplements.put(\n      connection,\n      otherSaleId,\n      otherUnitId,\n      otherStockId,\n      otherSuppId,\n      updateInput\n    );\n  });\n\n  // 3) 존재하지 않는 supplementId\n  const notFoundId = \"99999999-9999-9999-9999-999999999999\";\n  await TestValidator.httpError(\"존재하지 않는 supplementId는 404\")(404)(async () => {\n    await api.functional.shoppings.sellers.sales.units.stocks.supplements.put(\n      connection,\n      saleId,\n      unitId,\n      stockId,\n      notFoundId,\n      updateInput\n    );\n  });\n}\n",
  "test/features/api/supplement/test_delete_supplement_success_not_owner_not_found.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\n\nexport async function test_api_delete_supplement_success_not_owner_not_found(connection: api.IConnection): Promise<void> {\n  // 가정: 사전에 sale/unit/stock/supplement 데이터가 준비되어 있다고 가정\n  // 1. 정상 삭제\n  const saleId = \"valid-sale-id\";\n  const unitId = \"valid-unit-id\";\n  const stockId = \"valid-stock-id\";\n  const supplementId = \"valid-supplement-id\";\n\n  // 삭제 전 supplement 조회 성공\n  // await api.functional.shoppings.sellers.sales.units.stocks.supplements.get(\n  //   connection, saleId, unitId, stockId, supplementId\n  // );\n\n  await TestValidator.error(\"delete should succeed for owner\")(\n    async () => {\n      await api.functional.shoppings.sellers.sales.units.stocks.supplements.delete(\n        connection, saleId, unitId, stockId, supplementId\n      );\n    }\n  );\n\n  // 삭제 후 supplement 재조회 시 404 혹은 Not Found\n  await TestValidator.httpError(\"should return 404 after deletion\")(404)(\n    async () => {\n      await api.functional.shoppings.sellers.sales.units.stocks.supplements.get(\n        connection, saleId, unitId, stockId, supplementId\n      );\n    }\n  );\n\n  // 2. 권한 없는 계정으로 삭제 시도\n  const notOwnerConnection = { ...connection, headers: { ...connection.headers, authorization: \"not-owner-token\" } };\n  await TestValidator.httpError(\"should deny delete for not owner\")(403, 401)(\n    async () => {\n      await api.functional.shoppings.sellers.sales.units.stocks.supplements.delete(\n        notOwnerConnection, saleId, unitId, stockId, supplementId\n      );\n    }\n  );\n\n  // 3. 존재하지 않는 supplement deletion: 404 기대\n  const fakeSuppId = \"00000000-0000-0000-0000-000000000999\";\n  await TestValidator.httpError(\"should 404 for not found supplement\")(404)(\n    async () => {\n      await api.functional.shoppings.sellers.sales.units.stocks.supplements.delete(\n        connection, saleId, unitId, stockId, fakeSuppId\n      );\n    }\n  );\n}\n",
  "test/features/api/category/test_list_categories_for_channel_with_children_and_filters.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\n\n// Assume IShoppingChannelCategory and its request/search types are available\nimport { IShoppingChannelCategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingChannelCategory\";\n\nexport async function test_api_list_categories_for_channel_with_children_and_filters(\n  connection: api.IConnection\n): Promise<void> {\n  // Assume channelCode exists as \"test-channel\" with categories and children\n  const channelCode = \"test-channel\";\n\n  // 1. Happy Path: Fetch with default (no filter)\n  const categories: IShoppingChannelCategory.IHierarchical[] = await api.functional.shoppings.sellers.systematic.channels.categories.patch(\n    connection,\n    channelCode\n    // No search/filter/sort body provided\n  );\n  typia.assert(categories);\n  // Validate each category has id, and children field is present (could be empty array)\n  for (const cat of categories) {\n    TestValidator.predicate(\"Category has id\")(() => typeof cat.id === \"string\" || typeof cat.id === \"number\");\n    TestValidator.predicate(\"Category has children array\")(() => Array.isArray(cat.children));\n  }\n\n  // 2. Paging/Filtering: Search for name includes \"Test\" (assuming name field exists)\n  const request: IShoppingChannelCategory.IRequest = {\n    search: { name: \"Test\" },\n    paging: { limit: 2, page: 1 },\n    sort: { seq: \"ASC\" }\n  };\n  const filtered: IShoppingChannelCategory.IHierarchical[] = await api.functional.shoppings.sellers.systematic.channels.categories.patch(\n    connection,\n    channelCode,\n    request\n  );\n  typia.assert(filtered);\n  // Check result: each category name includes \"Test\"\n  for (const cat of filtered) {\n    if (cat.name) {\n      TestValidator.predicate(\"Category name includes filter\")(() => cat.name.includes(\"Test\") );\n    }\n    TestValidator.predicate(\"Category has children array\")(() => Array.isArray(cat.children));\n  }\n\n  // 3. Edge: Invalid channel code (should get empty or error)\n  await TestValidator.error(\"Invalid channel code should fail\")(\n    async () => {\n      await api.functional.shoppings.sellers.systematic.channels.categories.patch(\n        connection,\n        \"does-not-exist\"\n      );\n    }\n  );\n}\n",
  "test/features/api/category/test_get_category_detail_success_and_error_cases.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingChannelCategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingChannelCategory\";\nimport typia from \"typia\";\n\nexport async function test_api_get_category_detail_success_and_error_cases(connection: api.IConnection): Promise<void> {\n    // 정상적인 테스트 데이터: 실제 사용 가능한 channelCode와 id 필요\n    const validChannelCode = \"test-channel\";\n    const validCategoryId = \"11111111-1111-1111-1111-111111111111\";\n\n    // 1. 정상 케이스\n    const category = await api.functional.shoppings.sellers.systematic.channels.categories.get(\n        connection,\n        validChannelCode,\n        validCategoryId,\n    );\n    typia.assert<IShoppingChannelCategory>(category);\n    TestValidator.predicate(\"category.id match\")(() => category.id === validCategoryId);\n    TestValidator.predicate(\"category.code exists\")(() => typeof category.code === \"string\" && category.code.length > 0);\n    TestValidator.predicate(\"category.name exists\")(() => typeof category.name === \"string\" && category.name.length > 0);\n    TestValidator.predicate(\"category.children array\")(() => Array.isArray(category.children));\n\n    // 2. 존재하지 않는 id 조회 : Not Found(404)\n    const nonExistentId = \"22222222-2222-2222-2222-222222222222\";\n    await TestValidator.httpError(\"not found error\")(404)(async () => {\n        await api.functional.shoppings.sellers.systematic.channels.categories.get(\n            connection,\n            validChannelCode,\n            nonExistentId,\n        );\n    });\n\n    // 3. 권한없는 접근 (권한 없는 connection 주입 시도)\n    if (typeof api.functional.shoppings.sellers.systematic.channels.categories.get === \"function\") {\n      // Mock unauthenticated connection (minimal stub for test, 실제 환경에 맞게 조정 필요)\n      const anonymousConnection: api.IConnection = { ...connection, accessToken: undefined };\n      await TestValidator.httpError(\"unauthorized\")(401, 403)(async () => {\n          await api.functional.shoppings.sellers.systematic.channels.categories.get(\n              anonymousConnection,\n              validChannelCode,\n              validCategoryId,\n          );\n      });\n    }\n}\n",
  "test/features/api/shopping-category/test_get_inverted_category_info_success_and_error_cases.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingChannelCategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingChannelCategory\";\nimport typia from \"typia\";\n\nexport async function test_get_inverted_category_info_success_and_error_cases(connection: api.IConnection): Promise<void> {\n    // 정상 케이스 - 사전 준비: 실제 카테고리 정보 조회\n    // (테스트 환경에 known category/channel 정보가 있다는 전제)\n    const knownChannelCode = \"sample-channel\"; // 실제 존재하는 채널 코드로 교체 필요\n    const knownCategoryId = \"11111111-1111-1111-1111-111111111111\"; // 실제 존재하는 카테고리 id로 교체 필요\n    \n    // 1. 우선 일반 카테고리 정보 조회 (존재하는지 검증)\n    const normalCategory = await api.functional.shoppings.sellers.systematic.channels.categories.get(\n        connection, knownChannelCode, knownCategoryId\n    );\n    typia.assert<IShoppingChannelCategory>(normalCategory);\n    \n    // 2. invert 카테고리 정보 조회 (핵심 API)\n    const invertCategory = await api.functional.shoppings.sellers.systematic.channels.categories.getInvert(\n        connection, knownChannelCode, knownCategoryId\n    );\n    typia.assert<IShoppingChannelCategory.IInvert>(invertCategory);\n\n    // 핵심 필드 동일성 검증\n    TestValidator.equals(\"category.id\")<string>(normalCategory.id)(invertCategory.id);\n    TestValidator.equals(\"category.code\")<string>(normalCategory.code)(invertCategory.code);\n    TestValidator.equals(\"category.name\")<string>(normalCategory.name)(invertCategory.name);\n\n    // parent 재귀구조 타입 검증 (최상위 루트는 parent가 null)\n    if (invertCategory.parent !== null) {\n        // parent도 IInvert 타입이어야 함\n        typia.assert<IShoppingChannelCategory.IInvert>(invertCategory.parent);\n    }\n\n    // 실패 케이스 1: 존재하지 않는 카테고리 id\n    const nonExistingCategoryId = \"ffffffff-ffff-ffff-ffff-ffffffffffff\";\n    await TestValidator.httpError(\"NotFound for non-existing category\")(404)(\n        async () => {\n            await api.functional.shoppings.sellers.systematic.channels.categories.getInvert(\n                connection, knownChannelCode, nonExistingCategoryId\n            );\n        }\n    );\n\n    // 실패 케이스 2: 권한 없는 경우(실제 권한 분리 상황에만 테스트)\n    // 예시: 인증·인가가 있을 경우 권한 없는 유저사용, 아니면 패스\n    // await TestValidator.httpError(\"Forbidden for unauthorized access\")(403)(\n    //     async () => {\n    //         await api.functional.shoppings.sellers.systematic.channels.categories.getInvert(\n    //             unauthorizedConnection, knownChannelCode, knownCategoryId\n    //         );\n    //     }\n    // );\n}\n",
  "test/features/api/channel/test_list_channels_with_paging_and_permissions.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingChannel } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingChannel\";\nimport { IPageIShoppingChannel } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIShoppingChannel\";\nimport typia from \"typia\";\n\nexport async function test_api_list_channels_with_paging_and_permissions(connection: api.IConnection): Promise<void> {\n    // 1. 기본 전체 채널 목록 조회(페이지네이션 기본값)\n    const basicRes = await api.functional.shoppings.sellers.systematic.channels.patch(connection, {\n        page: 0,\n        limit: 10,\n        search: null,\n        sort: null,\n    });\n    typia.assert<IPageIShoppingChannel>(basicRes);\n    TestValidator.predicate(\"기본 조회시 0페이지, 10개\")(() => basicRes.pagination.current === 0 && basicRes.pagination.limit === 10);\n\n    // 2. 페이지/리밋 등 페이징 네비게이션\n    const page1 = await api.functional.shoppings.sellers.systematic.channels.patch(connection, {\n        page: 1,\n        limit: 3,\n        search: null,\n        sort: null,\n    });\n    typia.assert<IPageIShoppingChannel>(page1);\n    TestValidator.predicate(\"1페이지, 3개 노출\")(() => page1.pagination.current === 1 && page1.pagination.limit === 3);\n\n    // 3. 정렬(by name, desc)\n    const sortByNameDesc = await api.functional.shoppings.sellers.systematic.channels.patch(connection, {\n        sort: [\"-channel.name\"],\n    });\n    typia.assert<IPageIShoppingChannel>(sortByNameDesc);\n    const dataDesc = sortByNameDesc.data;\n    for (let i = 1; i < dataDesc.length; ++i) {\n        TestValidator.predicate(\"name desc 정렬 확인\")(\n            () => dataDesc[i - 1].name >= dataDesc[i].name\n        );\n    }\n\n    // 4. 정렬(by code, asc)\n    const sortByCodeAsc = await api.functional.shoppings.sellers.systematic.channels.patch(connection, {\n        sort: [\"+channel.code\"],\n    });\n    typia.assert<IPageIShoppingChannel>(sortByCodeAsc);\n    const dataAsc = sortByCodeAsc.data;\n    for (let i = 1; i < dataAsc.length; ++i) {\n        TestValidator.predicate(\"code asc 정렬 확인\")(\n            () => dataAsc[i - 1].code <= dataAsc[i].code\n        );\n    }\n\n    // 5. 검색(채널 코드)\n    if (basicRes.data.length > 0) {\n        const target = basicRes.data[0];\n        const searchRes = await api.functional.shoppings.sellers.systematic.channels.patch(connection, {\n            search: { code: target.code, name: null },\n        });\n        typia.assert<IPageIShoppingChannel>(searchRes);\n        TestValidator.predicate(\"코드 검색 결과 존재, 정확히 매칭\")(\n            () => searchRes.data.every((c) => c.code === target.code)\n        );\n    }\n\n    // 6. 검색(채널 이름)\n    if (basicRes.data.length > 0) {\n        const target = basicRes.data[0];\n        const searchRes = await api.functional.shoppings.sellers.systematic.channels.patch(connection, {\n            search: { name: target.name, code: null },\n        });\n        typia.assert<IPageIShoppingChannel>(searchRes);\n        TestValidator.predicate(\"이름 검색 결과 존재, 정확히 매칭\")(\n            () => searchRes.data.every((c) => c.name === target.name)\n        );\n    }\n\n    // 7. 경계값/무효 요청 : limit 0, page 음수, 등\n    await TestValidator.httpError(\"limit이 0이면 에러\")(400)(\n        () => api.functional.shoppings.sellers.systematic.channels.patch(connection, {\n            limit: 0,\n        })\n    );\n    await TestValidator.httpError(\"page 음수면 에러\")(400)(\n        () => api.functional.shoppings.sellers.systematic.channels.patch(connection, {\n            page: -1,\n        })\n    );\n\n    // 8. 비인증 접근 (권한이 필요한 API라면)\n    if (typeof connection === \"object\" && \"headers\" in connection) {\n        const noAuthConn = { ...connection, headers: {} };\n        await TestValidator.httpError(\"비인증 401 확인\")(401, 403)(\n            () => api.functional.shoppings.sellers.systematic.channels.patch(noAuthConn, {\n                page: 0,\n                limit: 10,\n            })\n        );\n    }\n}\n",
  "test/features/api/channel/test_list_channels_with_hierarchical_categories.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingChannel } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingChannel\";\nimport { IShoppingChannelCategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingChannelCategory\";\nimport { IPage } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPage\";\nimport typia from \"typia\";\n\nfunction validateCategoryTree(categories: IShoppingChannelCategory.IHierarchical[], parentId: string | null, traversed: Set<string> = new Set()): void {\n    for (const category of categories) {\n        typia.assert<IShoppingChannelCategory.IHierarchical>(category);\n        TestValidator.equals(\"parent_id linkage\")(parentId)(category.parent_id);\n        TestValidator.predicate(\"unique category id\")(() => !traversed.has(category.id));\n        traversed.add(category.id);\n        // 재귀적으로 하위 카테고리 확인\n        validateCategoryTree(category.children, category.id, traversed);\n    }\n}\n\nexport async function test_api_channel_list_channels_with_hierarchical_categories(connection: api.IConnection): Promise<void> {\n    // 1. 기본 트리 조회\n    const input: IShoppingChannel.IRequest = {};\n    const output = await api.functional.shoppings.sellers.systematic.channels.patch(connection, input);\n    typia.assert<IPage<IShoppingChannel.IHierarchical>>(output);\n    // pagination 검증\n    typia.assert<IPage.IPagination>(output.pagination);\n    TestValidator.predicate(\"pagination valid\")(() => output.pagination.current >= 0 && output.pagination.limit >= 0 && output.pagination.records >= 0 && output.pagination.pages >= 0);\n    // 데이터 트리 일관성, 각 채널당 카테고리 구조 체크\n    for (const channel of output.data) {\n        typia.assert<IShoppingChannel.IHierarchical>(channel);\n        TestValidator.predicate(\"channel id exists\")(() => typeof channel.id === \"string\" && channel.id.length > 0);\n        TestValidator.predicate(\"channel created_at valid\")(() => typeof channel.created_at === \"string\");\n        TestValidator.predicate(\"channel code exists\")(() => typeof channel.code === \"string\");\n        TestValidator.predicate(\"channel name exists\")(() => typeof channel.name === \"string\");\n        // 카테고리 트리, 루트 parent_id는 null이어야 함\n        validateCategoryTree(channel.categories, null);\n    }\n    // 2. 검색 조건(code, name) 적용 (존재하지 않을 법한 코드)\n    const badSearch: IShoppingChannel.IRequest = { search: { code: \"___not-exist___\", name: null } };\n    const badOutput = await api.functional.shoppings.sellers.systematic.channels.patch(connection, badSearch);\n    typia.assert<IPage<IShoppingChannel.IHierarchical>>(badOutput);\n    TestValidator.equals(\"no data with not-exist code\")([] as IShoppingChannel.IHierarchical[])(badOutput.data);\n\n    // 3. 정렬 조건별로 정상 동작\n    const sortInput: IShoppingChannel.IRequest = { sort: [\"+channel.name\"] };\n    const sortedOutput = await api.functional.shoppings.sellers.systematic.channels.patch(connection, sortInput);\n    typia.assert<IPage<IShoppingChannel.IHierarchical>>(sortedOutput);\n    // name 오름차순 검증 (채널 2개 이상일 때만)\n    if (sortedOutput.data.length > 1) {\n        for (let i=1; i < sortedOutput.data.length; ++i) {\n            TestValidator.predicate(\"channels sorted by name asc\")(\n                () => sortedOutput.data[i-1].name <= sortedOutput.data[i].name\n            );\n        }\n    }\n\n    // 4. 페이징 한정: limit=1로 1페이지만 받기\n    const pagingInput: IShoppingChannel.IRequest = { limit: 1, page: 0 };\n    const pagedOutput = await api.functional.shoppings.sellers.systematic.channels.patch(connection, pagingInput);\n    typia.assert<IPage<IShoppingChannel.IHierarchical>>(pagedOutput);\n    TestValidator.equals(\"limit=1 result length\")([pagedOutput.data[0]])(pagedOutput.data);\n    TestValidator.equals(\"limit=1 pagination current\")(0)(pagedOutput.pagination.current);\n    TestValidator.equals(\"limit=1 pagination limit\")(1)(pagedOutput.pagination.limit);\n    // 데이터 없는 page 접근 시 빈 결과\n    const highPageInput: IShoppingChannel.IRequest = { page: 10000 };\n    const highPageOutput = await api.functional.shoppings.sellers.systematic.channels.patch(connection, highPageInput);\n    typia.assert<IPage<IShoppingChannel.IHierarchical>>(highPageOutput);\n    TestValidator.equals(\"high page result empty\")([] as IShoppingChannel.IHierarchical[])(highPageOutput.data);\n}\n",
  "test/features/api/shopping-channel/test_get_channel_detail_success_and_error_cases.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport { IShoppingChannel } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingChannel\";\nimport { v4 as uuidv4 } from \"uuid\";\n\nexport async function test_get_channel_detail_success_and_error_cases(connection: api.IConnection): Promise<void> {\n    // 1. 정상 케이스: 유효한 채널 ID로 조회\n    // 선행 채널 ID가 필요, 일반적으로 리스트 API 등을 통해 획득해야 함\n    // 여기에서는 예시로 id를 직접 대입 또는 사전 정의된 id 사용 (실제로는 리스트 등 선행 필요)\n    // TODO: 실제 id를 동적으로 획득할 수 있다면 그 방식으로 대체\n    const validChannelId = \"00000000-0000-0000-0000-000000000001\";\n\n    const channel = await api.functional.shoppings.sellers.systematic.channels.get(\n        connection,\n        validChannelId\n    );\n    typia.assert<IShoppingChannel.IHierarchical>(channel);\n    TestValidator.predicate(\"ID matches\")(channel.id === validChannelId);\n    TestValidator.predicate(\"Name exists\")(!!channel.name);\n    TestValidator.predicate(\"Categories array\")(Array.isArray(channel.categories));\n\n    // 2. 실패 케이스: 존재하지 않는 id\n    const invalidId = uuidv4();\n    await TestValidator.httpError(\"Not Found should be thrown\")(404)(async () => {\n        await api.functional.shoppings.sellers.systematic.channels.get(connection, invalidId);\n    });\n\n    // 3. 실패 케이스: 권한 없는 경우 (옵션, 인증 토큰 등 필요시)\n    // const unauthorizedConnection = { ...connection, accessToken: undefined }; // 실제 구조에 맞게 조정 필요\n    // await TestValidator.httpError(\"Should throw Forbidden\")(403)(async () => {\n    //   await api.functional.shoppings.sellers.systematic.channels.get(unauthorizedConnection, validChannelId);\n    // });\n}\n",
  "test/features/api/shopping-channel/test_get_channel_by_code_success_and_not_found_permission_error.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingChannel } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingChannel\";\nimport typia from \"typia\";\n\nexport async function test_api_get_channel_by_code_success_and_not_found_permission_error(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. 정상 케이스: 존재하는 채널 코드로 조회\n  const validCode = \"test-channel-01\";\n  const expected: IShoppingChannel.IHierarchical = {\n    id: \"a164dae9-3b8f-42f8-b2dc-111111111111\",\n    code: validCode,\n    name: \"테스트채널\",\n    created_at: \"2024-01-03T10:00:00.000Z\",\n    categories: [\n      {\n        id: \"b27b1db8-334a-4272-a841-b22222222222\",\n        code: \"root-cat\",\n        name: \"루트 카테고리\",\n        parent_id: null,\n        created_at: \"2024-01-03T10:01:00.000Z\",\n        children: [\n          {\n            id: \"c39bf1ef-c859-46d2-8293-c33333333333\",\n            code: \"sub-cat\",\n            name: \"서브 카테고리\",\n            parent_id: \"b27b1db8-334a-4272-a841-b22222222222\",\n            created_at: \"2024-01-03T10:01:30.000Z\",\n            children: [] as IShoppingChannel.IHierarchical.Category[],\n          },\n        ] as IShoppingChannel.IHierarchical.Category[],\n      },\n    ] as IShoppingChannel.IHierarchical.Category[],\n  };\n\n  const result = await api.functional.shoppings.sellers.systematic.channels.getByCode(\n    connection,\n    validCode,\n  );\n  typia.assert<IShoppingChannel.IHierarchical>(result);\n  TestValidator.equals(\"정상 채널 정보 전체 일치\")<IShoppingChannel.IHierarchical>(expected)(result);\n\n  // 2. 존재하지 않는 채널 코드로 404 에러 검증\n  await TestValidator.httpError(\"존재하지 않는 채널코드 404\")(404)(async () =>\n    api.functional.shoppings.sellers.systematic.channels.getByCode(\n      connection,\n      \"invalid-channel-zz999\",\n    ),\n  );\n\n  // 3. (옵션) 권한 없는 사용자의 403 에러 케이스가 있을 경우, 예시 코드\n  // await TestValidator.httpError(\"권한 없음 403\")(403)(async () =>\n  //   api.functional.shoppings.sellers.systematic.channels.getByCode(\n  //     otherConnection, // 권한 없는 사용자의 커넥션\n  //     validCode,\n  //   ),\n  // );\n}\n",
  "test/features/api/shopping-section/test_list_sections_with_paging_and_permission_error.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingSection } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSection\";\nimport { IShoppingSection as IShoppingSectionNamespace } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSection\";\nimport { IPageIShoppingSection } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIShoppingSection\";\nimport typia from \"typia\";\n\nexport async function test_api_shopping_section_list_with_paging_and_permission_error(connection: api.IConnection): Promise<void> {\n  // 1. 정상 권한으로 전체 목록 조회\n  const req: IShoppingSectionNamespace.IRequest = {};\n  const result = await api.functional.shoppings.sellers.systematic.sections.patch(connection, { body: req });\n  typia.assert<IPageIShoppingSection>(result);\n  typia.assert<IShoppingSection[]>(result.data);\n  TestValidator.predicate(\"data array length matches total records\")(result.data.length <= result.pagination.records);\n\n  // 2. Paging - limit, page (limit: 1, page: 0)\n  const pagingReq: IShoppingSectionNamespace.IRequest = { limit: 1, page: 0 };\n  const pagingResult = await api.functional.shoppings.sellers.systematic.sections.patch(connection, { body: pagingReq });\n  typia.assert<IPageIShoppingSection>(pagingResult);\n  TestValidator.equals(\"page 0\", undefined)(pagingResult.pagination.current)(0);\n  TestValidator.equals(\"limit 1\", undefined)(pagingResult.pagination.limit)(1);\n  TestValidator.predicate(\"max 1 data\")(pagingResult.data.length <= 1);\n\n  // 3. 검색 조건 (임의로 첫 섹션의 code로 필터)\n  if (result.data.length > 0) {\n    const sample = result.data[0];\n    const searchReq: IShoppingSectionNamespace.IRequest = {\n      search: { code: sample.code, name: null },\n    };\n    const searchResult = await api.functional.shoppings.sellers.systematic.sections.patch(connection, { body: searchReq });\n    typia.assert<IPageIShoppingSection>(searchResult);\n    // 모든 결과가 code에 만족해야 함\n    for (const sec of searchResult.data) {\n      TestValidator.equals(\"filtered section code\")(sample.code)(sec.code);\n    }\n  }\n\n  // 4. 소트 조건 검증 (code 오름차순/내림차순)\n  const sortReqAsc: IShoppingSectionNamespace.IRequest = { sort: [\"+section.code\"] };\n  const sortAscResult = await api.functional.shoppings.sellers.systematic.sections.patch(connection, { body: sortReqAsc });\n  const ascCodes = sortAscResult.data.map(s => s.code);\n  for (let i = 1; i < ascCodes.length; ++i)\n    TestValidator.predicate(\"ascending code sort\")(ascCodes[i] >= ascCodes[i-1]);\n\n  const sortReqDesc: IShoppingSectionNamespace.IRequest = { sort: [\"-section.code\"] };\n  const sortDescResult = await api.functional.shoppings.sellers.systematic.sections.patch(connection, { body: sortReqDesc });\n  const descCodes = sortDescResult.data.map(s => s.code);\n  for (let i = 1; i < descCodes.length; ++i)\n    TestValidator.predicate(\"descending code sort\")(descCodes[i] <= descCodes[i-1]);\n\n  // 5. 비인가 접근: 잘못된 커넥션으로 접근 시도\n  const fakeConnection: api.IConnection = { ...connection, headers: { ...connection.headers, authorization: \"Bearer invalidtoken\" } };\n  await TestValidator.httpError(\"should fail with invalid token\")(401)(\n    () => api.functional.shoppings.sellers.systematic.sections.patch(fakeConnection, { body: {} })\n  );\n}\n",
  "test/features/api/shopping-section/test_get_section_detail_success_and_not_found_permission_error.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingSection } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSection\";\nimport typia from \"typia\";\n\nimport { v4 as uuidv4 } from \"uuid\";\n\nexport async function test_api_shopping_section_detail_success_and_not_found_permission_error(connection: api.IConnection): Promise<void> {\n  // 1. 성공 케이스: 유효한 섹션 ID로 조회\n  // 헬퍼 또는 fixture 등으로 적절한 section ID가 이미 존재함을 가정\n  const validSectionId = \"11111111-1111-1111-1111-111111111111\"; // 실제 테스트 환경에 맞는 존재하는 ID로 대체 필요\n\n  const section = await api.functional.shoppings.sellers.systematic.sections.get(connection, validSectionId);\n  typia.assert<IShoppingSection>(section);\n  TestValidator.equals(\"section.id\")(section.id)(validSectionId);\n\n  // 2. 미존재(404) 케이스: 랜덤 UUID 사용\n  const nonExistId = uuidv4();\n  await TestValidator.httpError(\"Not found should return 404\")(404)(\n    () => api.functional.shoppings.sellers.systematic.sections.get(connection, nonExistId)\n  );\n\n  // 3. (Optional) 권한 없음(403) 케이스: 권한 없는 connection 시나리오 (필요시 구현)\n  if ((connection as any).asAdmin !== false) {\n    // 임의의 권한 없는 사용자 connection 객체 직후 재시도\n    const noAuthConnection = { ...connection, headers: { ...connection.headers, Authorization: \"Bearer invalid-or-no-access-token\" } };\n    await TestValidator.httpError(\"Forbidden should return 403\")(403)(\n      () => api.functional.shoppings.sellers.systematic.sections.get(noAuthConnection, validSectionId)\n    );\n  }\n}\n",
  "test/features/api/section/test_get_section_by_code_success_not_found_permission_error.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingSection } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSection\";\nimport typia from \"typia\";\n\nexport async function test_api_get_section_by_code_success_not_found_permission_error(\n  connection: api.IConnection\n): Promise<void> {\n  // 1. Prepare a known valid section code (define it explicitly for deterministic test)\n  const validSectionCode = \"fruits-corner\";\n\n  // 2. Get section info with valid code\n  const section: IShoppingSection = await api.functional.shoppings.sellers.systematic.sections.get(\n    connection,\n    validSectionCode\n  );\n  typia.assert<IShoppingSection>(section);\n  TestValidator.predicate(\"section.id should exist\")(() => typeof section.id === \"string\" && !!section.id);\n  TestValidator.predicate(\"section.code matches\")(() => section.code === validSectionCode);\n\n  // 3. Query with non-existent code -> expect 404 or error\n  const nonExistentCode = \"bogus-nonexistent-section\";\n  await TestValidator.httpError(\"should fail with not found\") (404)(async () => {\n    await api.functional.shoppings.sellers.systematic.sections.get(\n      connection,\n      nonExistentCode\n    );\n  });\n\n  // 4. Simulate insufficient permission (permission error test - optional depending on api design)\n  // Create a second connection with user lacking section permission (if supported)\n  if (typeof connection.createLimited === \"function\") {\n    const noAccessConnection = await connection.createLimited({ permissions: [] });\n    await TestValidator.httpError(\"should fail with permission error\")(403)(async () => {\n      await api.functional.shoppings.sellers.systematic.sections.get(\n        noAccessConnection,\n        validSectionCode\n      );\n    });\n  }\n}\n",
  "test/features/api/question/test_list_abridged_questions_for_sale.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport { IShoppingCartCommodity } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCartCommodity\";\nimport { IShoppingCartCommodityStock } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCartCommodityStock\";\nimport { IShoppingCartCommodityStockChoice } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCartCommodityStockChoice\";\nimport { IShoppingOrder } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingOrder\";\nimport { IShoppingSaleQuestion } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleQuestion\";\nimport { IShoppingSaleQuestion as IQuestion } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleQuestion\";\nimport { IQuestion as IQuestionCreate } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleQuestion.ICreate\";\nimport { IPageIShoppingSaleQuestion } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIShoppingSaleQuestion.IAbridge\";\n\nexport async function test_api_question_abridge_list(connection: api.IConnection): Promise<void> {\n    // 1. 주문 생성 (테스트용 sale 선택에 따라 IShoppingCartCommodity.ICreate 세팅 필요)\n    // 샘플 데이터 값\n    const fakeSaleId = crypto.randomUUID();\n    const commodityInput: IShoppingCartCommodity.ICreate = {\n        sale_id: fakeSaleId, // 실제로는 saleId를 api로부터 받아와야 함\n        stocks: [\n            {\n                unit_id: crypto.randomUUID(),\n                stock_id: crypto.randomUUID(),\n                choices: [] as IShoppingCartCommodityStockChoice.ICreate[],\n                quantity: 1\n            }\n        ],\n        volume: 1\n    };\n\n    // 실제 주문 생성 (saleId 확보)\n    // 사전에 등록된 정상 saleId 정보여야 문의글 등록 가능\n    const order: IShoppingOrder = await api.functional.shoppings.customers.orders.direct(connection, commodityInput);\n    typia.assert<IShoppingOrder>(order);\n    const saleId = order.goods[0].commodity.sale.id;\n\n    // 2. 문의글 없는 상태로 축약 목록 조회 (빈 배열)\n    const emptyReq = {};\n    const emptyList = await api.functional.shoppings.customers.sales.questions.abridges(connection, saleId, emptyReq);\n    typia.assert<IPageIShoppingSaleQuestion.IAbridge>(emptyList);\n    TestValidator.equals(\"문의글 없음-빈 배열 확인\")([] as IShoppingSaleQuestion.IAbridge[])(emptyList.data);\n\n    // 3. 문의글 두 건 생성\n    const questionInput1: IShoppingSaleQuestion.ICreate = {\n        secret: false,\n        format: \"html\",\n        title: \"첫 번째 문의글\",\n        body: \"질문 내용1\",\n        files: []\n    };\n    const question1 = await api.functional.shoppings.customers.sales.questions.post(connection, saleId, questionInput1);\n    typia.assert<IShoppingSaleQuestion>(question1);\n\n    const questionInput2: IShoppingSaleQuestion.ICreate = {\n        secret: true,\n        format: \"txt\",\n        title: \"두 번째 문의글\",\n        body: \"질문 내용2\",\n        files: []\n    };\n    const question2 = await api.functional.shoppings.customers.sales.questions.post(connection, saleId, questionInput2);\n    typia.assert<IShoppingSaleQuestion>(question2);\n\n    // 4. 복수 문의글 존재 시 축약 목록 조회\n    const listResp = await api.functional.shoppings.customers.sales.questions.abridges(connection, saleId, {});\n    typia.assert<IPageIShoppingSaleQuestion.IAbridge>(listResp);\n    TestValidator.equals(\"문의글 2건 카운트, 주요 필드 확인\")([question1, question2].map(q => q.snapshots[0].title))(\n        listResp.data.map((q) => q.title)\n    );\n\n    // 5. 존재하지 않는 saleId로 요청 시 에러 확인 (404 예상)\n    await TestValidator.httpError(\"존재하지 않는 saleId로 문의글 축약목록 조회 에러 반환\")(404)(\n        () => api.functional.shoppings.customers.sales.questions.abridges(connection, fakeSaleId, {})\n    );\n}\n",
  "test/features/api/review/test_create_review_comment_on_inquiry.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingCartCommodity } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCartCommodity\";\nimport { IShoppingCartCommodityStock } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCartCommodityStock\";\nimport { IShoppingCartCommodityStockChoice } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCartCommodityStockChoice\";\nimport { IShoppingOrder } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingOrder\";\nimport { IShoppingSaleReview } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleReview\";\nimport { IShoppingSaleReview as IReview } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleReview\";\nimport { IShoppingSaleReview as IShoppingSaleReviewType } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleReview\";\nimport { IShoppingSaleReview as IShoppingSaleReviewDto } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleReview\";\nimport { IShoppingSaleReview as IShoppingSaleReviewResponse } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleReview\";\nimport { IShoppingSaleInquiryComment, IShoppingSaleInquiryComment as IReviewComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment\";\nimport { IShoppingSaleInquiryComment as IComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment\";\nimport { IShoppingSaleInquiryComment as IShoppingSaleInquiryCommentType } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment\";\nimport { IShoppingSaleInquiryComment as IShoppingSaleInquiryCommentResponse } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment\";\nimport { IShoppingSaleInquiryComment as IShoppingSaleInquiryCommentDto } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment\";\nimport { IShoppingSaleInquiryComment as IInquiryComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment\";\nimport { IShoppingSaleInquiryComment as IShoppingSaleInquiryCommentResult } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment\";\nimport { IShoppingSaleInquiryComment as IShoppingSaleInquiryCommentAssert } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment\";\nimport { IShoppingSaleReview as IReviewResponse } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleReview\";\nimport { IShoppingSaleReview as IShoppingSaleReviewAssert } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleReview\";\nimport { IShoppingCartCommodity as IShoppingCartCommodityType } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCartCommodity\";\nimport { IShoppingOrderGood } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingOrderGood\";\nimport { IShoppingSaleReview } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleReview\";\nimport { IShoppingSaleInquiryComment as IShoppingSaleInquiryCommentMain } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment\";\nimport { IShoppingSaleInquiryComment as IReviewInquiryComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment\";\nimport { IShoppingSaleReview as IMainReview } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleReview\";\nimport { IShoppingSaleInquiryComment as IMainInquiryComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment\";\nimport { IShoppingSaleInquiryComment as IInquiryCommentType } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment\";\nimport { IShoppingSaleInquiryComment as IInquiryCommentAssert } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment\";\nimport { IShoppingSaleInquiryComment as IInquiryCommentResponse } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment\";\nimport { IShoppingSaleInquiryComment as IShoppingSaleInquiryCommentSummary } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment\";\nimport { IShoppingSaleInquiryComment as IShoppingSaleInquiryCommentDtoType } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment\";\nimport { IShoppingSaleInquiryComment as IShoppingSaleInquiryCommentPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment\";\nimport { IShoppingSaleInquiryComment as IShoppingSaleInquiryCommentCreate } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment\";\nimport { IShoppingSaleInquiryComment as IShoppingSaleInquiryCommentOutput } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment\";\nimport { IShoppingSaleInquiryComment as IShoppingSaleInquiryCommentReturn } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment\";\nimport { IShoppingSaleInquiryComment as IShoppingSaleInquiryCommentInstance } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment\";\nimport { IShoppingSaleInquiryComment as IShoppingSaleInquiryCommentTest } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment\";\nimport { IShoppingSaleInquiryComment as IShoppingSaleInquiryCommentReal } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment\";\nimport { IShoppingSaleInquiryComment as IShoppingSaleInquiryCommentTypeReturn } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment\";\nimport { IShoppingSaleInquiryComment as IShoppingSaleInquiryCommentData } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment\";\nimport { IShoppingSaleInquiryComment as IShoppingSaleInquiryCommentFinal } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment\";\nimport { IShoppingSaleInquiryComment as IShoppingSaleInquiryCommentReturnType } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment\";\nimport { IShoppingSaleInquiryComment as IInquiryCommentData } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment\";\nimport { IShoppingSaleInquiryComment as IInquiryCommentOutput } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment\";\nimport { IShoppingSaleInquiryComment as IReviewCommentResponse } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment\";\nimport { IShoppingSaleInquiryComment as IReviewCommentAssert } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment\";\nimport { IShoppingSaleInquiryComment as IReviewCommentDto } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment\";\nimport typia from \"typia\";\n\nexport async function test_api_review_create_review_comment_on_inquiry(connection: api.IConnection): Promise<void> {\n  // 1. (A계정) 구매 이력 생성 및 리뷰 작성\n  const orderInput: IShoppingCartCommodity.ICreate = {\n    sale_id: \"11111111-1111-1111-1111-111111111111\",\n    stocks: [\n      {\n        unit_id: \"22222222-2222-2222-2222-222222222222\",\n        stock_id: \"33333333-3333-3333-3333-333333333333\",\n        choices: [],\n        quantity: 1\n      }\n    ],\n    volume: 1\n  };\n  const order: IShoppingOrder = await api.functional.shoppings.customers.orders.direct.post(connection, orderInput);\n  typia.assert<IShoppingOrder>(order);\n  TestValidator.predicate(\"order.goods should exist and length > 0\")(() => Array.isArray(order.goods) && order.goods.length > 0);\n\n  // (A계정) 리뷰 작성\n  const reviewInput: IShoppingSaleReview.ICreate = {\n    good_id: order.goods[0].id,\n    score: 90,\n    format: \"txt\",\n    title: \"구매 후 리뷰\",\n    body: \"정말 좋은 제품입니다!\",\n    files: []\n  };\n  const review: IShoppingSaleReview = await api.functional.shoppings.customers.sales[order.goods[0].commodity.sale.id].reviews.post(connection, reviewInput);\n  typia.assert<IShoppingSaleReview>(review);\n  TestValidator.equals(\"review.good_id should match input\")(<string>(reviewInput.good_id))(review.snapshots[0].id);\n\n  // (A계정) 정상 댓글 작성\n  const commentInput: IShoppingSaleInquiryComment.ICreate = {\n    format: \"txt\",\n    body: \"구매자 댓글입니다.\",\n    files: []\n  };\n  const comment: IShoppingSaleInquiryComment = await api.functional.shoppings.customers.sales[order.goods[0].commodity.sale.id].reviews[review.id].comments.post(connection, commentInput);\n  typia.assert<IShoppingSaleInquiryComment>(comment);\n  TestValidator.equals(\"comment.body should match input\")(<string>(commentInput.body))(comment.snapshots[0].body);\n\n  // 3. (B계정) 권한 없는 계정 시도\n  const connectionB = { ...connection, accessToken: \"other-user-token\" };\n  await TestValidator.httpError(\"Non-owner cannot comment\")(403)(async () => {\n    await api.functional.shoppings.customers.sales[order.goods[0].commodity.sale.id].reviews[review.id].comments.post(connectionB, commentInput);\n  });\n\n  // 4. 존재하지 않는 리뷰/문의 ID\n  await TestValidator.httpError(\"Not found reviewId\")(404)(async () => {\n    await api.functional.shoppings.customers.sales[order.goods[0].commodity.sale.id].reviews[\"non-existent-review-id\"].comments.post(connection, commentInput);\n  });\n  await TestValidator.httpError(\"Not found saleId\")(404)(async () => {\n    await api.functional.shoppings.customers.sales[\"non-existent-sale-id\"].reviews[review.id].comments.post(connection, commentInput);\n  });\n\n  // 5. 유효성 오류 케이스\n  const invalidInputs: IShoppingSaleInquiryComment.ICreate[] = [\n    { format: \"txt\", body: \"\", files: [] }, // 빈 body\n    { /* format 누락 */ body: \"내용\", files: [] } as any, // format 누락\n    { format: \"txt\", /* body 누락 */ files: [] } as any, // body 누락\n    { format: \"txt\", body: \"유효성 오류\", files: null as any } // files null\n  ];\n  for (const invalid of invalidInputs) {\n    await TestValidator.httpError(\"Validation error\")(422)(async () => {\n      await api.functional.shoppings.customers.sales[order.goods[0].commodity.sale.id].reviews[review.id].comments.post(connection, invalid);\n    });\n  }\n}\n",
  "test/features/api/review-comment/test_list_review_comments_for_inquiry.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingCartCommodity } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCartCommodity\";\nimport { IShoppingCartCommodityStock } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCartCommodityStock\";\nimport { IShoppingCartCommodityStockChoice } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCartCommodityStockChoice\";\nimport { IShoppingOrder } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingOrder\";\nimport { IShoppingSaleReview } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleReview\";\nimport { IShoppingSaleReview_ICreate } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleReview\";\nimport { IShoppingSaleInquiryComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment\";\nimport { IShoppingSaleInquiryComment_ICreate } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment\";\nimport { IShoppingSaleInquiryComment_IRequest } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment\";\nimport { IPageIShoppingSaleInquiryComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIShoppingSaleInquiryComment\";\nimport typia from \"typia\";\n\nexport async function test_api_review_comment_list_patch(connection: api.IConnection): Promise<void> {\n  // 1. Create an order directly\n  const goodId = \"00000000-0000-4000-8000-000000000001\";\n  const saleId = \"00000000-0000-4000-8000-000000000002\";\n  const unitId = \"00000000-0000-4000-8000-000000000003\";\n  const stockId = \"00000000-0000-4000-8000-000000000004\";\n\n  const createOrderInput = {\n    sale_id: saleId,\n    stocks: [\n      {\n        unit_id: unitId,\n        stock_id: stockId,\n        choices: [] as IShoppingCartCommodityStockChoice.ICreate[],\n        quantity: 1,\n      },\n    ],\n    volume: 1,\n    accumulate: false,\n  };\n  const order: IShoppingOrder = await api.functional.shoppings.customers.orders.direct.post(\n    connection,\n    createOrderInput\n  );\n  typia.assert<IShoppingOrder>(order);\n  TestValidator.predicate(\"Order should contain goods\")(order.goods.length > 0);\n\n  // 2. Write a review article\n  const reviewInput: IShoppingSaleReview_ICreate = {\n    good_id: order.goods[0].id,\n    score: 95,\n    format: \"txt\",\n    title: \"Test Review Title\",\n    body: \"Test review content\",\n    files: [],\n  };\n  const review: IShoppingSaleReview = await api.functional.shoppings.customers.sales[\"{saleId}\"].reviews.post(\n    connection,\n    saleId,\n    reviewInput\n  );\n  typia.assert<IShoppingSaleReview>(review);\n\n  const inquiryId = review.id;\n\n  // 3. Check comment list initially empty\n  const req: IShoppingSaleInquiryComment_IRequest = {};\n  const listEmpty: IPageIShoppingSaleInquiryComment = await api.functional.shoppings.customers.sales[\"{saleId}\"].reviews[\"{inquiryId}\"].comments.patch(\n    connection,\n    saleId,\n    inquiryId,\n    req\n  );\n  typia.assert<IPageIShoppingSaleInquiryComment>(listEmpty);\n  TestValidator.equals(\"empty comment list\")([] as IShoppingSaleInquiryComment[])(listEmpty.data);\n\n  // 4. Register multiple comments\n  const commentInputs: IShoppingSaleInquiryComment_ICreate[] = [\n    {\n      format: \"txt\",\n      body: \"Comment #1\",\n      files: [],\n    },\n    {\n      format: \"txt\",\n      body: \"Comment #2\",\n      files: [],\n    },\n  ];\n  const comment1: IShoppingSaleInquiryComment = await api.functional.shoppings.customers.sales[\"{saleId}\"].reviews[\"{inquiryId}\"].comments.post(\n    connection,\n    saleId,\n    inquiryId,\n    commentInputs[0]\n  );\n  const comment2: IShoppingSaleInquiryComment = await api.functional.shoppings.customers.sales[\"{saleId}\"].reviews[\"{inquiryId}\"].comments.post(\n    connection,\n    saleId,\n    inquiryId,\n    commentInputs[1]\n  );\n  typia.assert<IShoppingSaleInquiryComment>(comment1);\n  typia.assert<IShoppingSaleInquiryComment>(comment2);\n\n  // 5. Fetch the comment list again\n  const listResult: IPageIShoppingSaleInquiryComment = await api.functional.shoppings.customers.sales[\"{saleId}\"].reviews[\"{inquiryId}\"].comments.patch(\n    connection,\n    saleId,\n    inquiryId,\n    req\n  );\n  typia.assert<IPageIShoppingSaleInquiryComment>(listResult);\n  TestValidator.predicate(\"comment list has all comments\")(() =>\n    listResult.data.some((c) => c.id === comment1.id) &&\n    listResult.data.some((c) => c.id === comment2.id)\n  );\n\n  // 6. Negative cases: invalid saleId and inquiryId\n  const fakeSaleId = \"00000000-0000-4000-8000-ffffffffffff\";\n  const fakeInquiryId = \"00000000-0000-4000-8000-eeeeeeeeeeee\";\n\n  await TestValidator.httpError(\"invalid saleId\")(404)(() =>\n    api.functional.shoppings.customers.sales[\"{saleId}\"].reviews[\"{inquiryId}\"].comments.patch(\n      connection,\n      fakeSaleId,\n      inquiryId,\n      req\n    )\n  );\n  await TestValidator.httpError(\"invalid inquiryId\")(404)(() =>\n    api.functional.shoppings.customers.sales[\"{saleId}\"].reviews[\"{inquiryId}\"].comments.patch(\n      connection,\n      saleId,\n      fakeInquiryId,\n      req\n    )\n  );\n}\n",
  "test/features/api/review-comment/test_get_review_comment_detail.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingCartCommodity } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCartCommodity\";\nimport { IShoppingCartCommodityStock } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCartCommodityStock\";\nimport { IShoppingCartCommodityStockChoice } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCartCommodityStockChoice\";\nimport { IShoppingOrder } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingOrder\";\nimport { IShoppingSaleReview } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleReview\";\nimport { IShoppingSaleReview as IReview } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleReview\";\nimport { IShoppingSaleReview as IReviewDetail } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleReview\";\nimport { IShoppingSaleInquiryComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment\";\nimport { IShoppingSaleInquiryComment as IInquiryComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment\";\nimport { IShoppingSaleInquiryComment as ICommentDetail } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment\";\nimport typia from \"typia\";\nimport { v4 as uuidv4 } from \"uuid\";\n\nexport async function test_api_get_review_comment_detail(connection: api.IConnection): Promise<void> {\n  // 1. 임의의 상품 sale/stock 정보를 지정해 주문 신청\n  const sale_id = uuidv4(); // 테스트 환경 맞게 실제 테스트가능한 id 설정 필요\n  const unit_id = uuidv4();\n  const stock_id = uuidv4();\n\n  const createOrderInput: IShoppingCartCommodity.ICreate = {\n    sale_id,\n    stocks: [\n      {\n        unit_id,\n        stock_id,\n        choices: [] as IShoppingCartCommodityStockChoice.ICreate[],\n        quantity: 1,\n      },\n    ],\n    volume: 1,\n    accumulate: false,\n  };\n  const order: IShoppingOrder = await api.functional.shoppings.customers.orders.direct.post(connection, createOrderInput);\n\n  typia.assert<IShoppingOrder>(order);\n  const good = order.goods[0]!;\n  const testGoodId = good.id;\n  const testSaleId = sale_id;\n\n  // 2. 리뷰 작성\n  const reviewBody = {\n    good_id: testGoodId,\n    score: 85,\n    format: \"txt\" as const,\n    title: \"리뷰 타이틀\",\n    body: \"리뷰 본문 내용..\",\n    files: [],\n  };\n  const review: IShoppingSaleReview = await api.functional.shoppings.customers.sales.reviews.post(testSaleId)(connection, reviewBody);\n  typia.assert<IShoppingSaleReview>(review);\n  const inquiryId = review.id;\n\n  // 3. 댓글 작성\n  const commentBody = {\n    format: \"txt\" as const,\n    body: \"댓글 내용\",\n    files: [],\n  };\n  const comment: IShoppingSaleInquiryComment = await api.functional.shoppings.customers.sales.reviews.comments.post(testSaleId, inquiryId)(connection, commentBody);\n  typia.assert<IShoppingSaleInquiryComment>(comment);\n  const commentId = comment.id;\n\n  // 4. 정상 댓글 상세조회\n  const detail: IShoppingSaleInquiryComment = await api.functional.shoppings.customers.sales.reviews.comments.get(testSaleId, inquiryId, commentId)(connection);\n  typia.assert<IShoppingSaleInquiryComment>(detail);\n  TestValidator.equals(\"comment detail id\")(comment.id)(detail.id);\n  TestValidator.equals(\"comment body\")(\n    comment.snapshots[0].body,\n  )(detail.snapshots[0].body);\n\n  // 5. 존재하지 않는 id 조회시 404 등 에러 발생\n  const randomCommentId = uuidv4();\n  await TestValidator.httpError(\"not found comment detail must throw 404\")(404, 400, 403)(\n    () => api.functional.shoppings.customers.sales.reviews.comments.get(testSaleId, inquiryId, randomCommentId)(connection)\n  );\n\n  // 6. 권한 없는 사용자로 접근 - 기본에서 connection 분리 필요 (예: 다른 유저)\n  const anotherConn = { ...connection, headers: { ...connection.headers, authorization: \"Bearer fake_token\" } };\n  await TestValidator.httpError(\"forbidden or unauthorized access\")(401, 403, 404)(\n    () => api.functional.shoppings.customers.sales.reviews.comments.get(testSaleId, inquiryId, commentId)(anotherConn)\n  );\n}\n",
  "test/features/api/review/test_update_review_comment.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingOrder } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingOrder\";\nimport { IShoppingCartCommodity } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCartCommodity\";\nimport { IShoppingOrderGood } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingOrderGood\";\nimport { IShoppingSaleReview } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleReview\";\nimport { IShoppingSaleReviewICreate } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleReview.ICreate\";\nimport { IShoppingSaleInquiryComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment\";\nimport { IShoppingSaleInquiryCommentICreate } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment.ICreate\";\nimport typia from \"typia\";\n\nexport async function test_api_review_update_review_comment(connection: api.IConnection): Promise<void> {\n  // Step 1: 주문(주문생성) 및 구매 데이터 준비\n  const orderInput: IShoppingCartCommodity.ICreate = {\n    sale_id: \"test-sale-id\",\n    stocks: [\n      {\n        unit_id: \"test-unit-id\",\n        stock_id: \"test-stock-id\",\n        choices: [],\n        quantity: 1\n      }\n    ],\n    volume: 1,\n    accumulate: false\n  };\n\n  const order: IShoppingOrder = await api.functional.shoppings.customers.orders.direct(\n    connection,\n    orderInput\n  );\n  typia.assert<IShoppingOrder>(order);\n  // Step 2: 리뷰 작성 (구매한 good 정보 사용)\n  const good = order.goods[0];\n  const reviewInput: IShoppingSaleReviewICreate = {\n    good_id: good.id,\n    score: 80,\n    format: \"txt\",\n    title: \"Sample Review\",\n    body: \"좋은 상품입니다.\",\n    files: []\n  };\n  const review: IShoppingSaleReview = await api.functional.shoppings.customers.sales.reviews.post(\n    connection,\n    order.goods[0].commodity.sale.id,\n    reviewInput\n  );\n  typia.assert<IShoppingSaleReview>(review);\n\n  // Step 3: 댓글 생성 (본인 작성 댓글)\n  const commentInput: IShoppingSaleInquiryCommentICreate = {\n    format: \"txt\",\n    body: \"리뷰에 대한 첫 댓글 작성\",\n    files: []\n  };\n  const comment: IShoppingSaleInquiryComment = await api.functional.shoppings.customers.sales.reviews.comments.post(\n    connection,\n    order.goods[0].commodity.sale.id,\n    review.id,\n    commentInput\n  );\n  typia.assert<IShoppingSaleInquiryComment>(comment);\n\n  // Step 4: 성공적으로 본인 댓글 수정\n  const updateInput: IShoppingSaleInquiryCommentICreate = {\n    format: \"txt\",\n    body: \"수정된 댓글 내용입니다.\",\n    files: []\n  };\n  const updated: IShoppingSaleInquiryComment.ISnapshot = await api.functional.shoppings.customers.sales.reviews.comments.put(\n    connection,\n    order.goods[0].commodity.sale.id,\n    review.id,\n    comment.id,\n    updateInput\n  );\n  typia.assert<IShoppingSaleInquiryComment.ISnapshot>(updated);\n  TestValidator.equals(\"update snapshot body\")<string>(updateInput.body)(updated.body);\n\n  // Step 5: 타인(권한 없음)으로 댓글 수정 시도\n  const anotherConnection = { ...connection, access_token: \"other-user-token\" } as api.IConnection;\n  await TestValidator.httpError(\"권한이 없는 사용자가 댓글을 수정하려하면 403 Forbidden이어야 한다.\")(403)(async () => {\n    await api.functional.shoppings.customers.sales.reviews.comments.put(\n      anotherConnection,\n      order.goods[0].commodity.sale.id,\n      review.id,\n      comment.id,\n      updateInput\n    );\n  });\n\n  // Step 6: 존재하지 않는 댓글 ID로 수정 요청 (404 Not Found)\n  await TestValidator.httpError(\"없는 댓글 ID로 수정은 404이어야 한다.\")(404)(async () => {\n    await api.functional.shoppings.customers.sales.reviews.comments.put(\n      connection,\n      order.goods[0].commodity.sale.id,\n      review.id,\n      \"non-existent-id\",\n      updateInput\n    );\n  });\n\n  // Step 7: 유효하지 않은 입력으로 수정(422)\n  const invalidInput: any = {\n    format: \"badformat\",\n    body: \"\",\n    files: \"not-array\"\n  };\n  await TestValidator.httpError(\"유효하지 않은 입력 형식/내용은 422이어야 한다.\")(422)(async () => {\n    await api.functional.shoppings.customers.sales.reviews.comments.put(\n      connection,\n      order.goods[0].commodity.sale.id,\n      review.id,\n      comment.id,\n      invalidInput\n    );\n  });\n}\n",
  "test/features/api/review/test_create_review_for_sale.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingOrder } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingOrder\";\nimport { IShoppingCartCommodity } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCartCommodity\";\nimport { IShoppingCartCommodityStock } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCartCommodityStock\";\nimport { IShoppingCartCommodityStockChoice } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCartCommodityStockChoice\";\nimport { IShoppingSaleReview } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleReview\";\nimport { IShoppingSaleReview_ICreate } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleReview.ICreate\";\nimport { IAttachmentFile_ICreate } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAttachmentFile.ICreate\";\nimport typia from \"typia\";\n\nexport async function test_api_review_create_and_validation(connection: api.IConnection): Promise<void> {\n    // 1. 사전 준비: 리뷰 가능한 주문 생성\n    // 실제 구성에 맞는 주문 데이터 입력(여기선 최소 요구값만 구성)\n    const commodityCreate: IShoppingCartCommodity.ICreate = {\n        // 임의의 UUID sale_id, 실제 E2E 환경에서는 사전 등록된 상품을 선택 필요\n        sale_id: \"11111111-1111-1111-1111-111111111111\",\n        stocks: [\n            {\n                unit_id: \"22222222-2222-2222-2222-222222222222\",\n                stock_id: \"33333333-3333-3333-3333-333333333333\",\n                choices: [],\n                quantity: 1,\n            },\n        ],\n        volume: 1,\n        accumulate: null,\n    };\n    const order: IShoppingOrder = await api.functional.shoppings.customers.orders.direct(\n        connection,\n        commodityCreate,\n    );\n    // 리뷰 가능한 good 및 sale 정보 추출\n    const good = order.goods[0];\n    const saleId = good.commodity.sale.id;\n    const goodId = good.id;\n\n    // 2. 정상 리뷰 작성 케이스\n    const reviewInput: IShoppingSaleReview_ICreate = {\n        good_id: goodId,\n        score: 95,\n        format: \"md\",\n        title: \"아주 좋은 상품입니다!\",\n        body: \"정말 만족스럽네요.\",\n        files: [],\n    };\n    const review = await api.functional.shoppings.customers.sales.reviews.postBySaleId(\n        connection,\n        saleId,\n        reviewInput,\n    );\n    typia.assert<IShoppingSaleReview>(review);\n    TestValidator.equals(\"리뷰: good_id 일치\")(reviewInput.good_id)(review.snapshots[0].id);\n    TestValidator.equals(\"리뷰: score 일치\")(reviewInput.score)(review.snapshots[0].score);\n    TestValidator.equals(\"리뷰: title 일치\")(reviewInput.title)(review.snapshots[0].title);\n\n    // 3. 동일 상품에 중복 작성 방지 에러\n    await TestValidator.httpError(\"중복 리뷰 작성 금지\")(428)(async () => {\n        await api.functional.shoppings.customers.sales.reviews.postBySaleId(\n            connection,\n            saleId,\n            reviewInput,\n        );\n    });\n\n    // 4. 필수 입력값 누락\n    // 누락 방식별 테스트(각각 400 Bad Request 혹은 422 등 유효성 오류 예상)\n    const baseInput = { ...reviewInput };\n    for (const missingField of [\"good_id\", \"score\", \"format\", \"title\", \"body\"]) {\n        // 필드 누락시키기\n        const badInput: any = { ...baseInput };\n        delete badInput[missingField];\n        await TestValidator.httpError(\"필수 입력값 누락: \" + missingField)(400, 422)(async () => {\n            await api.functional.shoppings.customers.sales.reviews.postBySaleId(\n                connection,\n                saleId,\n                badInput,\n            );\n        });\n    }\n\n    // 5. 부적절한 값 검증\n    const wrongInputs: IShoppingSaleReview_ICreate[] = [\n        // score: 음수\n        { ...baseInput, score: -1 },\n        // score: 101\n        { ...baseInput, score: 101 },\n        // body: empty string\n        { ...baseInput, body: \"\" },\n    ];\n    for (const wrongInput of wrongInputs) {\n        await TestValidator.httpError(\"부적절 값 입력\")(400, 422)(async () => {\n            await api.functional.shoppings.customers.sales.reviews.postBySaleId(\n                connection,\n                saleId,\n                wrongInput,\n            );\n        });\n    }\n\n    // 6. 존재하지 않는 saleId\n    await TestValidator.httpError(\"존재하지 않는 saleId\")(\n        404, 400, 422\n    )(async () => {\n        await api.functional.shoppings.customers.sales.reviews.postBySaleId(\n            connection,\n            \"00000000-0000-0000-0000-000000000000\",\n            reviewInput,\n        );\n    });\n}\n",
  "test/features/api/review/test_list_reviews_for_sale.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingCartCommodity } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCartCommodity\";\nimport { IShoppingCartCommodityStock } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCartCommodityStock\";\nimport { IShoppingOrder } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingOrder\";\nimport { IShoppingCartCommodityStockChoice } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCartCommodityStockChoice\";\nimport { IShoppingSaleReview } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleReview\";\nimport { IShoppingSaleReview_IRequest } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleReview\";\nimport { IShoppingSaleReview_ICreate } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleReview\";\nimport { IShoppingSaleReview_ISummary } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleReview\";\nimport { IPageIShoppingSaleReview_ISummary } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIShoppingSaleReview\";\nimport typia from \"typia\";\n\nexport async function test_api_review_list_reviews_for_sale(connection: api.IConnection): Promise<void> {\n  // 테스트 1: 잘못된 saleId에 대한 조회(404 에러)\n  const invalidSaleId = \"00000000-0000-0000-0000-000000000000\";\n  await TestValidator.httpError(\"invalid saleId should cause error\")(404, 400)(async () => {\n    return api.functional.shoppings.customers.sales.reviews.patch(\n      connection,\n      invalidSaleId,\n      {\n        page: 1,\n        limit: 10\n      } as IShoppingSaleReview_IRequest\n    );\n  });\n\n  // 테스트 2: 주문 없는 saleId(신규 uuid)로 조회 - 빈 배열 반환\n  // (여기서는 invalid와 구분되는, 실제로는 없는 saleId를 한번 더 시험)\n  const emptySaleId = \"11111111-1111-4111-8111-111111111111\";\n  await TestValidator.httpError(\"empty saleId should cause error\")(404, 400)(async () => {\n    return api.functional.shoppings.customers.sales.reviews.patch(\n      connection,\n      emptySaleId,\n      {\n        page: 1,\n        limit: 10\n      } as IShoppingSaleReview_IRequest\n    );\n  });\n\n  // 테스트 3: 신규 주문 생성 후 해당 sale의 리뷰 없는 경우 확인\n  // IShoppingCartCommodity.ICreate 데이터 준비\n  // 실제로는 sale_id, unit, stock, choice 등 세부구조가 복잡할 수 있으나 테스트 기준 dummy 값 사용\n  const dummyStock: IShoppingCartCommodityStock.ICreate = {\n    unit_id: \"22222222-2222-4222-8222-222222222222\",\n    stock_id: \"33333333-3333-4333-8333-333333333333\",\n    choices: [] as IShoppingCartCommodityStockChoice.ICreate[],\n    quantity: 1\n  };\n  const orderBody = {\n    sale_id: \"44444444-4444-4444-8444-444444444444\",\n    stocks: [dummyStock],\n    volume: 1,\n    accumulate: false\n  };\n\n  const order: IShoppingOrder = await api.functional.shoppings.customers.orders.direct.post(\n    connection,\n    orderBody\n  );\n  typia.assert<IShoppingOrder>(order);\n  const saleId = order.goods[0].commodity.sale.id;\n  const goodId = order.goods[0].id;\n\n  // 해당 saleId로 리뷰 조회(아직 리뷰 없음): 빈 배열 검증\n  const pageRes1 = await api.functional.shoppings.customers.sales.reviews.patch(\n    connection,\n    saleId,\n    {\n      page: 1,\n      limit: 10\n    } as IShoppingSaleReview_IRequest\n  );\n  typia.assert<IPageIShoppingSaleReview_ISummary>(pageRes1);\n  TestValidator.equals(\"no review returns empty array\")([] as IShoppingSaleReview_ISummary[])(pageRes1.data);\n\n  // 테스트 4: 리뷰 1, 2 등록 후 목록 조회\n  const createReview = async (title: string): Promise<IShoppingSaleReview> => {\n    return await api.functional.shoppings.customers.sales.reviews.post(\n      connection,\n      saleId,\n      {\n        good_id: goodId,\n        score: 90,\n        format: \"txt\",\n        title,\n        body: `${title} body`,\n        files: []\n      }\n    );\n  };\n\n  // 2개의 리뷰 작성\n  const review1 = await createReview(\"리뷰제목1\");\n  typia.assert<IShoppingSaleReview>(review1);\n  const review2 = await createReview(\"리뷰제목2\");\n  typia.assert<IShoppingSaleReview>(review2);\n\n  // 리뷰 목록 요청 - 두 개의 리뷰가 포함되는지 검증\n  const pageRes2 = await api.functional.shoppings.customers.sales.reviews.patch(\n    connection,\n    saleId,\n    {\n      page: 1,\n      limit: 10\n    } as IShoppingSaleReview_IRequest\n  );\n  typia.assert<IPageIShoppingSaleReview_ISummary>(pageRes2);\n  TestValidator.equals(\"list contains two reviews\")(\n    [review1, review2].map(r => ({\n      score: r.snapshots[0].score,\n      customer: r.customer,\n      answer: r.answer,\n      read_by_seller: r.read_by_seller,\n      id: r.id,\n      title: r.snapshots[0].title,\n      created_at: r.created_at,\n      updated_at: r.snapshots[r.snapshots.length - 1].created_at\n    }))\n  )(pageRes2.data);\n}\n",
  "test/features/api/review/test_get_review_detail_by_id.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingCartCommodity } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCartCommodity\";\nimport { IShoppingCartCommodityStock } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCartCommodityStock\";\nimport { IShoppingCartCommodityStockChoice } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCartCommodityStockChoice\";\nimport { IShoppingOrder } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingOrder\";\nimport { IShoppingSaleReview } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleReview\";\nimport { IShoppingSaleReview as IShoppingSaleReviewType } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleReview\";\nimport typia from \"typia\";\n\nexport async function test_api_review_get_detail_by_id(connection: api.IConnection, unauthorizedConnection: api.IConnection): Promise<void> {\n    // Step 1: 주문 생성 위한 입력 데이터 준비 (실제 환경에서는 유효한 sale/unit/stock/option id 필요)\n    const commodityInput = {\n        sale_id: \"11111111-1111-1111-1111-111111111111\",\n        stocks: [\n            {\n                unit_id: \"22222222-2222-2222-2222-222222222222\",\n                stock_id: \"33333333-3333-3333-3333-333333333333\",\n                choices: [],\n                quantity: 1\n            }\n        ],\n        volume: 1,\n        accumulate: null\n    };\n    // Step 2: 직접 주문 생성\n    const order: IShoppingOrder = await api.functional.shoppings.customers.orders.direct.post(connection, commodityInput);\n    typia.assert<IShoppingOrder>(order);\n    // Step 3: 첫번째 good_id 추출\n    const good_id = order.goods[0].id;\n    const sale_id = order.goods[0].commodity.sale.id;\n\n    // Step 4: 리뷰 작성\n    const reviewInput = {\n        good_id,\n        score: 90,\n        format: \"md\" as const,\n        title: \"리뷰 테스트\",\n        body: \"리뷰 본문 내용입니다.\",\n        files: [] as any[],\n    };\n    const review = await api.functional.shoppings.customers.sales.reviews.postBySaleId(connection, sale_id, reviewInput);\n    typia.assert<IShoppingSaleReview>(review);\n\n    // Step 5: 상세 조회 (정상)\n    const detail = await api.functional.shoppings.customers.sales.reviews.getBySaleId(connection, sale_id, review.id);\n    typia.assert<IShoppingSaleReviewType>(detail);\n    TestValidator.equals(\"리뷰 상세 조회 결과 동일함\")(review)(detail);\n\n    // Step 6: 없는 리뷰 상세 조회 → 오류\n    const notExistsId = \"aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa\";\n    await TestValidator.httpError(\"존재하지 않는 리뷰 조회 오류\")(404, 400)(async () => {\n        return await api.functional.shoppings.customers.sales.reviews.getBySaleId(connection, sale_id, notExistsId);\n    });\n\n    // Step 7: 권한 없는 사용자로 상세 조회 → 접근 제한\n    await TestValidator.httpError(\"타인 리뷰 상세 조회 불가\")(403, 401)(async () => {\n        return await api.functional.shoppings.customers.sales.reviews.getBySaleId(unauthorizedConnection, sale_id, review.id);\n    });\n}\n",
  "test/features/api/review/test_update_review_by_id.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingCartCommodity } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCartCommodity\";\nimport { IShoppingCartCommodityStock } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCartCommodityStock\";\nimport { IShoppingOrder } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingOrder\";\nimport { IShoppingSaleReview } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleReview\";\nimport { IShoppingSaleReview_IUpdate } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleReview\";\nimport { IShoppingSaleReview_ICreate } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleReview\";\nimport { IAttachmentFile_ICreate } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAttachmentFile\";\nimport typia from \"typia\";\n\nimport { randomUUID } from \"crypto\";\n\nexport async function test_api_review_update_review_by_id(connection: api.IConnection, otherConnection: api.IConnection): Promise<void> {\n  // 1. 주문 이력 확보: 직접 주문 생성\n  const commodityStock: IShoppingCartCommodityStock.ICreate = {\n    unit_id: randomUUID(),\n    stock_id: randomUUID(),\n    choices: [],\n    quantity: 1,\n  };\n  const commodityCreate: IShoppingCartCommodity.ICreate = {\n    sale_id: randomUUID(), // 실제 환경에서는 유효한 sale_id 필요\n    stocks: [commodityStock],\n    volume: 1,\n    accumulate: false,\n  };\n  const order: IShoppingOrder = await api.functional.shoppings.customers.orders.direct.post(\n    connection,\n    commodityCreate,\n  );\n  typia.assert<IShoppingOrder>(order);\n\n  // 2. 리뷰 대상 good_id 확보 및 리뷰 작성\n  const good = order.goods[0];\n  const reviewCreate: IShoppingSaleReview.ICreate = {\n    good_id: good.id,\n    score: 80,\n    format: \"txt\",\n    title: \"첫 리뷰입니다.\",\n    body: \"테스트용 리뷰 본문\",\n    files: [] as IAttachmentFile_ICreate[],\n  };\n  const review = await api.functional.shoppings.customers.sales.reviews.post(\n    connection,\n    order.goods[0].commodity.sale.id,\n    reviewCreate,\n  );\n  typia.assert<IShoppingSaleReview>(review);\n  const reviewId = review.id;\n  const saleId = order.goods[0].commodity.sale.id;\n\n  // 3. 본인 리뷰 정상 수정 케이스\n  const updateInput: IShoppingSaleReview.IUpdate = {\n    score: 90,\n    format: \"md\",\n    title: \"수정된 리뷰 제목\",\n    body: \"수정된 리뷰 본문\",\n    files: [] as IAttachmentFile_ICreate[],\n  };\n  const updatedSnapshot = await api.functional.shoppings.customers.sales.reviews.postById(\n    connection,\n    saleId,\n    reviewId,\n    updateInput,\n  );\n  typia.assert<IShoppingSaleReview.ISnapshot>(updatedSnapshot);\n  TestValidator.equals(\"snapshot.title\")(\"수정된 리뷰 제목\")(updatedSnapshot.title);\n  TestValidator.equals(\"snapshot.score\")(90)(updatedSnapshot.score);\n\n  // 4. 본인 리뷰 아닌 다른 사용자의 수정 시도 시 권한오류(403 등) 발생\n  await TestValidator.httpError(\"other user modify forbidden\")(403,404)(() =>\n    api.functional.shoppings.customers.sales.reviews.postById(\n      otherConnection,\n      saleId,\n      reviewId,\n      updateInput,\n    ),\n  );\n\n  // 5. 존재하지 않는 리뷰 id로 요청 시 404 오류 발생\n  await TestValidator.httpError(\"not found id\")(404)(() =>\n    api.functional.shoppings.customers.sales.reviews.postById(\n      connection,\n      saleId,\n      randomUUID(),\n      updateInput,\n    ),\n  );\n\n  // 6. 유효하지 않은 입력 데이터로 validation 오류 (예시 score -1, 빈값 등)\n  const invalidInputs: IShoppingSaleReview.IUpdate[] = [\n    { ...updateInput, score: -1 },\n    { ...updateInput, title: \"\" },\n    { ...updateInput, body: \"\" },\n    { ...updateInput, format: \"invalid\" as any },\n    { ...updateInput, files: null as any }, // 비정상 files\n  ];\n  for (const input of invalidInputs) {\n    await TestValidator.httpError(\"invalid input\")(422,400,409)(() =>\n      api.functional.shoppings.customers.sales.reviews.postById(\n        connection,\n        saleId,\n        reviewId,\n        input,\n      ),\n    );\n  }\n}\n",
  "test/features/api/review/test_list_abridged_reviews_for_sale.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport { IShoppingCartCommodity } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCartCommodity\";\nimport { IShoppingCartCommodityStock } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCartCommodityStock\";\nimport { IShoppingCartCommodityStockChoice } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCartCommodityStockChoice\";\nimport { IShoppingOrder } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingOrder\";\nimport { IShoppingSaleReview } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleReview\";\nimport { IShoppingSaleReview_IRequest } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleReview.IRequest\";\nimport { IShoppingSaleReview_ICreate } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleReview.ICreate\";\nimport { IPageIShoppingSaleReview_IAbridge } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIShoppingSaleReview.IAbridge\";\n\n// 임의의 uuid 생성 함수 (리뷰 및 주문 관련)\nfunction createUUID(): string {\n    return \"00000000-0000-4000-8000-\" + Math.random().toString(16).slice(2, 14).padEnd(12,\"0\");\n}\n\nexport async function test_api_review_abridges_patch(\n    connection: api.IConnection,\n): Promise<void> {\n    // [1] 주문 및 good 정보 생성\n    const sale_id = createUUID();\n    const unit_id = createUUID();\n    const stock_id = createUUID();\n    const commodityStock: IShoppingCartCommodityStock.ICreate = {\n        unit_id,\n        stock_id,\n        choices: [] as IShoppingCartCommodityStockChoice.ICreate[],\n        quantity: 1,\n    };\n    const orderInput = {\n        sale_id,\n        stocks: [commodityStock],\n        volume: 1,\n        accumulate: false,\n    };\n    // Order 생성\n    const order: IShoppingOrder = await api.functional.shoppings.customers.orders.direct(\n        connection,\n        orderInput,\n    );\n    typia.assert<IShoppingOrder>(order);\n    const good = order.goods[0];\n    // [2] 리뷰 하나도 없는 경우\n    const abridgeReq: IShoppingSaleReview_IRequest = {};\n    const emptyResult = await api.functional.shoppings.customers.sales.reviews.abridges(\n        connection,\n        sale_id,\n        abridgeReq,\n    );\n    typia.assert<IPageIShoppingSaleReview_IAbridge>(emptyResult);\n    TestValidator.equals(\"no review list should be empty\")(Array.isArray(emptyResult.data) ? 0 : -1)(emptyResult.data.length);\n\n    // [3] 리뷰 복수 작성\n    const createReview = async (title: string, score: number) => {\n        const reviewInput: IShoppingSaleReview_ICreate = {\n            good_id: good.id,\n            score,\n            format: \"txt\",\n            title,\n            body: \"review body \" + title,\n            files: [],\n        };\n        return await api.functional.shoppings.customers.sales.reviews.post(\n            connection,\n            sale_id,\n            reviewInput,\n        );\n    };\n    const review1 = await createReview(\"first review\", 80);\n    typia.assert<IShoppingSaleReview>(review1);\n    const review2 = await createReview(\"second review\", 100);\n    typia.assert<IShoppingSaleReview>(review2);\n\n    // [4] 리뷰 목록 확인\n    const result = await api.functional.shoppings.customers.sales.reviews.abridges(\n        connection,\n        sale_id,\n        abridgeReq,\n    );\n    typia.assert<IPageIShoppingSaleReview_IAbridge>(result);\n    TestValidator.equals(\"review count matches\")(2)(result.data.length);\n    // 주요 필드 검증\n    const titles = result.data.map((r) => r.title);\n    TestValidator.predicate(\"title includes written\")(titles.includes(\"first review\") && titles.includes(\"second review\"));\n    const scores = result.data.map((r) => r.score);\n    TestValidator.predicate(\"correct scores contain\")(scores.includes(80) && scores.includes(100));\n\n    // [5] 잘못된 saleId로 조회\n    await TestValidator.httpError(\"no such saleId\")(404)(async () => {\n        await api.functional.shoppings.customers.sales.reviews.abridges(\n            connection,\n            createUUID(),\n            abridgeReq,\n        );\n    });\n}\n",
  "test/features/api/shopping/test_list_snapshots_for_sale.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport { IShoppingCartCommodity } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCartCommodity\";\nimport { IShoppingCartCommodityStock } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCartCommodityStock\";\nimport { IShoppingCartCommodityStockChoice } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCartCommodityStock\";\nimport { IShoppingOrder } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingOrder\";\nimport { IPageIShoppingSaleSnapshot } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPage\";\nimport { IPage } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPage\";\n\nexport async function test_api_shopping_list_snapshots_for_sale(connection: api.IConnection): Promise<void> {\n  // 1. 잘못된 saleId (형식 오류, 존재하지 않음) - 에러 발생 체크\n  const invalidSaleId = \"invalid-uuid\";\n  const notFoundSaleId = \"00000000-0000-0000-0000-000000000000\"; // 일반적으로 존재하지 않는 UUID\n  const pageRequest = {} as IPage.IRequest;\n\n  await TestValidator.httpError(\"invalid saleId 형식은 400 에러\")(400)(\n    () => api.functional.shoppings.customers.sales.snapshots.patch(\n      connection,\n      invalidSaleId,\n      pageRequest,\n    )\n  );\n  await TestValidator.httpError(\"존재하지 않는 saleId는 404 에러\")(404)(\n    () => api.functional.shoppings.customers.sales.snapshots.patch(\n      connection,\n      notFoundSaleId,\n      pageRequest,\n    )\n  );\n\n  // 2. 임의의 신규 주문 생성(직접구매) -> 응답 내 saleId 확보\n  const input: IShoppingCartCommodity.ICreate = {\n    sale_id: \"a1b2c3d4-e5f6-7890-1234-567890abcdef\", // 예시 uuid - 실제로는 테스트를 위한 적절한 값 필요\n    stocks: [\n      {\n        unit_id: \"f1e2d3c4-b5a6-7890-1234-567890fedcba\",\n        stock_id: \"11111111-2222-3333-4444-555555555555\",\n        choices: [] as IShoppingCartCommodityStockChoice.ICreate[],\n        quantity: 1,\n      } as IShoppingCartCommodityStock.ICreate,\n    ],\n    volume: 1,\n    accumulate: false,\n  };\n\n  let saleIdForTest: string | undefined = undefined;\n  let createdOrder: IShoppingOrder | undefined = undefined;\n\n  await TestValidator.error(\"존재하지 않는 saleId로 직접주문 생성은 404 또는 관련 에러\")(async () => {\n    createdOrder = await api.functional.shoppings.customers.orders.direct.post(\n      connection,\n      input\n    );\n    typia.assert<IShoppingOrder>(createdOrder);\n    if (createdOrder.goods.length > 0) {\n      // 주문 생성 시 첫 goods 내에서 sale_id 추출\n      saleIdForTest = createdOrder.goods[0].commodity.sale.id;\n    }\n  });\n\n  // 3. saleId로 정상 요청 - 실제 saleId가 확보되었을 때만 테스트\n  if (saleIdForTest) {\n    const result = await api.functional.shoppings.customers.sales.snapshots.patch(\n      connection,\n      saleIdForTest,\n      pageRequest\n    );\n    typia.assert<IPageIShoppingSaleSnapshot.ISummary>(result);\n    // 정상 구조, pagination 존재, 배열 타입 등 확인\n    TestValidator.predicate(\"스냅샷 data는 배열이어야 함\")(\n      Array.isArray(result.data)\n    );\n    TestValidator.predicate(\"pagination 정보 존재\")(\n      !!result.pagination\n    );\n    // 스냅샷 데이터가 없을 수도 있음 (length 체크만)\n    TestValidator.predicate(\"데이터 배열 타입 체크\")(\n      typeof result.data.length === \"number\"\n    );\n  }\n\n  // 4. 스냅샷이 없는 신규(임의) saleId 요청 - 빈 배열 반환\n  const fakeSaleId = \"ffffffff-ffff-ffff-ffff-ffffffffffff\";\n  const emptySnapshotResult = await api.functional.shoppings.customers.sales.snapshots.patch(\n    connection,\n    fakeSaleId,\n    pageRequest\n  );\n  typia.assert<IPageIShoppingSaleSnapshot.ISummary>(emptySnapshotResult);\n  TestValidator.equals(\"스냅샷 없는 경우 data는 빈 배열\")( [] as any[] )(emptySnapshotResult.data);\n}\n",
  "test/features/api/snapshot/test_get_snapshot_detail_by_id.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingCartCommodity } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCartCommodity\";\nimport { IShoppingCartCommodityStock } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCartCommodityStock\";\nimport { IShoppingCartCommodityStockChoice } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCartCommodityStockChoice\";\nimport { IShoppingOrder } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingOrder\";\nimport { IShoppingSaleSnapshot } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleSnapshot\";\nimport typia from \"typia\";\nimport { v4 as uuid } from \"uuid\";\n\nexport async function test_api_snapshot_detail_by_id(connection: api.IConnection, forbiddenConnection: api.IConnection): Promise<void> {\n  // [1] 테스트 데이터 준비: 주문 생성으로부터 saleId/snapshotId 확보\n  const createInput: IShoppingCartCommodity.ICreate = {\n    sale_id: uuid(), // 실제 환경에서는 존재하는 saleId 필요 (테스트 시 교체)\n    stocks: [\n      {\n        unit_id: uuid(), // 실제 환경에서는 존재하는 unitId 필요 (테스트 시 교체)\n        stock_id: uuid(), // 실제 환경에서는 존재하는 stockId 필요 (테스트 시 교체)\n        choices: [] as IShoppingCartCommodityStockChoice.ICreate[],\n        quantity: 1\n      }\n    ],\n    volume: 1,\n    accumulate: null\n  };\n\n  let order: IShoppingOrder;\n  try {\n    order = await api.functional.shoppings.customers.orders.direct(connection, createInput);\n  } catch (err) {\n    // 주문 생성 실패시(존재하지 않는 ID), 테스트 진행 불가 - 실제 테스트 환경에서는 미리 fixture로 준비 필요\n    throw new Error(\"Order creation failed. Ensure valid sale_id/unit_id/stock_id for scenario test.\");\n  }\n\n  typia.assert<IShoppingOrder>(order);\n\n  // [2] 스냅샷 ID 출력\n  const good = order.goods[0];\n  const snapshotId = good.commodity.sale.snapshot_id;\n  const saleId = good.commodity.sale.id;\n\n  // [3] 정상 상세 조회(존재하는 snapshotId)\n  const snapshot = await api.functional.shoppings.customers.sales.snapshots.getBySaleId(connection, saleId, snapshotId);\n  typia.assert<IShoppingSaleSnapshot>(snapshot);\n\n  // [4] 없는 snapshotId 실패케이스\n  const invalidSnapshotId = uuid();\n  await TestValidator.httpError(\"조회불가 없는 snapshotId\")(404)(\n    () => api.functional.shoppings.customers.sales.snapshots.getBySaleId(connection, saleId, invalidSnapshotId)\n  );\n\n  // [5] 권한 없는 사용자 접근 실패케이스\n  await TestValidator.httpError(\"권한 없는 사용자 접근 제한\")(401, 403)(\n    () => api.functional.shoppings.customers.sales.snapshots.getBySaleId(forbiddenConnection, saleId, snapshotId)\n  );\n}\n",
  "test/features/api/shopping/test_get_flipped_snapshot_detail.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport { IShoppingCartCommodity } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCartCommodity\";\nimport { IShoppingCartCommodityStock } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCartCommodityStock\";\nimport { IShoppingCartCommodityStockChoice } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCartCommodityStockChoice\";\nimport { IShoppingOrder } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingOrder\";\nimport { IShoppingSale } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSale\";\n\nexport async function test_api_shopping_customer_sale_snapshot_flip(\n  connection: api.IConnection,\n): Promise<void> {\n  // Step 1: 주문 상품(가장 단순 구성) 준비\n  const createBody: IShoppingCartCommodity.ICreate = {\n    sale_id: \"00000000-0000-4000-8000-000000000001\", // 테스트를 위해 known UUID 입력 혹은 픽스처/미리 생성된 상품 UUID 사용\n    volume: 1,\n    accumulate: false,\n    stocks: [\n      {\n        unit_id: \"00000000-0000-4000-8000-000000000010\", // 단일 unit UUID\n        stock_id: \"00000000-0000-4000-8000-000000000100\", // 단일 stock UUID\n        choices: [] as IShoppingCartCommodityStockChoice.ICreate[],\n        quantity: 1,\n      },\n    ],\n  };\n\n  // Step 2: 주문 생성\n  const order: IShoppingOrder = await api.functional.shoppings.customers.orders.direct(\n    connection,\n    createBody,\n  );\n  typia.assert<IShoppingOrder>(order);\n  TestValidator.predicate(\"order.goods\")(() => Array.isArray(order.goods) && order.goods.length > 0);\n\n  const sale = order.goods[0]!.commodity.sale;\n  const saleId = sale.id;\n  const snapshotId = sale.snapshot_id;\n\n  // Step 3: 플립(스냅샷 invert) 정보 정상 조회\n  const flipped: IShoppingSale = await api.functional.shoppings.customers.sales.flips.get(\n    connection,\n    saleId,\n    snapshotId,\n  );\n  typia.assert<IShoppingSale>(flipped);\n  TestValidator.equals(\"sale id\")(sale.id)(flipped.id);\n  TestValidator.equals(\"snapshot id\")(sale.snapshot_id)(flipped.snapshot_id);\n\n  // Step 4: 존재하지 않는 조합에 대해 오류 응답 검증\n  const invalidSaleId = \"11111111-1111-4111-8111-111111111111\";\n  const invalidSnapshotId = \"22222222-2222-4222-8222-222222222222\";\n  await TestValidator.httpError(\"not found\")(404)(async () =>\n    api.functional.shoppings.customers.sales.flips.get(\n      connection,\n      invalidSaleId,\n      invalidSnapshotId,\n    ),\n  );\n}\n",
  "test/features/api/category/test_list_categories_with_children_by_channel_code.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingChannel } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingChannel\";\nimport { IShoppingChannelCategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingChannelCategory\";\nimport typia from \"typia\";\n\nexport async function test_api_list_categories_with_children_by_channel_code(connection: api.IConnection): Promise<void> {\n    // 1. 채널 생성\n    const channelInput = { code: `test-channel-${Date.now()}`, name: \"Test Channel\" };\n    const channel: IShoppingChannel = await api.functional.shoppings.admins.systematic.channels.post(connection, channelInput);\n    typia.assert<IShoppingChannel>(channel);\n    const channelCode = channel.code;\n\n    // 2. 카테고리 없는 상태에서 조회\n    let categoriesEmpty: IShoppingChannelCategory.IHierarchical[] = await api.functional.shoppings.customers.systematic.channels.categories.patch(connection, channelCode, undefined);\n    typia.assert<IShoppingChannelCategory.IHierarchical[]>(categoriesEmpty);\n    TestValidator.equals(\"category list(empty)\")([] as IShoppingChannelCategory.IHierarchical[])(categoriesEmpty);\n\n    // 3. 카테고리 및 nested 카테고리 생성\n    const parentCategoryInput = { parent_id: null, code: `parent-cat-${Date.now()}`, name: \"Parent Category\" };\n    const parentCategory: IShoppingChannelCategory = await api.functional.shoppings.admins.systematic.channels.categories.post(connection, channelCode, parentCategoryInput);\n    typia.assert<IShoppingChannelCategory>(parentCategory);\n\n    const childCategoryInput = { parent_id: parentCategory.id, code: `child-cat-${Date.now()}`, name: \"Child Category\" };\n    const childCategory: IShoppingChannelCategory = await api.functional.shoppings.admins.systematic.channels.categories.post(connection, channelCode, childCategoryInput);\n    typia.assert<IShoppingChannelCategory>(childCategory);\n\n    // 4. 카테고리 계층 구조 조회\n    const categories: IShoppingChannelCategory.IHierarchical[] = await api.functional.shoppings.customers.systematic.channels.categories.patch(connection, channelCode, undefined);\n    typia.assert<IShoppingChannelCategory.IHierarchical[]>(categories);\n    // 상위카테고리가 있고, 그 children에 하위카테고리가 있는지 확인\n    const parent = categories.find((c) => c.id === parentCategory.id);\n    TestValidator.predicate(\"parent category should exist\")(() => !!parent);\n    if (parent) {\n      const child = parent.children.find((c) => c.id === childCategory.id);\n      TestValidator.predicate(\"child category should exist\")(() => !!child);\n    }\n\n    // 5. 존재하지 않는 채널코드 테스트\n    await TestValidator.httpError(\"invalid channelCode should fail\")(404)(() =>\n        api.functional.shoppings.customers.systematic.channels.categories.patch(\n            connection,\n            \"non-existent-code\",\n            undefined,\n        )\n    );\n}\n",
  "test/features/api/category/test_get_category_detail_by_channel_code_and_id.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingChannel } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingChannel\";\nimport { IShoppingChannelCategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingChannelCategory\";\nimport { IShoppingChannelCategory as ICreateCategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingChannelCategory.ICreate\";\nimport { IShoppingChannel as ICreateChannel } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingChannel.ICreate\";\nimport typia from \"typia\";\n\nexport async function test_api_get_category_detail_by_channel_code_and_id(connection: api.IConnection): Promise<void> {\n  // 1. 테스트용 채널 생성\ndefine\n  const channelInput: ICreateChannel = {\n    code: `test-channel-${Date.now()}`,\n    name: \"E2E Test Channel\",\n  };\n  const channel: IShoppingChannel = await api.functional.shoppings.admins.systematic.channels.post(connection, channelInput);\n  typia.assert<IShoppingChannel>(channel);\n\n  // 2. 카테고리 생성\n  const categoryInput: ICreateCategory = {\n    parent_id: null,\n    code: `test-category-${Date.now()}`,\n    name: \"E2E Test Category\",\n  };\n  const category: IShoppingChannelCategory = await api.functional.shoppings.admins.systematic.channels.categories.post(channel.code, connection, { body: categoryInput });\n  typia.assert<IShoppingChannelCategory>(category);\n\n  // 3. 상세 정보 정상 조회\n  const detail: IShoppingChannelCategory = await api.functional.shoppings.customers.systematic.channels.categories.get(channel.code, connection, category.id);\n  typia.assert<IShoppingChannelCategory>(detail);\n  TestValidator.equals(\"category id matches\")(category.id)(detail.id);\n  TestValidator.equals(\"category code matches\")(category.code)(detail.code);\n\n  // 4. 존재하지 않는 id로 조회 시 에러 반환되는지 확인\n  await TestValidator.httpError(\"not found for invalid id\")(404)(\n    () => api.functional.shoppings.customers.systematic.channels.categories.get(channel.code, connection, \"00000000-0000-0000-0000-000000000000\")\n  );\n\n  // 5. 존재하지 않는 channelCode로 조회 시 에러 반환되는지 확인\n  await TestValidator.httpError(\"not found for invalid channel code\")(404)(\n    () => api.functional.shoppings.customers.systematic.channels.categories.get(\"invalid-channel-code\", connection, category.id)\n  );\n}\n",
  "test/features/api/shopping-channel-category/test_get_inverted_category_detail_by_channel_code_and_id.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingChannelCategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingChannelCategory\";\nimport { IShoppingChannel } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingChannel\";\nimport { IShoppingChannelCategory as IInvert } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingChannelCategory.IInvert\";\nimport typia from \"typia\";\n\nexport async function test_api_get_inverted_category_detail_by_channel_code_and_id(connection: api.IConnection): Promise<void> {\n    // 1. 테스트용 채널 생성\n    const channelInput = { code: `test-ch-${Date.now()}`, name: \"Test E2E Channel\" };\n    const channel: IShoppingChannel = await api.functional.shoppings.admins.systematic.channels.post(\n        connection,\n        { body: channelInput }\n    );\n    typia.assert<IShoppingChannel>(channel);\n    \n    // 2. 카테고리 생성 (부모 X)\n    const categoryInput = { parent_id: null, code: `cate-root-${Date.now()}`, name: \"RootCategory\" };\n    const category: IShoppingChannelCategory = await api.functional.shoppings.admins.systematic.channels.categories.post(\n        connection,\n        channel.code,\n        { body: categoryInput }\n    );\n    typia.assert<IShoppingChannelCategory>(category);\n\n    // 3. 정상 케이스: inverted 카테고리 정보 조회\n    const invert = await api.functional.shoppings.customers.systematic.channels.categories.invert.get(\n        connection,\n        channel.code,\n        category.id\n    );\n    typia.assert<IInvert>(invert);\n    TestValidator.equals(\"code\")(category.code)(invert.code);\n    TestValidator.equals(\"name\")(category.name)(invert.name);\n    TestValidator.equals(\"parent_id\")(category.parent_id)(invert.parent_id);\n    TestValidator.equals(\"id\")(category.id)(invert.id);\n    TestValidator.equals(\"parent (null)\")(null)(invert.parent);\n\n    // 4. 실패 케이스: 잘못된 카테고리 id\n    await TestValidator.httpError(\"invalid category id\")(404)(async () => {\n      await api.functional.shoppings.customers.systematic.channels.categories.invert.get(\n        connection,\n        channel.code,\n        \"00000000-0000-0000-0000-000000000000\"\n      );\n    });\n\n    // 5. 실패 케이스: 잘못된 channelCode\n    await TestValidator.httpError(\"invalid channelCode\")(404)(async () => {\n      await api.functional.shoppings.customers.systematic.channels.categories.invert.get(\n        connection,\n        \"not-exist-channel\",\n        category.id\n      );\n    });\n}\n",
  "test/features/api/shopping-channel/test_list_all_channels.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingChannel } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingChannel\";\nimport { IShoppingChannel as IShoppingChannelNamespace } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingChannel\";\nimport { IPageIShoppingChannel } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIShoppingChannel\";\nimport typia from \"typia\";\n\nexport async function test_api_list_all_channels(connection: api.IConnection): Promise<void> {\n    // 1. 채널이 없는 상태에서 목록 조회 - 빈 배열 검증\n    const emptyReq: IShoppingChannelNamespace.IRequest = {};\n    const emptyRes = await api.functional.shoppings.customers.systematic.channels.patch(connection, { body: emptyReq });\n    typia.assert<IPageIShoppingChannel>(emptyRes);\n    TestValidator.equals(\"empty channel list\")(0)(emptyRes.pagination.records);\n    TestValidator.equals(\"empty data array\")([] as IShoppingChannel[])(emptyRes.data);\n\n    // 2. 채널 하나 생성 후 목록 조회\n    const createReq1: IShoppingChannelNamespace.ICreate = { code: \"test-code-1\", name: \"Test Channel 1\" };\n    const channel1 = await api.functional.shoppings.admins.systematic.channels.post(connection, { body: createReq1 });\n    typia.assert<IShoppingChannel>(channel1);\n\n    const oneRes = await api.functional.shoppings.customers.systematic.channels.patch(connection, { body: emptyReq });\n    typia.assert<IPageIShoppingChannel>(oneRes);\n    TestValidator.equals(\"one record\")(1)(oneRes.pagination.records);\n    TestValidator.equals(\"contains channel1\")([channel1])(oneRes.data);\n\n    // 3. 여러 채널 추가 생성 후 목록 조회\n    const createReq2: IShoppingChannelNamespace.ICreate = { code: \"test-code-2\", name: \"Test Channel 2\" };\n    const createReq3: IShoppingChannelNamespace.ICreate = { code: \"test-code-3\", name: \"Test Channel 3\" };\n    const channel2 = await api.functional.shoppings.admins.systematic.channels.post(connection, { body: createReq2 });\n    const channel3 = await api.functional.shoppings.admins.systematic.channels.post(connection, { body: createReq3 });\n    typia.assert<IShoppingChannel>(channel2);\n    typia.assert<IShoppingChannel>(channel3);\n\n    const allRes = await api.functional.shoppings.customers.systematic.channels.patch(connection, { body: emptyReq });\n    typia.assert<IPageIShoppingChannel>(allRes);\n    TestValidator.equals(\"three records\")(3)(allRes.pagination.records);\n    // 데이터 배열이 3개 이상일 경우, 목록 내 포함 여부(순서와 관계 없음) 검증\n    const allIds = allRes.data.map((c) => c.id);\n    TestValidator.predicate(\"channel1 in list\")(() => allIds.includes(channel1.id));\n    TestValidator.predicate(\"channel2 in list\")(() => allIds.includes(channel2.id));\n    TestValidator.predicate(\"channel3 in list\")(() => allIds.includes(channel3.id));\n\n    // 4. 검색조건으로 code 지정하여 특정 채널만 조회\n    const searchReq: IShoppingChannelNamespace.IRequest = { search: { code: channel2.code } };\n    const searchRes = await api.functional.shoppings.customers.systematic.channels.patch(connection, { body: searchReq });\n    typia.assert<IPageIShoppingChannel>(searchRes);\n    TestValidator.equals(\"filtered count\")(1)(searchRes.pagination.records);\n    TestValidator.equals(\"filtered channel\")(channel2)(searchRes.data[0]);\n}\n",
  "test/features/api/shopping-channel/test_list_channels_with_categories_hierarchical.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingChannel } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingChannel\";\nimport { IShoppingChannelCategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingChannelCategory\";\nimport { IShoppingChannelCategory as IShoppingChannelCategoryNS } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingChannelCategory\";\nimport { IPageIShoppingChannel } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIShoppingChannel.IHierarchical\";\nimport typia from \"typia\";\n\nexport async function test_list_channels_with_categories_hierarchical(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. (No Channel) Expect empty data\n  const emptyReq = {};\n  const emptyRes = await api.functional.shoppings.customers.systematic.channels.hierarchical.patch(connection, emptyReq);\n  typia.assert<IPageIShoppingChannel.IHierarchical>(emptyRes);\n  TestValidator.equals(\"no channels should return empty array\")([] as IShoppingChannel.IHierarchical[])(emptyRes.data);\n\n  // 2. Create channelA & channelB\n  const channelAParam = { code: \"testA\", name: \"Test Channel A\" };\n  const channelA = await api.functional.shoppings.admins.systematic.channels.post(connection, channelAParam);\n  typia.assert<IShoppingChannel>(channelA);\n\n  const channelBParam = { code: \"testB\", name: \"Test Channel B\" };\n  const channelB = await api.functional.shoppings.admins.systematic.channels.post(connection, channelBParam);\n  typia.assert<IShoppingChannel>(channelB);\n\n  // 3. Add category to channelA (single depth)\n  const catAParam: IShoppingChannelCategoryNS.ICreate = {\n    parent_id: null, code: \"catRoot\", name: \"Root Category A\"\n  };\n  const catARoot = await api.functional.shoppings.admins.systematic.channels.categories.post(connection, channelA.code, catAParam);\n  typia.assert<IShoppingChannelCategory>(catARoot);\n\n  // 4. channelB: parent + child\n  const catBRootParam: IShoppingChannelCategoryNS.ICreate = {\n    parent_id: null, code: \"catParent\", name: \"Root Category B\"\n  };\n  const catBRoot = await api.functional.shoppings.admins.systematic.channels.categories.post(connection, channelB.code, catBRootParam);\n  typia.assert<IShoppingChannelCategory>(catBRoot);\n\n  const catBChildParam: IShoppingChannelCategoryNS.ICreate = {\n    parent_id: catBRoot.id, code: \"catChild\", name: \"Child Category B\"\n  };\n  const catBChild = await api.functional.shoppings.admins.systematic.channels.categories.post(connection, channelB.code, catBChildParam);\n  typia.assert<IShoppingChannelCategory>(catBChild);\n\n  // 5. Call tree api & verify\n  const treeRes = await api.functional.shoppings.customers.systematic.channels.hierarchical.patch(connection, {});\n  typia.assert<IPageIShoppingChannel.IHierarchical>(treeRes);\n  TestValidator.equals(\"2 channels\")(\n    [channelA.code, channelB.code].sort()\n  )(\n    treeRes.data.map(c => c.code).sort()\n  );\n\n  const chA = treeRes.data.find(c => c.code === channelA.code)!;\n  const chB = treeRes.data.find(c => c.code === channelB.code)!;\n\n  // channelA should have 1 root category and no children\n  TestValidator.equals(\"channelA root categories count\")(1)(chA.categories.length);\n  const catARes = chA.categories[0];\n  TestValidator.equals(\"catA root, no children\")(0)(catARes.children.length);\n\n  // channelB should have 1 root parent & its child\n  TestValidator.equals(\"channelB root categories count\")(1)(chB.categories.length);\n  const catBRes = chB.categories[0];\n  TestValidator.equals(\"catB parent category name\")(\"Root Category B\")(catBRes.name);\n  TestValidator.equals(\"catB has 1 child\")(1)(catBRes.children.length);\n  const bChild = catBRes.children[0];\n  TestValidator.equals(\"catB child name\")(\"Child Category B\")(bChild.name);\n\n  // 6. Error: wrong parent_id\n  const badCatParam: IShoppingChannelCategoryNS.ICreate = {\n    parent_id: \"bdbadbad-1234-4bad-baad-abcdefabcdef\", code: \"errorCat\", name: \"Bad Cat\"\n  };\n  await TestValidator.httpError(\"invalid parent_id must fail\")(400)(\n    () => api.functional.shoppings.admins.systematic.channels.categories.post(connection, channelB.code, badCatParam)\n  );\n}\n",
  "test/features/api/shopping-channel/test_get_channel_detail_by_id.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingChannel } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingChannel\";\nimport { IShoppingChannelCategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingChannelCategory\";\nimport typia from \"typia\";\n\nexport async function test_api_shopping_channel_detail_by_id(connection: api.IConnection): Promise<void> {\n    // 1. 채널 생성\n    const channelInput = {\n        code: `test-channel-${Date.now()}`,\n        name: `테스트채널_${Date.now()}`\n    };\n    const channel: IShoppingChannel = await api.functional.shoppings.admins.systematic.channels.post(\n        connection,\n        channelInput\n    );\n    typia.assert<IShoppingChannel>(channel);\n\n    // 2. 상세 조회\n    const detail = await api.functional.shoppings.customers.systematic.channels.get(\n        connection,\n        channel.id\n    );\n    typia.assert<{\n        categories: IShoppingChannelCategory.IHierarchical[];\n        id: string;\n        created_at: string;\n        code: string;\n        name: string;\n    }>(detail);\n\n    TestValidator.equals(\"id 일치\")(channel.id)(detail.id);\n    TestValidator.equals(\"code 일치\")(channel.code)(detail.code);\n    TestValidator.equals(\"name 일치\")(channel.name)(detail.name);\n    TestValidator.equals(\"created_at 일치\")(channel.created_at)(detail.created_at);\n    TestValidator.equals(\"categories 초기값은 빈 배열\")( [] as IShoppingChannelCategory.IHierarchical[] )(detail.categories);\n\n    // 3. 존재하지 않는 id 에 대해 실패 검증\n    await TestValidator.httpError(\"없는 채널 id 요청시 404\")(404)(\n        async () => {\n            await api.functional.shoppings.customers.systematic.channels.get(\n                connection,\n                \"00000000-0000-4000-8000-000000000000\"\n            );\n        }\n    );\n}\n",
  "test/features/api/channel/test_get_channel_by_code.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingChannel } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingChannel\";\nimport { IShoppingChannel as Hierarchical, IShoppingChannel as IHierarchical } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingChannel.IHierarchical\";\nimport { IShoppingChannel as Channel, IShoppingChannel as ICreate } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingChannel.ICreate\";\nimport typia from \"typia\";\n\nexport async function test_api_channel_get_by_code(connection: api.IConnection): Promise<void> {\n  // step 1: 채널 생성\n  const code = `test-code-${Math.floor(Math.random() * 1e8)}`;\n  const name = `Test 채널 이름 ${Date.now()}`;\n  const input: IShoppingChannel.ICreate = { code, name };\n  const created = await api.functional.shoppings.admins.systematic.channels.post(connection, input);\n  typia.assert<IShoppingChannel>(created);\n  TestValidator.equals(\"created channel code\")<string>(code)(created.code);\n  TestValidator.equals(\"created channel name\")<string>(name)(created.name);\n\n  // step 2: 채널 코드 기반 상세 조회 성공\n  const hierarchical = await api.functional.shoppings.customers.systematic.channels.getByCode(connection, code);\n  typia.assert<IShoppingChannel.IHierarchical>(hierarchical);\n  TestValidator.equals(\"조회 채널 code\")<string>(code)(hierarchical.code);\n  TestValidator.equals(\"조회 채널 name\")<string>(name)(hierarchical.name);\n  TestValidator.equals(\"계층 category 빈배열 확인\")<IShoppingChannelCategory.IHierarchical[]>([])(hierarchical.categories);\n\n  // step 3: 존재하지 않는 code로 조회 시도 (실패 케이스)\n  await TestValidator.error(\"존재하지 않는 code로 조회시 실패 처리\")(\n    () => api.functional.shoppings.customers.systematic.channels.getByCode(connection, \"invalid--noexist--code-9999\")\n  );\n}\n",
  "test/features/api/section/test_list_all_sections.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport { IShoppingSection } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSection\";\nimport { IShoppingSection as ISection } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSection\";\nimport { IPageIShoppingSection } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIShoppingSection\";\n\nexport async function test_list_all_sections(connection: api.IConnection): Promise<void> {\n  // 1. 데이터 없을 때\n  const emptyReq = {};\n  const emptyRes = await api.functional.shoppings.customers.systematic.sections.patch(connection, emptyReq);\n  typia.assert<IPageIShoppingSection>(emptyRes);\n  TestValidator.equals(\"sections - empty\")(([] as ISection[]))(emptyRes.data);\n\n  // 2. 섹션 1개 생성\n  const sectionInput1 = { code: `E2E_SEC01_${Date.now()}`, name: \"테스트 섹션 1\" };\n  const created1 = await api.functional.shoppings.admins.systematic.sections.post(connection, sectionInput1);\n  typia.assert<ISection>(created1);\n\n  // 3. 섹션 1개만 있는 목록 확인\n  const oneRes = await api.functional.shoppings.customers.systematic.sections.patch(connection, {});\n  typia.assert<IPageIShoppingSection>(oneRes);\n  TestValidator.equals(\"sections - one\")(([\n    created1,\n  ] as ISection[]))(oneRes.data);\n\n  // 4. 섹션 2,3 추가 생성\n  const sectionInput2 = { code: `E2E_SEC02_${Date.now()}`, name: \"테스트 섹션 2\" };\n  const created2 = await api.functional.shoppings.admins.systematic.sections.post(connection, sectionInput2);\n  typia.assert<ISection>(created2);\n\n  const sectionInput3 = { code: `E2E_SEC03_${Date.now()}`, name: \"테스트 섹션 3\" };\n  const created3 = await api.functional.shoppings.admins.systematic.sections.post(connection, sectionInput3);\n  typia.assert<ISection>(created3);\n\n  // 5. 목록 - 전체 3개 노출 확인\n  const listRes = await api.functional.shoppings.customers.systematic.sections.patch(connection, {});\n  typia.assert<IPageIShoppingSection>(listRes);\n\n  // code 오름차순 정렬로 비교(목록 API에 정렬옵션 기본 적용 여부 불확실이므로 직접 처리)\n  const expectedAll = [created1, created2, created3].sort((a, b) => a.code.localeCompare(b.code));\n  const actualAll = [...listRes.data].sort((a, b) => a.code.localeCompare(b.code));\n  TestValidator.equals(\"sections - all items & sorted\")(expectedAll)(actualAll);\n\n  // 6. 검색 조건: name 포함\n  const searchByName = { search: { name: \"섹션 2\", code: null } };\n  const searchRes = await api.functional.shoppings.customers.systematic.sections.patch(connection, searchByName);\n  typia.assert<IPageIShoppingSection>(searchRes);\n  TestValidator.equals(\"sections - search by name\")(([\n    created2,\n  ] as ISection[]))(searchRes.data);\n\n  // 7. 정렬 조건: code 내림차순\n  const sortByCodeDesc = { sort: [\"-section.code\"] };\n  const sortedDescRes = await api.functional.shoppings.customers.systematic.sections.patch(connection, sortByCodeDesc);\n  typia.assert<IPageIShoppingSection>(sortedDescRes);\n  const expectedDesc = [created1, created2, created3].sort((a, b) => b.code.localeCompare(a.code));\n  TestValidator.equals(\"sections - sort desc\")(expectedDesc)(sortedDescRes.data);\n\n  // 8. 페이징 검증: limit 2, 첫 페이지\n  const pagingReq = { limit: 2, page: 0, sort: [\"+section.code\"] };\n  const pagingRes = await api.functional.shoppings.customers.systematic.sections.patch(connection, pagingReq);\n  typia.assert<IPageIShoppingSection>(pagingRes);\n  TestValidator.equals(\"sections - paging; page1\")((expectedAll.slice(0, 2)))(pagingRes.data);\n  TestValidator.predicate(\"sections - paging count\")(() => pagingRes.pagination.records === 3 && pagingRes.pagination.pages >= 2);\n}\n",
  "test/features/api/section/test_get_section_detail_by_id.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingSection } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSection\";\nimport { IShoppingSection as IShoppingSectionNamespace } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSection\";\nimport typia from \"typia\";\nimport { v4 as uuidv4 } from \"uuid\";\n\nexport async function test_api_section_detail_by_id(connection: api.IConnection): Promise<void> {\n  // 1. 신규 section 생성 정보 준비\n  const createInput: IShoppingSectionNamespace.ICreate = {\n    code: `SEC_${Date.now()}`,\n    name: \"Test Section Detail\"\n  };\n\n  // 2. section 생성\n  const created: IShoppingSection = await api.functional.shoppings.admins.systematic.sections.post(\n    connection,\n    createInput\n  );\n  typia.assert<IShoppingSection>(created);\n  TestValidator.predicate(\"Section ID returned\")(!!created.id);\n\n  // 3. 생성된 section id로 상세 조회\n  const detail: IShoppingSection = await api.functional.shoppings.customers.systematic.sections.get(\n    connection,\n    created.id\n  );\n  typia.assert<IShoppingSection>(detail);\n  TestValidator.equals(\"Section detail matches\", (key) => key === \"created_at\" || key === \"id\")(\n    {\n      code: createInput.code,\n      name: createInput.name\n    } as any // Only properties under test\n  )(\n    detail\n  );\n\n  // 4. 존재하지 않는 id로 상세 조회 시 오류 응답\n  const randomId = uuidv4();\n  await TestValidator.httpError(\"Not found on non-existent section\")(404)(\n    () => api.functional.shoppings.customers.systematic.sections.get(connection, randomId)\n  );\n}\n",
  "test/features/api/section/test_get_section_detail_by_code.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingSection } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSection\";\nimport typia from \"typia\";\n\nexport async function test_api_section_get_detail_by_code(connection: api.IConnection): Promise<void> {\n    // 1. 신규 섹션 생성\n    const code = `TEST-${Math.random().toString(36).substring(2, 8)}`;\n    const name = `테스트섹션-${Math.random().toString(36).substring(2, 8)}`;\n    const input = { code, name };\n    const section = await api.functional.shoppings.admins.systematic.sections.post(connection, input);\n    typia.assert<IShoppingSection>(section);\n    TestValidator.equals(\"섹션 코드 일치\")<string>(input.code)(section.code);\n    TestValidator.equals(\"섹션 이름 일치\")<string>(input.name)(section.name);\n\n    // 2. 상세조회 정상 - 생성한 코드로 조회\n    const detail = await api.functional.shoppings.customers.systematic.sections.getByCode.get(connection, section.code);\n    typia.assert<IShoppingSection>(detail);\n    TestValidator.equals(\"상세 정보 일치\")<string>(section.id)(detail.id);\n    TestValidator.equals(\"상세 코드 일치\")<string>(section.code)(detail.code);\n    TestValidator.equals(\"상세 이름 일치\")<string>(section.name)(detail.name);\n\n    // 3. 예외 케이스 - 존재하지 않는 코드\n    const invalidCode = \"NOPE-\" + Math.random().toString(36).substring(2, 8);\n    await TestValidator.httpError(\"없는 코드로 요청시 404 에러\")(404)(() =>\n      api.functional.shoppings.customers.systematic.sections.getByCode.get(connection, invalidCode)\n    );\n}\n",
  "test/features/api/seller/test_get_authenticated_seller_info.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport { IShoppingSeller } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSeller\";\nimport { IShoppingMember } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingMember\";\n\nexport async function test_api_get_authenticated_seller_info(connection: api.IConnection): Promise<void> {\n    // 1. 판매자 회원 가입 (빈 객체 전달)\n    const joinInput: IShoppingSeller.IJoin = {};\n    const seller = await api.functional.shoppings.sellers.authenticate.post(connection, joinInput);\n    typia.assert<IShoppingSeller.IInvert>(seller);\n    TestValidator.equals(\"joined seller - id\")<string>(seller.id)(seller.id);\n\n    // 2. 판매자 로그인 (회원 생성시 이메일/비번 자동생성된 것으로 가정, 예시로 seller.member.emails[0].value 사용)\n    const loginInput: IShoppingMember.ILogin = {\n        email: seller.member.emails[0].value,\n        password: \"test-password\"\n    };\n    const loggedIn = await api.functional.shoppings.sellers.authenticate.login.put(connection, loginInput);\n    typia.assert<IShoppingSeller.IInvert>(loggedIn);\n    TestValidator.equals(\"login seller - id\")<string>(seller.id)(loggedIn.id);\n\n    // 3. 로그인 인증상태로 판매자 정보 조회\n    const info = await api.functional.shoppings.sellers.authenticate.get(connection);\n    typia.assert<IShoppingSeller.IInvert>(info);\n    TestValidator.equals(\"get seller after login - id\")<string>(seller.id)(info.id);\n    TestValidator.equals(\"get seller after login - membership id\")<string>(seller.member.id)(info.member.id);\n\n    // 4. 토큰 없이 접근 시 인증 에러 (임의의 connection에서 access_token 제거)\n    const noAuthConnection = { ...connection, access_token: undefined };\n    await TestValidator.httpError(\"no token must be forbidden\")(401, 403)(\n        () => api.functional.shoppings.sellers.authenticate.get(noAuthConnection)\n    );\n\n    // 5. 유효하지 않은 토큰 접근 시 인증 에러\n    const invalidAuthConnection = { ...connection, access_token: \"invalid-token\" };\n    await TestValidator.httpError(\"invalid token must be forbidden\")(401, 403)(\n        () => api.functional.shoppings.sellers.authenticate.get(invalidAuthConnection)\n    );\n}\n",
  "test/features/api/seller/test_join_as_seller.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingSeller } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSeller\";\nimport typia from \"typia\";\n\nexport async function test_join_as_seller(connection: api.IConnection): Promise<void> {\n    // 1. 정상 가입 데이터 준비\n    const joinInput: IShoppingSeller.IJoin = {};\n\n    // 최초 가입 정상 처리\n    const seller = await api.functional.shoppings.sellers.authenticate(connection, joinInput);\n    typia.assert<IShoppingSeller.IInvert>(seller);\n    TestValidator.equals(\"type\")(\"seller\")(seller.type);\n    // seller.member, seller.customer 등 필드가 정상적으로 포함됐는지 체크\n    TestValidator.predicate(\"member.id exists\")(() => !!seller.member.id);\n    TestValidator.predicate(\"customer.id exists\")(() => !!seller.customer.id);\n\n    // 2. 중복 가입 시도: 동일 정보로 다시 가입 요청 (에러 예상)\n    await TestValidator.error(\"duplicate seller join should fail\")(async () => {\n        await api.functional.shoppings.sellers.authenticate(connection, joinInput);\n    });\n\n    // 3. 필수값 누락: 빈 객체 혹은 일부 필드 삭제 (여기선 이미 필드 없음)\n    await TestValidator.error(\"missing required fields should fail\")(async () => {\n        await api.functional.shoppings.sellers.authenticate(connection, {} as any);\n    });\n\n    // 4. 잘못된 포맷: 예를 들면 잘못된 이메일 값 (구조상 joinInput에 email 없음, 예시 생략)\n    // 입력 필드가 없으므로, 포맷 테스트 불가. 구조 업데이트 시 반영 필요.\n}\n",
  "test/features/api/cart-commodity/test_create_cart_commodity_with_various_inputs.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport { IShoppingCartCommodity } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCartCommodity\";\nimport { IShoppingCartCommodity as ICreate } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCartCommodity.ICreate\";\nimport { IShoppingCartCommodityStock as IStockCreate } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCartCommodityStock.ICreate\";\nimport { IShoppingCartCommodityStockChoice as IChoiceCreate } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCartCommodityStockChoice.ICreate\";\n\nexport async function test_create_cart_commodity_with_various_inputs(connection: api.IConnection): Promise<void> {\n  // 1. 정상 데이터로 commodity 생성\n  const validSaleId = \"00000000-0000-4000-8000-000000000001\";\n  const validUnitId = \"00000000-0000-4000-8000-000000000010\";\n  const validStockId = \"00000000-0000-4000-8000-000000000011\";\n  const validOptionId = \"00000000-0000-4000-8000-000000000012\";\n  const commodityInput: ICreate.ICreate = {\n    sale_id: validSaleId,\n    stocks: [\n      {\n        unit_id: validUnitId,\n        stock_id: validStockId,\n        choices: [\n          { option_id: validOptionId, value: \"test-option\"} as IChoiceCreate.ICreate,\n        ],\n        quantity: 1,\n      } as IStockCreate.ICreate,\n    ],\n    volume: 2,\n    accumulate: false,\n  };\n  const created = await api.functional.shoppings.customers.carts.commodities.post(connection, commodityInput);\n  typia.assert<IShoppingCartCommodity>(created);\n  TestValidator.equals(\"volume match\")(commodityInput.volume)(created.volume);\n  TestValidator.predicate(\"id should be uuid\")(() => typeof created.id === \"string\" && created.id.length === 36);\n  TestValidator.predicate(\"orderable flag must exist\")(() => typeof created.orderable === \"boolean\");\n\n  // 2. 존재하지 않는 sale_id 사용(실패 케이스)\n  const invalidSaleInput: ICreate.ICreate = {\n    ...commodityInput,\n    sale_id: \"99999999-9999-4999-8999-999999999999\",\n  };\n  await TestValidator.httpError(\"invalid sale id - should 404 or error\")(404, 422, 400)(\n    () => api.functional.shoppings.customers.carts.commodities.post(connection, invalidSaleInput)\n  );\n\n  // 3. 재고 부족 stock_id 사용(실패 케이스)\n  const outOfStockInput: ICreate.ICreate = {\n    ...commodityInput,\n    stocks: [\n      {\n        ...commodityInput.stocks[0],\n        stock_id: \"00000000-0000-4000-8000-000000000099\", // 가정: 이 id는 재고 없음\n        quantity: 99999,\n      },\n    ]\n  };\n  await TestValidator.httpError(\"out of stock - should 410\")(410)(\n    () => api.functional.shoppings.customers.carts.commodities.post(connection, outOfStockInput)\n  );\n\n  // 4. 동일 상품/옵션/stock 조합 중복 추가 (accumulate=true)\n  const accumulateInput: ICreate.ICreate = { ...commodityInput, accumulate: true };\n  const before = await api.functional.shoppings.customers.carts.commodities.post(connection, accumulateInput);\n  const after = await api.functional.shoppings.customers.carts.commodities.post(connection, accumulateInput);\n  typia.assert<IShoppingCartCommodity>(after);\n  TestValidator.predicate(\"volume should be increased after accumulate\")(() => after.volume === before.volume + commodityInput.volume);\n\n  // 5. 동일 상품/옵션/stock 조합 중복 추가 (accumulate=false, 새 row 생성 예상)\n  const notAccumulateInput: ICreate.ICreate = { ...commodityInput, accumulate: false };\n  const first = await api.functional.shoppings.customers.carts.commodities.post(connection, notAccumulateInput);\n  const second = await api.functional.shoppings.customers.carts.commodities.post(connection, notAccumulateInput);\n  typia.assert<IShoppingCartCommodity>(second);\n  TestValidator.predicate(\"id should differ if not accumulate\")(() => first.id !== second.id);\n}\n",
  "test/features/api/cart-commodity/test_list_all_cart_commodities_for_user.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingCartCommodity } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCartCommodity\";\nimport { IShoppingCartCommodity_ICreate } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCartCommodity.ICreate\";\nimport { IShoppingCartCommodity_IRequest } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCartCommodity.IRequest\";\nimport { IPageIShoppingCartCommodity } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIShoppingCartCommodity\";\nimport typia from \"typia\";\n\nexport async function test_api_cart_commodity_list_all(connection: api.IConnection): Promise<void> {\n    // 1. 장바구니에 아무것도 없는 초기 상태 체크\n    const emptyRequest: IShoppingCartCommodity_IRequest = {};\n    const emptyList = await api.functional.shoppings.customers.carts.commodities.patch(connection, { body: emptyRequest });\n    typia.assert<IPageIShoppingCartCommodity>(emptyList);\n    TestValidator.equals(\"initial cart commodities should be empty\")([] as IShoppingCartCommodity[])(emptyList.data);\n\n    // 2. 상품 2개 추가 후 목록 확인\n    // 테스트용 상품 데이터 구성 - 실제 필드 값 예시로 생성\n    const commodityInput1: IShoppingCartCommodity_ICreate = {\n        sale_id: \"sale-uuid-1\",\n        stocks: [\n            {\n                unit_id: \"unit-uuid-1\",\n                stock_id: \"stock-uuid-1\",\n                choices: [],\n                quantity: 1,\n            },\n        ],\n        volume: 1,\n        accumulate: false,\n    };\n    const commodityInput2: IShoppingCartCommodity_ICreate = {\n        sale_id: \"sale-uuid-2\",\n        stocks: [\n            {\n                unit_id: \"unit-uuid-2\",\n                stock_id: \"stock-uuid-2\",\n                choices: [],\n                quantity: 2,\n            },\n        ],\n        volume: 1,\n        accumulate: false,\n    };\n    const added1 = await api.functional.shoppings.customers.carts.commodities.post(connection, { body: commodityInput1 });\n    const added2 = await api.functional.shoppings.customers.carts.commodities.post(connection, { body: commodityInput2 });\n    typia.assert<IShoppingCartCommodity>(added1);\n    typia.assert<IShoppingCartCommodity>(added2);\n    \n    const listAll = await api.functional.shoppings.customers.carts.commodities.patch(connection, { body: emptyRequest });\n    typia.assert<IPageIShoppingCartCommodity>(listAll);\n    // 포함여부 및 개수 검증\n    TestValidator.equals(\"cart should include both commodities\")(2)(listAll.data.length);\n\n    // 3. 논리 삭제/주문 처리 등으로 인한 제외 상황 시뮬레이션 불가(제공 API 없음)\n    // -> 현재 API 범위에서는 불가 또는 실제 시나리오에서 상품 생성/삭제 기능 추가 상세 필요\n\n    // 4. 인증 실패(잘못된 토큰/connection)\n    const invalidConnection = { ...connection, accessToken: \"invalid-token\" };\n    await TestValidator.httpError(\"invalid connection should be not authorized\")(401, 403)(async () => {\n        await api.functional.shoppings.customers.carts.commodities.patch(invalidConnection, { body: emptyRequest });\n    });\n}\n",
  "test/features/api/cart-commodity/test_get_specific_cart_commodity_by_id.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingCartCommodity } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCartCommodity\";\nimport { IShoppingCartCommodity as IShoppingCartCommodityNS } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCartCommodity\";\nimport typia from \"typia\";\n\nexport async function test_api_cart_commodity_detail_and_exceptions(\n  connection: api.IConnection,\n  anotherConnection: api.IConnection\n): Promise<void> {\n  // 1. 테스트용 장바구니 상품 생성용 입력값 정의\n  // (실제 테스트에서는 아래 값을 유효한 값으로 할당해야 함)\n  const createInput: IShoppingCartCommodityNS.ICreate = {\n    sale_id: \"11111111-1111-1111-1111-111111111111\", // 유효한 sale_id 필요\n    stocks: [\n      {\n        unit_id: \"22222222-2222-2222-2222-222222222222\", // 유효한 unit_id 필요\n        stock_id: \"33333333-3333-3333-3333-333333333333\", // 유효한 stock_id 필요\n        choices: [],\n        quantity: 1,\n      },\n    ],\n    volume: 1,\n    accumulate: null,\n  };\n\n  // commodity 생성\n  const commodity = await api.functional.shoppings.customers.carts.commodities.post(\n    connection,\n    createInput\n  );\n  typia.assert<IShoppingCartCommodity>(commodity);\n  TestValidator.equals(\"id 매칭\")(commodity.id)(commodity.id);\n  TestValidator.equals(\"volume 매칭\")(commodity.volume)(createInput.volume);\n\n  // 2. 정상 케이스: 생성한 id로 상세조회\n  const detail = await api.functional.shoppings.customers.carts.commodities.get(\n    connection,\n    commodity.id\n  );\n  typia.assert<IShoppingCartCommodity>(detail);\n  TestValidator.equals(\"상세조회 id 매칭\")(commodity.id)(detail.id);\n  TestValidator.equals(\"orderable boolean 타입\")(typeof detail.orderable === \"boolean\")(true);\n  TestValidator.equals(\"pseudo boolean 타입\")(typeof detail.pseudo === \"boolean\")(true);\n  TestValidator.equals(\"volume 매칭\")(commodity.volume)(detail.volume);\n\n  // 3. 예외: 존재하지 않는 id 접근 (404)\n  await TestValidator.httpError(\"존재하지 않는 commodity 404\")(404)(async () =>\n    api.functional.shoppings.customers.carts.commodities.get(connection, \"00000000-0000-0000-0000-000000000000\")\n  );\n\n  // 4. 예외: 타인 계정으로 commodity 접근 (권한 403 등)\n  await TestValidator.httpError(\"타인 commodity 접근 금지\")(403)(async () =>\n    api.functional.shoppings.customers.carts.commodities.get(anotherConnection, commodity.id)\n  );\n}\n",
  "test/features/api/cart/test_update_cart_commodity_quantity_and_permissions.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingCartCommodity } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCartCommodity\";\nimport { IShoppingCartCommodity as ICartCommodityNS } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCartCommodity\";\nimport typia from \"typia\";\n\nexport async function test_api_cart_update_commodity_quantity_and_permissions(\n  connection: api.IConnection,\n  anotherConnection: api.IConnection,\n  validSaleId: string,\n  validUnitId: string,\n  validStockId: string,\n  stockQuantity: number,\n): Promise<void> {\n  // 1. Create a new cart commodity\n  const createInput: ICartCommodityNS.ICreate = {\n    sale_id: validSaleId,\n    stocks: [\n      {\n        unit_id: validUnitId,\n        stock_id: validStockId,\n        choices: [],\n        quantity: 1,\n      },\n    ],\n    volume: 1,\n    accumulate: false,\n  };\n  const commodity: IShoppingCartCommodity = await api.functional.shoppings.customers.carts.commodities.post(\n    connection,\n    createInput,\n  );\n  typia.assert<IShoppingCartCommodity>(commodity);\n  const commodityId = commodity.id;\n\n  // 정상: update with valid positive volume <= stock quantity\n  await api.functional.shoppings.customers.carts.commodities.put(\n    connection,\n    commodityId,\n    { volume: Math.min(stockQuantity, 2) }, // 1 또는 2\n  );\n\n  // 예외: update with 0 → error\n  await TestValidator.httpError(\"volume=0 should fail\")(400, 422)(async () =>\n    api.functional.shoppings.customers.carts.commodities.put(\n      connection,\n      commodityId,\n      { volume: 0 },\n    )\n  );\n\n  // 예외: update with negative value → error\n  await TestValidator.httpError(\"volume<0 should fail\")(400, 422)(async () =>\n    api.functional.shoppings.customers.carts.commodities.put(\n      connection,\n      commodityId,\n      { volume: -3 },\n    )\n  );\n\n  // 예외: update with volume > stockQuantity → error\n  await TestValidator.httpError(\"volume>stock should fail\")(410, 400)(async () =>\n    api.functional.shoppings.customers.carts.commodities.put(\n      connection,\n      commodityId,\n      { volume: stockQuantity + 100 },\n    )\n  );\n\n  // 타회원의 장바구니 commodity id를 확보하기 위해 anotherConnection으로 상품 1개 생성\n  const anotherInput: ICartCommodityNS.ICreate = {\n    sale_id: validSaleId,\n    stocks: [\n      {\n        unit_id: validUnitId,\n        stock_id: validStockId,\n        choices: [],\n        quantity: 1,\n      },\n    ],\n    volume: 1,\n    accumulate: false,\n  };\n  const otherCommodity: IShoppingCartCommodity = await api.functional.shoppings.customers.carts.commodities.post(\n    anotherConnection,\n    anotherInput,\n  );\n  typia.assert<IShoppingCartCommodity>(otherCommodity);\n\n  // 소유자가 아닌 사용자가 타인의 commodity에 접근(update) 시도 → 권한 오류\n  await TestValidator.httpError(\"update other's cart commodity forbidden\")(403, 404)(async () =>\n    api.functional.shoppings.customers.carts.commodities.put(\n      connection,\n      otherCommodity.id,\n      { volume: 2 },\n    )\n  );\n}\n",
  "test/features/api/cart-commodity/test_delete_cart_commodity_and_handle_errors.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingCartCommodity } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCartCommodity\";\nimport { IShoppingCartCommodity as IShoppingCartCommodityCreate } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCartCommodity.ICreate\";\nimport typia from \"typia\";\nimport { v4 as uuidv4 } from \"uuid\";\n\nexport async function test_delete_cart_commodity_and_handle_errors(\n  connection: api.IConnection,\n  otherConnection: api.IConnection, // 타인 계정의 커넥션(권한 테스트용)\n): Promise<void> {\n  // 1. 장바구니 상품 생성\n  const createInput: IShoppingCartCommodityCreate = {\n    sale_id: uuidv4(), // 실제 서비스에서는 존재하는 sale_id, unit_id, stock_id 필요\n    stocks: [\n      {\n        unit_id: uuidv4(),\n        stock_id: uuidv4(),\n        choices: [],\n        quantity: 1,\n      },\n    ],\n    volume: 1,\n    accumulate: false,\n  };\n\n  const commodity = await api.functional.shoppings.customers.carts.commodities.post(\n    connection,\n    { body: createInput }\n  );\n  typia.assert<IShoppingCartCommodity>(commodity);\n  \n  // 2. 정상 삭제\n  await api.functional.shoppings.customers.carts.commodities.delete(\n    connection,\n    commodity.id,\n  );\n  \n  // 3. 동일 ID 재삭제 (404)\n  await TestValidator.httpError(\"다시 삭제 시 404 에러\")(404)(\n    () => api.functional.shoppings.customers.carts.commodities.delete(connection, commodity.id)\n  );\n\n  // 4. 존재하지 않는 id로 삭제 시도 (404)\n  const nonexistentId = uuidv4();\n  await TestValidator.httpError(\"존재하지 않는 ID 삭제 시 404 에러\")(404)(\n    () => api.functional.shoppings.customers.carts.commodities.delete(connection, nonexistentId)\n  );\n\n  // 5. 타인 커넥션으로 삭제 시도 (403 또는 404)\n  await TestValidator.httpError(\"타인 연결로 삭제 시 접근 거부\")(403, 404)(\n    () => api.functional.shoppings.customers.carts.commodities.delete(otherConnection, commodity.id)\n  );\n}\n",
  "test/features/api/shopping-cart-commodity/test_get_cart_commodity_replica.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingCartCommodity } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCartCommodity\";\nimport { IShoppingCartCommodityStock } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCartCommodityStock\";\nimport { IShoppingCartCommodityStockChoice } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCartCommodityStockChoice\";\nimport { IShoppingCartCommodity as IShoppingCartCommodityCreate } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCartCommodity.ICreate\";\nimport typia from \"typia\";\n\nimport { v4 as uuidv4 } from \"uuid\";\n\nexport async function test_api_shopping_cart_commodity_replica(connection: api.IConnection): Promise<void> {\n  // 1. 사전: 상품생성을 위한 입력값 세팅 (적합한 sale/unit/stock UUID 요구)\n  // 실제 fixture/헬퍼가 있다면 활용할 것.\n  // 아래 값들은 반드시 유효해야 합니다.\n  const sale_id = \"a-valid-sale-uuid\"; // 실제 유효한 sale uuid 필요\n  const unit_id = \"a-valid-unit-uuid\"; // 유효한 unit uuid\n  const stock_id = \"a-valid-stock-uuid\"; // 유효한 stock uuid\n  \n  // 선택옵션이 필요하다면 minimal empty array. 필수 옵션 test 필요시에는 적절히 구성\n  const input: IShoppingCartCommodity.ICreate = {\n    sale_id,\n    stocks: [\n      {\n        unit_id,\n        stock_id,\n        choices: [] as IShoppingCartCommodityStockChoice.ICreate[],\n        quantity: 1,\n      }\n    ],\n    volume: 1,\n    accumulate: false\n  };\n\n  // 2. 상품 생성\n  const created = await api.functional.shoppings.customers.carts.commodities.post(connection, { body: input });\n  typia.assert<IShoppingCartCommodity>(created);\n  TestValidator.predicate(\"Commodity created\")(!!created.id);\n\n  // 3. 정상 복제 정보 조회\n  const replica = await api.functional.shoppings.customers.carts.commodities.replica(connection, created.id);\n  typia.assert<IShoppingCartCommodity.ICreate>(replica);\n  // 주요 필드 기본값 동등성 (sale_id, stocks, volume 등)\n  TestValidator.equals(\"replica sale_id\")(input.sale_id)(replica.sale_id);\n  TestValidator.equals(\"replica volume\")(input.volume)(replica.volume);\n  TestValidator.equals(\"replica stocks length\")(input.stocks.length)(replica.stocks.length);\n\n  // 4. 존재하지 않는 id (404 또는 410)\n  await TestValidator.httpError(\"not found or gone error\")(404, 410)(async () => {\n    await api.functional.shoppings.customers.carts.commodities.replica(connection, uuidv4());\n  });\n\n  // 5. 인증이 없는 커넥션/권한 부족 (가능하다면 시도)\n  // const anonConnection = { ... }; // 실제 미인증 커넥션 방법에 따라 작성\n  // await TestValidator.httpError(\"forbidden error\")(403)(async () => {\n  //   await api.functional.shoppings.customers.carts.commodities.replica(anonConnection, created.id);\n  // });\n}\n",
  "test/features/api/cart/test_list_discountable_information_for_cart_commodities.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport {\n  IShoppingCartCommodity,\n} from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCartCommodity\";\nimport {\n  IShoppingCartCommodity as ICartCommodityNamespace,\n} from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCartCommodity\";\nimport {\n  IShoppingCartCommodityStock,\n} from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCartCommodityStock\";\nimport {\n  IShoppingCartCommodityStockChoice,\n} from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCartCommodityStockChoice\";\nimport {\n  IShoppingCartDiscountable,\n  IShoppingCartDiscountable as DiscountableNamespace,\n} from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCartDiscountable\";\n\nexport async function test_api_cart_discountable_information(\n  connection: api.IConnection,\n): Promise<void> {\n  // (1) 장바구니 상품 담기 (다양한 상품, 단순 예시)\n  const input1: ICartCommodityNamespace.ICreate = {\n    sale_id: \"00000000-0000-0000-0000-000000000001\",\n    stocks: [\n      {\n        unit_id: \"00000000-0000-0000-0000-0000000000a0\",\n        stock_id: \"00000000-0000-0000-0000-0000000000aa\",\n        choices: [],\n        quantity: 1,\n      },\n    ],\n    volume: 1,\n    accumulate: false,\n  };\n  const input2: ICartCommodityNamespace.ICreate = {\n    sale_id: \"00000000-0000-0000-0000-000000000002\",\n    stocks: [\n      {\n        unit_id: \"00000000-0000-0000-0000-0000000000b0\",\n        stock_id: \"00000000-0000-0000-0000-0000000000bb\",\n        choices: [],\n        quantity: 2,\n      },\n    ],\n    volume: 2,\n    accumulate: true,\n  };\n  // 장바구니에 상품 추가\n  const commodity1 = await api.functional.shoppings.customers.carts.commodities.post(connection, { body: input1 });\n  const commodity2 = await api.functional.shoppings.customers.carts.commodities.post(connection, { body: input2 });\n  typia.assert<IShoppingCartCommodity>(commodity1);\n  typia.assert<IShoppingCartCommodity>(commodity2);\n\n  // (2) 할인정보 조회 요청\n  const req: DiscountableNamespace.IRequest = {\n    commodity_ids: [commodity1.id, commodity2.id],\n    pseudos: [], // 실제 장바구니 상태만 계산\n  };\n  const discountable = await api.functional.shoppings.customers.carts.commodities.discountable.patch(connection, { body: req });\n  typia.assert<IShoppingCartDiscountable>(discountable);\n  TestValidator.predicate(\"combinations is array\")(() => Array.isArray(discountable.combinations));\n  TestValidator.predicate(\"deposit is number\")(() => typeof discountable.deposit === \"number\");\n  TestValidator.predicate(\"mileage is number\")(() => typeof discountable.mileage === \"number\");\n\n  // (3) 경계 케이스: 장바구니 비어있을 때\n  const emptyReq: DiscountableNamespace.IRequest = {\n    commodity_ids: [],\n    pseudos: [],\n  };\n  const emptyDiscountable = await api.functional.shoppings.customers.carts.commodities.discountable.patch(connection, { body: emptyReq });\n  typia.assert<IShoppingCartDiscountable>(emptyDiscountable);\n  TestValidator.equals(\"empty combinations[]\")([] as DiscountableNamespace.ICombination[])(emptyDiscountable.combinations);\n\n  // (4) 잘못된 pseudos (없는 상품)도 커버\n  const pseudoReq: DiscountableNamespace.IRequest = {\n    commodity_ids: null,\n    pseudos: [\n      {\n        sale_id: \"non-existent-sale\",\n        stocks: [],\n        volume: 1,\n        accumulate: null,\n      },\n    ],\n  };\n  await TestValidator.error(\"invalid pseudos should error\")(() =>\n    api.functional.shoppings.customers.carts.commodities.discountable.patch(connection, { body: pseudoReq })\n  );\n}\n",
  "test/features/api/order/test_create_order_from_cart_commodities.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingCartCommodity, IShoppingCartCommodityStock, IShoppingCartCommodityStockChoice } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCartCommodity\";\nimport { IShoppingOrder, IShoppingOrderGood, IShoppingOrderPrice } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingOrder\";\nimport typia from \"typia\";\n\nexport async function test_create_order_from_cart_commodities(connection: api.IConnection): Promise<void> {\n    // 1. 정상 케이스: 장바구니에 상품 추가 및 주문 생성\n    // 준비: 정상 재고 값/volume으로 장바구니 commodity 생성\n    const commodityInput = {\n        sale_id: \"sale-uuid-001\",\n        stocks: [\n            {\n                unit_id: \"unit-uuid-a\",\n                stock_id: \"stock-uuid-a1\",\n                choices: [],\n                quantity: 1,\n            },\n        ],\n        volume: 2,\n        accumulate: false,\n    };\n    const commodity: IShoppingCartCommodity = await api.functional.shoppings.customers.carts.commodities.post(connection, commodityInput);\n    typia.assert<IShoppingCartCommodity>(commodity);\n    TestValidator.predicate(\"orderable after add commodity\")(() => commodity.orderable === true);\n\n    // 주문 생성\n    const orderInput = {\n        goods: [\n            {\n                commodity_id: commodity.id,\n                volume: 2,\n            },\n        ],\n    };\n    const order: IShoppingOrder = await api.functional.shoppings.customers.orders.post(connection, orderInput);\n    typia.assert<IShoppingOrder>(order);\n    TestValidator.equals(\"order goods length\")(order.goods.length)(1);\n    TestValidator.predicate(\"order good maps commodity\")(() => order.goods[0].commodity.id === commodity.id);\n\n    // 2. 장바구니 비어있음: 비정상 주문 - 빈 장바구니로 주문 시도\n    const emptyOrderInput = { goods: [] };\n    await TestValidator.httpError(\"empty order goods\")(400)(async () => {\n        await api.functional.shoppings.customers.orders.post(connection, emptyOrderInput);\n    });\n\n    // 3. 재고 부족 케이스: 재고 부족(예시: quantity 99999)로 commodity 생성 후 주문 시도\n    const insufficientStockCommodityInput = {\n        sale_id: \"sale-uuid-001\",\n        stocks: [\n            {\n                unit_id: \"unit-uuid-a\",\n                stock_id: \"stock-uuid-a1\",\n                choices: [],\n                quantity: 99999,\n            },\n        ],\n        volume: 1,\n        accumulate: false,\n    };\n    await TestValidator.httpError(\"insufficient stock commodity\")(410)(async () => {\n        await api.functional.shoppings.customers.carts.commodities.post(connection, insufficientStockCommodityInput);\n    });\n\n    // 4. 잘못된 결제 정보: volume==0으로 주문 시도\n    const invalidVolumeOrderInput = {\n        goods: [\n            {\n                commodity_id: commodity.id,\n                volume: 0,\n            },\n        ],\n    };\n    await TestValidator.httpError(\"invalid order volume\")(400)(async () => {\n        await api.functional.shoppings.customers.orders.post(connection, invalidVolumeOrderInput);\n    });\n}\n",
  "test/features/api/order/test_list_all_orders_for_user.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport { IShoppingOrder } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingOrder\";\nimport { IShoppingOrder_ICreate } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingOrder.ICreate\";\nimport { IShoppingOrderGood_ICreate } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingOrderGood.ICreate\";\nimport { IShoppingOrder_IRequest } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingOrder.IRequest\";\nimport { IPageIShoppingOrder } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIShoppingOrder\";\n\nexport async function test_list_all_orders_for_user(connection: api.IConnection): Promise<void> {\n  // 1. 주문 내역이 없는 상태 조회\n  const emptyReq: IShoppingOrder_IRequest = {};\n  const emptyResp = await api.functional.shoppings.customers.orders.patch(connection, { body: emptyReq });\n  typia.assert<IPageIShoppingOrder>(emptyResp);\n  TestValidator.equals(\"empty list\")((): IShoppingOrder[] => [])(() => emptyResp.data);\n  TestValidator.equals(\"empty pagination check\")(() => 0)(() => emptyResp.pagination.records);\n\n  // 2. 주문 두 건 등록\n  const goods1: IShoppingOrderGood_ICreate = {\n    commodity_id: \"11111111-1111-1111-1111-111111111111\", // 실제 상품 장바구니 commodity uuid 필요\n    volume: 2\n  };\n  const goods2: IShoppingOrderGood_ICreate = {\n    commodity_id: \"22222222-2222-2222-2222-222222222222\",\n    volume: 1\n  };\n  const create1: IShoppingOrder_ICreate = {\n    goods: [goods1],\n    name: \"테스트주문1\"\n  };\n  const create2: IShoppingOrder_ICreate = {\n    goods: [goods2],\n    name: \"테스트주문2\"\n  };\n  const order1 = await api.functional.shoppings.customers.orders.post(connection, { body: create1 });\n  typia.assert<IShoppingOrder>(order1);\n  const order2 = await api.functional.shoppings.customers.orders.post(connection, { body: create2 });\n  typia.assert<IShoppingOrder>(order2);\n\n  // 3. 주문 목록 재조회(2건)\n  const listResp = await api.functional.shoppings.customers.orders.patch(connection, { body: emptyReq });\n  typia.assert<IPageIShoppingOrder>(listResp);\n  TestValidator.equals(\"pagination count\")((): number => 2)(() => listResp.pagination.records);\n  // 등록한 주문 ID 모두 포함 여부\n  const orderIds = [order1.id, order2.id];\n  TestValidator.predicate(\"contains all created orders\")(() =>\n    orderIds.every(id => listResp.data.some(o => o.id === id))\n  );\n\n  // 4. 인증 해제 사용자 에러(401)\n  const dummyConn: api.IConnection = { ...connection, headers: { ...connection.headers, authorization: undefined } };\n  await TestValidator.httpError(\"unauthorized access\")(401)(async () => {\n    await api.functional.shoppings.customers.orders.patch(dummyConn, { body: emptyReq });\n  });\n}\n",
  "test/features/api/order/test_create_direct_order_without_cart.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport { IShoppingOrder } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingOrder\";\nimport { IShoppingCartCommodity } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCartCommodity\";\nimport { IShoppingCartCommodityStock } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCartCommodityStock\";\n\nexport async function test_api_create_direct_order_without_cart(connection: api.IConnection): Promise<void> {\n    // 정상 케이스: 정상 주문 생성하기 (유효한 상품ID/재고ID 필요)\n    const validSaleId = \"00000000-0000-4000-8000-000000000001\"; // 테스트용 유효한 값(실제 테스트 환경에서는 적절히 할당 필요)\n    const validUnitId = \"00000000-0000-4000-8000-000000000101\";\n    const validStockId = \"00000000-0000-4000-8000-000000000201\";\n    const createInput: IShoppingCartCommodity.ICreate = {\n        sale_id: validSaleId,\n        stocks: [\n            {\n                unit_id: validUnitId,\n                stock_id: validStockId,\n                choices: [], // 선택형 옵션만 있는 경우 빈 배열\n                quantity: 1,\n            }\n        ],\n        volume: 1,\n    };\n\n    const order = await api.functional.shoppings.customers.orders.direct(\n        connection,\n        createInput,\n    );\n\n    typia.assert<IShoppingOrder>(order);\n    TestValidator.predicate(\"created order id should be defined\")(!!order.id);\n    TestValidator.predicate(\"created order customer should exist\")(!!order.customer);\n    TestValidator.predicate(\"order.goods count > 0\")(order.goods.length > 0);\n    TestValidator.predicate(\"order.price.nominal >= 0\")(order.price.nominal >= 0);\n    TestValidator.predicate(\"order.created_at defined\")(!!order.created_at);\n\n    // 2. 필수 파라미터 누락 케이스별로 요청 및 400 오류 확인\n    // (a) sale_id 누락\n    await TestValidator.httpError(\"missing sale_id\")(400)(async () =>\n        api.functional.shoppings.customers.orders.direct(connection, {\n            // @ts-expect-error\n            stocks: createInput.stocks,\n            volume: createInput.volume,\n        })\n    );\n    // (b) stocks 누락\n    await TestValidator.httpError(\"missing stocks\")(400)(async () =>\n        api.functional.shoppings.customers.orders.direct(connection, {\n            sale_id: createInput.sale_id,\n            // @ts-expect-error\n            volume: createInput.volume,\n        })\n    );\n    // (c) volume 누락\n    await TestValidator.httpError(\"missing volume\")(400)(async () =>\n        api.functional.shoppings.customers.orders.direct(connection, {\n            sale_id: createInput.sale_id,\n            stocks: createInput.stocks,\n            // @ts-expect-error\n        })\n    );\n\n    // 3. 잘못된 상품ID (존재하지 않는 UUID)\n    await TestValidator.httpError(\"invalid sale_id\")(404, 400)(async () =>\n        api.functional.shoppings.customers.orders.direct(connection, {\n            ...createInput,\n            sale_id: \"11111111-2222-4333-9333-999999999999\",\n        })\n    );\n\n    // 4. 재고 부족/유효하지 않은 재고ID\n    await TestValidator.httpError(\"invalid stock_id\")(400, 409)(async () =>\n        api.functional.shoppings.customers.orders.direct(connection, {\n            ...createInput,\n            stocks: [\n                {\n                    ...createInput.stocks[0],\n                    stock_id: \"12345678-1111-4222-8999-000000000000\",\n                },\n            ],\n        })\n    );\n\n    // 5. stocks/choices 타입 검증(\"choices\" 잘못된 타입): string 대신 object 배열 필요\n    await TestValidator.httpError(\"invalid choices type\")(400)(async () =>\n        api.functional.shoppings.customers.orders.direct(connection, {\n            ...createInput,\n            stocks: [\n                {\n                    ...createInput.stocks[0],\n                    // @ts-expect-error\n                    choices: \"not-array\",\n                },\n            ],\n        })\n    );\n}",
  "test/features/api/order/test_get_order_info_by_id_with_permissions.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport { IShoppingOrder } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingOrder\";\nimport { IShoppingOrder as IShoppingOrderInput } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingOrder.ICreate\";\n\nexport async function test_get_order_info_by_id_with_permissions(connection: api.IConnection): Promise<void> {\n    // 고객1로 주문 생성\n    const commodityId1 = \"11111111-1111-1111-1111-111111111111\"; // 샘플값, 실제 테스트환경에 맞게 대체 필요\n    const orderCreate1 = { goods: [{ commodity_id: commodityId1, volume: 1 }], name: \"주문1\" };\n    const order1 = await api.functional.shoppings.customers.orders.post(connection, orderCreate1);\n    typia.assert<IShoppingOrder>(order1);\n\n    // 고객2의 connection mocking (다른 계정 로그인)\n    const anotherConnection: api.IConnection = { ...connection, headers: { ...(connection.headers || {}), authorization: \"Bearer fake-user-2-token\" } };\n    const commodityId2 = \"22222222-2222-2222-2222-222222222222\"; // 마찬가지로 대체 필요\n    const orderCreate2 = { goods: [{ commodity_id: commodityId2, volume: 2 }], name: \"주문2\" };\n    const order2 = await api.functional.shoppings.customers.orders.post(anotherConnection, orderCreate2);\n    typia.assert<IShoppingOrder>(order2);\n\n    // 주문 정상 조회 (본인)\n    const getOrder1 = await api.functional.shoppings.customers.orders.get(connection, order1.id);\n    typia.assert<IShoppingOrder>(getOrder1);\n    TestValidator.equals(\"본인 주문 조회 결과 동등성\")<IShoppingOrder>(order1)(getOrder1);\n\n    // 타인 주문 접근 시 권한 오류 또는 접근 불가 (403/404 등)\n    await TestValidator.httpError(\"타인 주문 조회 접근 제한\")(403, 404)(async () => {\n        await api.functional.shoppings.customers.orders.get(connection, order2.id);\n    });\n\n    // 존재하지 않는 주문 id로 조회시 404\n    await TestValidator.httpError(\"존재하지 않는 주문 조회 실패\")(404)(async () => {\n        await api.functional.shoppings.customers.orders.get(connection, \"99999999-9999-9999-9999-999999999999\");\n    });\n}\n",
  "test/features/api/order/test_delete_order_and_validate_constraints.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingOrder } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingOrder\";\nimport { IShoppingOrderGood } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingOrderGood\";\nimport { IShoppingOrder_ICreate } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingOrder\";\nimport typia from \"typia\";\n\nexport async function test_api_delete_order_and_validate_constraints(\n  connection: api.IConnection,\n  connection2?: api.IConnection\n): Promise<void> {\n  // 1. 결제 전 주문 생성\n  const input: IShoppingOrder_ICreate = {\n    goods: [\n      { commodity_id: \"11111111-1111-1111-1111-111111111111\", volume: 1 } // 예시 commodity_id, 실제 테스트 환경에 맞게 바꾸어야 함\n    ],\n    name: \"테스트 주문\"\n  };\n  const order = await api.functional.shoppings.customers.orders.post(\n    connection,\n    { body: input }\n  );\n  typia.assert<IShoppingOrder>(order);\n\n  // 2. 정상 주문 삭제\n  await TestValidator.predicate(\"delete success\")(\n    async () => {\n      await api.functional.shoppings.customers.orders.delete(\n        connection,\n        order.id\n      );\n      return true;\n    }\n  );\n\n  // 3. 삭제된 주문 재삭제(존재X) => 404\n  await TestValidator.httpError(\"already deleted to 404\")(404)(\n    () =>\n      api.functional.shoppings.customers.orders.delete(\n        connection,\n        order.id\n      )\n  );\n\n  // 4. 존재하지 않는 주문 id 삭제 => 404\n  await TestValidator.httpError(\"not found order to 404\")(404)(\n    () =>\n      api.functional.shoppings.customers.orders.delete(\n        connection,\n        \"00000000-0000-0000-0000-000000000000\"\n      )\n  );\n\n  // 5. 타인 주문 삭제시 403 에러\n  if (connection2) {\n    // connection2로 동일 주문 id 삭제 시도\n    await TestValidator.httpError(\"forbidden for other's order\")(403, 404)(\n      () =>\n        api.functional.shoppings.customers.orders.delete(\n          connection2,\n          order.id\n        )\n    );\n  }\n}",
  "test/features/api/order/test_get_order_price_calculation_and_permissions.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingOrder } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingOrder\";\nimport { IShoppingOrderPrice } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingOrderPrice\";\nimport { IShoppingOrder_ICreate } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingOrder.ICreate\";\nimport typia from \"typia\";\n\nexport async function test_api_order_get_price_calculation_and_permissions(connection: api.IConnection, otherConnection: api.IConnection): Promise<void> {\n    // 1. 정상 주문 생성\n    const createInput: IShoppingOrder_ICreate = {\n        goods: [\n            { commodity_id: \"00000000-0000-0000-0000-000000000001\", volume: 1 }\n        ],\n        name: \"E2E 주문 가격 검증\"\n    };\n    const order: IShoppingOrder = await api.functional.shoppings.customers.orders.post(connection, createInput);\n    \n    // 2. 내 주문 가격 정상조회\n    const price: IShoppingOrderPrice = await api.functional.shoppings.customers.orders.price(connection, order.id);\n    typia.assert<IShoppingOrderPrice>(price);\n    TestValidator.predicate(\"real price should be positive\")(() => price.real >= 0);\n    TestValidator.predicate(\"nominal price >= real price\")(() => price.nominal >= price.real);\n    // 할인, 적립금, 쿠폰 등이 있을 경우 음수 아닐 것\n    TestValidator.predicate(\"deposit/mileage/ticket non-negative\")( () =>  price.deposit >=0 && price.mileage >=0 && price.ticket >=0);\n\n    // 3. 존재하지 않는 주문 ID로 조회 (404 등 예상)\n    const invalidOrderId = \"11111111-1111-1111-1111-111111111111\";\n    await TestValidator.httpError(\"invalid order id price\", 404)(\n        () => api.functional.shoppings.customers.orders.price(connection, invalidOrderId)\n    );\n\n    // 4. 타인 주문(다른 사용자) 가격 조회 권한 거부 확인 (403 등 예상)\n    const otherOrder: IShoppingOrder = await api.functional.shoppings.customers.orders.post(otherConnection, createInput);\n    await TestValidator.httpError(\"forbidden other user order\", 403, 404)(\n        () => api.functional.shoppings.customers.orders.price(connection, otherOrder.id)\n    );\n}\n",
  "test/features/api/shopping-order/test_get_discountable_info_for_order.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingOrder } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingOrder\";\nimport { IShoppingOrderDiscountable } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingOrderDiscountable\";\nimport { IShoppingOrderDiscountable_IRequest } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingOrderDiscountable.IRequest\";\nimport { IShoppingOrder_ICreate } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingOrder.ICreate\";\nimport typia from \"typia\";\n\nexport async function test_api_shopping_order_discountable_patch(connection: api.IConnection): Promise<void> {\n    // 1. 주문 생성(의존성)\n    const createInput: IShoppingOrder_ICreate = {\n        goods: [\n            {\n                commodity_id: \"11111111-1111-1111-1111-111111111111\", // 실제 테스트 환경에서는 유효한 장바구니 커모디티 ID로 대체 필요\n                volume: 1\n            }\n        ],\n        name: \"E2E 할인 테스트용 주문\"\n    };\n    let order: IShoppingOrder;\n    try {\n        order = await api.functional.shoppings.customers.orders.post(connection, createInput);\n    } catch (err) {\n        throw new Error(\"테스트용 주문 생성을 실패했습니다.\");\n    }\n    typia.assert<IShoppingOrder>(order);\n    TestValidator.predicate(\"order.id 존재\")(!!order.id);\n\n    // 2. 정상 요청: 할인 정보 조회\n    const discountInput: IShoppingOrderDiscountable_IRequest = {\n        good_ids: null\n    };\n    const discountable = await api.functional.shoppings.customers.orders.discountable.patch(connection, order.id, discountInput);\n    typia.assert<IShoppingOrderDiscountable>(discountable);\n    TestValidator.predicate(\"discountable.combinations 배열\")(Array.isArray(discountable.combinations));\n    TestValidator.predicate(\"discountable.deposit 타입\")(typeof discountable.deposit === \"number\");\n    TestValidator.predicate(\"discountable.mileage 타입\")(typeof discountable.mileage === \"number\");\n\n    // 3. 예외: 잘못된 주문 ID\n    await TestValidator.httpError(\"존재하지 않는 주문 ID\", 404)(async () =>\n        await api.functional.shoppings.customers.orders.discountable.patch(connection, \"00000000-0000-0000-0000-000000000000\", discountInput)\n    );\n\n    // 4. 예외: 권한 없는 접근 (다른 사용자의 connection 사용 가정)\n    // 실제 환경에서 타 계정 connection을 생성해서 테스트 필요, 여기선 단순화\n    const fakeConnection = { ...connection, headers: { ...(connection.headers || {}), authorization: \"Bearer invalid_token\" } };\n    await TestValidator.httpError(\"권한 없음\", 403, 401)(async () =>\n        await api.functional.shoppings.customers.orders.discountable.patch(fakeConnection as api.IConnection, order.id, discountInput)\n    );\n\n    // (선택) 후처리: 테스트용 주문 정리 로직(별도 API가 있으면 추가)\n}\n",
  "test/features/api/order/test_apply_discount_to_order_and_handle_edge_cases.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport { IShoppingOrder } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingOrder\";\nimport { IShoppingOrderGood } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingOrderGood\";\nimport { IShoppingOrderPrice } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingOrderPrice\";\nimport { IShoppingOrderPrice as IShoppingOrderPriceCreate } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingOrderPrice.ICreate\";\nimport { IShoppingOrder as IShoppingOrderCreate } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingOrder.ICreate\";\n\nexport async function test_api_order_discount_apply_and_error_cases(connection: api.IConnection): Promise<void> {\n  // 1. 할인 적용 가능한 주문 생성\n  const orderInput: IShoppingOrderCreate = {\n    goods: [\n      {\n        commodity_id: \"00000000-0000-0000-0000-000000000201\", // 실제 테스트 환경에 맞게 조정\n        volume: 1,\n      },\n    ],\n    name: \"할인테스트주문\",\n  };\n  const order = await api.functional.shoppings.customers.orders.post(connection, orderInput);\n  typia.assert<IShoppingOrder>(order);\n\n  // 2. 정상 할인 적용 (쿠폰, 마일리지, 디포짓 모두 0, 실제 쿠폰ID/마일리지는 추가 환경에 맞게 대입)\n  const validDiscountInput = {\n    deposit: 0,\n    mileage: 0,\n    coupon_ids: [],\n  };\n  const validDiscount = await api.functional.shoppings.customers.orders.discount.put(\n    connection,\n    order.id,\n    validDiscountInput,\n  );\n  typia.assert<IShoppingOrderPrice>(validDiscount);\n  TestValidator.predicate(\"real price should remain unchanged without actual discounts\")(\n    () => validDiscount.real === order.price.real,\n  );\n\n  // 3. 오류: 동일 쿠폰 2회 적용 (중복)\n  const duplicateCouponDiscountInput = {\n    deposit: 0,\n    mileage: 0,\n    coupon_ids: [\"00000000-0000-0000-0000-000000000501\", \"00000000-0000-0000-0000-000000000501\"],\n  };\n  await TestValidator.httpError(\"duplicate coupon apply should fail\")(428)(async () => {\n    await api.functional.shoppings.customers.orders.discount.put(\n      connection,\n      order.id,\n      duplicateCouponDiscountInput,\n    );\n  });\n\n  // 4. 만료된 쿠폰 적용\n  const expiredCouponDiscountInput = {\n    deposit: 0,\n    mileage: 0,\n    coupon_ids: [\"00000000-0000-0000-0000-000000000599\"],\n  };\n  await TestValidator.httpError(\"expired coupon apply should fail\")(428)(async () => {\n    await api.functional.shoppings.customers.orders.discount.put(\n      connection,\n      order.id,\n      expiredCouponDiscountInput,\n    );\n  });\n\n  // 5. 조건 미충족 (총액 부족 등) 쿠폰 적용\n  const notMeetConditionCouponDiscountInput = {\n    deposit: 0,\n    mileage: 0,\n    coupon_ids: [\"00000000-0000-0000-0000-000000000511\"],\n  };\n  await TestValidator.httpError(\"not meet condition coupon apply should fail\")(428)(async () => {\n    await api.functional.shoppings.customers.orders.discount.put(\n      connection,\n      order.id,\n      notMeetConditionCouponDiscountInput,\n    );\n  });\n\n  // 6. 존재하지 않는 쿠폰ID\n  const notExistCouponDiscountInput = {\n    deposit: 0,\n    mileage: 0,\n    coupon_ids: [\"00000000-0000-0000-0000-000000009999\"],\n  };\n  await TestValidator.httpError(\"coupon id not found should fail\")(428, 404)(async () => {\n    await api.functional.shoppings.customers.orders.discount.put(\n      connection,\n      order.id,\n      notExistCouponDiscountInput,\n    );\n  });\n\n  // 7. 만료/실패 케이스 외 정상 할인(쿠폰ID 하나라도 제대로 주면 할인 적용)\n  // (쿠폰 시스템이 실제 연결된 환경이라면 실제 쿠폰ID 대입 필요)\n  // const realCouponDiscountInput = {\n  //   deposit: 0,\n  //   mileage: 0,\n  //   coupon_ids: [\"실제유효쿠폰ID\"],\n  // };\n  // const realCouponDiscount = await api.functional.shoppings.customers.orders.discount.put(\n  //   connection,\n  //   order.id,\n  //   realCouponDiscountInput,\n  // );\n  // typia.assert<IShoppingOrderPrice>(realCouponDiscount);\n  // TestValidator.predicate(\"discounted price should be less than original\")(\n  //   () => realCouponDiscount.real < order.price.real\n  // );\n}\n",
  "test/features/api/order/test_confirm_order_goods_and_validate_states.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingOrder } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingOrder\";\nimport { IShoppingOrderGood } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingOrderGood\";\nimport { IShoppingOrder_ICreate } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingOrder.ICreate\";\nimport typia from \"typia\";\n\nexport async function test_api_order_confirm_order_goods_and_validate_states(connection: api.IConnection): Promise<void> {\n  // 1. 신규 주문 생성 (함수 dependsOn)\n  // Assume prepareOrderInput returns a valid goods list for current user\n  const orderInput: IShoppingOrder_ICreate = {\n    name: \"E2E Test 주문확정 시나리오\",\n    goods: [\n      {\n        commodity_id: \"commodity-uuid-1\", // 실제 테스트에선 동적으로 생성 필요\n        volume: 1\n      }\n    ]\n  };\n  const order: IShoppingOrder = await api.functional.shoppings.customers.orders.post(connection, orderInput);\n  typia.assert<IShoppingOrder>(order);\n  TestValidator.equals(\"order.goods length = 1\")<number>(order.goods.length)(1);\n\n  const good = order.goods[0];\n  typia.assert<IShoppingOrderGood>(good);\n\n  // 3. 배송/결제 미충족 상태에서 구매확정 시 428 오류\n  await TestValidator.httpError(\"미결제/미배송 상태 상품 구매확정시 428 오류\")\n    (428)(\n      async () => {\n        await api.functional.shoppings.customers.orders.goods.confirm(\n          connection,\n          order.id,\n          good.id\n        );\n      }\n    );\n\n  // 4. (테스트 환경상 가능하다면) 주문 상태를 배송완료로 전환하는 처리가 있어야 실제 구매확정 진행 가능 (생략)\n  // 5. 정상 조건에서 1회 구매확정 (가정) - 테스트 환경상 상태 전환이 불가하면 일단 푸티브/skip\n\n  // 6. 동일 상품 중복 확정시 오류 검증 (이미 확정처리라 가정)\n  await TestValidator.httpError(\"중복 구매확정시 400/409 오류\")(400, 409)(\n    async () => {\n      await api.functional.shoppings.customers.orders.goods.confirm(\n        connection,\n        order.id,\n        good.id\n      );\n    }\n  );\n\n  // 7. 존재하지 않는 주문/상품id, 권한없는 사용자로 요청시 적절 오류\n  await TestValidator.httpError(\"존재하지 않는 주문\")\n    (404)(\n      async () => {\n        await api.functional.shoppings.customers.orders.goods.confirm(\n          connection,\n          \"not-found-orderId\",\n          good.id\n        );\n      }\n    );\n  await TestValidator.httpError(\"존재하지 않는 상품\")\n    (404)(\n      async () => {\n        await api.functional.shoppings.customers.orders.goods.confirm(\n          connection,\n          order.id,\n          \"not-found-goodId\"\n        );\n      }\n    );\n  // 권한 없는 사용자 (별도의 커넥션 필요/skip)\n}\n",
  "test/features/api/order/test_check_order_publishable_status.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingOrder } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingOrder\";\nimport { IShoppingOrderGood } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingOrderGood\";\nimport { IShoppingOrder_price } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingOrder_price\";\nimport typia from \"typia\";\n\nexport async function test_api_check_order_publishable_status(connection: api.IConnection): Promise<void> {\n    // 1. 우선 주문 하나를 생성 (결제 대기 상태)\n    const createOrderInput = {\n        goods: [\n            { commodity_id: \"00000000-0000-0000-0000-000000000001\", volume: 1 },\n        ],\n        name: \"Test Order Publishable\"\n    };\n    const order: IShoppingOrder = await api.functional.shoppings.customers.orders.post(connection, { body: createOrderInput });\n    typia.assert<IShoppingOrder>(order);\n    TestValidator.predicate(\"create order should have id\")(() => typeof order.id === \"string\" && !!order.id);\n\n    // 2. 생성된 주문이 발행 가능 상태인지 (결제대기) 체크\n    await TestValidator.error(\"publish/able must not throw error for newly created order\")(\n      async () => {\n        await api.functional.shoppings.customers.orders.publish.able.get(connection, order.id);\n      }\n    ); // 200 OK 일 경우 통과(에러 없음)\n\n    // 3. 잘못된 주문ID로 요청(에러 기대)\n    await TestValidator.httpError(\"invalid order id must return error\")(404)(\n      async () => {\n        await api.functional.shoppings.customers.orders.publish.able.get(connection, \"invalid-order-id\");\n      }\n    );\n\n    // 4. [선택] 주문이 삭제/결제완료 상태일 때(여기선 상태 조작 API 없으므로 생략)\n    // 실제 환경에선 결제상태 변경 후 다시 검증 필요\n}\n",
  "test/features/api/order/test_publish_order_and_handle_payment_statuses.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingOrder } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingOrder\";\nimport { IShoppingOrderPublish } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingOrderPublish\";\nimport { IShoppingOrderPublish_ICreate } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingOrderPublish.ICreate\";\nimport { IShoppingOrder_ICreate } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingOrder.ICreate\";\nimport { IShoppingOrderGood_ICreate } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingOrderGood.ICreate\";\nimport { IShoppingAddress_ICreate } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingAddress.ICreate\";\nimport typia from \"typia\";\n\nexport async function test_api_publish_order_and_handle_payment_statuses(connection: api.IConnection): Promise<void> {\n  // 1. 주문 생성(정상 플로우)\n  const testCommodityId = \"11111111-1111-1111-1111-111111111111\"; // 테스트용 UUID (cart commodity id)\n  const orderInput: IShoppingOrder_ICreate = {\n    goods: [\n      {\n        commodity_id: testCommodityId,\n        volume: 1,\n      } satisfies IShoppingOrderGood_ICreate,\n    ],\n    name: \"테스트주문\"\n  };\n\n  const newOrder = await api.functional.shoppings.customers.orders.post(connection, orderInput);\n  typia.assert<IShoppingOrder>(newOrder);\n  TestValidator.predicate(\"order.created_at exists\")(!!newOrder.created_at);\n  TestValidator.equals(\"order.goods length\")(1)(newOrder.goods.length);\n  const orderId = newOrder.id;\n\n  // 2. 정상 결제 발행\n  const addressInput: IShoppingAddress_ICreate = {\n    mobile: \"01012341234\",\n    name: \"홍길동\",\n    country: \"대한민국\",\n    province: \"서울특별시\",\n    city: \"강남구\",\n    department: \"역삼동\",\n    possession: \"테헤란로 123\",\n    zip_code: \"12345\",\n    special_note: null\n  };\n  const validVendor = { code: \"PAYVENDOR\", uid: \"ABCDEF1234567890\" };\n  const publishInput: IShoppingOrderPublish_ICreate = {\n    address: addressInput,\n    vendor: validVendor\n  };\n  const publishResult = await api.functional.shoppings.customers.orders.publish.post(connection, orderId, publishInput);\n  typia.assert<IShoppingOrderPublish>(publishResult);\n  TestValidator.predicate(\"publish.paid_at exists\")(publishResult.paid_at === null || typeof publishResult.paid_at === \"string\");\n  TestValidator.equals(\"publish.address.name\")(addressInput.name)(publishResult.address.name);\n\n  // 3. 중복 결제 발행(이미 발행된 주문)\n  await TestValidator.httpError(\"already published order must fail\")(409)(async () => {\n    await api.functional.shoppings.customers.orders.publish.post(connection, orderId, publishInput);\n  });\n\n  // 4. 결제 실패 - vendor 문제(vendor 누락/null 전달)\n  const badVendorInput: IShoppingOrderPublish_ICreate = {\n    address: addressInput,\n    vendor: null\n  };\n  await TestValidator.httpError(\"vendor=null must fail\")(400, 422)(async () => {\n    await api.functional.shoppings.customers.orders.publish.post(connection, orderId, badVendorInput);\n  });\n\n  // 5. 필수 정보(주소) 누락\n  const noAddressInput: IShoppingOrderPublish_ICreate = {\n    address: null as any,\n    vendor: validVendor\n  };\n  await TestValidator.httpError(\"address=null must fail\")(400, 422)(async () => {\n    await api.functional.shoppings.customers.orders.publish.post(connection, orderId, noAddressInput);\n  });\n}\n",
  "test/features/api/order/test_cancel_order_publish_with_error_cases.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport { IShoppingOrder } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingOrder\";\nimport { IShoppingOrder_ICreate } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingOrder.ICreate\";\n\nfunction createOrderInput(commodityId: string): IShoppingOrder_ICreate {\n    return {\n        goods: [\n            {\n                commodity_id: commodityId,\n                volume: 1,\n            },\n        ],\n        name: \"테스트 주문\"\n    };\n}\n\nexport async function test_cancel_order_publish_with_error_cases(connection: api.IConnection): Promise<void> {\n    // 1. 주문 생성 (결제 전 상태)\n    const dummyCommodityId = \"11111111-1111-4111-8111-211111111111\"; // 실제 테스트 환경에 맞게 수정 필요\n    const orderInput = createOrderInput(dummyCommodityId);\n    const order = await api.functional.shoppings.customers.orders.post(connection, orderInput);\n    typia.assert<IShoppingOrder>(order);\n\n    // 실제 결제 및 publish 단계가 필요하다면, 별도 API로 상태 전환 구현 필요 (여기서는 기본 상태 그대로로 가정)\n    // 2. 예외: 결제 전 상태에서 결제 취소 (에러 기대)\n    await TestValidator.httpError(\"결제 전 주문 결제 취소 오류\")(400, 409)(async () => {\n        await api.functional.shoppings.customers.orders.publish.delete(connection, order.id);\n    });\n\n    // 3. 예외: 존재하지 않는 주문 ID 사용\n    const nonExistOrderId = \"00000000-0000-4000-8000-000000000000\";\n    await TestValidator.httpError(\"존재하지 않는 주문 결제 취소\") (404, 400)(async () => {\n        await api.functional.shoppings.customers.orders.publish.delete(connection, nonExistOrderId);\n    });\n\n    // 4. 예외: 권한 없는 사용자 (세션 또는 별도 connection 필요, 불가 시 아래 주석)\n    // const anotherConnection = { ...connection, accessToken: \"INVALID_OR_OTHER_USER_TOKEN\" };\n    // await TestValidator.httpError(\"권한 없는 사용자 결제 취소\", 401, 403)(async () => {\n    //     await api.functional.shoppings.customers.orders.publish.delete(anotherConnection, order.id);\n    // });\n}\n",
  "test/features/api/sale/test_list_all_sale_details_for_customer.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport { IShoppingOrder } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingOrder\";\nimport { IShoppingOrderGood } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingOrderGood\";\nimport { IShoppingOrder_ICreate } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingOrder.ICreate\";\nimport { IShoppingOrderGood_ICreate } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingOrderGood.ICreate\";\nimport { IShoppingSale_IRequest } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSale.IRequest\";\nimport { IPageIShoppingSale } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIShoppingSale\";\n\nexport async function test_api_list_all_sale_details_for_customer(connection: api.IConnection): Promise<void> {\n    // 1. 조회: 구매 이력이 없는 고객의 판매 상세 내역\n    const emptyRequest: IShoppingSale_IRequest = {};\n    const emptyDetails: IPageIShoppingSale = await api.functional.shoppings.customers.sales.details.patch(connection, emptyRequest);\n    typia.assert<IPageIShoppingSale>(emptyDetails);\n    TestValidator.equals(\"empty sale detail data\")([] as typeof emptyDetails.data)(emptyDetails.data);\n\n    // 2. 주문 기록 2건 생성 - 상품은 임의 uuid, 수량 1씩\n    const commodity_id_1 = \"10000000-0000-4000-8000-000000000111\";\n    const commodity_id_2 = \"10000000-0000-4000-8000-000000000222\";\n    const orderInput1: IShoppingOrder_ICreate = {\n        goods: [\n            { commodity_id: commodity_id_1, volume: 1 } as IShoppingOrderGood_ICreate,\n        ],\n        name: \"TestOrder_1\"\n    };\n    const orderInput2: IShoppingOrder_ICreate = {\n        goods: [\n            { commodity_id: commodity_id_2, volume: 1 } as IShoppingOrderGood_ICreate,\n        ],\n        name: \"TestOrder_2\"\n    };\n    const order1: IShoppingOrder = await api.functional.shoppings.customers.orders.post(connection, orderInput1);\n    const order2: IShoppingOrder = await api.functional.shoppings.customers.orders.post(connection, orderInput2);\n    typia.assert<IShoppingOrder>(order1);\n    typia.assert<IShoppingOrder>(order2);\n    const goods_ids = [order1.goods[0].commodity.id, order2.goods[0].commodity.id];\n\n    // 3. 재조회 - 구매 이력(주문 포함)에 대한 상세 판매 데이터\n    const details: IPageIShoppingSale = await api.functional.shoppings.customers.sales.details.patch(connection, {});\n    typia.assert<IPageIShoppingSale>(details);\n    // 결과 배열에 두 상품 정보가 모두 포함되어 있는지 검증\n    TestValidator.predicate(\"sale details includes customer's commodities\")(\n        () => goods_ids.every(cid => details.data.some(sale =>\n            sale.units.some(unit =>\n                unit.stocks.some(stock =>\n                    stock.id === cid\n                )\n            )\n        ))\n    );\n    // 4. Negative: 타인 connection(권한 없는 경우), http error 기대\n    await TestValidator.httpError(\"unauthorized access\")(401, 403)(async () => {\n        const invalidConnection = { ...connection, token: \"invalid-token\" };\n        await api.functional.shoppings.customers.sales.details.patch(invalidConnection, {});\n    });\n}\n",
  "test/features/api/sale/test_list_all_sale_summaries_for_customer.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport { IShoppingOrder } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingOrder\";\nimport { IShoppingOrderGood } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingOrderGood\";\nimport { IShoppingOrder_ICreate } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingOrder.ICreate\";\nimport { IShoppingOrderGood_ICreate } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingOrderGood.ICreate\";\nimport { IShoppingCartCommodity } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCartCommodity\";\nimport { IShoppingSale_IRequest } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSale.IRequest\";\nimport { IPageIShoppingSale_ISummary } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIShoppingSale.ISummary\";\n\nexport async function test_api_sale_list_all_summaries_for_customer(connection: api.IConnection): Promise<void> {\n  // 1. 구매 이력이 없는 상태에서 전체 요약 조회\n  const emptyRequest: IShoppingSale_IRequest = {};\n  const page0 = await api.functional.shoppings.customers.sales.patch(connection, { body: emptyRequest });\n  typia.assert<IPageIShoppingSale_ISummary>(page0);\n  TestValidator.equals(\"빈 구매 요약 목록 반환 여부\")([] as typeof page0.data)(page0.data);\n\n  // 2. 신규 주문 1건 생성: 주문을 위한 임시 장바구니 commodity 준비 및 주문 생성\n  const commodityId1 = \"00000000-0000-0000-0000-000000000001\"; // 테스트용 mock commodity id (실제 환경에 맞게 채번 필요)\n  const orderInput1: IShoppingOrder_ICreate = { goods: [{ commodity_id: commodityId1, volume: 1 }], name: \"test order 01\" };\n  const order1 = await api.functional.shoppings.customers.orders.post(connection, { body: orderInput1 });\n  typia.assert<IShoppingOrder>(order1);\n\n  // 3. 신규 주문 2건 생성(멀티 주문 테스트)\n  const commodityId2 = \"00000000-0000-0000-0000-000000000002\";\n  const commodityId3 = \"00000000-0000-0000-0000-000000000003\";\n  const orderInput2: IShoppingOrder_ICreate = { goods: [{ commodity_id: commodityId2, volume: 2 }], name: \"multi order 02\" };\n  const orderInput3: IShoppingOrder_ICreate = { goods: [{ commodity_id: commodityId3, volume: 3 }], name: \"multi order 03\" };\n  const order2 = await api.functional.shoppings.customers.orders.post(connection, { body: orderInput2 });\n  const order3 = await api.functional.shoppings.customers.orders.post(connection, { body: orderInput3 });\n  typia.assert<IShoppingOrder>(order2);\n  typia.assert<IShoppingOrder>(order3);\n\n  // 4. 실제 주문 3건 데이터로 전체 요약 재요청\n  const page1 = await api.functional.shoppings.customers.sales.patch(connection, { body: emptyRequest });\n  typia.assert<IPageIShoppingSale_ISummary>(page1);\n  // 적어도 주문 건수 >= 3\n  TestValidator.predicate(\"요약 반환 건수 3 이상\")(() => page1.data.length >= 3);\n\n  // 5. 각 요약 DTO 정합성 및 전체 orders에서 최근 주문이 요약에 포함 되는가 체크\n  page1.data.forEach(summary => {\n    // 타입 일치\n    // (상세 field 검증 필요 시 아래와 같이 체크 가능)\n    typia.assert(summary);\n    TestValidator.predicate(\"요약 sale id 존재\")(() => typeof summary.id === \"string\" && summary.id.length > 0);\n    TestValidator.predicate(\"요약 units 배열 존재\")(() => Array.isArray(summary.units) && summary.units.length > 0);\n  });\n\n  // 6. 비회원(권한없는) 또는 토큰 없는 연결로 요청 시 에러(401/403 등) 발생 확인\n  await TestValidator.httpError(\"권한 없는 요청시 401/403 오류\") (401, 403) (async () => {\n    const invalidConn = {} as api.IConnection;\n    await api.functional.shoppings.customers.sales.patch(invalidConn, { body: emptyRequest });\n  });\n}\n",
  "test/features/api/shopping-sale/test_get_sale_detail_info_by_id.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingOrder } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingOrder\";\nimport { IShoppingOrderGood } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingOrderGood\";\nimport { IShoppingOrder_ICreate } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingOrder.ICreate\";\nimport { IShoppingOrderGood_ICreate } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingOrderGood.ICreate\";\nimport { IShoppingSale } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSale\";\nimport typia from \"typia\";\n\nimport { v4 as uuidv4 } from \"uuid\";\n\nexport async function test_api_get_sale_detail_info_by_id(connection: api.IConnection): Promise<void> {\n  // Step 1: 구매 가능한 상품의 장바구니 commodity 생성 등 사전 작업이 필요하다고 가정\n  // 사전 조건: customer의 장바구니 commodity id가 있다고 가정 (id: \"commodity-uuid\")\n  // 실제 E2E에서 별도 commodity 생성함수/헬퍼가 제공된다면 사용 필요\n  const commodityId = uuidv4(); // 실제 환경에서는 유효한 commodity id 필요\n  // 볼륨은 임의로 1 사용\n  const orderDto: IShoppingOrder_ICreate = {\n    goods: [\n      {\n        commodity_id: commodityId,\n        volume: 1,\n      } as IShoppingOrderGood_ICreate,\n    ],\n    name: \"테스트주문\"\n  };\n\n  // Step 2: POST /shoppings/customers/orders로 주문(응답으로 IShoppingOrder)\n  let order: IShoppingOrder | null = null;\n  await TestValidator.error(\"존재하지 않는 commodity_id로 주문 생성시 에러 발생\")(async () => {\n    order = await api.functional.shoppings.customers.orders.post(connection, orderDto);\n  });\n  // 실제로는 commodity를 준비해서 주문을 성공시키는 시나리오가 중요하나,\n  // 문서상 commodity 준비에 대한 API 미기재라 placeholder로 처리\n  // 정상적인 주문 성공 후 order에서 연결된 sale id 추출이 필요\n\n  // Step 3: 정상적인 sale id로 상세조회 요청\n  // order?.goods[0]?.commodity.sale.id 등으로 접근해야 하나, \n  // 타입 연결이 불확실하니 아래는 예시 흐름\n  const saleId = uuidv4(); // 실제로는 order.goods[0].commodity.sale.id 사용\n\n  // 정상적인 상세 조회 (실패 예상: 잘못된 id)\n  await TestValidator.error(\"존재하지 않는 sale id 상세조회시 에러\")(async () => {\n    await api.functional.shoppings.customers.sales.get(connection, saleId);\n  });\n\n  // 타인 sale id, 또는 권한 없는 id로 조회 시도 (테스트 환경에서 가능하다면 추가)\n  // 랜덤 uuid로 충분히 커버된다고 가정.\n  const anotherSaleId = uuidv4();\n  await TestValidator.error(\"타인의 sale id 상세조회시 에러\")(async () => {\n    await api.functional.shoppings.customers.sales.get(connection, anotherSaleId);\n  });\n\n  // 정상 흐름 (commodiy/sale 준비 가능하다면)\n  //const sale = await api.functional.shoppings.customers.sales.get(connection, saleId);\n  //typia.assert<IShoppingSale>(sale);\n  //TestValidator.equals(\"sale id 일치\")(saleId)(sale.id);\n}\n",
  "test/features/api/comment/test_create_comment_on_question_with_validations.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingSaleQuestion } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleQuestion\";\nimport { IShoppingSaleQuestion.ICreate } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleQuestion\";\nimport { IShoppingSaleInquiryComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment\";\nimport { IShoppingSaleInquiryComment as IShoppingSaleInquiryCommentNS } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment\";\nimport typia from \"typia\";\n\nexport async function test_create_comment_on_question_with_validations(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. 정상적인 문의글 생성\n  const saleId = \"11111111-1111-1111-1111-111111111111\";\n  const questionInput: IShoppingSaleQuestion.ICreate = {\n    secret: false,\n    format: \"txt\",\n    title: \"문의드립니다.\",\n    body: \"문의 내용입니다.\",\n    files: [],\n  };\n  const question: IShoppingSaleQuestion = await api.functional.shoppings.customers.sales.questions.post(\n    connection,\n    saleId,\n    questionInput,\n  );\n  typia.assert<IShoppingSaleQuestion>(question);\n  TestValidator.predicate(\"question id 생성을 확인\")(!!question.id);\n\n  // 2. 정상적인 댓글 작성\n  const commentInput: IShoppingSaleInquiryCommentNS.ICreate = {\n    format: \"txt\",\n    body: \"댓글 내용입니다.\",\n    files: [],\n  };\n  const comment = await api.functional.shoppings.customers.sales.questions.comments.post(\n    connection,\n    saleId,\n    question.id,\n    commentInput,\n  );\n  typia.assert<IShoppingSaleInquiryComment>(comment);\n  TestValidator.predicate(\"comment id 생성됨\")(!!comment.id);\n  TestValidator.equals(\"본문 확인\")(commentInput.body)(comment.snapshots[0].body);\n\n  // 3. 본문이 빈 댓글 작성 시 유효성 검사\n  const emptyBodyInput: IShoppingSaleInquiryCommentNS.ICreate = {\n    format: \"txt\",\n    body: \"\",\n    files: [],\n  };\n  await TestValidator.httpError(\"댓글 본문 필수값 체크\")(400)(() =>\n    api.functional.shoppings.customers.sales.questions.comments.post(\n      connection,\n      saleId,\n      question.id,\n      emptyBodyInput,\n    ),\n  );\n\n  // 4. 본문이 너무 긴 댓글 작성 시 (10,001자)\n  const longBodyInput: IShoppingSaleInquiryCommentNS.ICreate = {\n    format: \"txt\",\n    body: \"a\".repeat(10001),\n    files: [],\n  };\n  await TestValidator.httpError(\"댓글 본문 길이 초과 체크\")(400)(() =>\n    api.functional.shoppings.customers.sales.questions.comments.post(\n      connection,\n      saleId,\n      question.id,\n      longBodyInput,\n    ),\n  );\n\n  // 5. 존재하지 않는 문의글에 댓글 작성 (잘못된 inquiryId)\n  const invalidInquiryId = \"22222222-2222-2222-2222-222222222222\";\n  await TestValidator.httpError(\"없는 문의글에 댓글 작성시 에러\")(404)(() =>\n    api.functional.shoppings.customers.sales.questions.comments.post(\n      connection,\n      saleId,\n      invalidInquiryId,\n      commentInput,\n    ),\n  );\n\n  // 6. 권한 없는 사용자로 댓글 작성 시도 (connection 변경이 불가하기 때문에 comment 내용 에러 체킹만 수행)\n  // 만약 실제 권한 없는 connection 사용이 가능하다면 별도 테스트 케이스 추가 필요\n}\n",
  "test/features/api/shopping/test_list_comments_on_question_for_customer.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport { IShoppingSaleQuestion } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleQuestion\";\nimport { IShoppingSaleQuestion.ICreate } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleQuestion\";\nimport { IShoppingSaleInquiryComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment\";\nimport { IShoppingSaleInquiryComment.ICreate } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment\";\nimport { IShoppingSaleInquiryComment.IRequest } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment\";\nimport { IPageIShoppingSaleInquiryComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIShoppingSaleInquiryComment\";\n\nexport async function test_list_comments_on_question_for_customer(connection: api.IConnection, unauthorizedConnection: api.IConnection, saleId: string): Promise<void> {\n  // 1. 문의글 생성\n  const questionInput: IShoppingSaleQuestion.ICreate = {\n    secret: false,\n    format: \"txt\",\n    title: \"문의글 제목\",\n    body: \"문의글 본문\",\n    files: []\n  };\n  const question = await api.functional.shoppings.customers.sales.questions.post(connection, saleId, questionInput);\n  typia.assert<IShoppingSaleQuestion>(question);\n\n  const inquiryId = question.id;\n\n  // 2. 댓글 없는 상태에서 댓글 목록 조회\n  const emptyRequest: IShoppingSaleInquiryComment.IRequest = {\n    search: null,\n    sort: null,\n    page: null,\n    limit: null\n  };\n  const emptyRes = await api.functional.shoppings.customers.sales.questions.comments.patch(connection, saleId, inquiryId, emptyRequest);\n  typia.assert<IPageIShoppingSaleInquiryComment>(emptyRes);\n  TestValidator.equals(\"comments empty\")(emptyRes.data)([] as IShoppingSaleInquiryComment[]);\n\n  // 3. 댓글 두 개 등록\n  const commentInput: IShoppingSaleInquiryComment.ICreate = {\n    format: \"txt\",\n    body: \"첫 번째 댓글\",\n    files: [\n      { name: \"file1\", extension: \"txt\", url: \"https://example.com/file1.txt\" }\n    ]\n  };\n  const comment1 = await api.functional.shoppings.customers.sales.questions.comments.post(connection, saleId, inquiryId, commentInput);\n  typia.assert<IShoppingSaleInquiryComment>(comment1);\n\n  const commentInput2: IShoppingSaleInquiryComment.ICreate = {\n    format: \"txt\",\n    body: \"두 번째 댓글\",\n    files: [\n      { name: \"file2\", extension: \"txt\", url: \"https://example.com/file2.txt\" }\n    ]\n  };\n  const comment2 = await api.functional.shoppings.customers.sales.questions.comments.post(connection, saleId, inquiryId, commentInput2);\n  typia.assert<IShoppingSaleInquiryComment>(comment2);\n\n  // 4. 댓글 존재 상태에서 댓글 목록 재조회\n  const withCommentsRes = await api.functional.shoppings.customers.sales.questions.comments.patch(connection, saleId, inquiryId, emptyRequest);\n  typia.assert<IPageIShoppingSaleInquiryComment>(withCommentsRes);\n  TestValidator.equals(\"comments count 2\")(withCommentsRes.data.length)(2);\n\n  // 5. 권한 없는 세션에서 댓글 목록 조회 시도\n  await TestValidator.httpError(\"unauthorized access\")(401, 403)(async () => {\n    await api.functional.shoppings.customers.sales.questions.comments.patch(unauthorizedConnection, saleId, inquiryId, emptyRequest);\n  });\n}\n",
  "test/features/api/inquiry-comment/test_get_comment_detail_on_question.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingSaleQuestion } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleQuestion\";\nimport { IShoppingSaleInquiryComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment\";\nimport { IShoppingSaleQuestion as IShoppingSaleQuestionCreate } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleQuestion.ICreate\";\nimport { IShoppingSaleInquiryComment as IShoppingSaleInquiryCommentCreate } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment.ICreate\";\nimport typia from \"typia\";\n\nexport async function test_api_get_comment_detail_on_question(connection: api.IConnection): Promise<void> {\n    // 1. 문의글 생성\n    const saleId = \"11111111-aaaa-bbbb-cccc-222222222222\";\n    const questionInput: IShoppingSaleQuestionCreate = {\n        secret: false,\n        format: \"txt\",\n        title: \"문의글 제목\",\n        body: \"문의글 본문 내용입니다.\",\n        files: []\n    };\n    const question = await api.functional.shoppings.customers.sales.questions.post(connection, saleId, questionInput);\n    typia.assert<IShoppingSaleQuestion>(question);\n\n    // 2. 댓글 생성\n    const inquiryId = question.id;\n    const commentInput: IShoppingSaleInquiryCommentCreate = {\n        format: \"txt\",\n        body: \"댓글 내용입니다.\",\n        files: [\n            {\n                name: \"sample\",\n                extension: \"txt\",\n                url: \"https://example.com/sample.txt\",\n            },\n        ]\n    };\n    const comment = await api.functional.shoppings.customers.sales.questions.comments.post(connection, saleId, inquiryId, commentInput);\n    typia.assert<IShoppingSaleInquiryComment>(comment);\n\n    // 3. 상세 조회\n    const read = await api.functional.shoppings.customers.sales.questions.comments.get(connection, saleId, inquiryId, comment.id);\n    typia.assert<IShoppingSaleInquiryComment>(read);\n    TestValidator.equals(\"comment detail id\")(comment.id)(read.id);\n    TestValidator.equals(\"comment detail body\")(comment.snapshots[0].body)(read.snapshots[0].body);\n\n    // 4. 존재하지 않는 id 접근\n    await TestValidator.httpError(\"not found error\")(404)(\n        () => api.functional.shoppings.customers.sales.questions.comments.get(\n            connection, saleId, inquiryId, \"00000000-0000-0000-0000-000000000000\"\n        )\n    );\n}",
  "test/features/api/inquiry-comment/test_update_comment_on_question_with_validation.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingSaleQuestion } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleQuestion\";\nimport { IShoppingSaleQuestion as IQuestion } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleQuestion\";\nimport { IShoppingSaleInquiryComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment\";\nimport { IShoppingSaleInquiryComment as IComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment\";\nimport { IShoppingSaleInquiryComment as InquiryComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment\";\nimport { IShoppingSaleInquiryComment as Comment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment\";\nimport { IShoppingSaleInquiryComment as InquiryCommentType } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment\";\nimport { IShoppingSaleInquiryComment_ICreate } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment.ICreate\";\nimport { IShoppingSaleQuestion_ICreate } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleQuestion.ICreate\";\nimport typia from \"typia\";\n\nexport async function test_update_comment_on_question_with_validation(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. 질문 등록 (문의글)\n  const saleId = \"11111111-1111-1111-1111-111111111111\"; // 테스트용 saleId (실제 테스트 환경에서는 동적으로 할당 필요)\n  const questionInput: IShoppingSaleQuestion_ICreate = {\n    secret: false,\n    format: \"md\",\n    title: \"테스트 문의글 제목\",\n    body: \"테스트 문의글 본문\",\n    files: [],\n  };\n  const question = await api.functional.shoppings.customers.sales.questions.post(\n    connection,\n    saleId,\n    questionInput,\n  );\n  typia.assert<IShoppingSaleQuestion>(question);\n\n  // 2. 댓글 등록\n  const commentInput: IShoppingSaleInquiryComment_ICreate = {\n    format: \"md\",\n    body: \"처음 댓글 내용입니다.\",\n    files: [],\n  };\n  const comment = await api.functional.shoppings.customers.sales.questions.comments.post(\n    connection,\n    saleId,\n    question.id,\n    commentInput,\n  );\n  typia.assert<IShoppingSaleInquiryComment>(comment);\n\n  // 3. 정상 수정\n  const updateInput: IShoppingSaleInquiryComment_ICreate = {\n    format: \"md\",\n    body: \"수정된 댓글 내용입니다.\",\n    files: [],\n  };\n  const updated = await api.functional.shoppings.customers.sales.questions.comments.put(\n    connection,\n    saleId,\n    question.id,\n    comment.id,\n    updateInput,\n  );\n  typia.assert(updated);\n  TestValidator.equals(\"댓글 수정: body\", () => true)(\n    updated.body,\n  )(updateInput.body);\n\n  // 4. 타 계정으로 수정 (권한 오류)\n  const anotherConnection: api.IConnection = {\n    ...connection,\n    headers: { ...connection.headers, Authorization: \"Bearer unauthorized-token\" },\n  };\n  await TestValidator.httpError(\"타 계정 댓글 수정시 403\", 403)(async () =>\n    api.functional.shoppings.customers.sales.questions.comments.put(\n      anotherConnection,\n      saleId,\n      question.id,\n      comment.id,\n      {\n        format: \"md\",\n        body: \"타인이 수정 시도\",\n        files: [],\n      },\n    ),\n  );\n\n  // 5. 본문 너무 긴 경우\n  const longBody = \"a\".repeat(10001); // 10,001자\n  await TestValidator.httpError(\"댓글 본문이 너무 길면 400\", 400)(async () =>\n    api.functional.shoppings.customers.sales.questions.comments.put(\n      connection,\n      saleId,\n      question.id,\n      comment.id,\n      {\n        format: \"md\",\n        body: longBody,\n        files: [],\n      },\n    ),\n  );\n\n  // 6. 빈 본문\n  await TestValidator.httpError(\"댓글 본문 빈 값시 400\", 400)(async () =>\n    api.functional.shoppings.customers.sales.questions.comments.put(\n      connection,\n      saleId,\n      question.id,\n      comment.id,\n      {\n        format: \"md\",\n        body: \"\",\n        files: [],\n      },\n    ),\n  );\n\n  // 7. 지원하지 않는 format\n  await TestValidator.httpError(\"지원하지 않는 format은 400\", 400)(async () =>\n    api.functional.shoppings.customers.sales.questions.comments.put(\n      connection,\n      saleId,\n      question.id,\n      comment.id,\n      {\n        format: \"unsupported-format\" as any,\n        body: \"정상적인 내용\",\n        files: [],\n      },\n    ),\n  );\n}\n",
  "test/features/api/question/test_create_question_on_sale_for_customer.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport { IShoppingOrder } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingOrder\";\nimport { IShoppingOrderGood } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingOrderGood\";\nimport { IShoppingOrder_ICreate } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingOrder.ICreate\";\nimport { IShoppingOrderGood_ICreate } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingOrderGood.ICreate\";\nimport { IShoppingSaleQuestion_ICreate } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleQuestion.ICreate\";\nimport { IShoppingSaleQuestion } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleQuestion\";\nimport { IAttachmentFile_ICreate } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAttachmentFile.ICreate\";\n\nexport async function test_api_create_question_on_sale_for_customer(connection: api.IConnection): Promise<void> {\n    // 1. Create an order to get an order good (select proper saleId)\n    // Prepare fake commodity_id for test\n    const commodityId = \"11111111-1111-1111-1111-111111111111\";\n    const orderGoodInput: IShoppingOrderGood_ICreate = {\n        commodity_id: commodityId,\n        volume: 1,\n    };\n    const orderInput: IShoppingOrder_ICreate = {\n        goods: [orderGoodInput],\n        name: \"테스트 주문\"\n    };\n    let order: IShoppingOrder;\n    await TestValidator.error(\"주문 생성실패 - 필수누락\")(\n      // missing goods field\n      async () => {\n        await api.functional.shoppings.customers.orders.post(connection, { name: \"누락 케이스\" } as IShoppingOrder_ICreate);\n      }\n    );\n    order = await api.functional.shoppings.customers.orders.post(connection, orderInput);\n    typia.assert<IShoppingOrder>(order);\n    TestValidator.equals(\"주문 이름\")(orderInput.name!)(order.name);\n    typia.assert<IShoppingOrderGood[]>(order.goods);\n    // 상품 문의 작성용 saleId는 주문 goods에서 추출\n    const targetGood: IShoppingOrderGood = order.goods[0];\n    const saleId: string = targetGood.commodity.sale.id;\n\n    // 2. 정상 문의글 작성\n    const file: IAttachmentFile_ICreate = {\n        name: \"test.png\",\n        extension: \"png\",\n        url: \"https://cdn.example.com/test.png\"\n    };\n    const questionInput: IShoppingSaleQuestion_ICreate = {\n        secret: false,\n        format: \"txt\",\n        title: \"상품 문의드립니다.\",\n        body: \"상세 문의 내용입니다.\",\n        files: [file],\n    };\n    const question: IShoppingSaleQuestion = await api.functional.shoppings.customers.sales.questions.post(\n      connection, saleId, questionInput\n    );\n    typia.assert<IShoppingSaleQuestion>(question);\n    TestValidator.equals(\"문의 제목\")(questionInput.title)(question.snapshots[0].title);\n    TestValidator.equals(\"문의 작성자 매칭\")(order.customer.id)(question.customer.id);\n\n    // 3. 필수 파라미터 미입력 케이스\n    await TestValidator.httpError(\"필수값 누락 실패\", 400)(\n      async () => {\n        // title이 빠진 경우\n        const badInput = { ...questionInput, title: undefined } as any;\n        await api.functional.shoppings.customers.sales.questions.post(\n          connection, saleId, badInput\n        );\n      }\n    );\n\n    // 4. 존재하지/삭제된 상품 케이스\n    await TestValidator.httpError(\"없는 상품 문의\", 404)(\n      async () => {\n        await api.functional.shoppings.customers.sales.questions.post(\n          connection, \"00000000-0000-0000-0000-000000000000\", questionInput\n        );\n      }\n    );\n\n    // 5. 본인 주문이 아닌 saleId 케이스 (임의의 saleId 값)\n    await TestValidator.httpError(\"본인 주문이 아닌 상품 문의\", 403)(\n      async () => {\n        await api.functional.shoppings.customers.sales.questions.post(\n          connection, \"22222222-2222-2222-2222-222222222222\", questionInput\n        );\n      }\n    );\n}\n",
  "test/features/api/question/test_list_questions_on_sale_for_customer.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingSaleQuestion } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleQuestion\";\nimport { IShoppingSaleQuestion as IQuestionNS } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleQuestion\";\nimport { IPageIShoppingSaleQuestion } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIShoppingSaleQuestion\";\nimport typia from \"typia\";\n\nexport async function test_api_list_questions_on_sale_for_customer(\n  connection: api.IConnection,\n  saleId_empty: string,\n  saleId_with_questions: string,\n): Promise<void> {\n  // 1. 문의글이 없는 판매 상품의 조회 (결과 없음)\n  const emptyRequest: IQuestionNS.IRequest = {};\n  const pageEmpty = await api.functional.shoppings.customers.sales.questions.patch(\n    connection,\n    saleId_empty,\n    emptyRequest,\n  );\n  typia.assert<IPageIShoppingSaleQuestion.ISummary>(pageEmpty);\n  TestValidator.equals(\"문의글 없음(배열 empty)\")<IShoppingSaleQuestion.ISummary[]>([])(pageEmpty.data);\n  TestValidator.equals(\"페이지네이션 empty\")<number>(0)(pageEmpty.pagination.records);\n\n  // 2. 문의글 2개 생성 (동일한 상품)\n  const questionInput1: IQuestionNS.ICreate = {\n    secret: false,\n    format: \"txt\",\n    title: \"문의 제목1\",\n    body: \"문의 본문1\",\n    files: [],\n  };\n  const question1 = await api.functional.shoppings.customers.sales.questions.post(\n    connection, saleId_with_questions, questionInput1,\n  );\n  typia.assert<IShoppingSaleQuestion>(question1);\n\n  const questionInput2: IQuestionNS.ICreate = {\n    secret: true,\n    format: \"txt\",\n    title: \"문의 제목2\",\n    body: \"문의 본문2\",\n    files: [],\n  };\n  const question2 = await api.functional.shoppings.customers.sales.questions.post(\n    connection, saleId_with_questions, questionInput2,\n  );\n  typia.assert<IShoppingSaleQuestion>(question2);\n\n  // 3. 해당 상품의 문의글 목록 조회\n  const listRequest: IQuestionNS.IRequest = {};\n  const pageWithQuestions = await api.functional.shoppings.customers.sales.questions.patch(\n    connection,\n    saleId_with_questions,\n    listRequest,\n  );\n  typia.assert<IPageIShoppingSaleQuestion.ISummary>(pageWithQuestions);\n\n  // 생성된 문의글 id가 목록에 모두 포함됐는지 확인\n  const ids = pageWithQuestions.data.map(r => r.id);\n  TestValidator.predicate(\"문의글1 포함\")(ids.includes(question1.id));\n  TestValidator.predicate(\"문의글2 포함\")(ids.includes(question2.id));\n  TestValidator.equals(\"문의글 개수(2)\")<number>(2)(pageWithQuestions.data.length);\n  TestValidator.equals(\"페이지네이션 records(2)\")<number>(2)(pageWithQuestions.pagination.records);\n\n  // 4. 에러케이스: 존재하지 않는 saleId\n  await TestValidator.httpError(\"존재하지 않는 saleId - 404\")(404)(async () =>\n    api.functional.shoppings.customers.sales.questions.patch(\n      connection,\n      \"00000000-0000-0000-0000-000000000000\", // 잘못된 saleId\n      listRequest,\n    )\n  );\n}\n",
  "test/features/api/question/test_get_question_detail_on_sale.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport { IShoppingSaleQuestion } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleQuestion\";\nimport { IShoppingSaleQuestion as IShoppingSaleQuestionInput } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleQuestion.ICreate\";\n\nexport async function test_get_question_detail_on_sale(\n  connection: api.IConnection,\n  anotherConnection: api.IConnection,\n  saleId: string\n): Promise<void> {\n  // 1. 문의글 작성(비밀글)\n  const questionInput: IShoppingSaleQuestionInput = {\n    secret: true,\n    format: \"md\",\n    title: \"테스트 비밀 문의글\",\n    body: \"비밀 문의글 내용입니다.\",\n    files: [\n      {\n        name: \"file1\",\n        extension: \"png\",\n        url: \"https://cdn.test.com/img1.png\"\n      }\n    ]\n  };\n\n  const question = await api.functional.shoppings.customers.sales.questions.post(\n    connection,\n    saleId,\n    { body: questionInput }\n  );\n  typia.assert<IShoppingSaleQuestion>(question);\n\n  // 2. 정상 케이스: 본인(작성자 또는 관련 판매자) 커넥션 조회\n  const found = await api.functional.shoppings.customers.sales.questions.get(\n    connection,\n    saleId,\n    question.id\n  );\n  typia.assert<IShoppingSaleQuestion>(found);\n  TestValidator.equals(\"question id\")(question.id)(found.id);\n  TestValidator.equals(\"secret\")(question.secret)(found.secret);\n  TestValidator.equals(\"title\")(question.snapshots[0].title)(found.snapshots[0].title);\n  TestValidator.equals(\"body\")(question.snapshots[0].body)(found.snapshots[0].body);\n\n  // 3. 없는 id 조회: 404 에러\n  await TestValidator.httpError(\"Not Found\")(404)(async () => {\n    await api.functional.shoppings.customers.sales.questions.get(\n      connection,\n      saleId,\n      \"00000000-0000-0000-0000-000000000000\"\n    );\n  });\n\n  // 4. 권한 없는 커넥션: 403 에러\n  await TestValidator.httpError(\"Forbidden\")(403)(async () => {\n    await api.functional.shoppings.customers.sales.questions.get(\n      anotherConnection,\n      saleId,\n      question.id\n    );\n  });\n}\n",
  "test/features/api/question/test_update_question_on_sale_with_validation.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingSaleQuestion } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleQuestion\";\nimport { IShoppingSaleQuestion as IShoppingSaleQuestionNamespace } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleQuestion\";\nimport { IAttachmentFile } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAttachmentFile\";\nimport { IBbsArticle } from \"@ORGANIZATION/PROJECT-api/lib/structures/IBbsArticle\";\nimport typia from \"typia\";\n\nexport async function test_update_question_on_sale_with_validation(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. 사전 saleId와 문의글 생성 (본인)\n  const saleId =\n    \"00000000-0000-4000-8000-100000000001\"; // 실제 환경에서는 랜덤 saleId 생성 필요\n  const createQuestionInput: IShoppingSaleQuestionNamespace.ICreate = {\n    secret: false,\n    format: \"md\",\n    title: \"Original question title\",\n    body: \"Original question body\",\n    files: [\n      {\n        name: \"sample-image\",\n        extension: \"jpg\",\n        url: \"https://cdn.example.com/img1.jpg\",\n      },\n    ],\n  };\n  const question: IShoppingSaleQuestion = await api.functional.shoppings.customers.sales.questions.post(\n    connection,\n    saleId,\n    createQuestionInput,\n  );\n  typia.assert<IShoppingSaleQuestion>(question);\n  const questionId = question.id;\n\n  // 2. 정상 수정 시나리오\n  const updateInput: IBbsArticle.ICreate = {\n    format: \"md\",\n    title: \"Updated Title\",\n    body: \"Updated body content.\",\n    files: [\n      {\n        name: \"updated-file\",\n        extension: \"png\",\n        url: \"https://cdn.example.com/img2.png\",\n      },\n    ],\n  };\n  const snapshot: IBbsArticle.ISnapshot = await api.functional.shoppings.customers.sales.questions.postById(\n    connection,\n    saleId,\n    questionId,\n    updateInput,\n  );\n  typia.assert<IBbsArticle.ISnapshot>(snapshot);\n  TestValidator.equals(\"modified title\")(updateInput.title)(snapshot.title);\n  TestValidator.equals(\"modified body\")(updateInput.body)(snapshot.body);\n\n  // 3. 예외 케이스: body가 빈 문자열\n  const emptyBodyInput: IBbsArticle.ICreate = {\n    format: \"md\",\n    title: \"Blank body try\",\n    body: \"\",\n    files: [],\n  };\n  await TestValidator.httpError(\"빈 body 오류\") (400)(\n    () => api.functional.shoppings.customers.sales.questions.postById(\n      connection,\n      saleId,\n      questionId,\n      emptyBodyInput,\n    )\n  );\n\n  // 4. 예외 케이스: body가 아주 긴 경우\n  const longBody = \"a\".repeat(10001); // 정책 제한 초과라 가정\n  const tooLongBodyInput: IBbsArticle.ICreate = {\n    format: \"md\",\n    title: \"Too long body try\",\n    body: longBody,\n    files: [],\n  };\n  await TestValidator.httpError(\"긴 body 오류\") (400)(\n    () => api.functional.shoppings.customers.sales.questions.postById(\n      connection,\n      saleId,\n      questionId,\n      tooLongBodyInput,\n    )\n  );\n\n  // 5. 예외 케이스: 타인 계정으로 수정 시도\n  // 가정: 다른 사용자 커넥션(otherConnection)이 있다고 가정\n  const otherConnection = { ...connection, accessToken: \"WRONG_USER_TOKEN\" } as api.IConnection;\n  await TestValidator.httpError(\"타인 수정 불가 오류\") (403, 401)(\n    () => api.functional.shoppings.customers.sales.questions.postById(\n      otherConnection,\n      saleId,\n      questionId,\n      updateInput,\n    )\n  );\n}\n",
  "test/features/api/monitor/test_get_monitors_health_basic_and_failure_check.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\n\nexport async function test_get_monitors_health_basic_and_failure_check(\n  connection: api.IConnection,\n): Promise<void> {\n  // Positive Case: Server is healthy\n  await TestValidator.error(\"should not throw when server is healthy\")(\n    async () => {\n      const res = await api.functional.monitors.health.get(connection);\n      // No response DTO, so just ensure successful call\n    },\n  );\n\n  // Negative Case: Simulate server down (manual/skip guidance since actual turning off server is not feasible in test)\n  // To test, stop the server and run the following block separately\n  await TestValidator.httpError(\n    \"should throw 503 or error when server is down\",\n  )(503, 500, 502, 504)(async () => {\n    // This will fail unless server is down\n    await api.functional.monitors.health.get(connection);\n  });\n}\n",
  "test/features/api/monitor/test_get_monitors_performance_metric_accuracy.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport { IPerformance } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPerformance\";\n\nexport async function test_get_monitors_performance_metric_accuracy(connection: api.IConnection): Promise<void> {\n  // 1. 요청\n  const perf = await api.functional.monitors.performance.get(connection);\n\n  // 2. 타입 및 구조 검증\n  typia.assert<IPerformance>(perf);\n\n  // 3. CPU, memory, resource 세부 필드 값 타입 검증\n  TestValidator.predicate(\"cpu.user is number\")(() => typeof perf.cpu.user === \"number\");\n  TestValidator.predicate(\"cpu.system is number\")(() => typeof perf.cpu.system === \"number\");\n  TestValidator.predicate(\"memory.rss is number\")(() => typeof perf.memory.rss === \"number\");\n  TestValidator.predicate(\"memory.heapTotal is number\")(() => typeof perf.memory.heapTotal === \"number\");\n  TestValidator.predicate(\"memory.heapUsed is number\")(() => typeof perf.memory.heapUsed === \"number\");\n  TestValidator.predicate(\"memory.external is number\")(() => typeof perf.memory.external === \"number\");\n  TestValidator.predicate(\"memory.arrayBuffers is number\")(() => typeof perf.memory.arrayBuffers === \"number\");\n  TestValidator.predicate(\"resource.fsRead is number\")(() => typeof perf.resource.fsRead === \"number\");\n  TestValidator.predicate(\"resource.fsWrite is number\")(() => typeof perf.resource.fsWrite === \"number\");\n  TestValidator.predicate(\"resource.involuntaryContextSwitches is number\")(() => typeof perf.resource.involuntaryContextSwitches === \"number\");\n  TestValidator.predicate(\"resource.ipcReceived is number\")(() => typeof perf.resource.ipcReceived === \"number\");\n  TestValidator.predicate(\"resource.ipcSent is number\")(() => typeof perf.resource.ipcSent === \"number\");\n  TestValidator.predicate(\"resource.majorPageFault is number\")(() => typeof perf.resource.majorPageFault === \"number\");\n  TestValidator.predicate(\"resource.maxRSS is number\")(() => typeof perf.resource.maxRSS === \"number\");\n  TestValidator.predicate(\"resource.minorPageFault is number\")(() => typeof perf.resource.minorPageFault === \"number\");\n  TestValidator.predicate(\"resource.sharedMemorySize is number\")(() => typeof perf.resource.sharedMemorySize === \"number\");\n  TestValidator.predicate(\"resource.signalsCount is number\")(() => typeof perf.resource.signalsCount === \"number\");\n  TestValidator.predicate(\"resource.swappedOut is number\")(() => typeof perf.resource.swappedOut === \"number\");\n  TestValidator.predicate(\"resource.systemCPUTime is number\")(() => typeof perf.resource.systemCPUTime === \"number\");\n  TestValidator.predicate(\"resource.unsharedDataSize is number\")(() => typeof perf.resource.unsharedDataSize === \"number\");\n  TestValidator.predicate(\"resource.unsharedStackSize is number\")(() => typeof perf.resource.unsharedStackSize === \"number\");\n  TestValidator.predicate(\"resource.userCPUTime is number\")(() => typeof perf.resource.userCPUTime === \"number\");\n  TestValidator.predicate(\"resource.voluntaryContextSwitches is number\")(() => typeof perf.resource.voluntaryContextSwitches === \"number\");\n\n  // 4. 값의 0 이상 여부 검증 (음수여서는 안되는 값만)\n  TestValidator.predicate(\"cpu.user >= 0\")(() => perf.cpu.user >= 0);\n  TestValidator.predicate(\"cpu.system >= 0\")(() => perf.cpu.system >= 0);\n  TestValidator.predicate(\"memory.rss >= 0\")(() => perf.memory.rss >= 0);\n  TestValidator.predicate(\"memory.heapTotal >= 0\")(() => perf.memory.heapTotal >= 0);\n  TestValidator.predicate(\"memory.heapUsed >= 0\")(() => perf.memory.heapUsed >= 0);\n  TestValidator.predicate(\"memory.external >= 0\")(() => perf.memory.external >= 0);\n  TestValidator.predicate(\"memory.arrayBuffers >= 0\")(() => perf.memory.arrayBuffers >= 0);\n  TestValidator.predicate(\"resource.fsRead >= 0\")(() => perf.resource.fsRead >= 0);\n  TestValidator.predicate(\"resource.fsWrite >= 0\")(() => perf.resource.fsWrite >= 0);\n  TestValidator.predicate(\"resource.majorPageFault >= 0\")(() => perf.resource.majorPageFault >= 0);\n  TestValidator.predicate(\"resource.maxRSS >= 0\")(() => perf.resource.maxRSS >= 0);\n  TestValidator.predicate(\"resource.minorPageFault >= 0\")(() => perf.resource.minorPageFault >= 0);\n  TestValidator.predicate(\"resource.sharedMemorySize >= 0\")(() => perf.resource.sharedMemorySize >= 0);\n  TestValidator.predicate(\"resource.signalsCount >= 0\")(() => perf.resource.signalsCount >= 0);\n  TestValidator.predicate(\"resource.swappedOut >= 0\")(() => perf.resource.swappedOut >= 0);\n  TestValidator.predicate(\"resource.systemCPUTime >= 0\")(() => perf.resource.systemCPUTime >= 0);\n  TestValidator.predicate(\"resource.unsharedDataSize >= 0\")(() => perf.resource.unsharedDataSize >= 0);\n  TestValidator.predicate(\"resource.unsharedStackSize >= 0\")(() => perf.resource.unsharedStackSize >= 0);\n  TestValidator.predicate(\"resource.userCPUTime >= 0\")(() => perf.resource.userCPUTime >= 0);\n  TestValidator.predicate(\"resource.voluntaryContextSwitches >= 0\")(() => perf.resource.voluntaryContextSwitches >= 0);\n}\n",
  "test/features/api/monitor/test_get_monitors_system_info_and_permission_handling.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { ISystem } from \"@ORGANIZATION/PROJECT-api/lib/structures/ISystem\";\nimport typia from \"typia\";\n\nexport async function test_api_monitors_system_info_and_permission_handling(\n  connection: api.IConnection,\n): Promise<void> {\n  // 정상: 시스템 정보 조회\n  const system: ISystem = await api.functional.monitors.system.get(\n    connection,\n  );\n  typia.assert<ISystem>(system);\n  TestValidator.predicate(\"uid is positive\")(() => system.uid > 0);\n  TestValidator.predicate(\"has commit info\")(\n    () => typeof system.commit === \"object\" && !!system.commit.hash,\n  );\n  TestValidator.predicate(\"has arguments array\")(\n    () => Array.isArray(system.arguments),\n  );\n  TestValidator.predicate(\"has package info\")(\n    () => typeof system.package === \"object\" && !!system.package.name,\n  );\n  TestValidator.predicate(\"created_at is non-empty\")(\n    () => typeof system.created_at === \"string\" && !!system.created_at,\n  );\n\n  // 음수: 권한 없는 연결 시 에러 발생 확인 (여기서는 임의로 connection.token = \"\" 사용)\n  const noAuthConnection = { ...connection, token: \"\" };\n  await TestValidator.httpError(\"permission denied\")(401, 403)(async () => {\n    await api.functional.monitors.system.get(noAuthConnection);\n  });\n}\n",
  "test/features/api/admin/test_get_admin_authenticate_with_and_without_token.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingAdministrator } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingAdministrator\";\nimport { IShoppingMember } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingMember\";\nimport typia from \"typia\";\n\nexport async function test_api_admin_authenticate_token_validation(connection: api.IConnection): Promise<void> {\n  // 1. 관리자 회원가입\n  await api.functional.shoppings.admins.authenticate.post(\n    connection,\n    {} // IShoppingAdministrator.IJoin: 필드 없음\n  );\n\n  // 2. 관리자 로그인 정보\n  const email = \"admin@example.com\";\n  const password = \"A_StrongP@ssw0rd!\";\n  const loginDto: IShoppingMember.ILogin = {\n    email,\n    password,\n  };\n\n  // 3. 로그인 (토큰 획득)\n  const loginResult = await api.functional.shoppings.admins.authenticate.login(\n    connection,\n    loginDto\n  );\n  typia.assert<IShoppingAdministrator.IInvert>(loginResult);\n  TestValidator.predicate(\"login result contains admin id\")(!!loginResult.id);\n\n  // 4. 유효한 토큰으로 관리자 정보 조회\n  const adminInfo = await api.functional.shoppings.admins.authenticate.get(\n    connection\n  );\n  typia.assert<IShoppingAdministrator.IInvert>(adminInfo);\n  TestValidator.equals(\"adminInfo.id == loginResult.id\")(loginResult.id)(adminInfo.id);\n\n  // 5. 익명 연결 객체(토큰 없는 상태) 생성 (connection에서 token 필드 제거)\n  const anonymous = { ...connection };\n  delete (anonymous as any).accessToken;\n  delete (anonymous as any).token;\n\n  // 6. 인증 토큰 없이 요청 시 인증 실패 검증\n  await TestValidator.httpError(\"no token: should fail\")(401, 403)(async () => {\n    await api.functional.shoppings.admins.authenticate.get(anonymous as api.IConnection);\n  });\n}\n",
  "test/features/api/administrator/test_post_admin_authenticate_signup_and_duplicate.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport { IShoppingAdministrator } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingAdministrator\";\n\nexport async function test_post_admin_authenticate_signup_and_duplicate(connection: api.IConnection): Promise<void> {\n    // 1. 정상적인 회원가입 요청 (빈 객체 허용 케이스 시도)\n    const input1: IShoppingAdministrator.IJoin = {};\n    const result1 = await api.functional.shoppings.admins.authenticate.post(connection, input1);\n    typia.assert<IShoppingAdministrator.IInvert>(result1);\n    TestValidator.equals(\"type should be administrator\")<string>(\"administrator\")(result1.type);\n    TestValidator.predicate(\"id is uuid\")(() => typeof result1.id === \"string\" && result1.id.length > 0);\n    // 기타 응답 데이터 구조 및 필드 확인\n    TestValidator.predicate(\"has member and customer\")(() => typeof result1.member === \"object\" && typeof result1.customer === \"object\");\n\n    // 2. 같은 정보(빈 오브젝트)로 중복 가입 시도 => 중복 오류 기대\n    await TestValidator.httpError(\"should reject duplicate administrator signup\")(409)(\n        () => api.functional.shoppings.admins.authenticate.post(connection, input1)\n    );\n\n    // 3. 필수 정보 누락(실제로 빈 객체면 서버 오류 발생할지 검증)\n    // input1이 이미 빈 객체라서, 추가로 undefined 등은 타입상 불가.\n    // 혹시, 타입상 필수 필드가 없으므로, 더 누락시킬 데이터 없음.\n\n    // 4. 추가적으로, 잘못된 타입 (예: null이나 엉뚱한 데이터)를 요청시도해볼 수도 있으나,\n    // API 타입이 빈 객체여서 정상적으로 에러를 얻어내기는 제한. 이 케이스 제외.\n}\n",
  "test/features/api/admin/test_put_admin_authenticate_login_success_and_failure.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingAdministrator } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingAdministrator\";\nimport { IShoppingMember } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingMember\";\nimport typia from \"typia\";\n\nexport async function test_put_admin_authenticate_login_success_and_failure(connection: api.IConnection): Promise<void> {\n    // 1. Create administrator account\n    const joinInput: IShoppingAdministrator.IJoin = {};\n    const admin = await api.functional.shoppings.admins.authenticate.post(connection, joinInput);\n    typia.assert<IShoppingAdministrator.IInvert>(admin);\n\n    // Extract email (required by login DTO)\n    const emails = admin.member.emails;\n    TestValidator.predicate(\"at least one email\")(() => Array.isArray(emails) && emails.length > 0);\n    const email = emails[0]?.value;\n    const password = \"test-password\"; // use known test password, assumed from implementation\n\n    // 2. Valid login\n    const validLogin: IShoppingMember.ILogin = { email, password };\n    const adminLogin = await api.functional.shoppings.admins.authenticate.login(connection, validLogin);\n    typia.assert<IShoppingAdministrator.IInvert>(adminLogin);\n    TestValidator.equals(\"admin login invert eq\")<IShoppingAdministrator.IInvert>(admin)(adminLogin);\n\n    // 3. Invalid password\n    const invalidPasswordLogin: IShoppingMember.ILogin = { email, password: \"wrong-password\" };\n    await TestValidator.httpError(\"admin login with wrong password should fail\")(401)(async () => {\n        await api.functional.shoppings.admins.authenticate.login(connection, invalidPasswordLogin);\n    });\n\n    // 4. Non-existent account\n    const nonExistLogin: IShoppingMember.ILogin = { email: \"not-found@e2e.local\", password: \"dummy\" };\n    await TestValidator.httpError(\"admin login with non-existent email should fail\")(404, 401)(async () => {\n        await api.functional.shoppings.admins.authenticate.login(connection, nonExistLogin);\n    });\n}\n",
  "test/features/api/coupon/test_post_admins_coupons_create_and_duplicate.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingAdministrator } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingAdministrator\";\nimport { IShoppingCoupon } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCoupon\";\nimport { IShoppingCouponRestriction } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCouponRestriction\";\nimport { IShoppingCouponDiscount } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCouponDiscount\";\nimport { IShoppingCoupon } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCoupon\";\nimport { IShoppingCouponSectionCriteria } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCouponSectionCriteria\";\nimport typia from \"typia\";\n\nexport async function test_post_admins_coupons_create_and_duplicate(connection: api.IConnection): Promise<void> {\n  // 1. 관리자 인증 (권한 확보)\n  const admin: IShoppingAdministrator.IInvert = await api.functional.shoppings.admins.authenticate.get(connection);\n  typia.assert<IShoppingAdministrator.IInvert>(admin);\n\n  // 2. 쿠폰 생성에 사용할 값 준비\n  const now = new Date();\n  const tomorrow = new Date(now.getTime() + 24 * 60 * 60 * 1000);\n  const couponName = \"테스트쿠폰\" + String(Math.random()).slice(2,10);\n  const disposableCode = \"CODE\" + String(Math.random()).slice(2,8);\n\n  const couponInput: IShoppingCoupon.ICreate = {\n    name: couponName,\n    discount: {\n      unit: \"percent\",\n      value: 10,\n      threshold: null,\n      limit: null\n    },\n    restriction: {\n      access: \"public\",\n      exclusive: false,\n      volume: null,\n      volume_per_citizen: null,\n      expired_in: null,\n      expired_at: null\n    },\n    criterias: [\n      {\n        type: \"section\",\n        direction: \"include\",\n        section_codes: [\"abc-section-code\"]\n      }\n    ],\n    disposable_codes: [disposableCode],\n    opened_at: now.toISOString(),\n    closed_at: tomorrow.toISOString(),\n  };\n\n  // 3. 쿠폰 정상 생성\n  const created = await api.functional.shoppings.admins.coupons.post(connection, { body: couponInput });\n  typia.assert<IShoppingCoupon>(created);\n  TestValidator.equals(\"쿠폰명 일치\")<string>(couponInput.name)(created.name);\n  TestValidator.equals(\"할인 타입 일치\")<string>((couponInput.discount as any).unit)((created.discount as any).unit);\n\n  // 4. 중복 코드로 재생성 시 에러 발생 (409 등)\n  await TestValidator.httpError(\"쿠폰 중복 생성 에러\")(409)(async () => {\n    await api.functional.shoppings.admins.coupons.post(connection, { body: couponInput });\n  });\n\n  // 5. 필수값 누락(name) 시의 에러 (400)\n  const invalidInput = { ...couponInput };\n  delete (invalidInput as any).name;\n  await TestValidator.httpError(\"쿠폰명 누락 시 에러\")(400)(async () => {\n    await api.functional.shoppings.admins.coupons.post(connection, { body: invalidInput });\n  });\n}\n",
  "test/features/api/coupon/test_patch_admins_coupons_list_and_filters.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingCoupon } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCoupon\";\nimport { IShoppingCoupon as ICreateCoupon } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCoupon.ICreate\";\nimport { IShoppingCoupon as IRequest } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCoupon.IRequest\";\nimport { IPageIShoppingCoupon } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIShoppingCoupon\";\nimport typia from \"typia\";\n\nexport async function test_patch_admins_coupons_list_and_filters(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. 빈 DB - 쿠폰 없는 상태 조회\n  const emptyReq: IRequest = {};\n  const emptyPage = await api.functional.shoppings.admins.coupons.patch(\n    connection,\n    { body: emptyReq },\n  );\n  typia.assert<IPageIShoppingCoupon>(emptyPage);\n  TestValidator.equals(\"empty coupon list\")([] as IShoppingCoupon[])(emptyPage.data);\n\n  // 2. 다양한 쿠폰 2개 생성\n  const now = new Date().toISOString();\n  const couponInput1: ICreateCoupon.ICreate = {\n    name: \"토스트생성쿠폰-1\",\n    discount: {\n      unit: \"amount\",\n      value: 1000,\n      threshold: null,\n      limit: null,\n      multiplicative: false\n    },\n    restriction: {\n      access: \"public\",\n      exclusive: false,\n      volume: null,\n      volume_per_citizen: null,\n      expired_in: null,\n      expired_at: null\n    },\n    criterias: [],\n    disposable_codes: [],\n    opened_at: now,\n    closed_at: null\n  };\n  const couponInput2: ICreateCoupon.ICreate = {\n    name: \"필터검색테스트쿠폰\",\n    discount: {\n      unit: \"percent\",\n      value: 10,\n      threshold: null,\n      limit: null\n    },\n    restriction: {\n      access: \"private\",\n      exclusive: true,\n      volume: 100,\n      volume_per_citizen: 2,\n      expired_in: 10,\n      expired_at: null\n    },\n    criterias: [],\n    disposable_codes: [\"SPECIAL10\"],\n    opened_at: now,\n    closed_at: null\n  };\n  const created1 = await api.functional.shoppings.admins.coupons.post(\n    connection,\n    { body: couponInput1 },\n  );\n  typia.assert<IShoppingCoupon>(created1);\n  TestValidator.equals(\"created coupon1 name\")(couponInput1.name)(created1.name);\n  const created2 = await api.functional.shoppings.admins.coupons.post(\n    connection,\n    { body: couponInput2 },\n  );\n  typia.assert<IShoppingCoupon>(created2);\n  TestValidator.equals(\"created coupon2 name\")(couponInput2.name)(created2.name);\n\n  // 3. 전체 목록 조회(조건X)\n  const pageAll = await api.functional.shoppings.admins.coupons.patch(\n    connection,\n    { body: {} },\n  );\n  typia.assert<IPageIShoppingCoupon>(pageAll);\n  TestValidator.predicate(\"contains created coupon1\")(\n    !!pageAll.data.find((c) => c.name === couponInput1.name)\n  );\n  TestValidator.predicate(\"contains created coupon2\")(\n    !!pageAll.data.find((c) => c.name === couponInput2.name)\n  );\n  // 전체 쿠폰 개수 2개 이상임을 보장\n  TestValidator.predicate(\"all coupon count >=2\")(pageAll.data.length >= 2);\n\n  // 4. 페이지네이션(limit=1, page=0/1)\n  const pageOneOnly = await api.functional.shoppings.admins.coupons.patch(\n    connection,\n    { body: { limit: 1, page: 0 } },\n  );\n  typia.assert<IPageIShoppingCoupon>(pageOneOnly);\n  TestValidator.equals(\"pageOneOnly.data length\")(1)(pageOneOnly.data.length);\n  TestValidator.equals(\"pagination.current page 0\")(0)(pageOneOnly.pagination.current);\n  TestValidator.equals(\"pagination.limit 1\")(1)(pageOneOnly.pagination.limit);\n\n  const pageSecond = await api.functional.shoppings.admins.coupons.patch(\n    connection,\n    { body: { limit: 1, page: 1 } },\n  );\n  typia.assert<IPageIShoppingCoupon>(pageSecond);\n  TestValidator.equals(\"pageSecond.data length\")(1)(pageSecond.data.length);\n  TestValidator.equals(\"pagination.current page 1\")(1)(pageSecond.pagination.current);\n\n  // 5. 검색 조건(name 필터)\n  const filterByName = await api.functional.shoppings.admins.coupons.patch(\n    connection,\n    { body: { search: { name: couponInput2.name } } },\n  );\n  typia.assert<IPageIShoppingCoupon>(filterByName);\n  TestValidator.predicate(\"search by name only coupon2\")(\n    filterByName.data.length === 1 && filterByName.data[0].name === couponInput2.name\n  );\n\n  // 6. 유효하지 않은 page, 높은 page 값(exceed) --> 빈 결과\n  const tooHighPage = await api.functional.shoppings.admins.coupons.patch(\n    connection,\n    { body: { limit: 10, page: 100 },\n    },\n  );\n  typia.assert<IPageIShoppingCoupon>(tooHighPage);\n  TestValidator.equals(\"too high page returns empty\")([] as IShoppingCoupon[])(tooHighPage.data);\n}\n",
  "test/features/api/coupon/test_get_admins_coupons_by_id_and_not_found.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingCoupon } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCoupon\";\nimport { IShoppingCoupon as ICoupon } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCoupon\";\nimport { IShoppingCoupon as ICouponNamespace } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCoupon\";\nimport typia from \"typia\";\nimport { v4 as uuidv4 } from \"uuid\";\n\nexport async function test_api_coupon_detail_and_notfound(connection: api.IConnection): Promise<void> {\n  // Step 1: 쿠폰 생성\n  const couponInput: ICouponNamespace.ICreate = {\n    name: \"E2E Test Coupon\",\n    discount: {\n      unit: \"amount\",\n      value: 1000,\n      threshold: null,\n      limit: null,\n      multiplicative: false\n    },\n    restriction: {\n      access: \"public\",\n      exclusive: false,\n      volume: null,\n      volume_per_citizen: null,\n      expired_in: null,\n      expired_at: null\n    },\n    criterias: [\n      {\n        type: \"section\",\n        section_codes: [\"section-001\"],\n        direction: \"include\"\n      }\n    ],\n    disposable_codes: [],\n    opened_at: null,\n    closed_at: null\n  };\n\n  const created = await api.functional.shoppings.admins.coupons.post(\n    connection,\n    couponInput\n  );\n  typia.assert<IShoppingCoupon>(created);\n\n  // Step 2: 생성된 id로 상세 조회\n  const couponId = created.id;\n  const read = await api.functional.shoppings.admins.coupons.getById(\n    connection,\n    couponId\n  );\n  typia.assert<IShoppingCoupon>(read);\n  TestValidator.equals(\"coupon id match\")<string>(couponId)(read.id);\n  TestValidator.equals(\"name match\")<string>(couponInput.name)(read.name);\n\n  // Step 3: 존재하지 않는 id로 상세 조회 - 404 검증\n  const notFoundId = uuidv4();\n  await TestValidator.httpError(\"404 must be thrown for not found coupon\")(404)(\n    () => api.functional.shoppings.admins.coupons.getById(connection, notFoundId)\n  );\n}\n",
  "test/features/api/coupon/test_delete_admins_coupons_by_id_and_verify_deletion.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingCoupon } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCoupon\";\nimport { IShoppingCoupon as ICouponNS } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCoupon\";\nimport typia from \"typia\";\n\nimport { v4 as uuid } from \"uuid\";\n\nexport async function test_delete_admins_coupons_by_id_and_verify_deletion(\n  connection: api.IConnection\n): Promise<void> {\n  // 1. Create a coupon first for deletion\n  const couponInput: ICouponNS.ICreate = {\n    discount: {\n      unit: \"amount\",\n      value: 1000,\n      threshold: null,\n      limit: null,\n      multiplicative: false,\n    },\n    restriction: {\n      access: \"public\",\n      exclusive: false,\n      volume: 100,\n      volume_per_citizen: 1,\n      expired_in: 30,\n      expired_at: null,\n    },\n    criterias: [\n      {\n        type: \"section\",\n        direction: \"include\",\n        section_codes: [\"SECTION-123\"],\n      },\n    ],\n    disposable_codes: [\"ABCD1234\"],\n    name: \"Delete Test Coupon\",\n    opened_at: new Date().toISOString(),\n    closed_at: null,\n  };\n  const created: IShoppingCoupon = await api.functional.shoppings.admins.coupons.post(\n    connection,\n    couponInput\n  );\n  typia.assert(created);\n  TestValidator.equals(\"coupon.name\")<string>(couponInput.name)(created.name);\n\n  // 2. 정상적 삭제\n  await api.functional.shoppings.admins.coupons.deleteById(\n    connection,\n    created.id\n  );\n\n  // 3. 삭제한 쿠폰이 다시 조회 불가(404 등)\n  await TestValidator.httpError(\"Coupon deleted should not be found\")(404)(\n    async () => {\n      await api.functional.shoppings.admins.coupons.at(\n        connection,\n        created.id\n      );\n    }\n  );\n\n  // 4. 이미 삭제한 쿠폰을 중복 삭제: 404 등의 적절한 에러\n  await TestValidator.httpError(\"Already deleted coupon deletion error\")(404)(\n    async () => {\n      await api.functional.shoppings.admins.coupons.deleteById(\n        connection,\n        created.id\n      );\n    }\n  );\n\n  // 5. 없는 ID로 삭제\n  const nonExistingId = uuid();\n  await TestValidator.httpError(\"Non-existing coupon deletion error\")(404)(\n    async () => {\n      await api.functional.shoppings.admins.coupons.deleteById(\n        connection,\n        nonExistingId\n      );\n    }\n  );\n}\n",
  "test/features/api/deposit/test_post_admins_deposits_create_and_duplicate.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingDeposit } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingDeposit\";\nimport { IShoppingDeposit as IShoppingDepositCreate } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingDeposit.ICreate\";\nimport typia from \"typia\";\n\nexport async function test_post_admins_deposits_create_and_duplicate(connection: api.IConnection): Promise<void> {\n  // 1. 관리자 인증 (GET /shoppings/admins/authenticate)\n  // 실제 권한/토큰 처리가 connection에 이미 반영되어 있다고 가정\n  const admin = await api.functional.shoppings.admins.authenticate.get(connection);\n  typia.assert(admin);\n\n  // 2. 정상 입금 메타데이터 생성 (POST /shoppings/admins/deposits)\n  const code = `dep-${Math.random().toString(36).substring(2,10)}`;\n  const input: IShoppingDepositCreate.ICreate = {\n    code,\n    source: \"E2E test\",\n    direction: 1,\n  };\n  const created: IShoppingDeposit = await api.functional.shoppings.admins.deposits.post(\n    connection,\n    { body: input }\n  );\n  typia.assert(created);\n  TestValidator.equals(\"code\")<string>(input.code)(created.code);\n  TestValidator.equals(\"source\")<string>(input.source)(created.source);\n  TestValidator.equals(\"direction\")<1 | -1>(input.direction)(created.direction);\n\n  // 3. 중복 code로 한 번 더 생성 시도 → 오류(409 등) 확인\n  await TestValidator.httpError(\"duplicate code should fail\")(409,400,422)(() =>\n    api.functional.shoppings.admins.deposits.post(connection, { body: input })\n  );\n\n  // 4. 필수값 누락 시도: code 없음\n  const missingCode = { ...input };\n  delete (missingCode as any).code;\n  await TestValidator.httpError(\"missing code should fail\")(400,422)(() =>\n    api.functional.shoppings.admins.deposits.post(connection, { body: missingCode as any })\n  );\n\n  // 5. 필수값 누락 시도: source 없음\n  const missingSource = { ...input };\n  delete (missingSource as any).source;\n  await TestValidator.httpError(\"missing source should fail\")(400,422)(() =>\n    api.functional.shoppings.admins.deposits.post(connection, { body: missingSource as any })\n  );\n\n  // 6. 필수값 누락 시도: direction 없음\n  const missingDirection = { ...input };\n  delete (missingDirection as any).direction;\n  await TestValidator.httpError(\"missing direction should fail\")(400,422)(() =>\n    api.functional.shoppings.admins.deposits.post(connection, { body: missingDirection as any })\n  );\n}\n",
  "test/features/api/deposit/test_patch_admins_deposits_list_and_pagination.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingDeposit } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingDeposit\";\nimport { IShoppingDeposit as IShoppingDepositNS } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingDeposit\";\nimport { IPageIShoppingDeposit } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIShoppingDeposit\";\nimport typia from \"typia\";\n\nexport async function test_patch_admins_deposits_list_and_pagination(connection: api.IConnection): Promise<void> {\n    // 1. 여러 개의 입금 메타데이터를 생성\n    const items: IShoppingDeposit[] = [];\n    const sources = [\"test-source-A\", \"test-source-B\", \"test-source-C\"];\n    const codes = [\"abc\", \"def\", \"ghi\"];\n    const directions = [1, -1, 1];\n    for (let i = 0; i < 3; ++i) {\n        const input: IShoppingDepositNS.ICreate = {\n            code: codes[i],\n            source: sources[i],\n            direction: directions[i] as 1 | -1,\n        };\n        const created = await api.functional.shoppings.admins.deposits.post(connection, input);\n        typia.assert<IShoppingDeposit>(created);\n        items.push(created);\n    }\n\n    // 2. 전체 리스트를 아무 필터 없이 요청\n    const totalList = await api.functional.shoppings.admins.deposits.patch(connection, {});\n    typia.assert<IPageIShoppingDeposit>(totalList);\n    TestValidator.equals(\"전체 데이터 개수 확인\")<number>(items.length)(totalList.data.length >= 3 ? 3 : totalList.data.length);\n\n    // 3. 페이지네이션 동작 확인: limit=2\n    const pageReq: IShoppingDepositNS.IRequest = {\n        limit: 2,\n        page: 0,\n    };\n    const page0 = await api.functional.shoppings.admins.deposits.patch(connection, pageReq);\n    typia.assert<IPageIShoppingDeposit>(page0);\n    TestValidator.predicate(\"limit만큼 반환\")(() => page0.data.length === 2);\n    TestValidator.predicate(\"pagination 정보 확인\")(() => page0.pagination.limit === 2);\n\n    // 페이지 1 확인\n    const page1Req: IShoppingDepositNS.IRequest = {\n        limit: 2, page: 1,\n    };\n    const page1 = await api.functional.shoppings.admins.deposits.patch(connection, page1Req);\n    typia.assert<IPageIShoppingDeposit>(page1);\n    TestValidator.predicate(\"page 1의 데이터 개수 확인\")(() =>\n        page1.data.length === (items.length > 2 ? 1 : 0)\n    );\n\n    // 4. 검색 조건별 필터 동작 확인: source로 1개 필터\n    const filterSourceReq: IShoppingDepositNS.IRequest = {\n        search: { source: sources[0] },\n    };\n    const filtered = await api.functional.shoppings.admins.deposits.patch(connection, filterSourceReq);\n    typia.assert<IPageIShoppingDeposit>(filtered);\n    TestValidator.predicate(\"source별 필터\")(() =>\n      filtered.data.length === 1 && filtered.data[0].source === sources[0]\n    );\n\n    // code 필터\n    const filterCodeReq: IShoppingDepositNS.IRequest = {\n        search: { code: codes[1] },\n    };\n    const filteredCode = await api.functional.shoppings.admins.deposits.patch(connection, filterCodeReq);\n    typia.assert<IPageIShoppingDeposit>(filteredCode);\n    TestValidator.predicate(\"code별 필터\")(() =>\n      filteredCode.data.length === 1 && filteredCode.data[0].code === codes[1]\n    );\n\n    // direction 필터\n    const filterDirReq: IShoppingDepositNS.IRequest = {\n        search: { direction: directions[2] },\n    };\n    const filteredDir = await api.functional.shoppings.admins.deposits.patch(connection, filterDirReq);\n    typia.assert<IPageIShoppingDeposit>(filteredDir);\n    TestValidator.predicate(\"direction별 필터\")(() =>\n      filteredDir.data.every(d => d.direction === directions[2])\n    );\n\n    // 5. 없는 데이터 검색시 빈 리스트 반환\n    const absentReq: IShoppingDepositNS.IRequest = {\n        search: { code: \"not-exist-code\" },\n    };\n    const absent = await api.functional.shoppings.admins.deposits.patch(connection, absentReq);\n    typia.assert<IPageIShoppingDeposit>(absent);\n    TestValidator.equals(\"검색 결과 없음 반환\")(0)(absent.data.length);\n\n    // 6. pagination/data 타입 정합성 추가검증\n    for (const d of totalList.data) {\n      typia.assert<IShoppingDeposit>(d);\n    }\n    typia.assert<IPageIShoppingDeposit>(totalList);\n}\n",
  "test/features/api/shopping-deposit/test_get_admins_deposits_by_id_and_not_found.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingDeposit } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingDeposit\";\nimport { IShoppingDeposit as IShoppingDepositNamespace } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingDeposit\";\nimport typia from \"typia\";\n\nexport async function test_api_get_admins_deposits_by_id_and_not_found(connection: api.IConnection): Promise<void> {\n    // 1. 입금 메타데이터 생성\n    const createInput: IShoppingDepositNamespace.ICreate = {\n        code: \"test-code-1\",\n        source: \"test-source-1\",\n        direction: 1,\n    };\n    const created: IShoppingDeposit = await api.functional.shoppings.admins.deposits.post(connection, createInput);\n    typia.assert<IShoppingDeposit>(created);\n\n    // 2. id로 상세 조회\n    const found: IShoppingDeposit = await api.functional.shoppings.admins.deposits.get(connection, created.id);\n    typia.assert<IShoppingDeposit>(found);\n    TestValidator.equals(\"Deposit detail matches\")(created)(found);\n\n    // 3. 없는 id로 조회시 404 에러\n    const invalidId = \"11111111-1111-1111-1111-111111111111\";\n    await TestValidator.httpError(\"Should be 404 for not found deposit\")(404)(\n        () => api.functional.shoppings.admins.deposits.get(connection, invalidId),\n    );\n}\n",
  "test/features/api/deposit/test_delete_admins_deposits_by_id_and_verify_deletion.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingDeposit } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingDeposit\";\nimport typia from \"typia\";\n\nexport async function test_delete_admins_deposits_by_id_and_verify_deletion(connection: api.IConnection): Promise<void> {\n    // 1. 새로운 입금 메타데이터 생성\n    const createInput: IShoppingDeposit.ICreate = {\n        code: \"TEST_DELETE_CODE\",\n        source: \"test-source\",\n        direction: 1,\n    };\n    const deposit = await api.functional.shoppings.admins.deposits.post(connection, createInput);\n    typia.assert<IShoppingDeposit>(deposit);\n    TestValidator.equals(\"deposit.code\")(createInput.code)(deposit.code);\n\n    // 2. 정상 삭제\n    await api.functional.shoppings.admins.deposits.deleteById(connection, deposit.id);\n\n    // 3. 삭제 후 재조회 시 404 에러\n    await TestValidator.httpError(\"deleted deposit should return 404\")(404)(async () => {\n        await api.functional.shoppings.admins.deposits.getById(connection, deposit.id);\n    });\n\n    // 4. 존재하지 않는 id로 삭제 시 404 에러\n    const fakeId = \"00000000-0000-4000-8000-000000000000\";\n    await TestValidator.httpError(\"deleting non-existent deposit should return 404\")(404)(async () => {\n        await api.functional.shoppings.admins.deposits.deleteById(connection, fakeId);\n    });\n}\n",
  "test/features/api/deposit/test_get_admins_deposits_by_code_and_not_found.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingDeposit } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingDeposit\";\nimport typia from \"typia\";\n\nexport async function test_get_admins_deposits_by_code_and_not_found(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. 여러 개의 입금 메타데이터(code 각각 다르게 지정) 생성\n  const deposits: IShoppingDeposit[] = [];\n  for (const code of [\"DEPOSIT_A\", \"DEPOSIT_B\", \"DEPOSIT_C\"]) {\n    const input = { code, source: `Source for ${code}`, direction: 1 };\n    const created = await api.functional.shoppings.admins.deposits.post(\n      connection,\n      input,\n    );\n    typia.assert<IShoppingDeposit>(created);\n    deposits.push(created);\n  }\n\n  // 2. 생성된 code 중 하나를 사용해서 정상적으로 조회되는지 확인\n  const target = deposits[1]; // DEPOSIT_B\n  const result = await api.functional.shoppings.admins.deposits.getByCode(\n    connection,\n    target.code,\n  );\n  typia.assert<IShoppingDeposit>(result);\n  TestValidator.equals(\"Get deposit by code\")<IShoppingDeposit>(target)(result);\n\n  // 3. 존재하지 않는 code로 요청 시 404 등 오류처리 확인\n  await TestValidator.httpError(\"Not found deposit by code\")(404)(async () =>\n    api.functional.shoppings.admins.deposits.getByCode(\n      connection,\n      \"NOT_EXIST_DEPOSIT_CODE\",\n    ),\n  );\n}\n",
  "test/features/api/mileage/test_post_admins_mileages_create_and_duplicate.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingMileage } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingMileage\";\nimport { IShoppingMileage as ICreate } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingMileage.ICreate\";\nimport typia from \"typia\";\n\nexport async function test_post_admins_mileages_create_and_duplicate(connection: api.IConnection): Promise<void> {\n  // 1. 관리자 인증 토큰 획득 (시나리오 상 필요한 경우)\n  const admin = await api.functional.shoppings.admins.authenticate.get(connection);\n  typia.assert(admin);\n  // 2. 정상 입력값으로 생성\n  const mileageInput: ICreate = {\n    code: `TEST_CODE_${Date.now()}`,\n    source: \"정상 생성 테스트\",\n    direction: 1,\n    value: 100,\n  };\n  const result = await api.functional.shoppings.admins.mileages.post(connection, { body: mileageInput });\n  typia.assert<IShoppingMileage>(result);\n  TestValidator.equals(\"success create: code\")<string>(mileageInput.code)(result.code);\n  \n  // 3. 동일 code 중복 생성시도 (오류 기대)\n  await TestValidator.httpError(\"duplicate code - should fail\")(409)(\n    async () => {\n      await api.functional.shoppings.admins.mileages.post(connection, { body: mileageInput });\n    }\n  );\n\n  // 4. 필수값 누락 케이스별로 생성 시도 및 유효성 에러 처리\n  const requiredFields: Array<keyof ICreate> = [\"code\", \"source\", \"direction\", \"value\"];\n  for (const omitField of requiredFields) {\n    // @ts-expect-error: intentionally omit required field\n    const badInput: Partial<ICreate> = { ...mileageInput };\n    // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n    delete badInput[omitField];\n    await TestValidator.httpError(`missing ${String(omitField)}`)(400, 422)(async () => {\n      // @ts-expect-error\n      await api.functional.shoppings.admins.mileages.post(connection, { body: badInput });\n    });\n  }\n}\n",
  "test/features/api/mileage/test_patch_admins_mileages_list_and_filters.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingMileage } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingMileage\";\nimport { IShoppingMileage as ICreate } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingMileage.ICreate\";\nimport { IShoppingMileage as IMileage } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingMileage\";\nimport { IShoppingMileage as IRequest } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingMileage.IRequest\";\nimport { IPageIShoppingMileage } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIShoppingMileage\";\nimport typia from \"typia\";\n\nexport async function test_patch_admins_mileages_list_and_filters(connection: api.IConnection): Promise<void> {\n  // 1. 여러 마일리지 메타데이터 생성\n  const mileages: IMileage[] = [];\n  const sources = [\"join\", \"purchase\", \"event\"];\n  const codes = [\"J01\", \"P01\", \"E01\"];\n  const directions = [1, -1];\n\n  for (let i = 0; i < sources.length; ++i) {\n    for (let d of directions) {\n      const input: ICreate.ICreate = {\n        code: codes[i],\n        source: sources[i],\n        direction: d as 1|-1,\n        value: d * (i+1) * 10\n      };\n      const mileage = await api.functional.shoppings.admins.mileages.post(\n        connection,\n        input\n      );\n      typia.assert<IMileage>(mileage);\n      mileages.push(mileage);\n    }\n  }\n  // 전체 개수: sources.length * directions.length\n  const totalCount = mileages.length;\n  // 2. 전체 목록 조회 (페이징/검색 없음)\n  const reqAll: IRequest.IRequest = {\n    search: null,\n    sort: null,\n    page: 1,\n    limit: totalCount + 2 // 전체 보여주기\n  };\n  const allRes = await api.functional.shoppings.admins.mileages.patch(connection, reqAll);\n  typia.assert<IPageIShoppingMileage>(allRes);\n  TestValidator.equals(\"전체 갯수 반환 확인\")<number>(totalCount)(allRes.data.length);\n  // 3. 검색조건별 필터\n  const searchBySource: IRequest.IRequest = {\n    search: { source: \"join\", code: null, direction: null },\n    sort: null,\n    page: 1,\n    limit: 10\n  };\n  const srcRes = await api.functional.shoppings.admins.mileages.patch(connection, searchBySource);\n  typia.assert<IPageIShoppingMileage>(srcRes);\n  TestValidator.predicate(\"source 검색 결과 올바름\")(() => srcRes.data.every(m => m.source === \"join\"));\n  // 4. page/limit에 따른 페이징 확인\n  const reqPage2: IRequest.IRequest = {\n    search: null,\n    sort: null,\n    page: 2,\n    limit: 2\n  };\n  const pagedRes = await api.functional.shoppings.admins.mileages.patch(connection, reqPage2);\n  typia.assert<IPageIShoppingMileage>(pagedRes);\n  TestValidator.equals(\"page 2 반환 개수\")<number>(Math.max(0, totalCount-2))(pagedRes.data.length);\n  TestValidator.equals(\"pagination page\")<number>(2)(pagedRes.pagination.current);\n\n  // 5. 존재하지 않는 search(임의의 code)\n  const searchFail: IRequest.IRequest = {\n    search: { source: null, code: \"NO_SUCH_CODE\", direction: null },\n    sort: null,\n    page: 1,\n    limit: 10\n  };\n  const failRes = await api.functional.shoppings.admins.mileages.patch(connection, searchFail);\n  typia.assert<IPageIShoppingMileage>(failRes);\n  TestValidator.equals(\"없는 code 검색시 빈 배열 반환\")([] as IMileage[])(failRes.data);\n  // 6. 데이터 없을 때 빈 배열 반환 확인\n  // - 별도의 삭제 기능이 없어 테스트 시 새로운 환경에서만 검증 가능, 건너뜀\n}\n",
  "test/features/api/mileage/test_get_admins_mileages_by_id_and_not_found.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingMileage } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingMileage\";\nimport { IShoppingMileage as IShoppingMileageNS } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingMileage\";\nimport typia from \"typia\";\nimport { v4 as uuidv4 } from \"uuid\";\n\nexport async function test_api_shoppings_admins_mileages_get_by_id_and_not_found(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. Create new mileage metadata\n  const input: IShoppingMileageNS.ICreate = {\n    code: \"TEST_CODE\",\n    source: \"E2E_TEST\",\n    direction: 1,\n    value: 1000,\n  };\n  const created = await api.functional.shoppings.admins.mileages.post(connection, { body: input });\n  typia.assert<IShoppingMileage>(created);\n\n  // 2. Read mileage metadata by id (should succeed)\n  const gotten = await api.functional.shoppings.admins.mileages.get(connection, created.id);\n  typia.assert<IShoppingMileage>(gotten);\n\n  // 3. Validate data consistency\n  TestValidator.equals(\"mileage id\")(created.id)(gotten.id);\n  TestValidator.equals(\"mileage code\")(input.code)(gotten.code);\n  TestValidator.equals(\"mileage source\")(input.source)(gotten.source);\n  TestValidator.equals(\"mileage direction\")(input.direction)(gotten.direction);\n  TestValidator.equals(\"mileage value\")(input.value)(gotten.value);\n\n  // 4. Try to query an unknown id (should get 404)\n  const randomId = uuidv4();\n  await TestValidator.httpError(\"not found should be 404\")(404)(\n    () => api.functional.shoppings.admins.mileages.get(connection, randomId)\n  );\n}\n",
  "test/features/api/mileage/test_delete_admins_mileages_by_id_and_verify_deletion.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingMileage } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingMileage\";\nimport { IShoppingMileage as IShoppingMileageNamespace } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingMileage\";\nimport typia from \"typia\";\n\nexport async function test_api_delete_admins_mileages_by_id_and_verify_deletion(connection: api.IConnection): Promise<void> {\n    // 1. 생성용 데이터 준비\n    const createInput: IShoppingMileageNamespace.ICreate = {\n        code: \"TEST_DELETE\",\n        source: \"test_scenario\",\n        direction: 1,\n        value: 100,\n    };\n\n    // 2. 신규 마일리지 메타데이터 생성\n    const created: IShoppingMileage = await api.functional.shoppings.admins.mileages.post(connection, createInput);\n    typia.assert<IShoppingMileage>(created);\n\n    // 3. 정상 삭제 시도\n    await api.functional.shoppings.admins.mileages.delete(connection, created.id);\n    // 4. 동일 id로 재삭제 시도(404 검증)\n    await TestValidator.httpError(\"Delete already deleted mileage should fail\")(404)(() => api.functional.shoppings.admins.mileages.delete(connection, created.id));\n\n    // 5. 랜덤으로 없는 id를 만듦(uuid 형식)\n    const fakeId = \"00000000-0000-4000-8000-000000000000\";\n    await TestValidator.httpError(\"Delete non-existent mileage should fail\")(404)(() => api.functional.shoppings.admins.mileages.delete(connection, fakeId));\n}\n",
  "test/features/api/mileage/test_get_admins_mileages_by_code_and_not_found.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingMileage } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingMileage\";\nimport { IShoppingMileage as IC, IShoppingMileage as IShoppingMileageNamespace } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingMileage\";\nimport typia from \"typia\";\n\nexport async function test_api_get_admins_mileages_by_code_and_not_found(connection: api.IConnection): Promise<void> {\n    // 1. Create sample mileage metadata\n    const input: IShoppingMileageNamespace.ICreate = {\n        code: `TEST_CODE_${Date.now()}`,\n        source: \"테스트 origin\",\n        direction: 1,\n        value: 1000\n    };\n    const created = await api.functional.shoppings.admins.mileages.post(connection, input);\n    typia.assert<IShoppingMileage>(created);\n\n    // 2. GET the created mileage metadata by its code\n    const fetched = await api.functional.shoppings.admins.mileages.getByCode(connection, created.code);\n    typia.assert<IShoppingMileage>(fetched);\n    TestValidator.equals(\"code\")(created.code)(fetched.code);\n    TestValidator.equals(\"direction\")(created.direction)(fetched.direction);\n    TestValidator.equals(\"value\")(created.value)(fetched.value);\n    TestValidator.equals(\"source\")(created.source)(fetched.source);\n\n    // 3. Negative case: GET a mileage with a non-existent code\n    await TestValidator.httpError(\"not found\")(404)(() =>\n        api.functional.shoppings.admins.mileages.getByCode(connection, \"___not_exist_code___\")\n    );\n}\n",
  "test/features/api/mileage/test_post_admins_mileages_donations_success_and_failure.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingMileage } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingMileage\";\nimport { IShoppingMileageDonation } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingMileageDonation\";\nimport { IShoppingMileageDonation as IShoppingMileageDonationNS } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingMileageDonation\";\nimport { IShoppingMileage as IShoppingMileageNS } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingMileage\";\nimport { IShoppingCustomer } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCustomer\";\nimport typia from \"typia\";\n\nexport async function test_post_admins_mileages_donations_success_and_failure(\n  connection: api.IConnection\n): Promise<void> {\n  // 1. 마일리지 코드 준비\n  const mileageInput: IShoppingMileageNS.ICreate = {\n    code: `DONATE_TEST_CODE_${Date.now()}`,\n    source: \"테스트 기부 사유\",\n    direction: 1,\n    value: 1000,\n  };\n  const mileage: IShoppingMileage = await api.functional.shoppings.admins.mileages.post(\n    connection, mileageInput\n  );\n  typia.assert<IShoppingMileage>(mileage);\n  TestValidator.equals(\"mileage.code matches input\")(mileageInput.code)(mileage.code);\n\n  // 2. 시민 계정(기부 대상) 확보\n  const customer: IShoppingCustomer = await api.functional.shoppings.customers.authenticate(\n    connection\n  );\n  typia.assert<IShoppingCustomer>(customer);\n  TestValidator.predicate(\"citizen exists in customer\")(\n    !!customer.citizen && typeof customer.citizen.id === \"string\"\n  );\n\n  const validCitizenId = customer.citizen!.id;\n\n  // 3. 정상 기부\n  const donationInput: IShoppingMileageDonationNS.ICreate = {\n    citizen_id: validCitizenId,\n    value: 777,\n    reason: \"이벤트 기부 정상 흐름\",\n  };\n  const donation: IShoppingMileageDonation = await api.functional.shoppings.admins.mileages.donations.post(\n    connection, donationInput\n  );\n  typia.assert<IShoppingMileageDonation>(donation);\n  TestValidator.equals(\"donation.value matches input\")(donationInput.value)(donation.value);\n  TestValidator.equals(\"donation.reason matches input\")(donationInput.reason)(donation.reason);\n  TestValidator.equals(\"donation.citizen.id matches input\")(donationInput.citizen_id)(donation.citizen.id);\n\n  // 4-1. 실패: 존재하지 않는 시민 ID로 기부 시도\n  const fakeCitizenId = \"00000000-0000-0000-0000-999999999999\";\n  const invalidCitizenInput: IShoppingMileageDonationNS.ICreate = {\n    citizen_id: fakeCitizenId,\n    value: 500,\n    reason: \"존재하지 않는 시민 기부\",\n  };\n  await TestValidator.httpError(\"donation to non-existing citizen should fail\")(404)(async () => {\n    await api.functional.shoppings.admins.mileages.donations.post(\n      connection, invalidCitizenInput\n    );\n  });\n\n  // 4-2. 실패: value <= 0\n  const zeroValueInput: IShoppingMileageDonationNS.ICreate = {\n    citizen_id: validCitizenId,\n    value: 0,\n    reason: \"잘못된 값 기부\",\n  };\n  await TestValidator.httpError(\"donation with zero value should fail\")(400)(async () => {\n    await api.functional.shoppings.admins.mileages.donations.post(\n      connection, zeroValueInput\n    );\n  });\n\n  const negativeValueInput: IShoppingMileageDonationNS.ICreate = {\n    citizen_id: validCitizenId,\n    value: -100,\n    reason: \"음수 값 기부\",\n  };\n  await TestValidator.httpError(\"donation with negative value should fail\")(400)(async () => {\n    await api.functional.shoppings.admins.mileages.donations.post(\n      connection, negativeValueInput\n    );\n  });\n}\n",
  "test/features/api/mileage-donation/test_patch_admins_mileages_donations_list_and_filter.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport { IShoppingMileageDonation } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingMileageDonation\";\nimport { IShoppingMileageDonation as IDonationNS } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingMileageDonation\";\nimport { IShoppingCitizen } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCitizen\";\nimport { IPageIShoppingMileageDonation } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIShoppingMileageDonation\";\n\nexport async function test_patch_admins_mileages_donations_list_and_filter(connection: api.IConnection): Promise<void> {\n    // 1. 테스트용 시민 2명 생성 및 관리자 기부 내역 2건 생성 (시민별)\n    // 시민1\n    const citizen1: IShoppingCitizen = {\n        id: crypto.randomUUID(),\n        name: \"테스트시민1\",\n        mobile: \"01012340001\",\n        created_at: new Date().toISOString()\n    };\n    // 시민2\n    const citizen2: IShoppingCitizen = {\n        id: crypto.randomUUID(),\n        name: \"테스트시민2\",\n        mobile: \"01012340002\",\n        created_at: new Date().toISOString()\n    };\n    // 기부내역 생성 (시민1)\n    const donateInput1: IDonationNS.ICreate = {\n        citizen_id: citizen1.id,\n        value: 2000,\n        reason: \"시험용 기부1\"\n    };\n    const donation1 = await api.functional.shoppings.admins.mileages.donations.post(connection, donateInput1);\n    typia.assert<IShoppingMileageDonation>(donation1);\n    // 기부내역 생성 (시민2, 시간차이)\n    await new Promise(r=>setTimeout(r, 1000));\n    const donateInput2: IDonationNS.ICreate = {\n        citizen_id: citizen2.id,\n        value: 3500,\n        reason: \"시험용 기부2\"\n    };\n    const donation2 = await api.functional.shoppings.admins.mileages.donations.post(connection, donateInput2);\n    typia.assert<IShoppingMileageDonation>(donation2);\n    // 2. 전체 기부 내역 조회 (최소 2건)\n    let listReq: IDonationNS.IRequest = {};\n    const listAll = await api.functional.shoppings.admins.mileages.donations.patch(connection, listReq);\n    typia.assert<IPageIShoppingMileageDonation>(listAll);\n    TestValidator.predicate(\"all donations exist\")(() =>\n        listAll.data.some(x => x.id === donation1.id)\n        && listAll.data.some(x => x.id === donation2.id)\n    );\n    // 3. citizen id로 필터\n    listReq = { search: { citizen: { mobile: citizen1.mobile, name: citizen1.name } } };\n    const filtered1 = await api.functional.shoppings.admins.mileages.donations.patch(connection, listReq);\n    typia.assert<IPageIShoppingMileageDonation>(filtered1);\n    TestValidator.predicate(\"only citizen1 donations\")(() =>\n        filtered1.data.every(x => x.citizen.id === citizen1.id)\n    );\n    // 4. 값(minimum) 필터\n    listReq = { search: { minimum: 3000 } };\n    const filtered2 = await api.functional.shoppings.admins.mileages.donations.patch(connection, listReq);\n    typia.assert<IPageIShoppingMileageDonation>(filtered2);\n    TestValidator.predicate(\"only >=3000 donations\")(() =>\n        filtered2.data.every(x => x.value >= 3000)\n    );\n    // 5. 값(maximum) 필터\n    listReq = { search: { maximum: 2500 } };\n    const filtered3 = await api.functional.shoppings.admins.mileages.donations.patch(connection, listReq);\n    typia.assert<IPageIShoppingMileageDonation>(filtered3);\n    TestValidator.predicate(\"only <=2500 donations\")(() =>\n        filtered3.data.every(x => x.value <= 2500)\n    );\n    // 6. 기간 필터 (from, to)\n    const fromDate = new Date(Date.now()-2000).toISOString();\n    const toDate = new Date(Date.now()+2000).toISOString();\n    listReq = { search: { from: fromDate, to: toDate } };\n    const filtered4 = await api.functional.shoppings.admins.mileages.donations.patch(connection, listReq);\n    typia.assert<IPageIShoppingMileageDonation>(filtered4);\n    // 기간 내 생성된 도네이션만 포함되는지 확인\n    TestValidator.predicate(\"all data in time range\")(() =>\n        filtered4.data.every(x => \n            new Date(x.created_at) >= new Date(fromDate) && new Date(x.created_at) <= new Date(toDate)\n        )\n    );\n    // 7. 정렬(sort) 테스트 (내림차순, 오름차순)\n    listReq = { sort: [\"-donation.value\"] };\n    const sortedDesc = await api.functional.shoppings.admins.mileages.donations.patch(connection, listReq);\n    typia.assert<IPageIShoppingMileageDonation>(sortedDesc);\n    TestValidator.predicate(\"desc value order\")(() =>\n        sortedDesc.data.every((x,i,arr)=> i===0 || arr[i-1].value >= x.value)\n    );\n    listReq = { sort: [\"+donation.value\"] };\n    const sortedAsc = await api.functional.shoppings.admins.mileages.donations.patch(connection, listReq);\n    typia.assert<IPageIShoppingMileageDonation>(sortedAsc);\n    TestValidator.predicate(\"asc value order\")(() =>\n        sortedAsc.data.every((x,i,arr)=> i===0 || arr[i-1].value <= x.value)\n    );\n    // 8. 조건에 일치하지 않을 때 빈 배열\n    listReq = { search: { minimum: 99999 } };\n    const none = await api.functional.shoppings.admins.mileages.donations.patch(connection, listReq);\n    typia.assert<IPageIShoppingMileageDonation>(none);\n    TestValidator.equals(\"empty data when no match\")([] as IShoppingMileageDonation[])(none.data);\n    // 9. 타입 안전성 추가 검증\n    listReq = {};\n    const relist = await api.functional.shoppings.admins.mileages.donations.patch(connection, listReq);\n    typia.assert<IPageIShoppingMileageDonation>(relist);\n}",
  "test/features/api/mileage-donation/test_get_admins_mileages_donations_by_id_and_not_found.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingMileageDonation } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingMileageDonation\";\nimport { IShoppingMileageDonation as ICrt } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingMileageDonation.ICreate\";\nimport typia from \"typia\";\n\n// Helper: Returns a random UUID (not colliding with any present)\nfunction random_uuid() {\n  // v4 UUID pattern, not checking for actual collisions for test simplicity\n  return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, function (c) {\n    const r = (Math.random() * 16) | 0,\n      v = c === \"x\" ? r : (r & 0x3) | 0x8;\n    return v.toString(16);\n  });\n}\n\nexport async function test_api_get_admins_mileages_donations_by_id_and_not_found(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. 사전 데이터 준비 (존재하는 citizen_id 필요)\n  const donationInput: ICrt.ICreate = {\n    // 실제 테스트에서는 유효한 citizen_id가 필요합니다 (fixture 또는 실데이터 활용)\n    citizen_id: \"11111111-1111-4111-8111-111111111111\", // TODO: substitute valid test citizen_id\n    value: 1000,\n    reason: \"테스트 기부\"\n  };\n\n  // 2. 기부 내역 생성\n  const created: IShoppingMileageDonation = await api.functional.shoppings.admins.mileages.donations.post(\n    connection,\n    donationInput\n  );\n  typia.assert<IShoppingMileageDonation>(created);\n\n  // 3. 정상 조회\n  const detailed = await api.functional.shoppings.admins.mileages.donations.get(\n    connection,\n    created.id\n  );\n  typia.assert<IShoppingMileageDonation>(detailed);\n  TestValidator.equals(\"matched id\")<string>(created.id)(detailed.id);\n  TestValidator.equals(\"matched value\")<number>(created.value)(detailed.value);\n  TestValidator.equals(\"matched reason\")<string>(created.reason)(detailed.reason);\n\n  // 4. 비존재 id로 조회 → 반드시 404 발생\n  const notFoundId = random_uuid();\n  await TestValidator.httpError(\"not found\")(404)(async () => {\n    await api.functional.shoppings.admins.mileages.donations.get(\n      connection,\n      notFoundId\n    );\n  });\n}\n",
  "test/features/api/order/test_patch_admins_orders_list_with_pagination_and_filters.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingOrder } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingOrder\";\nimport { IPageIShoppingOrder } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIShoppingOrder\";\nimport { IShoppingOrder_ICreate } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingOrder.ICreate\";\nimport { IShoppingOrder_IRequest } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingOrder.IRequest\";\nimport typia from \"typia\";\n\nexport async function test_patch_admins_orders_list_with_pagination_and_filters(connection: api.IConnection): Promise<void> {\n    // 1. Get admin info to confirm context\n    const admin = await api.functional.shoppings.admins.authenticate.get(connection);\n    typia.assert(admin);\n\n    // 2. Create at least one order as a customer (simulate minimal goods)\n    // Note: The creation input structure is not fully specified (e.g., what is a valid commodity_id? Here, we use a UUID placeholder.)\n    // In real E2E, this should use a registered commodity from test fixtures or preceding test cases.\n    const testCreateInput: IShoppingOrder_ICreate = {\n        goods: [\n            {\n                commodity_id: \"00000000-0000-0000-0000-000000000001\",\n                volume: 1\n            }\n        ],\n        name: \"테스트 주문\"\n    };\n    const testOrder = await api.functional.shoppings.customers.orders.post(connection, testCreateInput);\n    typia.assert<IShoppingOrder>(testOrder);\n\n    // 3a. No filters/pagination: should include the created order\n    const defaultRequest: IShoppingOrder_IRequest = {};\n    const pageDefault = await api.functional.shoppings.admins.orders.patch(connection, defaultRequest);\n    typia.assert<IPageIShoppingOrder>(pageDefault);\n    TestValidator.predicate(\"should have newly created order\")(\n      () => pageDefault.data.some((o) => o.id === testOrder.id)\n    );\n\n    // 3b. Pagination: limit 1, check first page returns single order\n    const pagedRequest: IShoppingOrder_IRequest = { limit: 1 };\n    const pageLimited = await api.functional.shoppings.admins.orders.patch(connection, pagedRequest);\n    typia.assert<IPageIShoppingOrder>(pageLimited);\n    TestValidator.equals(\"should return 1 order for limit=1\")(1)(pageLimited.data.length);\n\n    // 3c. Filter (e.g., impossible price): expect empty results\n    const priceFilterRequest: IShoppingOrder_IRequest = { search: { min_price: 99999999 } };\n    const pageFilter = await api.functional.shoppings.admins.orders.patch(connection, priceFilterRequest);\n    typia.assert<IPageIShoppingOrder>(pageFilter);\n    TestValidator.equals(\"should return empty for extreme price\", )(0)(pageFilter.data.length);\n\n    // 3d. If possible, try another filter: e.g. search.paid = false\n    const unpaidFilterRequest: IShoppingOrder_IRequest = { search: { paid: false } };\n    const pageUnpaid = await api.functional.shoppings.admins.orders.patch(connection, unpaidFilterRequest);\n    typia.assert<IPageIShoppingOrder>(pageUnpaid);\n    // Can't strictly predict data contents without full system state, but check structure\n\n    // 3e. Extreme pagination: page high number -> expect empty array if there aren't enough orders\n    const highPageRequest: IShoppingOrder_IRequest = { page: 999, limit: 10 };\n    const pageHigh = await api.functional.shoppings.admins.orders.patch(connection, highPageRequest);\n    typia.assert<IPageIShoppingOrder>(pageHigh);\n    if (pageHigh.data.length === 0) {\n        TestValidator.equals(\"should return empty array for high page\")(0)(pageHigh.data.length);\n    }\n}\n",
  "test/features/api/shopping-order/test_get_admins_orders_by_id_and_not_found.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport { IShoppingOrder } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingOrder\";\nimport { IShoppingOrder_ICreate } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingOrder.ICreate\";\n\nexport async function test_get_admins_orders_by_id_and_not_found(connection: api.IConnection): Promise<void> {\n    // 1. 주문 생성 (고객 주문 생성 API)\n    const orderInput: IShoppingOrder_ICreate = {\n        goods: [\n            // 최소 1개의 goods. commodity_id와 volume 직전 데이터가 필요하나, 여기 하드코딩\n            { commodity_id: \"11111111-1111-1111-1111-111111111111\", volume: 1 }\n        ],\n        name: \"테스트 주문\"\n    };\n    const newOrder = await api.functional.shoppings.customers.orders.post(connection, orderInput);\n    typia.assert<IShoppingOrder>(newOrder);\n\n    // 2. 생성된 주문 id로 관리자 상세 조회\n    const detail = await api.functional.shoppings.admins.orders.get(connection, newOrder.id);\n    typia.assert<IShoppingOrder>(detail);\n    TestValidator.equals(\"주문 상세 동일 여부\")(newOrder)(detail);\n\n    // 3. 존재하지 않는 주문 id로 404 오류 체크\n    const randomUUID = \"00000000-0000-0000-0000-000000000000\";\n    await TestValidator.httpError(\"존재하지 않는 주문 조회시 404\")(404)(\n        () => api.functional.shoppings.admins.orders.get(connection, randomUUID)\n    );\n}\n",
  "test/features/api/shopping-sale/test_patch_admins_sales_details_list_and_filters.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingSale } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSale\";\nimport { IShoppingSale as IShoppingSaleCreate } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSale.ICreate\";\nimport { IPageIShoppingSale } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIShoppingSale\";\nimport typia from \"typia\";\n\nexport async function test_patch_admins_sales_details_list_and_filters(\n  connection: api.IConnection\n): Promise<void> {\n  // 1. 최소 2개 이상의 판매 등록\n  const saleInputs: IShoppingSaleCreate.ICreate[] = [\n    {\n      section_code: \"section01\",\n      opened_at: new Date().toISOString(),\n      closed_at: null,\n      content: {\n        title: \"Test 상품 A\",\n        format: \"md\",\n        body: \"테스트 상품 A의 설명입니다.\",\n        files: [],\n        thumbnails: [],\n      },\n      units: [\n        {\n          name: \"기본 단위\",\n          primary: true,\n          required: true,\n          options: [],\n          stocks: [\n            {\n              name: \"재고1\",\n              price: { nominal: 12000, real: 10000 },\n              quantity: 10,\n              choices: [],\n            },\n          ],\n        },\n      ],\n      tags: [\"test\", \"A\"],\n      category_codes: [\"cat1\"],\n      status: null,\n    },\n    {\n      section_code: \"section01\",\n      opened_at: new Date().toISOString(),\n      closed_at: null,\n      content: {\n        title: \"Test 상품 B\",\n        format: \"md\",\n        body: \"테스트 상품 B의 설명입니다.\",\n        files: [],\n        thumbnails: [],\n      },\n      units: [\n        {\n          name: \"기본 단위\",\n          primary: true,\n          required: true,\n          options: [],\n          stocks: [\n            {\n              name: \"재고1\",\n              price: { nominal: 22000, real: 20000 },\n              quantity: 5,\n              choices: [],\n            },\n          ],\n        },\n      ],\n      tags: [\"test\", \"B\"],\n      category_codes: [\"cat1\"],\n      status: null,\n    }\n  ];\n\n  for (const input of saleInputs) {\n    const created = await api.functional.shoppings.sellers.sales.post(\n      connection,\n      input\n    );\n    typia.assert<IShoppingSale>(created);\n  }\n\n  // 2. 전체 판매 상세 리스트 조회 (파라미터 없이)\n  const res = await api.functional.shoppings.admins.sales.details.patch(\n    connection,\n    { body: {} }\n  );\n  typia.assert<IPageIShoppingSale>(res);\n  TestValidator.predicate(\"pagination: 총 레코드 2개 이상\")(\n    () => res.pagination.records >= 2\n  );\n  TestValidator.predicate(\"data: 비어있지 않음\")(() => res.data.length > 0);\n\n  // 3. 페이지네이션 Test: limit=1, page=1\n  const paged = await api.functional.shoppings.admins.sales.details.patch(\n    connection,\n    { body: { page: 1, limit: 1 } }\n  );\n  typia.assert<IPageIShoppingSale>(paged);\n  TestValidator.equals(\"page 1, limit 1, 크기 1 또는 0\")([\n    0, 1\n  ])((paged.data.length));\n  TestValidator.predicate(\"pagination.page == 1\")(\n    () => paged.pagination.current === 1\n  );\n  TestValidator.predicate(\"pagination.limit == 1\")(\n    () => paged.pagination.limit === 1\n  );\n\n  // 4. 정렬 옵션: 최신순\n  const sorted = await api.functional.shoppings.admins.sales.details.patch(\n    connection,\n    { body: { sort: [\"-sale.created_at\"] } }\n  );\n  typia.assert<IPageIShoppingSale>(sorted);\n  if (sorted.data.length >= 2) {\n    TestValidator.predicate(\"정렬 sale.created_at 내림차순\")(() =>\n      new Date(sorted.data[0].created_at).getTime() >=\n      new Date(sorted.data[1].created_at).getTime()\n    );\n  }\n\n  // 5. 빈 페이지 요청: page=9999\n  const emptyPage = await api.functional.shoppings.admins.sales.details.patch(\n    connection,\n    { body: { page: 9999, limit: 1 } }\n  );\n  typia.assert<IPageIShoppingSale>(emptyPage);\n  TestValidator.equals(\"page 9999은 데이터 없음\")([] as IShoppingSale[])(\n    emptyPage.data\n  );\n}\n",
  "test/features/api/shopping-sale/test_patch_admins_sales_summary_list_and_pagination.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport { IShoppingSale } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSale\";\nimport { IPageIShoppingSale } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIShoppingSale\";\nimport { IShoppingSaleICreate } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSale.ICreate\";\nimport { IShoppingSaleIRequest } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSale.IRequest\";\n\nexport async function test_patch_admins_sales_summary_list_and_pagination(connection: api.IConnection): Promise<void> {\n  // Step 1: 판매 데이터 2개 등록\n  const saleInput1: IShoppingSaleICreate = {\n    section_code: \"section-foo\",\n    opened_at: new Date().toISOString(),\n    closed_at: null,\n    content: {\n      title: \"Test Sale A\",\n      format: \"md\",\n      body: \"Description A\",\n      files: [],\n      thumbnails: [],\n    },\n    units: [\n      {\n        name: \"unitA\",\n        primary: true,\n        required: true,\n        options: [],\n        stocks: [\n          {\n            name: \"stockA\",\n            price: { nominal: 5000, real: 4800 },\n            quantity: 2,\n            choices: [],\n          },\n        ],\n      },\n    ],\n    tags: [\"test\"],\n    category_codes: [\"cat-a\"],\n    status: null,\n  };\n  const sale1 = await api.functional.shoppings.sellers.sales.post(connection, { body: saleInput1 });\n\n  const saleInput2: IShoppingSaleICreate = {\n    section_code: \"section-foo\",\n    opened_at: new Date().toISOString(),\n    closed_at: null,\n    content: {\n      title: \"Test Sale B\",\n      format: \"md\",\n      body: \"Description B\",\n      files: [],\n      thumbnails: [],\n    },\n    units: [\n      {\n        name: \"unitB\",\n        primary: true,\n        required: true,\n        options: [],\n        stocks: [\n          {\n            name: \"stockB\",\n            price: { nominal: 7000, real: 6500 },\n            quantity: 2,\n            choices: [],\n          },\n        ],\n      },\n    ],\n    tags: [\"test\"],\n    category_codes: [\"cat-a\"],\n    status: null,\n  };\n  const sale2 = await api.functional.shoppings.sellers.sales.post(connection, { body: saleInput2 });\n\n  // Step 2: 목록 조회 기본 (limit=10)\n  const req: IShoppingSaleIRequest = {};\n  const page = await api.functional.shoppings.admins.sales.patch(connection, { body: req });\n  typia.assert<IPageIShoppingSale.ISummary>(page);\n  TestValidator.predicate(\"at least 2 items existed\")(() => page.data.length >= 2);\n\n  // Step 3: limit=1 페이징\n  {\n    const req1: IShoppingSaleIRequest = { limit: 1 };\n    const page1 = await api.functional.shoppings.admins.sales.patch(connection, { body: req1 });\n    typia.assert<IPageIShoppingSale.ISummary>(page1);\n    TestValidator.equals(\"limit=1 count\")(1)(page1.data.length);\n    TestValidator.equals(\"pagination reflects limit\")(1)(page1.pagination.limit);\n  }\n  // page=2 정상 동작 체크\n  {\n    const req2: IShoppingSaleIRequest = { limit: 1, page: 2 };\n    const page2 = await api.functional.shoppings.admins.sales.patch(connection, { body: req2 });\n    typia.assert<IPageIShoppingSale.ISummary>(page2);\n    TestValidator.equals(\"limit=1 page=2 count\")(1)(page2.data.length);\n    TestValidator.equals(\"pagination current page\")(2)(page2.pagination.current);\n  }\n\n  // Step 4: 데이터 없을 때 빈 배열과 페이지네이션\n  {\n    // 임의로 별도 connection 없이, 요청만 빈 DB 상황 가정\n    // 실 환경에서는 별도의 테스트 DB 초기화 및 분리 필요\n    // 여기서는 신규 req with high page value로 보장\n    const reqEmpty: IShoppingSaleIRequest = { page: 99, limit: 10 };\n    const emptyPage = await api.functional.shoppings.admins.sales.patch(connection, { body: reqEmpty });\n    typia.assert<IPageIShoppingSale.ISummary>(emptyPage);\n    TestValidator.equals(\"empty array when out page\")([] as IShoppingSale.ISummary[])(emptyPage.data);\n  }\n}\n",
  "test/features/api/sale/test_get_admins_sales_by_id_and_not_found.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport { IShoppingSale } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSale\";\nimport { IShoppingSale_ICreate } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSale.ICreate\";\n\nexport async function test_get_admins_sales_by_id_and_not_found(connection: api.IConnection): Promise<void> {\n    // 1. 판매 데이터 생성 (Seller 권한)\n    const createInput: IShoppingSale_ICreate = {\n        section_code: \"default-section\",\n        opened_at: new Date().toISOString(),\n        closed_at: null,\n        content: {\n            title: \"테스트 상품\",\n            format: \"md\",\n            body: \"테스트용 상품 설명입니다.\",\n            files: [],\n            thumbnails: [],\n        },\n        units: [\n            {\n                name: \"기본 단위\",\n                primary: true,\n                required: true,\n                options: [],\n                stocks: [\n                    {\n                        name: \"기본 재고\",\n                        price: { nominal: 10000, real: 9000 },\n                        quantity: 5,\n                        choices: [],\n                    },\n                ],\n            },\n        ],\n        tags: [\"e2e-test\"],\n        category_codes: [\"default-category\"],\n        status: null,\n    };\n    const sale: IShoppingSale = await api.functional.shoppings.sellers.sales.post(connection, createInput);\n    typia.assert<IShoppingSale>(sale);\n    // 2. 관리자로 상세 조회\n    const fetched = await api.functional.shoppings.admins.sales.get(connection, sale.id);\n    typia.assert<IShoppingSale>(fetched);\n    TestValidator.equals(\"판매 id 일치\")(sale.id)(fetched.id);\n    // 3. 없는 id로 404 오류 체크\n    const notExistId = \"00000000-0000-4000-8000-000000000000\";\n    await TestValidator.httpError(\"존재하지 않는 판매 id 404\")(404)(async () => {\n        await api.functional.shoppings.admins.sales.get(connection, notExistId);\n    });\n}\n",
  "test/features/api/shopping/test_post_admins_sales_questions_comments_create_and_error_cases.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport { IShoppingSale } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSale\";\nimport { IShoppingSaleInquiryComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment\";\nimport { IShoppingSaleInquiryComment as ICreateComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment\";\n\nexport async function test_post_admins_sales_questions_comments_create_and_error_cases(connection: api.IConnection): Promise<void> {\n    // 1. 판매 상품 데이터 준비\n    const saleInput = {\n        section_code: \"SECTION-CODE\",\n        opened_at: new Date().toISOString(),\n        closed_at: null,\n        content: {\n            title: \"테스트 상품\",\n            format: \"md\",\n            body: \"설명 작성\",\n            files: [],\n            thumbnails: [],\n        },\n        units: [\n          {\n            options: [],\n            stocks: [\n              {\n                name: \"기본 재고\",\n                price: { nominal: 10000, real: 9000 },\n                quantity: 10,\n                choices: []\n              },\n            ],\n            name: \"유닛1\",\n            primary: true,\n            required: true,\n          },\n        ],\n        tags: [\"태그\"],\n        category_codes: [\"CAT-CODE\"],\n    };\n    const sale: IShoppingSale = await api.functional.shoppings.sellers.sales.post(connection, { body: saleInput });\n    typia.assert<IShoppingSale>(sale);\n    // 임시 inquiryId 설정 (실제 테스트 환경에서는 문의 사전 생성이 필요)\n    const fakeInquiryId = \"00000000-0000-0000-0000-000000000001\";\n    // 2. 정상 댓글 생성\n    const createInput: ICreateComment.ICreate = {\n        format: \"md\",\n        body: \"관리자 댓글 내용\",\n        files: [],\n    };\n    const comment = await api.functional.shoppings.admins.sales.questions.comments.post(\n        connection,\n        sale.id,\n        fakeInquiryId,\n        { body: createInput }\n    );\n    typia.assert<IShoppingSaleInquiryComment>(comment);\n    TestValidator.predicate(\"댓글 생성된 내용 매칭\")(() => comment.snapshots[0].body === createInput.body);\n    TestValidator.predicate(\"댓글 형식 매칭\")(() => comment.snapshots[0].format === createInput.format);\n    TestValidator.equals(\"첨부파일 확인\")([] as any[])(comment.snapshots[0].files);\n    // 3. 오류 케이스 - 존재하지 않는 saleId\n    await TestValidator.httpError(\"존재하지 않는 saleId\", 404)(\n        () => api.functional.shoppings.admins.sales.questions.comments.post(\n            connection,\n            \"11111111-1111-1111-1111-111111111111\",\n            fakeInquiryId,\n            { body: createInput }\n        )\n    );\n    // 4. 오류 케이스 - 존재하지 않는 inquiryId\n    await TestValidator.httpError(\"존재하지 않는 inquiryId\", 404)(\n        () => api.functional.shoppings.admins.sales.questions.comments.post(\n            connection,\n            sale.id,\n            \"11111111-1111-1111-1111-111111111111\",\n            { body: createInput }\n        )\n    );\n    // 5. 필수값 누락 (body)\n    await TestValidator.httpError(\"body 누락시 오류\", 400)(\n        () => api.functional.shoppings.admins.sales.questions.comments.post(\n            connection,\n            sale.id,\n            fakeInquiryId,\n            { body: { format: \"md\", files: [] } as any }\n        )\n    );\n    // 6. 필수값 누락 (format)\n    await TestValidator.httpError(\"format 누락시 오류\", 400)(\n        () => api.functional.shoppings.admins.sales.questions.comments.post(\n            connection,\n            sale.id,\n            fakeInquiryId,\n            { body: { body: \"aa\", files: [] } as any }\n        )\n    );\n    // 7. 필수값 누락 (files)\n    await TestValidator.httpError(\"files 누락시 오류\", 400)(\n        () => api.functional.shoppings.admins.sales.questions.comments.post(\n            connection,\n            sale.id,\n            fakeInquiryId,\n            { body: { body: \"aa\", format: \"md\" } as any }\n        )\n    );\n}\n",
  "test/features/api/shopping/test_patch_admins_sales_questions_comments_list_and_empty_case.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingSaleInquiryComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment\";\nimport { IShoppingSaleInquiryComment as InquiryCommentNS } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment\";\nimport { IPageIShoppingSaleInquiryComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIShoppingSaleInquiryComment\";\nimport typia from \"typia\";\n\nexport async function test_patch_admins_sales_questions_comments_list_and_empty_case(connection: api.IConnection): Promise<void> {\n    // 준비: 임의의 saleId 및 inquiryId\n    const saleId = \"11111111-1111-4111-8111-111111111111\";\n    const inquiryId = \"22222222-2222-4222-8222-222222222222\";\n    \n    // 1. 댓글 없는 상태에서 호출 -> 빈 배열 반환 검증\n    {\n        const req: InquiryCommentNS.IRequest = {\n            search: null,\n            sort: null,\n            page: 0,\n            limit: 10,\n        };\n        const res = await api.functional.shoppings.admins.sales.questions.comments.patch\n            (connection, saleId, inquiryId, req);\n        typia.assert<IPageIShoppingSaleInquiryComment>(res);\n        TestValidator.equals(\"empty comments array\")(res.data)([] as IShoppingSaleInquiryComment[]);\n    }\n\n    // 2. 댓글 2개 생성\n    const commentInputs: InquiryCommentNS.ICreate[] = [\n        {\n            format: \"md\",\n            body: \"첫번째 댓글\",\n            files: []\n        },\n        {\n            format: \"txt\",\n            body: \"두번째 댓글입니다.\",\n            files: [\n                {\n                    name: \"img\",\n                    extension: \"jpg\",\n                    url: \"https://example.com/image.jpg\"\n                }\n            ]\n        }\n    ];\n    const expected: IShoppingSaleInquiryComment[] = [];\n    for (const input of commentInputs) {\n        const created = await api.functional.shoppings.admins.sales.questions.comments.post(\n            connection, saleId, inquiryId, input\n        );\n        typia.assert<IShoppingSaleInquiryComment>(created);\n        expected.push(created);\n    }\n\n    // 3. 다시 목록 조회, 방금 생성한 댓글들이 모두 조회되는지 확인\n    {\n        const req: InquiryCommentNS.IRequest = {\n            search: null,\n            sort: null,\n            page: 0,\n            limit: 10,\n        };\n        const res = await api.functional.shoppings.admins.sales.questions.comments.patch(\n            connection, saleId, inquiryId, req\n        );\n        typia.assert<IPageIShoppingSaleInquiryComment>(res);\n        TestValidator.equals(\"all comments count\")(res.data.length)(expected.length);\n        // 각 댓글의 ID로 비교 검증\n        for (const comment of expected) {\n            const found = res.data.find((c) => c.id === comment.id);\n            TestValidator.predicate(`comment ${comment.id} in response`)(!!found);\n        }\n    }\n\n    // 4. 댓글이 없는 inquiryId로 조회, 빈 배열 확인\n    {\n        const emptyInquiryId = \"33333333-3333-4333-8333-333333333333\";\n        const req: InquiryCommentNS.IRequest = {\n            search: null,\n            sort: null,\n            page: 0,\n            limit: 10,\n        };\n        const res = await api.functional.shoppings.admins.sales.questions.comments.patch(\n            connection, saleId, emptyInquiryId, req\n        );\n        typia.assert<IPageIShoppingSaleInquiryComment>(res);\n        TestValidator.equals(\"empty for different inquiry\")(res.data)([] as IShoppingSaleInquiryComment[]);\n    }\n}\n",
  "test/features/api/shopping/test_get_admins_sale_question_comment_info_valid_and_invalid_id.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingSaleInquiryComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment\";\nimport { IShoppingSaleInquiryComment as IShoppingSaleInquiryComment_NS } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment\";\nimport typia from \"typia\";\n\nexport async function test_api_get_admins_sale_question_comment_info_valid_and_invalid_id(\n  connection: api.IConnection,\n  saleId: string,\n  inquiryId: string\n): Promise<void> {\n  // 1. 테스트용 코멘트 생성\n  const input: IShoppingSaleInquiryComment_NS.ICreate = {\n    format: \"txt\",\n    body: \"Test inquiry comment\",\n    files: [\n      {\n        name: \"example\",\n        extension: \"txt\",\n        url: \"https://example.com/test.txt\",\n      },\n    ],\n  };\n  const created = await api.functional.shoppings.admins.sales.questions.comments.post(\n    connection,\n    saleId,\n    inquiryId,\n    input\n  );\n\n  // 2. 정상적으로 코멘트 조회\n  const found = await api.functional.shoppings.admins.sales.questions.comments.get(\n    connection,\n    saleId,\n    inquiryId,\n    created.id\n  );\n  typia.assert<IShoppingSaleInquiryComment>(found);\n  TestValidator.equals(\"코멘트 ID 일치\")<string>(created.id)(found.id);\n  TestValidator.equals(\"코멘트 스냅샷 length\")<number>(1)(found.snapshots.length);\n  TestValidator.equals(\"본문 일치\")<string>(input.body)(found.snapshots[0].body);\n  TestValidator.equals(\"포맷 일치\")<string>(input.format)(found.snapshots[0].format);\n\n  // 3. 존재하지 않는 id로 조회했을 때 404 에러 검증\n  await TestValidator.httpError(\"존재하지 않는 코멘트 ID 조회시 404 에러\")\n    (404)(async () => {\n      await api.functional.shoppings.admins.sales.questions.comments.get(\n        connection,\n        saleId,\n        inquiryId,\n        \"00000000-0000-0000-0000-000000000000\"\n      );\n    });\n}\n",
  "test/features/api/sale/test_update_admins_sale_question_comment_with_various_scenarios.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport { IShoppingSaleInquiryComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment\";\nimport { IShoppingSaleInquiryComment as ICreate } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment.ICreate\";\n\nexport async function test_update_admins_sale_question_comment_with_various_scenarios(connection: api.IConnection, saleId: string, inquiryId: string): Promise<void> {\n  // --- 준비: 코멘트 하나 생성 ---\n  const createInput: ICreate.ICreate = {\n    format: \"md\",\n    body: \"original comment\",\n    files: [\n      {\n        name: \"sample\",\n        extension: \"jpg\",\n        url: \"https://example.com/sample.jpg\",\n      },\n    ],\n  };\n  const created = await api.functional.shoppings.admins.sales.questions.comments.post(\n    connection,\n    saleId,\n    inquiryId,\n    createInput\n  );\n  typia.assert<IShoppingSaleInquiryComment>(created);\n  TestValidator.equals(\"comment body should match\")(createInput.body)(created.snapshots[created.snapshots.length - 1].body);\n\n  // --- (1) 정상적으로 코멘트 수정 ---\n  const updateInput: ICreate.ICreate = {\n    format: \"md\",\n    body: \"updated comment\",\n    files: [\n      {\n        name: \"updated\",\n        extension: \"png\",\n        url: \"https://example.com/updated.png\",\n      },\n    ],\n  };\n  const updated = await api.functional.shoppings.admins.sales.questions.comments.put(\n    connection,\n    saleId,\n    inquiryId,\n    created.id,\n    updateInput\n  );\n  typia.assert<IShoppingSaleInquiryComment.ISnapshot>(updated);\n  TestValidator.equals(\"updated body\")(updateInput.body)(updated.body);\n\n  // --- (2) 존재하지 않는 코멘트 ID로 수정 시 404 ---\n  const nonExistentId = \"00000000-0000-4000-8000-000000000000\";\n  await TestValidator.httpError(\"not found\")(404)(async () => {\n    await api.functional.shoppings.admins.sales.questions.comments.put(\n      connection,\n      saleId,\n      inquiryId,\n      nonExistentId,\n      updateInput\n    );\n  });\n\n  // --- (3) 유효성 실패: body가 비어 있는 경우 ---\n  const invalidInput: ICreate.ICreate = {\n    format: \"md\",\n    body: \"\",\n    files: [\n      {\n        name: \"fail\",\n        extension: \"jpg\",\n        url: \"https://example.com/fail.jpg\",\n      },\n    ],\n  };\n  await TestValidator.httpError(\"bad request\")(400)(async () => {\n    await api.functional.shoppings.admins.sales.questions.comments.put(\n      connection,\n      saleId,\n      inquiryId,\n      created.id,\n      invalidInput\n    );\n  });\n}\n",
  "test/features/api/shopping/test_list_admins_sale_questions_with_filter_and_pagination.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingSaleQuestion } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleQuestion\";\nimport { IPageIShoppingSaleQuestion } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIShoppingSaleQuestion\";\nimport typia from \"typia\";\n\nexport async function test_list_admins_sale_questions_with_filter_and_pagination(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. 정상 플로우를 위한 테스트용 saleId 확보(가정: 사전 등록된 saleId 사용)\n  const validSaleId = \"11111111-1111-1111-1111-111111111111\";\n\n  // 1-1. 기본 호출 (필터 없이)\n  const baseReq = {};\n  const baseResult = await api.functional.shoppings.admins.sales.questions.patch(\n    connection,\n    validSaleId,\n    { body: baseReq },\n  );\n  typia.assert<IPageIShoppingSaleQuestion.ISummary>(baseResult);\n  TestValidator.predicate(\"should have data & pagination\")(\n    baseResult.data !== undefined && baseResult.pagination !== undefined,\n  );\n\n  // 1-2. 답변 여부 필터\n  const answeredReq = { search: { answered: true } };\n  const answeredResult = await api.functional.shoppings.admins.sales.questions.patch(\n    connection,\n    validSaleId,\n    { body: answeredReq },\n  );\n  typia.assert<IPageIShoppingSaleQuestion.ISummary>(answeredResult);\n  if (answeredResult.data.length > 0) {\n    TestValidator.predicate(\"all answered\")(\n      answeredResult.data.every(q => q.answer !== null),\n    );\n  }\n\n  // 1-3. 키워드(제목) 검색\n  const titleKeyword = baseResult.data[0]?.title || \"\";\n  const titleReq = { search: { title: titleKeyword } };\n  const titleResult = await api.functional.shoppings.admins.sales.questions.patch(\n    connection,\n    validSaleId,\n    { body: titleReq },\n  );\n  typia.assert<IPageIShoppingSaleQuestion.ISummary>(titleResult);\n  if (titleKeyword) {\n    TestValidator.predicate(\"title matched\")(\n      titleResult.data.every(q => q.title.includes(titleKeyword)),\n    );\n  }\n\n  // 1-4. 페이징 (첫 페이지, limit 2)\n  const pagingReq = { page: 0, limit: 2 };\n  const pagingResult = await api.functional.shoppings.admins.sales.questions.patch(\n    connection,\n    validSaleId,\n    { body: pagingReq },\n  );\n  typia.assert<IPageIShoppingSaleQuestion.ISummary>(pagingResult);\n  TestValidator.predicate(\"respect limit\")(\n    pagingResult.data.length <= 2,\n  );\n\n  // 1-5. 정렬 (최신순)\n  const sortReq = { sort: [\"-created_at\"] };\n  const sortResult = await api.functional.shoppings.admins.sales.questions.patch(\n    connection,\n    validSaleId,\n    { body: sortReq },\n  );\n  typia.assert<IPageIShoppingSaleQuestion.ISummary>(sortResult);\n  if (sortResult.data.length >= 2) {\n    const t0 = new Date(sortResult.data[0].created_at).getTime();\n    const t1 = new Date(sortResult.data[1].created_at).getTime();\n    TestValidator.predicate(\"sorted by created_at desc\")(t0 >= t1);\n  }\n\n  // 1-6. 빈 결과 반환 (조건 불충족)\n  const noneReq = { search: { title: \"UNLIKELY_KEYWORD_@#$_9999\" } };\n  const noneResult = await api.functional.shoppings.admins.sales.questions.patch(\n    connection,\n    validSaleId,\n    { body: noneReq },\n  );\n  typia.assert<IPageIShoppingSaleQuestion.ISummary>(noneResult);\n  TestValidator.equals(\"should be empty\")([] as IShoppingSaleQuestion.ISummary[])(noneResult.data);\n\n  // 2. 음수 플로우 - 유효하지 않은 saleId (포맷/존재하지 않음)\n  const invalidSaleId = \"00000000-0000-0000-0000-000000000000\";\n  await TestValidator.httpError(\"sale id not found\")(404)(async () => {\n    await api.functional.shoppings.admins.sales.questions.patch(\n      connection,\n      invalidSaleId,\n      { body: {} },\n    );\n  });\n\n  // 비정상 포맷\n  const badSaleId = \"not-a-uuid\";\n  await TestValidator.httpError(\"sale id format invalid\")(400, 404)(async () => {\n    await api.functional.shoppings.admins.sales.questions.patch(\n      connection,\n      badSaleId,\n      { body: {} },\n    );\n  });\n}\n",
  "test/features/api/question/test_list_admins_sale_questions_abridged.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingSaleQuestion } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleQuestion\";\nimport { IPageIShoppingSaleQuestion } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIShoppingSaleQuestion\";\nimport typia from \"typia\";\n\nexport async function test_api_list_admins_sale_questions_abridged(connection: api.IConnection): Promise<void> {\n  // 1. Prepare a valid saleId (for positive test) and non-existent saleId (for negative test)\n  const validSaleId = \"11111111-1111-1111-1111-111111111111\"; // Replace with a real UUID available in the test DB\n  const nonexistentSaleId = \"eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee\";\n  const emptyRequest: IShoppingSaleQuestion.IRequest = {};\n\n  // 2. Call the API for positive case\n  const result = await api.functional.shoppings.admins.sales.questions.abridges.patch(\n    connection,\n    validSaleId,\n    { body: emptyRequest }\n  );\n\n  typia.assert<IPageIShoppingSaleQuestion.IAbridge>(result);\n  TestValidator.predicate(\"data should be an array\")(() => Array.isArray(result.data));\n  result.data.forEach((abridged) => {\n    typia.assert<IShoppingSaleQuestion.IAbridge>(abridged);\n    TestValidator.predicate(\"should contain id\")(() => typeof abridged.id === \"string\");\n    TestValidator.predicate(\"should have secret property\")(() => typeof abridged.secret === \"boolean\");\n    TestValidator.predicate(\"should have answer property\")(() => \"answer\" in abridged);\n    TestValidator.predicate(\"should have body property\")(() => typeof abridged.body === \"string\");\n  });\n\n  // 3. Negative case: saleId not existing\n  const negative = await api.functional.shoppings.admins.sales.questions.abridges.patch(\n    connection,\n    nonexistentSaleId,\n    { body: emptyRequest }\n  );\n  typia.assert<IPageIShoppingSaleQuestion.IAbridge>(negative);\n  TestValidator.equals(\"nonexistent sale should return empty data\")<IShoppingSaleQuestion.IAbridge[]>([])(negative.data);\n}\n",
  "test/features/api/shopping/test_get_admins_sale_question_detail_valid_and_invalid_id.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport { IShoppingSaleQuestion } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleQuestion\";\nimport { v4 as uuid } from \"uuid\";\n\nexport async function test_get_admins_sale_question_detail_valid_and_invalid_id(connection: api.IConnection): Promise<void> {\n    // 1. 테스트용 문의글 생성 (사전조건: saleId 필요)\n    // <--- 실제 테스트 환경에 맞는 saleId와 문의글 생성 API 호출 필요.>\n    // 아래는 saleId를 얻는 부분과 문의글 생성이 실제 정의되어야 함.\n    // 예시로 saleId를 임의로 지정(실제 환경에서는 적합하지 않음)\n    const saleId = uuid(); // 실제 saleId가 필요하다면 적절히 대체\n    const questionInput = {  /* 문의글 생성 DTO 타입에 맞게 데이터 생성 필요 */ };\n    // 문의글 등록 API가 내부 구현에서 제공되어야 정상 동작함\n    // const created = await api.functional.shoppings.admins.sales.questions.post(connection, saleId, { body: questionInput });\n    // typia.assert<IShoppingSaleQuestion>(created);\n\n    // 위에서 정상생성 후 created.id와 saleId로 상세 조회\n    // const result = await api.functional.shoppings.admins.sales.questions.get(connection, saleId, created.id);\n    // typia.assert<IShoppingSaleQuestion>(result);\n\n    // 2. 존재하지 않는 ID로 요청\n    await TestValidator.httpError(\"존재하지 않는 문의글 id로 404 오류 여부 확인\")(404)(async () => {\n        await api.functional.shoppings.admins.sales.questions.get(connection, saleId, uuid());\n    });\n}\n",
  "test/features/api/shopping/test_create_admins_review_comment_valid_invalid_cases.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingSaleInquiryComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment\";\nimport { IShoppingSaleInquiryComment as ICreate } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment.ICreate\";\nimport typia from \"typia\";\n\nexport async function test_create_admins_review_comment_valid_invalid_cases(\n  connection: api.IConnection\n): Promise<void> {\n  // 1. 관리자용 판매 데이터 사전 생성\n  const sale = await api.functional.shoppings.admins.sales.post(\n    connection,\n    {\n      // 최소 필수값으로 판매 데이터 생성 (예시)\n      // 아래 값은 실제 DTO에 맞게 작성해야 함\n      // 예: { title: \"Test Sale\", ... }\n      title: \"Test Sale\",\n      description: \"Sale for inquiry comment test\",\n      price: 1000,\n      // ... 기타 필수 필드\n    } as any // 실제 필드는 실제 DTO로 교체 필요\n  );\n  \n  // 2. 리뷰/문의 데이터 생성(판매에 소속)\n  const inquiry = await api.functional.shoppings.admins.sales.reviews.post(\n    connection,\n    sale.id,\n    {\n      // 리뷰/문의 생성을 위한 최소 데이터\n      // 예: { title: \"Test Inquiry\", body: \"This is a test inquiry.\" }\n      title: \"Test Inquiry\",\n      body: \"문의 또는 리뷰 본문 내용\",\n      // 기타 필수값\n    } as any // 실제 필드는 실제 DTO로 교체 필요\n  );\n\n  // 3-a. 유효한 입력: 정상 생성 요청\n  const validInput: ICreate.ICreate = {\n    format: \"txt\",\n    body: \"코멘트 본문입니다.\",\n    files: [\n      {\n        name: \"example\",\n        extension: \"txt\",\n        url: \"http://localhost/files/example.txt\",\n      },\n    ],\n  };\n  const comment = await api.functional.shoppings.admins.sales.reviews.comments.post(\n    connection,\n    sale.id,\n    inquiry.id,\n    validInput\n  );\n  typia.assert<IShoppingSaleInquiryComment>(comment);\n  TestValidator.equals(\"정상 코멘트 생성 및 값 일치\")<IShoppingSaleInquiryComment>(comment)(comment); // 본문, 파일 목록 등 값 검증\n\n  // 4. 존재하지 않는 saleId/inquiryId: 에러 발생\n  await TestValidator.httpError(\"존재하지 않는 saleId, 404 에러 예상\")(404)(async () => {\n    await api.functional.shoppings.admins.sales.reviews.comments.post(\n      connection,\n      \"00000000-0000-0000-0000-000000000000\", // 없음\n      inquiry.id,\n      validInput\n    );\n  });\n  await TestValidator.httpError(\"존재하지 않는 inquiryId, 404 에러 예상\")(404)(async () => {\n    await api.functional.shoppings.admins.sales.reviews.comments.post(\n      connection,\n      sale.id,\n      \"00000000-0000-0000-0000-000000000000\",\n      validInput\n    );\n  });\n\n  // 5. 바디 등 유효성 에러\n  const invalidInput1: ICreate.ICreate = {\n    format: \"txt\",\n    body: \"\", // 비어있음\n    files: [],\n  };\n  await TestValidator.httpError(\"본문 비어있을 때 400 에러\")(400)(async () => {\n    await api.functional.shoppings.admins.sales.reviews.comments.post(\n      connection,\n      sale.id,\n      inquiry.id,\n      invalidInput1\n    );\n  });\n  const invalidInput2: any = {\n    // body 없음\n    format: \"txt\",\n    files: [],\n  };\n  await TestValidator.httpError(\"본문 미포함시 400 에러\")(400)(async () => {\n    await api.functional.shoppings.admins.sales.reviews.comments.post(\n      connection,\n      sale.id,\n      inquiry.id,\n      invalidInput2\n    );\n  });\n}\n",
  "test/features/api/shopping-sale-inquiry-comment/test_list_admins_review_comments_with_valid_invalid_inquiry_id.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingSaleInquiryComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment\";\nimport { IShoppingSaleInquiryComment as IShoppingSaleInquiryCommentDTO } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment\";\nimport { IShoppingSaleInquiryComment as IShoppingSaleInquiryCommentNS } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment\";\nimport { IAttachmentFile } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAttachmentFile\";\nimport { IPage } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPage\";\nimport typia from \"typia\";\n\nexport async function test_api_list_admins_review_comments_with_valid_invalid_inquiry_id(\n    connection: api.IConnection\n): Promise<void> {\n    // 1. 테스트용 sale/inquiry 정보 및 코멘트 다수 생성\n    const saleId = \"11111111-1111-1111-1111-111111111111\";\n    const inquiryId = \"22222222-2222-2222-2222-222222222222\";\n\n    const createBody: IShoppingSaleInquiryCommentNS.ICreate = {\n        format: \"txt\",\n        body: \"테스트 코멘트입니다.\",\n        files: [\n            {\n                name: \"testfile1\",\n                extension: \"txt\",\n                url: \"https://fileserver.test/testfile1.txt\"\n            }\n        ]\n    };\n\n    // 코멘트 2개 생성\n    const comment1 = await api.functional.shoppings.admins.sales.reviews.comments.post(\n        connection, saleId, inquiryId, createBody\n    );\n    const comment2 = await api.functional.shoppings.admins.sales.reviews.comments.post(\n        connection, saleId, inquiryId, createBody\n    );\n\n    typia.assert<IShoppingSaleInquiryComment>(comment1);\n    typia.assert<IShoppingSaleInquiryComment>(comment2);\n\n    // 2. 정상적으로 코멘트 목록 조회\n    const req: IShoppingSaleInquiryCommentNS.IRequest = {};\n    const listRes = await api.functional.shoppings.admins.sales.reviews.comments.patch(\n        connection, saleId, inquiryId, req\n    );\n    typia.assert<IPage<IShoppingSaleInquiryComment>>(listRes);\n    TestValidator.predicate(\"data가 최소 2개 이상의 코멘트를 포함함\")(\n        () => listRes.data.length >= 2\n    );\n\n    // 데이터 내용 확인\n    listRes.data.forEach(comment => {\n        typia.assert<IShoppingSaleInquiryComment>(comment);\n    });\n\n    // 3. 유효하지 않은 inquiryId 사용 시 에러 발생 여부 확인\n    const invalidInquiryId = \"not-a-uuid\";\n    await TestValidator.httpError(\"형식 잘못된 inquiryId 에러\")\n        (400, 422, 404)(async () =>\n        await api.functional.shoppings.admins.sales.reviews.comments.patch(\n            connection,\n            saleId,\n            invalidInquiryId,\n            req,\n        )\n    );\n\n    // 4. 존재하지 않는 inquiryId (UUID지만 실제 존재하지 않음)\n    const notFoundInquiryId = \"ffffffff-ffff-ffff-ffff-ffffffffffff\";\n    await TestValidator.httpError(\"존재하지 않는 inquiryId 에러\")\n        (404)(async () =>\n        await api.functional.shoppings.admins.sales.reviews.comments.patch(\n            connection,\n            saleId,\n            notFoundInquiryId,\n            req,\n        )\n    );\n\n    // 5. 빈 inquiryId 전달\n    await TestValidator.httpError(\"빈 inquiryId 전달시 에러\")\n        (400, 404)(async () =>\n        await api.functional.shoppings.admins.sales.reviews.comments.patch(\n            connection,\n            saleId,\n            \"\",\n            req,\n        )\n    );\n}\n",
  "test/features/api/shopping/test_get_admins_review_comment_detail_valid_and_invalid_id.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingSaleInquiryComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment\";\nimport { IShoppingSaleInquiryComment as IComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment\";\nimport { IShoppingSaleInquiryComment as IShoppingSaleInquiryCommentType } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment\";\nimport { IShoppingSaleInquiryComment as IShoppingSaleInquiryCommentType2 } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment\";\nimport { IShoppingSaleInquiryComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment\";\nimport { IShoppingSaleInquiryComment as IShoppingSaleInquiryCommentType3 } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment\";\nimport { IShoppingSaleInquiryComment as ICreateInput } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment.ICreate\";\nimport typia from \"typia\";\n\nexport async function test_api_shopping_get_admins_review_comment_detail_valid_and_invalid_id(\n    connection: api.IConnection\n): Promise<void> {\n    // Prerequisite IDs (should be provided in real tests or via setup)\n    const saleId = \"11111111-1111-4111-8111-111111111111\";\n    const inquiryId = \"22222222-2222-4222-8222-222222222222\";\n\n    // 1. Create new comment\n    const createInput: IShoppingSaleInquiryComment.ICreate = {\n        format: \"md\",\n        body: \"관리자 문의 코멘트 테스트 본문입니다.\",\n        files: [\n            {\n                name: \"testfile\",\n                extension: \"jpg\",\n                url: \"https://cdn.test.com/testfile.jpg\"\n            }\n        ]\n    };\n    const created: IShoppingSaleInquiryComment = await api.functional.shoppings.admins.sales.reviews.comments.post(\n        connection,\n        saleId,\n        inquiryId,\n        createInput\n    );\n    typia.assert<IShoppingSaleInquiryComment>(created);\n    // 2. Fetch by valid id\n    const fetched: IShoppingSaleInquiryComment = await api.functional.shoppings.admins.sales.reviews.comments.get(\n        connection,\n        saleId,\n        inquiryId,\n        created.id\n    );\n    typia.assert<IShoppingSaleInquiryComment>(fetched);\n    TestValidator.equals(\"comment detail - valid id\")(created)(fetched);\n\n    // 3. Fetch by invalid id\n    const invalidId = \"00000000-0000-4000-8000-000000000000\";\n    await TestValidator.httpError(\"comment detail - invalid id\")(404)(async () => {\n        await api.functional.shoppings.admins.sales.reviews.comments.get(\n            connection,\n            saleId,\n            inquiryId,\n            invalidId\n        );\n    });\n}\n",
  "test/features/api/shopping/test_update_admins_review_comment_with_various_conditions.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport { IShoppingSaleInquiryComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment\";\nimport { IShoppingSaleInquiryComment as InquiryComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment\";\n\nexport async function test_update_admins_review_comment_with_various_conditions(connection: api.IConnection): Promise<void> {\n    // 1. 사전 데이터 : 코멘트 생성\n    const saleId = \"00000000-0000-4000-8000-000000000111\";\n    const inquiryId = \"00000000-0000-4000-8000-000000000222\";\n    const createInput: InquiryComment.ICreate = {\n        format: \"md\",\n        body: \"초기 댓글 내용\",\n        files: [\n            { name: \"sample\", extension: \"txt\", url: \"https://file.test/sample.txt\" }\n        ],\n    };\n    const comment = await api.functional.shoppings.admins.sales.reviews.comments.post(\n        connection,\n        saleId,\n        inquiryId,\n        createInput\n    );\n    typia.assert<IShoppingSaleInquiryComment>(comment);\n    TestValidator.equals(\"초기 댓글 내용 체크\")(createInput.body)(comment.snapshots[0].body);\n\n    // 2. 정상적인 코멘트 수정\n    const updateInput: InquiryComment.ICreate = {\n        format: \"md\",\n        body: \"수정된 댓글 내용\",\n        files: [\n            { name: \"update\", extension: \"txt\", url: \"https://file.test/update.txt\" }\n        ],\n    };\n    const updated = await api.functional.shoppings.admins.sales.reviews.comments.put(\n        connection,\n        saleId,\n        inquiryId,\n        comment.id,\n        updateInput\n    );\n    typia.assert<InquiryComment.ISnapshot>(updated);\n    TestValidator.equals(\"수정 요청 본문 일치\")(updateInput.body)(updated.body);\n    TestValidator.equals(\"수정 요청 파일 url 일치\")(updateInput.files[0].url)(updated.files[0].url);\n    TestValidator.equals(\"수정 요청 format 일치\")(updateInput.format)(updated.format);\n\n    // 3. 존재하지 않는 ID로 PUT 시 404\n    const nonExistCommentId = \"00000000-0000-4000-8000-999999999999\";\n    await TestValidator.httpError(\"존재하지 않는 코멘트 404 테스트\")(404)(async () => {\n        await api.functional.shoppings.admins.sales.reviews.comments.put(\n            connection,\n            saleId,\n            inquiryId,\n            nonExistCommentId,\n            updateInput\n        );\n    });\n\n    // 4. 비정상 입력(빈 body) PUT 시 유효성 에러\n    const invalidInput: InquiryComment.ICreate = {\n        format: \"md\",\n        body: \"\",\n        files: [\n            { name: \"should-fail\", extension: \"txt\", url: \"https://file.test/should-fail.txt\" }\n        ],\n    };\n    await TestValidator.httpError(\"비정상 입력 유효성 에러\")(400, 422)(async () => {\n        await api.functional.shoppings.admins.sales.reviews.comments.put(\n            connection,\n            saleId,\n            inquiryId,\n            comment.id,\n            invalidInput\n        );\n    });\n}\n",
  "test/features/api/shopping-sale-review/test_list_admins_sales_reviews_with_filters_and_pagination.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingSaleReview } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleReview\";\nimport { IPageIShoppingSaleReview } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIShoppingSaleReview\";\nimport typia from \"typia\";\n\nexport async function test_list_admins_sales_reviews_with_filters_and_pagination(\n  connection: api.IConnection,\n  saleId: string,\n): Promise<void> {\n  // 1. 기본 요청 (기본 페이지네이션 및 전체 조회)\n  const basicRequest: IShoppingSaleReview.IRequest = {};\n  const basicRes = await api.functional.shoppings.admins.sales.reviews.patch(\n    connection,\n    saleId,\n    basicRequest,\n  );\n  typia.assert<IPageIShoppingSaleReview.ISummary>(basicRes);\n  TestValidator.predicate(\"basic pageination\")(\n    basicRes.pagination.current >= 0 && basicRes.pagination.limit > 0,\n  );\n\n  // 2. 1페이지 2개 제한\n  const limitRequest: IShoppingSaleReview.IRequest = { limit: 2, page: 0 };\n  const limitedRes = await api.functional.shoppings.admins.sales.reviews.patch(\n    connection,\n    saleId,\n    limitRequest,\n  );\n  typia.assert<IPageIShoppingSaleReview.ISummary>(limitedRes);\n  TestValidator.equals(\"limit equals\")(\n    limitRequest.limit,\n  )(limitedRes.pagination.limit);\n  TestValidator.equals(\"page equals\")(\n    limitRequest.page,\n  )(limitedRes.pagination.current);\n\n  // 3. 정렬 최신순 (created_at desc) 및 오래된순(sort asc)\n  const sortDescRequest: IShoppingSaleReview.IRequest = {\n    sort: [\"-created_at\"],\n  };\n  const sortDescRes = await api.functional.shoppings.admins.sales.reviews.patch(\n    connection,\n    saleId,\n    sortDescRequest,\n  );\n  typia.assert<IPageIShoppingSaleReview.ISummary>(sortDescRes);\n  const dataDesc = sortDescRes.data;\n  if (dataDesc.length >= 2) {\n    TestValidator.predicate(\"desc by created_at\")(\n      new Date(dataDesc[0].created_at).getTime() >=\n        new Date(dataDesc[1].created_at).getTime(),\n    );\n  }\n\n  const sortAscRequest: IShoppingSaleReview.IRequest = {\n    sort: [\"+created_at\"],\n  };\n  const sortAscRes = await api.functional.shoppings.admins.sales.reviews.patch(\n    connection,\n    saleId,\n    sortAscRequest,\n  );\n  typia.assert<IPageIShoppingSaleReview.ISummary>(sortAscRes);\n  const dataAsc = sortAscRes.data;\n  if (dataAsc.length >= 2) {\n    TestValidator.predicate(\"asc by created_at\")(\n      new Date(dataAsc[0].created_at).getTime() <=\n        new Date(dataAsc[1].created_at).getTime(),\n    );\n  }\n\n  // 4. 필터: title 키워드 포함 (존재할 경우만)\n  const filterTitleRequest: IShoppingSaleReview.IRequest = {\n    search: { title: \"Test\" },\n  };\n  const filterTitleRes = await api.functional.shoppings.admins.sales.reviews.patch(\n    connection,\n    saleId,\n    filterTitleRequest,\n  );\n  typia.assert<IPageIShoppingSaleReview.ISummary>(filterTitleRes);\n  if (filterTitleRes.data.length > 0) {\n    filterTitleRes.data.forEach((i) =>\n      TestValidator.predicate(\"filtered title contains\")(\n        i.title.includes(\"Test\"),\n      ),\n    );\n  }\n\n  // 5. 필터: 100점만 (score)\n  const filterScoreRequest: IShoppingSaleReview.IRequest = {\n    search: { minimum: 100, maximum: 100 },\n  };\n  const filterScoreRes = await api.functional.shoppings.admins.sales.reviews.patch(\n    connection,\n    saleId,\n    filterScoreRequest,\n  );\n  typia.assert<IPageIShoppingSaleReview.ISummary>(filterScoreRes);\n  if (filterScoreRes.data.length > 0) {\n    filterScoreRes.data.forEach((i) =>\n      TestValidator.equals(\"score only 100\")(100)(i.score),\n    );\n  }\n\n  // 6. 데이터 없음(존재하지 않는 조건)\n  const emptyRequest: IShoppingSaleReview.IRequest = {\n    search: { title: \"__NO_EXIST__\" },\n  };\n  const emptyRes = await api.functional.shoppings.admins.sales.reviews.patch(\n    connection,\n    saleId,\n    emptyRequest,\n  );\n  typia.assert<IPageIShoppingSaleReview.ISummary>(emptyRes);\n  TestValidator.equals(\"empty page\")(0)(emptyRes.data.length);\n\n  // 7. 없는 saleId로 404 반환 여부\n  const randomSaleId = \"11111111-1111-4111-8111-111111111111\";\n  await TestValidator.httpError(\"not found 404\")(404)(async () =>\n    api.functional.shoppings.admins.sales.reviews.patch(\n      connection,\n      randomSaleId,\n      {},\n    ),\n  );\n}\n",
  "test/features/api/shopping-sale-review/test_list_admins_sales_reviews_abridged.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IPageIShoppingSaleReview } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIShoppingSaleReview\";\nimport typia from \"typia\";\n\nexport async function test_list_admins_sales_reviews_abridged(connection: api.IConnection, saleId: string): Promise<void> {\n  // 테스트용 요청 본문 생성 (기본: 검색/정렬 없이, 첫 페이지, 10개 제한)\n  const requestBody = {\n    search: null,\n    sort: null,\n    page: 0,\n    limit: 10\n  };\n\n  // PATCH 요청: abridged 리뷰 목록 조회\n  const page = await api.functional.shoppings.admins.sales.reviews.abridges.patch(connection, saleId, { body: requestBody });\n\n  // 반환 타입 검증\n  typia.assert<IPageIShoppingSaleReview.IAbridge>(page);\n\n  // 필수 필드 개별 검증\n  TestValidator.predicate(\"pagination field must exist\")(() => !!page.pagination);\n  TestValidator.predicate(\"data field must be array\")(() => Array.isArray(page.data));\n\n  // pagination과 data 배열의 길이 검증\n  TestValidator.equals(\"records == data.length or data is paginated\")(\n    page.pagination.records >= 0\n  )(page.data.length <= requestBody.limit);\n\n  // 각 리뷰가 abridged 구조의 필수 필드를 갖는지 확인\n  for (const review of page.data) {\n    TestValidator.predicate(\"review.id exists\")(() => typeof review.id === \"string\" && review.id.length > 0);\n    TestValidator.predicate(\"review.title exists\")(() => typeof review.title === \"string\" && review.title.length > 0);\n    TestValidator.predicate(\"review.score is number\")(() => typeof review.score === \"number\");\n    TestValidator.predicate(\"review.created_at exists\")(() => typeof review.created_at === \"string\");\n    TestValidator.predicate(\"review.updated_at exists\")(() => typeof review.updated_at === \"string\");\n    TestValidator.predicate(\"customer.id exists\")(() => typeof review.customer.id === \"string\");\n  }\n}\n",
  "test/features/api/review/test_get_admins_review_detail_valid_and_invalid_id.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingSaleReview } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleReview\";\nimport typia from \"typia\";\n\nexport async function test_get_admins_review_detail_valid_and_invalid_id(connection: api.IConnection): Promise<void> {\n    // 1. 미리 리뷰 데이터 생성\n    const saleId = \"00000000-0000-4000-8000-000000000001\";\n    const reviewInput = {\n        // 실제 DTO 명세가 더 필요하겠으나 우선 임의값 포함\n        // 반드시 실제 테스트에서는 실제 POST DTO와 타입 맞게 수정필요\n        // 여기는 예시\n        snapshots: [{\n            score: 90,\n            id: \"00000000-0000-4000-9000-000000000002\",\n            created_at: new Date().toISOString(),\n            format: \"md\",\n            title: \"review title\",\n            body: \"good review\",\n            files: [],\n        }],\n    };\n    // 임의로 POST 함수 존재 가정, 실제 테스트엔 정확한 타입/경로 확인\n    const created = await api.functional.shoppings.admins.sales.reviews.post(connection, saleId, reviewInput);\n\n    typia.assert<IShoppingSaleReview>(created);\n    const reviewId = created.id;\n\n    // 2. 정상 상세 조회\n    const detail = await api.functional.shoppings.admins.sales.reviews.get(connection, saleId, reviewId);\n    typia.assert<IShoppingSaleReview>(detail);\n    TestValidator.equals(\"review id\")(created.id)(detail.id);\n    TestValidator.equals(\"snapshots length\")((created.snapshots || []).length)((detail.snapshots || []).length);\n\n    // 3. 비정상 (존재하지 않는 ID)\n    const notFoundSaleId = \"99999999-9999-4999-8999-999999999999\";\n    const notFoundReviewId = \"99999999-9999-4999-8999-999999999999\";\n    await TestValidator.httpError(\"Not found error\")(404)(() =>\n        api.functional.shoppings.admins.sales.reviews.get(connection, notFoundSaleId, notFoundReviewId),\n    );\n}\n",
  "test/features/api/sale/test_list_admins_sale_snapshots_with_filters_and_pagination.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport { IPage } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPage\";\nimport { IShoppingSaleSnapshot } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleSnapshot\";\n\nexport async function test_api_list_admins_sale_snapshots_with_filters_and_pagination(connection: api.IConnection): Promise<void> {\n  // 1. 가정된 saleId (테스트 환경에서 유효한 UUID를 입력해야 함)\n  const saleId = \"11111111-1111-1111-1111-111111111111\"; // 일반적으로 테스트 sale 데이터 사용\n\n  // 2. 정상 - 기본 페이지네이션 (page:1, limit:5)\n  const req1 = { page: 1, limit: 5 };\n  const res1 = await api.functional.shoppings.admins.sales.snapshots.patch(connection, saleId, req1);\n  typia.assert<IPage<IShoppingSaleSnapshot.ISummary>>(res1);\n  TestValidator.predicate(\"pagination must be valid\")(() => res1.pagination.current === 1 && res1.pagination.limit === 5);\n  if (res1.data.length > 0) {\n    res1.data.forEach((snap) => typia.assert<IShoppingSaleSnapshot.ISummary>(snap));\n  }\n\n  // 3. 페이지네이션: 두 번째 페이지 요청\n  const req2 = { page: 2, limit: 2 };\n  const res2 = await api.functional.shoppings.admins.sales.snapshots.patch(connection, saleId, req2);\n  typia.assert<IPage<IShoppingSaleSnapshot.ISummary>>(res2);\n  TestValidator.predicate(\"pagination - page 2\")(() => res2.pagination.current === 2 && res2.pagination.limit === 2);\n\n  // 4. 경계값: 지나치게 큰 page 번호 요청 (존재 X)\n  const req3 = { page: 999, limit: 2 };\n  const res3 = await api.functional.shoppings.admins.sales.snapshots.patch(connection, saleId, req3);\n  typia.assert<IPage<IShoppingSaleSnapshot.ISummary>>(res3);\n  TestValidator.equals(\"empty result for high page\")([] as IShoppingSaleSnapshot.ISummary[])(res3.data);\n\n  // 5. 존재하지 않는 saleId 시도 (에러 혹은 빈 데이터)\n  const notFoundId = \"22222222-2222-2222-2222-222222222222\";\n  const req4 = { page: 1, limit: 5 };\n  await TestValidator.error(\"not found saleId should error or return empty\")(() => api.functional.shoppings.admins.sales.snapshots.patch(connection, notFoundId, req4));\n}\n",
  "test/features/api/shopping/test_get_admins_sale_snapshot_detail_valid_and_invalid_id.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport { IShoppingSaleSnapshot } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleSnapshot\";\n\nexport async function test_get_admins_sale_snapshot_detail_valid_and_invalid_id(connection: api.IConnection): Promise<void> {\n    // 1. (의존) 테스트용 sale 및 스냅샷 생성\n    // 이 예시에서는 saleId, snapshotId를 가정합니다. 실제 테스트에서는 helper나 사전조건에서 확보한 값을 사용하세요.\n    const saleId = \"11111111-1111-4111-8111-111111111111\";\n\n    // 스냅샷 생성 (의존)\n    // 실제로는 POST /shoppings/admins/sales/{saleId}/snapshots를 이용하여 스냅샷 생성 필요\n    // 아래는 생성 후 id를 얻는 로직 예시\n    const createdSnapshot = await api.functional.shoppings.admins.sales.snapshots.post(connection, saleId, {\n        // 필수 입력값만 예시로 작성 (실제 DTO에 맞게 조정)\n        title: \"Test Snapshot\",\n        content: {\n            id: \"22222222-2222-4222-8222-222222222222\",\n            title: \"Test Content\",\n            format: \"md\",\n            body: \"This is a test content.\",\n            files: [],\n            thumbnails: []\n        },\n        categories: [],\n        tags: [\"tag1\", \"tag2\"],\n        units: [\n            {\n                options: [],\n                stocks: [\n                    {\n                        id: \"33333333-3333-4333-8333-333333333333\",\n                        name: \"Stock 1\",\n                        price: { nominal: 1000, real: 900 },\n                        inventory: { income: 10, outcome: 2 },\n                        choices: []\n                    }\n                ],\n                id: \"44444444-4444-4444-8444-444444444444\",\n                name: \"Unit 1\",\n                primary: true,\n                required: true\n            }\n        ]\n    });\n    const snapshotId = createdSnapshot.id;\n\n    // 2. 정상적인 ID로 상세 조회\n    const detail = await api.functional.shoppings.admins.sales.snapshots.get(connection, saleId, snapshotId);\n    typia.assert<IShoppingSaleSnapshot>(detail);\n    TestValidator.equals(\"snapshotId match\")(snapshotId)(detail.id);\n\n    // 3. 존재하지 않는 ID 테스트 (형식만 올바른 임의 UUID)\n    const invalidId = \"12345678-1234-4123-8123-123456789012\";\n    await TestValidator.httpError(\"should fail with 404\")(404)(() =>\n        api.functional.shoppings.admins.sales.snapshots.get(connection, saleId, invalidId)\n    );\n}\n",
  "test/features/api/shopping-sale-snapshot/test_get_admins_snapshot_flip_valid_and_invalid_id.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingSale } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSale\";\nimport typia from \"typia\";\n\nexport async function test_api_get_admins_snapshot_flip_valid_and_invalid_id(connection: api.IConnection): Promise<void> {\n  // 1. 사전 데이터 준비: sale 및 snapshot 생성\n  // (이 API 목록에서 sale 생성/스냅샷 생성이 명시적이지 않으므로 API 제공 명세에 맞는 호출을 가정)\n  // 아래와 같이 스냅샷 생성 API가 있다고 가정하고 작성\n  const saleId = \"9b735772-5f73-4da2-8bcd-2c53e5c0e226\";\n\n  // 스냅샷을 생성한다: /shoppings/admins/sales/{saleId}/snapshots (사전 의존성에서 명시)\n  // 실제 API 함수명: api.functional.shoppings.admins.sales.snapshots.post\n  const snapshot = await api.functional.shoppings.admins.sales.snapshots.post(\n    connection,\n    saleId,\n    { body: {} }, // 실제 생성에 필요한 파라미터는 구조에 맞춰 채워야 함\n  );\n  typia.assert(snapshot);\n\n  // 2. 정상 케이스: 올바른 saleId와 snapshot.id로 flip 정보 조회\n  const flip = await api.functional.shoppings.admins.sales.snapshots.flip.get(\n    connection,\n    saleId,\n    snapshot.id,\n  );\n  typia.assert<IShoppingSale>(flip);\n  TestValidator.equals(\"saleId 정합성\")<string>(saleId)(flip.id);\n  TestValidator.equals(\"snapshot id 정합성\")<string>(snapshot.id)(flip.snapshot_id);\n\n  // 3. 비정상 케이스: 존재하지 않는 snapshotId에 대해 404에러 검사\n  const invalidSnapshotId = \"00000000-0000-0000-0000-000000000001\";\n  await TestValidator.httpError(\"존재하지 않는 snapshotId는 404\")(404)(\n    () => api.functional.shoppings.admins.sales.snapshots.flip.get(\n      connection,\n      saleId,\n      invalidSnapshotId,\n    )\n  );\n\n  // 4. 비정상 케이스: 존재하지 않는 saleId에 대해 404에러 검사\n  const invalidSaleId = \"00000000-0000-0000-0000-000000000002\";\n  await TestValidator.httpError(\"존재하지 않는 saleId는 404\")(404)(\n    () => api.functional.shoppings.admins.sales.snapshots.flip.get(\n      connection,\n      invalidSaleId,\n      snapshot.id,\n    )\n  );\n}\n",
  "test/features/api/category/test_create_admins_category_with_valid_and_invalid_data.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingChannel } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingChannel\";\nimport { IShoppingChannelCategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingChannelCategory\";\nimport { IShoppingChannelCategory as ICategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingChannelCategory\";\nimport { IShoppingChannelCategory as ICategoryNS } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingChannelCategory\";\nimport { IShoppingChannel as IChannelNS } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingChannel\";\nimport typia from \"typia\";\n\nexport async function test_create_admins_category_with_valid_and_invalid_data(connection: api.IConnection): Promise<void> {\n    // 1. 채널 생성 (테스트용 고유 코드/이름)\n    const channelInput: IChannelNS.ICreate = {\n        code: `test-channel-${Date.now()}`,\n        name: `Test Channel ${Date.now()}`,\n    };\n    const channel: IShoppingChannel = await api.functional.shoppings.admins.systematic.channels.post(connection, channelInput);\n    typia.assert(channel);\n    TestValidator.equals(\"channel.code\")(channelInput.code)(channel.code);\n    TestValidator.equals(\"channel.name\")(channelInput.name)(channel.name);\n\n    // 2. 루트 카테고리 생성\n    const rootCategoryInput: ICategoryNS.ICreate = {\n        parent_id: null,\n        code: `root-category-${Date.now()}`,\n        name: `Root Category ${Date.now()}`,\n    };\n    const rootCategory: IShoppingChannelCategory = await api.functional.shoppings.admins.systematic.channels.categories.post(\n        connection,\n        channel.code,\n        rootCategoryInput,\n    );\n    typia.assert(rootCategory);\n    TestValidator.equals(\"카테고리 코드\")(rootCategoryInput.code)(rootCategory.code);\n    TestValidator.equals(\"카테고리 이름\")(rootCategoryInput.name)(rootCategory.name);\n    TestValidator.equals(\"parent_id null\")(rootCategoryInput.parent_id)(rootCategory.parent_id);\n\n    // 3. 동일 이름/코드 중복 생성 시 에러\n    await TestValidator.error(\"중복 코드와 이름으로 카테고리 생성\")(() =>\n        api.functional.shoppings.admins.systematic.channels.categories.post(\n            connection,\n            channel.code,\n            rootCategoryInput\n        )\n    );\n\n    // 4. 부모 카테고리 지정하여 서브 카테고리 생성\n    const childCategoryInput: ICategoryNS.ICreate = {\n        parent_id: rootCategory.id,\n        code: `child-category-${Date.now()}`,\n        name: `Child Category ${Date.now()}`,\n    };\n    const childCategory: IShoppingChannelCategory = await api.functional.shoppings.admins.systematic.channels.categories.post(\n        connection,\n        channel.code,\n        childCategoryInput,\n    );\n    typia.assert(childCategory);\n    TestValidator.equals(\"parent 지정\")(childCategoryInput.parent_id)(childCategory.parent_id);\n    TestValidator.equals(\"코드\")(childCategoryInput.code)(childCategory.code);\n    TestValidator.equals(\"이름\")(childCategoryInput.name)(childCategory.name);\n\n    // 5-1. 누락(parent_id) : null과 undefined 구분\n    const categoryMissingParent: Partial<ICategoryNS.ICreate> = {\n        // parent_id intentionally omitted\n        code: `miss-parent-${Date.now()}`,\n        name: `MissParent Category ${Date.now()}`,\n    };\n    await TestValidator.error(\"parent_id 누락시 에러\")(() =>\n        api.functional.shoppings.admins.systematic.channels.categories.post(\n            connection,\n            channel.code,\n            categoryMissingParent as ICategoryNS.ICreate\n        )\n    );\n\n    // 5-2. 누락(code)\n    const categoryMissingCode: Partial<ICategoryNS.ICreate> = {\n        parent_id: null,\n        // code omitted\n        name: `MissCode Category ${Date.now()}`,\n    };\n    await TestValidator.error(\"code 누락시 에러\")(() =>\n        api.functional.shoppings.admins.systematic.channels.categories.post(\n            connection,\n            channel.code,\n            categoryMissingCode as ICategoryNS.ICreate\n        )\n    );\n\n    // 5-3. 누락(name)\n    const categoryMissingName: Partial<ICategoryNS.ICreate> = {\n        parent_id: null,\n        code: `miss-name-${Date.now()}`,\n        // name omitted\n    };\n    await TestValidator.error(\"name 누락시 에러\")(() =>\n        api.functional.shoppings.admins.systematic.channels.categories.post(\n            connection,\n            channel.code,\n            categoryMissingName as ICategoryNS.ICreate\n        )\n    );\n}\n",
  "test/features/api/category/test_list_admins_channel_categories_with_children_and_filters.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingChannel } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingChannel\";\nimport { IShoppingChannelCategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingChannelCategory\";\nimport { IShoppingChannelCategory as ICat } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingChannelCategory\";\nimport typia from \"typia\";\n\nexport async function test_list_admins_channel_categories_with_children_and_filters(connection: api.IConnection): Promise<void> {\n    // 1. 테스트용 채널 생성\n    const channelInput = {\n        code: `channel-${Date.now()}`,\n        name: `테스트채널명-${Date.now()}`,\n    };\n    const channel: IShoppingChannel = await api.functional.shoppings.admins.systematic.channels.post(connection, { body: channelInput });\n    typia.assert<IShoppingChannel>(channel);\n    // 2. 계층적 카테고리 3개 이상 생성: 상위+자식\n    const parentCatInput = { parent_id: null, code: `cat-parent-${Date.now()}`, name: `상위카테고리A-${Date.now()}` };\n    const parentCat: ICat = await api.functional.shoppings.admins.systematic.channels.categories.post(connection, channel.code, { body: parentCatInput });\n    typia.assert<ICat>(parentCat);\n    // 하위 카테고리 (부모: parentCat)\n    const childCat1Input = { parent_id: parentCat.id, code: `cat-child1-${Date.now()}`, name: `하위카테고리A1-${Date.now()}` };\n    const childCat1: ICat = await api.functional.shoppings.admins.systematic.channels.categories.post(connection, channel.code, { body: childCat1Input });\n    typia.assert<ICat>(childCat1);\n    const childCat2Input = { parent_id: parentCat.id, code: `cat-child2-${Date.now()}`, name: `하위카테고리A2-${Date.now()}` };\n    const childCat2: ICat = await api.functional.shoppings.admins.systematic.channels.categories.post(connection, channel.code, { body: childCat2Input });\n    typia.assert<ICat>(childCat2);\n    // 계층관계가 없는 또다른 카테고리\n    const parentBInput = { parent_id: null, code: `cat-parentB-${Date.now()}`, name: `상위카테고리B-${Date.now()}` };\n    const parentCatB: ICat = await api.functional.shoppings.admins.systematic.channels.categories.post(connection, channel.code, { body: parentBInput });\n    typia.assert<ICat>(parentCatB);\n\n    // 3. PATCH 계층 구조 전체 리스트 조회\n    const categories: IShoppingChannelCategory.IHierarchical[] = await api.functional.shoppings.admins.systematic.channels.categories.patch(connection, channel.code);\n    typia.assert<IShoppingChannelCategory.IHierarchical[]>(categories);\n\n    // 4. 계층 구조 검증 (parentCat이 루트로, 그 아래에 childCat1, childCat2 존재)\n    const findParentA = categories.find((c) => c.id === parentCat.id);\n    TestValidator.predicate(\"상위카테고리A 존재 여부\")(() => !!findParentA);\n    TestValidator.equals(\"상위카테고리A 자식 노드 수 일치\")<IShoppingChannelCategory.IHierarchical[]>([childCat1, childCat2].map(cc => ({\n        ...cc,\n        children: ([] as IShoppingChannelCategory.IHierarchical[]),\n    })))(findParentA ? findParentA.children : []);\n    // 독립 parentB도 계층 노드로 존재하는지 체크\n    const findParentB = categories.find((c) => c.id === parentCatB.id);\n    TestValidator.predicate(\"상위카테고리B 존재 여부\")(() => !!findParentB);\n    TestValidator.equals(\"상위카테고리B는 children없음\")<IShoppingChannelCategory.IHierarchical[]>([])(findParentB ? findParentB.children : []);\n\n    // 5. 필터/정렬 옵션 테스트(예: name에서 'A1' 포함되는 것만 조회)\n    // 필터 및 정렬 옵션 위한 Request interface 정의 필요 (OpenAPI에 부재 시 skip)\n    // 예시는, 실제 IShoppingChannelCategory.IRequest.search 구조 필요. 없어서 skip\n    // 향후 구조 확인되면, 아래와 같이\n    // const filtered = await api.functional.shoppings.admins.systematic.channels.categories.patch(connection, channel.code, { body: { search: { name: \"A1\" } }});\n\n    // 6. 존재하지 않는 채널 코드 에러 검증\n    await TestValidator.httpError(\"없는 채널코드 계층조회 404 반환\")(404)(async () => {\n        await api.functional.shoppings.admins.systematic.channels.categories.patch(connection, \"non-exist-code-\" + Date.now());\n    });\n}\n",
  "test/features/api/category/test_get_admins_category_detail_valid_and_invalid_id.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport { IShoppingChannelCategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingChannelCategory\";\nimport { IShoppingChannelCategory as ICreate } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingChannelCategory.ICreate\";\n\nexport async function test_get_admins_category_detail_valid_and_invalid_id(connection: api.IConnection): Promise<void> {\n    // 1. 준비: 테스트용 채널코드\n    const channelCode = \"test-channel\";\n    // 2. 사전 카테고리 생성\n    const input: ICreate.ICreate = {\n        parent_id: null,\n        code: `test-category-${Math.random().toString(36).substring(2, 10)}`,\n        name: `테스트카테고리-${Math.random().toString(36).substring(2, 10)}`\n    };\n    const created = await api.functional.shoppings.admins.systematic.channels.categories.post(\n        connection, channelCode, { body: input }\n    );\n    typia.assert<IShoppingChannelCategory>(created);\n\n    // 3. 정상: 생성한 ID로 상세 조회\n    const detail = await api.functional.shoppings.admins.systematic.channels.categories.get(\n        connection, channelCode, created.id\n    );\n    typia.assert<IShoppingChannelCategory>(detail);\n    TestValidator.equals(\"id\")(created.id)(detail.id);\n    TestValidator.equals(\"code\")(created.code)(detail.code);\n    TestValidator.equals(\"name\")(created.name)(detail.name);\n    TestValidator.equals(\"parent_id\")(created.parent_id)(detail.parent_id);\n\n    // 4. 비정상: 존재하지 않는 ID 조회 (UUID)\n    const dummyUUID = \"00000000-0000-4000-8000-000000000404\";\n    await TestValidator.httpError(\"Not Found\")(404)(async () =>\n        api.functional.shoppings.admins.systematic.channels.categories.get(\n            connection, channelCode, dummyUUID)\n    );\n}\n",
  "test/features/api/category/test_update_admins_category_with_valid_and_invalid_data.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingChannelCategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingChannelCategory\";\nimport typia from \"typia\";\n\nimport { v4 as uuidv4 } from \"uuid\";\n\nexport async function test_api_update_admins_category_with_valid_and_invalid_data(connection: api.IConnection): Promise<void> {\n    // 1. Prepare test channel and initial category\n    const channelCode = \"test-channel\";\n    const initialCategoryInput: IShoppingChannelCategory.ICreate = {\n        parent_id: null,\n        code: `cat-${Date.now()}`,\n        name: \"Initial Category\"\n    };\n    const createdCategory = await api.functional.shoppings.admins.systematic.channels.categories.post(\n        connection,\n        channelCode,\n        initialCategoryInput\n    );\n    typia.assert<IShoppingChannelCategory>(createdCategory);\n\n    // 2. Positive: Update name and parent_id\n    const updateCategoryInput: IShoppingChannelCategory.ICreate = {\n        parent_id: null,\n        code: createdCategory.code,\n        name: \"Updated Category Name\"\n    };\n    const updateResult = await api.functional.shoppings.admins.systematic.channels.categories.put(\n        connection,\n        channelCode,\n        createdCategory.id,\n        updateCategoryInput\n    );\n    // Response is void/null; update should succeed without error\n\n    // 3. Negative: Not Found (random UUID)\n    await TestValidator.httpError(\"not found 404\")(404)(async () => {\n        await api.functional.shoppings.admins.systematic.channels.categories.put(\n            connection,\n            channelCode,\n            uuidv4(),\n            updateCategoryInput\n        );\n    });\n\n    // 4. Negative: Invalid Empty Name\n    const invalidNameInput: IShoppingChannelCategory.ICreate = {\n        parent_id: null,\n        code: createdCategory.code,\n        name: \"\"\n    };\n    await TestValidator.httpError(\"empty name validation\")(400)(async () => {\n        await api.functional.shoppings.admins.systematic.channels.categories.put(\n            connection,\n            channelCode,\n            createdCategory.id,\n            invalidNameInput\n        );\n    });\n\n    // 5. Negative: Missing Required Field 'name'\n    const missingNameInput = {\n        parent_id: null,\n        code: createdCategory.code\n        // name missing\n    } as any;\n    await TestValidator.httpError(\"missing name validation\")(400)(async () => {\n        await api.functional.shoppings.admins.systematic.channels.categories.put(\n            connection,\n            channelCode,\n            createdCategory.id,\n            missingNameInput\n        );\n    });\n}\n",
  "test/features/api/category/test_merge_admins_channel_categories_normal_and_invalid_case.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport { IShoppingChannelCategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingChannelCategory\";\nimport { IRecordMerge } from \"@ORGANIZATION/PROJECT-api/lib/structures/IRecordMerge\";\n\nexport async function test_merge_admins_channel_categories_normal_and_invalid_case(connection: api.IConnection): Promise<void> {\n    // Step 1: Prepare channel code and unique category data\n    const channelCode = \"channel-1\";\n    const catCode1 = `cat1-${Date.now()}`;\n    const catCode2 = `cat2-${Date.now()}`;\n    const catName1 = \"카테고리1\";\n    const catName2 = \"카테고리2\";\n\n    // Step 2: Create two categories\n    const input1: IShoppingChannelCategory.ICreate = {\n        parent_id: null,\n        code: catCode1,\n        name: catName1,\n    };\n    const result1 = await api.functional.shoppings.admins.systematic.channels.categories.post(\n        connection,\n        channelCode,\n        input1,\n    );\n    typia.assert<IShoppingChannelCategory>(result1);\n    TestValidator.equals(\"category1 name\")(catName1)(result1.name);\n\n    const input2: IShoppingChannelCategory.ICreate = {\n        parent_id: null,\n        code: catCode2,\n        name: catName2,\n    };\n    const result2 = await api.functional.shoppings.admins.systematic.channels.categories.post(\n        connection,\n        channelCode,\n        input2,\n    );\n    typia.assert<IShoppingChannelCategory>(result2);\n    TestValidator.equals(\"category2 name\")(catName2)(result2.name);\n\n    // Step 3: Merge cat2 into cat1 (cat1 keep, cat2 absorbed)\n    const mergeInput: IRecordMerge = {\n        keep: result1.id,\n        absorbed: [result2.id],\n    };\n    await api.functional.shoppings.admins.systematic.channels.categories.merge(\n        connection,\n        channelCode,\n        mergeInput,\n    );\n\n    // (Optional additional validation would require a categories-listing/at API)\n\n    // Step 4: Negative test - try to merge with invalid absorbed id\n    const invalidMerge: IRecordMerge = {\n        keep: result1.id,\n        absorbed: [\"00000000-0000-0000-0000-000000000000\"],\n    };\n    await TestValidator.httpError(\"invalid absorbed id\")(404)(async () => {\n        await api.functional.shoppings.admins.systematic.channels.categories.merge(\n            connection,\n            channelCode,\n            invalidMerge,\n        );\n    });\n\n    // Step 5: Negative test - try to merge with no absorbed ids\n    const emptyAbsorbed: IRecordMerge = {\n        keep: result1.id,\n        absorbed: [],\n    };\n    await TestValidator.httpError(\"no absorbed ids\")(400, 422)(async () => {\n        await api.functional.shoppings.admins.systematic.channels.categories.merge(\n            connection,\n            channelCode,\n            emptyAbsorbed,\n        );\n    });\n}\n",
  "test/features/api/category/test_get_admins_category_invert_info_and_invalid_id.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingChannelCategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingChannelCategory\";\nimport typia from \"typia\";\n\nexport async function test_get_admins_category_invert_info_and_invalid_id(\n  connection: api.IConnection\n): Promise<void> {\n  const channelCode = \"test-channel\";\n  // 1. 신규 카테고리 생성\n  const categoryInput: IShoppingChannelCategory.ICreate = {\n    parent_id: null,\n    code: `ctg-invert-test-${Date.now()}`,\n    name: `Invert Test Category ${Date.now()}`,\n  };\n  const created = await api.functional.shoppings.admins.systematic.channels.categories.post(\n    connection,\n    channelCode,\n    { body: categoryInput }\n  );\n  typia.assert<IShoppingChannelCategory>(created);\n\n  // 2. 인버트(invert) API 호출로 정보 조회 및 결과 검증\n  const invert = await api.functional.shoppings.admins.systematic.channels.categories.getInvert(\n    connection,\n    channelCode,\n    created.id\n  );\n  typia.assert<IShoppingChannelCategory.IInvert>(invert);\n  TestValidator.equals(\"id\")(created.id)(invert.id);\n  TestValidator.equals(\"code\")(created.code)(invert.code);\n  TestValidator.equals(\"name\")(created.name)(invert.name);\n  TestValidator.equals(\"parent_id\")(created.parent_id)(invert.parent_id);\n\n  // 3. 존재하지 않는 ID로 조회 시 에러 발생 확인\n  const randomUUID = \"00000000-0000-4000-8000-000000000001\";\n  await TestValidator.httpError(\"not found\")(404)(async () => {\n    await api.functional.shoppings.admins.systematic.channels.categories.getInvert(\n      connection,\n      channelCode,\n      randomUUID\n    );\n  });\n}\n",
  "test/features/api/channel/test_create_admins_channel_with_valid_and_duplicate_code_name.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport { IShoppingChannel } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingChannel\";\nimport { IShoppingChannel as IShoppingChannelNS } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingChannel\";\n\nexport async function test_api_create_admins_channel_with_valid_and_duplicate_code_name(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. 정상 생성 (valid input)\n  const input: IShoppingChannelNS.ICreate = {\n    code: `ch-test-${Date.now()}`,\n    name: `TestChannel-${Math.floor(Math.random() * 10000)}`,\n  };\n  const created: IShoppingChannel = await api.functional.shoppings.admins.systematic.channels.post(\n    connection,\n    input,\n  );\n  typia.assert<IShoppingChannel>(created);\n  TestValidator.equals(\"channel.code\")(input.code)(created.code);\n  TestValidator.equals(\"channel.name\")(input.name)(created.name);\n\n  // 2. 중복 생성 (duplicated code & name)\n  await TestValidator.httpError(\"duplicate channel\")(409, 400)(async () => {\n    await api.functional.shoppings.admins.systematic.channels.post(connection, input);\n  });\n\n  // 3-1. code 누락 (missing code)\n  const missingCode: Omit<IShoppingChannelNS.ICreate, \"code\"> = {\n    name: `TestChannel-${Math.floor(Math.random() * 10000)}`,\n  };\n  await TestValidator.httpError(\"missing code\")(400, 422)(async () => {\n    // @ts-expect-error: code intentionally missing for negative test\n    await api.functional.shoppings.admins.systematic.channels.post(connection, missingCode);\n  });\n\n  // 3-2. name 누락 (missing name)\n  const missingName: Omit<IShoppingChannelNS.ICreate, \"name\"> = {\n    code: `ch-test-missname-${Date.now()}`,\n  };\n  await TestValidator.httpError(\"missing name\")(400, 422)(async () => {\n    // @ts-expect-error: name intentionally missing for negative test\n    await api.functional.shoppings.admins.systematic.channels.post(connection, missingName);\n  });\n}\n",
  "test/features/api/shopping-channel/test_list_admins_channels_with_filters_and_sorting.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingChannel } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingChannel\";\nimport { IPageIShoppingChannel } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIShoppingChannel\";\nimport typia from \"typia\";\n\nexport async function test_api_list_admins_channels_with_filters_and_sorting(connection: api.IConnection): Promise<void> {\n  // 1. 여러 개의 채널 등록\n  const channelsInput: IShoppingChannel.ICreate[] = [\n    { code: \"code-aaa\", name: \"Alpha Channel\" },\n    { code: \"code-bbb\", name: \"Beta Channel\" },\n    { code: \"code-ccc\", name: \"Gamma Channel\" }\n  ];\n  const createdChannels: IShoppingChannel[] = [];\n  for (const input of channelsInput) {\n    const created = await api.functional.shoppings.admins.systematic.channels.post(connection, input);\n    typia.assert<IShoppingChannel>(created);\n    createdChannels.push(created);\n  }\n  // 2. 전체 목록 조회\n  const listResp1 = await api.functional.shoppings.admins.systematic.channels.patch(connection, {});\n  typia.assert<IPageIShoppingChannel>(listResp1);\n  // 등록한 채널 각각이 목록에 모두 포함되어야 한다\n  for (const c of createdChannels) {\n    TestValidator.predicate(`list includes channel ${c.code}`)(() =>\n      listResp1.data.some((item) => item.id === c.id),\n    );\n  }\n  // 3. 검색 기능(code)\n  const searchByCodeReq = {\n    search: { code: createdChannels[0].code, name: null },\n    sort: null,\n    page: null,\n    limit: null,\n  };\n  const listByCode = await api.functional.shoppings.admins.systematic.channels.patch(connection, searchByCodeReq);\n  typia.assert<IPageIShoppingChannel>(listByCode);\n  TestValidator.equals(\"search by code count\")([createdChannels[0]])(listByCode.data);\n  // 4. 검색 기능(name)\n  const searchByNameReq = {\n    search: { code: null, name: createdChannels[1].name },\n    sort: null,\n    page: null,\n    limit: null,\n  };\n  const listByName = await api.functional.shoppings.admins.systematic.channels.patch(connection, searchByNameReq);\n  typia.assert<IPageIShoppingChannel>(listByName);\n  TestValidator.equals(\"search by name count\")([createdChannels[1]])(listByName.data);\n\n  // 5. 정렬 기능 검증 (code, name, created_at)\n  const sortFields = [\"code\", \"name\", \"created_at\"] as const;\n  for (const field of sortFields) {\n    // asc\n    const ascRes = await api.functional.shoppings.admins.systematic.channels.patch(connection, {\n      sort: [`+channel.${field}`], search: null, page: null, limit: null,\n    });\n    typia.assert<IPageIShoppingChannel>(ascRes);\n    const ascValues = ascRes.data.map((c) => c[field]);\n    TestValidator.predicate(`asc sorted ${field}`)(() =>\n      ascValues.every((v, i, arr) => i === 0 || String(v) >= String(arr[i - 1])),\n    );\n    // desc\n    const descRes = await api.functional.shoppings.admins.systematic.channels.patch(connection, {\n      sort: [`-channel.${field}`], search: null, page: null, limit: null,\n    });\n    typia.assert<IPageIShoppingChannel>(descRes);\n    const descValues = descRes.data.map((c) => c[field]);\n    TestValidator.predicate(`desc sorted ${field}`)(() =>\n      descValues.every((v, i, arr) => i === 0 || String(v) <= String(arr[i - 1])),\n    );\n  }\n  // 6. 페이지네이션 테스트\n  const pageReq = { page: 0, limit: 2, search: null, sort: [\"+channel.code\"]};\n  const pageRes = await api.functional.shoppings.admins.systematic.channels.patch(connection, pageReq);\n  typia.assert<IPageIShoppingChannel>(pageRes);\n  TestValidator.predicate(\"pagination result\")(pageRes.data.length <= 2);\n\n  // 7. 검색+페이지 조합\n  const nameLike = createdChannels[2].name;\n  const searchPageReq = { search: { code: null, name: nameLike }, page: 0, limit: 1, sort: null };\n  const searchPageRes = await api.functional.shoppings.admins.systematic.channels.patch(connection, searchPageReq);\n  typia.assert<IPageIShoppingChannel>(searchPageRes);\n  TestValidator.predicate(\"search + pagination results\")(searchPageRes.data.length === 1 && searchPageRes.data[0].id === createdChannels[2].id);\n\n  // 8. 유효하지 않은/존재하지 않는 조건으로 조회 시 비어있는 결과 또는 에러 없이 정상 동작하는지\n  const invalidSearchReq = { search: { code: \"not-exist-xyz\", name: null }, sort: null, page: null, limit: null };\n  const invalidRes = await api.functional.shoppings.admins.systematic.channels.patch(connection, invalidSearchReq);\n  typia.assert<IPageIShoppingChannel>(invalidRes);\n  TestValidator.equals(\"invalid search returns empty\")([] as IShoppingChannel[])(invalidRes.data);\n}\n",
  "test/features/api/channel/test_get_admins_channel_detail_valid_and_invalid_id.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingChannel } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingChannel\";\nimport { IShoppingChannel as IHierarchical, IShoppingChannelCategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingChannel.IHierarchical\";\nimport typia from \"typia\";\n\nexport async function test_get_admins_channel_detail_valid_and_invalid_id(connection: api.IConnection): Promise<void> {\n    // 1. 테스트용 채널 생성\n    const channelInput = {\n        code: `test-${Math.random().toString(36).slice(2, 10)}`,\n        name: `채널-${Math.random().toString(36).slice(2, 10)}`,\n    };\n    const created: IShoppingChannel = await api.functional.shoppings.admins.systematic.channels.post(\n        connection,\n        { body: channelInput }\n    );\n    typia.assert<IShoppingChannel>(created);\n    TestValidator.equals(\"code\")(channelInput.code)(created.code);\n    TestValidator.equals(\"name\")(channelInput.name)(created.name);\n    TestValidator.predicate(\"created id should be uuid\")(() => typeof created.id === \"string\" && created.id.length > 0);\n\n    // 2. 생성된 id로 상세조회\n    const detail = await api.functional.shoppings.admins.systematic.channels.get(\n        connection,\n        created.id\n    );\n    typia.assert<IHierarchical>(detail);\n    TestValidator.predicate(\"categories should be empty\")(\n        () => Array.isArray(detail.categories) && detail.categories.length === 0\n    );\n    TestValidator.equals(\"id match\")(created.id)(detail.id);\n    TestValidator.equals(\"code match\")(created.code)(detail.code);\n    TestValidator.equals(\"name match\")(created.name)(detail.name);\n\n    // 3. 존재하지 않는 id로 조회시 404\n    const fakeId = \"00000000-0000-4000-8000-000000000000\";\n    await TestValidator.httpError(\"not found error\")(404)(() =>\n        api.functional.shoppings.admins.systematic.channels.get(\n            connection,\n            fakeId\n        )\n    );\n}\n",
  "test/features/api/shopping-channel/test_update_admins_channel_with_valid_and_invalid_case.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport { IShoppingChannel } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingChannel\";\nimport { IShoppingChannel as IShoppingChannelNS } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingChannel\";\n\nexport async function test_update_admins_channel_with_valid_and_invalid_case(connection: api.IConnection): Promise<void> {\n  // 1. 채널 등록 - 사전 데이터 생성\n  const createInput: IShoppingChannelNS.ICreate = {\n    code: `test-code-${Date.now()}`,\n    name: \"Original Name\",\n  };\n  const created = await api.functional.shoppings.admins.systematic.channels.post(\n    connection,\n    createInput,\n  );\n  typia.assert<IShoppingChannel>(created);\n\n  // 2. 정상 수정 케이스\n  const updateName = \"Updated Channel Name\";\n  const updateInput: IShoppingChannelNS.IUpdate = {\n    name: updateName,\n  };\n  await api.functional.shoppings.admins.systematic.channels.put(\n    connection,\n    created.id,\n    updateInput,\n  );\n  // 수정 결과를 조회하는 API가 제공되지 않으므로, PUT 성공여부를 예외/에러 없이 통과함을 확인\n\n  // 3. 존재하지 않는 ID로 수정 시도\n  const nonExistentId = \"00000000-0000-4000-8000-000000000000\";\n  await TestValidator.httpError(\"invalid id should return 404\")(404)(\n    () =>\n      api.functional.shoppings.admins.systematic.channels.put(\n        connection,\n        nonExistentId,\n        updateInput,\n      ),\n  );\n\n  // 4. 유효하지 않은 name(빈 문자열)으로 수정 시도\n  const invalidUpdateInput: IShoppingChannelNS.IUpdate = {\n    name: \"\",\n  };\n  await TestValidator.httpError(\"empty name should return 400\")(400)(\n    () =>\n      api.functional.shoppings.admins.systematic.channels.put(\n        connection,\n        created.id,\n        invalidUpdateInput,\n      ),\n  );\n}\n",
  "test/features/api/shopping/test_merge_admins_channels_normal_and_abnormal_case.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingChannel } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingChannel\";\nimport { IRecordMerge } from \"@ORGANIZATION/PROJECT-api/lib/structures/IRecordMerge\";\nimport typia from \"typia\";\n\nexport async function test_api_merge_admins_channels_normal_and_abnormal_case(\n    connection: api.IConnection,\n): Promise<void> {\n    // 1. 준비: 3개의 채널 등록\n    const input1 = { code: \"chan-1\", name: \"Channel One\" };\n    const input2 = { code: \"chan-2\", name: \"Channel Two\" };\n    const input3 = { code: \"chan-3\", name: \"Channel Three\" };\n\n    const ch1 = await api.functional.shoppings.admins.systematic.channels.post(\n        connection, input1,\n    );\n    const ch2 = await api.functional.shoppings.admins.systematic.channels.post(\n        connection, input2,\n    );\n    const ch3 = await api.functional.shoppings.admins.systematic.channels.post(\n        connection, input3,\n    );\n\n    typia.assert<IShoppingChannel>(ch1);\n    typia.assert<IShoppingChannel>(ch2);\n    typia.assert<IShoppingChannel>(ch3);\n\n    // 2. 정상 병합: ch2, ch3 -> ch1\n    const mergeReq: IRecordMerge = {\n        keep: ch1.id,\n        absorbed: [ch2.id, ch3.id],\n    };\n    await api.functional.shoppings.admins.systematic.channels.merge(\n        connection, mergeReq,\n    ); // 결과는 없음(null) => 성공시 에러 없음\n\n    // 3. 비정상 병합: 존재하지 않는 channel을 absorbed에 포함\n    const badMergeReq1: IRecordMerge = {\n        keep: ch1.id,\n        absorbed: [\n            \"00000000-0000-0000-0000-000000000000\", // 존재하지 않는 UUID\n        ],\n    };\n    await TestValidator.httpError(\"merge: invalid absorbed id\")(400)(async () => {\n        await api.functional.shoppings.admins.systematic.channels.merge(connection, badMergeReq1);\n    });\n\n    // 4. 비정상 병합: keep과 absorbed에 중복(id 동일)\n    const badMergeReq2: IRecordMerge = {\n        keep: ch1.id,\n        absorbed: [ch1.id, ch2.id],\n    };\n    await TestValidator.httpError(\"merge: keep included in absorbed\")(400)(async () => {\n        await api.functional.shoppings.admins.systematic.channels.merge(connection, badMergeReq2);\n    });\n\n    // 5. 비정상 병합: absorbed에 중복된 id\n    const badMergeReq3: IRecordMerge = {\n        keep: ch1.id,\n        absorbed: [ch2.id, ch2.id],\n    };\n    await TestValidator.httpError(\"merge: duplicated absorbed\")(400)(async () => {\n        await api.functional.shoppings.admins.systematic.channels.merge(connection, badMergeReq3);\n    });\n}\n",
  "test/features/api/channel/test_list_admins_channels_hierarchical_with_category_tree.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport { IShoppingChannel } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingChannel\";\nimport { IShoppingChannelCategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingChannelCategory\";\nimport { IShoppingChannelCategory as IShoppingChannelCategoryDto } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingChannelCategory\";\nimport { IShoppingChannelCategory as ICategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingChannelCategory\";\nimport { IShoppingChannel } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingChannel\";\nimport { IShoppingChannel as IChannel } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingChannel\";\nimport { IShoppingChannelCategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingChannelCategory\";\nimport { IShoppingChannelCategory as ICategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingChannelCategory\";\nimport { IShoppingChannelCategory as IChannelCategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingChannelCategory\";\nimport { IShoppingChannelCategory as IShoppingChannelCategoryDto } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingChannelCategory\";\nimport { IShoppingChannel as IShoppingChannelDto } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingChannel\";\nimport { IPageIShoppingChannel } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIShoppingChannel.IHierarchical\";\nimport { IShoppingChannelCategory as CategoryDto } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingChannelCategory\";\nimport { IShoppingChannelCategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingChannelCategory\";\n\nexport async function test_list_admins_channels_hierarchical_with_category_tree(connection: api.IConnection): Promise<void> {\n    // 1. 채널 생성\n    const channelInput = { code: `test-channel-${Date.now()}`, name: \"테스트채널\" };\n    const channel = await api.functional.shoppings.admins.systematic.channels.post(connection, { body: channelInput });\n    typia.assert<IShoppingChannel>(channel);\n\n    // 2. 카테고리 계층 생성\n    // 2-1. 루트 카테고리 A\n    const rootAInput = { parent_id: null, code: `food-${Date.now()}`, name: \"Food\" };\n    const rootA = await api.functional.shoppings.admins.systematic.channels.categories.post(connection, channel.code, { body: rootAInput });\n    typia.assert<IShoppingChannelCategory>(rootA);\n    // 2-2. 루트 카테고리 B\n    const rootBInput = { parent_id: null, code: `electronics-${Date.now()}`, name: \"Electronics\" };\n    const rootB = await api.functional.shoppings.admins.systematic.channels.categories.post(connection, channel.code, { body: rootBInput });\n    typia.assert<IShoppingChannelCategory>(rootB);\n    // 2-3. 하위 카테고리 (Food > Meat)\n    const childAInput = { parent_id: rootA.id, code: `meat-${Date.now()}`, name: \"Meat\" };\n    const childA = await api.functional.shoppings.admins.systematic.channels.categories.post(connection, channel.code, { body: childAInput });\n    typia.assert<IShoppingChannelCategory>(childA);\n    // 2-4. Food > Meat > Frozen\n    const subChildAInput = { parent_id: childA.id, code: `frozen-${Date.now()}`, name: \"Frozen\" };\n    const subChildA = await api.functional.shoppings.admins.systematic.channels.categories.post(connection, channel.code, { body: subChildAInput });\n    typia.assert<IShoppingChannelCategory>(subChildA);\n    // 2-5. Electronics > Notebook\n    const childBInput = { parent_id: rootB.id, code: `notebook-${Date.now()}`, name: \"Notebook\" };\n    const childB = await api.functional.shoppings.admins.systematic.channels.categories.post(connection, channel.code, { body: childBInput });\n    typia.assert<IShoppingChannelCategory>(childB);\n\n    // 3. 계층형 채널/카테고리 트리 조회 및 검증\n    const req = { search: null, sort: null, page: null, limit: null };\n    const res = await api.functional.shoppings.admins.systematic.channels.hierarchical.patch(connection, { body: req });\n    typia.assert<IPageIShoppingChannel.IHierarchical>(res);\n    // 위에서 만든 채널과 계층 구조가 정상적으로 포함됐는지 확인\n    const foundTestChannel = res.data.find((c) => c.code === channel.code);\n    TestValidator.predicate(\"채널 존재 여부\")(() => !!foundTestChannel);\n    // Food, Electronics 두 root 카테고리 존재, 자식관계 맞는지 확인\n    const foodCategory = foundTestChannel?.categories.find((cat) => cat.code.startsWith(\"food-\"));\n    const electronicsCategory = foundTestChannel?.categories.find((cat) => cat.code.startsWith(\"electronics-\"));\n    TestValidator.predicate(\"Food 루트카테고리 존재\")(() => !!foodCategory);\n    TestValidator.predicate(\"Electronics 루트카테고리 존재\")(() => !!electronicsCategory);\n    // Food > Meat 구조 체크\n    const meatCategory = foodCategory?.children.find((cat) => cat.code.startsWith(\"meat-\"));\n    TestValidator.predicate(\"Food>Meat 존재\")(() => !!meatCategory);\n    // Food > Meat > Frozen\n    const frozenCategory = meatCategory?.children.find((cat) => cat.code.startsWith(\"frozen-\"));\n    TestValidator.predicate(\"Meat>Frozen 존재\")(() => !!frozenCategory);\n    // Electronics > Notebook\n    const notebookCategory = electronicsCategory?.children.find((cat) => cat.code.startsWith(\"notebook-\"));\n    TestValidator.predicate(\"Electronics>Notebook 존재\")(() => !!notebookCategory);\n\n    // 4. 예외 케이스: 존재하지 않는 parent_id로 추가 시 에러 확인\n    const badCategoryInput = { parent_id: \"00000000-0000-0000-0000-000000000000\", code: \"badnode\", name: \"BadNode\" };\n    await TestValidator.httpError(\"잘못된 parent_id\", 404)(() =>\n        api.functional.shoppings.admins.systematic.channels.categories.post(connection, channel.code, { body: badCategoryInput })\n    );\n}\n",
  "test/features/api/channel/test_get_admins_channel_by_code_valid_and_invalid.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingChannel } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingChannel\";\nimport { IShoppingChannel as IShoppingChannelTypes } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingChannel\";\nimport { IShoppingChannel as IShoppingChannelNamespace } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingChannel\";\nimport typia from \"typia\";\n\nexport async function test_get_admins_channel_by_code_valid_and_invalid(connection: api.IConnection): Promise<void> {\n  // 1. 고유한 테스트 채널 생성\n  const uniqueCode = `test-code-${Date.now()}`;\n  const createInput: IShoppingChannelNamespace.ICreate = {\n    code: uniqueCode,\n    name: `테스트 채널 ${uniqueCode}`\n  };\n\n  const created: IShoppingChannel = await api.functional.shoppings.admins.systematic.channels.post(\n    connection,\n    createInput\n  );\n  typia.assert<IShoppingChannel>(created);\n  TestValidator.equals(\"채널 코드 및 이름 일치\")<IShoppingChannel>(created)({\n    ...created, // 모든 필드 체크 (id, created_at, code, name)\n    code: createInput.code,\n    name: createInput.name,\n  });\n\n  // 2. 해당 code로 채널 상세 조회\n  const hierarchical = await api.functional.shoppings.admins.systematic.channels.get(\n    connection,\n    created.code\n  );\n  typia.assert<IShoppingChannelNamespace.IHierarchical>(hierarchical);\n  TestValidator.equals(\"상세 채널 정보 일치\")<string>(created.id)(hierarchical.id);\n  TestValidator.equals(\"code 일치\")<string>(created.code)(hierarchical.code);\n  TestValidator.equals(\"name 일치\")<string>(created.name)(hierarchical.name);\n  TestValidator.equals(\"categories는 빈 배열이어야 함\")<IShoppingChannelNamespace.IHierarchical[\"categories\"]>([])(hierarchical.categories);\n\n  // 3. 잘못된 code로 조회 시 404 에러 반환 확인\n  const invalidCode = `${created.code}-not-exist`;\n  await TestValidator.httpError(\"존재하지 않는 코드 조회시 404 반환\")(404)(async () => {\n    await api.functional.shoppings.admins.systematic.channels.get(connection, invalidCode);\n  });\n}\n",
  "test/features/api/section/test_create_admins_section_with_valid_and_duplicate_data.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport { IShoppingSection } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSection\";\nimport { ICreate as IShoppingSectionICreate } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSection.ICreate\";\n\nexport async function test_create_admins_section_with_valid_and_duplicate_data(connection: api.IConnection): Promise<void> {\n    // 1. 정상 케이스: valid 입력으로 섹션 생성\n    const input: IShoppingSectionICreate = {\n        code: `test-section-${Date.now()}`,\n        name: \"Test Section\"\n    };\n    const created = await api.functional.shoppings.admins.systematic.sections.post(connection, input);\n    typia.assert<IShoppingSection>(created);\n    TestValidator.equals(\"section code\")(input.code)(created.code);\n    TestValidator.equals(\"section name\")(input.name)(created.name);\n\n    // 2. 중복 케이스: 이미 존재하는 code로 호출\n    await TestValidator.httpError(\"duplicate section code\")(409)(async () => {\n        await api.functional.shoppings.admins.systematic.sections.post(connection, input);\n    });\n\n    // 3. 누락 케이스: code 누락\n    await TestValidator.httpError(\"missing code\")(400)(async () => {\n        await api.functional.shoppings.admins.systematic.sections.post(connection, {\n            // @ts-expect-error\n            name: \"No Code Section\"\n        });\n    });\n\n    // 4. 누락 케이스: name 누락\n    await TestValidator.httpError(\"missing name\")(400)(async () => {\n        await api.functional.shoppings.admins.systematic.sections.post(connection, {\n            // @ts-expect-error\n            code: `missing-name-${Date.now()}`\n        });\n    });\n}",
  "test/features/api/section/test_list_admins_sections_with_search_and_filters.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport { IShoppingSection } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSection\";\nimport { IPageIShoppingSection } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIShoppingSection\";\n\nexport async function test_list_admins_sections_with_search_and_filters(connection: api.IConnection): Promise<void> {\n    // 1. Create multiple sections\n    const sections: IShoppingSection[] = [];\n    const inputs = [\n        { code: \"FRT\", name: \"Fruit Corner\" },\n        { code: \"MEAT\", name: \"Butcher Corner\" },\n        { code: \"DAIRY\", name: \"Dairy Section\" },\n    ];\n    for (const input of inputs) {\n        const created = await api.functional.shoppings.admins.systematic.sections.post(connection, input);\n        typia.assert<IShoppingSection>(created);\n        sections.push(created);\n    }\n\n    // 2. List all sections, no filters\n    const pageAll = await api.functional.shoppings.admins.systematic.sections.patch(connection, {});\n    typia.assert<IPageIShoppingSection>(pageAll);\n    TestValidator.index(\"full section list\")(sections)(pageAll.data);\n\n    // 3. Search by code\n    const codeSearch = await api.functional.shoppings.admins.systematic.sections.patch(connection, { search: { code: \"FRT\", name: null } });\n    typia.assert<IPageIShoppingSection>(codeSearch);\n    TestValidator.equals(\"code search length\")(1)(codeSearch.data.length);\n    TestValidator.equals(\"code search result\")(sections[0])(codeSearch.data[0]);\n\n    // 4. Search by name\n    const nameSearch = await api.functional.shoppings.admins.systematic.sections.patch(connection, { search: { code: null, name: \"Butcher Corner\" } });\n    typia.assert<IPageIShoppingSection>(nameSearch);\n    TestValidator.equals(\"name search length\")(1)(nameSearch.data.length);\n    TestValidator.equals(\"name search result\")(sections[1])(nameSearch.data[0]);\n\n    // 5. Sort by code ascending\n    const sortedAsc = await api.functional.shoppings.admins.systematic.sections.patch(connection, { sort: [\"+section.code\"] });\n    typia.assert<IPageIShoppingSection>(sortedAsc);\n    const expectAsc = [...sections].sort((a, b) => a.code.localeCompare(b.code));\n    TestValidator.index(\"sort code asc\")(expectAsc)(sortedAsc.data);\n\n    // 6. Sort by code descending\n    const sortedDesc = await api.functional.shoppings.admins.systematic.sections.patch(connection, { sort: [\"-section.code\"] });\n    typia.assert<IPageIShoppingSection>(sortedDesc);\n    const expectDesc = [...sections].sort((a, b) => b.code.localeCompare(a.code));\n    TestValidator.index(\"sort code desc\")(expectDesc)(sortedDesc.data);\n\n    // 7. Pagination test (limit 2, first page)\n    const paged = await api.functional.shoppings.admins.systematic.sections.patch(connection, { page: 0, limit: 2 });\n    typia.assert<IPageIShoppingSection>(paged);\n    TestValidator.equals(\"pagination length\")(2)(paged.data.length);\n    TestValidator.equals(\"pagination current\")(0)(paged.pagination.current);\n    TestValidator.equals(\"pagination limit\")(2)(paged.pagination.limit);\n    // The records in paged.data must be found in sections\n    for (const rec of paged.data) {\n        TestValidator.predicate(\"paged section present\")(() => sections.some(s => s.id === rec.id));\n    }\n\n    // 8. Search with no matching result\n    const none = await api.functional.shoppings.admins.systematic.sections.patch(connection, { search: { code: \"NOPE\", name: null } });\n    typia.assert<IPageIShoppingSection>(none);\n    TestValidator.equals(\"empty search result\")(0)(none.data.length);\n}\n",
  "test/features/api/sale/test_update_sale_with_valid_and_invalid_data.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingSale } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSale\";\nimport { IShoppingSaleSnapshot } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleSnapshot\";\nimport { IShoppingSale as IShoppingSaleCreate } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSale.ICreate\";\nimport typia from \"typia\";\n\nexport async function test_update_sale_with_valid_and_invalid_data(connection: api.IConnection): Promise<void> {\n  // 1. 판매 생성 (사전 준비)\n  const createInput: IShoppingSaleCreate.ICreate = {\n    section_code: \"main-section\",\n    opened_at: new Date().toISOString(),\n    closed_at: null,\n    status: null,\n    content: {\n      title: \"초기 판매 상품\",\n      format: \"md\",\n      body: \"상품 설명입니다.\",\n      files: [],\n      thumbnails: [],\n    },\n    units: [\n      {\n        name: \"기본 유닛\",\n        primary: true,\n        required: true,\n        options: [\n          {\n            type: \"select\",\n            name: \"색상\",\n            variable: false,\n            candidates: [ { name: \"블랙\" }, { name: \"화이트\" } ],\n          },\n        ],\n        stocks: [\n          {\n            name: \"블랙 기본형\",\n            price: { nominal: 10000, real: 9000 },\n            quantity: 10,\n            choices: [ { option_index: 0, candidate_index: 0 } ],\n          },\n          {\n            name: \"화이트 기본형\",\n            price: { nominal: 10000, real: 9000 },\n            quantity: 5,\n            choices: [ { option_index: 0, candidate_index: 1 } ],\n          },\n        ],\n      },\n    ],\n    tags: [\"테스트\", \"기본\"],\n    category_codes: [\"cate-1\"],\n  };\n  const created = await api.functional.shoppings.sellers.sales.post(connection, createInput);\n  typia.assert<IShoppingSale>(created);\n\n  // 2. 정상 수정 케이스\n  const updateInput: IShoppingSaleSnapshot.ICreate = {\n    content: {\n      title: \"수정된 판매 상품명\",\n      format: \"md\",\n      body: \"수정된 상품 설명입니다.\",\n      files: [],\n      thumbnails: [],\n    },\n    units: [\n      {\n        name: \"수정 유닛\",\n        primary: true,\n        required: true,\n        options: [\n          {\n            type: \"select\",\n            name: \"색상\",\n            variable: false,\n            candidates: [ { name: \"블랙\" }, { name: \"실버\" } ],\n          },\n        ],\n        stocks: [\n          {\n            name: \"블랙형\",\n            price: { nominal: 12000, real: 10000 },\n            quantity: 7,\n            choices: [ { option_index: 0, candidate_index: 0 } ],\n          },\n          {\n            name: \"실버형\",\n            price: { nominal: 12500, real: 11000 },\n            quantity: 3,\n            choices: [ { option_index: 0, candidate_index: 1 } ],\n          },\n        ],\n      },\n    ],\n    tags: [\"수정\", \"테스트\"],\n    category_codes: [\"cate-2\"],\n  };\n  const updated = await api.functional.shoppings.sellers.sales.put(connection, created.id, updateInput);\n  typia.assert<IShoppingSale>(updated);\n  TestValidator.equals(\"수정 후 판매명\")(\"수정된 판매 상품명\")(updated.content.title);\n  TestValidator.equals(\"수정 후 태그\")([\"수정\", \"테스트\"])(updated.tags);\n\n  // 3. 필수 입력값 누락(예: units 미포함) → 검증 오류 (400)\n  const updateMissingUnits: IShoppingSaleSnapshot.ICreate = {\n    content: updateInput.content,\n    units: [] as IShoppingSaleUnit[],\n    tags: updateInput.tags,\n    category_codes: updateInput.category_codes,\n  };\n  await TestValidator.httpError(\"units 없음-400\")(400)(() =>\n    api.functional.shoppings.sellers.sales.put(connection, created.id, updateMissingUnits)\n  );\n\n  // 4. 음수 가격 입력 → 검증 오류 (400)\n  const updateNegativePrice: IShoppingSaleSnapshot.ICreate = {\n    ...updateInput,\n    units: [\n      {\n        ...updateInput.units[0],\n        stocks: [\n          {\n            ...updateInput.units[0].stocks[0],\n            price: { nominal: -10000, real: 10000 }, // invalid\n            quantity: 2,\n            choices: updateInput.units[0].stocks[0].choices,\n          },\n        ],\n      },\n    ],\n  };\n  await TestValidator.httpError(\"음수 가격-400\")(400)(() =>\n    api.functional.shoppings.sellers.sales.put(connection, created.id, updateNegativePrice)\n  );\n\n  // 5. 유효하지 않은 카테고리\n  const updateInvalidCategory: IShoppingSaleSnapshot.ICreate = {\n    ...updateInput,\n    category_codes: [\"NOT-EXIST-CATEGORY\"]\n  };\n  await TestValidator.httpError(\"잘못된 카테고리-400\")(400)(() =>\n    api.functional.shoppings.sellers.sales.put(connection, created.id, updateInvalidCategory)\n  );\n\n  // 6. 존재하지 않는 판매 ID (404)\n  await TestValidator.httpError(\"존재하지 않는 ID-404\")(404)(() =>\n    api.functional.shoppings.sellers.sales.put(connection, \"00000000-0000-0000-0000-000000000404\", updateInput)\n  );\n\n  // 7. 승인되지 않은 판매자 (403) - connection을 권한 없는 사용자의 것으로 바꿔야함(이전 판매자를 대표하는 connection 필요)\n  // 본 테스트에서는 단순히 connection 불충분 시나리오는 mocking/fixture 필요, 아래 예제는 기본적인 예시\n  const dummyConnection: api.IConnection = { ...connection, headers: { authorization: \"Bearer INVALID\" } };\n  await TestValidator.httpError(\"권한 없음-403\")(403)(() =>\n    api.functional.shoppings.sellers.sales.put(dummyConnection, created.id, updateInput)\n  );\n\n  // 8. 이미 종료된(비활성) 판매 (409 등) : 판매 종료 후 수정 시도 -> 종료 처리 API가 없으므로 closed_at 세팅\n  const closedInput: IShoppingSaleSnapshot.ICreate = {\n    ...updateInput,\n    content: {\n      ...updateInput.content,\n      title: \"종료된 판매\"\n    },\n  };\n  // 비활성(종료)로 간주될 수 있도록 closed_at이 과거\n  await api.functional.shoppings.sellers.sales.put(connection, created.id, {\n    ...updateInput,\n    content: updateInput.content,\n    units: updateInput.units,\n    tags: updateInput.tags,\n    category_codes: updateInput.category_codes,\n  });\n  // 종료 처리 후 수정 요청(409 혹은 403)\n  await TestValidator.httpError(\"종료된 판매 수정-409/403\")(409, 403)(() =>\n    api.functional.shoppings.sellers.sales.put(connection, created.id, updateInput)\n  );\n}\n",
  "test/features/api/sale/test_change_sale_opening_and_closing_time.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport { IShoppingSale } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSale\";\nimport { IShoppingSale_ICreate } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSale.ICreate\";\nimport { IShoppingSale_IUpdateOpeningTime } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSale.IUpdateOpeningTime\";\n\nexport async function test_api_change_sale_opening_and_closing_time(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. 테스트용 판매 데이터 생성\n  const now = new Date();\n  const openAt = new Date(now.getTime() + 3600 * 1000).toISOString(); // 1시간 후\n  const closeAt = new Date(now.getTime() + 7200 * 1000).toISOString(); // 2시간 후\n\n  const createInput: IShoppingSale_ICreate = {\n    section_code: \"test-section\",\n    opened_at: openAt,\n    closed_at: closeAt,\n    status: null,\n    content: {\n      title: \"Test Sale\",\n      format: \"md\",\n      body: \"Test Body\",\n      files: [\n        {\n          name: \"test\",\n          extension: \"jpg\",\n          url: \"https://example.com/test.jpg\",\n        },\n      ],\n      thumbnails: [\n        {\n          name: \"thumb\",\n          extension: \"png\",\n          url: \"https://example.com/thumb.png\",\n        },\n      ],\n    },\n    units: [\n      {\n        name: \"Unit1\",\n        primary: true,\n        required: true,\n        options: [\n          {\n            type: \"select\",\n            name: \"Color\",\n            variable: true,\n            candidates: [\n              {\n                name: \"Red\",\n              },\n              {\n                name: \"Blue\",\n              },\n            ],\n          },\n        ],\n        stocks: [\n          {\n            name: \"Stock1\",\n            price: {\n              nominal: 10000,\n              real: 9000,\n            },\n            quantity: 10,\n            choices: [\n              {\n                option_index: 0,\n                candidate_index: 0,\n              },\n            ],\n          },\n        ],\n      },\n    ],\n    tags: [\"tag1\", \"tag2\"],\n    category_codes: [\"cat1\"],\n  };\n\n  const created = await api.functional.shoppings.sellers.sales.post(\n    connection,\n    createInput,\n  );\n  typia.assert<IShoppingSale>(created);\n\n  // 2. 정상 오픈/클로즈 시간 변경 (미래 시간)\n  const updateInput: IShoppingSale_IUpdateOpeningTime = {\n    opened_at: new Date(now.getTime() + 10800 * 1000).toISOString(), // 3시간 후\n    closed_at: new Date(now.getTime() + 14400 * 1000).toISOString(), // 4시간 후\n  };\n  await api.functional.shoppings.sellers.sales.putOpen(\n    connection,\n    created.id,\n    updateInput,\n  );\n\n  // 변경 후 조회로 값 검증 (조회 API가 있다면 사용 권장, 여기선 created를 직접 갱신 확인 불가. 실제론 조회해서 비교)\n\n  // 3. 예외 케이스: 이미 종료된 경우(클로즈 시간을 과거로)\n  const closedInput: IShoppingSale_IUpdateOpeningTime = {\n    opened_at: openAt,\n    closed_at: new Date(now.getTime() - 3600 * 1000).toISOString(), // 1시간 전(이미 종료)\n  };\n  await TestValidator.httpError(\"closed sale - 409\")(409)(async () =>\n    api.functional.shoppings.sellers.sales.putOpen(\n      connection,\n      created.id,\n      closedInput,\n    ),\n  );\n\n  // 4. 잘못된 시간값(클로즈가 오픈보다 과거)\n  const invalidInput: IShoppingSale_IUpdateOpeningTime = {\n    opened_at: new Date(now.getTime() + 7200 * 1000).toISOString(), // 2시간 후\n    closed_at: new Date(now.getTime() + 3600 * 1000).toISOString(), // 1시간 후\n  };\n  await TestValidator.httpError(\"invalid time - 400\")(400)(async () =>\n    api.functional.shoppings.sellers.sales.putOpen(\n      connection,\n      created.id,\n      invalidInput,\n    ),\n  );\n\n  // 5. 존재하지 않는 ID(404)\n  await TestValidator.httpError(\"not found - 404\")(404)(async () =>\n    api.functional.shoppings.sellers.sales.putOpen(\n      connection,\n      \"00000000-0000-0000-0000-000000000000\",\n      updateInput,\n    ),\n  );\n\n  // 6. (판매자 소유 아님, 별도 connection 필요. here we skip unless 멀티 connection 지원)\n}\n",
  "test/features/api/sale/test_replicate_sale_with_valid_and_invalid_scenarios.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport { IShoppingSale } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSale\";\nimport { IShoppingSale as ICreateSale } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSale.ICreate\";\n\nexport async function test_api_sale_replicate_with_valid_and_invalid_scenarios(connection: api.IConnection): Promise<void> {\n    // 1. 사전 조건: 신규 판매 건 생성\n    const saleInput: ICreateSale.ICreate = {\n        section_code: \"SECTION-001\",\n        status: null,\n        opened_at: new Date().toISOString(),\n        closed_at: null,\n        content: {\n            title: \"테스트 복제용 판매\",\n            format: \"md\",\n            body: \"복제 기능 테스트용 본문 내용.\",\n            files: [\n                {\n                    name: \"manual\",\n                    extension: \"pdf\",\n                    url: \"https://static.test.com/manual.pdf\",\n                },\n            ],\n            thumbnails: [\n                {\n                    name: \"thumb\",\n                    extension: \"png\",\n                    url: \"https://static.test.com/thumb.png\",\n                },\n            ],\n        },\n        units: [\n            {\n                name: \"기본 단위\",\n                primary: true,\n                required: true,\n                options: [\n                    {\n                        type: \"select\",\n                        name: \"색상\",\n                        variable: true,\n                        candidates: [\n                            { name: \"레드\" },\n                            { name: \"블루\" },\n                        ],\n                    },\n                ],\n                stocks: [\n                    {\n                        name: \"레드-재고\",\n                        price: { nominal: 15000, real: 12000 },\n                        quantity: 10,\n                        choices: [\n                            { option_index: 0, candidate_index: 0 },\n                        ],\n                    },\n                    {\n                        name: \"블루-재고\",\n                        price: { nominal: 15000, real: 13000 },\n                        quantity: 8,\n                        choices: [\n                            { option_index: 0, candidate_index: 1 },\n                        ],\n                    },\n                ],\n            },\n        ],\n        tags: [\"테스트\", \"복제\"],\n        category_codes: [\"CATEGORY-001\"],\n    };\n    const sale: IShoppingSale = await api.functional.shoppings.sellers.sales.post(connection, saleInput);\n    typia.assert<IShoppingSale>(sale);\n\n    // 2. 정상 흐름: 복제 요청\n    const replica: ICreateSale.ICreate = await api.functional.shoppings.sellers.sales.replica.post(connection, sale.id);\n    typia.assert<ICreateSale.ICreate>(replica);\n\n    // 주요 필드 동일성 비교 (content, units, tags, category_codes)\n    TestValidator.equals(\"복제된 section_code 동일\")<string>(sale.section.code)(replica.section_code);\n    TestValidator.equals(\"복제된 태그 동일\")<string[]>(sale.tags)(replica.tags);\n    TestValidator.equals(\"복제된 units 구조 기본 확인\")<number>(sale.units.length)(replica.units.length);\n    TestValidator.equals(\"복제된 카테고리 동일 개수\")<number>(sale.categories.length)(replica.category_codes.length);\n\n    // 3. 비정상 흐름: 존재하지 않는 ID 복제 요청\n    await TestValidator.httpError(\"존재하지 않는 판매 ID로 복제시 404 반환\")(404)(async () => {\n        await api.functional.shoppings.sellers.sales.replica.post(connection, \"00000000-0000-4000-8000-000000000999\");\n    });\n\n    // (선택적) 권한 없는 사용자/connection이 있을 경우 401/403 확인 (환경에 맞게 추가)\n}",
  "test/features/api/sale/test_pause_sale_valid_and_invalid_cases.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingSale } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSale\";\nimport { IShoppingSale as IShoppingSaleCreate } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSale.ICreate\";\nimport typia from \"typia\";\n\nexport async function test_pause_sale_valid_and_invalid_cases(connection: api.IConnection): Promise<void> {\n    // 1. 판매 생성\n    const saleInput: IShoppingSaleCreate = {\n        section_code: \"section-code-001\",\n        opened_at: new Date().toISOString(),\n        closed_at: null,\n        content: {\n            title: \"테스트 세일\",\n            format: \"md\",\n            body: \"설명 입니다.\",\n            files: [{ name: \"test\", extension: \"jpg\", url: \"https://test.com/1.jpg\" }],\n            thumbnails: [{ name: \"thumb\", extension: \"png\", url: \"https://test.com/thumb.png\" }]\n        },\n        units: [\n            {\n                name: \"상품단위\",\n                primary: true,\n                required: true,\n                options: [\n                    {\n                        type: \"select\",\n                        name: \"옵션1\",\n                        variable: false,\n                        candidates: [\n                            { name: \"옵션1-1\" }\n                        ]\n                    }\n                ],\n                stocks: [\n                    {\n                        name: \"스톡1\",\n                        price: { nominal: 50000, real: 45000 },\n                        quantity: 100,\n                        choices: [\n                            { option_index: 0, candidate_index: 0 }\n                        ]\n                    }\n                ]\n            }\n        ],\n        tags: [\"태그A\", \"태그B\"],\n        category_codes: [\"cat-code1\"]\n    };\n    const createdSale = await api.functional.shoppings.sellers.sales.post(connection, { body: saleInput });\n    typia.assert<IShoppingSale>(createdSale);\n    const saleId = createdSale.id;\n\n    // 2. 정상적으로 일시중지 요청\n    await api.functional.shoppings.sellers.sales.delete_pause(connection, saleId);\n    // 별도 조회 API가 있다면, 일시중지 상태 등 추가 검증도 가능\n    // 3. 이미 일시중지한 판매 pause 재요청시 에러\n    await TestValidator.httpError(\"pause double\")(409)(() => api.functional.shoppings.sellers.sales.delete_pause(connection, saleId));\n\n    // 4. 존재하지 않는 판매ID\n    await TestValidator.httpError(\"pause not found\")(404)(() => api.functional.shoppings.sellers.sales.delete_pause(connection, \"00000000-0000-0000-0000-000000000000\"));\n\n    // 5. 타인 소유 판매에 대해 pause 요청 (타인 connection 필요)\n    // 단순히 같은 saleId에 대해 다른 연결로 시도 (새로운 connection으로 가정)\n    const otherConnection: api.IConnection = { ...connection, accessToken: \"other-token\" };\n    await TestValidator.httpError(\"pause not owner\")(403, 401)(() => api.functional.shoppings.sellers.sales.delete_pause(otherConnection, saleId));\n}\n",
  "test/features/api/sale/test_suspend_sale_various_edge_cases.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport { IShoppingSale } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSale\";\nimport { IShoppingSale as IShoppingSaleCreate } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSale.ICreate\";\n\nexport async function test_suspend_sale_various_edge_cases(connection: api.IConnection): Promise<void> {\n  // 1. 정상 판매 생성\n  const saleInput: IShoppingSaleCreate = {\n    section_code: \"section-001\",\n    opened_at: new Date().toISOString(),\n    closed_at: null,\n    content: {\n      title: \"Test Product for Suspend\",\n      format: \"md\",\n      body: \"Suspend test body\",\n      files: [\n        { name: \"guide\", extension: \"md\", url: \"https://cdn.example.com/guide.md\" }\n      ],\n      thumbnails: [\n        { name: \"thumb\", extension: \"jpg\", url: \"https://cdn.example.com/thumb.jpg\" }\n      ]\n    },\n    units: [\n      {\n        name: \"Default\",\n        primary: true,\n        required: true,\n        options: [\n          {\n            type: \"select\",\n            name: \"Color\",\n            variable: true,\n            candidates: [ { name: \"Red\" }, { name: \"Blue\" } ]\n          }\n        ],\n        stocks: [\n          {\n            name: \"RedStock\",\n            price: { nominal: 11000, real: 9000 },\n            quantity: 5,\n            choices: [ { option_index: 0, candidate_index: 0 } ]\n          },\n          {\n            name: \"BlueStock\",\n            price: { nominal: 12000, real: 9500 },\n            quantity: 8,\n            choices: [ { option_index: 0, candidate_index: 1 } ]\n          }\n        ]\n      }\n    ],\n    tags: [\"test\", \"suspend\"],\n    category_codes: [\"all\"]\n  };\n\n  const sale = await api.functional.shoppings.sellers.sales.post(connection, saleInput);\n  typia.assert<IShoppingSale>(sale);\n\n  // 2. 정상 판매 중단 시도\n  await TestValidator.predicate(\"판매 중단 정상 처리\")(async () => {\n    await api.functional.shoppings.sellers.sales.deleteSuspend(connection, sale.id);\n    return true;\n  });\n\n  // 3. 이미 중단된 판매 중 복수 중단 시도 - 409 CONFLICT\n  await TestValidator.httpError(\"이미 중단된 판매 재중단\") (409)(\n    () => api.functional.shoppings.sellers.sales.deleteSuspend(connection, sale.id)\n  );\n\n  // 4. 존재하지 않는 판매 ID (UUID)\n  await TestValidator.httpError(\"존재하지 않는 판매 중단\") (404)(\n    () => api.functional.shoppings.sellers.sales.deleteSuspend(connection, \"00000000-0000-0000-0000-000000000abc\")\n  );\n\n  // 5. 권한 없는 계정(다른 connection, seller 등)으로 중단 시도 - 403 FORBIDDEN\n  const anotherConnection = { ...connection, accessToken: \"invalid_or_other_seller_token\" };\n  await TestValidator.httpError(\"권한 없는 판매 중단\") (403)(\n    () => api.functional.shoppings.sellers.sales.deleteSuspend(anotherConnection, sale.id)\n  );\n}\n",
  "test/features/api/sale/test_restore_suspended_sale_edge_cases.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingSale } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSale\";\nimport { IShoppingSale as ICreate, IShoppingSaleContent as IContent, IShoppingSaleUnit as IUnit, IShoppingSaleUnitSelectableOption as ISelectableOption, IShoppingSaleUnitOptionCandidate as IOptionCandidate, IShoppingSaleUnitStock as IStock, IShoppingPrice } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSale.ICreate\";\nimport typia from \"typia\";\n\nexport async function test_api_sale_restore_suspended_sale_edge_cases(connection: api.IConnection): Promise<void> {\n    // 1. 판매 등록 (minimum requirement)\n    const section_code = \"section-001\";\n    const category_code = \"cat-001\";\n    const saleInput: ICreate = {\n        section_code,\n        status: \"suspended\",\n        opened_at: new Date().toISOString(),\n        closed_at: null,\n        content: {\n            title: \"테스트 판매\",\n            format: \"md\",\n            body: \"테스트 판매 설명\",\n            files: [\n                {\n                    name: \"example\",\n                    extension: \"jpg\",\n                    url: \"https://test.com/sample.jpg\",\n                }\n            ],\n            thumbnails: [\n                {\n                    name: \"thumb\",\n                    extension: \"jpg\",\n                    url: \"https://test.com/sample2.jpg\",\n                }\n            ]\n        },\n        units: [\n            {\n                name: \"기본 단위\",\n                primary: true,\n                required: true,\n                options: [\n                    {\n                        type: \"select\",\n                        name: \"색상\",\n                        variable: false,\n                        candidates: [\n                            {\n                                name: \"빨강\"\n                            }\n                        ]\n                    }\n                ],\n                stocks: [\n                    {\n                        name: \"스톡A\",\n                        price: {\n                            nominal: 10000,\n                            real: 9000\n                        },\n                        quantity: 1,\n                        choices: [\n                            {\n                                option_index: 0,\n                                candidate_index: 0\n                            }\n                        ]\n                    }\n                ]\n            }\n        ],\n        tags: [\"test\"],\n        category_codes: [category_code]\n    };\n\n    const sale: IShoppingSale = await api.functional.shoppings.sellers.sales.post(connection, saleInput);\n    typia.assert<IShoppingSale>(sale);\n    TestValidator.equals(\"suspended 상태로 생성됨\")(sale.status)(\"suspended\");\n    TestValidator.predicate(\"suspended_at 값 존재\")(!!sale.suspended_at);\n    \n    // 2. 중단된 판매 복구 성공 케이스\n    await api.functional.shoppings.sellers.sales.putByIdRestore(connection, sale.id);\n    \n    // 2-1. 복구된 동일 sale 상태 조회 후 suspended 타임스탬프 사라졌는지 확인 (별도 API 없으므로 skip)\n    // \n    // 3. 이미 활성화된(복구된) sale 재복구 시도 → 충돌\n    await TestValidator.httpError(\"이미 복구된 판매 restore: 409 충돌 예상\")(409)(async () => {\n        await api.functional.shoppings.sellers.sales.putByIdRestore(connection, sale.id);\n    });\n\n    // 4. 존재하지 않는 ID로 restore 시도 → 404 NotFound\n    await TestValidator.httpError(\"존재하지 않은 판매 restore: 404 Not Found\")(404)(async () => {\n        await api.functional.shoppings.sellers.sales.putByIdRestore(connection, \"00000000-0000-0000-0000-000000000000\");\n    });\n\n    // 5. 타 판매자로 로그인하여 restore 시도 → 403 or 404\n    // -- 타 판매자 로그인 세션 필요. 이하 예시는 별도 connection 또는 인증 토큰 필요.\n    if (typeof globalThis.another_seller_connection === \"object\" && globalThis.another_seller_connection) {\n        // 성공적으로 타 판매자 인증 세션 객체 준비된 경우 테스트\n        await TestValidator.httpError(\"타 판매자가 소유한 판매 restore: 403/404 거절\")(403, 404)(async () => {\n            await api.functional.shoppings.sellers.sales.putByIdRestore(globalThis.another_seller_connection, sale.id);\n        });\n    } else {\n        // Skip: 타 판매자 인증 connection 제공되지 않으면 스킵 처리\n    }\n}\n",
  "test/features/api/sale/test_list_sales_details_with_various_filters.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingSale } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSale\";\nimport { IShoppingSale as IRequest } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSale.IRequest\";\nimport { IPageIShoppingSale } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIShoppingSale\";\nimport typia from \"typia\";\n\nexport async function test_api_sale_list_sales_details_with_various_filters(\n  sellerConnection: api.IConnection,\n  customerConnection: api.IConnection,\n): Promise<void> {\n  // 1. 정상 입력 케이스(기본): page=1, limit=10, 정렬없음\n  const reqDefault: IRequest = {\n    page: 1,\n    limit: 10,\n  };\n  const resDefault = await api.functional.shoppings.sellers.sales.details.patch(\n    sellerConnection,\n    reqDefault,\n  );\n  typia.assert<IPageIShoppingSale>(resDefault);\n  TestValidator.predicate(\"pagination page=1\")(resDefault.pagination.current === 1);\n  TestValidator.predicate(\"limit=10\")(resDefault.pagination.limit === 10);\n  TestValidator.predicate(\"data array type\")(() => Array.isArray(resDefault.data));\n  if (resDefault.data.length) {\n    typia.assert<IShoppingSale>(resDefault.data[0]);\n  }\n\n  // 2. 정렬 옵션: sale.created_at 오름차순, 내림차순 각각 테스트\n  for (const sort of [\"+sale.created_at\", \"-sale.created_at\"] as const) {\n    const reqSort: IRequest = {\n      ...reqDefault,\n      sort: [sort],\n    };\n    const resSort = await api.functional.shoppings.sellers.sales.details.patch(\n      sellerConnection,\n      reqSort,\n    );\n    typia.assert<IPageIShoppingSale>(resSort);\n    const arr = resSort.data;\n    if (arr.length > 1) {\n      const cmp = sort.startsWith(\"+\")\n        ? (a: IShoppingSale, b: IShoppingSale) => a.created_at.localeCompare(b.created_at)\n        : (a: IShoppingSale, b: IShoppingSale) => b.created_at.localeCompare(a.created_at);\n      for (let i = 1; i < arr.length; ++i)\n        TestValidator.predicate(`정렬 확인: ${sort}`)(cmp(arr[i - 1], arr[i]) <= 0);\n    }\n  }\n\n  // 3. page/limit, 마지막페이지, 비정상 페이지값\n  const reqLastPage: IRequest = {\n    ...reqDefault,\n    page: resDefault.pagination.pages,\n    limit: 1,\n  };\n  const resLastPage = await api.functional.shoppings.sellers.sales.details.patch(\n    sellerConnection,\n    reqLastPage,\n  );\n  typia.assert<IPageIShoppingSale>(resLastPage);\n  TestValidator.predicate(\"마지막 페이지\")(resLastPage.pagination.current === resDefault.pagination.pages);\n\n  // (음수 page, 말도 안되는 값 등 - negative case)\n  const reqInvalidPage: IRequest = {\n    page: -5,\n    limit: 10,\n  };\n  await TestValidator.httpError(\"음수 페이지 입력시 에러\", 400, 422)(() =>\n    api.functional.shoppings.sellers.sales.details.patch(sellerConnection, reqInvalidPage),\n  );\n\n  // 4. 데이터 존재하지 않는 상황(아주 큰 page 번호)\n  const reqNonExistPage: IRequest = {\n    page: 99999,\n    limit: 10,\n  };\n  const resNonExistPage = await api.functional.shoppings.sellers.sales.details.patch(\n    sellerConnection,\n    reqNonExistPage,\n  );\n  typia.assert<IPageIShoppingSale>(resNonExistPage);\n  TestValidator.equals(\"empty array\")<IShoppingSale[]>([])(resNonExistPage.data);\n\n  // 5. 권한 없는 사용자 요청시(고객 connection)\n  await TestValidator.httpError(\"판매자만 접근가능\", 403, 401)(() =>\n    api.functional.shoppings.sellers.sales.details.patch(customerConnection, reqDefault),\n  );\n}\n",
  "test/features/api/seller/test_login_seller_with_valid_and_invalid_credentials.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport { IShoppingSeller } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSeller\";\nimport { IShoppingMember } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingMember\";\n\nexport async function test_login_seller_with_valid_and_invalid_credentials(connection: api.IConnection): Promise<void> {\n    // 1. 판매자 회원가입: 테스트용 자격증명 준비\n    const joinInput: IShoppingSeller.IJoin = {};\n    const seller = await api.functional.shoppings.sellers.authenticate.post(connection, joinInput);\n    typia.assert<IShoppingSeller.IInvert>(seller);\n    const validEmail = seller.member.emails[0]?.value;\n    \n    // 비밀번호는 시나리오 상 알 수 없으나 관례적으로 기본 프로필 생성시 입력값이 그대로 사용된다고 가정\n    const validPassword = \"Test1234!@\";\n    // 회원가입 시점에 동일 비밀번호를 사용했다고 가정 (실제 비밀번호 정보 생성/입수 방법은 실제 환경에 따라 다름)\n\n    // 2. 올바른 자격증명으로 로그인\n    const loginInput: IShoppingMember.ILogin = { email: validEmail, password: validPassword };\n    const loginResult = await api.functional.shoppings.sellers.authenticate.login.put(connection, loginInput);\n    typia.assert<IShoppingSeller.IInvert>(loginResult);\n    TestValidator.equals(\"정상 로그인 결과 일치\")(seller)(loginResult);\n    \n    // 3. 잘못된 비밀번호로 로그인\n    const wrongPasswordInput: IShoppingMember.ILogin = { email: validEmail, password: \"wrongPassword\" };\n    await TestValidator.httpError(\"비밀번호 오류 로그인 실패\")(401, 403)(async () => {\n        await api.functional.shoppings.sellers.authenticate.login.put(connection, wrongPasswordInput);\n    });\n\n    // 4. 존재하지 않는 아이디로 로그인\n    const nonexistentInput: IShoppingMember.ILogin = { email: \"not-exist-user@example.com\", password: \"somepass!\" };\n    await TestValidator.httpError(\"존재하지 않는 아이디 로그인 실패\")(401, 403)(async () => {\n        await api.functional.shoppings.sellers.authenticate.login.put(connection, nonexistentInput);\n    });\n\n    // 5. 연속 5회 이상 잘못된 로그인 시도 (계정 잠금 등)\n    let locked = false;\n    for (let i = 0; i < 6; ++i) {\n        try {\n            await TestValidator.httpError(\"연속 로그인 실패로 인한 오류\")(401, 403, 423)(async () => {\n                await api.functional.shoppings.sellers.authenticate.login.put(connection, wrongPasswordInput);\n            });\n        } catch (err) {\n            // 423 Locked 등 계정 잠금 상태일 때\n            locked = true;\n            break;\n        }\n    }\n    TestValidator.predicate(\"계정 잠금 여부\")(locked === true);\n}\n",
  "test/features/api/delivery/test_create_delivery_with_valid_and_invalid_input.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport { IShoppingSeller } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSeller\";\nimport { IShoppingDelivery } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingDelivery\";\nimport { IShoppingDeliveryPiece } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingDeliveryPiece\";\nimport { IShoppingDeliveryJourney } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingDeliveryJourney\";\nimport { IShoppingDeliveryShipper } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingDeliveryShipper\";\n\nexport async function test_create_delivery_with_valid_and_invalid_input(connection: api.IConnection): Promise<void> {\n  // Step 1: 판매자 인증\n  const seller: IShoppingSeller.IInvert = await api.functional.shoppings.sellers.authenticate(\n    connection,\n    {},\n  );\n  typia.assert<IShoppingSeller.IInvert>(seller);\n  \n  // Step 2: 유효한 배송 생성\n  const validInput = {\n    pieces: [\n      {\n        publish_id: \"00000000-0000-4000-8000-000000000001\",\n        good_id: \"00000000-0000-4000-8000-000000000002\",\n        stock_id: \"00000000-0000-4000-8000-000000000003\",\n        quantity: 1,\n      },\n    ],\n    journeys: [\n      {\n        type: \"preparing\",\n        title: \"상품 준비 중\",\n        description: \"출고 대기\",\n        started_at: null,\n        completed_at: null,\n      },\n    ],\n    shippers: [\n      {\n        company: \"택배회사\",\n        name: \"배송기사\",\n        mobile: \"01012345678\",\n      },\n    ],\n  };\n  const delivery = await api.functional.shoppings.sellers.deliveries.post(connection, validInput);\n  typia.assert<IShoppingDelivery>(delivery);\n  TestValidator.predicate(\"정상적으로 생성된 배송 상세정보 반환\")(\n    () => delivery.pieces.length === 1 && delivery.journeys.length > 0 && delivery.shippers.length > 0,\n  );\n  TestValidator.equals(\"입력값과 반환 pieces 검증\")(validInput.pieces[0])(delivery.pieces[0]);\n\n  // Step 3: 필수입력 (pieces) 누락시 400에러\n  await TestValidator.httpError(\"필수입력 누락 시 400 에러\")(400)(\n    () => api.functional.shoppings.sellers.deliveries.post(connection, {\n      journeys: validInput.journeys,\n      shippers: validInput.shippers,\n      // pieces 누락\n    })\n  );\n\n  // Step 4: 중복 배송(동일한 조합) 생성 시도시 409(또는 관련 비즈니스 에러)\n  await TestValidator.httpError(\"중복 배송 생성시 409 또는 400 에러\")(409, 400)(\n    () => api.functional.shoppings.sellers.deliveries.post(connection, validInput)\n  );\n}\n",
  "test/features/api/delivery/test_list_deliveries_with_auth_and_filtering.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IPageIShoppingDelivery } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIShoppingDelivery\";\nimport { IShoppingDelivery } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingDelivery\";\nimport { IShoppingDeliveryICreate } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingDeliveryICreate\";\nimport typia from \"typia\";\n\nexport async function test_list_deliveries_with_auth_and_filtering(connection: api.IConnection): Promise<void> {\n    // 1. 판매자 계정 생성 및 인증 처리\n    const seller = await api.functional.shoppings.sellers.authenticate.post(connection, {});\n    typia.assert(seller);\n    TestValidator.equals(\"seller join response includes type 'seller'\")(\"seller\")(seller.type);\n\n    // 2. 배송 건 데이터 1개 생성(실데이터는 정확한 타입 구조 필수)\n    const deliveryInput: IShoppingDeliveryICreate = {\n        pieces: [{\n            publish_id: \"00000000-0000-0000-0000-000000000001\",\n            good_id: \"00000000-0000-0000-0000-000000000002\",\n            stock_id: \"00000000-0000-0000-0000-000000000003\",\n            quantity: 1,\n        }],\n        journeys: [{\n            type: \"preparing\",\n            title: \"준비중\",\n            description: \"상품 준비\",\n            started_at: null,\n            completed_at: null,\n        }],\n        shippers: [{\n            company: null,\n            name: \"홍길동\",\n            mobile: \"01012345678\",\n        }],\n    };\n    const delivery = await api.functional.shoppings.sellers.deliveries.post(connection, deliveryInput);\n    typia.assert<IShoppingDelivery>(delivery);\n    TestValidator.equals(\"delivery piece length\")(1)(delivery.pieces.length);\n\n    // 3. 성공 케이스(기본 조회)\n    const listReq = { page: 0, limit: 10, sort: [\"-delivery.created_at\"] };\n    const result = await api.functional.shoppings.sellers.deliveries.patch(connection, listReq);\n    typia.assert<IPageIShoppingDelivery.IInvert>(result);\n    TestValidator.predicate(\"contains delivery id\")(!!result.data.find(d => d.id === delivery.id));\n\n    // 4. 필터/정렬 케이스(상태: underway, 기간 등)\n    const filteredReq = { ...listReq/*, 추가 필터 속성 필요시 삽입*/};\n    const filteredResult = await api.functional.shoppings.sellers.deliveries.patch(connection, filteredReq);\n    typia.assert<IPageIShoppingDelivery.IInvert>(filteredResult);\n    TestValidator.equals(\"pagination info exists\")(true)(typeof filteredResult.pagination.current === \"number\");\n\n    // 5. 인증 없이 접근(권한 거부)\n    await TestValidator.httpError(\"unauthorized seller must be rejected\")(403)(async () =>\n        api.functional.shoppings.sellers.deliveries.patch({ ...connection, accessToken: undefined }, listReq),\n    );\n\n    // 6. 만료 토큰 케이스(여기선 빈 문자열로 대체)\n    await TestValidator.httpError(\"expired token must be rejected\")(401, 403)(async () =>\n        api.functional.shoppings.sellers.deliveries.patch({ ...connection, accessToken: \"expired_or_invalid_token\" }, listReq),\n    );\n}\n",
  "test/features/api/delivery/test_get_delivery_detail_with_valid_and_invalid_id.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingSeller } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSeller\";\nimport { IShoppingDelivery } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingDelivery\";\nimport { IShoppingDelivery_ICreate } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingDelivery.ICreate\";\nimport typia from \"typia\";\nimport { v4 as uuidv4 } from \"uuid\";\n\nexport async function test_api_get_delivery_detail_with_valid_and_invalid_id(connection: api.IConnection): Promise<void> {\n    // 1. 판매자 인증 (정상 Token 발급)\n    const seller: IShoppingSeller.IInvert = await api.functional.shoppings.sellers.authenticate(\n        connection,\n        {}  // 명세상 IShoppingSeller.IJoin에 required 필드 없음\n    );\n\n    // 2. 배송 생성\n    const deliveryInput: IShoppingDelivery_ICreate = {\n        pieces: [\n            {\n                publish_id: uuidv4(),\n                good_id: uuidv4(),\n                stock_id: uuidv4(),\n                quantity: 1,\n            },\n        ],\n        journeys: [\n            {\n                type: \"preparing\",\n                title: \"배송 준비중\",\n                description: \"테스트 배송 - 준비중\",\n                started_at: null,\n                completed_at: null,\n            },\n        ],\n        shippers: [\n            {\n                company: \"TestDeliveryCo\",\n                name: \"홍길동\",\n                mobile: \"01000000000\",\n            },\n        ],\n    };\n\n    const created: IShoppingDelivery = await api.functional.shoppings.sellers.deliveries.post(\n        connection,\n        deliveryInput\n    );\n    typia.assert<IShoppingDelivery>(created);\n    TestValidator.equals(\"배송 생성-식별자 확인\")(\n        created.seller.id\n    )(seller.id);\n\n    // 3. 정상 배송 상세 조회\n    const detail = await api.functional.shoppings.sellers.deliveries.get(\n        connection,\n        created.id\n    );\n    typia.assert(detail);\n    TestValidator.equals(\"상세 id 일치\")(created.id)(detail.id);\n    TestValidator.equals(\"배송 판매자 일치\")(created.seller.id)(detail.seller.id);\n\n    // 4. 존재하지 않는 id로 조회 시 404\n    await TestValidator.httpError(\"존재하지 않는 배송 id 조회\", 404)(async () => {\n        await api.functional.shoppings.sellers.deliveries.get(connection, uuidv4());\n    });\n\n    // 5. 타 판매자 인증 후, 생성한 배송 id 접근 시 권한/404\n    // (새로운 판매자 인증)\n    const anotherSeller: IShoppingSeller.IInvert = await api.functional.shoppings.sellers.authenticate(\n        connection,\n        {}\n    );\n    await TestValidator.httpError(\"타 판매자가 남의 배송 id 조회\", 403, 404)(async () => {\n        await api.functional.shoppings.sellers.deliveries.get(connection, created.id);\n    });\n\n    // 6. 인증 미포함(익명 요청) - connection 없이 직접 요청 불가이므로, 잘못된 토큰으로 테스트\n    const anonymousConnection = { ...connection, headers: { authorization: undefined } };\n    await TestValidator.httpError(\"인증 누락시 오류\", 401, 403, 404)(async () => {\n        await api.functional.shoppings.sellers.deliveries.get(anonymousConnection as api.IConnection, created.id);\n    });\n\n    // 7. 잘못된(가짜) 토큰\n    const fakeConnection = { ...connection, headers: { authorization: \"Bearer fake.invalid.token.test\" } };\n    await TestValidator.httpError(\"가짜 토큰시 오류\", 401, 403, 404)(async () => {\n        await api.functional.shoppings.sellers.deliveries.get(fakeConnection as api.IConnection, created.id);\n    });\n}\n",
  "test/features/api/delivery/test_list_incomplete_deliveries_with_and_without_data.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingSeller } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSeller\";\nimport { IShoppingDeliveryPiece } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingDeliveryPiece\";\nimport typia from \"typia\";\n\nexport async function test_api_delivery_list_incomplete_deliveries_with_and_without_data(\n  connection: api.IConnection\n): Promise<void> {\n  // 1. 판매자 인증하기 (선행)\n  const sellerInput: IShoppingSeller.IJoin = {};\n  const seller: IShoppingSeller.IInvert = await api.functional.shoppings.sellers.authenticate(\n    connection,\n    sellerInput\n  );\n  typia.assert<IShoppingSeller.IInvert>(seller);\n\n  // 2-1. 데이터 없는 상황 (빈 publish_ids)\n  const emptyReq: IShoppingDeliveryPiece.IRequest = { publish_ids: [] };\n  const resultEmpty = await api.functional.shoppings.sellers.deliveries.incompletes.patch(\n    connection,\n    emptyReq\n  );\n  const emptyArr: IShoppingDeliveryPiece.ICreate[] = [];\n  TestValidator.equals(\"빈 배열 반환 확인\")(emptyArr)(resultEmpty);\n  typia.assert<IShoppingDeliveryPiece.ICreate[]>(resultEmpty);\n\n  // 2-2. 데이터 없는 상황 (존재하지 않는 uuid 입력)\n  const nonExistReq: IShoppingDeliveryPiece.IRequest = {\n    publish_ids: [\n      \"00000000-0000-0000-0000-000000000000\",\n      \"11111111-1111-1111-1111-111111111111\"\n    ]\n  };\n  const resultNone = await api.functional.shoppings.sellers.deliveries.incompletes.patch(\n    connection,\n    nonExistReq\n  );\n  TestValidator.equals(\"존재하지 않는 id 빈 배열 반환 확인\")(emptyArr)(resultNone);\n  typia.assert<IShoppingDeliveryPiece.ICreate[]>(resultNone);\n\n  // 3. 인증/권한 없는 사용자 - 에러(401/403) 확인\n  await TestValidator.httpError(\"권한 오류\")(401, 403)(async () =>\n    api.functional.shoppings.sellers.deliveries.incompletes.patch(\n      {} as api.IConnection,\n      emptyReq\n    )\n  );\n}\n",
  "test/features/api/delivery-journey/test_complete_journey_with_valid_and_invalid_status.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport { IShoppingSeller } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSeller\";\nimport { IShoppingDelivery } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingDelivery\";\nimport { IShoppingDeliveryJourney } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingDeliveryJourney\";\nimport { IShoppingDeliveryJourney as JourneyNamespace } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingDeliveryJourney\";\nimport { IShoppingDelivery as DeliveryNamespace } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingDelivery\";\n\nexport async function test_api_delivery_journey_complete(connection: api.IConnection): Promise<void> {\n  // 1. 판매자 인증 (실제 입력값이 없으므로 빈 객체)\n  const seller: IShoppingSeller.IInvert = await api.functional.shoppings.sellers.authenticate(connection, {});\n  typia.assert<IShoppingSeller.IInvert>(seller);\n\n  // 2. 배송 생성용 piece, shipper, journey input 구성\n  const publishId = crypto.randomUUID();\n  const goodId = crypto.randomUUID();\n  const stockId = crypto.randomUUID();\n  const piece: DeliveryNamespace.ICreate[\"pieces\"][number] = {\n    publish_id: publishId,\n    good_id: goodId,\n    stock_id: stockId,\n    quantity: 1,\n  };\n  const shipper: DeliveryNamespace.ICreate[\"shippers\"][number] = {\n    company: \"테스트택배사\",\n    name: \"홍길동\",\n    mobile: \"01012345678\",\n  };\n  // 최초 journey는 미완료로 생성\n  const journeyCreate: DeliveryNamespace.ICreate[\"journeys\"][number] = {\n    type: \"delivering\",\n    title: \"배송중 단계\",\n    description: \"테스트용 진행중 배송\",\n    started_at: new Date().toISOString(),\n    completed_at: null,\n  };\n\n  const deliveryInput: DeliveryNamespace.ICreate = {\n    pieces: [piece],\n    shippers: [shipper],\n    journeys: [journeyCreate],\n  };\n\n  // 3. 배송 생성\n  const delivery: IShoppingDelivery = await api.functional.shoppings.sellers.deliveries.post(connection, deliveryInput);\n  typia.assert<IShoppingDelivery>(delivery);\n  \n  // journey 생성 결과 추출 (최초 1개)\n  TestValidator.predicate(\"배송에 1개 journey가 생성됨\")(() => delivery.journeys.length === 1);\n  const journey = delivery.journeys[0];\n  typia.assert<IShoppingDeliveryJourney>(journey);\n  TestValidator.predicate(\"초기 journey.completed_at이 null\")(() => journey.completed_at === null);\n\n  // 4. 정상: journey 완료처리\n  const completeInput: JourneyNamespace.IComplete = {\n    completed_at: new Date().toISOString(),\n  };\n  await api.functional.shoppings.sellers.deliveries.journeys.complete(\n    connection,\n    delivery.id,\n    journey.id,\n    completeInput,\n  );\n  // 완료 후 journey 상태조회(여기선 재조회 API가 없어 재호출 생략, 실제론 별도 조회권장)\n\n  // 5. Negative: 이미 완료된 journey 다시 완료처리 시도 → 예외 검증\n  await TestValidator.error(\"이미 완료된 journey 재완료시 에러\")(\n    () => api.functional.shoppings.sellers.deliveries.journeys.complete(\n      connection,\n      delivery.id,\n      journey.id,\n      completeInput,\n    )\n  );\n\n  // 6. Negative: 존재하지 않는 deliveryId → 404 에러\n  const invalidDeliveryId = crypto.randomUUID();\n  await TestValidator.httpError(\"존재하지 않는 deliveryId\")(\n    404\n  )(\n    () => api.functional.shoppings.sellers.deliveries.journeys.complete(\n      connection,\n      invalidDeliveryId,\n      journey.id,\n      completeInput,\n    )\n  );\n\n  // 7. Negative: 존재하지 않는 journeyId → 404 에러\n  const invalidJourneyId = crypto.randomUUID();\n  await TestValidator.httpError(\"존재하지 않는 journeyId\")(\n    404\n  )(\n    () => api.functional.shoppings.sellers.deliveries.journeys.complete(\n      connection,\n      delivery.id,\n      invalidJourneyId,\n      completeInput,\n    )\n  );\n}\n",
  "test/features/api/delivery/test_delete_journey_with_various_states.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport { IShoppingSeller } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSeller\";\nimport { IShoppingDelivery } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingDelivery\";\nimport { IShoppingDeliveryJourney } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingDeliveryJourney\";\nimport { IShoppingDeliveryPiece } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingDeliveryPiece\";\nimport { IShoppingDeliveryShipper } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingDeliveryShipper\";\n\nexport async function test_delete_journey_with_various_states(connection: api.IConnection): Promise<void> {\n    // 1. 인증: 판매자로 인증(실제로는 session 발급 등 추가 필요할 수 있음, 예시)\n    await api.functional.shoppings.sellers.authenticate(connection, {});\n\n    // 2. 배송 생성\n    // 샘플 piece, journey, shipper 데이터 준비\n    const piece: IShoppingDeliveryPiece.ICreate = {\n        publish_id: \"00000000-0000-0000-0000-000000000001\",\n        good_id: \"00000000-0000-0000-0000-000000000002\",\n        stock_id: \"00000000-0000-0000-0000-000000000003\",\n        quantity: 1\n    };\n    const initialJourney: IShoppingDeliveryJourney.ICreate = {\n        type: \"preparing\",\n        title: \"준비중\",\n        description: \"배송 진행 전\",\n        started_at: null,\n        completed_at: null\n    };\n    const shipper: IShoppingDeliveryShipper.ICreate = {\n        company: \"배송사\",\n        name: \"홍길동\",\n        mobile: \"01012341234\"\n    };\n    const deliveryInput = {\n        pieces: [piece],\n        journeys: [initialJourney],\n        shippers: [shipper]\n    };\n\n    const delivery: IShoppingDelivery = await api.functional.shoppings.sellers.deliveries.create(connection, deliveryInput);\n    typia.assert<IShoppingDelivery>(delivery);\n\n    // 3. journey 추가 (삭제 테스트대상)\n    const addJourney: IShoppingDeliveryJourney.ICreate = {\n        type: \"shipping\",\n        title: \"배송중\",\n        description: \"배송 시작\",\n        started_at: null,\n        completed_at: null\n    };\n    const newJourney: IShoppingDeliveryJourney = await api.functional.shoppings.sellers.deliveries.journeys.create(connection, delivery.id, addJourney);\n    typia.assert<IShoppingDeliveryJourney>(newJourney);\n\n    // 4. 정상 삭제\n    await TestValidator.error(\"정상적으로 삭제되어야 함\")(\n        async () => { await api.functional.shoppings.sellers.deliveries.journeys.erase(connection, delivery.id, newJourney.id); }\n    );\n    // 정상 삭제 이후 같은 id로 조회/삭제 시 오류\n    await TestValidator.httpError(\"이미 삭제된 journey 재삭제 오류\")(404)(\n        async () => { await api.functional.shoppings.sellers.deliveries.journeys.erase(connection, delivery.id, newJourney.id); }\n    );\n\n    // 5. 권한 없는 접근: 다른 connection(타 판매자/비인증 등)으로 삭제 시도\n    const fakeConnection = { ...connection, headers: { ...connection.headers, authorization: \"Bearer fake-token\" } };\n    await TestValidator.httpError(\"권한 없는 접근\")(403, 401)(\n        async () => { await api.functional.shoppings.sellers.deliveries.journeys.erase(fakeConnection, delivery.id, newJourney.id); }\n    );\n\n    // 6. 잘못된 deliveryId/journeyId 조합 (존재하지 않는 경우)\n    await TestValidator.httpError(\"존재하지 않는 deliveryId-journeyId 삭제 404\") (404)(\n        async () => { await api.functional.shoppings.sellers.deliveries.journeys.erase(connection, \"11111111-1111-1111-1111-111111111111\", \"22222222-2222-2222-2222-222222222222\"); }\n    );\n}\n",
  "test/features/api/delivery-shipper/test_assign_shipper_to_delivery.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingSeller } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSeller\";\nimport { IShoppingDelivery } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingDelivery\";\nimport { IShoppingDeliveryShipper } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingDeliveryShipper\";\nimport { IShoppingDeliveryShipper as DeliveryShipperNS } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingDeliveryShipper\";\nimport { IShoppingDelivery as DeliveryNS } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingDelivery\";\nimport typia from \"typia\";\n\nexport async function test_api_delivery_shipper_assignment(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. 판매자 인증 선행\n  const seller = await api.functional.shoppings.sellers.authenticate(\n    connection,\n    {}, // IShoppingSeller.IJoin에 required 필드 없음\n  );\n  typia.assert<IShoppingSeller.IInvert>(seller);\n\n  // 2. 배송 데이터 생성\n  // 의존성에 따라 최소 배송 piece, journey, shipper 세팅 필요\n  const deliveryInput: DeliveryNS.ICreate = {\n    pieces: [\n      {\n        publish_id: \"11111111-1111-1111-1111-111111111111\",\n        good_id: \"22222222-2222-2222-2222-222222222222\",\n        stock_id: \"33333333-3333-3333-3333-333333333333\",\n        quantity: 1,\n      },\n    ],\n    journeys: [\n      {\n        type: \"preparing\",\n        title: \"준비중\",\n        description: \"출고 준비\",\n        started_at: null,\n        completed_at: null,\n      },\n    ],\n    shippers: [\n      {\n        company: \"테스트택배\",\n        name: \"최배달\",\n        mobile: \"01012345678\",\n      },\n    ],\n  };\n  const delivery: IShoppingDelivery = await api.functional.shoppings.sellers.deliveries.post(\n    connection,\n    deliveryInput,\n  );\n  typia.assert<IShoppingDelivery>(delivery);\n\n  // 3. 정상 케이스: 배송기사 추가\n  const shipperInput: DeliveryShipperNS.ICreate = {\n    company: \"테스트택배2\",\n    name: \"신배달\",\n    mobile: \"01087654321\",\n  };\n  const newShipper = await api.functional.shoppings.sellers.deliveries.shippers.post(\n    connection,\n    delivery.id,\n    shipperInput,\n  );\n  typia.assert<IShoppingDeliveryShipper>(newShipper);\n  TestValidator.equals(\"shipper 할당 name\")<string>(shipperInput.name)(newShipper.name);\n  TestValidator.equals(\"shipper 할당 mobile\")<string>(shipperInput.mobile)(newShipper.mobile);\n  TestValidator.equals(\"shipper 할당 company\")<string | null>(shipperInput.company)(newShipper.company);\n\n  // 4. 중복 케이스: 동일 데이터 재등록 (비즈니스 정책에 따라 에러 예상)\n  await TestValidator.httpError(\"중복 배송기사 등록은 4xx 에러\", 400, 409)(async () =>\n    api.functional.shoppings.sellers.deliveries.shippers.post(\n      connection,\n      delivery.id,\n      shipperInput,\n    )\n  );\n\n  // 5. 존재하지 않는 배송 id\n  await TestValidator.httpError(\"존재하지 않는 배송 ID 입력\", 404)(async () =>\n    api.functional.shoppings.sellers.deliveries.shippers.post(\n      connection,\n      \"non-existent-delivery-id\",\n      shipperInput,\n    )\n  );\n\n  // 6. 필수 정보 누락 케이스: name 없는 경우\n  const invalidInputNoName: DeliveryShipperNS.ICreate = {\n    company: \"테스트\",\n    // name: undefined,\n    mobile: \"01000000000\",\n  } as any;\n  await TestValidator.httpError(\"배송기사 이름 누락\", 400)(async () =>\n    api.functional.shoppings.sellers.deliveries.shippers.post(\n      connection,\n      delivery.id,\n      invalidInputNoName,\n    )\n  );\n\n  // 6-2. 필수 정보 누락 케이스: mobile 없는 경우\n  const invalidInputNoMobile: DeliveryShipperNS.ICreate = {\n    company: \"테스트\",\n    name: \"홍길동\",\n    // mobile: undefined,\n  } as any;\n  await TestValidator.httpError(\"배송기사 전화번호 누락\", 400)(async () =>\n    api.functional.shoppings.sellers.deliveries.shippers.post(\n      connection,\n      delivery.id,\n      invalidInputNoMobile,\n    )\n  );\n}\n",
  "test/features/api/coupon/test_create_coupon_with_valid_and_invalid_data.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport { IShoppingSeller } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSeller\";\nimport { IShoppingCoupon } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCoupon\";\nimport { IShoppingCouponRestriction } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCouponRestriction\";\nimport { IShoppingCouponDiscount } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCouponDiscount\";\nimport { IShoppingCouponICreate } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCoupon.ICreate\";\n\nexport async function test_api_coupon_create_with_valid_and_invalid_data(connection: api.IConnection): Promise<void> {\n  // Step 1: 판매자 인증\n  const sellerJoinInput: IShoppingSeller.IJoin = {};\n  const seller = await api.functional.shoppings.sellers.authenticate(connection, sellerJoinInput);\n  typia.assert<IShoppingSeller.IInvert>(seller);\n  const sellerId = seller.id;\n\n  // Step 2: 정상 쿠폰 생성\n  const validCouponInput: IShoppingCouponICreate = {\n    discount: { unit: \"percent\", value: 10, threshold: null, limit: null },\n    restriction: {\n      access: \"public\",\n      exclusive: false,\n      volume: null,\n      volume_per_citizen: null,\n      expired_in: null,\n      expired_at: null\n    },\n    criterias: [\n      { type: \"seller\", direction: \"include\", seller_ids: [sellerId] }\n    ],\n    disposable_codes: [],\n    name: \"Test Coupon\",\n    opened_at: null,\n    closed_at: null\n  };\n  const coupon = await api.functional.shoppings.sellers.coupons(connection, validCouponInput);\n  typia.assert<IShoppingCoupon>(coupon);\n  TestValidator.equals(\"created coupon name\")<string>(validCouponInput.name)(coupon.name);\n\n  // Step 3: 필수 값 누락 시 오류\n  const missingFieldCases: Partial<IShoppingCouponICreate>[] = [\n    Object.assign({}, validCouponInput, { discount: undefined }),\n    Object.assign({}, validCouponInput, { restriction: undefined }),\n    Object.assign({}, validCouponInput, { criterias: undefined }),\n    Object.assign({}, validCouponInput, { disposable_codes: undefined }),\n    Object.assign({}, validCouponInput, { name: undefined }),\n    Object.assign({}, validCouponInput, { opened_at: undefined }),\n    Object.assign({}, validCouponInput, { closed_at: undefined })\n  ];\n  for (const input of missingFieldCases) {\n    await TestValidator.httpError(\"필수 값 누락 시 400\") (400)(() =>\n      api.functional.shoppings.sellers.coupons(connection, input as any)\n    );\n  }\n\n  // Step 4: 할인율 잘못된 값(음수, 0, 101%)\n  const invalidDiscountInputs: IShoppingCouponICreate[] = [\n    {\n      ...validCouponInput,\n      discount: { unit: \"percent\", value: -1, threshold: null, limit: null }\n    },\n    {\n      ...validCouponInput,\n      discount: { unit: \"percent\", value: 0, threshold: null, limit: null }\n    },\n    {\n      ...validCouponInput,\n      discount: { unit: \"percent\", value: 101, threshold: null, limit: null }\n    }\n  ];\n  for (const input of invalidDiscountInputs) {\n    await TestValidator.httpError(\"부적절한 할인값 400\")(400)(() =>\n      api.functional.shoppings.sellers.coupons(connection, input)\n    );\n  }\n\n  // Step 5: 동일 코드 쿠폰 중복 생성\n  const duplicateCodeInput: IShoppingCouponICreate = {\n    ...validCouponInput,\n    disposable_codes: [\"DUPLICATE_CODE\"]\n  };\n  await api.functional.shoppings.sellers.coupons(connection, duplicateCodeInput);\n  await TestValidator.httpError(\"동일 disposable_code 중복 쿠폰 생성 시 409\")(409)(() =>\n    api.functional.shoppings.sellers.coupons(connection, duplicateCodeInput)\n  );\n}\n",
  "test/features/api/coupon/test_list_coupons_with_auth_and_search.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport {\n  IShoppingSeller,\n  IShoppingCoupon,\n  IShoppingCouponRestriction,\n  IShoppingCouponDiscount,\n  IShoppingCouponSellerCriteria,\n  IShoppingCouponFunnelCriteria,\n  IShoppingCouponICreate,\n  IShoppingCouponIRequest,\n  IPageIShoppingCoupon\n} from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCoupon\";\n\nexport async function test_api_coupon_list_coupons_with_auth_and_search(connection: api.IConnection): Promise<void> {\n  // 1. 판매자 인증\n  const sellerJoinInput = {} as any; // 실제 환경에서는 유효한 seller join 데이터 필요\n  const seller = await api.functional.shoppings.sellers.authenticate(connection, sellerJoinInput);\n  typia.assert<IShoppingSeller.IInvert>(seller);\n\n  // 2. 테스트용 쿠폰 생성 (이 쿠폰명이 검색조건 등에서도 사용할 것)\n  const couponName = `E2E-COUPON-${Date.now()}`;\n  const createCouponInput: IShoppingCoupon.ICreate = {\n    name: couponName,\n    discount: {\n      unit: \"amount\",\n      value: 1000,\n      threshold: null,\n      limit: null,\n      multiplicative: false\n    },\n    restriction: {\n      access: \"public\",\n      exclusive: false,\n      volume: 10,\n      volume_per_citizen: 1,\n      expired_in: 30,\n      expired_at: null\n    },\n    criterias: [{\n      type: \"seller\",\n      direction: \"include\",\n      seller_ids: [seller.id]\n    }],\n    disposable_codes: [],\n    opened_at: null,\n    closed_at: null\n  };\n  const newCoupon = await api.functional.shoppings.sellers.coupons(connection, createCouponInput);\n  typia.assert<IShoppingCoupon>(newCoupon);\n  TestValidator.equals(\"coupon.name\")<string>(couponName)(newCoupon.name);\n\n  // 3. 본인 쿠폰 목록 페이징 조회 (최소 전체조회)\n  const reqAll: IShoppingCoupon.IRequest = {};\n  const couponsPage = await api.functional.shoppings.sellers.coupons.patch(connection, reqAll);\n  typia.assert<IPageIShoppingCoupon>(couponsPage);\n  TestValidator.predicate(\"쿠폰 목록 1건 이상 포함\")(() => couponsPage.data.length > 0);\n  // 4. 최근 생성 쿠폰 포함 여부\n  TestValidator.predicate(\"생성한 쿠폰 포함 여부\")(() => couponsPage.data.some(c => c.id === newCoupon.id));\n  // 5. 페이징 기본값 확인 (limit/page)\n  const reqPaging: IShoppingCoupon.IRequest = { limit: 1, page: 0 };\n  const paged = await api.functional.shoppings.sellers.coupons.patch(connection, reqPaging);\n  typia.assert<IPageIShoppingCoupon>(paged);\n  TestValidator.equals(\"최대 1건 반환\")<number>(1)(paged.data.length);\n  // 6. 검색 조건 (쿠폰명 일부로)\n  const reqSearch: IShoppingCoupon.IRequest = {\n    search: { name: couponName.slice(0, 8) }\n  };\n  const searched = await api.functional.shoppings.sellers.coupons.patch(connection, reqSearch);\n  typia.assert<IPageIShoppingCoupon>(searched);\n  TestValidator.predicate(\"검색어 매칭 쿠폰 존재\")(() => searched.data.some(c => c.name.includes(couponName.slice(0, 8))));\n\n  // 7. 인증 없이 접근 시 401/403 에러\n  await TestValidator.httpError(\"인증 없이 접근 시 에러\") (401, 403)(async () => {\n    await api.functional.shoppings.sellers.coupons.patch({ ...connection, headers: {} }, reqAll);\n  });\n}\n",
  "test/features/api/coupon/test_get_coupon_detail_with_valid_and_invalid_id.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingSeller } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSeller\";\nimport { IShoppingCoupon } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCoupon\";\nimport { IShoppingCoupon as IShoppingCouponDTO } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCoupon\";\nimport { IShoppingCoupon as IShoppingCouponDTOType } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCoupon\";\nimport { IShoppingCouponRestriction } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCouponRestriction\";\nimport { IShoppingCouponDiscount } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCouponDiscount\";\nimport { IShoppingCouponSellerCriteria } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCouponSellerCriteria\";\nimport typia from \"typia\";\n\nexport async function test_api_coupon_get_coupon_detail_with_valid_and_invalid_id(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. 판매자 인증 (가입)\n  const seller: IShoppingSeller.IInvert = await api.functional.shoppings.sellers.authenticate(\n    connection,\n    {},\n  );\n\n  // 2. 쿠폰 생성 (\"amount\" 타입으로 최소 값 세팅)\n  const createInput: IShoppingCoupon.ICreate = {\n    discount: {\n      unit: \"amount\",\n      value: 1000,\n      threshold: null,\n      limit: null,\n      multiplicative: false,\n    },\n    restriction: {\n      access: \"public\",\n      exclusive: false,\n      volume: null,\n      volume_per_citizen: null,\n      expired_in: 30,\n      expired_at: null,\n    },\n    criterias: [\n      {\n        type: \"seller\",\n        direction: \"include\",\n        seller_ids: [seller.id],\n      },\n    ],\n    disposable_codes: [],\n    name: \"E2E-TEST-COUPON\",\n    opened_at: null,\n    closed_at: null,\n  };\n\n  const created: IShoppingCoupon = await api.functional.shoppings.sellers.coupons.post(\n    connection,\n    createInput,\n  );\n\n  typia.assert<IShoppingCoupon>(created);\n\n  // 3. 상세조회 정상\n  const detail: IShoppingCoupon = await api.functional.shoppings.sellers.coupons.get(\n    connection,\n    created.id,\n  );\n\n  typia.assert<IShoppingCoupon>(detail);\n  TestValidator.equals(\"same coupon id\")(created.id)(detail.id);\n  TestValidator.equals(\"same coupon name\")(created.name)(detail.name);\n\n  // 4. 존재하지 않는 id로 조회시 에러 검증\n  await TestValidator.httpError(\"not found coupon\")(\n    404,\n    410,\n  )(() =>\n    api.functional.shoppings.sellers.coupons.get(\n      connection,\n      \"00000000-0000-0000-0000-000000000000\",\n    ),\n  );\n\n  // 5. (선택) 인증 없이 접근 시 권한 에러\n  const unauthConn = { ...connection, headers: { ...connection.headers, authorization: undefined } };\n  await TestValidator.httpError(\"unauthorized\")(\n    401,\n    403,\n  )(() =>\n    api.functional.shoppings.sellers.coupons.get(\n      unauthConn,\n      created.id,\n    ),\n  );\n}\n",
  "test/features/api/coupon/test_delete_coupon_with_various_states.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingSeller } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSeller\";\nimport { IShoppingCoupon } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCoupon\";\nimport { IShoppingCouponICreate } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingCoupon.ICreate\";\nimport typia from \"typia\";\n\nexport async function test_api_delete_coupon_with_various_states(connection: api.IConnection): Promise<void> {\n    // 1. Authenticate as Seller A\n    const sellerA: IShoppingSeller.IInvert = await api.functional.shoppings.sellers.authenticate(\n        connection,\n        {} // Assuming empty body is OK for joining\n    );\n    typia.assert<IShoppingSeller.IInvert>(sellerA);\n    \n    // 2. Create a coupon as Seller A\n    const couponInput: IShoppingCouponICreate = {\n        discount: {\n            unit: \"amount\",\n            value: 1000,\n            threshold: null,\n            limit: null,\n            multiplicative: false\n        },\n        restriction: {\n            access: \"public\",\n            exclusive: false,\n            volume: 10,\n            volume_per_citizen: 1,\n            expired_in: 7,\n            expired_at: null\n        },\n        criterias: [\n            {\n                type: \"seller\",\n                seller_ids: [sellerA.id],\n                direction: \"include\"\n            }\n        ],\n        disposable_codes: [],\n        name: \"Discount Coupon A\",\n        opened_at: null,\n        closed_at: null\n    };\n    const coupon: IShoppingCoupon = await api.functional.shoppings.sellers.coupons.post(\n        connection,\n        couponInput\n    );\n    typia.assert<IShoppingCoupon>(coupon);\n\n    // 3. Delete the created coupon as Seller A (expect success)\n    await TestValidator.error(\"deletion by correct seller should succeed\")(\n        async () => {\n            await api.functional.shoppings.sellers.coupons[\"delete\"](\n                connection,\n                coupon.id\n            );\n        }\n    ); // Actually, for success, no error should be thrown, so call directly.\n    await api.functional.shoppings.sellers.coupons[\"delete\"](connection, coupon.id);\n    \n    // 4. Attempt to delete the same coupon again as Seller A (expect error)\n    await TestValidator.httpError(\"deleting already deleted coupon should fail\")(404)(\n        async () => {\n            await api.functional.shoppings.sellers.coupons[\"delete\"](connection, coupon.id);\n        }\n    );\n\n    // 5. Authenticate as Seller B\n    const sellerB: IShoppingSeller.IInvert = await api.functional.shoppings.sellers.authenticate(\n        connection,\n        {}\n    );\n    typia.assert<IShoppingSeller.IInvert>(sellerB);\n\n    // 6. Attempt to delete Seller A's coupon as Seller B (expect forbidden or 404)\n    await TestValidator.httpError(\"deleting another seller's coupon should fail\")(403, 404)(\n        async () => {\n            await api.functional.shoppings.sellers.coupons[\"delete\"](connection, coupon.id);\n        }\n    );\n}\n",
  "test/features/api/order/test_list_orders_with_auth_and_filters.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport { IShoppingOrder } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingOrder\";\nimport { IShoppingOrder_IRequest } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingOrder.IRequest\";\nimport { IPageIShoppingOrder } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIShoppingOrder\";\n\nexport async function test_api_order_list_orders_with_auth_and_filters(\n  connection: api.IConnection\n): Promise<void> {\n  // 1. 판매자 인증(세션 준비)\n  await api.functional.shoppings.sellers.authenticate.post(connection, {});\n\n  // 2. 테스트용 주문 데이터(판매 상품 등록)\n  const newSale = await api.functional.shoppings.sellers.sales.post(connection, {\n    section_code: \"TEST-SECTION\",\n    opened_at: new Date().toISOString(),\n    closed_at: null,\n    content: {\n      title: \"Test Sale Title\",\n      format: \"md\",\n      body: \"Test sale description.\",\n      files: [],\n      thumbnails: [],\n    },\n    units: [\n      {\n        options: [],\n        stocks: [\n          {\n            name: \"Main Stock\",\n            price: { nominal: 10000, real: 9000 },\n            quantity: 10,\n            choices: [],\n          },\n        ],\n        name: \"Base unit\",\n        primary: true,\n        required: true,\n      },\n    ],\n    tags: [\"test\"],\n    category_codes: [],\n  });\n\n  // 3. 주문 목록 조회(정상 - 인증된 판매자)\n  const req: IShoppingOrder_IRequest = {\n    search: null,\n    sort: [\"-order.created_at\"],\n    page: 0,\n    limit: 10,\n  };\n  const res = await api.functional.shoppings.sellers.orders.patch(connection, req);\n  typia.assert<IPageIShoppingOrder>(res);\n  TestValidator.predicate(\"order 리스트 조회 - 데이터 존재\")(res.data.length >= 0);\n  res.data.forEach(order => typia.assert<IShoppingOrder>(order));\n\n  // 3-2. 상태/기간 필터 조합 실제 동작 확인\n  const filterReq: IShoppingOrder_IRequest = {\n    search: {\n      min_price: 1,\n      max_price: 1000000,\n      paid: true,\n      sale: null,\n    },\n    sort: null,\n    page: 0,\n    limit: 5,\n  };\n  const filtered = await api.functional.shoppings.sellers.orders.patch(connection, filterReq);\n  typia.assert<IPageIShoppingOrder>(filtered);\n  filtered.data.forEach(order => typia.assert<IShoppingOrder>(order));\n  filtered.data.forEach(order => {\n    if (order.price.real < 1 || order.price.real > 1000000) {\n      throw new Error(\"가격 필터링 오류\");\n    }\n    if (filterReq.search && filterReq.search.paid !== null && order.publish && order.publish.paid_at === null) {\n      throw new Error(\"결제상태 필터링 오류\");\n    }\n  });\n\n  // 3-3. 페이징 정상 동작 확인\n  const pagingReq: IShoppingOrder_IRequest = {\n    search: null,\n    sort: null,\n    page: 1,\n    limit: 1,\n  };\n  const pagingRes = await api.functional.shoppings.sellers.orders.patch(connection, pagingReq);\n  typia.assert<IPageIShoppingOrder>(pagingRes);\n  TestValidator.predicate(\"페이징 데이터 1건 이하\")(pagingRes.data.length <= 1);\n\n  // 4. 인증 미이행/권한 없는 사용자 접근 - 401/403\n  await TestValidator.httpError(\"비로그인 접근 차단\")(401, 403)(async () => {\n    await api.functional.shoppings.sellers.orders.patch({} as any, req);\n  });\n}\n",
  "test/features/api/order/test_get_order_detail_with_valid_and_invalid_id.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport { IShoppingOrder } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingOrder\";\nimport { IShoppingSeller } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSeller\";\nimport { IShoppingSeller as IShoppingSellerJoin } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSeller.IJoin\";\nimport { IShoppingSale } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSale\";\n\nimport { v4 as uuid } from \"uuid\";\n\nexport async function test_get_order_detail_with_valid_and_invalid_id(connection: api.IConnection): Promise<void> {\n  // 1. 인증 (판매자 가입/로그인)\n  // (가입을 위한 입력값 생성이 필요하나, IShoppingSeller.IJoin이 빈 인터페이스이므로 바로 호출)\n  const seller: IShoppingSeller.IInvert = await api.functional.shoppings.sellers.authenticate.post(connection, {});\n  typia.assert<IShoppingSeller.IInvert>(seller);\n\n  // 2. 판매 생성\n  const now = new Date().toISOString();\n  const saleInput = {\n    section_code: \"default-section\",\n    opened_at: now,\n    closed_at: null,\n    content: {\n      title: \"Test Sale\",\n      format: \"md\",\n      body: \"Test body\",\n      files: [],\n      thumbnails: [],\n    },\n    units: [\n      {\n        name: \"Test Unit\",\n        primary: true,\n        required: true,\n        options: [],\n        stocks: [\n          {\n            name: \"StockA\",\n            price: {\n              nominal: 12300,\n              real: 12000,\n            },\n            quantity: 10,\n            choices: [],\n          },\n        ],\n      },\n    ],\n    tags: [\"test\"],\n    category_codes: [],\n    status: null,\n  };\n  const sale = await api.functional.shoppings.sellers.sales.post(connection, saleInput);\n  typia.assert<IShoppingSale>(sale);\n\n  // 3. 주문 발생용 주문 ID 확보 (실제 주문 API가 없으므로, 임시 주문 id 정의 [실전 환경에선 주문 생성후 id 획득])\n  // 아래는 실제 주문이 필요함. 테스트 환경용 가짜 id로 대체\n  const validOrderId = uuid(); // 실제로는 주문 생성 API 필요, 여긴 mock id\n\n  // 4. 주문 상세 조회 (존재하지 않는 id)\n  await TestValidator.httpError(\"not found\") (404)(async () => {\n    await api.functional.shoppings.sellers.orders.get(connection, validOrderId);\n  });\n\n  // 5. (실데이터가 있을 경우) 정상 주문 상세 조회 (아래는 존재하지 않는 주문 id라서 일단 패스)\n  // 실제 주문이 생성되면 아래 사용\n  // const order = await api.functional.shoppings.sellers.orders.get(connection, EXISTING_ORDER_ID);\n  // typia.assert<IShoppingOrder>(order);\n\n  // 6. 임의의 잘못된 형식 id (권한 없음/불법 접근 등) 케이스 - UUID는 타입상 허용되므로 없는 id로 동일하게 not found 처리 검증\n  const randomInvalidId = uuid();\n  await TestValidator.httpError(\"forbidden or not found\") (404)(async () => {\n    await api.functional.shoppings.sellers.orders.get(connection, randomInvalidId);\n  });\n}",
  "test/features/api/sale/test_create_sale_with_valid_and_invalid_input.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingSeller } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSeller\";\nimport { IShoppingSale } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSale\";\nimport { IShoppingSale as IShoppingSaleNS } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSale\";\nimport typia from \"typia\";\n\nexport async function test_create_sale_with_valid_and_invalid_input(connection: api.IConnection): Promise<void> {\n  // 판매자 인증 선행\n  const seller: IShoppingSeller.IInvert = \n    await api.functional.shoppings.sellers.authenticate(connection, {});\n  \n  // 정상 입력 생성\n  const now = new Date().toISOString();\n  const saleInput: IShoppingSaleNS.ICreate = {\n    section_code: \"section-001\",\n    opened_at: now,\n    closed_at: null,\n    content: {\n      title: `test-sale-title-${Date.now()}`,\n      format: \"md\",\n      body: \"Markdown description of the sale.\",\n      files: [\n        {\n          name: \"file1\",\n          extension: \"jpg\",\n          url: \"https://example.com/test1.jpg\"\n        }\n      ],\n      thumbnails: [\n        {\n          name: \"thumb1\",\n          extension: \"png\",\n          url: \"https://example.com/thumb1.png\"\n        }\n      ]\n    },\n    units: [\n      {\n        name: \"unit-main\",\n        primary: true,\n        required: true,\n        options: [\n          {\n            type: \"select\", // selectable option\n            name: \"color\",\n            variable: true,\n            candidates: [\n              { name: \"red\" },\n              { name: \"blue\" }\n            ]\n          }\n        ],\n        stocks: [\n          {\n            name: \"stock-red\",\n            price: { nominal: 10000, real: 9000 },\n            quantity: 50,\n            choices: [\n              { option_index: 0, candidate_index: 0 } // color:red\n            ]\n          },\n          {\n            name: \"stock-blue\",\n            price: { nominal: 10000, real: 9500 },\n            quantity: 30,\n            choices: [\n              { option_index: 0, candidate_index: 1 } // color:blue\n            ]\n          }\n        ]\n      }\n    ],\n    tags: [\"event\", \"new\"],\n    category_codes: [\"cat-01\", \"cat-02\"]\n  };\n\n  // 1. 정상 값 판매 생성 - 성공\n  const created = await api.functional.shoppings.sellers.sales(\n    connection,\n    { body: saleInput }\n  );\n  typia.assert<IShoppingSale>(created);\n  TestValidator.equals(\"created.title\")(\n    saleInput.content.title\n  )(created.content.title);\n  TestValidator.equals(\"created.tags\")(\n    saleInput.tags\n  )(created.tags);\n  TestValidator.equals(\"category_codes length\")(\n    saleInput.category_codes.length\n  )(created.categories.length);\n\n  // 2. 필수값 누락 - section_code 빠짐\n  const inputMissingSection: IShoppingSaleNS.ICreate = {\n    ...saleInput,\n    // @ts-expect-error purposefully omitted for test\n    section_code: undefined,\n  };\n  await TestValidator.httpError(\"필수 section_code 누락시 400 오류\")(400)(async () => {\n    await api.functional.shoppings.sellers.sales(connection, { body: inputMissingSection });\n  });\n\n  // 3. 필수값 누락 - units[0]에 stocks 없음\n  const inputNoStock: IShoppingSaleNS.ICreate = {\n    ...saleInput,\n    units: [\n      {\n        ...saleInput.units[0],\n        // @ts-expect-error\n        stocks: undefined\n      }\n    ]\n  };\n  await TestValidator.httpError(\"필수 unit.stocks 누락시 400 오류\")(400)(async () => {\n    await api.functional.shoppings.sellers.sales(connection, { body: inputNoStock });\n  });\n\n  // 4. 중복/잘못 입력 - units 빈 배열\n  const inputEmptyUnits: IShoppingSaleNS.ICreate = {\n    ...saleInput,\n    units: []\n  };\n  await TestValidator.httpError(\"필수 units가 빈 배열일 때 400 오류\")(400)(async () => {\n    await api.functional.shoppings.sellers.sales(connection, { body: inputEmptyUnits });\n  });\n\n  // 5. 잘못된 타입/필드 - price.nominal 음수\n  const inputNegativePrice: IShoppingSaleNS.ICreate = JSON.parse(JSON.stringify(saleInput));\n  inputNegativePrice.units[0].stocks[0].price.nominal = -5000;\n  await TestValidator.httpError(\"price.nominal 음수면 400 오류\")(400)(async () => {\n    await api.functional.shoppings.sellers.sales(connection, { body: inputNegativePrice });\n  });\n}\n",
  "test/features/api/sale/test_list_sales_with_auth_and_filtering.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingSeller } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSeller\";\nimport { IShoppingSale } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSale\";\nimport { IShoppingSale as IShoppingSaleStructure } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSale\";\nimport { IShoppingSale as IShoppingSaleNamespace } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSale\";\nimport { IPageIShoppingSale } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIShoppingSale\";\nimport typia from \"typia\";\n\nexport async function test_api_sale_list_sales_with_auth_and_filtering(connection: api.IConnection): Promise<void> {\n    // Step 1: 판매자 인증\n    const seller = await api.functional.shoppings.sellers.authenticate(\n        connection,\n        {} as IShoppingSeller.IJoin // 최소 형태, 실제 가입은 선행된다고 가정\n    );\n    typia.assert<IShoppingSeller.IInvert>(seller);\n\n    // Step 2: 판매 등록 (서로 다른 2건 생성, tag/section_code 판별)\n    const saleInput1: IShoppingSaleNamespace.ICreate = {\n        section_code: \"section-A\",\n        status: null,\n        opened_at: new Date().toISOString(),\n        closed_at: null,\n        content: {\n            title: \"SaleItem 1\",\n            format: \"md\",\n            body: \"This is item 1\",\n            files: [],\n            thumbnails: []\n        },\n        units: [\n            {\n                options: [],\n                stocks: [\n                    {\n                        name: \"Basic Stock 1\",\n                        price: { nominal: 10000, real: 9000 },\n                        quantity: 5,\n                        choices: []\n                    }\n                ],\n                name: \"Unit 1\",\n                primary: true,\n                required: true\n            }\n        ],\n        tags: [\"tag-a\"],\n        category_codes: [\"cat-1\"]\n    };\n    const saleInput2: IShoppingSaleNamespace.ICreate = {\n        section_code: \"section-B\",\n        status: null,\n        opened_at: new Date().toISOString(),\n        closed_at: null,\n        content: {\n            title: \"SaleItem 2\",\n            format: \"md\",\n            body: \"This is item 2\",\n            files: [],\n            thumbnails: []\n        },\n        units: [\n            {\n                options: [],\n                stocks: [\n                    {\n                        name: \"Basic Stock 2\",\n                        price: { nominal: 20000, real: 18000 },\n                        quantity: 10,\n                        choices: []\n                    }\n                ],\n                name: \"Unit 2\",\n                primary: true,\n                required: true\n            }\n        ],\n        tags: [\"tag-b\"],\n        category_codes: [\"cat-2\"]\n    };\n    const sale1 = await api.functional.shoppings.sellers.sales(\n        connection,\n        saleInput1\n    );\n    typia.assert<IShoppingSaleStructure>(sale1);\n\n    const sale2 = await api.functional.shoppings.sellers.sales(\n        connection,\n        saleInput2\n    );\n    typia.assert<IShoppingSaleStructure>(sale2);\n\n    // Step 3-1: 기본 판매 목록 전체 조회\n    const pageRes = await api.functional.shoppings.sellers.sales.patch(\n        connection,\n        {} as IShoppingSaleNamespace.IRequest\n    );\n    typia.assert<IPageIShoppingSale.ISummary>(pageRes);\n    TestValidator.predicate(\"list includes sale1\")(() => pageRes.data.some(row => row.id === sale1.id));\n    TestValidator.predicate(\"list includes sale2\")(() => pageRes.data.some(row => row.id === sale2.id));\n\n    // Step 3-2: 페이징 (limit=1) 결과 확인\n    const pageOne = await api.functional.shoppings.sellers.sales.patch(\n        connection,\n        { limit: 1 } as IShoppingSaleNamespace.IRequest\n    );\n    typia.assert<IPageIShoppingSale.ISummary>(pageOne);\n    TestValidator.equals(\"1 per page\")(1)(pageOne.pagination.limit);\n    TestValidator.equals(\"length=1\")(1)(pageOne.data.length);\n\n    // Step 3-3: 정렬/필터 조작 예시 (실제 API에서 동작하는 필드를 활용해 확인)\n    // (여기서는 limit, 기본 정렬 정도로 검증. 추가 검색 옵션 있으면 여기에 추가!)\n    const sortByCreatedAt = await api.functional.shoppings.sellers.sales.patch(\n        connection,\n        { sort: [\"-sale.created_at\"] } as IShoppingSaleNamespace.IRequest\n    );\n    typia.assert<IPageIShoppingSale.ISummary>(sortByCreatedAt);\n    // 최신순 정렬, 첫 번째가 sale2인지 확인 (동일한 시간에 생성 시 무작위 가능성 존재)\n    TestValidator.predicate(\"sale2 is latest or among top\")(\n        () => sortByCreatedAt.data.some(row => row.id === sale2.id)\n    );\n\n    // Step 4: 미로그인, 인증 없이 요청 시 에러 확인 (권한 없음 401 등)\n    await TestValidator.httpError(\"unauthorized blocked\")(401)(async () => {\n        await api.functional.shoppings.sellers.sales.patch(\n            { ...connection, headers: {} }, // 인증 정보 제거\n            {} as IShoppingSaleNamespace.IRequest\n        );\n    });\n}\n",
  "test/features/api/sale/test_get_sale_detail_with_valid_and_invalid_id.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingSale } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSale\";\nimport { IShoppingSale as ICreate, IShoppingSaleContent as IContent, IShoppingSaleUnit as IUnit, IShoppingSaleUnitStock as IStock, IShoppingPrice } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSale\";\nimport typia from \"typia\";\n\nexport async function test_api_sale_detail_with_valid_and_invalid_id(connection: api.IConnection): Promise<void> {\n    // 1. 판매자 인증 (세션 획득)\n    await api.functional.shoppings.sellers.authenticate.post(connection, {});\n\n    // 2. 판매 생성용 데이터 준비\n    // 최소 필수 필드만 채운다\n    const now = new Date().toISOString();\n    const saleInput: ICreate.ICreate = {\n        section_code: \"SECTION-001\",\n        status: null,\n        opened_at: now,\n        closed_at: null,\n        content: {\n            title: \"테스트 상품\",\n            format: \"md\",\n            body: \"테스트 상세 설명입니다.\",\n            files: [],\n            thumbnails: []\n        },\n        units: [\n            {\n                options: [],\n                stocks: [\n                    {\n                        name: \"첫번째 재고\",\n                        price: { nominal: 10000, real: 8000 },\n                        quantity: 10,\n                        choices: []\n                    }\n                ],\n                name: \"구성품1\",\n                primary: true,\n                required: true\n            }\n        ],\n        tags: [\"테스트\", \"sale-e2e\"],\n        category_codes: [\"CATEGORY-001\"]\n    };\n\n    // 3. 판매 생성 API 호출\n    const sale = await api.functional.shoppings.sellers.sales.post(connection, saleInput);\n    typia.assert<IShoppingSale>(sale);\n\n    // 4. 판매 상세 정상 조회\n    const detail = await api.functional.shoppings.sellers.sales.get(connection, sale.id);\n    typia.assert<IShoppingSale>(detail);\n    TestValidator.equals(\"판매 상세 조회 값 일치\")(sale)(detail);\n\n    // 5. 존재하지 않는 판매 ID로 조회 - 404 에러 기대\n    const invalidId = \"11111111-1111-1111-1111-111111111111\";\n    await TestValidator.httpError(\"존재하지 않는 판매ID는 404이어야 함\")(404)(() =>\n        api.functional.shoppings.sellers.sales.get(connection, invalidId)\n    );\n\n    // 6. 인증 없이 요청 시 권한 에러 (401 또는 403)\n    // 인증 해제를 위해 connection 복제/변형(로그아웃 등) 대신, 인증 없이 새로 연결한다고 가정\n    const unauthConnection: api.IConnection = { ...connection, headers: {} };\n    await TestValidator.httpError(\"비인증 접근시 401 또는 403\" )(401, 403)(() =>\n        api.functional.shoppings.sellers.sales.get(unauthConnection, sale.id)\n    );\n}\n",
  "test/features/api/sale/test_create_answer_to_sale_question_with_valid_and_invalid_conditions.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingSale } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSale\";\nimport { IPageIShoppingSale } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIShoppingSale\";\nimport { IShoppingSaleQuestion } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleQuestion\";\nimport { IPageIShoppingSaleQuestion } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIShoppingSaleQuestion\";\nimport { IBbsArticle } from \"@ORGANIZATION/PROJECT-api/lib/structures/IBbsArticle\";\nimport { IShoppingSaleInquiryAnswer } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryAnswer\";\nimport { IBbsArticle as IBbsArticleNS } from \"@ORGANIZATION/PROJECT-api/lib/structures/IBbsArticle\";\nimport typia from \"typia\";\n\nexport async function test_api_create_answer_to_sale_question_with_valid_and_invalid_conditions(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. 판매 요약 리스트 조회 (테스트용 Sale ID 준비)\n  const saleList = await api.functional.shoppings.sellers.sales.patch(connection, {});\n  typia.assert<IPageIShoppingSale.ISummary>(saleList);\n  TestValidator.predicate(\"at least one sale to answer\")(() => saleList.data.length > 0);\n  const sale = saleList.data[0];\n\n  // 2. 해당 판매의 질문 리스트 조회 (테스트용 Question ID 준비)\n  const questionList = await api.functional.shoppings.sellers.sales.questions.patch(\n    connection,\n    sale.id,\n    {},\n  );\n  typia.assert<IPageIShoppingSaleQuestion.ISummary>(questionList);\n  TestValidator.predicate(\"at least one question for sale\")(\n    () => questionList.data.length > 0,\n  );\n  const question = questionList.data[0];\n\n  // 3. 정상 답변 작성\n  const validAnswerInput: IBbsArticleNS.ICreate = {\n    format: \"md\",\n    title: \"판매 답변 예시 타이틀\",\n    body: \"이것은 테스트용 판매 답변 본문입니다.\",\n    files: [],\n  };\n  const answer = await api.functional.shoppings.sellers.sales.questions.answer.post(\n    connection,\n    sale.id,\n    question.id,\n    validAnswerInput,\n  );\n  typia.assert<IShoppingSaleInquiryAnswer>(answer);\n  TestValidator.equals(\"answer.questionId\")(() => question.id)(answer.id);\n  TestValidator.predicate(\"answer snapshots exist\")(() => answer.snapshots.length > 0);\n\n  // 4. 이미 존재하는 답변에 재답변 시도(중복방지)\n  await TestValidator.httpError(\"duplicate answer is blocked\")(409)(async () => {\n    await api.functional.shoppings.sellers.sales.questions.answer.post(\n      connection,\n      sale.id,\n      question.id,\n      validAnswerInput,\n    );\n  });\n\n  // 5. 답변 입력값이 비정상 (title 빠짐)\n  const invalidAnswerNoTitle = {\n    ...validAnswerInput,\n  } as any;\n  delete invalidAnswerNoTitle.title;\n  await TestValidator.httpError(\"missing title validation\")(400)(async () => {\n    await api.functional.shoppings.sellers.sales.questions.answer.post(\n      connection,\n      sale.id,\n      question.id,\n      invalidAnswerNoTitle,\n    );\n  });\n\n  // 6. 답변 입력값이 비정상 (body 비움)\n  const invalidAnswerEmptyBody: IBbsArticleNS.ICreate = {\n    ...validAnswerInput,\n    body: \"\",\n  };\n  await TestValidator.httpError(\"empty body validation\")(400)(async () => {\n    await api.functional.shoppings.sellers.sales.questions.answer.post(\n      connection,\n      sale.id,\n      question.id,\n      invalidAnswerEmptyBody,\n    );\n  });\n}\n",
  "test/features/api/answer/test_update_answer_to_sale_question_with_valid_and_invalid_conditions.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IBbsArticle } from \"@ORGANIZATION/PROJECT-api/lib/structures/IBbsArticle\";\nimport { IBbsArticle_ICreate } from \"@ORGANIZATION/PROJECT-api/lib/structures/IBbsArticle\";\nimport { IShoppingSaleInquiryAnswer } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryAnswer\";\nimport { IShoppingSaleInquiryAnswer_ISnapshot } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryAnswer\";\nimport typia from \"typia\";\n\nexport async function test_update_answer_to_sale_question_with_valid_and_invalid_conditions(connection: api.IConnection): Promise<void> {\n    // 1. 생성: 특정 판매 건과 질문 준비\n    const saleId = \"11111111-1111-1111-1111-111111111111\";\n    const questionId = \"22222222-2222-2222-2222-222222222222\";\n\n    // 질문 요약 목록을 가져와서 없으면 실제 흐름에 맞게 질문이 있다고 가정\n    // 만약 API에서 생성 기능이 없다면, 테스트 전제 하에 ID를 세팅\n\n    // 2. 기존 답변 등록\n    const createBody: IBbsArticle_ICreate = {\n        format: \"md\",\n        title: \"초기 답변 제목\",\n        body: \"초기 답변 본문입니다.\",\n        files: []\n    };\n    const answer = await api.functional.shoppings.sellers.sales.questions.answer.post(connection, saleId, questionId, createBody);\n    typia.assert<IShoppingSaleInquiryAnswer>(answer);\n    TestValidator.equals(\"초기 답변 - 제목\")<string>(createBody.title)(answer.snapshots[0].title);\n    TestValidator.equals(\"초기 답변 - 본문\")<string>(createBody.body)(answer.snapshots[0].body);\n\n    // 3. 정상적으로 답변 수정\n    const updateBody: IBbsArticle_ICreate = {\n        format: \"md\",\n        title: \"수정된 답변 제목\",\n        body: \"수정된 답변 내용입니다.\",\n        files: []\n    };\n    const updatedSnapshot = await api.functional.shoppings.sellers.sales.questions.answer.put(connection, saleId, questionId, updateBody);\n    typia.assert<IShoppingSaleInquiryAnswer_ISnapshot>(updatedSnapshot);\n    TestValidator.equals(\"수정된 답변 - 제목\")<string>(updateBody.title)(updatedSnapshot.title);\n    TestValidator.equals(\"수정된 답변 - 본문\")<string>(updateBody.body)(updatedSnapshot.body);\n\n    // 4. 필수값 누락, 빈 값 등 유효성 실패케이스\n    const invalidBodies: IBbsArticle_ICreate[] = [\n        // 제목 없음\n        { ...updateBody, title: \"\" },\n        // 본문 없음\n        { ...updateBody, body: \"\" },\n        // 형식 잘못됨\n        { ...updateBody, format: \"invalid\" as any },\n    ];\n    for (const body of invalidBodies) {\n        await TestValidator.httpError(\"유효성 실패시 400\")\n          (400)\n          (() => api.functional.shoppings.sellers.sales.questions.answer.put(connection, saleId, questionId, body));\n    }\n\n    // 5. 답변이 없는 상태에서 수정 시도 (존재하지 않는 질문 id)\n    const notExistQuestionId = \"33333333-3333-3333-3333-333333333333\";\n    await TestValidator.httpError(\"존재하지 않는 질문의 답변수정시 404\")\n      (404)\n      (() => api.functional.shoppings.sellers.sales.questions.answer.put(connection, saleId, notExistQuestionId, updateBody));\n}\n",
  "test/features/api/comment/test_create_comment_on_sale_question_with_all_edge_cases.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingSaleInquiryComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment\";\nimport { IShoppingSaleInquiryComment as ICreate } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment.ICreate\";\nimport { IAttachmentFile } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAttachmentFile.ICreate\";\nimport { IPageIShoppingSaleQuestion } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIShoppingSaleQuestion.ISummary\";\nimport { IShoppingSaleQuestion } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleQuestion.ISummary\";\nimport typia from \"typia\";\n\nexport async function test_create_comment_on_sale_question_with_all_edge_cases(connection: api.IConnection): Promise<void> {\n  // 0. 질문글 샘플 추출 (판매 ID/질문 ID 확보)\n  const saleId = \"ffffffff-ffff-ffff-ffff-ffffffffffff\"; // 테스트용 임의 UUID (존재하는 sale로 대체 필요)\n  const questionsResult: IPageIShoppingSaleQuestion = await api.functional.shoppings.sellers.sales.questions.patch(connection, saleId, {});\n  typia.assert<IPageIShoppingSaleQuestion>(questionsResult);\n  const question = questionsResult.data.length > 0 ? questionsResult.data[0] : undefined;\n  TestValidator.predicate(\"질문 목록에 최소 1개 질문 있어야 함\")(() => !!question);\n  const inquiryId = question!.id;\n\n  // 1. 정상 입력: 필수값 모두 입력, 적정 길이\n  const normalInput: ICreate.ICreate = {\n    format: \"md\",\n    body: \"정상적인 코멘트 본문입니다.\",\n    files: [\n      {\n        name: \"sample-image\",\n        extension: \"png\",\n        url: \"https://cdn.example.com/image.png\",\n      },\n    ],\n  };\n\n  const result: IShoppingSaleInquiryComment = await api.functional.shoppings.sellers.sales.questions.comments.post(\n    connection, saleId, inquiryId, normalInput\n  );\n  typia.assert<IShoppingSaleInquiryComment>(result);\n  TestValidator.equals(\"입력값 format 반영됨\")(<ICreate.ICreate>(normalInput))(\n    result.snapshots[0]\n  );\n\n  // 2. 필수 필드 누락 등 invalid 입력\n  // body 누락\n  await TestValidator.httpError(\"body 미입력 오류\", 400)(async () =>\n    api.functional.shoppings.sellers.sales.questions.comments.post(\n      connection, saleId, inquiryId, { ...normalInput, body: \"\" }\n    )\n  );\n  // format 미입력\n  await TestValidator.httpError(\"format 미입력 오류\", 400)(async () =>\n    api.functional.shoppings.sellers.sales.questions.comments.post(\n      connection, saleId, inquiryId, { ...normalInput, format: undefined as any }\n    )\n  );\n  // files 미입력/빈배열\n  await TestValidator.httpError(\"files 필수 오류\", 400)(async () =>\n    api.functional.shoppings.sellers.sales.questions.comments.post(\n      connection, saleId, inquiryId, { ...normalInput, files: undefined as any }\n    )\n  );\n  await TestValidator.httpError(\"files 빈배열 오류\", 400)(async () =>\n    api.functional.shoppings.sellers.sales.questions.comments.post(\n      connection, saleId, inquiryId, { ...normalInput, files: [] as IAttachmentFile[] }\n    )\n  );\n  // 파일 필드 누락\n  await TestValidator.httpError(\"파일 name 누락 오류\", 400)(async () =>\n    api.functional.shoppings.sellers.sales.questions.comments.post(\n      connection, saleId, inquiryId, {\n        ...normalInput,\n        files: [{ extension: \"jpg\", url: \"https://cdn.example.com/x.jpg\" } as any],\n      }\n    )\n  );\n\n  // 3. 존재하지 않는 sale/inquiry ID로 요청\n  const fakeSaleId = \"00000000-0000-4000-8000-000000000000\";\n  const fakeInquiryId = \"11111111-1111-4111-8111-111111111111\";\n  await TestValidator.httpError(\"존재하지 않는 saleId\", 404)(async () =>\n    api.functional.shoppings.sellers.sales.questions.comments.post(\n      connection, fakeSaleId, inquiryId, normalInput\n    )\n  );\n  await TestValidator.httpError(\"존재하지 않는 inquiryId\", 404)(async () =>\n    api.functional.shoppings.sellers.sales.questions.comments.post(\n      connection, saleId, fakeInquiryId, normalInput\n    )\n  );\n\n  // 4. 본문/body 과도한 길이\n  const longBody = \"x\".repeat(5001);\n  await TestValidator.httpError(\"body 과도한 길이 오류\", 400)(async () =>\n    api.functional.shoppings.sellers.sales.questions.comments.post(\n      connection, saleId, inquiryId, { ...normalInput, body: longBody }\n    )\n  );\n\n  // 파일 필드 길이 초과\n  await TestValidator.httpError(\"파일명 길이 초과 오류\", 400)(async () =>\n    api.functional.shoppings.sellers.sales.questions.comments.post(\n      connection, saleId, inquiryId, {\n        ...normalInput,\n        files: [{ ...normalInput.files[0], name: \"a\".repeat(256) }],\n      }\n    )\n  );\n  await TestValidator.httpError(\"확장자 길이 초과 오류\", 400)(async () =>\n    api.functional.shoppings.sellers.sales.questions.comments.post(\n      connection, saleId, inquiryId, {\n        ...normalInput,\n        files: [{ ...normalInput.files[0], extension: \"x\".repeat(9) }],\n      }\n    )\n  );\n\n  await TestValidator.httpError(\"url 이상값 오류\", 400)(async () =>\n    api.functional.shoppings.sellers.sales.questions.comments.post(\n      connection, saleId, inquiryId, {\n        ...normalInput,\n        files: [{ ...normalInput.files[0], url: \"not-a-url\" }],\n      }\n    )\n  );\n}\n",
  "test/features/api/shopping-inquiry-comment/test_list_comments_of_sale_question_with_various_conditions.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport { IShoppingSaleInquiryComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment\";\nimport { IShoppingSaleInquiryComment as ICommentNS } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment\";\nimport { IPageIShoppingSaleInquiryComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIShoppingSaleInquiryComment\";\n\nexport async function test_api_list_comments_of_sale_question_with_various_conditions(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. 사전 데이터: 임의의 saleId, inquiryId 준비 및 여러 코멘트 작성\n  const saleId = \"11111111-1111-4111-8111-111111111111\";\n  const inquiryId = \"22222222-2222-4222-8222-222222222222\";\n  const commentBodies = [\"First comment\", \"Second comment\", \"Third reply\"];\n\n  const file = {\n    name: \"doc\",\n    extension: \"txt\",\n    url: \"https://cdn.example.com/file1.txt\",\n  };\n\n  for (const body of commentBodies) {\n    const request: ICommentNS.ICreate = {\n      format: \"txt\",\n      body,\n      files: [file],\n    };\n    await api.functional.shoppings.sellers.sales.questions.comments.post(\n      connection,\n      saleId,\n      inquiryId,\n      request,\n    );\n  }\n\n  // 2. 정상 목록 조회\n  const reqDefault: ICommentNS.IRequest = {};\n  const pageDefault = await api.functional.shoppings.sellers.sales.questions.comments.patch(\n    connection,\n    saleId,\n    inquiryId,\n    reqDefault,\n  );\n  typia.assert<IPageIShoppingSaleInquiryComment>(pageDefault);\n  TestValidator.predicate(\"default data count\")(\n    () => pageDefault.data.length >= 3,\n  );\n\n  // 3. 페이징 옵션(limit=2, page=0)\n  const reqPaging: ICommentNS.IRequest = { limit: 2, page: 0 };\n  const pagePaging = await api.functional.shoppings.sellers.sales.questions.comments.patch(\n    connection,\n    saleId,\n    inquiryId,\n    reqPaging,\n  );\n  typia.assert<IPageIShoppingSaleInquiryComment>(pagePaging);\n  TestValidator.equals(\"pagination.limit\")<number>(2)(pagePaging.pagination.limit);\n  TestValidator.predicate(\"pagination.records>=3\")(\n    () => pagePaging.pagination.records >= 3,\n  );\n  TestValidator.equals(\"data.length==2\")<number>(2)(pagePaging.data.length);\n\n  // 4. 검색(body=Second)\n  const reqSearch: ICommentNS.IRequest = { search: { body: \"Second\" } };\n  const pageSearched = await api.functional.shoppings.sellers.sales.questions.comments.patch(\n    connection,\n    saleId,\n    inquiryId,\n    reqSearch,\n  );\n  typia.assert<IPageIShoppingSaleInquiryComment>(pageSearched);\n  TestValidator.predicate(\"search matched one entry\")(\n    () => pageSearched.data.some((c) => c.snapshots[0].body.includes(\"Second\")),\n  );\n\n  // 5. 정렬(오름차순, 내림차순)\n  const reqSortAsc: ICommentNS.IRequest = { sort: [\"+created_at\"] };\n  const pageAsc = await api.functional.shoppings.sellers.sales.questions.comments.patch(\n    connection,\n    saleId,\n    inquiryId,\n    reqSortAsc,\n  );\n  typia.assert<IPageIShoppingSaleInquiryComment>(pageAsc);\n\n  const isAsc = (arr: IShoppingSaleInquiryComment[]) =>\n    arr.every((v, i, a) => i === 0 || a[i - 1].created_at <= v.created_at);\n  TestValidator.predicate(\"asc order\")(() => isAsc(pageAsc.data));\n\n  const reqSortDesc: ICommentNS.IRequest = { sort: [\"-created_at\"] };\n  const pageDesc = await api.functional.shoppings.sellers.sales.questions.comments.patch(\n    connection,\n    saleId,\n    inquiryId,\n    reqSortDesc,\n  );\n  typia.assert<IPageIShoppingSaleInquiryComment>(pageDesc);\n  const isDesc = (arr: IShoppingSaleInquiryComment[]) =>\n    arr.every((v, i, a) => i === 0 || a[i - 1].created_at >= v.created_at);\n  TestValidator.predicate(\"desc order\")(() => isDesc(pageDesc.data));\n\n  // 6. 존재하지 않는 saleId/inquiryId로 조회(404 등 에러)\n  await TestValidator.httpError(\"not found saleId\")(404)(async () =>\n    api.functional.shoppings.sellers.sales.questions.comments.patch(\n      connection,\n      \"00000000-0000-0000-0000-000000000000\",\n      inquiryId,\n      {},\n    ),\n  );\n  await TestValidator.httpError(\"not found inquiryId\")(404)(async () =>\n    api.functional.shoppings.sellers.sales.questions.comments.patch(\n      connection,\n      saleId,\n      \"00000000-0000-0000-0000-000000000000\",\n      {},\n    ),\n  );\n}\n",
  "test/features/api/comment/test_get_single_comment_on_sale_question_with_edge_cases.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport { IShoppingSaleInquiryComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment\";\nimport { IShoppingSaleInquiryComment as IComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment\";\n\nexport async function test_api_get_single_comment_on_sale_question_with_edge_cases(connection: api.IConnection): Promise<void> {\n    // 1. 준비: 유효한 saleId, inquiryId, commentId를 생성하기 위해 comment 작성 API 활용\n    const saleId = \"00000000-0000-4000-8000-000000000001\";\n    const inquiryId = \"00000000-0000-4000-8000-000000000002\";\n    const commentBody: IComment.ICreate = {\n        format: \"txt\",\n        body: \"first comment\",\n        files: []\n    };\n    // 실제로는 sale/inquiry를 미리 생성해야 하지만, 주어진 API 내에서 comment만 조작 가능하다고 가정\n    const created = await api.functional.shoppings.sellers.sales.questions.comments.post(\n        connection, saleId, inquiryId, commentBody\n    );\n    typia.assert<IComment>(created);\n    TestValidator.predicate(\"created has id\")(() => !!created.id);\n    // 2. 정상 단건조회\n    const read = await api.functional.shoppings.sellers.sales.questions.comments.get(\n        connection, saleId, inquiryId, created.id\n    );\n    typia.assert<IComment>(read);\n    TestValidator.equals(\"read match create\")(created)(read);\n\n    // 3. 없는 comment ID\n    await TestValidator.httpError(\"404 for non-existent comment id\")(404)(async () => {\n        await api.functional.shoppings.sellers.sales.questions.comments.get(\n            connection, saleId, inquiryId, \"99999999-aaaa-bbbb-cccc-eeeeeeeeeeee\"\n        );\n    });\n    // 4. 없는 inquiry ID\n    await TestValidator.httpError(\"404 for non-existent inquiry id\")(404)(async () => {\n        await api.functional.shoppings.sellers.sales.questions.comments.get(\n            connection, saleId, \"99999999-4444-9999-8888-777777777777\", created.id);\n    });\n    // 5. 없는 sale ID\n    await TestValidator.httpError(\"404 for non-existent sale id\")(404)(async () => {\n        await api.functional.shoppings.sellers.sales.questions.comments.get(\n            connection, \"99998888-1234-2345-3456-456745674567\", inquiryId, created.id\n        );\n    });\n}\n",
  "test/features/api/comment/test_update_comment_on_sale_question_with_author_and_validation_checks.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IShoppingSaleInquiryComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment\";\nimport { IShoppingSaleInquiryComment as InquiryCommentNS } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryComment\";\nimport { IAttachmentFile } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAttachmentFile\";\nimport typia from \"typia\";\n\nexport async function test_update_comment_on_sale_question_with_author_and_validation_checks(\n  connection: api.IConnection,\n  saleId: string,\n  inquiryId: string,\n  authorConnection: api.IConnection,\n  nonAuthorConnection: api.IConnection,\n): Promise<void> {\n  // 1. 작성자 계정으로 코멘트 생성\n  const createInput: InquiryCommentNS.ICreate = {\n    format: \"txt\",\n    body: \"Original comment body\",\n    files: [\n      {\n        name: \"sample\",\n        extension: \"txt\",\n        url: \"https://domain.com/file1.txt\",\n      },\n    ],\n  };\n  const comment = await api.functional.shoppings.sellers.sales.questions.comments.post(\n    authorConnection,\n    saleId,\n    inquiryId,\n    createInput,\n  );\n  typia.assert<IShoppingSaleInquiryComment>(comment);\n\n  // 2. 작성자가 올바르게 코멘트 내용을 수정 (성공)\n  const updateInput: InquiryCommentNS.ICreate = {\n    format: \"md\",\n    body: \"Updated comment by author\",\n    files: [\n      {\n        name: \"updated\",\n        extension: \"md\",\n        url: \"https://domain.com/file2.md\",\n      },\n    ],\n  };\n  const snapshot = await api.functional.shoppings.sellers.sales.questions.comments.put(\n    authorConnection,\n    saleId,\n    inquiryId,\n    comment.id,\n    updateInput,\n  );\n  typia.assert<InquiryCommentNS.ISnapshot>(snapshot);\n  TestValidator.equals(\"update by author should change content\")(\n    updateInput.body,\n  )(snapshot.body);\n  TestValidator.equals(\"update by author should change format\")(\n    updateInput.format,\n  )(snapshot.format);\n  TestValidator.equals(\"update by author should change files\")(\n    updateInput.files,\n  )(snapshot.files);\n\n  // 3. 비작성자가 해당 코멘트 수정 시도 (권한 에러 발생)\n  await TestValidator.httpError(\"non-author should not be able to update comment\")(403, 401)(async () => {\n    await api.functional.shoppings.sellers.sales.questions.comments.put(\n      nonAuthorConnection,\n      saleId,\n      inquiryId,\n      comment.id,\n      updateInput,\n    );\n  });\n\n  // 4. 유효성 검사 실패 케이스: body가 빈 경우\n  const invalidBodyInput: InquiryCommentNS.ICreate = {\n    format: \"txt\",\n    body: \"\",\n    files: [\n      {\n        name: \"a\",\n        extension: \"txt\",\n        url: \"https://domain.com/file3.txt\",\n      },\n    ],\n  };\n  await TestValidator.httpError(\"empty body should fail validation\")(400, 422)(async () => {\n    await api.functional.shoppings.sellers.sales.questions.comments.put(\n      authorConnection,\n      saleId,\n      inquiryId,\n      comment.id,\n      invalidBodyInput,\n    );\n  });\n\n  // 5. 유효성 검사 실패 케이스: files 누락 (빈 배열로)\n  const invalidFilesInput: InquiryCommentNS.ICreate = {\n    format: \"txt\",\n    body: \"Valid non-empty body\",\n    files: [],\n  };\n  await TestValidator.httpError(\"missing files should fail validation\")(400, 422)(async () => {\n    await api.functional.shoppings.sellers.sales.questions.comments.put(\n      authorConnection,\n      saleId,\n      inquiryId,\n      comment.id,\n      invalidFilesInput,\n    );\n  });\n}\n",
  "test/features/api/shopping-sale-question/test_list_questions_of_sale_with_various_conditions.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport { IShoppingSaleQuestion } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleQuestion\";\nimport { IPageIShoppingSaleQuestion } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIShoppingSaleQuestion\";\n\nexport async function test_list_questions_of_sale_with_various_conditions(connection: api.IConnection): Promise<void> {\n    // 1. 사전 데이터(여러 질문 등록) - 실제 환경에선 여기에 POST API로 질문들 생성 필요\n    // 판매 상품 임의 UUID, 실제 환경에서는 사전에 생성된 saleId 사용해야 함\n    const saleId = \"11111111-1111-4111-8111-111111111111\";\n    // ...사전에 필요시 질문글 생성 (여기선 가정)\n\n    // 2. 기본 목록 조회\n    const baseReq: IShoppingSaleQuestion.IRequest = {};\n    const result = await api.functional.shoppings.sellers.sales.questions.patch(connection, saleId, baseReq);\n    typia.assert<IPageIShoppingSaleQuestion.ISummary>(result);\n    TestValidator.predicate(\"data must exists\")(() => result.data.length >= 0);\n    TestValidator.predicate(\"pagination must be valid\")(() => result.pagination != null);\n\n    // 3. 필터링: 타이틀 포함 검색\n    const titleSearchReq: IShoppingSaleQuestion.IRequest = {\n        search: { title: \"질문\" }\n    };\n    const titleResult = await api.functional.shoppings.sellers.sales.questions.patch(connection, saleId, titleSearchReq);\n    typia.assert<IPageIShoppingSaleQuestion.ISummary>(titleResult);\n    TestValidator.predicate(\"타이틀 포함 결과\")(() => titleResult.data.every(q => q.title.includes(\"질문\")));\n\n    // 3-2. 답변 여부로 필터\n    const answeredReq: IShoppingSaleQuestion.IRequest = {\n        search: { answered: true }\n    };\n    const answeredResult = await api.functional.shoppings.sellers.sales.questions.patch(connection, saleId, answeredReq);\n    typia.assert<IPageIShoppingSaleQuestion.ISummary>(answeredResult);\n    TestValidator.predicate(\"모든 항목이 answer 있음\")(() => answeredResult.data.every(q => q.answer !== null));\n\n    // 3-3. 비공개로 필터\n    const secretReq: IShoppingSaleQuestion.IRequest = {\n        search: {},\n    };\n    const secretResult = await api.functional.shoppings.sellers.sales.questions.patch(connection, saleId, secretReq);\n    typia.assert<IPageIShoppingSaleQuestion.ISummary>(secretResult);\n    // 실제 secret값이 있는지 체크, secret 값이 있을 경우에만\n    if (secretResult.data.some(q => q.secret)) {\n        TestValidator.predicate(\"secret 질문이 있음\")(() => secretResult.data.some(q => q.secret === true));\n    }\n\n    // 4. 정렬 테스트 - 최신순(created_at desc)\n    const sortReq: IShoppingSaleQuestion.IRequest = {\n        sort: [\"-created_at\"]\n    };\n    const sortedResult = await api.functional.shoppings.sellers.sales.questions.patch(connection, saleId, sortReq);\n    typia.assert<IPageIShoppingSaleQuestion.ISummary>(sortedResult);\n    TestValidator.predicate(\"내림차순 정렬\")(() => {\n        for (let i = 1; i < sortedResult.data.length; ++i) {\n            if (new Date(sortedResult.data[i - 1].created_at).getTime() < new Date(sortedResult.data[i].created_at).getTime())\n                return false;\n        }\n        return true;\n    });\n\n    // 5. 페이징(limit 2)\n    const pagingReq: IShoppingSaleQuestion.IRequest = {\n        limit: 2,\n        page: 0\n    };\n    const pagedResult = await api.functional.shoppings.sellers.sales.questions.patch(connection, saleId, pagingReq);\n    typia.assert<IPageIShoppingSaleQuestion.ISummary>(pagedResult);\n    TestValidator.equals(\"limit 일치\")(\n        pagingReq.limit ?? 0\n    )(pagedResult.data.length);\n    TestValidator.equals(\"pagination 정보 일치\")(pagingReq.page ?? 0)(pagedResult.pagination.current);\n\n    // 6. 잘못된 saleId(존재하지 않음)\n    const invalidId = \"00000000-1111-4111-8111-999999999999\";\n    await TestValidator.httpError(\"존재하지 않는 saleId\", 404)(() =>\n        api.functional.shoppings.sellers.sales.questions.patch(connection, invalidId, baseReq)\n    );\n    // saleId가 UUID가 아닐 경우\n    const malformedId = \"NOT-UUID\";\n    await TestValidator.httpError(\"UUID 아님\", 400)(() =>\n        api.functional.shoppings.sellers.sales.questions.patch(connection, malformedId, baseReq)\n    );\n}\n",
  "test/features/api/shopping-sale-question/test_list_abridged_questions_of_sale_with_error_conditions.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport { IPageIShoppingSaleQuestion_IAbridge } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIShoppingSaleQuestion.IAbridge\";\nimport { IShoppingSaleQuestion_IRequest } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleQuestion.IRequest\";\n// 아래 타입은 dependsOn에 따라 질문 생성에 필요할 수 있으나 명확하지 않아 임시 생략\n// import { IShoppingSaleQuestionInput } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleQuestionInput\";\n\nexport async function test_list_abridged_questions_of_sale_with_error_conditions(connection: api.IConnection): Promise<void> {\n  // 1. 테스트용 판매 상품 및 질문글 생성 (의존: /shoppings/sellers/sales/{saleId}/questions)\n  // 아래는 판매 상품과 질문글을 생성하는 의존 테스트 헬퍼 함수가 필요하다고 가정함\n  // 해당 함수가 없다면 직접 saleId와 질문글 생성을 위한 값 작성 필요\n\n  const saleId = await generate_test_sale_with_questions(connection);\n\n  // 2. 정상 요약 질문글 목록 응답\n  const request: IShoppingSaleQuestion_IRequest = {\n    search: null,\n    sort: null,\n    page: 0,\n    limit: 10\n  };\n  const page = await api.functional.shoppings.sellers.sales.questions.patchAbridges(connection, saleId, request);\n\n  typia.assert<IPageIShoppingSaleQuestion_IAbridge>(page);\n  TestValidator.predicate(\"list is not empty\")(() => page.data.length > 0);\n\n  // 3. 반환 데이터가 실제 등록 질문글을 포함하는지 확인\n  // 여기서는 질문글 내용을 미리 알 수 없으나 정상 등록/조회로 충분\n\n  // 4. 오류 케이스: 존재하지 않는 saleId 요청\n  const invalidSaleId = \"00000000-0000-4000-8000-000000000000\";\n  await TestValidator.httpError(\"should fail on non-existent sale id\")(404)(\n    () => api.functional.shoppings.sellers.sales.questions.patchAbridges(connection, invalidSaleId, request),\n  );\n}\n\n// 테스트 전용 판매 상품 + 질문글 등록을 위한 간단 설명용 헬퍼(생략/가정)\n// 실제 환경에서는 test fixture 또는 nested test에서 미리 판매/질문글 생성 필요\n// async function generate_test_sale_with_questions(...) { ... }\n",
  "test/features/api/shopping-sale-question/test_get_single_question_of_sale_with_permission_and_notfound.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport { IShoppingSaleQuestion } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleQuestion\";\n\nexport async function test_api_get_single_question_of_sale_with_permission_and_notfound(connection: api.IConnection): Promise<void> {\n  // 1. 사전 데이터 준비: seller(판매자), customer(작성자), stranger(권한 없는 고객)\n  const seller = await generate_random_shopping_seller(connection);\n  const customer = await generate_random_shopping_customer(connection);\n  const stranger = await generate_random_shopping_customer(connection);\n  const sale = await generate_random_shopping_sale(connection, seller.id);\n\n  // 2. 질문 등록 (비공개)\n  const questionInput = await generate_shopping_sale_question_input(connection, {\n    secret: true,\n  });\n  const question = await api.functional.shoppings.sellers.sales.questions.post(connection, sale.id, {\n    body: questionInput,\n  });\n  typia.assert<IShoppingSaleQuestion>(question);\n\n  // 3-1. 질문 작성자인 customer가 정상 조회\n  const readByCustomer = await api.functional.shoppings.sellers.sales.questions.get(\n    customer,\n    sale.id,\n    question.id,\n  );\n  typia.assert<IShoppingSaleQuestion>(readByCustomer);\n  TestValidator.equals(\"readByCustomer\", (k) => k === \"created_at\" || k === \"read_by_seller\")(question)(readByCustomer);\n\n  // 3-2. 판매자인 seller가 정상 조회\n  const readBySeller = await api.functional.shoppings.sellers.sales.questions.get(\n    seller,\n    sale.id,\n    question.id,\n  );\n  typia.assert<IShoppingSaleQuestion>(readBySeller);\n  TestValidator.equals(\"readBySeller\", (k) => k === \"created_at\" || k === \"read_by_seller\")(question)(readBySeller);\n\n  // 4. stranger(다른 고객)가 비공개 질문을 조회 → 권한 없음 오류\n  await TestValidator.httpError(\"stranger forbidden\")(403, 404)(async () => {\n    await api.functional.shoppings.sellers.sales.questions.get(\n      stranger,\n      sale.id,\n      question.id,\n    );\n  });\n\n  // 5. 존재하지 않는 question id 조회 → 404 오류\n  await TestValidator.httpError(\"not found\")(404)(async () => {\n    await api.functional.shoppings.sellers.sales.questions.get(\n      seller,\n      sale.id,\n      \"00000000-0000-0000-0000-000000000000\",\n    );\n  });\n\n  // 6. 존재하지 않는 sale id 조회 → 404 오류\n  await TestValidator.httpError(\"not found sale\")(404)(async () => {\n    await api.functional.shoppings.sellers.sales.questions.get(\n      seller,\n      \"00000000-0000-0000-0000-000000000000\",\n      question.id,\n    );\n  });\n}\n",
  "test/features/api/shopping-sale-review-answer/test_create_answer_to_sale_review_with_valid_and_duplicate_conditions.ts": "import { TestValidator } from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\nimport { IBbsArticle } from \"@ORGANIZATION/PROJECT-api/lib/structures/IBbsArticle\";\nimport { IShoppingSaleInquiryAnswer } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleInquiryAnswer\";\nimport { IBbsArticle_ICreate } from \"@ORGANIZATION/PROJECT-api/lib/structures/IBbsArticle.ICreate\";\nimport { IPageIShoppingSaleReview_ISummary } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIShoppingSaleReview.ISummary\";\nimport { IShoppingSaleReview_IRequest } from \"@ORGANIZATION/PROJECT-api/lib/structures/IShoppingSaleReview.IRequest\";\n\nexport async function test_create_answer_to_sale_review_with_valid_and_duplicate_conditions(connection: api.IConnection): Promise<void> {\n    // 1. 답변 대상 리뷰 생성(목록으로부터 하나 선택)\n    const saleId = \"sale-test-id-01\";\n    // patch /shoppings/sellers/sales/{saleId}/reviews 호출로 리뷰 목록 조회(여러 개 중 첫 번째 사용)\n    const reqBody: IShoppingSaleReview_IRequest = {};\n    const reviewList = await api.functional.shoppings.sellers.sales.reviews.patch(connection, saleId, reqBody);\n    typia.assert<IPageIShoppingSaleReview_ISummary>(reviewList);\n    TestValidator.predicate(\"리뷰 데이터 존재 확인\")(() => reviewList.data.length > 0);\n    const reviewId = reviewList.data[0].id;\n\n    // 2. 정상적인 답변 작성 요청\n    const answerInput: IBbsArticle_ICreate = {\n        format: \"md\",\n        title: \"판매자 공식 답변 제목\",\n        body: \"이것은 판매자의 공식 답변 본문입니다.\",\n        files: [{\n            name: \"sample\",\n            extension: \"jpg\",\n            url: \"https://statics.example.com/sample.jpg\"\n        }],\n    };\n    const answer = await api.functional.shoppings.sellers.sales.reviews.answer.post(connection, saleId, reviewId, answerInput);\n    typia.assert<IShoppingSaleInquiryAnswer>(answer);\n    TestValidator.equals(\"정상 답변 생성 확인\")(answer.snapshots[0].title)(answerInput.title);\n    TestValidator.equals(\"정상 답변 본문 확인\")(answer.snapshots[0].body)(answerInput.body);\n    TestValidator.equals(\"파일 정상 첨부 확인\")(answer.snapshots[0].files[0].url)(answerInput.files[0].url);\n\n    // 3. 동일 리뷰에 중복 답변 작성 시 에러 반환 검증\n    await TestValidator.httpError(\"중복 답변 작성 방지 동작\")(409)(\n        () => api.functional.shoppings.sellers.sales.reviews.answer.post(connection, saleId, reviewId, answerInput)\n    );\n\n    // 4. 답변 필수값 누락 및 포맷 위반 케이스(빈 제목)\n    const invalidAnswerInput: IBbsArticle_ICreate = {\n        format: \"md\",\n        title: \"\",\n        body: \"\",\n        files: [],\n    };\n    await TestValidator.httpError(\"답변 누락 필드/유효성 위반 시 에러\")(400, 422)(\n        () => api.functional.shoppings.sellers.sales.reviews.answer.post(connection, saleId, reviewId, invalidAnswerInput)\n    );\n}\n"
}