[
  {
    "id": "b51adde4-9e1e-4412-9641-df0869e3ab12",
    "type": "userMessage",
    "contents": [
      {
        "type": "text",
        "text": "I want to create a political/economic discussion board. Since I'm not familiar with programming, please write a requirements analysis report as you see fit. The report should be approximately 3 pages long.\n"
      }
    ],
    "created_at": "2025-06-09T05:49:50.474Z"
  },
  {
    "id": "4444a46e-6ede-4049-b27a-628e6e96271f",
    "type": "analyze",
    "prefix": "bbs",
    "reason": "Create a requirements analysis report for a political/economic discussion board. The report should be about 3 pages long and suitable for someone with no programming background. Use clear, non-technical explanations for the system purpose, features, user roles, data structure, and business rules. Do not include any design requirements, as the user did not provide any. If user input is vague or incomplete, supplement only with standard best practices for such platforms.",
    "files": {
      "00_toc.md": "# Table of Contents\n\n1. [Introduction and Purpose](01_introduction_and_purpose.md)\n2. [Key Features and User Roles](02_key_features_and_user_roles.md)\n3. [Data Structure and Business Rules](03_data_structure_and_business_rules.md)\n\nEach section is designed to clearly lay out the purpose, main functions, target users, and operational guidelines for the discussion board, using accessible language suitable for non-technical readers.",
      "01_introduction_and_purpose.md": "# Introduction and Purpose\n\n## Overview\nThis document provides an introduction and outlines the purpose of a Political/Economic Discussion Board platform. It is intended for an audience with no programming background, aiming for clarity and accessibility about the system’s objectives and value. This document is part of a broader requirements analysis, which includes system features, user roles, data structure, and business rules covered in related documents.\n\n## Goals of the Discussion Board\n\nThe Political/Economic Discussion Board is designed as an online gathering place where people can discuss, share, and debate topics related to politics and economics. The main goals of the platform are:\n\n- To foster informed and respectful conversations.\n- To create a space where users can share news, opinions, and analysis.\n- To support constructive debate by allowing different perspectives to be expressed.\n- To encourage community-driven content while moderating for civility and factual accuracy.\n\n## Target Users\nThe discussion board is intended for:\n- General members of the public interested in politics and economics\n- Students and educators seeking information or discussion opportunities\n- Journalists and opinion leaders sharing insights or analysis\n- Community moderators keeping conversations respectful and accurate\n\n## Use Cases\nTypical ways people might use the discussion board include:\n- Posting questions about current political or economic events\n- Sharing news articles and starting discussions\n- Engaging in debates on policy proposals or global events\n- Fact-checking statements for accuracy\n- Connecting with others who have similar or opposing viewpoints\n\n## Benefits\nThe platform provides a reliable, easy-to-use space for civic engagement. Users benefit from:\n- Free access to wide-ranging discussions\n- Exposure to multiple viewpoints, promoting critical thinking\n- Guidance and moderation to ensure a respectful environment\n- The ability to both consume and contribute content easily\n\n---\n\n[Continue to Key Features and User Roles](02_key_features_and_user_roles.md)",
      "02_key_features_and_user_roles.md": "# Key Features and User Roles\n\n## Overview\nThis section outlines the essential functions and participant roles for a political/economic discussion board. The goal is to facilitate open, respectful, and insightful discussions on political and economic topics, making it easy for users of any background to engage safely and meaningfully.\n\n---\n\n## 1. Core Features\n\n### 1.1. Discussion Threads\n- Users can create, view, and contribute to ongoing discussions (called \"threads\").\n- Threads are organized by category (e.g., politics, economics, current events), enabling easy navigation.\n\n### 1.2. Posting and Commenting\n- Registered users can start new threads or reply to existing ones.\n- Replies can be nested to show conversation flow.\n\n### 1.3. Voting System\n- Users can upvote or downvote posts and replies, raising helpful or insightful contributions and lowering less useful ones.\n\n### 1.4. Moderation Tools\n- Moderators oversee discussions, enforce rules, and can remove posts that violate guidelines (e.g., hate speech, spam).\n- Users can report inappropriate content for review.\n\n### 1.5. User Profiles and Reputation\n- Each user has a profile with a public username, optional bio, and summary of their participation.\n- Reputation points reflect positive contributions and trustworthiness.\n\n### 1.6. Notification and Search\n- Notifications alert users to replies or mentions.\n- Search tools help find relevant discussions and posts.\n\n---\n\n## 2. User Roles\n\n| Role         | Main Abilities                                                    |\n|--------------|-------------------------------------------------------------------|\n| Visitor      | Browse and read posts, but cannot participate actively            |\n| Member       | Create threads, comment, vote, customize profile                  |\n| Moderator    | Edit/delete posts, manage reports, enforce rules, assist users    |\n| Administrator| Set rules, manage categories and users, oversee the platform      |\n\n- **Visitors** have read-only access for easy entry.\n- **Members** can fully participate in discussions after signing up.\n- **Moderators** are trusted community members with extra responsibilities to keep the board welcoming and informative.\n- **Administrators** manage the overall setup, policies, and safety of the platform.\n\n---\n\n## 3. Accessibility & Best Practices\n- Simple, clear navigation for all users.\n- Rule reminders before posting.\n- Options to follow or mute threads.\n- Privacy protections, such as the ability to hide real names.\n\n---\n\n[Return to Table of Contents](./00_toc.md) | [Next: Data Structure & Business Rules](./03_data_structure_and_business_rules.md)\n",
      "03_data_structure_and_business_rules.md": "# Data Structure and Business Rules for Political/Economic Discussion Board\n\n---\n\n## Overview\nThis section describes how the key information and rules that enable a robust, user-focused political/economic discussion board are structured. The explanations are intended for a general audience with no technical background. No design or implementation details are included, focusing solely on the organization and logic that would shape the platform.\n\n## 1. Core Data Entities\nThe discussion board revolves around several main types of information (“data entities”). These define what kinds of things exist in the system and how they are related. The main entities are:\n\n- **User:** An individual participating on the board (as reader, poster, or moderator)\n- **Post:** A discussion topic or article submitted by a user\n- **Comment:** A reply or discussion made in response to a post or another comment\n- **Category:** Broad topics (e.g., politics, economics, international affairs) under which posts are organized\n- **Vote:** An indication of support or disagreement with posts or comments\n\n### Entity Table\n| Entity     | Description                          | Main Attributes                 |\n|------------|--------------------------------------|---------------------------------|\n| User       | A registered board member            | Username, email, role, status   |\n| Post       | New topic or article                 | Title, content, author, time, category, vote tally |\n| Comment    | Response to post/comment             | Content, author, time, parent post/comment, vote tally |\n| Category   | Topic area for organization          | Name, description               |\n| Vote       | User feedback on posts/comments      | Voter, target (post/comment), value (+1 or -1) |\n\n## 2. Relationships and Data Flow\n- A **User** can create many **Posts** and **Comments**.\n- Each **Post** belongs to one **Category**, and each **Comment** is linked to a **Post** or another **Comment**.\n- A **Post** or **Comment** can have multiple **Votes** from different **Users**.\n\n### Example Relationship Diagram\n\n```mermaid\nerDiagram\n    USER ||--o{ POST : makes\n    USER ||--o{ COMMENT : writes\n    POST ||--o{ COMMENT : receives\n    POST }o--|| CATEGORY : organized_in\n    COMMENT ||--o{ COMMENT : replies\n    POST ||--o{ VOTE : receives\n    COMMENT ||--o{ VOTE : receives\n    USER ||--o{ VOTE : submits\n```\n\n## 3. Business Rules\nBusiness rules are guidelines and requirements that keep the board fair, informative, and secure.\n\n### 3.1 Posting and Commenting\n- Only registered users can create posts or comments.\n- Posts must be assigned to a category.\n- Comments can be placed on posts or as replies to other comments.\n- Editing and deleting posts or comments is limited to their original authors (within a time window, if enforced).\n\n### 3.2 Voting System\n- All registered users can vote (upvote or downvote) on posts and comments.\n- Each user is allowed only one vote per post or comment.\n- Vote tallies are visible and help users find useful or popular discussions.\n\n### 3.3 Moderation and User Roles\n- Roles include: regular users, moderators, and administrators.\n- Moderators can remove posts/comments that violate policies (e.g., personal attacks, hate speech).\n- Repeated rule-breaking may result in warnings, temporary suspensions, or bans.\n\n### 3.4 Content Organization\n- Categories are managed by administrators, ensuring posts fit the board’s focus.\n- Users can suggest new categories for consideration.\n\n### 3.5 Privacy and Security\n- Email addresses and private data are not publicly visible.\n- Passwords and sensitive information remain protected.\n- Users must accept the terms and rules before joining.\n\n## 4. Example Scenario\nA new user joins and chooses their area of interest, such as \"Economics.\" They post a discussion about inflation. Other users reply, ask questions, and upvote insightful comments. Moderators remove off-topic or rule-breaking content.\n\n## 5. Key Takeaways\n- The platform encourages respectful and insightful debate on political and economic topics.\n- Rules and structures ensure fair participation, content quality, and a safe environment.\n- The board is organized for easy navigation, with user-driven voting to highlight quality discussions.\n\n[Return to Table of Contents](./00_toc.md)\n"
    },
    "step": 0,
    "created_at": "2025-06-09T05:49:56.464Z",
    "completed_at": "2025-06-09T05:50:44.046Z"
  },
  {
    "id": "036b8432-0aa1-4b9e-b86e-ce9fc5a82f84",
    "type": "userMessage",
    "contents": [
      {
        "type": "text",
        "text": "Design the database schema, but don't make it complicate please.\n"
      }
    ],
    "created_at": "2025-06-09T05:51:32.953Z"
  },
  {
    "type": "prisma",
    "id": "8ddb5a92-c653-410b-81a6-8d25aefdd437",
    "created_at": "2025-06-09T05:51:36.014Z",
    "completed_at": "2025-06-09T05:54:22.131Z",
    "reason": "The requirements analysis report for a political/economic discussion board has been completed and the user requested a simple, non-complicated database schema. Proceed to design a straightforward schema with minimal but sufficient entities and relationships for this context.",
    "description": "",
    "result": {
      "success": true,
      "data": {
        "files": [
          {
            "filename": "schema-01-core.prisma",
            "namespace": "Core",
            "models": [
              {
                "name": "users",
                "description": "User information - This implements the 'User' entity from the requirements analysis document (03_data_structure_and_business_rules.md). \n\nRepresents registered members of the discussion board. Each user record holds public profile data and permissions (role and status). For example, Alice with email alice@email.com can be a regular user, moderator, or admin.\n\nKey relationships: references user_roles for permission, and relates to posts, comments, and votes they create.\nSpecial behaviors: emails are unique; passwords are stored securely; role assignment required.",
                "material": false,
                "primaryField": {
                  "name": "id",
                  "type": "uuid",
                  "description": "Primary Key. \nUnique identifier for each user."
                },
                "foreignFields": [
                  {
                    "name": "user_role_id",
                    "type": "uuid",
                    "description": "Role of the user. Target model's {@link user_roles.id}.\nDetermines user permissions such as regular member, moderator, or administrator.",
                    "relation": {
                      "name": "role",
                      "targetModel": "user_roles"
                    },
                    "unique": false,
                    "nullable": false
                  }
                ],
                "plainFields": [
                  {
                    "name": "username",
                    "type": "string",
                    "description": "Username visible on the platform - Implements profile display requirement. Must be unique and public. For example, 'politicoFan88'.",
                    "nullable": false
                  },
                  {
                    "name": "email",
                    "type": "string",
                    "description": "User's email address - Used for login and notifications. Must be unique. For example, 'user@example.com'.",
                    "nullable": false
                  },
                  {
                    "name": "bio",
                    "type": "string",
                    "description": "Optional short biography - Lets users share info about themselves. For example, 'Economics student, debate enthusiast.'",
                    "nullable": true
                  },
                  {
                    "name": "password_hash",
                    "type": "string",
                    "description": "Hashed password - Implements security requirement. Stores a hashed version of the user password for authentication. Example: long hash string. Not public.",
                    "nullable": false
                  },
                  {
                    "name": "created_at",
                    "type": "datetime",
                    "description": "Account creation timestamp - Implements auditability. For example, '2024-06-09T10:00:00+09:00'.",
                    "nullable": false
                  },
                  {
                    "name": "updated_at",
                    "type": "datetime",
                    "description": "Timestamp of last profile update - Implements history/auth traceability. For example, '2024-07-01T12:30:00+09:00'.",
                    "nullable": false
                  },
                  {
                    "name": "status",
                    "type": "string",
                    "description": "Account status - Implements moderation/authentication rules. For example, 'active', 'suspended', or 'banned'.",
                    "nullable": false
                  }
                ],
                "uniqueIndexes": [
                  {
                    "fieldNames": [
                      "username"
                    ],
                    "unique": true
                  },
                  {
                    "fieldNames": [
                      "email"
                    ],
                    "unique": true
                  }
                ],
                "plainIndexes": [
                  {
                    "fieldNames": [
                      "created_at"
                    ]
                  }
                ],
                "ginIndexes": []
              },
              {
                "name": "user_roles",
                "description": "User role definitions - This implements the role structure outlined in user roles section of the requirements analysis document (02_key_features_and_user_roles.md).\n\nDefines different permissions and capabilities for users. For example, 'member', 'moderator', 'administrator'.\n\nKey relationships: referenced by users table; no direct link to posts or comments.\nSpecial behaviors: role 'name' must be unique.",
                "material": false,
                "primaryField": {
                  "name": "id",
                  "type": "uuid",
                  "description": "Primary Key. Unique identifier for user role."
                },
                "foreignFields": [],
                "plainFields": [
                  {
                    "name": "name",
                    "type": "string",
                    "description": "Role label - Implements user roles requirement. Example: 'member', 'moderator', 'administrator'. Must be unique.",
                    "nullable": false
                  },
                  {
                    "name": "description",
                    "type": "string",
                    "description": "Role description - Gives context about permissions and duties; e.g., 'Can moderate comments and suspend users' for moderators.",
                    "nullable": false
                  }
                ],
                "uniqueIndexes": [
                  {
                    "fieldNames": [
                      "name"
                    ],
                    "unique": true
                  }
                ],
                "plainIndexes": [],
                "ginIndexes": []
              },
              {
                "name": "categories",
                "description": "Discussion categories - This covers the 'Category' entity from the requirements document (03_data_structure_and_business_rules.md).\n\nRepresents the main topic divisions organizing posts. For example, 'Politics', 'Economics', 'International Affairs'.\n\nKey relationships: referenced by posts; managed by administrators.\nSpecial behaviors: unique name required, can be suggested by users but created by admin.",
                "material": false,
                "primaryField": {
                  "name": "id",
                  "type": "uuid",
                  "description": "Primary Key. Unique identifier for category."
                },
                "foreignFields": [],
                "plainFields": [
                  {
                    "name": "name",
                    "type": "string",
                    "description": "Category name - Implements content organization and navigation requirement. For example, 'Politics'. Must be unique per category.",
                    "nullable": false
                  },
                  {
                    "name": "description",
                    "type": "string",
                    "description": "Category description - Explains scope. For example, 'Discussion about domestic and international political systems, governance, and related events.'",
                    "nullable": false
                  },
                  {
                    "name": "created_at",
                    "type": "datetime",
                    "description": "Timestamp when the category was added - Implements audit trail. Example: '2024-06-09T09:00:00+09:00'.",
                    "nullable": false
                  }
                ],
                "uniqueIndexes": [
                  {
                    "fieldNames": [
                      "name"
                    ],
                    "unique": true
                  }
                ],
                "plainIndexes": [
                  {
                    "fieldNames": [
                      "created_at"
                    ]
                  }
                ],
                "ginIndexes": []
              }
            ]
          },
          {
            "filename": "schema-02-posts.prisma",
            "namespace": "Posts",
            "models": [
              {
                "name": "posts",
                "description": "Post entity - This implements the 'Post' entity from the requirements document (see Data Structure and Business Rules, section 1, and Example Scenario). \n\nRepresents discussion topics or articles submitted by users. Provides a core construct to enable users to initiate threads, share analysis, and start community debates. For example, a user posts a discussion about inflation in the 'Economics' category. \n\nKey relationships: Each post belongs to one user (author) and one category. Each post can have many comments and votes. \nSpecial behaviors: A post must be assigned to a category, may be edited/deleted by its author, and is visible to all users. Vote tally and creation metadata are key for surfacing relevant content.",
                "material": false,
                "primaryField": {
                  "name": "id",
                  "type": "uuid",
                  "description": "Primary Key. Unique identifier for each post."
                },
                "foreignFields": [
                  {
                    "name": "user_id",
                    "type": "uuid",
                    "description": "Author's {@link users.id} - Links each post to its authoring user account. Enforces the association between posts and registered users. Required for accountability and profile-related features.",
                    "relation": {
                      "name": "author",
                      "targetModel": "users"
                    },
                    "unique": false,
                    "nullable": false
                  },
                  {
                    "name": "category_id",
                    "type": "uuid",
                    "description": "Category's {@link categories.id} - Associates the post with a topic/category, used for board structure and navigation. Enforces the requirement that every post has a topical context.",
                    "relation": {
                      "name": "category",
                      "targetModel": "categories"
                    },
                    "unique": false,
                    "nullable": false
                  }
                ],
                "plainFields": [
                  {
                    "name": "title",
                    "type": "string",
                    "description": "Title of the post - Implements the requirement that each post has a headline/subject. Business meaning: summary/subject line visible in post lists and thread views. For example, 'Economic Impact of Inflation in 2025'.",
                    "nullable": false
                  },
                  {
                    "name": "content",
                    "type": "string",
                    "description": "Body content of the post - Implements the rule that posts have main text where users express opinions, share news, analysis, etc. For example, a 400-word analysis of current economic events. Allows rich content or text.",
                    "nullable": false
                  },
                  {
                    "name": "created_at",
                    "type": "datetime",
                    "description": "Creation timestamp - Implements transparency and audit requirements by recording when the post was created. Business use: shows recency in lists, allows moderation tracking.",
                    "nullable": false
                  },
                  {
                    "name": "updated_at",
                    "type": "datetime",
                    "description": "Last edited timestamp - Allows tracking of post edits for evidence/history. Enforces business constraint of allowing users to edit posts within the permitted window. For example, updated_at is changed when a user fixes a typo.",
                    "nullable": false
                  },
                  {
                    "name": "deleted_at",
                    "type": "datetime",
                    "description": "Soft deletion timestamp - Implements moderation rules (see Moderation and User Roles). Posts are not hard deleted but marked with this field if removed for rule violations or by user request. For example, moderators mark spam here for audit/history.",
                    "nullable": true
                  }
                ],
                "uniqueIndexes": [],
                "plainIndexes": [
                  {
                    "fieldNames": [
                      "category_id",
                      "created_at"
                    ]
                  },
                  {
                    "fieldNames": [
                      "user_id",
                      "created_at"
                    ]
                  },
                  {
                    "fieldNames": [
                      "created_at"
                    ]
                  }
                ],
                "ginIndexes": [
                  {
                    "fieldName": "title"
                  },
                  {
                    "fieldName": "content"
                  }
                ]
              },
              {
                "name": "comments",
                "description": "Comment entity - This implements the 'Comment' entity from the requirements (see Data Structure and Business Rules section 1, and Example Scenario).\n\nRepresents replies to posts or other comments, allowing for nested conversations and community discussion. For example, a user comments on a post about inflation, or replies to another comment with their opinion.\n\nKey relationships: Each comment is written by a user and is attached either directly to a post or as a nested reply to another comment. Each comment can have multiple votes. Replies form a hierarchy.\nSpecial behaviors: Only registered users can comment. Comments may be deleted/edited by their author within constraints. Vote tally supports surfacing relevant replies. Threaded (self-referential) relations supported.",
                "material": false,
                "primaryField": {
                  "name": "id",
                  "type": "uuid",
                  "description": "Primary Key. Unique identifier for each comment."
                },
                "foreignFields": [
                  {
                    "name": "user_id",
                    "type": "uuid",
                    "description": "Author's {@link users.id} - Indicates the owner/author of the comment. Enforces accountability, links to profile and reputation system. Required for audit and moderation.",
                    "relation": {
                      "name": "author",
                      "targetModel": "users"
                    },
                    "unique": false,
                    "nullable": false
                  },
                  {
                    "name": "post_id",
                    "type": "uuid",
                    "description": "Parent post's {@link posts.id} - The post that this comment is in response to. Implements the association between comments and discussions. Required unless it's a reply to another comment only.",
                    "relation": {
                      "name": "post",
                      "targetModel": "posts"
                    },
                    "unique": false,
                    "nullable": false
                  },
                  {
                    "name": "parent_id",
                    "type": "uuid",
                    "description": "Parent comment's {@link comments.id} - Implements threaded/nested replies, allowing for comment hierarchies. Enables conversations to branch. Nullable for top-level comments (direct responses to posts).",
                    "relation": {
                      "name": "parent",
                      "targetModel": "comments"
                    },
                    "unique": false,
                    "nullable": true
                  }
                ],
                "plainFields": [
                  {
                    "name": "content",
                    "type": "string",
                    "description": "Comment body - Implements the rule that each comment consists of user-written text/content. Used for replies, opinions, and ongoing discussion. For example, 'I agree and here’s why...'.",
                    "nullable": false
                  },
                  {
                    "name": "created_at",
                    "type": "datetime",
                    "description": "Creation timestamp - Implements audit/history requirement for comment posting, tracking the date and time for moderation and display ordering. For example, enables 'most recent first' sorting.",
                    "nullable": false
                  },
                  {
                    "name": "updated_at",
                    "type": "datetime",
                    "description": "Last edited timestamp - Implements edit history tracking for evidence and transparency. If a user updates their comment, this records when.",
                    "nullable": false
                  },
                  {
                    "name": "deleted_at",
                    "type": "datetime",
                    "description": "Soft deletion timestamp - Implements moderation controls by marking comments removed (not hard deleted) for evidence/history. Used if comment violates rules, is self-removed, or by moderator action.",
                    "nullable": true
                  }
                ],
                "uniqueIndexes": [],
                "plainIndexes": [
                  {
                    "fieldNames": [
                      "post_id",
                      "created_at"
                    ]
                  },
                  {
                    "fieldNames": [
                      "user_id",
                      "created_at"
                    ]
                  },
                  {
                    "fieldNames": [
                      "parent_id",
                      "created_at"
                    ]
                  }
                ],
                "ginIndexes": [
                  {
                    "fieldName": "content"
                  }
                ]
              }
            ]
          },
          {
            "filename": "schema-03-votes.prisma",
            "namespace": "Votes",
            "models": [
              {
                "name": "votes",
                "description": "Vote records - This implements the voting/feedback requirements section described in the requirements analysis, enabling users to provide positive or negative feedback on posts and comments in the discussion board. \n\nBusiness purpose: Allows users to upvote or downvote content, surfacing high-quality posts and comments, while discouraging low-quality contributions. Only registered users can cast votes and only one vote per content item per user is allowed, enforcing fairness and preventing manipulation. Used to calculate real-time content ranking and trust metrics.\n\nKey relationships: Votes always belong to a user and point to either a post or a comment. The voted target is mutually exclusive: each row references either a post or a comment, but never both. \n\nSpecial behaviors: Unique constraint ensures one vote per user per post or comment. Cascade deletion if the user or voted content is removed, to maintain data integrity.",
                "material": false,
                "primaryField": {
                  "name": "id",
                  "type": "uuid",
                  "description": "Primary Key. Unique identifier for each vote record."
                },
                "foreignFields": [
                  {
                    "name": "user_id",
                    "type": "uuid",
                    "description": "Voter's user reference - Links each vote to the user who cast it. Implements the requirement that only registered users can vote. Business meaning: Tracks voting history and enforces unique voting constraints. Example: User 'U' upvotes a comment, linking the vote to 'U's user_id.",
                    "relation": {
                      "name": "user",
                      "targetModel": "users"
                    },
                    "unique": false,
                    "nullable": false
                  },
                  {
                    "name": "post_id",
                    "type": "uuid",
                    "description": "Target post's reference - References the post being voted on, if the vote relates to a post (and not a comment). Implements mutual exclusivity rule and enables vote tallies for posts. Example: Voting on a thread increases the tally on the referenced post. Constraint: Only one of post_id or comment_id is non-null per row.",
                    "relation": {
                      "name": "post",
                      "targetModel": "posts"
                    },
                    "unique": false,
                    "nullable": true
                  },
                  {
                    "name": "comment_id",
                    "type": "uuid",
                    "description": "Target comment's reference - References the comment being voted on, if applicable. Implements mutual exclusivity rule as with posts. Example: Voting on a reply records the vote linked to this comment. Only one of post_id or comment_id is set per vote record.",
                    "relation": {
                      "name": "comment",
                      "targetModel": "comments"
                    },
                    "unique": false,
                    "nullable": true
                  }
                ],
                "plainFields": [
                  {
                    "name": "value",
                    "type": "int",
                    "description": "Vote value - Implements the upvote/downvote requirement. Stores +1 for upvote, -1 for downvote. Business meaning: This value is aggregated to produce content rankings. Example: A +1 value indicates an upvote from a user.",
                    "nullable": false
                  },
                  {
                    "name": "created_at",
                    "type": "datetime",
                    "description": "Vote timestamp - Implements auditing requirements for vote tracking. Stores the date and time the vote was made. Used for analytics and to enforce time-based voting limits, if ever required by policy.",
                    "nullable": false
                  }
                ],
                "uniqueIndexes": [
                  {
                    "fieldNames": [
                      "user_id",
                      "post_id"
                    ],
                    "unique": true
                  },
                  {
                    "fieldNames": [
                      "user_id",
                      "comment_id"
                    ],
                    "unique": true
                  }
                ],
                "plainIndexes": [
                  {
                    "fieldNames": [
                      "post_id",
                      "created_at"
                    ]
                  },
                  {
                    "fieldNames": [
                      "comment_id",
                      "created_at"
                    ]
                  }
                ],
                "ginIndexes": []
              }
            ]
          }
        ]
      }
    },
    "schemas": {
      "schema-01-core.prisma": "/// User information - This implements the 'User' entity from the requirements analysis document (03_data_structure_and_business_rules.md). \n///\n/// Represents registered members of the discussion board. Each user record holds public profile data and permissions (role and status). For example, Alice with email alice@email.com can be a regular user, moderator, or admin.\n///\n/// Key relationships: references user_roles for permission, and relates to posts, comments, and votes they create.\n/// Special behaviors: emails are unique; passwords are stored securely; role assignment required.\n///\n/// @namespace Core\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel users {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key. \n  /// Unique identifier for each user.\n  id String @id @db.Uuid\n  \n  /// Role of the user. Target model's {@link user_roles.id}.\n  /// Determines user permissions such as regular member, moderator, or administrator.\n  user_role_id String @db.Uuid\n  \n  /// Username visible on the platform - Implements profile display requirement. Must be unique and public. For example, 'politicoFan88'.\n  username String\n  \n  /// User's email address - Used for login and notifications. Must be unique. For example, 'user@example.com'.\n  email String\n  \n  /// Optional short biography - Lets users share info about themselves. For example, 'Economics student, debate enthusiast.'\n  bio String?\n  \n  /// Hashed password - Implements security requirement. Stores a hashed version of the user password for authentication. Example: long hash string. Not public.\n  password_hash String\n  \n  /// Account creation timestamp - Implements auditability. For example, '2024-06-09T10:00:00+09:00'.\n  created_at DateTime @db.Timestamptz\n  \n  /// Timestamp of last profile update - Implements history/auth traceability. For example, '2024-07-01T12:30:00+09:00'.\n  updated_at DateTime @db.Timestamptz\n  \n  /// Account status - Implements moderation/authentication rules. For example, 'active', 'suspended', or 'banned'.\n  status String\n  \n  //----\n  // RELATIONS\n  //----\n  role user_roles @relation(fields: [user_role_id], references: [id], onDelete: Cascade)\n  \n  posts posts[]\n  comments comments[]\n  votes votes[]\n  \n  @@index([user_role_id])\n  \n  @@unique([username])\n  @@unique([email])\n  @@index([created_at])\n}\n\n/// User role definitions - This implements the role structure outlined in user roles section of the requirements analysis document (02_key_features_and_user_roles.md).\n///\n/// Defines different permissions and capabilities for users. For example, 'member', 'moderator', 'administrator'.\n///\n/// Key relationships: referenced by users table; no direct link to posts or comments.\n/// Special behaviors: role 'name' must be unique.\n///\n/// @namespace Core\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel user_roles {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key. Unique identifier for user role.\n  id String @id @db.Uuid\n  \n  /// Role label - Implements user roles requirement. Example: 'member', 'moderator', 'administrator'. Must be unique.\n  name String\n  \n  /// Role description - Gives context about permissions and duties; e.g., 'Can moderate comments and suspend users' for moderators.\n  description String\n  \n  //----\n  // RELATIONS\n  //----\n  users users[]\n  \n  @@unique([name])\n}\n\n/// Discussion categories - This covers the 'Category' entity from the requirements document (03_data_structure_and_business_rules.md).\n///\n/// Represents the main topic divisions organizing posts. For example, 'Politics', 'Economics', 'International Affairs'.\n///\n/// Key relationships: referenced by posts; managed by administrators.\n/// Special behaviors: unique name required, can be suggested by users but created by admin.\n///\n/// @namespace Core\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel categories {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key. Unique identifier for category.\n  id String @id @db.Uuid\n  \n  /// Category name - Implements content organization and navigation requirement. For example, 'Politics'. Must be unique per category.\n  name String\n  \n  /// Category description - Explains scope. For example, 'Discussion about domestic and international political systems, governance, and related events.'\n  description String\n  \n  /// Timestamp when the category was added - Implements audit trail. Example: '2024-06-09T09:00:00+09:00'.\n  created_at DateTime @db.Timestamptz\n  \n  //----\n  // RELATIONS\n  //----\n  posts posts[]\n  \n  @@unique([name])\n  @@index([created_at])\n}",
      "schema-02-posts.prisma": "/// Post entity - This implements the 'Post' entity from the requirements document (see Data Structure and Business Rules, section 1, and Example Scenario). \n///\n/// Represents discussion topics or articles submitted by users. Provides a core construct to enable users to initiate threads, share analysis, and start community debates. For example, a user posts a discussion about inflation in the 'Economics' category. \n///\n/// Key relationships: Each post belongs to one user (author) and one category. Each post can have many comments and votes. \n/// Special behaviors: A post must be assigned to a category, may be edited/deleted by its author, and is visible to all users. Vote tally and creation metadata are key for surfacing relevant content.\n///\n/// @namespace Posts\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel posts {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key. Unique identifier for each post.\n  id String @id @db.Uuid\n  \n  /// Author's {@link users.id} - Links each post to its authoring user account. Enforces the association between posts and registered users. Required for accountability and profile-related features.\n  user_id String @db.Uuid\n  \n  /// Category's {@link categories.id} - Associates the post with a topic/category, used for board structure and navigation. Enforces the requirement that every post has a topical context.\n  category_id String @db.Uuid\n  \n  /// Title of the post - Implements the requirement that each post has a headline/subject. Business meaning: summary/subject line visible in post lists and thread views. For example, 'Economic Impact of Inflation in 2025'.\n  title String\n  \n  /// Body content of the post - Implements the rule that posts have main text where users express opinions, share news, analysis, etc. For example, a 400-word analysis of current economic events. Allows rich content or text.\n  content String\n  \n  /// Creation timestamp - Implements transparency and audit requirements by recording when the post was created. Business use: shows recency in lists, allows moderation tracking.\n  created_at DateTime @db.Timestamptz\n  \n  /// Last edited timestamp - Allows tracking of post edits for evidence/history. Enforces business constraint of allowing users to edit posts within the permitted window. For example, updated_at is changed when a user fixes a typo.\n  updated_at DateTime @db.Timestamptz\n  \n  /// Soft deletion timestamp - Implements moderation rules (see Moderation and User Roles). Posts are not hard deleted but marked with this field if removed for rule violations or by user request. For example, moderators mark spam here for audit/history.\n  deleted_at DateTime? @db.Timestamptz\n  \n  //----\n  // RELATIONS\n  //----\n  author users @relation(fields: [user_id], references: [id], onDelete: Cascade)\n  category categories @relation(fields: [category_id], references: [id], onDelete: Cascade)\n  \n  comments comments[]\n  votes votes[]\n  \n  @@index([category_id, created_at])\n  @@index([user_id, created_at])\n  @@index([created_at])\n  @@index([title(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n  @@index([content(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}\n\n/// Comment entity - This implements the 'Comment' entity from the requirements (see Data Structure and Business Rules section 1, and Example Scenario).\n///\n/// Represents replies to posts or other comments, allowing for nested conversations and community discussion. For example, a user comments on a post about inflation, or replies to another comment with their opinion.\n///\n/// Key relationships: Each comment is written by a user and is attached either directly to a post or as a nested reply to another comment. Each comment can have multiple votes. Replies form a hierarchy.\n/// Special behaviors: Only registered users can comment. Comments may be deleted/edited by their author within constraints. Vote tally supports surfacing relevant replies. Threaded (self-referential) relations supported.\n///\n/// @namespace Posts\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel comments {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key. Unique identifier for each comment.\n  id String @id @db.Uuid\n  \n  /// Author's {@link users.id} - Indicates the owner/author of the comment. Enforces accountability, links to profile and reputation system. Required for audit and moderation.\n  user_id String @db.Uuid\n  \n  /// Parent post's {@link posts.id} - The post that this comment is in response to. Implements the association between comments and discussions. Required unless it's a reply to another comment only.\n  post_id String @db.Uuid\n  \n  /// Parent comment's {@link comments.id} - Implements threaded/nested replies, allowing for comment hierarchies. Enables conversations to branch. Nullable for top-level comments (direct responses to posts).\n  parent_id String? @db.Uuid\n  \n  /// Comment body - Implements the rule that each comment consists of user-written text/content. Used for replies, opinions, and ongoing discussion. For example, 'I agree and here’s why...'.\n  content String\n  \n  /// Creation timestamp - Implements audit/history requirement for comment posting, tracking the date and time for moderation and display ordering. For example, enables 'most recent first' sorting.\n  created_at DateTime @db.Timestamptz\n  \n  /// Last edited timestamp - Implements edit history tracking for evidence and transparency. If a user updates their comment, this records when.\n  updated_at DateTime @db.Timestamptz\n  \n  /// Soft deletion timestamp - Implements moderation controls by marking comments removed (not hard deleted) for evidence/history. Used if comment violates rules, is self-removed, or by moderator action.\n  deleted_at DateTime? @db.Timestamptz\n  \n  //----\n  // RELATIONS\n  //----\n  author users @relation(fields: [user_id], references: [id], onDelete: Cascade)\n  post posts @relation(fields: [post_id], references: [id], onDelete: Cascade)\n  parent comments? @relation(\"recursive\", fields: [parent_id], references: [id], onDelete: Cascade)\n  \n  recursive comments[] @relation(\"recursive\")\n  votes votes[]\n  \n  @@index([post_id, created_at])\n  @@index([user_id, created_at])\n  @@index([parent_id, created_at])\n  @@index([content(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}",
      "schema-03-votes.prisma": "/// Vote records - This implements the voting/feedback requirements section described in the requirements analysis, enabling users to provide positive or negative feedback on posts and comments in the discussion board. \n///\n/// Business purpose: Allows users to upvote or downvote content, surfacing high-quality posts and comments, while discouraging low-quality contributions. Only registered users can cast votes and only one vote per content item per user is allowed, enforcing fairness and preventing manipulation. Used to calculate real-time content ranking and trust metrics.\n///\n/// Key relationships: Votes always belong to a user and point to either a post or a comment. The voted target is mutually exclusive: each row references either a post or a comment, but never both. \n///\n/// Special behaviors: Unique constraint ensures one vote per user per post or comment. Cascade deletion if the user or voted content is removed, to maintain data integrity.\n///\n/// @namespace Votes\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel votes {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key. Unique identifier for each vote record.\n  id String @id @db.Uuid\n  \n  /// Voter's user reference - Links each vote to the user who cast it. Implements the requirement that only registered users can vote. Business meaning: Tracks voting history and enforces unique voting constraints. Example: User 'U' upvotes a comment, linking the vote to 'U's user_id.\n  user_id String @db.Uuid\n  \n  /// Target post's reference - References the post being voted on, if the vote relates to a post (and not a comment). Implements mutual exclusivity rule and enables vote tallies for posts. Example: Voting on a thread increases the tally on the referenced post. Constraint: Only one of post_id or comment_id is non-null per row.\n  post_id String? @db.Uuid\n  \n  /// Target comment's reference - References the comment being voted on, if applicable. Implements mutual exclusivity rule as with posts. Example: Voting on a reply records the vote linked to this comment. Only one of post_id or comment_id is set per vote record.\n  comment_id String? @db.Uuid\n  \n  /// Vote value - Implements the upvote/downvote requirement. Stores +1 for upvote, -1 for downvote. Business meaning: This value is aggregated to produce content rankings. Example: A +1 value indicates an upvote from a user.\n  value Int @db.Integer\n  \n  /// Vote timestamp - Implements auditing requirements for vote tracking. Stores the date and time the vote was made. Used for analytics and to enforce time-based voting limits, if ever required by policy.\n  created_at DateTime @db.Timestamptz\n  \n  //----\n  // RELATIONS\n  //----\n  user users @relation(fields: [user_id], references: [id], onDelete: Cascade)\n  post posts? @relation(fields: [post_id], references: [id], onDelete: Cascade)\n  comment comments? @relation(fields: [comment_id], references: [id], onDelete: Cascade)\n  \n  @@unique([user_id, post_id])\n  @@unique([user_id, comment_id])\n  @@index([post_id, created_at])\n  @@index([comment_id, created_at])\n}",
      "main.prisma": "generator client {\n  provider        = \"prisma-client-js\"\n  previewFeatures = [\"postgresqlExtensions\", \"views\"]\n  binaryTargets   = [\"native\"]\n}\n\ndatasource db {\n  provider   = \"postgresql\"\n  url        = env(\"DATABASE_URL\")\n  extensions = []\n}\n\ngenerator markdown {\n  provider = \"prisma-markdown\"\n  output   = \"../docs/ERD.md\"\n}"
    },
    "compiled": {
      "type": "success",
      "schemas": {
        "schema-01-core.prisma": "/// User information - This implements the 'User' entity from the requirements analysis document (03_data_structure_and_business_rules.md). \n///\n/// Represents registered members of the discussion board. Each user record holds public profile data and permissions (role and status). For example, Alice with email alice@email.com can be a regular user, moderator, or admin.\n///\n/// Key relationships: references user_roles for permission, and relates to posts, comments, and votes they create.\n/// Special behaviors: emails are unique; passwords are stored securely; role assignment required.\n///\n/// @namespace Core\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel users {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key. \n  /// Unique identifier for each user.\n  id String @id @db.Uuid\n\n  /// Role of the user. Target model's {@link user_roles.id}.\n  /// Determines user permissions such as regular member, moderator, or administrator.\n  user_role_id String @db.Uuid\n\n  /// Username visible on the platform - Implements profile display requirement. Must be unique and public. For example, 'politicoFan88'.\n  username String\n\n  /// User's email address - Used for login and notifications. Must be unique. For example, 'user@example.com'.\n  email String\n\n  /// Optional short biography - Lets users share info about themselves. For example, 'Economics student, debate enthusiast.'\n  bio String?\n\n  /// Hashed password - Implements security requirement. Stores a hashed version of the user password for authentication. Example: long hash string. Not public.\n  password_hash String\n\n  /// Account creation timestamp - Implements auditability. For example, '2024-06-09T10:00:00+09:00'.\n  created_at DateTime @db.Timestamptz\n\n  /// Timestamp of last profile update - Implements history/auth traceability. For example, '2024-07-01T12:30:00+09:00'.\n  updated_at DateTime @db.Timestamptz\n\n  /// Account status - Implements moderation/authentication rules. For example, 'active', 'suspended', or 'banned'.\n  status String\n\n  //----\n  // RELATIONS\n  //----\n  role user_roles @relation(fields: [user_role_id], references: [id], onDelete: Cascade)\n\n  posts    posts[]\n  comments comments[]\n  votes    votes[]\n\n  @@unique([username])\n  @@unique([email])\n  @@index([user_role_id])\n  @@index([created_at])\n}\n\n/// User role definitions - This implements the role structure outlined in user roles section of the requirements analysis document (02_key_features_and_user_roles.md).\n///\n/// Defines different permissions and capabilities for users. For example, 'member', 'moderator', 'administrator'.\n///\n/// Key relationships: referenced by users table; no direct link to posts or comments.\n/// Special behaviors: role 'name' must be unique.\n///\n/// @namespace Core\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel user_roles {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key. Unique identifier for user role.\n  id String @id @db.Uuid\n\n  /// Role label - Implements user roles requirement. Example: 'member', 'moderator', 'administrator'. Must be unique.\n  name String\n\n  /// Role description - Gives context about permissions and duties; e.g., 'Can moderate comments and suspend users' for moderators.\n  description String\n\n  //----\n  // RELATIONS\n  //----\n  users users[]\n\n  @@unique([name])\n}\n\n/// Discussion categories - This covers the 'Category' entity from the requirements document (03_data_structure_and_business_rules.md).\n///\n/// Represents the main topic divisions organizing posts. For example, 'Politics', 'Economics', 'International Affairs'.\n///\n/// Key relationships: referenced by posts; managed by administrators.\n/// Special behaviors: unique name required, can be suggested by users but created by admin.\n///\n/// @namespace Core\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel categories {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key. Unique identifier for category.\n  id String @id @db.Uuid\n\n  /// Category name - Implements content organization and navigation requirement. For example, 'Politics'. Must be unique per category.\n  name String\n\n  /// Category description - Explains scope. For example, 'Discussion about domestic and international political systems, governance, and related events.'\n  description String\n\n  /// Timestamp when the category was added - Implements audit trail. Example: '2024-06-09T09:00:00+09:00'.\n  created_at DateTime @db.Timestamptz\n\n  //----\n  // RELATIONS\n  //----\n  posts posts[]\n\n  @@unique([name])\n  @@index([created_at])\n}\n",
        "schema-02-posts.prisma": "/// Post entity - This implements the 'Post' entity from the requirements document (see Data Structure and Business Rules, section 1, and Example Scenario). \n///\n/// Represents discussion topics or articles submitted by users. Provides a core construct to enable users to initiate threads, share analysis, and start community debates. For example, a user posts a discussion about inflation in the 'Economics' category. \n///\n/// Key relationships: Each post belongs to one user (author) and one category. Each post can have many comments and votes. \n/// Special behaviors: A post must be assigned to a category, may be edited/deleted by its author, and is visible to all users. Vote tally and creation metadata are key for surfacing relevant content.\n///\n/// @namespace Posts\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel posts {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key. Unique identifier for each post.\n  id String @id @db.Uuid\n\n  /// Author's {@link users.id} - Links each post to its authoring user account. Enforces the association between posts and registered users. Required for accountability and profile-related features.\n  user_id String @db.Uuid\n\n  /// Category's {@link categories.id} - Associates the post with a topic/category, used for board structure and navigation. Enforces the requirement that every post has a topical context.\n  category_id String @db.Uuid\n\n  /// Title of the post - Implements the requirement that each post has a headline/subject. Business meaning: summary/subject line visible in post lists and thread views. For example, 'Economic Impact of Inflation in 2025'.\n  title String\n\n  /// Body content of the post - Implements the rule that posts have main text where users express opinions, share news, analysis, etc. For example, a 400-word analysis of current economic events. Allows rich content or text.\n  content String\n\n  /// Creation timestamp - Implements transparency and audit requirements by recording when the post was created. Business use: shows recency in lists, allows moderation tracking.\n  created_at DateTime @db.Timestamptz\n\n  /// Last edited timestamp - Allows tracking of post edits for evidence/history. Enforces business constraint of allowing users to edit posts within the permitted window. For example, updated_at is changed when a user fixes a typo.\n  updated_at DateTime @db.Timestamptz\n\n  /// Soft deletion timestamp - Implements moderation rules (see Moderation and User Roles). Posts are not hard deleted but marked with this field if removed for rule violations or by user request. For example, moderators mark spam here for audit/history.\n  deleted_at DateTime? @db.Timestamptz\n\n  //----\n  // RELATIONS\n  //----\n  author   users      @relation(fields: [user_id], references: [id], onDelete: Cascade)\n  category categories @relation(fields: [category_id], references: [id], onDelete: Cascade)\n\n  comments comments[]\n  votes    votes[]\n\n  @@index([category_id, created_at])\n  @@index([user_id, created_at])\n  @@index([created_at])\n  @@index([title(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n  @@index([content(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}\n\n/// Comment entity - This implements the 'Comment' entity from the requirements (see Data Structure and Business Rules section 1, and Example Scenario).\n///\n/// Represents replies to posts or other comments, allowing for nested conversations and community discussion. For example, a user comments on a post about inflation, or replies to another comment with their opinion.\n///\n/// Key relationships: Each comment is written by a user and is attached either directly to a post or as a nested reply to another comment. Each comment can have multiple votes. Replies form a hierarchy.\n/// Special behaviors: Only registered users can comment. Comments may be deleted/edited by their author within constraints. Vote tally supports surfacing relevant replies. Threaded (self-referential) relations supported.\n///\n/// @namespace Posts\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel comments {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key. Unique identifier for each comment.\n  id String @id @db.Uuid\n\n  /// Author's {@link users.id} - Indicates the owner/author of the comment. Enforces accountability, links to profile and reputation system. Required for audit and moderation.\n  user_id String @db.Uuid\n\n  /// Parent post's {@link posts.id} - The post that this comment is in response to. Implements the association between comments and discussions. Required unless it's a reply to another comment only.\n  post_id String @db.Uuid\n\n  /// Parent comment's {@link comments.id} - Implements threaded/nested replies, allowing for comment hierarchies. Enables conversations to branch. Nullable for top-level comments (direct responses to posts).\n  parent_id String? @db.Uuid\n\n  /// Comment body - Implements the rule that each comment consists of user-written text/content. Used for replies, opinions, and ongoing discussion. For example, 'I agree and here’s why...'.\n  content String\n\n  /// Creation timestamp - Implements audit/history requirement for comment posting, tracking the date and time for moderation and display ordering. For example, enables 'most recent first' sorting.\n  created_at DateTime @db.Timestamptz\n\n  /// Last edited timestamp - Implements edit history tracking for evidence and transparency. If a user updates their comment, this records when.\n  updated_at DateTime @db.Timestamptz\n\n  /// Soft deletion timestamp - Implements moderation controls by marking comments removed (not hard deleted) for evidence/history. Used if comment violates rules, is self-removed, or by moderator action.\n  deleted_at DateTime? @db.Timestamptz\n\n  //----\n  // RELATIONS\n  //----\n  author users     @relation(fields: [user_id], references: [id], onDelete: Cascade)\n  post   posts     @relation(fields: [post_id], references: [id], onDelete: Cascade)\n  parent comments? @relation(\"recursive\", fields: [parent_id], references: [id], onDelete: Cascade)\n\n  recursive comments[] @relation(\"recursive\")\n  votes     votes[]\n\n  @@index([post_id, created_at])\n  @@index([user_id, created_at])\n  @@index([parent_id, created_at])\n  @@index([content(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}\n",
        "schema-03-votes.prisma": "/// Vote records - This implements the voting/feedback requirements section described in the requirements analysis, enabling users to provide positive or negative feedback on posts and comments in the discussion board. \n///\n/// Business purpose: Allows users to upvote or downvote content, surfacing high-quality posts and comments, while discouraging low-quality contributions. Only registered users can cast votes and only one vote per content item per user is allowed, enforcing fairness and preventing manipulation. Used to calculate real-time content ranking and trust metrics.\n///\n/// Key relationships: Votes always belong to a user and point to either a post or a comment. The voted target is mutually exclusive: each row references either a post or a comment, but never both. \n///\n/// Special behaviors: Unique constraint ensures one vote per user per post or comment. Cascade deletion if the user or voted content is removed, to maintain data integrity.\n///\n/// @namespace Votes\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel votes {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key. Unique identifier for each vote record.\n  id String @id @db.Uuid\n\n  /// Voter's user reference - Links each vote to the user who cast it. Implements the requirement that only registered users can vote. Business meaning: Tracks voting history and enforces unique voting constraints. Example: User 'U' upvotes a comment, linking the vote to 'U's user_id.\n  user_id String @db.Uuid\n\n  /// Target post's reference - References the post being voted on, if the vote relates to a post (and not a comment). Implements mutual exclusivity rule and enables vote tallies for posts. Example: Voting on a thread increases the tally on the referenced post. Constraint: Only one of post_id or comment_id is non-null per row.\n  post_id String? @db.Uuid\n\n  /// Target comment's reference - References the comment being voted on, if applicable. Implements mutual exclusivity rule as with posts. Example: Voting on a reply records the vote linked to this comment. Only one of post_id or comment_id is set per vote record.\n  comment_id String? @db.Uuid\n\n  /// Vote value - Implements the upvote/downvote requirement. Stores +1 for upvote, -1 for downvote. Business meaning: This value is aggregated to produce content rankings. Example: A +1 value indicates an upvote from a user.\n  value Int @db.Integer\n\n  /// Vote timestamp - Implements auditing requirements for vote tracking. Stores the date and time the vote was made. Used for analytics and to enforce time-based voting limits, if ever required by policy.\n  created_at DateTime @db.Timestamptz\n\n  //----\n  // RELATIONS\n  //----\n  user    users     @relation(fields: [user_id], references: [id], onDelete: Cascade)\n  post    posts?    @relation(fields: [post_id], references: [id], onDelete: Cascade)\n  comment comments? @relation(fields: [comment_id], references: [id], onDelete: Cascade)\n\n  @@unique([user_id, post_id])\n  @@unique([user_id, comment_id])\n  @@index([post_id, created_at])\n  @@index([comment_id, created_at])\n}\n",
        "main.prisma": "generator client {\n  provider        = \"prisma-client-js\"\n  previewFeatures = [\"postgresqlExtensions\", \"views\"]\n  binaryTargets   = [\"native\"]\n}\n\ndatasource db {\n  provider   = \"postgresql\"\n  url        = env(\"DATABASE_URL\")\n  extensions = []\n}\n\ngenerator markdown {\n  provider = \"prisma-markdown\"\n  output   = \"../docs/ERD.md\"\n}\n"
      },
      "nodeModules": {
        "node_modules/.prisma/client/client.d.ts": "export * from \"./index\"",
        "node_modules/.prisma/client/default.d.ts": "export * from \"./index\"",
        "node_modules/.prisma/client/edge.d.ts": "export * from \"./default\"",
        "node_modules/.prisma/client/index.d.ts": "\n/**\n * Client\n**/\n\nimport * as runtime from './runtime/library.js';\nimport $Types = runtime.Types // general types\nimport $Public = runtime.Types.Public\nimport $Utils = runtime.Types.Utils\nimport $Extensions = runtime.Types.Extensions\nimport $Result = runtime.Types.Result\n\nexport type PrismaPromise<T> = $Public.PrismaPromise<T>\n\n\n/**\n * Model users\n * User information - This implements the 'User' entity from the requirements analysis document (03_data_structure_and_business_rules.md). \n * \n * Represents registered members of the discussion board. Each user record holds public profile data and permissions (role and status). For example, Alice with email alice@email.com can be a regular user, moderator, or admin.\n * \n * Key relationships: references user_roles for permission, and relates to posts, comments, and votes they create.\n * Special behaviors: emails are unique; passwords are stored securely; role assignment required.\n * \n * @namespace Core\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type users = $Result.DefaultSelection<Prisma.$usersPayload>\n/**\n * Model user_roles\n * User role definitions - This implements the role structure outlined in user roles section of the requirements analysis document (02_key_features_and_user_roles.md).\n * \n * Defines different permissions and capabilities for users. For example, 'member', 'moderator', 'administrator'.\n * \n * Key relationships: referenced by users table; no direct link to posts or comments.\n * Special behaviors: role 'name' must be unique.\n * \n * @namespace Core\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type user_roles = $Result.DefaultSelection<Prisma.$user_rolesPayload>\n/**\n * Model categories\n * Discussion categories - This covers the 'Category' entity from the requirements document (03_data_structure_and_business_rules.md).\n * \n * Represents the main topic divisions organizing posts. For example, 'Politics', 'Economics', 'International Affairs'.\n * \n * Key relationships: referenced by posts; managed by administrators.\n * Special behaviors: unique name required, can be suggested by users but created by admin.\n * \n * @namespace Core\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type categories = $Result.DefaultSelection<Prisma.$categoriesPayload>\n/**\n * Model posts\n * Post entity - This implements the 'Post' entity from the requirements document (see Data Structure and Business Rules, section 1, and Example Scenario). \n * \n * Represents discussion topics or articles submitted by users. Provides a core construct to enable users to initiate threads, share analysis, and start community debates. For example, a user posts a discussion about inflation in the 'Economics' category. \n * \n * Key relationships: Each post belongs to one user (author) and one category. Each post can have many comments and votes. \n * Special behaviors: A post must be assigned to a category, may be edited/deleted by its author, and is visible to all users. Vote tally and creation metadata are key for surfacing relevant content.\n * \n * @namespace Posts\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type posts = $Result.DefaultSelection<Prisma.$postsPayload>\n/**\n * Model comments\n * Comment entity - This implements the 'Comment' entity from the requirements (see Data Structure and Business Rules section 1, and Example Scenario).\n * \n * Represents replies to posts or other comments, allowing for nested conversations and community discussion. For example, a user comments on a post about inflation, or replies to another comment with their opinion.\n * \n * Key relationships: Each comment is written by a user and is attached either directly to a post or as a nested reply to another comment. Each comment can have multiple votes. Replies form a hierarchy.\n * Special behaviors: Only registered users can comment. Comments may be deleted/edited by their author within constraints. Vote tally supports surfacing relevant replies. Threaded (self-referential) relations supported.\n * \n * @namespace Posts\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type comments = $Result.DefaultSelection<Prisma.$commentsPayload>\n/**\n * Model votes\n * Vote records - This implements the voting/feedback requirements section described in the requirements analysis, enabling users to provide positive or negative feedback on posts and comments in the discussion board. \n * \n * Business purpose: Allows users to upvote or downvote content, surfacing high-quality posts and comments, while discouraging low-quality contributions. Only registered users can cast votes and only one vote per content item per user is allowed, enforcing fairness and preventing manipulation. Used to calculate real-time content ranking and trust metrics.\n * \n * Key relationships: Votes always belong to a user and point to either a post or a comment. The voted target is mutually exclusive: each row references either a post or a comment, but never both. \n * \n * Special behaviors: Unique constraint ensures one vote per user per post or comment. Cascade deletion if the user or voted content is removed, to maintain data integrity.\n * \n * @namespace Votes\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type votes = $Result.DefaultSelection<Prisma.$votesPayload>\n\n/**\n * ##  Prisma Client ʲˢ\n *\n * Type-safe database client for TypeScript & Node.js\n * @example\n * ```\n * const prisma = new PrismaClient()\n * // Fetch zero or more Users\n * const users = await prisma.users.findMany()\n * ```\n *\n *\n * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).\n */\nexport class PrismaClient<\n  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,\n  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,\n  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs\n> {\n  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }\n\n    /**\n   * ##  Prisma Client ʲˢ\n   *\n   * Type-safe database client for TypeScript & Node.js\n   * @example\n   * ```\n   * const prisma = new PrismaClient()\n   * // Fetch zero or more Users\n   * const users = await prisma.users.findMany()\n   * ```\n   *\n   *\n   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).\n   */\n\n  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);\n  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;\n\n  /**\n   * Connect with the database\n   */\n  $connect(): $Utils.JsPromise<void>;\n\n  /**\n   * Disconnect from the database\n   */\n  $disconnect(): $Utils.JsPromise<void>;\n\n  /**\n   * Add a middleware\n   * @deprecated since 4.16.0. For new code, prefer client extensions instead.\n   * @see https://pris.ly/d/extensions\n   */\n  $use(cb: Prisma.Middleware): void\n\n/**\n   * Executes a prepared raw query and returns the number of affected rows.\n   * @example\n   * ```\n   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`\n   * ```\n   *\n   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).\n   */\n  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;\n\n  /**\n   * Executes a raw query and returns the number of affected rows.\n   * Susceptible to SQL injections, see documentation.\n   * @example\n   * ```\n   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')\n   * ```\n   *\n   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).\n   */\n  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;\n\n  /**\n   * Performs a prepared raw query and returns the `SELECT` data.\n   * @example\n   * ```\n   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`\n   * ```\n   *\n   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).\n   */\n  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;\n\n  /**\n   * Performs a raw query and returns the `SELECT` data.\n   * Susceptible to SQL injections, see documentation.\n   * @example\n   * ```\n   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')\n   * ```\n   *\n   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).\n   */\n  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;\n\n\n  /**\n   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.\n   * @example\n   * ```\n   * const [george, bob, alice] = await prisma.$transaction([\n   *   prisma.user.create({ data: { name: 'George' } }),\n   *   prisma.user.create({ data: { name: 'Bob' } }),\n   *   prisma.user.create({ data: { name: 'Alice' } }),\n   * ])\n   * ```\n   * \n   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).\n   */\n  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>\n\n  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>\n\n\n  $extends: $Extensions.ExtendsHook<\"extends\", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {\n    extArgs: ExtArgs\n  }>>\n\n      /**\n   * `prisma.users`: Exposes CRUD operations for the **users** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Users\n    * const users = await prisma.users.findMany()\n    * ```\n    */\n  get users(): Prisma.usersDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.user_roles`: Exposes CRUD operations for the **user_roles** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more User_roles\n    * const user_roles = await prisma.user_roles.findMany()\n    * ```\n    */\n  get user_roles(): Prisma.user_rolesDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.categories`: Exposes CRUD operations for the **categories** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Categories\n    * const categories = await prisma.categories.findMany()\n    * ```\n    */\n  get categories(): Prisma.categoriesDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.posts`: Exposes CRUD operations for the **posts** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Posts\n    * const posts = await prisma.posts.findMany()\n    * ```\n    */\n  get posts(): Prisma.postsDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.comments`: Exposes CRUD operations for the **comments** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Comments\n    * const comments = await prisma.comments.findMany()\n    * ```\n    */\n  get comments(): Prisma.commentsDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.votes`: Exposes CRUD operations for the **votes** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Votes\n    * const votes = await prisma.votes.findMany()\n    * ```\n    */\n  get votes(): Prisma.votesDelegate<ExtArgs, ClientOptions>;\n}\n\nexport namespace Prisma {\n  export import DMMF = runtime.DMMF\n\n  export type PrismaPromise<T> = $Public.PrismaPromise<T>\n\n  /**\n   * Validator\n   */\n  export import validator = runtime.Public.validator\n\n  /**\n   * Prisma Errors\n   */\n  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError\n  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError\n  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError\n  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError\n  export import PrismaClientValidationError = runtime.PrismaClientValidationError\n\n  /**\n   * Re-export of sql-template-tag\n   */\n  export import sql = runtime.sqltag\n  export import empty = runtime.empty\n  export import join = runtime.join\n  export import raw = runtime.raw\n  export import Sql = runtime.Sql\n\n\n\n  /**\n   * Decimal.js\n   */\n  export import Decimal = runtime.Decimal\n\n  export type DecimalJsLike = runtime.DecimalJsLike\n\n  /**\n   * Metrics\n   */\n  export type Metrics = runtime.Metrics\n  export type Metric<T> = runtime.Metric<T>\n  export type MetricHistogram = runtime.MetricHistogram\n  export type MetricHistogramBucket = runtime.MetricHistogramBucket\n\n  /**\n  * Extensions\n  */\n  export import Extension = $Extensions.UserArgs\n  export import getExtensionContext = runtime.Extensions.getExtensionContext\n  export import Args = $Public.Args\n  export import Payload = $Public.Payload\n  export import Result = $Public.Result\n  export import Exact = $Public.Exact\n\n  /**\n   * Prisma Client JS version: local\n   * Query Engine version: local\n   */\n  export type PrismaVersion = {\n    client: string\n  }\n\n  export const prismaVersion: PrismaVersion\n\n  /**\n   * Utility Types\n   */\n\n\n  export import JsonObject = runtime.JsonObject\n  export import JsonArray = runtime.JsonArray\n  export import JsonValue = runtime.JsonValue\n  export import InputJsonObject = runtime.InputJsonObject\n  export import InputJsonArray = runtime.InputJsonArray\n  export import InputJsonValue = runtime.InputJsonValue\n\n  /**\n   * Types of the values used to represent different kinds of `null` values when working with JSON fields.\n   *\n   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n   */\n  namespace NullTypes {\n    /**\n    * Type of `Prisma.DbNull`.\n    *\n    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.\n    *\n    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n    */\n    class DbNull {\n      private DbNull: never\n      private constructor()\n    }\n\n    /**\n    * Type of `Prisma.JsonNull`.\n    *\n    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.\n    *\n    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n    */\n    class JsonNull {\n      private JsonNull: never\n      private constructor()\n    }\n\n    /**\n    * Type of `Prisma.AnyNull`.\n    *\n    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.\n    *\n    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n    */\n    class AnyNull {\n      private AnyNull: never\n      private constructor()\n    }\n  }\n\n  /**\n   * Helper for filtering JSON entries that have `null` on the database (empty on the db)\n   *\n   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n   */\n  export const DbNull: NullTypes.DbNull\n\n  /**\n   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)\n   *\n   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n   */\n  export const JsonNull: NullTypes.JsonNull\n\n  /**\n   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`\n   *\n   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n   */\n  export const AnyNull: NullTypes.AnyNull\n\n  type SelectAndInclude = {\n    select: any\n    include: any\n  }\n\n  type SelectAndOmit = {\n    select: any\n    omit: any\n  }\n\n  /**\n   * Get the type of the value, that the Promise holds.\n   */\n  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;\n\n  /**\n   * Get the return type of a function which returns a Promise.\n   */\n  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>\n\n  /**\n   * From T, pick a set of properties whose keys are in the union K\n   */\n  type Prisma__Pick<T, K extends keyof T> = {\n      [P in K]: T[P];\n  };\n\n\n  export type Enumerable<T> = T | Array<T>;\n\n  export type RequiredKeys<T> = {\n    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K\n  }[keyof T]\n\n  export type TruthyKeys<T> = keyof {\n    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K\n  }\n\n  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>\n\n  /**\n   * Subset\n   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection\n   */\n  export type Subset<T, U> = {\n    [key in keyof T]: key extends keyof U ? T[key] : never;\n  };\n\n  /**\n   * SelectSubset\n   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.\n   * Additionally, it validates, if both select and include are present. If the case, it errors.\n   */\n  export type SelectSubset<T, U> = {\n    [key in keyof T]: key extends keyof U ? T[key] : never\n  } &\n    (T extends SelectAndInclude\n      ? 'Please either choose `select` or `include`.'\n      : T extends SelectAndOmit\n        ? 'Please either choose `select` or `omit`.'\n        : {})\n\n  /**\n   * Subset + Intersection\n   * @desc From `T` pick properties that exist in `U` and intersect `K`\n   */\n  export type SubsetIntersection<T, U, K> = {\n    [key in keyof T]: key extends keyof U ? T[key] : never\n  } &\n    K\n\n  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };\n\n  /**\n   * XOR is needed to have a real mutually exclusive union type\n   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types\n   */\n  type XOR<T, U> =\n    T extends object ?\n    U extends object ?\n      (Without<T, U> & U) | (Without<U, T> & T)\n    : U : T\n\n\n  /**\n   * Is T a Record?\n   */\n  type IsObject<T extends any> = T extends Array<any>\n  ? False\n  : T extends Date\n  ? False\n  : T extends Uint8Array\n  ? False\n  : T extends BigInt\n  ? False\n  : T extends object\n  ? True\n  : False\n\n\n  /**\n   * If it's T[], return T\n   */\n  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T\n\n  /**\n   * From ts-toolbelt\n   */\n\n  type __Either<O extends object, K extends Key> = Omit<O, K> &\n    {\n      // Merge all but K\n      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities\n    }[K]\n\n  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>\n\n  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>\n\n  type _Either<\n    O extends object,\n    K extends Key,\n    strict extends Boolean\n  > = {\n    1: EitherStrict<O, K>\n    0: EitherLoose<O, K>\n  }[strict]\n\n  type Either<\n    O extends object,\n    K extends Key,\n    strict extends Boolean = 1\n  > = O extends unknown ? _Either<O, K, strict> : never\n\n  export type Union = any\n\n  type PatchUndefined<O extends object, O1 extends object> = {\n    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]\n  } & {}\n\n  /** Helper Types for \"Merge\" **/\n  export type IntersectOf<U extends Union> = (\n    U extends unknown ? (k: U) => void : never\n  ) extends (k: infer I) => void\n    ? I\n    : never\n\n  export type Overwrite<O extends object, O1 extends object> = {\n      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];\n  } & {};\n\n  type _Merge<U extends object> = IntersectOf<Overwrite<U, {\n      [K in keyof U]-?: At<U, K>;\n  }>>;\n\n  type Key = string | number | symbol;\n  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;\n  type AtStrict<O extends object, K extends Key> = O[K & keyof O];\n  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;\n  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {\n      1: AtStrict<O, K>;\n      0: AtLoose<O, K>;\n  }[strict];\n\n  export type ComputeRaw<A extends any> = A extends Function ? A : {\n    [K in keyof A]: A[K];\n  } & {};\n\n  export type OptionalFlat<O> = {\n    [K in keyof O]?: O[K];\n  } & {};\n\n  type _Record<K extends keyof any, T> = {\n    [P in K]: T;\n  };\n\n  // cause typescript not to expand types and preserve names\n  type NoExpand<T> = T extends unknown ? T : never;\n\n  // this type assumes the passed object is entirely optional\n  type AtLeast<O extends object, K extends string> = NoExpand<\n    O extends unknown\n    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)\n      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O\n    : never>;\n\n  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;\n\n  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;\n  /** End Helper Types for \"Merge\" **/\n\n  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;\n\n  /**\n  A [[Boolean]]\n  */\n  export type Boolean = True | False\n\n  // /**\n  // 1\n  // */\n  export type True = 1\n\n  /**\n  0\n  */\n  export type False = 0\n\n  export type Not<B extends Boolean> = {\n    0: 1\n    1: 0\n  }[B]\n\n  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]\n    ? 0 // anything `never` is false\n    : A1 extends A2\n    ? 1\n    : 0\n\n  export type Has<U extends Union, U1 extends Union> = Not<\n    Extends<Exclude<U1, U>, U1>\n  >\n\n  export type Or<B1 extends Boolean, B2 extends Boolean> = {\n    0: {\n      0: 0\n      1: 1\n    }\n    1: {\n      0: 1\n      1: 1\n    }\n  }[B1][B2]\n\n  export type Keys<U extends Union> = U extends unknown ? keyof U : never\n\n  type Cast<A, B> = A extends B ? A : B;\n\n  export const type: unique symbol;\n\n\n\n  /**\n   * Used by group by\n   */\n\n  export type GetScalarType<T, O> = O extends object ? {\n    [P in keyof T]: P extends keyof O\n      ? O[P]\n      : never\n  } : never\n\n  type FieldPaths<\n    T,\n    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>\n  > = IsObject<T> extends True ? U : T\n\n  type GetHavingFields<T> = {\n    [K in keyof T]: Or<\n      Or<Extends<'OR', K>, Extends<'AND', K>>,\n      Extends<'NOT', K>\n    > extends True\n      ? // infer is only needed to not hit TS limit\n        // based on the brilliant idea of Pierre-Antoine Mills\n        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437\n        T[K] extends infer TK\n        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>\n        : never\n      : {} extends FieldPaths<T[K]>\n      ? never\n      : K\n  }[keyof T]\n\n  /**\n   * Convert tuple to union\n   */\n  type _TupleToUnion<T> = T extends (infer E)[] ? E : never\n  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>\n  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T\n\n  /**\n   * Like `Pick`, but additionally can also accept an array of keys\n   */\n  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>\n\n  /**\n   * Exclude all keys with underscores\n   */\n  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T\n\n\n  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>\n\n  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>\n\n\n  export const ModelName: {\n    users: 'users',\n    user_roles: 'user_roles',\n    categories: 'categories',\n    posts: 'posts',\n    comments: 'comments',\n    votes: 'votes'\n  };\n\n  export type ModelName = (typeof ModelName)[keyof typeof ModelName]\n\n\n  export type Datasources = {\n    db?: Datasource\n  }\n\n  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {\n    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>\n  }\n\n  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {\n    globalOmitOptions: {\n      omit: GlobalOmitOptions\n    }\n    meta: {\n      modelProps: \"users\" | \"user_roles\" | \"categories\" | \"posts\" | \"comments\" | \"votes\"\n      txIsolationLevel: Prisma.TransactionIsolationLevel\n    }\n    model: {\n      users: {\n        payload: Prisma.$usersPayload<ExtArgs>\n        fields: Prisma.usersFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.usersFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.usersFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$usersPayload>\n          }\n          findFirst: {\n            args: Prisma.usersFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.usersFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$usersPayload>\n          }\n          findMany: {\n            args: Prisma.usersFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]\n          }\n          create: {\n            args: Prisma.usersCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$usersPayload>\n          }\n          createMany: {\n            args: Prisma.usersCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.usersCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]\n          }\n          delete: {\n            args: Prisma.usersDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$usersPayload>\n          }\n          update: {\n            args: Prisma.usersUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$usersPayload>\n          }\n          deleteMany: {\n            args: Prisma.usersDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.usersUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.usersUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]\n          }\n          upsert: {\n            args: Prisma.usersUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$usersPayload>\n          }\n          aggregate: {\n            args: Prisma.UsersAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateUsers>\n          }\n          groupBy: {\n            args: Prisma.usersGroupByArgs<ExtArgs>\n            result: $Utils.Optional<UsersGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.usersCountArgs<ExtArgs>\n            result: $Utils.Optional<UsersCountAggregateOutputType> | number\n          }\n        }\n      }\n      user_roles: {\n        payload: Prisma.$user_rolesPayload<ExtArgs>\n        fields: Prisma.user_rolesFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.user_rolesFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$user_rolesPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.user_rolesFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$user_rolesPayload>\n          }\n          findFirst: {\n            args: Prisma.user_rolesFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$user_rolesPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.user_rolesFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$user_rolesPayload>\n          }\n          findMany: {\n            args: Prisma.user_rolesFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$user_rolesPayload>[]\n          }\n          create: {\n            args: Prisma.user_rolesCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$user_rolesPayload>\n          }\n          createMany: {\n            args: Prisma.user_rolesCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.user_rolesCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$user_rolesPayload>[]\n          }\n          delete: {\n            args: Prisma.user_rolesDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$user_rolesPayload>\n          }\n          update: {\n            args: Prisma.user_rolesUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$user_rolesPayload>\n          }\n          deleteMany: {\n            args: Prisma.user_rolesDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.user_rolesUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.user_rolesUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$user_rolesPayload>[]\n          }\n          upsert: {\n            args: Prisma.user_rolesUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$user_rolesPayload>\n          }\n          aggregate: {\n            args: Prisma.User_rolesAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateUser_roles>\n          }\n          groupBy: {\n            args: Prisma.user_rolesGroupByArgs<ExtArgs>\n            result: $Utils.Optional<User_rolesGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.user_rolesCountArgs<ExtArgs>\n            result: $Utils.Optional<User_rolesCountAggregateOutputType> | number\n          }\n        }\n      }\n      categories: {\n        payload: Prisma.$categoriesPayload<ExtArgs>\n        fields: Prisma.categoriesFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.categoriesFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$categoriesPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.categoriesFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>\n          }\n          findFirst: {\n            args: Prisma.categoriesFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$categoriesPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.categoriesFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>\n          }\n          findMany: {\n            args: Prisma.categoriesFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>[]\n          }\n          create: {\n            args: Prisma.categoriesCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>\n          }\n          createMany: {\n            args: Prisma.categoriesCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.categoriesCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>[]\n          }\n          delete: {\n            args: Prisma.categoriesDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>\n          }\n          update: {\n            args: Prisma.categoriesUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>\n          }\n          deleteMany: {\n            args: Prisma.categoriesDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.categoriesUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.categoriesUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>[]\n          }\n          upsert: {\n            args: Prisma.categoriesUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>\n          }\n          aggregate: {\n            args: Prisma.CategoriesAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateCategories>\n          }\n          groupBy: {\n            args: Prisma.categoriesGroupByArgs<ExtArgs>\n            result: $Utils.Optional<CategoriesGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.categoriesCountArgs<ExtArgs>\n            result: $Utils.Optional<CategoriesCountAggregateOutputType> | number\n          }\n        }\n      }\n      posts: {\n        payload: Prisma.$postsPayload<ExtArgs>\n        fields: Prisma.postsFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.postsFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$postsPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.postsFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$postsPayload>\n          }\n          findFirst: {\n            args: Prisma.postsFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$postsPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.postsFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$postsPayload>\n          }\n          findMany: {\n            args: Prisma.postsFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$postsPayload>[]\n          }\n          create: {\n            args: Prisma.postsCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$postsPayload>\n          }\n          createMany: {\n            args: Prisma.postsCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.postsCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$postsPayload>[]\n          }\n          delete: {\n            args: Prisma.postsDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$postsPayload>\n          }\n          update: {\n            args: Prisma.postsUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$postsPayload>\n          }\n          deleteMany: {\n            args: Prisma.postsDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.postsUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.postsUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$postsPayload>[]\n          }\n          upsert: {\n            args: Prisma.postsUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$postsPayload>\n          }\n          aggregate: {\n            args: Prisma.PostsAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregatePosts>\n          }\n          groupBy: {\n            args: Prisma.postsGroupByArgs<ExtArgs>\n            result: $Utils.Optional<PostsGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.postsCountArgs<ExtArgs>\n            result: $Utils.Optional<PostsCountAggregateOutputType> | number\n          }\n        }\n      }\n      comments: {\n        payload: Prisma.$commentsPayload<ExtArgs>\n        fields: Prisma.commentsFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.commentsFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$commentsPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.commentsFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$commentsPayload>\n          }\n          findFirst: {\n            args: Prisma.commentsFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$commentsPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.commentsFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$commentsPayload>\n          }\n          findMany: {\n            args: Prisma.commentsFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$commentsPayload>[]\n          }\n          create: {\n            args: Prisma.commentsCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$commentsPayload>\n          }\n          createMany: {\n            args: Prisma.commentsCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.commentsCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$commentsPayload>[]\n          }\n          delete: {\n            args: Prisma.commentsDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$commentsPayload>\n          }\n          update: {\n            args: Prisma.commentsUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$commentsPayload>\n          }\n          deleteMany: {\n            args: Prisma.commentsDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.commentsUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.commentsUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$commentsPayload>[]\n          }\n          upsert: {\n            args: Prisma.commentsUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$commentsPayload>\n          }\n          aggregate: {\n            args: Prisma.CommentsAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateComments>\n          }\n          groupBy: {\n            args: Prisma.commentsGroupByArgs<ExtArgs>\n            result: $Utils.Optional<CommentsGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.commentsCountArgs<ExtArgs>\n            result: $Utils.Optional<CommentsCountAggregateOutputType> | number\n          }\n        }\n      }\n      votes: {\n        payload: Prisma.$votesPayload<ExtArgs>\n        fields: Prisma.votesFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.votesFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$votesPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.votesFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$votesPayload>\n          }\n          findFirst: {\n            args: Prisma.votesFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$votesPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.votesFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$votesPayload>\n          }\n          findMany: {\n            args: Prisma.votesFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$votesPayload>[]\n          }\n          create: {\n            args: Prisma.votesCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$votesPayload>\n          }\n          createMany: {\n            args: Prisma.votesCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.votesCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$votesPayload>[]\n          }\n          delete: {\n            args: Prisma.votesDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$votesPayload>\n          }\n          update: {\n            args: Prisma.votesUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$votesPayload>\n          }\n          deleteMany: {\n            args: Prisma.votesDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.votesUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.votesUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$votesPayload>[]\n          }\n          upsert: {\n            args: Prisma.votesUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$votesPayload>\n          }\n          aggregate: {\n            args: Prisma.VotesAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateVotes>\n          }\n          groupBy: {\n            args: Prisma.votesGroupByArgs<ExtArgs>\n            result: $Utils.Optional<VotesGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.votesCountArgs<ExtArgs>\n            result: $Utils.Optional<VotesCountAggregateOutputType> | number\n          }\n        }\n      }\n    }\n  } & {\n    other: {\n      payload: any\n      operations: {\n        $executeRaw: {\n          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],\n          result: any\n        }\n        $executeRawUnsafe: {\n          args: [query: string, ...values: any[]],\n          result: any\n        }\n        $queryRaw: {\n          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],\n          result: any\n        }\n        $queryRawUnsafe: {\n          args: [query: string, ...values: any[]],\n          result: any\n        }\n      }\n    }\n  }\n  export const defineExtension: $Extensions.ExtendsHook<\"define\", Prisma.TypeMapCb, $Extensions.DefaultArgs>\n  export type DefaultPrismaClient = PrismaClient\n  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'\n  export interface PrismaClientOptions {\n    /**\n     * Overwrites the datasource url from your schema.prisma file\n     */\n    datasources?: Datasources\n    /**\n     * Overwrites the datasource url from your schema.prisma file\n     */\n    datasourceUrl?: string\n    /**\n     * @default \"colorless\"\n     */\n    errorFormat?: ErrorFormat\n    /**\n     * @example\n     * ```\n     * // Defaults to stdout\n     * log: ['query', 'info', 'warn', 'error']\n     * \n     * // Emit as events\n     * log: [\n     *   { emit: 'stdout', level: 'query' },\n     *   { emit: 'stdout', level: 'info' },\n     *   { emit: 'stdout', level: 'warn' }\n     *   { emit: 'stdout', level: 'error' }\n     * ]\n     * ```\n     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).\n     */\n    log?: (LogLevel | LogDefinition)[]\n    /**\n     * The default values for transactionOptions\n     * maxWait ?= 2000\n     * timeout ?= 5000\n     */\n    transactionOptions?: {\n      maxWait?: number\n      timeout?: number\n      isolationLevel?: Prisma.TransactionIsolationLevel\n    }\n    /**\n     * Global configuration for omitting model fields by default.\n     * \n     * @example\n     * ```\n     * const prisma = new PrismaClient({\n     *   omit: {\n     *     user: {\n     *       password: true\n     *     }\n     *   }\n     * })\n     * ```\n     */\n    omit?: Prisma.GlobalOmitConfig\n  }\n  export type GlobalOmitConfig = {\n    users?: usersOmit\n    user_roles?: user_rolesOmit\n    categories?: categoriesOmit\n    posts?: postsOmit\n    comments?: commentsOmit\n    votes?: votesOmit\n  }\n\n  /* Types for Logging */\n  export type LogLevel = 'info' | 'query' | 'warn' | 'error'\n  export type LogDefinition = {\n    level: LogLevel\n    emit: 'stdout' | 'event'\n  }\n\n  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never\n  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?\n    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>\n    : never\n\n  export type QueryEvent = {\n    timestamp: Date\n    query: string\n    params: string\n    duration: number\n    target: string\n  }\n\n  export type LogEvent = {\n    timestamp: Date\n    message: string\n    target: string\n  }\n  /* End Types for Logging */\n\n\n  export type PrismaAction =\n    | 'findUnique'\n    | 'findUniqueOrThrow'\n    | 'findMany'\n    | 'findFirst'\n    | 'findFirstOrThrow'\n    | 'create'\n    | 'createMany'\n    | 'createManyAndReturn'\n    | 'update'\n    | 'updateMany'\n    | 'updateManyAndReturn'\n    | 'upsert'\n    | 'delete'\n    | 'deleteMany'\n    | 'executeRaw'\n    | 'queryRaw'\n    | 'aggregate'\n    | 'count'\n    | 'runCommandRaw'\n    | 'findRaw'\n    | 'groupBy'\n\n  /**\n   * These options are being passed into the middleware as \"params\"\n   */\n  export type MiddlewareParams = {\n    model?: ModelName\n    action: PrismaAction\n    args: any\n    dataPath: string[]\n    runInTransaction: boolean\n  }\n\n  /**\n   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation\n   */\n  export type Middleware<T = any> = (\n    params: MiddlewareParams,\n    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,\n  ) => $Utils.JsPromise<T>\n\n  // tested in getLogLevel.test.ts\n  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;\n\n  /**\n   * `PrismaClient` proxy available in interactive transactions.\n   */\n  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>\n\n  export type Datasource = {\n    url?: string\n  }\n\n  /**\n   * Count Types\n   */\n\n\n  /**\n   * Count Type UsersCountOutputType\n   */\n\n  export type UsersCountOutputType = {\n    posts: number\n    comments: number\n    votes: number\n  }\n\n  export type UsersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    posts?: boolean | UsersCountOutputTypeCountPostsArgs\n    comments?: boolean | UsersCountOutputTypeCountCommentsArgs\n    votes?: boolean | UsersCountOutputTypeCountVotesArgs\n  }\n\n  // Custom InputTypes\n  /**\n   * UsersCountOutputType without action\n   */\n  export type UsersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the UsersCountOutputType\n     */\n    select?: UsersCountOutputTypeSelect<ExtArgs> | null\n  }\n\n  /**\n   * UsersCountOutputType without action\n   */\n  export type UsersCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: postsWhereInput\n  }\n\n  /**\n   * UsersCountOutputType without action\n   */\n  export type UsersCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: commentsWhereInput\n  }\n\n  /**\n   * UsersCountOutputType without action\n   */\n  export type UsersCountOutputTypeCountVotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: votesWhereInput\n  }\n\n\n  /**\n   * Count Type User_rolesCountOutputType\n   */\n\n  export type User_rolesCountOutputType = {\n    users: number\n  }\n\n  export type User_rolesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    users?: boolean | User_rolesCountOutputTypeCountUsersArgs\n  }\n\n  // Custom InputTypes\n  /**\n   * User_rolesCountOutputType without action\n   */\n  export type User_rolesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the User_rolesCountOutputType\n     */\n    select?: User_rolesCountOutputTypeSelect<ExtArgs> | null\n  }\n\n  /**\n   * User_rolesCountOutputType without action\n   */\n  export type User_rolesCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: usersWhereInput\n  }\n\n\n  /**\n   * Count Type CategoriesCountOutputType\n   */\n\n  export type CategoriesCountOutputType = {\n    posts: number\n  }\n\n  export type CategoriesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    posts?: boolean | CategoriesCountOutputTypeCountPostsArgs\n  }\n\n  // Custom InputTypes\n  /**\n   * CategoriesCountOutputType without action\n   */\n  export type CategoriesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the CategoriesCountOutputType\n     */\n    select?: CategoriesCountOutputTypeSelect<ExtArgs> | null\n  }\n\n  /**\n   * CategoriesCountOutputType without action\n   */\n  export type CategoriesCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: postsWhereInput\n  }\n\n\n  /**\n   * Count Type PostsCountOutputType\n   */\n\n  export type PostsCountOutputType = {\n    comments: number\n    votes: number\n  }\n\n  export type PostsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    comments?: boolean | PostsCountOutputTypeCountCommentsArgs\n    votes?: boolean | PostsCountOutputTypeCountVotesArgs\n  }\n\n  // Custom InputTypes\n  /**\n   * PostsCountOutputType without action\n   */\n  export type PostsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the PostsCountOutputType\n     */\n    select?: PostsCountOutputTypeSelect<ExtArgs> | null\n  }\n\n  /**\n   * PostsCountOutputType without action\n   */\n  export type PostsCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: commentsWhereInput\n  }\n\n  /**\n   * PostsCountOutputType without action\n   */\n  export type PostsCountOutputTypeCountVotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: votesWhereInput\n  }\n\n\n  /**\n   * Count Type CommentsCountOutputType\n   */\n\n  export type CommentsCountOutputType = {\n    recursive: number\n    votes: number\n  }\n\n  export type CommentsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    recursive?: boolean | CommentsCountOutputTypeCountRecursiveArgs\n    votes?: boolean | CommentsCountOutputTypeCountVotesArgs\n  }\n\n  // Custom InputTypes\n  /**\n   * CommentsCountOutputType without action\n   */\n  export type CommentsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the CommentsCountOutputType\n     */\n    select?: CommentsCountOutputTypeSelect<ExtArgs> | null\n  }\n\n  /**\n   * CommentsCountOutputType without action\n   */\n  export type CommentsCountOutputTypeCountRecursiveArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: commentsWhereInput\n  }\n\n  /**\n   * CommentsCountOutputType without action\n   */\n  export type CommentsCountOutputTypeCountVotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: votesWhereInput\n  }\n\n\n  /**\n   * Models\n   */\n\n  /**\n   * Model users\n   */\n\n  export type AggregateUsers = {\n    _count: UsersCountAggregateOutputType | null\n    _min: UsersMinAggregateOutputType | null\n    _max: UsersMaxAggregateOutputType | null\n  }\n\n  export type UsersMinAggregateOutputType = {\n    id: string | null\n    user_role_id: string | null\n    username: string | null\n    email: string | null\n    bio: string | null\n    password_hash: string | null\n    created_at: Date | null\n    updated_at: Date | null\n    status: string | null\n  }\n\n  export type UsersMaxAggregateOutputType = {\n    id: string | null\n    user_role_id: string | null\n    username: string | null\n    email: string | null\n    bio: string | null\n    password_hash: string | null\n    created_at: Date | null\n    updated_at: Date | null\n    status: string | null\n  }\n\n  export type UsersCountAggregateOutputType = {\n    id: number\n    user_role_id: number\n    username: number\n    email: number\n    bio: number\n    password_hash: number\n    created_at: number\n    updated_at: number\n    status: number\n    _all: number\n  }\n\n\n  export type UsersMinAggregateInputType = {\n    id?: true\n    user_role_id?: true\n    username?: true\n    email?: true\n    bio?: true\n    password_hash?: true\n    created_at?: true\n    updated_at?: true\n    status?: true\n  }\n\n  export type UsersMaxAggregateInputType = {\n    id?: true\n    user_role_id?: true\n    username?: true\n    email?: true\n    bio?: true\n    password_hash?: true\n    created_at?: true\n    updated_at?: true\n    status?: true\n  }\n\n  export type UsersCountAggregateInputType = {\n    id?: true\n    user_role_id?: true\n    username?: true\n    email?: true\n    bio?: true\n    password_hash?: true\n    created_at?: true\n    updated_at?: true\n    status?: true\n    _all?: true\n  }\n\n  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which users to aggregate.\n     */\n    where?: usersWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of users to fetch.\n     */\n    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: usersWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` users from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` users.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned users\n    **/\n    _count?: true | UsersCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: UsersMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: UsersMaxAggregateInputType\n  }\n\n  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {\n        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateUsers[P]>\n      : GetScalarType<T[P], AggregateUsers[P]>\n  }\n\n\n\n\n  export type usersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: usersWhereInput\n    orderBy?: usersOrderByWithAggregationInput | usersOrderByWithAggregationInput[]\n    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum\n    having?: usersScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: UsersCountAggregateInputType | true\n    _min?: UsersMinAggregateInputType\n    _max?: UsersMaxAggregateInputType\n  }\n\n  export type UsersGroupByOutputType = {\n    id: string\n    user_role_id: string\n    username: string\n    email: string\n    bio: string | null\n    password_hash: string\n    created_at: Date\n    updated_at: Date\n    status: string\n    _count: UsersCountAggregateOutputType | null\n    _min: UsersMinAggregateOutputType | null\n    _max: UsersMaxAggregateOutputType | null\n  }\n\n  type GetUsersGroupByPayload<T extends usersGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<UsersGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], UsersGroupByOutputType[P]>\n            : GetScalarType<T[P], UsersGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type usersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    user_role_id?: boolean\n    username?: boolean\n    email?: boolean\n    bio?: boolean\n    password_hash?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    status?: boolean\n    role?: boolean | user_rolesDefaultArgs<ExtArgs>\n    posts?: boolean | users$postsArgs<ExtArgs>\n    comments?: boolean | users$commentsArgs<ExtArgs>\n    votes?: boolean | users$votesArgs<ExtArgs>\n    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"users\"]>\n\n  export type usersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    user_role_id?: boolean\n    username?: boolean\n    email?: boolean\n    bio?: boolean\n    password_hash?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    status?: boolean\n    role?: boolean | user_rolesDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"users\"]>\n\n  export type usersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    user_role_id?: boolean\n    username?: boolean\n    email?: boolean\n    bio?: boolean\n    password_hash?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    status?: boolean\n    role?: boolean | user_rolesDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"users\"]>\n\n  export type usersSelectScalar = {\n    id?: boolean\n    user_role_id?: boolean\n    username?: boolean\n    email?: boolean\n    bio?: boolean\n    password_hash?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    status?: boolean\n  }\n\n  export type usersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"user_role_id\" | \"username\" | \"email\" | \"bio\" | \"password_hash\" | \"created_at\" | \"updated_at\" | \"status\", ExtArgs[\"result\"][\"users\"]>\n  export type usersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    role?: boolean | user_rolesDefaultArgs<ExtArgs>\n    posts?: boolean | users$postsArgs<ExtArgs>\n    comments?: boolean | users$commentsArgs<ExtArgs>\n    votes?: boolean | users$votesArgs<ExtArgs>\n    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>\n  }\n  export type usersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    role?: boolean | user_rolesDefaultArgs<ExtArgs>\n  }\n  export type usersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    role?: boolean | user_rolesDefaultArgs<ExtArgs>\n  }\n\n  export type $usersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"users\"\n    objects: {\n      role: Prisma.$user_rolesPayload<ExtArgs>\n      posts: Prisma.$postsPayload<ExtArgs>[]\n      comments: Prisma.$commentsPayload<ExtArgs>[]\n      votes: Prisma.$votesPayload<ExtArgs>[]\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key. \n       * Unique identifier for each user.\n       */\n      id: string\n      /**\n       * Role of the user. Target model's {@link user_roles.id}.\n       * Determines user permissions such as regular member, moderator, or administrator.\n       */\n      user_role_id: string\n      /**\n       * Username visible on the platform - Implements profile display requirement. Must be unique and public. For example, 'politicoFan88'.\n       */\n      username: string\n      /**\n       * User's email address - Used for login and notifications. Must be unique. For example, 'user@example.com'.\n       */\n      email: string\n      /**\n       * Optional short biography - Lets users share info about themselves. For example, 'Economics student, debate enthusiast.'\n       */\n      bio: string | null\n      /**\n       * Hashed password - Implements security requirement. Stores a hashed version of the user password for authentication. Example: long hash string. Not public.\n       */\n      password_hash: string\n      /**\n       * Account creation timestamp - Implements auditability. For example, '2024-06-09T10:00:00+09:00'.\n       */\n      created_at: Date\n      /**\n       * Timestamp of last profile update - Implements history/auth traceability. For example, '2024-07-01T12:30:00+09:00'.\n       */\n      updated_at: Date\n      /**\n       * Account status - Implements moderation/authentication rules. For example, 'active', 'suspended', or 'banned'.\n       */\n      status: string\n    }, ExtArgs[\"result\"][\"users\"]>\n    composites: {}\n  }\n\n  type usersGetPayload<S extends boolean | null | undefined | usersDefaultArgs> = $Result.GetResult<Prisma.$usersPayload, S>\n\n  type usersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<usersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: UsersCountAggregateInputType | true\n    }\n\n  export interface usersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['users'], meta: { name: 'users' } }\n    /**\n     * Find zero or one Users that matches the filter.\n     * @param {usersFindUniqueArgs} args - Arguments to find a Users\n     * @example\n     * // Get one Users\n     * const users = await prisma.users.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends usersFindUniqueArgs>(args: SelectSubset<T, usersFindUniqueArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Users that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {usersFindUniqueOrThrowArgs} args - Arguments to find a Users\n     * @example\n     * // Get one Users\n     * const users = await prisma.users.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends usersFindUniqueOrThrowArgs>(args: SelectSubset<T, usersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Users that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {usersFindFirstArgs} args - Arguments to find a Users\n     * @example\n     * // Get one Users\n     * const users = await prisma.users.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends usersFindFirstArgs>(args?: SelectSubset<T, usersFindFirstArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Users that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {usersFindFirstOrThrowArgs} args - Arguments to find a Users\n     * @example\n     * // Get one Users\n     * const users = await prisma.users.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends usersFindFirstOrThrowArgs>(args?: SelectSubset<T, usersFindFirstOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Users that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {usersFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Users\n     * const users = await prisma.users.findMany()\n     * \n     * // Get first 10 Users\n     * const users = await prisma.users.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends usersFindManyArgs>(args?: SelectSubset<T, usersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Users.\n     * @param {usersCreateArgs} args - Arguments to create a Users.\n     * @example\n     * // Create one Users\n     * const Users = await prisma.users.create({\n     *   data: {\n     *     // ... data to create a Users\n     *   }\n     * })\n     * \n     */\n    create<T extends usersCreateArgs>(args: SelectSubset<T, usersCreateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Users.\n     * @param {usersCreateManyArgs} args - Arguments to create many Users.\n     * @example\n     * // Create many Users\n     * const users = await prisma.users.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends usersCreateManyArgs>(args?: SelectSubset<T, usersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Users and returns the data saved in the database.\n     * @param {usersCreateManyAndReturnArgs} args - Arguments to create many Users.\n     * @example\n     * // Create many Users\n     * const users = await prisma.users.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Users and only return the `id`\n     * const usersWithIdOnly = await prisma.users.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends usersCreateManyAndReturnArgs>(args?: SelectSubset<T, usersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Users.\n     * @param {usersDeleteArgs} args - Arguments to delete one Users.\n     * @example\n     * // Delete one Users\n     * const Users = await prisma.users.delete({\n     *   where: {\n     *     // ... filter to delete one Users\n     *   }\n     * })\n     * \n     */\n    delete<T extends usersDeleteArgs>(args: SelectSubset<T, usersDeleteArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Users.\n     * @param {usersUpdateArgs} args - Arguments to update one Users.\n     * @example\n     * // Update one Users\n     * const users = await prisma.users.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends usersUpdateArgs>(args: SelectSubset<T, usersUpdateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Users.\n     * @param {usersDeleteManyArgs} args - Arguments to filter Users to delete.\n     * @example\n     * // Delete a few Users\n     * const { count } = await prisma.users.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends usersDeleteManyArgs>(args?: SelectSubset<T, usersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Users.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {usersUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Users\n     * const users = await prisma.users.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends usersUpdateManyArgs>(args: SelectSubset<T, usersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Users and returns the data updated in the database.\n     * @param {usersUpdateManyAndReturnArgs} args - Arguments to update many Users.\n     * @example\n     * // Update many Users\n     * const users = await prisma.users.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Users and only return the `id`\n     * const usersWithIdOnly = await prisma.users.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends usersUpdateManyAndReturnArgs>(args: SelectSubset<T, usersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Users.\n     * @param {usersUpsertArgs} args - Arguments to update or create a Users.\n     * @example\n     * // Update or create a Users\n     * const users = await prisma.users.upsert({\n     *   create: {\n     *     // ... data to create a Users\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Users we want to update\n     *   }\n     * })\n     */\n    upsert<T extends usersUpsertArgs>(args: SelectSubset<T, usersUpsertArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Users.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {usersCountArgs} args - Arguments to filter Users to count.\n     * @example\n     * // Count the number of Users\n     * const count = await prisma.users.count({\n     *   where: {\n     *     // ... the filter for the Users we want to count\n     *   }\n     * })\n    **/\n    count<T extends usersCountArgs>(\n      args?: Subset<T, usersCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], UsersCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Users.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>\n\n    /**\n     * Group by Users.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {usersGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends usersGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: usersGroupByArgs['orderBy'] }\n        : { orderBy?: usersGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the users model\n   */\n  readonly fields: usersFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for users.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__usersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    role<T extends user_rolesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, user_rolesDefaultArgs<ExtArgs>>): Prisma__user_rolesClient<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    posts<T extends users$postsArgs<ExtArgs> = {}>(args?: Subset<T, users$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$postsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    comments<T extends users$commentsArgs<ExtArgs> = {}>(args?: Subset<T, users$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    votes<T extends users$votesArgs<ExtArgs> = {}>(args?: Subset<T, users$votesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$votesPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the users model\n   */\n  interface usersFieldRefs {\n    readonly id: FieldRef<\"users\", 'String'>\n    readonly user_role_id: FieldRef<\"users\", 'String'>\n    readonly username: FieldRef<\"users\", 'String'>\n    readonly email: FieldRef<\"users\", 'String'>\n    readonly bio: FieldRef<\"users\", 'String'>\n    readonly password_hash: FieldRef<\"users\", 'String'>\n    readonly created_at: FieldRef<\"users\", 'DateTime'>\n    readonly updated_at: FieldRef<\"users\", 'DateTime'>\n    readonly status: FieldRef<\"users\", 'String'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * users findUnique\n   */\n  export type usersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the users\n     */\n    select?: usersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the users\n     */\n    omit?: usersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: usersInclude<ExtArgs> | null\n    /**\n     * Filter, which users to fetch.\n     */\n    where: usersWhereUniqueInput\n  }\n\n  /**\n   * users findUniqueOrThrow\n   */\n  export type usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the users\n     */\n    select?: usersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the users\n     */\n    omit?: usersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: usersInclude<ExtArgs> | null\n    /**\n     * Filter, which users to fetch.\n     */\n    where: usersWhereUniqueInput\n  }\n\n  /**\n   * users findFirst\n   */\n  export type usersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the users\n     */\n    select?: usersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the users\n     */\n    omit?: usersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: usersInclude<ExtArgs> | null\n    /**\n     * Filter, which users to fetch.\n     */\n    where?: usersWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of users to fetch.\n     */\n    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for users.\n     */\n    cursor?: usersWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` users from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` users.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of users.\n     */\n    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]\n  }\n\n  /**\n   * users findFirstOrThrow\n   */\n  export type usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the users\n     */\n    select?: usersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the users\n     */\n    omit?: usersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: usersInclude<ExtArgs> | null\n    /**\n     * Filter, which users to fetch.\n     */\n    where?: usersWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of users to fetch.\n     */\n    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for users.\n     */\n    cursor?: usersWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` users from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` users.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of users.\n     */\n    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]\n  }\n\n  /**\n   * users findMany\n   */\n  export type usersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the users\n     */\n    select?: usersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the users\n     */\n    omit?: usersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: usersInclude<ExtArgs> | null\n    /**\n     * Filter, which users to fetch.\n     */\n    where?: usersWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of users to fetch.\n     */\n    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing users.\n     */\n    cursor?: usersWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` users from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` users.\n     */\n    skip?: number\n    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]\n  }\n\n  /**\n   * users create\n   */\n  export type usersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the users\n     */\n    select?: usersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the users\n     */\n    omit?: usersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: usersInclude<ExtArgs> | null\n    /**\n     * The data needed to create a users.\n     */\n    data: XOR<usersCreateInput, usersUncheckedCreateInput>\n  }\n\n  /**\n   * users createMany\n   */\n  export type usersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many users.\n     */\n    data: usersCreateManyInput | usersCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * users createManyAndReturn\n   */\n  export type usersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the users\n     */\n    select?: usersSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the users\n     */\n    omit?: usersOmit<ExtArgs> | null\n    /**\n     * The data used to create many users.\n     */\n    data: usersCreateManyInput | usersCreateManyInput[]\n    skipDuplicates?: boolean\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: usersIncludeCreateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * users update\n   */\n  export type usersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the users\n     */\n    select?: usersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the users\n     */\n    omit?: usersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: usersInclude<ExtArgs> | null\n    /**\n     * The data needed to update a users.\n     */\n    data: XOR<usersUpdateInput, usersUncheckedUpdateInput>\n    /**\n     * Choose, which users to update.\n     */\n    where: usersWhereUniqueInput\n  }\n\n  /**\n   * users updateMany\n   */\n  export type usersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update users.\n     */\n    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>\n    /**\n     * Filter which users to update\n     */\n    where?: usersWhereInput\n    /**\n     * Limit how many users to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * users updateManyAndReturn\n   */\n  export type usersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the users\n     */\n    select?: usersSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the users\n     */\n    omit?: usersOmit<ExtArgs> | null\n    /**\n     * The data used to update users.\n     */\n    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>\n    /**\n     * Filter which users to update\n     */\n    where?: usersWhereInput\n    /**\n     * Limit how many users to update.\n     */\n    limit?: number\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: usersIncludeUpdateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * users upsert\n   */\n  export type usersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the users\n     */\n    select?: usersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the users\n     */\n    omit?: usersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: usersInclude<ExtArgs> | null\n    /**\n     * The filter to search for the users to update in case it exists.\n     */\n    where: usersWhereUniqueInput\n    /**\n     * In case the users found by the `where` argument doesn't exist, create a new users with this data.\n     */\n    create: XOR<usersCreateInput, usersUncheckedCreateInput>\n    /**\n     * In case the users was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<usersUpdateInput, usersUncheckedUpdateInput>\n  }\n\n  /**\n   * users delete\n   */\n  export type usersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the users\n     */\n    select?: usersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the users\n     */\n    omit?: usersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: usersInclude<ExtArgs> | null\n    /**\n     * Filter which users to delete.\n     */\n    where: usersWhereUniqueInput\n  }\n\n  /**\n   * users deleteMany\n   */\n  export type usersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which users to delete\n     */\n    where?: usersWhereInput\n    /**\n     * Limit how many users to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * users.posts\n   */\n  export type users$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the posts\n     */\n    select?: postsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the posts\n     */\n    omit?: postsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: postsInclude<ExtArgs> | null\n    where?: postsWhereInput\n    orderBy?: postsOrderByWithRelationInput | postsOrderByWithRelationInput[]\n    cursor?: postsWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: PostsScalarFieldEnum | PostsScalarFieldEnum[]\n  }\n\n  /**\n   * users.comments\n   */\n  export type users$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the comments\n     */\n    select?: commentsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the comments\n     */\n    omit?: commentsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: commentsInclude<ExtArgs> | null\n    where?: commentsWhereInput\n    orderBy?: commentsOrderByWithRelationInput | commentsOrderByWithRelationInput[]\n    cursor?: commentsWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: CommentsScalarFieldEnum | CommentsScalarFieldEnum[]\n  }\n\n  /**\n   * users.votes\n   */\n  export type users$votesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the votes\n     */\n    select?: votesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the votes\n     */\n    omit?: votesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: votesInclude<ExtArgs> | null\n    where?: votesWhereInput\n    orderBy?: votesOrderByWithRelationInput | votesOrderByWithRelationInput[]\n    cursor?: votesWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: VotesScalarFieldEnum | VotesScalarFieldEnum[]\n  }\n\n  /**\n   * users without action\n   */\n  export type usersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the users\n     */\n    select?: usersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the users\n     */\n    omit?: usersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: usersInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Model user_roles\n   */\n\n  export type AggregateUser_roles = {\n    _count: User_rolesCountAggregateOutputType | null\n    _min: User_rolesMinAggregateOutputType | null\n    _max: User_rolesMaxAggregateOutputType | null\n  }\n\n  export type User_rolesMinAggregateOutputType = {\n    id: string | null\n    name: string | null\n    description: string | null\n  }\n\n  export type User_rolesMaxAggregateOutputType = {\n    id: string | null\n    name: string | null\n    description: string | null\n  }\n\n  export type User_rolesCountAggregateOutputType = {\n    id: number\n    name: number\n    description: number\n    _all: number\n  }\n\n\n  export type User_rolesMinAggregateInputType = {\n    id?: true\n    name?: true\n    description?: true\n  }\n\n  export type User_rolesMaxAggregateInputType = {\n    id?: true\n    name?: true\n    description?: true\n  }\n\n  export type User_rolesCountAggregateInputType = {\n    id?: true\n    name?: true\n    description?: true\n    _all?: true\n  }\n\n  export type User_rolesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which user_roles to aggregate.\n     */\n    where?: user_rolesWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of user_roles to fetch.\n     */\n    orderBy?: user_rolesOrderByWithRelationInput | user_rolesOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: user_rolesWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` user_roles from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` user_roles.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned user_roles\n    **/\n    _count?: true | User_rolesCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: User_rolesMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: User_rolesMaxAggregateInputType\n  }\n\n  export type GetUser_rolesAggregateType<T extends User_rolesAggregateArgs> = {\n        [P in keyof T & keyof AggregateUser_roles]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateUser_roles[P]>\n      : GetScalarType<T[P], AggregateUser_roles[P]>\n  }\n\n\n\n\n  export type user_rolesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: user_rolesWhereInput\n    orderBy?: user_rolesOrderByWithAggregationInput | user_rolesOrderByWithAggregationInput[]\n    by: User_rolesScalarFieldEnum[] | User_rolesScalarFieldEnum\n    having?: user_rolesScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: User_rolesCountAggregateInputType | true\n    _min?: User_rolesMinAggregateInputType\n    _max?: User_rolesMaxAggregateInputType\n  }\n\n  export type User_rolesGroupByOutputType = {\n    id: string\n    name: string\n    description: string\n    _count: User_rolesCountAggregateOutputType | null\n    _min: User_rolesMinAggregateOutputType | null\n    _max: User_rolesMaxAggregateOutputType | null\n  }\n\n  type GetUser_rolesGroupByPayload<T extends user_rolesGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<User_rolesGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof User_rolesGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], User_rolesGroupByOutputType[P]>\n            : GetScalarType<T[P], User_rolesGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type user_rolesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    name?: boolean\n    description?: boolean\n    users?: boolean | user_roles$usersArgs<ExtArgs>\n    _count?: boolean | User_rolesCountOutputTypeDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"user_roles\"]>\n\n  export type user_rolesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    name?: boolean\n    description?: boolean\n  }, ExtArgs[\"result\"][\"user_roles\"]>\n\n  export type user_rolesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    name?: boolean\n    description?: boolean\n  }, ExtArgs[\"result\"][\"user_roles\"]>\n\n  export type user_rolesSelectScalar = {\n    id?: boolean\n    name?: boolean\n    description?: boolean\n  }\n\n  export type user_rolesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"name\" | \"description\", ExtArgs[\"result\"][\"user_roles\"]>\n  export type user_rolesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    users?: boolean | user_roles$usersArgs<ExtArgs>\n    _count?: boolean | User_rolesCountOutputTypeDefaultArgs<ExtArgs>\n  }\n  export type user_rolesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}\n  export type user_rolesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}\n\n  export type $user_rolesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"user_roles\"\n    objects: {\n      users: Prisma.$usersPayload<ExtArgs>[]\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key. Unique identifier for user role.\n       */\n      id: string\n      /**\n       * Role label - Implements user roles requirement. Example: 'member', 'moderator', 'administrator'. Must be unique.\n       */\n      name: string\n      /**\n       * Role description - Gives context about permissions and duties; e.g., 'Can moderate comments and suspend users' for moderators.\n       */\n      description: string\n    }, ExtArgs[\"result\"][\"user_roles\"]>\n    composites: {}\n  }\n\n  type user_rolesGetPayload<S extends boolean | null | undefined | user_rolesDefaultArgs> = $Result.GetResult<Prisma.$user_rolesPayload, S>\n\n  type user_rolesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<user_rolesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: User_rolesCountAggregateInputType | true\n    }\n\n  export interface user_rolesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user_roles'], meta: { name: 'user_roles' } }\n    /**\n     * Find zero or one User_roles that matches the filter.\n     * @param {user_rolesFindUniqueArgs} args - Arguments to find a User_roles\n     * @example\n     * // Get one User_roles\n     * const user_roles = await prisma.user_roles.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends user_rolesFindUniqueArgs>(args: SelectSubset<T, user_rolesFindUniqueArgs<ExtArgs>>): Prisma__user_rolesClient<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one User_roles that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {user_rolesFindUniqueOrThrowArgs} args - Arguments to find a User_roles\n     * @example\n     * // Get one User_roles\n     * const user_roles = await prisma.user_roles.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends user_rolesFindUniqueOrThrowArgs>(args: SelectSubset<T, user_rolesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__user_rolesClient<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first User_roles that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {user_rolesFindFirstArgs} args - Arguments to find a User_roles\n     * @example\n     * // Get one User_roles\n     * const user_roles = await prisma.user_roles.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends user_rolesFindFirstArgs>(args?: SelectSubset<T, user_rolesFindFirstArgs<ExtArgs>>): Prisma__user_rolesClient<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first User_roles that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {user_rolesFindFirstOrThrowArgs} args - Arguments to find a User_roles\n     * @example\n     * // Get one User_roles\n     * const user_roles = await prisma.user_roles.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends user_rolesFindFirstOrThrowArgs>(args?: SelectSubset<T, user_rolesFindFirstOrThrowArgs<ExtArgs>>): Prisma__user_rolesClient<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more User_roles that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {user_rolesFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all User_roles\n     * const user_roles = await prisma.user_roles.findMany()\n     * \n     * // Get first 10 User_roles\n     * const user_roles = await prisma.user_roles.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const user_rolesWithIdOnly = await prisma.user_roles.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends user_rolesFindManyArgs>(args?: SelectSubset<T, user_rolesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a User_roles.\n     * @param {user_rolesCreateArgs} args - Arguments to create a User_roles.\n     * @example\n     * // Create one User_roles\n     * const User_roles = await prisma.user_roles.create({\n     *   data: {\n     *     // ... data to create a User_roles\n     *   }\n     * })\n     * \n     */\n    create<T extends user_rolesCreateArgs>(args: SelectSubset<T, user_rolesCreateArgs<ExtArgs>>): Prisma__user_rolesClient<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many User_roles.\n     * @param {user_rolesCreateManyArgs} args - Arguments to create many User_roles.\n     * @example\n     * // Create many User_roles\n     * const user_roles = await prisma.user_roles.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends user_rolesCreateManyArgs>(args?: SelectSubset<T, user_rolesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many User_roles and returns the data saved in the database.\n     * @param {user_rolesCreateManyAndReturnArgs} args - Arguments to create many User_roles.\n     * @example\n     * // Create many User_roles\n     * const user_roles = await prisma.user_roles.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many User_roles and only return the `id`\n     * const user_rolesWithIdOnly = await prisma.user_roles.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends user_rolesCreateManyAndReturnArgs>(args?: SelectSubset<T, user_rolesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a User_roles.\n     * @param {user_rolesDeleteArgs} args - Arguments to delete one User_roles.\n     * @example\n     * // Delete one User_roles\n     * const User_roles = await prisma.user_roles.delete({\n     *   where: {\n     *     // ... filter to delete one User_roles\n     *   }\n     * })\n     * \n     */\n    delete<T extends user_rolesDeleteArgs>(args: SelectSubset<T, user_rolesDeleteArgs<ExtArgs>>): Prisma__user_rolesClient<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one User_roles.\n     * @param {user_rolesUpdateArgs} args - Arguments to update one User_roles.\n     * @example\n     * // Update one User_roles\n     * const user_roles = await prisma.user_roles.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends user_rolesUpdateArgs>(args: SelectSubset<T, user_rolesUpdateArgs<ExtArgs>>): Prisma__user_rolesClient<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more User_roles.\n     * @param {user_rolesDeleteManyArgs} args - Arguments to filter User_roles to delete.\n     * @example\n     * // Delete a few User_roles\n     * const { count } = await prisma.user_roles.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends user_rolesDeleteManyArgs>(args?: SelectSubset<T, user_rolesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more User_roles.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {user_rolesUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many User_roles\n     * const user_roles = await prisma.user_roles.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends user_rolesUpdateManyArgs>(args: SelectSubset<T, user_rolesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more User_roles and returns the data updated in the database.\n     * @param {user_rolesUpdateManyAndReturnArgs} args - Arguments to update many User_roles.\n     * @example\n     * // Update many User_roles\n     * const user_roles = await prisma.user_roles.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more User_roles and only return the `id`\n     * const user_rolesWithIdOnly = await prisma.user_roles.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends user_rolesUpdateManyAndReturnArgs>(args: SelectSubset<T, user_rolesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one User_roles.\n     * @param {user_rolesUpsertArgs} args - Arguments to update or create a User_roles.\n     * @example\n     * // Update or create a User_roles\n     * const user_roles = await prisma.user_roles.upsert({\n     *   create: {\n     *     // ... data to create a User_roles\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the User_roles we want to update\n     *   }\n     * })\n     */\n    upsert<T extends user_rolesUpsertArgs>(args: SelectSubset<T, user_rolesUpsertArgs<ExtArgs>>): Prisma__user_rolesClient<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of User_roles.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {user_rolesCountArgs} args - Arguments to filter User_roles to count.\n     * @example\n     * // Count the number of User_roles\n     * const count = await prisma.user_roles.count({\n     *   where: {\n     *     // ... the filter for the User_roles we want to count\n     *   }\n     * })\n    **/\n    count<T extends user_rolesCountArgs>(\n      args?: Subset<T, user_rolesCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], User_rolesCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a User_roles.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {User_rolesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends User_rolesAggregateArgs>(args: Subset<T, User_rolesAggregateArgs>): Prisma.PrismaPromise<GetUser_rolesAggregateType<T>>\n\n    /**\n     * Group by User_roles.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {user_rolesGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends user_rolesGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: user_rolesGroupByArgs['orderBy'] }\n        : { orderBy?: user_rolesGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, user_rolesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_rolesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the user_roles model\n   */\n  readonly fields: user_rolesFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for user_roles.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__user_rolesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    users<T extends user_roles$usersArgs<ExtArgs> = {}>(args?: Subset<T, user_roles$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the user_roles model\n   */\n  interface user_rolesFieldRefs {\n    readonly id: FieldRef<\"user_roles\", 'String'>\n    readonly name: FieldRef<\"user_roles\", 'String'>\n    readonly description: FieldRef<\"user_roles\", 'String'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * user_roles findUnique\n   */\n  export type user_rolesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the user_roles\n     */\n    select?: user_rolesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the user_roles\n     */\n    omit?: user_rolesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: user_rolesInclude<ExtArgs> | null\n    /**\n     * Filter, which user_roles to fetch.\n     */\n    where: user_rolesWhereUniqueInput\n  }\n\n  /**\n   * user_roles findUniqueOrThrow\n   */\n  export type user_rolesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the user_roles\n     */\n    select?: user_rolesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the user_roles\n     */\n    omit?: user_rolesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: user_rolesInclude<ExtArgs> | null\n    /**\n     * Filter, which user_roles to fetch.\n     */\n    where: user_rolesWhereUniqueInput\n  }\n\n  /**\n   * user_roles findFirst\n   */\n  export type user_rolesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the user_roles\n     */\n    select?: user_rolesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the user_roles\n     */\n    omit?: user_rolesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: user_rolesInclude<ExtArgs> | null\n    /**\n     * Filter, which user_roles to fetch.\n     */\n    where?: user_rolesWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of user_roles to fetch.\n     */\n    orderBy?: user_rolesOrderByWithRelationInput | user_rolesOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for user_roles.\n     */\n    cursor?: user_rolesWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` user_roles from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` user_roles.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of user_roles.\n     */\n    distinct?: User_rolesScalarFieldEnum | User_rolesScalarFieldEnum[]\n  }\n\n  /**\n   * user_roles findFirstOrThrow\n   */\n  export type user_rolesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the user_roles\n     */\n    select?: user_rolesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the user_roles\n     */\n    omit?: user_rolesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: user_rolesInclude<ExtArgs> | null\n    /**\n     * Filter, which user_roles to fetch.\n     */\n    where?: user_rolesWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of user_roles to fetch.\n     */\n    orderBy?: user_rolesOrderByWithRelationInput | user_rolesOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for user_roles.\n     */\n    cursor?: user_rolesWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` user_roles from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` user_roles.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of user_roles.\n     */\n    distinct?: User_rolesScalarFieldEnum | User_rolesScalarFieldEnum[]\n  }\n\n  /**\n   * user_roles findMany\n   */\n  export type user_rolesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the user_roles\n     */\n    select?: user_rolesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the user_roles\n     */\n    omit?: user_rolesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: user_rolesInclude<ExtArgs> | null\n    /**\n     * Filter, which user_roles to fetch.\n     */\n    where?: user_rolesWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of user_roles to fetch.\n     */\n    orderBy?: user_rolesOrderByWithRelationInput | user_rolesOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing user_roles.\n     */\n    cursor?: user_rolesWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` user_roles from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` user_roles.\n     */\n    skip?: number\n    distinct?: User_rolesScalarFieldEnum | User_rolesScalarFieldEnum[]\n  }\n\n  /**\n   * user_roles create\n   */\n  export type user_rolesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the user_roles\n     */\n    select?: user_rolesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the user_roles\n     */\n    omit?: user_rolesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: user_rolesInclude<ExtArgs> | null\n    /**\n     * The data needed to create a user_roles.\n     */\n    data: XOR<user_rolesCreateInput, user_rolesUncheckedCreateInput>\n  }\n\n  /**\n   * user_roles createMany\n   */\n  export type user_rolesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many user_roles.\n     */\n    data: user_rolesCreateManyInput | user_rolesCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * user_roles createManyAndReturn\n   */\n  export type user_rolesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the user_roles\n     */\n    select?: user_rolesSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the user_roles\n     */\n    omit?: user_rolesOmit<ExtArgs> | null\n    /**\n     * The data used to create many user_roles.\n     */\n    data: user_rolesCreateManyInput | user_rolesCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * user_roles update\n   */\n  export type user_rolesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the user_roles\n     */\n    select?: user_rolesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the user_roles\n     */\n    omit?: user_rolesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: user_rolesInclude<ExtArgs> | null\n    /**\n     * The data needed to update a user_roles.\n     */\n    data: XOR<user_rolesUpdateInput, user_rolesUncheckedUpdateInput>\n    /**\n     * Choose, which user_roles to update.\n     */\n    where: user_rolesWhereUniqueInput\n  }\n\n  /**\n   * user_roles updateMany\n   */\n  export type user_rolesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update user_roles.\n     */\n    data: XOR<user_rolesUpdateManyMutationInput, user_rolesUncheckedUpdateManyInput>\n    /**\n     * Filter which user_roles to update\n     */\n    where?: user_rolesWhereInput\n    /**\n     * Limit how many user_roles to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * user_roles updateManyAndReturn\n   */\n  export type user_rolesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the user_roles\n     */\n    select?: user_rolesSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the user_roles\n     */\n    omit?: user_rolesOmit<ExtArgs> | null\n    /**\n     * The data used to update user_roles.\n     */\n    data: XOR<user_rolesUpdateManyMutationInput, user_rolesUncheckedUpdateManyInput>\n    /**\n     * Filter which user_roles to update\n     */\n    where?: user_rolesWhereInput\n    /**\n     * Limit how many user_roles to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * user_roles upsert\n   */\n  export type user_rolesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the user_roles\n     */\n    select?: user_rolesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the user_roles\n     */\n    omit?: user_rolesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: user_rolesInclude<ExtArgs> | null\n    /**\n     * The filter to search for the user_roles to update in case it exists.\n     */\n    where: user_rolesWhereUniqueInput\n    /**\n     * In case the user_roles found by the `where` argument doesn't exist, create a new user_roles with this data.\n     */\n    create: XOR<user_rolesCreateInput, user_rolesUncheckedCreateInput>\n    /**\n     * In case the user_roles was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<user_rolesUpdateInput, user_rolesUncheckedUpdateInput>\n  }\n\n  /**\n   * user_roles delete\n   */\n  export type user_rolesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the user_roles\n     */\n    select?: user_rolesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the user_roles\n     */\n    omit?: user_rolesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: user_rolesInclude<ExtArgs> | null\n    /**\n     * Filter which user_roles to delete.\n     */\n    where: user_rolesWhereUniqueInput\n  }\n\n  /**\n   * user_roles deleteMany\n   */\n  export type user_rolesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which user_roles to delete\n     */\n    where?: user_rolesWhereInput\n    /**\n     * Limit how many user_roles to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * user_roles.users\n   */\n  export type user_roles$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the users\n     */\n    select?: usersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the users\n     */\n    omit?: usersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: usersInclude<ExtArgs> | null\n    where?: usersWhereInput\n    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]\n    cursor?: usersWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]\n  }\n\n  /**\n   * user_roles without action\n   */\n  export type user_rolesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the user_roles\n     */\n    select?: user_rolesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the user_roles\n     */\n    omit?: user_rolesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: user_rolesInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Model categories\n   */\n\n  export type AggregateCategories = {\n    _count: CategoriesCountAggregateOutputType | null\n    _min: CategoriesMinAggregateOutputType | null\n    _max: CategoriesMaxAggregateOutputType | null\n  }\n\n  export type CategoriesMinAggregateOutputType = {\n    id: string | null\n    name: string | null\n    description: string | null\n    created_at: Date | null\n  }\n\n  export type CategoriesMaxAggregateOutputType = {\n    id: string | null\n    name: string | null\n    description: string | null\n    created_at: Date | null\n  }\n\n  export type CategoriesCountAggregateOutputType = {\n    id: number\n    name: number\n    description: number\n    created_at: number\n    _all: number\n  }\n\n\n  export type CategoriesMinAggregateInputType = {\n    id?: true\n    name?: true\n    description?: true\n    created_at?: true\n  }\n\n  export type CategoriesMaxAggregateInputType = {\n    id?: true\n    name?: true\n    description?: true\n    created_at?: true\n  }\n\n  export type CategoriesCountAggregateInputType = {\n    id?: true\n    name?: true\n    description?: true\n    created_at?: true\n    _all?: true\n  }\n\n  export type CategoriesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which categories to aggregate.\n     */\n    where?: categoriesWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of categories to fetch.\n     */\n    orderBy?: categoriesOrderByWithRelationInput | categoriesOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: categoriesWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` categories from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` categories.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned categories\n    **/\n    _count?: true | CategoriesCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: CategoriesMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: CategoriesMaxAggregateInputType\n  }\n\n  export type GetCategoriesAggregateType<T extends CategoriesAggregateArgs> = {\n        [P in keyof T & keyof AggregateCategories]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateCategories[P]>\n      : GetScalarType<T[P], AggregateCategories[P]>\n  }\n\n\n\n\n  export type categoriesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: categoriesWhereInput\n    orderBy?: categoriesOrderByWithAggregationInput | categoriesOrderByWithAggregationInput[]\n    by: CategoriesScalarFieldEnum[] | CategoriesScalarFieldEnum\n    having?: categoriesScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: CategoriesCountAggregateInputType | true\n    _min?: CategoriesMinAggregateInputType\n    _max?: CategoriesMaxAggregateInputType\n  }\n\n  export type CategoriesGroupByOutputType = {\n    id: string\n    name: string\n    description: string\n    created_at: Date\n    _count: CategoriesCountAggregateOutputType | null\n    _min: CategoriesMinAggregateOutputType | null\n    _max: CategoriesMaxAggregateOutputType | null\n  }\n\n  type GetCategoriesGroupByPayload<T extends categoriesGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<CategoriesGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof CategoriesGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], CategoriesGroupByOutputType[P]>\n            : GetScalarType<T[P], CategoriesGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type categoriesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    name?: boolean\n    description?: boolean\n    created_at?: boolean\n    posts?: boolean | categories$postsArgs<ExtArgs>\n    _count?: boolean | CategoriesCountOutputTypeDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"categories\"]>\n\n  export type categoriesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    name?: boolean\n    description?: boolean\n    created_at?: boolean\n  }, ExtArgs[\"result\"][\"categories\"]>\n\n  export type categoriesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    name?: boolean\n    description?: boolean\n    created_at?: boolean\n  }, ExtArgs[\"result\"][\"categories\"]>\n\n  export type categoriesSelectScalar = {\n    id?: boolean\n    name?: boolean\n    description?: boolean\n    created_at?: boolean\n  }\n\n  export type categoriesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"name\" | \"description\" | \"created_at\", ExtArgs[\"result\"][\"categories\"]>\n  export type categoriesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    posts?: boolean | categories$postsArgs<ExtArgs>\n    _count?: boolean | CategoriesCountOutputTypeDefaultArgs<ExtArgs>\n  }\n  export type categoriesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}\n  export type categoriesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}\n\n  export type $categoriesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"categories\"\n    objects: {\n      posts: Prisma.$postsPayload<ExtArgs>[]\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key. Unique identifier for category.\n       */\n      id: string\n      /**\n       * Category name - Implements content organization and navigation requirement. For example, 'Politics'. Must be unique per category.\n       */\n      name: string\n      /**\n       * Category description - Explains scope. For example, 'Discussion about domestic and international political systems, governance, and related events.'\n       */\n      description: string\n      /**\n       * Timestamp when the category was added - Implements audit trail. Example: '2024-06-09T09:00:00+09:00'.\n       */\n      created_at: Date\n    }, ExtArgs[\"result\"][\"categories\"]>\n    composites: {}\n  }\n\n  type categoriesGetPayload<S extends boolean | null | undefined | categoriesDefaultArgs> = $Result.GetResult<Prisma.$categoriesPayload, S>\n\n  type categoriesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<categoriesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: CategoriesCountAggregateInputType | true\n    }\n\n  export interface categoriesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['categories'], meta: { name: 'categories' } }\n    /**\n     * Find zero or one Categories that matches the filter.\n     * @param {categoriesFindUniqueArgs} args - Arguments to find a Categories\n     * @example\n     * // Get one Categories\n     * const categories = await prisma.categories.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends categoriesFindUniqueArgs>(args: SelectSubset<T, categoriesFindUniqueArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Categories that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {categoriesFindUniqueOrThrowArgs} args - Arguments to find a Categories\n     * @example\n     * // Get one Categories\n     * const categories = await prisma.categories.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends categoriesFindUniqueOrThrowArgs>(args: SelectSubset<T, categoriesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Categories that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {categoriesFindFirstArgs} args - Arguments to find a Categories\n     * @example\n     * // Get one Categories\n     * const categories = await prisma.categories.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends categoriesFindFirstArgs>(args?: SelectSubset<T, categoriesFindFirstArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Categories that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {categoriesFindFirstOrThrowArgs} args - Arguments to find a Categories\n     * @example\n     * // Get one Categories\n     * const categories = await prisma.categories.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends categoriesFindFirstOrThrowArgs>(args?: SelectSubset<T, categoriesFindFirstOrThrowArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Categories that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {categoriesFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Categories\n     * const categories = await prisma.categories.findMany()\n     * \n     * // Get first 10 Categories\n     * const categories = await prisma.categories.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const categoriesWithIdOnly = await prisma.categories.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends categoriesFindManyArgs>(args?: SelectSubset<T, categoriesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Categories.\n     * @param {categoriesCreateArgs} args - Arguments to create a Categories.\n     * @example\n     * // Create one Categories\n     * const Categories = await prisma.categories.create({\n     *   data: {\n     *     // ... data to create a Categories\n     *   }\n     * })\n     * \n     */\n    create<T extends categoriesCreateArgs>(args: SelectSubset<T, categoriesCreateArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Categories.\n     * @param {categoriesCreateManyArgs} args - Arguments to create many Categories.\n     * @example\n     * // Create many Categories\n     * const categories = await prisma.categories.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends categoriesCreateManyArgs>(args?: SelectSubset<T, categoriesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Categories and returns the data saved in the database.\n     * @param {categoriesCreateManyAndReturnArgs} args - Arguments to create many Categories.\n     * @example\n     * // Create many Categories\n     * const categories = await prisma.categories.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Categories and only return the `id`\n     * const categoriesWithIdOnly = await prisma.categories.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends categoriesCreateManyAndReturnArgs>(args?: SelectSubset<T, categoriesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Categories.\n     * @param {categoriesDeleteArgs} args - Arguments to delete one Categories.\n     * @example\n     * // Delete one Categories\n     * const Categories = await prisma.categories.delete({\n     *   where: {\n     *     // ... filter to delete one Categories\n     *   }\n     * })\n     * \n     */\n    delete<T extends categoriesDeleteArgs>(args: SelectSubset<T, categoriesDeleteArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Categories.\n     * @param {categoriesUpdateArgs} args - Arguments to update one Categories.\n     * @example\n     * // Update one Categories\n     * const categories = await prisma.categories.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends categoriesUpdateArgs>(args: SelectSubset<T, categoriesUpdateArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Categories.\n     * @param {categoriesDeleteManyArgs} args - Arguments to filter Categories to delete.\n     * @example\n     * // Delete a few Categories\n     * const { count } = await prisma.categories.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends categoriesDeleteManyArgs>(args?: SelectSubset<T, categoriesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Categories.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {categoriesUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Categories\n     * const categories = await prisma.categories.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends categoriesUpdateManyArgs>(args: SelectSubset<T, categoriesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Categories and returns the data updated in the database.\n     * @param {categoriesUpdateManyAndReturnArgs} args - Arguments to update many Categories.\n     * @example\n     * // Update many Categories\n     * const categories = await prisma.categories.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Categories and only return the `id`\n     * const categoriesWithIdOnly = await prisma.categories.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends categoriesUpdateManyAndReturnArgs>(args: SelectSubset<T, categoriesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Categories.\n     * @param {categoriesUpsertArgs} args - Arguments to update or create a Categories.\n     * @example\n     * // Update or create a Categories\n     * const categories = await prisma.categories.upsert({\n     *   create: {\n     *     // ... data to create a Categories\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Categories we want to update\n     *   }\n     * })\n     */\n    upsert<T extends categoriesUpsertArgs>(args: SelectSubset<T, categoriesUpsertArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Categories.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {categoriesCountArgs} args - Arguments to filter Categories to count.\n     * @example\n     * // Count the number of Categories\n     * const count = await prisma.categories.count({\n     *   where: {\n     *     // ... the filter for the Categories we want to count\n     *   }\n     * })\n    **/\n    count<T extends categoriesCountArgs>(\n      args?: Subset<T, categoriesCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], CategoriesCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Categories.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {CategoriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends CategoriesAggregateArgs>(args: Subset<T, CategoriesAggregateArgs>): Prisma.PrismaPromise<GetCategoriesAggregateType<T>>\n\n    /**\n     * Group by Categories.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {categoriesGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends categoriesGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: categoriesGroupByArgs['orderBy'] }\n        : { orderBy?: categoriesGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, categoriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the categories model\n   */\n  readonly fields: categoriesFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for categories.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__categoriesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    posts<T extends categories$postsArgs<ExtArgs> = {}>(args?: Subset<T, categories$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$postsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the categories model\n   */\n  interface categoriesFieldRefs {\n    readonly id: FieldRef<\"categories\", 'String'>\n    readonly name: FieldRef<\"categories\", 'String'>\n    readonly description: FieldRef<\"categories\", 'String'>\n    readonly created_at: FieldRef<\"categories\", 'DateTime'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * categories findUnique\n   */\n  export type categoriesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the categories\n     */\n    select?: categoriesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the categories\n     */\n    omit?: categoriesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: categoriesInclude<ExtArgs> | null\n    /**\n     * Filter, which categories to fetch.\n     */\n    where: categoriesWhereUniqueInput\n  }\n\n  /**\n   * categories findUniqueOrThrow\n   */\n  export type categoriesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the categories\n     */\n    select?: categoriesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the categories\n     */\n    omit?: categoriesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: categoriesInclude<ExtArgs> | null\n    /**\n     * Filter, which categories to fetch.\n     */\n    where: categoriesWhereUniqueInput\n  }\n\n  /**\n   * categories findFirst\n   */\n  export type categoriesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the categories\n     */\n    select?: categoriesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the categories\n     */\n    omit?: categoriesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: categoriesInclude<ExtArgs> | null\n    /**\n     * Filter, which categories to fetch.\n     */\n    where?: categoriesWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of categories to fetch.\n     */\n    orderBy?: categoriesOrderByWithRelationInput | categoriesOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for categories.\n     */\n    cursor?: categoriesWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` categories from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` categories.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of categories.\n     */\n    distinct?: CategoriesScalarFieldEnum | CategoriesScalarFieldEnum[]\n  }\n\n  /**\n   * categories findFirstOrThrow\n   */\n  export type categoriesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the categories\n     */\n    select?: categoriesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the categories\n     */\n    omit?: categoriesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: categoriesInclude<ExtArgs> | null\n    /**\n     * Filter, which categories to fetch.\n     */\n    where?: categoriesWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of categories to fetch.\n     */\n    orderBy?: categoriesOrderByWithRelationInput | categoriesOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for categories.\n     */\n    cursor?: categoriesWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` categories from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` categories.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of categories.\n     */\n    distinct?: CategoriesScalarFieldEnum | CategoriesScalarFieldEnum[]\n  }\n\n  /**\n   * categories findMany\n   */\n  export type categoriesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the categories\n     */\n    select?: categoriesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the categories\n     */\n    omit?: categoriesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: categoriesInclude<ExtArgs> | null\n    /**\n     * Filter, which categories to fetch.\n     */\n    where?: categoriesWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of categories to fetch.\n     */\n    orderBy?: categoriesOrderByWithRelationInput | categoriesOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing categories.\n     */\n    cursor?: categoriesWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` categories from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` categories.\n     */\n    skip?: number\n    distinct?: CategoriesScalarFieldEnum | CategoriesScalarFieldEnum[]\n  }\n\n  /**\n   * categories create\n   */\n  export type categoriesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the categories\n     */\n    select?: categoriesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the categories\n     */\n    omit?: categoriesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: categoriesInclude<ExtArgs> | null\n    /**\n     * The data needed to create a categories.\n     */\n    data: XOR<categoriesCreateInput, categoriesUncheckedCreateInput>\n  }\n\n  /**\n   * categories createMany\n   */\n  export type categoriesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many categories.\n     */\n    data: categoriesCreateManyInput | categoriesCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * categories createManyAndReturn\n   */\n  export type categoriesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the categories\n     */\n    select?: categoriesSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the categories\n     */\n    omit?: categoriesOmit<ExtArgs> | null\n    /**\n     * The data used to create many categories.\n     */\n    data: categoriesCreateManyInput | categoriesCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * categories update\n   */\n  export type categoriesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the categories\n     */\n    select?: categoriesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the categories\n     */\n    omit?: categoriesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: categoriesInclude<ExtArgs> | null\n    /**\n     * The data needed to update a categories.\n     */\n    data: XOR<categoriesUpdateInput, categoriesUncheckedUpdateInput>\n    /**\n     * Choose, which categories to update.\n     */\n    where: categoriesWhereUniqueInput\n  }\n\n  /**\n   * categories updateMany\n   */\n  export type categoriesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update categories.\n     */\n    data: XOR<categoriesUpdateManyMutationInput, categoriesUncheckedUpdateManyInput>\n    /**\n     * Filter which categories to update\n     */\n    where?: categoriesWhereInput\n    /**\n     * Limit how many categories to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * categories updateManyAndReturn\n   */\n  export type categoriesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the categories\n     */\n    select?: categoriesSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the categories\n     */\n    omit?: categoriesOmit<ExtArgs> | null\n    /**\n     * The data used to update categories.\n     */\n    data: XOR<categoriesUpdateManyMutationInput, categoriesUncheckedUpdateManyInput>\n    /**\n     * Filter which categories to update\n     */\n    where?: categoriesWhereInput\n    /**\n     * Limit how many categories to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * categories upsert\n   */\n  export type categoriesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the categories\n     */\n    select?: categoriesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the categories\n     */\n    omit?: categoriesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: categoriesInclude<ExtArgs> | null\n    /**\n     * The filter to search for the categories to update in case it exists.\n     */\n    where: categoriesWhereUniqueInput\n    /**\n     * In case the categories found by the `where` argument doesn't exist, create a new categories with this data.\n     */\n    create: XOR<categoriesCreateInput, categoriesUncheckedCreateInput>\n    /**\n     * In case the categories was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<categoriesUpdateInput, categoriesUncheckedUpdateInput>\n  }\n\n  /**\n   * categories delete\n   */\n  export type categoriesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the categories\n     */\n    select?: categoriesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the categories\n     */\n    omit?: categoriesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: categoriesInclude<ExtArgs> | null\n    /**\n     * Filter which categories to delete.\n     */\n    where: categoriesWhereUniqueInput\n  }\n\n  /**\n   * categories deleteMany\n   */\n  export type categoriesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which categories to delete\n     */\n    where?: categoriesWhereInput\n    /**\n     * Limit how many categories to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * categories.posts\n   */\n  export type categories$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the posts\n     */\n    select?: postsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the posts\n     */\n    omit?: postsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: postsInclude<ExtArgs> | null\n    where?: postsWhereInput\n    orderBy?: postsOrderByWithRelationInput | postsOrderByWithRelationInput[]\n    cursor?: postsWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: PostsScalarFieldEnum | PostsScalarFieldEnum[]\n  }\n\n  /**\n   * categories without action\n   */\n  export type categoriesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the categories\n     */\n    select?: categoriesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the categories\n     */\n    omit?: categoriesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: categoriesInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Model posts\n   */\n\n  export type AggregatePosts = {\n    _count: PostsCountAggregateOutputType | null\n    _min: PostsMinAggregateOutputType | null\n    _max: PostsMaxAggregateOutputType | null\n  }\n\n  export type PostsMinAggregateOutputType = {\n    id: string | null\n    user_id: string | null\n    category_id: string | null\n    title: string | null\n    content: string | null\n    created_at: Date | null\n    updated_at: Date | null\n    deleted_at: Date | null\n  }\n\n  export type PostsMaxAggregateOutputType = {\n    id: string | null\n    user_id: string | null\n    category_id: string | null\n    title: string | null\n    content: string | null\n    created_at: Date | null\n    updated_at: Date | null\n    deleted_at: Date | null\n  }\n\n  export type PostsCountAggregateOutputType = {\n    id: number\n    user_id: number\n    category_id: number\n    title: number\n    content: number\n    created_at: number\n    updated_at: number\n    deleted_at: number\n    _all: number\n  }\n\n\n  export type PostsMinAggregateInputType = {\n    id?: true\n    user_id?: true\n    category_id?: true\n    title?: true\n    content?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n  }\n\n  export type PostsMaxAggregateInputType = {\n    id?: true\n    user_id?: true\n    category_id?: true\n    title?: true\n    content?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n  }\n\n  export type PostsCountAggregateInputType = {\n    id?: true\n    user_id?: true\n    category_id?: true\n    title?: true\n    content?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n    _all?: true\n  }\n\n  export type PostsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which posts to aggregate.\n     */\n    where?: postsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of posts to fetch.\n     */\n    orderBy?: postsOrderByWithRelationInput | postsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: postsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` posts from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` posts.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned posts\n    **/\n    _count?: true | PostsCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: PostsMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: PostsMaxAggregateInputType\n  }\n\n  export type GetPostsAggregateType<T extends PostsAggregateArgs> = {\n        [P in keyof T & keyof AggregatePosts]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregatePosts[P]>\n      : GetScalarType<T[P], AggregatePosts[P]>\n  }\n\n\n\n\n  export type postsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: postsWhereInput\n    orderBy?: postsOrderByWithAggregationInput | postsOrderByWithAggregationInput[]\n    by: PostsScalarFieldEnum[] | PostsScalarFieldEnum\n    having?: postsScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: PostsCountAggregateInputType | true\n    _min?: PostsMinAggregateInputType\n    _max?: PostsMaxAggregateInputType\n  }\n\n  export type PostsGroupByOutputType = {\n    id: string\n    user_id: string\n    category_id: string\n    title: string\n    content: string\n    created_at: Date\n    updated_at: Date\n    deleted_at: Date | null\n    _count: PostsCountAggregateOutputType | null\n    _min: PostsMinAggregateOutputType | null\n    _max: PostsMaxAggregateOutputType | null\n  }\n\n  type GetPostsGroupByPayload<T extends postsGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<PostsGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof PostsGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], PostsGroupByOutputType[P]>\n            : GetScalarType<T[P], PostsGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type postsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    user_id?: boolean\n    category_id?: boolean\n    title?: boolean\n    content?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    author?: boolean | usersDefaultArgs<ExtArgs>\n    category?: boolean | categoriesDefaultArgs<ExtArgs>\n    comments?: boolean | posts$commentsArgs<ExtArgs>\n    votes?: boolean | posts$votesArgs<ExtArgs>\n    _count?: boolean | PostsCountOutputTypeDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"posts\"]>\n\n  export type postsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    user_id?: boolean\n    category_id?: boolean\n    title?: boolean\n    content?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    author?: boolean | usersDefaultArgs<ExtArgs>\n    category?: boolean | categoriesDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"posts\"]>\n\n  export type postsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    user_id?: boolean\n    category_id?: boolean\n    title?: boolean\n    content?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    author?: boolean | usersDefaultArgs<ExtArgs>\n    category?: boolean | categoriesDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"posts\"]>\n\n  export type postsSelectScalar = {\n    id?: boolean\n    user_id?: boolean\n    category_id?: boolean\n    title?: boolean\n    content?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n  }\n\n  export type postsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"user_id\" | \"category_id\" | \"title\" | \"content\" | \"created_at\" | \"updated_at\" | \"deleted_at\", ExtArgs[\"result\"][\"posts\"]>\n  export type postsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    author?: boolean | usersDefaultArgs<ExtArgs>\n    category?: boolean | categoriesDefaultArgs<ExtArgs>\n    comments?: boolean | posts$commentsArgs<ExtArgs>\n    votes?: boolean | posts$votesArgs<ExtArgs>\n    _count?: boolean | PostsCountOutputTypeDefaultArgs<ExtArgs>\n  }\n  export type postsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    author?: boolean | usersDefaultArgs<ExtArgs>\n    category?: boolean | categoriesDefaultArgs<ExtArgs>\n  }\n  export type postsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    author?: boolean | usersDefaultArgs<ExtArgs>\n    category?: boolean | categoriesDefaultArgs<ExtArgs>\n  }\n\n  export type $postsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"posts\"\n    objects: {\n      author: Prisma.$usersPayload<ExtArgs>\n      category: Prisma.$categoriesPayload<ExtArgs>\n      comments: Prisma.$commentsPayload<ExtArgs>[]\n      votes: Prisma.$votesPayload<ExtArgs>[]\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key. Unique identifier for each post.\n       */\n      id: string\n      /**\n       * Author's {@link users.id} - Links each post to its authoring user account. Enforces the association between posts and registered users. Required for accountability and profile-related features.\n       */\n      user_id: string\n      /**\n       * Category's {@link categories.id} - Associates the post with a topic/category, used for board structure and navigation. Enforces the requirement that every post has a topical context.\n       */\n      category_id: string\n      /**\n       * Title of the post - Implements the requirement that each post has a headline/subject. Business meaning: summary/subject line visible in post lists and thread views. For example, 'Economic Impact of Inflation in 2025'.\n       */\n      title: string\n      /**\n       * Body content of the post - Implements the rule that posts have main text where users express opinions, share news, analysis, etc. For example, a 400-word analysis of current economic events. Allows rich content or text.\n       */\n      content: string\n      /**\n       * Creation timestamp - Implements transparency and audit requirements by recording when the post was created. Business use: shows recency in lists, allows moderation tracking.\n       */\n      created_at: Date\n      /**\n       * Last edited timestamp - Allows tracking of post edits for evidence/history. Enforces business constraint of allowing users to edit posts within the permitted window. For example, updated_at is changed when a user fixes a typo.\n       */\n      updated_at: Date\n      /**\n       * Soft deletion timestamp - Implements moderation rules (see Moderation and User Roles). Posts are not hard deleted but marked with this field if removed for rule violations or by user request. For example, moderators mark spam here for audit/history.\n       */\n      deleted_at: Date | null\n    }, ExtArgs[\"result\"][\"posts\"]>\n    composites: {}\n  }\n\n  type postsGetPayload<S extends boolean | null | undefined | postsDefaultArgs> = $Result.GetResult<Prisma.$postsPayload, S>\n\n  type postsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<postsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: PostsCountAggregateInputType | true\n    }\n\n  export interface postsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['posts'], meta: { name: 'posts' } }\n    /**\n     * Find zero or one Posts that matches the filter.\n     * @param {postsFindUniqueArgs} args - Arguments to find a Posts\n     * @example\n     * // Get one Posts\n     * const posts = await prisma.posts.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends postsFindUniqueArgs>(args: SelectSubset<T, postsFindUniqueArgs<ExtArgs>>): Prisma__postsClient<$Result.GetResult<Prisma.$postsPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Posts that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {postsFindUniqueOrThrowArgs} args - Arguments to find a Posts\n     * @example\n     * // Get one Posts\n     * const posts = await prisma.posts.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends postsFindUniqueOrThrowArgs>(args: SelectSubset<T, postsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__postsClient<$Result.GetResult<Prisma.$postsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Posts that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {postsFindFirstArgs} args - Arguments to find a Posts\n     * @example\n     * // Get one Posts\n     * const posts = await prisma.posts.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends postsFindFirstArgs>(args?: SelectSubset<T, postsFindFirstArgs<ExtArgs>>): Prisma__postsClient<$Result.GetResult<Prisma.$postsPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Posts that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {postsFindFirstOrThrowArgs} args - Arguments to find a Posts\n     * @example\n     * // Get one Posts\n     * const posts = await prisma.posts.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends postsFindFirstOrThrowArgs>(args?: SelectSubset<T, postsFindFirstOrThrowArgs<ExtArgs>>): Prisma__postsClient<$Result.GetResult<Prisma.$postsPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Posts that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {postsFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Posts\n     * const posts = await prisma.posts.findMany()\n     * \n     * // Get first 10 Posts\n     * const posts = await prisma.posts.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const postsWithIdOnly = await prisma.posts.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends postsFindManyArgs>(args?: SelectSubset<T, postsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$postsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Posts.\n     * @param {postsCreateArgs} args - Arguments to create a Posts.\n     * @example\n     * // Create one Posts\n     * const Posts = await prisma.posts.create({\n     *   data: {\n     *     // ... data to create a Posts\n     *   }\n     * })\n     * \n     */\n    create<T extends postsCreateArgs>(args: SelectSubset<T, postsCreateArgs<ExtArgs>>): Prisma__postsClient<$Result.GetResult<Prisma.$postsPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Posts.\n     * @param {postsCreateManyArgs} args - Arguments to create many Posts.\n     * @example\n     * // Create many Posts\n     * const posts = await prisma.posts.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends postsCreateManyArgs>(args?: SelectSubset<T, postsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Posts and returns the data saved in the database.\n     * @param {postsCreateManyAndReturnArgs} args - Arguments to create many Posts.\n     * @example\n     * // Create many Posts\n     * const posts = await prisma.posts.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Posts and only return the `id`\n     * const postsWithIdOnly = await prisma.posts.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends postsCreateManyAndReturnArgs>(args?: SelectSubset<T, postsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$postsPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Posts.\n     * @param {postsDeleteArgs} args - Arguments to delete one Posts.\n     * @example\n     * // Delete one Posts\n     * const Posts = await prisma.posts.delete({\n     *   where: {\n     *     // ... filter to delete one Posts\n     *   }\n     * })\n     * \n     */\n    delete<T extends postsDeleteArgs>(args: SelectSubset<T, postsDeleteArgs<ExtArgs>>): Prisma__postsClient<$Result.GetResult<Prisma.$postsPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Posts.\n     * @param {postsUpdateArgs} args - Arguments to update one Posts.\n     * @example\n     * // Update one Posts\n     * const posts = await prisma.posts.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends postsUpdateArgs>(args: SelectSubset<T, postsUpdateArgs<ExtArgs>>): Prisma__postsClient<$Result.GetResult<Prisma.$postsPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Posts.\n     * @param {postsDeleteManyArgs} args - Arguments to filter Posts to delete.\n     * @example\n     * // Delete a few Posts\n     * const { count } = await prisma.posts.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends postsDeleteManyArgs>(args?: SelectSubset<T, postsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Posts.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {postsUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Posts\n     * const posts = await prisma.posts.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends postsUpdateManyArgs>(args: SelectSubset<T, postsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Posts and returns the data updated in the database.\n     * @param {postsUpdateManyAndReturnArgs} args - Arguments to update many Posts.\n     * @example\n     * // Update many Posts\n     * const posts = await prisma.posts.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Posts and only return the `id`\n     * const postsWithIdOnly = await prisma.posts.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends postsUpdateManyAndReturnArgs>(args: SelectSubset<T, postsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$postsPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Posts.\n     * @param {postsUpsertArgs} args - Arguments to update or create a Posts.\n     * @example\n     * // Update or create a Posts\n     * const posts = await prisma.posts.upsert({\n     *   create: {\n     *     // ... data to create a Posts\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Posts we want to update\n     *   }\n     * })\n     */\n    upsert<T extends postsUpsertArgs>(args: SelectSubset<T, postsUpsertArgs<ExtArgs>>): Prisma__postsClient<$Result.GetResult<Prisma.$postsPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Posts.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {postsCountArgs} args - Arguments to filter Posts to count.\n     * @example\n     * // Count the number of Posts\n     * const count = await prisma.posts.count({\n     *   where: {\n     *     // ... the filter for the Posts we want to count\n     *   }\n     * })\n    **/\n    count<T extends postsCountArgs>(\n      args?: Subset<T, postsCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], PostsCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Posts.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {PostsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends PostsAggregateArgs>(args: Subset<T, PostsAggregateArgs>): Prisma.PrismaPromise<GetPostsAggregateType<T>>\n\n    /**\n     * Group by Posts.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {postsGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends postsGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: postsGroupByArgs['orderBy'] }\n        : { orderBy?: postsGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, postsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the posts model\n   */\n  readonly fields: postsFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for posts.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__postsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    author<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    category<T extends categoriesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, categoriesDefaultArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    comments<T extends posts$commentsArgs<ExtArgs> = {}>(args?: Subset<T, posts$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    votes<T extends posts$votesArgs<ExtArgs> = {}>(args?: Subset<T, posts$votesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$votesPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the posts model\n   */\n  interface postsFieldRefs {\n    readonly id: FieldRef<\"posts\", 'String'>\n    readonly user_id: FieldRef<\"posts\", 'String'>\n    readonly category_id: FieldRef<\"posts\", 'String'>\n    readonly title: FieldRef<\"posts\", 'String'>\n    readonly content: FieldRef<\"posts\", 'String'>\n    readonly created_at: FieldRef<\"posts\", 'DateTime'>\n    readonly updated_at: FieldRef<\"posts\", 'DateTime'>\n    readonly deleted_at: FieldRef<\"posts\", 'DateTime'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * posts findUnique\n   */\n  export type postsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the posts\n     */\n    select?: postsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the posts\n     */\n    omit?: postsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: postsInclude<ExtArgs> | null\n    /**\n     * Filter, which posts to fetch.\n     */\n    where: postsWhereUniqueInput\n  }\n\n  /**\n   * posts findUniqueOrThrow\n   */\n  export type postsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the posts\n     */\n    select?: postsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the posts\n     */\n    omit?: postsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: postsInclude<ExtArgs> | null\n    /**\n     * Filter, which posts to fetch.\n     */\n    where: postsWhereUniqueInput\n  }\n\n  /**\n   * posts findFirst\n   */\n  export type postsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the posts\n     */\n    select?: postsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the posts\n     */\n    omit?: postsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: postsInclude<ExtArgs> | null\n    /**\n     * Filter, which posts to fetch.\n     */\n    where?: postsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of posts to fetch.\n     */\n    orderBy?: postsOrderByWithRelationInput | postsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for posts.\n     */\n    cursor?: postsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` posts from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` posts.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of posts.\n     */\n    distinct?: PostsScalarFieldEnum | PostsScalarFieldEnum[]\n  }\n\n  /**\n   * posts findFirstOrThrow\n   */\n  export type postsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the posts\n     */\n    select?: postsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the posts\n     */\n    omit?: postsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: postsInclude<ExtArgs> | null\n    /**\n     * Filter, which posts to fetch.\n     */\n    where?: postsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of posts to fetch.\n     */\n    orderBy?: postsOrderByWithRelationInput | postsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for posts.\n     */\n    cursor?: postsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` posts from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` posts.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of posts.\n     */\n    distinct?: PostsScalarFieldEnum | PostsScalarFieldEnum[]\n  }\n\n  /**\n   * posts findMany\n   */\n  export type postsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the posts\n     */\n    select?: postsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the posts\n     */\n    omit?: postsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: postsInclude<ExtArgs> | null\n    /**\n     * Filter, which posts to fetch.\n     */\n    where?: postsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of posts to fetch.\n     */\n    orderBy?: postsOrderByWithRelationInput | postsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing posts.\n     */\n    cursor?: postsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` posts from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` posts.\n     */\n    skip?: number\n    distinct?: PostsScalarFieldEnum | PostsScalarFieldEnum[]\n  }\n\n  /**\n   * posts create\n   */\n  export type postsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the posts\n     */\n    select?: postsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the posts\n     */\n    omit?: postsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: postsInclude<ExtArgs> | null\n    /**\n     * The data needed to create a posts.\n     */\n    data: XOR<postsCreateInput, postsUncheckedCreateInput>\n  }\n\n  /**\n   * posts createMany\n   */\n  export type postsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many posts.\n     */\n    data: postsCreateManyInput | postsCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * posts createManyAndReturn\n   */\n  export type postsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the posts\n     */\n    select?: postsSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the posts\n     */\n    omit?: postsOmit<ExtArgs> | null\n    /**\n     * The data used to create many posts.\n     */\n    data: postsCreateManyInput | postsCreateManyInput[]\n    skipDuplicates?: boolean\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: postsIncludeCreateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * posts update\n   */\n  export type postsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the posts\n     */\n    select?: postsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the posts\n     */\n    omit?: postsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: postsInclude<ExtArgs> | null\n    /**\n     * The data needed to update a posts.\n     */\n    data: XOR<postsUpdateInput, postsUncheckedUpdateInput>\n    /**\n     * Choose, which posts to update.\n     */\n    where: postsWhereUniqueInput\n  }\n\n  /**\n   * posts updateMany\n   */\n  export type postsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update posts.\n     */\n    data: XOR<postsUpdateManyMutationInput, postsUncheckedUpdateManyInput>\n    /**\n     * Filter which posts to update\n     */\n    where?: postsWhereInput\n    /**\n     * Limit how many posts to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * posts updateManyAndReturn\n   */\n  export type postsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the posts\n     */\n    select?: postsSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the posts\n     */\n    omit?: postsOmit<ExtArgs> | null\n    /**\n     * The data used to update posts.\n     */\n    data: XOR<postsUpdateManyMutationInput, postsUncheckedUpdateManyInput>\n    /**\n     * Filter which posts to update\n     */\n    where?: postsWhereInput\n    /**\n     * Limit how many posts to update.\n     */\n    limit?: number\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: postsIncludeUpdateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * posts upsert\n   */\n  export type postsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the posts\n     */\n    select?: postsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the posts\n     */\n    omit?: postsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: postsInclude<ExtArgs> | null\n    /**\n     * The filter to search for the posts to update in case it exists.\n     */\n    where: postsWhereUniqueInput\n    /**\n     * In case the posts found by the `where` argument doesn't exist, create a new posts with this data.\n     */\n    create: XOR<postsCreateInput, postsUncheckedCreateInput>\n    /**\n     * In case the posts was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<postsUpdateInput, postsUncheckedUpdateInput>\n  }\n\n  /**\n   * posts delete\n   */\n  export type postsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the posts\n     */\n    select?: postsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the posts\n     */\n    omit?: postsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: postsInclude<ExtArgs> | null\n    /**\n     * Filter which posts to delete.\n     */\n    where: postsWhereUniqueInput\n  }\n\n  /**\n   * posts deleteMany\n   */\n  export type postsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which posts to delete\n     */\n    where?: postsWhereInput\n    /**\n     * Limit how many posts to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * posts.comments\n   */\n  export type posts$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the comments\n     */\n    select?: commentsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the comments\n     */\n    omit?: commentsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: commentsInclude<ExtArgs> | null\n    where?: commentsWhereInput\n    orderBy?: commentsOrderByWithRelationInput | commentsOrderByWithRelationInput[]\n    cursor?: commentsWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: CommentsScalarFieldEnum | CommentsScalarFieldEnum[]\n  }\n\n  /**\n   * posts.votes\n   */\n  export type posts$votesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the votes\n     */\n    select?: votesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the votes\n     */\n    omit?: votesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: votesInclude<ExtArgs> | null\n    where?: votesWhereInput\n    orderBy?: votesOrderByWithRelationInput | votesOrderByWithRelationInput[]\n    cursor?: votesWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: VotesScalarFieldEnum | VotesScalarFieldEnum[]\n  }\n\n  /**\n   * posts without action\n   */\n  export type postsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the posts\n     */\n    select?: postsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the posts\n     */\n    omit?: postsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: postsInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Model comments\n   */\n\n  export type AggregateComments = {\n    _count: CommentsCountAggregateOutputType | null\n    _min: CommentsMinAggregateOutputType | null\n    _max: CommentsMaxAggregateOutputType | null\n  }\n\n  export type CommentsMinAggregateOutputType = {\n    id: string | null\n    user_id: string | null\n    post_id: string | null\n    parent_id: string | null\n    content: string | null\n    created_at: Date | null\n    updated_at: Date | null\n    deleted_at: Date | null\n  }\n\n  export type CommentsMaxAggregateOutputType = {\n    id: string | null\n    user_id: string | null\n    post_id: string | null\n    parent_id: string | null\n    content: string | null\n    created_at: Date | null\n    updated_at: Date | null\n    deleted_at: Date | null\n  }\n\n  export type CommentsCountAggregateOutputType = {\n    id: number\n    user_id: number\n    post_id: number\n    parent_id: number\n    content: number\n    created_at: number\n    updated_at: number\n    deleted_at: number\n    _all: number\n  }\n\n\n  export type CommentsMinAggregateInputType = {\n    id?: true\n    user_id?: true\n    post_id?: true\n    parent_id?: true\n    content?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n  }\n\n  export type CommentsMaxAggregateInputType = {\n    id?: true\n    user_id?: true\n    post_id?: true\n    parent_id?: true\n    content?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n  }\n\n  export type CommentsCountAggregateInputType = {\n    id?: true\n    user_id?: true\n    post_id?: true\n    parent_id?: true\n    content?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n    _all?: true\n  }\n\n  export type CommentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which comments to aggregate.\n     */\n    where?: commentsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of comments to fetch.\n     */\n    orderBy?: commentsOrderByWithRelationInput | commentsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: commentsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` comments from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` comments.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned comments\n    **/\n    _count?: true | CommentsCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: CommentsMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: CommentsMaxAggregateInputType\n  }\n\n  export type GetCommentsAggregateType<T extends CommentsAggregateArgs> = {\n        [P in keyof T & keyof AggregateComments]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateComments[P]>\n      : GetScalarType<T[P], AggregateComments[P]>\n  }\n\n\n\n\n  export type commentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: commentsWhereInput\n    orderBy?: commentsOrderByWithAggregationInput | commentsOrderByWithAggregationInput[]\n    by: CommentsScalarFieldEnum[] | CommentsScalarFieldEnum\n    having?: commentsScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: CommentsCountAggregateInputType | true\n    _min?: CommentsMinAggregateInputType\n    _max?: CommentsMaxAggregateInputType\n  }\n\n  export type CommentsGroupByOutputType = {\n    id: string\n    user_id: string\n    post_id: string\n    parent_id: string | null\n    content: string\n    created_at: Date\n    updated_at: Date\n    deleted_at: Date | null\n    _count: CommentsCountAggregateOutputType | null\n    _min: CommentsMinAggregateOutputType | null\n    _max: CommentsMaxAggregateOutputType | null\n  }\n\n  type GetCommentsGroupByPayload<T extends commentsGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<CommentsGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof CommentsGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], CommentsGroupByOutputType[P]>\n            : GetScalarType<T[P], CommentsGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type commentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    user_id?: boolean\n    post_id?: boolean\n    parent_id?: boolean\n    content?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    author?: boolean | usersDefaultArgs<ExtArgs>\n    post?: boolean | postsDefaultArgs<ExtArgs>\n    parent?: boolean | comments$parentArgs<ExtArgs>\n    recursive?: boolean | comments$recursiveArgs<ExtArgs>\n    votes?: boolean | comments$votesArgs<ExtArgs>\n    _count?: boolean | CommentsCountOutputTypeDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"comments\"]>\n\n  export type commentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    user_id?: boolean\n    post_id?: boolean\n    parent_id?: boolean\n    content?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    author?: boolean | usersDefaultArgs<ExtArgs>\n    post?: boolean | postsDefaultArgs<ExtArgs>\n    parent?: boolean | comments$parentArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"comments\"]>\n\n  export type commentsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    user_id?: boolean\n    post_id?: boolean\n    parent_id?: boolean\n    content?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    author?: boolean | usersDefaultArgs<ExtArgs>\n    post?: boolean | postsDefaultArgs<ExtArgs>\n    parent?: boolean | comments$parentArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"comments\"]>\n\n  export type commentsSelectScalar = {\n    id?: boolean\n    user_id?: boolean\n    post_id?: boolean\n    parent_id?: boolean\n    content?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n  }\n\n  export type commentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"user_id\" | \"post_id\" | \"parent_id\" | \"content\" | \"created_at\" | \"updated_at\" | \"deleted_at\", ExtArgs[\"result\"][\"comments\"]>\n  export type commentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    author?: boolean | usersDefaultArgs<ExtArgs>\n    post?: boolean | postsDefaultArgs<ExtArgs>\n    parent?: boolean | comments$parentArgs<ExtArgs>\n    recursive?: boolean | comments$recursiveArgs<ExtArgs>\n    votes?: boolean | comments$votesArgs<ExtArgs>\n    _count?: boolean | CommentsCountOutputTypeDefaultArgs<ExtArgs>\n  }\n  export type commentsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    author?: boolean | usersDefaultArgs<ExtArgs>\n    post?: boolean | postsDefaultArgs<ExtArgs>\n    parent?: boolean | comments$parentArgs<ExtArgs>\n  }\n  export type commentsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    author?: boolean | usersDefaultArgs<ExtArgs>\n    post?: boolean | postsDefaultArgs<ExtArgs>\n    parent?: boolean | comments$parentArgs<ExtArgs>\n  }\n\n  export type $commentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"comments\"\n    objects: {\n      author: Prisma.$usersPayload<ExtArgs>\n      post: Prisma.$postsPayload<ExtArgs>\n      parent: Prisma.$commentsPayload<ExtArgs> | null\n      recursive: Prisma.$commentsPayload<ExtArgs>[]\n      votes: Prisma.$votesPayload<ExtArgs>[]\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key. Unique identifier for each comment.\n       */\n      id: string\n      /**\n       * Author's {@link users.id} - Indicates the owner/author of the comment. Enforces accountability, links to profile and reputation system. Required for audit and moderation.\n       */\n      user_id: string\n      /**\n       * Parent post's {@link posts.id} - The post that this comment is in response to. Implements the association between comments and discussions. Required unless it's a reply to another comment only.\n       */\n      post_id: string\n      /**\n       * Parent comment's {@link comments.id} - Implements threaded/nested replies, allowing for comment hierarchies. Enables conversations to branch. Nullable for top-level comments (direct responses to posts).\n       */\n      parent_id: string | null\n      /**\n       * Comment body - Implements the rule that each comment consists of user-written text/content. Used for replies, opinions, and ongoing discussion. For example, 'I agree and here’s why...'.\n       */\n      content: string\n      /**\n       * Creation timestamp - Implements audit/history requirement for comment posting, tracking the date and time for moderation and display ordering. For example, enables 'most recent first' sorting.\n       */\n      created_at: Date\n      /**\n       * Last edited timestamp - Implements edit history tracking for evidence and transparency. If a user updates their comment, this records when.\n       */\n      updated_at: Date\n      /**\n       * Soft deletion timestamp - Implements moderation controls by marking comments removed (not hard deleted) for evidence/history. Used if comment violates rules, is self-removed, or by moderator action.\n       */\n      deleted_at: Date | null\n    }, ExtArgs[\"result\"][\"comments\"]>\n    composites: {}\n  }\n\n  type commentsGetPayload<S extends boolean | null | undefined | commentsDefaultArgs> = $Result.GetResult<Prisma.$commentsPayload, S>\n\n  type commentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<commentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: CommentsCountAggregateInputType | true\n    }\n\n  export interface commentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['comments'], meta: { name: 'comments' } }\n    /**\n     * Find zero or one Comments that matches the filter.\n     * @param {commentsFindUniqueArgs} args - Arguments to find a Comments\n     * @example\n     * // Get one Comments\n     * const comments = await prisma.comments.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends commentsFindUniqueArgs>(args: SelectSubset<T, commentsFindUniqueArgs<ExtArgs>>): Prisma__commentsClient<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Comments that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {commentsFindUniqueOrThrowArgs} args - Arguments to find a Comments\n     * @example\n     * // Get one Comments\n     * const comments = await prisma.comments.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends commentsFindUniqueOrThrowArgs>(args: SelectSubset<T, commentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__commentsClient<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Comments that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {commentsFindFirstArgs} args - Arguments to find a Comments\n     * @example\n     * // Get one Comments\n     * const comments = await prisma.comments.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends commentsFindFirstArgs>(args?: SelectSubset<T, commentsFindFirstArgs<ExtArgs>>): Prisma__commentsClient<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Comments that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {commentsFindFirstOrThrowArgs} args - Arguments to find a Comments\n     * @example\n     * // Get one Comments\n     * const comments = await prisma.comments.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends commentsFindFirstOrThrowArgs>(args?: SelectSubset<T, commentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__commentsClient<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Comments that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {commentsFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Comments\n     * const comments = await prisma.comments.findMany()\n     * \n     * // Get first 10 Comments\n     * const comments = await prisma.comments.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const commentsWithIdOnly = await prisma.comments.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends commentsFindManyArgs>(args?: SelectSubset<T, commentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Comments.\n     * @param {commentsCreateArgs} args - Arguments to create a Comments.\n     * @example\n     * // Create one Comments\n     * const Comments = await prisma.comments.create({\n     *   data: {\n     *     // ... data to create a Comments\n     *   }\n     * })\n     * \n     */\n    create<T extends commentsCreateArgs>(args: SelectSubset<T, commentsCreateArgs<ExtArgs>>): Prisma__commentsClient<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Comments.\n     * @param {commentsCreateManyArgs} args - Arguments to create many Comments.\n     * @example\n     * // Create many Comments\n     * const comments = await prisma.comments.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends commentsCreateManyArgs>(args?: SelectSubset<T, commentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Comments and returns the data saved in the database.\n     * @param {commentsCreateManyAndReturnArgs} args - Arguments to create many Comments.\n     * @example\n     * // Create many Comments\n     * const comments = await prisma.comments.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Comments and only return the `id`\n     * const commentsWithIdOnly = await prisma.comments.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends commentsCreateManyAndReturnArgs>(args?: SelectSubset<T, commentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Comments.\n     * @param {commentsDeleteArgs} args - Arguments to delete one Comments.\n     * @example\n     * // Delete one Comments\n     * const Comments = await prisma.comments.delete({\n     *   where: {\n     *     // ... filter to delete one Comments\n     *   }\n     * })\n     * \n     */\n    delete<T extends commentsDeleteArgs>(args: SelectSubset<T, commentsDeleteArgs<ExtArgs>>): Prisma__commentsClient<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Comments.\n     * @param {commentsUpdateArgs} args - Arguments to update one Comments.\n     * @example\n     * // Update one Comments\n     * const comments = await prisma.comments.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends commentsUpdateArgs>(args: SelectSubset<T, commentsUpdateArgs<ExtArgs>>): Prisma__commentsClient<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Comments.\n     * @param {commentsDeleteManyArgs} args - Arguments to filter Comments to delete.\n     * @example\n     * // Delete a few Comments\n     * const { count } = await prisma.comments.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends commentsDeleteManyArgs>(args?: SelectSubset<T, commentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Comments.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {commentsUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Comments\n     * const comments = await prisma.comments.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends commentsUpdateManyArgs>(args: SelectSubset<T, commentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Comments and returns the data updated in the database.\n     * @param {commentsUpdateManyAndReturnArgs} args - Arguments to update many Comments.\n     * @example\n     * // Update many Comments\n     * const comments = await prisma.comments.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Comments and only return the `id`\n     * const commentsWithIdOnly = await prisma.comments.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends commentsUpdateManyAndReturnArgs>(args: SelectSubset<T, commentsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Comments.\n     * @param {commentsUpsertArgs} args - Arguments to update or create a Comments.\n     * @example\n     * // Update or create a Comments\n     * const comments = await prisma.comments.upsert({\n     *   create: {\n     *     // ... data to create a Comments\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Comments we want to update\n     *   }\n     * })\n     */\n    upsert<T extends commentsUpsertArgs>(args: SelectSubset<T, commentsUpsertArgs<ExtArgs>>): Prisma__commentsClient<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Comments.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {commentsCountArgs} args - Arguments to filter Comments to count.\n     * @example\n     * // Count the number of Comments\n     * const count = await prisma.comments.count({\n     *   where: {\n     *     // ... the filter for the Comments we want to count\n     *   }\n     * })\n    **/\n    count<T extends commentsCountArgs>(\n      args?: Subset<T, commentsCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], CommentsCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Comments.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {CommentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends CommentsAggregateArgs>(args: Subset<T, CommentsAggregateArgs>): Prisma.PrismaPromise<GetCommentsAggregateType<T>>\n\n    /**\n     * Group by Comments.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {commentsGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends commentsGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: commentsGroupByArgs['orderBy'] }\n        : { orderBy?: commentsGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, commentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the comments model\n   */\n  readonly fields: commentsFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for comments.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__commentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    author<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    post<T extends postsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, postsDefaultArgs<ExtArgs>>): Prisma__postsClient<$Result.GetResult<Prisma.$postsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    parent<T extends comments$parentArgs<ExtArgs> = {}>(args?: Subset<T, comments$parentArgs<ExtArgs>>): Prisma__commentsClient<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n    recursive<T extends comments$recursiveArgs<ExtArgs> = {}>(args?: Subset<T, comments$recursiveArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    votes<T extends comments$votesArgs<ExtArgs> = {}>(args?: Subset<T, comments$votesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$votesPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the comments model\n   */\n  interface commentsFieldRefs {\n    readonly id: FieldRef<\"comments\", 'String'>\n    readonly user_id: FieldRef<\"comments\", 'String'>\n    readonly post_id: FieldRef<\"comments\", 'String'>\n    readonly parent_id: FieldRef<\"comments\", 'String'>\n    readonly content: FieldRef<\"comments\", 'String'>\n    readonly created_at: FieldRef<\"comments\", 'DateTime'>\n    readonly updated_at: FieldRef<\"comments\", 'DateTime'>\n    readonly deleted_at: FieldRef<\"comments\", 'DateTime'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * comments findUnique\n   */\n  export type commentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the comments\n     */\n    select?: commentsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the comments\n     */\n    omit?: commentsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: commentsInclude<ExtArgs> | null\n    /**\n     * Filter, which comments to fetch.\n     */\n    where: commentsWhereUniqueInput\n  }\n\n  /**\n   * comments findUniqueOrThrow\n   */\n  export type commentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the comments\n     */\n    select?: commentsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the comments\n     */\n    omit?: commentsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: commentsInclude<ExtArgs> | null\n    /**\n     * Filter, which comments to fetch.\n     */\n    where: commentsWhereUniqueInput\n  }\n\n  /**\n   * comments findFirst\n   */\n  export type commentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the comments\n     */\n    select?: commentsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the comments\n     */\n    omit?: commentsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: commentsInclude<ExtArgs> | null\n    /**\n     * Filter, which comments to fetch.\n     */\n    where?: commentsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of comments to fetch.\n     */\n    orderBy?: commentsOrderByWithRelationInput | commentsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for comments.\n     */\n    cursor?: commentsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` comments from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` comments.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of comments.\n     */\n    distinct?: CommentsScalarFieldEnum | CommentsScalarFieldEnum[]\n  }\n\n  /**\n   * comments findFirstOrThrow\n   */\n  export type commentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the comments\n     */\n    select?: commentsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the comments\n     */\n    omit?: commentsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: commentsInclude<ExtArgs> | null\n    /**\n     * Filter, which comments to fetch.\n     */\n    where?: commentsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of comments to fetch.\n     */\n    orderBy?: commentsOrderByWithRelationInput | commentsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for comments.\n     */\n    cursor?: commentsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` comments from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` comments.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of comments.\n     */\n    distinct?: CommentsScalarFieldEnum | CommentsScalarFieldEnum[]\n  }\n\n  /**\n   * comments findMany\n   */\n  export type commentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the comments\n     */\n    select?: commentsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the comments\n     */\n    omit?: commentsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: commentsInclude<ExtArgs> | null\n    /**\n     * Filter, which comments to fetch.\n     */\n    where?: commentsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of comments to fetch.\n     */\n    orderBy?: commentsOrderByWithRelationInput | commentsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing comments.\n     */\n    cursor?: commentsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` comments from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` comments.\n     */\n    skip?: number\n    distinct?: CommentsScalarFieldEnum | CommentsScalarFieldEnum[]\n  }\n\n  /**\n   * comments create\n   */\n  export type commentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the comments\n     */\n    select?: commentsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the comments\n     */\n    omit?: commentsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: commentsInclude<ExtArgs> | null\n    /**\n     * The data needed to create a comments.\n     */\n    data: XOR<commentsCreateInput, commentsUncheckedCreateInput>\n  }\n\n  /**\n   * comments createMany\n   */\n  export type commentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many comments.\n     */\n    data: commentsCreateManyInput | commentsCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * comments createManyAndReturn\n   */\n  export type commentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the comments\n     */\n    select?: commentsSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the comments\n     */\n    omit?: commentsOmit<ExtArgs> | null\n    /**\n     * The data used to create many comments.\n     */\n    data: commentsCreateManyInput | commentsCreateManyInput[]\n    skipDuplicates?: boolean\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: commentsIncludeCreateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * comments update\n   */\n  export type commentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the comments\n     */\n    select?: commentsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the comments\n     */\n    omit?: commentsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: commentsInclude<ExtArgs> | null\n    /**\n     * The data needed to update a comments.\n     */\n    data: XOR<commentsUpdateInput, commentsUncheckedUpdateInput>\n    /**\n     * Choose, which comments to update.\n     */\n    where: commentsWhereUniqueInput\n  }\n\n  /**\n   * comments updateMany\n   */\n  export type commentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update comments.\n     */\n    data: XOR<commentsUpdateManyMutationInput, commentsUncheckedUpdateManyInput>\n    /**\n     * Filter which comments to update\n     */\n    where?: commentsWhereInput\n    /**\n     * Limit how many comments to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * comments updateManyAndReturn\n   */\n  export type commentsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the comments\n     */\n    select?: commentsSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the comments\n     */\n    omit?: commentsOmit<ExtArgs> | null\n    /**\n     * The data used to update comments.\n     */\n    data: XOR<commentsUpdateManyMutationInput, commentsUncheckedUpdateManyInput>\n    /**\n     * Filter which comments to update\n     */\n    where?: commentsWhereInput\n    /**\n     * Limit how many comments to update.\n     */\n    limit?: number\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: commentsIncludeUpdateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * comments upsert\n   */\n  export type commentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the comments\n     */\n    select?: commentsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the comments\n     */\n    omit?: commentsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: commentsInclude<ExtArgs> | null\n    /**\n     * The filter to search for the comments to update in case it exists.\n     */\n    where: commentsWhereUniqueInput\n    /**\n     * In case the comments found by the `where` argument doesn't exist, create a new comments with this data.\n     */\n    create: XOR<commentsCreateInput, commentsUncheckedCreateInput>\n    /**\n     * In case the comments was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<commentsUpdateInput, commentsUncheckedUpdateInput>\n  }\n\n  /**\n   * comments delete\n   */\n  export type commentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the comments\n     */\n    select?: commentsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the comments\n     */\n    omit?: commentsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: commentsInclude<ExtArgs> | null\n    /**\n     * Filter which comments to delete.\n     */\n    where: commentsWhereUniqueInput\n  }\n\n  /**\n   * comments deleteMany\n   */\n  export type commentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which comments to delete\n     */\n    where?: commentsWhereInput\n    /**\n     * Limit how many comments to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * comments.parent\n   */\n  export type comments$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the comments\n     */\n    select?: commentsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the comments\n     */\n    omit?: commentsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: commentsInclude<ExtArgs> | null\n    where?: commentsWhereInput\n  }\n\n  /**\n   * comments.recursive\n   */\n  export type comments$recursiveArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the comments\n     */\n    select?: commentsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the comments\n     */\n    omit?: commentsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: commentsInclude<ExtArgs> | null\n    where?: commentsWhereInput\n    orderBy?: commentsOrderByWithRelationInput | commentsOrderByWithRelationInput[]\n    cursor?: commentsWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: CommentsScalarFieldEnum | CommentsScalarFieldEnum[]\n  }\n\n  /**\n   * comments.votes\n   */\n  export type comments$votesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the votes\n     */\n    select?: votesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the votes\n     */\n    omit?: votesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: votesInclude<ExtArgs> | null\n    where?: votesWhereInput\n    orderBy?: votesOrderByWithRelationInput | votesOrderByWithRelationInput[]\n    cursor?: votesWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: VotesScalarFieldEnum | VotesScalarFieldEnum[]\n  }\n\n  /**\n   * comments without action\n   */\n  export type commentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the comments\n     */\n    select?: commentsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the comments\n     */\n    omit?: commentsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: commentsInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Model votes\n   */\n\n  export type AggregateVotes = {\n    _count: VotesCountAggregateOutputType | null\n    _avg: VotesAvgAggregateOutputType | null\n    _sum: VotesSumAggregateOutputType | null\n    _min: VotesMinAggregateOutputType | null\n    _max: VotesMaxAggregateOutputType | null\n  }\n\n  export type VotesAvgAggregateOutputType = {\n    value: number | null\n  }\n\n  export type VotesSumAggregateOutputType = {\n    value: number | null\n  }\n\n  export type VotesMinAggregateOutputType = {\n    id: string | null\n    user_id: string | null\n    post_id: string | null\n    comment_id: string | null\n    value: number | null\n    created_at: Date | null\n  }\n\n  export type VotesMaxAggregateOutputType = {\n    id: string | null\n    user_id: string | null\n    post_id: string | null\n    comment_id: string | null\n    value: number | null\n    created_at: Date | null\n  }\n\n  export type VotesCountAggregateOutputType = {\n    id: number\n    user_id: number\n    post_id: number\n    comment_id: number\n    value: number\n    created_at: number\n    _all: number\n  }\n\n\n  export type VotesAvgAggregateInputType = {\n    value?: true\n  }\n\n  export type VotesSumAggregateInputType = {\n    value?: true\n  }\n\n  export type VotesMinAggregateInputType = {\n    id?: true\n    user_id?: true\n    post_id?: true\n    comment_id?: true\n    value?: true\n    created_at?: true\n  }\n\n  export type VotesMaxAggregateInputType = {\n    id?: true\n    user_id?: true\n    post_id?: true\n    comment_id?: true\n    value?: true\n    created_at?: true\n  }\n\n  export type VotesCountAggregateInputType = {\n    id?: true\n    user_id?: true\n    post_id?: true\n    comment_id?: true\n    value?: true\n    created_at?: true\n    _all?: true\n  }\n\n  export type VotesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which votes to aggregate.\n     */\n    where?: votesWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of votes to fetch.\n     */\n    orderBy?: votesOrderByWithRelationInput | votesOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: votesWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` votes from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` votes.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned votes\n    **/\n    _count?: true | VotesCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to average\n    **/\n    _avg?: VotesAvgAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to sum\n    **/\n    _sum?: VotesSumAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: VotesMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: VotesMaxAggregateInputType\n  }\n\n  export type GetVotesAggregateType<T extends VotesAggregateArgs> = {\n        [P in keyof T & keyof AggregateVotes]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateVotes[P]>\n      : GetScalarType<T[P], AggregateVotes[P]>\n  }\n\n\n\n\n  export type votesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: votesWhereInput\n    orderBy?: votesOrderByWithAggregationInput | votesOrderByWithAggregationInput[]\n    by: VotesScalarFieldEnum[] | VotesScalarFieldEnum\n    having?: votesScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: VotesCountAggregateInputType | true\n    _avg?: VotesAvgAggregateInputType\n    _sum?: VotesSumAggregateInputType\n    _min?: VotesMinAggregateInputType\n    _max?: VotesMaxAggregateInputType\n  }\n\n  export type VotesGroupByOutputType = {\n    id: string\n    user_id: string\n    post_id: string | null\n    comment_id: string | null\n    value: number\n    created_at: Date\n    _count: VotesCountAggregateOutputType | null\n    _avg: VotesAvgAggregateOutputType | null\n    _sum: VotesSumAggregateOutputType | null\n    _min: VotesMinAggregateOutputType | null\n    _max: VotesMaxAggregateOutputType | null\n  }\n\n  type GetVotesGroupByPayload<T extends votesGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<VotesGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof VotesGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], VotesGroupByOutputType[P]>\n            : GetScalarType<T[P], VotesGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type votesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    user_id?: boolean\n    post_id?: boolean\n    comment_id?: boolean\n    value?: boolean\n    created_at?: boolean\n    user?: boolean | usersDefaultArgs<ExtArgs>\n    post?: boolean | votes$postArgs<ExtArgs>\n    comment?: boolean | votes$commentArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"votes\"]>\n\n  export type votesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    user_id?: boolean\n    post_id?: boolean\n    comment_id?: boolean\n    value?: boolean\n    created_at?: boolean\n    user?: boolean | usersDefaultArgs<ExtArgs>\n    post?: boolean | votes$postArgs<ExtArgs>\n    comment?: boolean | votes$commentArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"votes\"]>\n\n  export type votesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    user_id?: boolean\n    post_id?: boolean\n    comment_id?: boolean\n    value?: boolean\n    created_at?: boolean\n    user?: boolean | usersDefaultArgs<ExtArgs>\n    post?: boolean | votes$postArgs<ExtArgs>\n    comment?: boolean | votes$commentArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"votes\"]>\n\n  export type votesSelectScalar = {\n    id?: boolean\n    user_id?: boolean\n    post_id?: boolean\n    comment_id?: boolean\n    value?: boolean\n    created_at?: boolean\n  }\n\n  export type votesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"user_id\" | \"post_id\" | \"comment_id\" | \"value\" | \"created_at\", ExtArgs[\"result\"][\"votes\"]>\n  export type votesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    user?: boolean | usersDefaultArgs<ExtArgs>\n    post?: boolean | votes$postArgs<ExtArgs>\n    comment?: boolean | votes$commentArgs<ExtArgs>\n  }\n  export type votesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    user?: boolean | usersDefaultArgs<ExtArgs>\n    post?: boolean | votes$postArgs<ExtArgs>\n    comment?: boolean | votes$commentArgs<ExtArgs>\n  }\n  export type votesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    user?: boolean | usersDefaultArgs<ExtArgs>\n    post?: boolean | votes$postArgs<ExtArgs>\n    comment?: boolean | votes$commentArgs<ExtArgs>\n  }\n\n  export type $votesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"votes\"\n    objects: {\n      user: Prisma.$usersPayload<ExtArgs>\n      post: Prisma.$postsPayload<ExtArgs> | null\n      comment: Prisma.$commentsPayload<ExtArgs> | null\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key. Unique identifier for each vote record.\n       */\n      id: string\n      /**\n       * Voter's user reference - Links each vote to the user who cast it. Implements the requirement that only registered users can vote. Business meaning: Tracks voting history and enforces unique voting constraints. Example: User 'U' upvotes a comment, linking the vote to 'U's user_id.\n       */\n      user_id: string\n      /**\n       * Target post's reference - References the post being voted on, if the vote relates to a post (and not a comment). Implements mutual exclusivity rule and enables vote tallies for posts. Example: Voting on a thread increases the tally on the referenced post. Constraint: Only one of post_id or comment_id is non-null per row.\n       */\n      post_id: string | null\n      /**\n       * Target comment's reference - References the comment being voted on, if applicable. Implements mutual exclusivity rule as with posts. Example: Voting on a reply records the vote linked to this comment. Only one of post_id or comment_id is set per vote record.\n       */\n      comment_id: string | null\n      /**\n       * Vote value - Implements the upvote/downvote requirement. Stores +1 for upvote, -1 for downvote. Business meaning: This value is aggregated to produce content rankings. Example: A +1 value indicates an upvote from a user.\n       */\n      value: number\n      /**\n       * Vote timestamp - Implements auditing requirements for vote tracking. Stores the date and time the vote was made. Used for analytics and to enforce time-based voting limits, if ever required by policy.\n       */\n      created_at: Date\n    }, ExtArgs[\"result\"][\"votes\"]>\n    composites: {}\n  }\n\n  type votesGetPayload<S extends boolean | null | undefined | votesDefaultArgs> = $Result.GetResult<Prisma.$votesPayload, S>\n\n  type votesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<votesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: VotesCountAggregateInputType | true\n    }\n\n  export interface votesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['votes'], meta: { name: 'votes' } }\n    /**\n     * Find zero or one Votes that matches the filter.\n     * @param {votesFindUniqueArgs} args - Arguments to find a Votes\n     * @example\n     * // Get one Votes\n     * const votes = await prisma.votes.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends votesFindUniqueArgs>(args: SelectSubset<T, votesFindUniqueArgs<ExtArgs>>): Prisma__votesClient<$Result.GetResult<Prisma.$votesPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Votes that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {votesFindUniqueOrThrowArgs} args - Arguments to find a Votes\n     * @example\n     * // Get one Votes\n     * const votes = await prisma.votes.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends votesFindUniqueOrThrowArgs>(args: SelectSubset<T, votesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__votesClient<$Result.GetResult<Prisma.$votesPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Votes that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {votesFindFirstArgs} args - Arguments to find a Votes\n     * @example\n     * // Get one Votes\n     * const votes = await prisma.votes.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends votesFindFirstArgs>(args?: SelectSubset<T, votesFindFirstArgs<ExtArgs>>): Prisma__votesClient<$Result.GetResult<Prisma.$votesPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Votes that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {votesFindFirstOrThrowArgs} args - Arguments to find a Votes\n     * @example\n     * // Get one Votes\n     * const votes = await prisma.votes.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends votesFindFirstOrThrowArgs>(args?: SelectSubset<T, votesFindFirstOrThrowArgs<ExtArgs>>): Prisma__votesClient<$Result.GetResult<Prisma.$votesPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Votes that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {votesFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Votes\n     * const votes = await prisma.votes.findMany()\n     * \n     * // Get first 10 Votes\n     * const votes = await prisma.votes.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const votesWithIdOnly = await prisma.votes.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends votesFindManyArgs>(args?: SelectSubset<T, votesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$votesPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Votes.\n     * @param {votesCreateArgs} args - Arguments to create a Votes.\n     * @example\n     * // Create one Votes\n     * const Votes = await prisma.votes.create({\n     *   data: {\n     *     // ... data to create a Votes\n     *   }\n     * })\n     * \n     */\n    create<T extends votesCreateArgs>(args: SelectSubset<T, votesCreateArgs<ExtArgs>>): Prisma__votesClient<$Result.GetResult<Prisma.$votesPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Votes.\n     * @param {votesCreateManyArgs} args - Arguments to create many Votes.\n     * @example\n     * // Create many Votes\n     * const votes = await prisma.votes.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends votesCreateManyArgs>(args?: SelectSubset<T, votesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Votes and returns the data saved in the database.\n     * @param {votesCreateManyAndReturnArgs} args - Arguments to create many Votes.\n     * @example\n     * // Create many Votes\n     * const votes = await prisma.votes.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Votes and only return the `id`\n     * const votesWithIdOnly = await prisma.votes.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends votesCreateManyAndReturnArgs>(args?: SelectSubset<T, votesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$votesPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Votes.\n     * @param {votesDeleteArgs} args - Arguments to delete one Votes.\n     * @example\n     * // Delete one Votes\n     * const Votes = await prisma.votes.delete({\n     *   where: {\n     *     // ... filter to delete one Votes\n     *   }\n     * })\n     * \n     */\n    delete<T extends votesDeleteArgs>(args: SelectSubset<T, votesDeleteArgs<ExtArgs>>): Prisma__votesClient<$Result.GetResult<Prisma.$votesPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Votes.\n     * @param {votesUpdateArgs} args - Arguments to update one Votes.\n     * @example\n     * // Update one Votes\n     * const votes = await prisma.votes.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends votesUpdateArgs>(args: SelectSubset<T, votesUpdateArgs<ExtArgs>>): Prisma__votesClient<$Result.GetResult<Prisma.$votesPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Votes.\n     * @param {votesDeleteManyArgs} args - Arguments to filter Votes to delete.\n     * @example\n     * // Delete a few Votes\n     * const { count } = await prisma.votes.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends votesDeleteManyArgs>(args?: SelectSubset<T, votesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Votes.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {votesUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Votes\n     * const votes = await prisma.votes.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends votesUpdateManyArgs>(args: SelectSubset<T, votesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Votes and returns the data updated in the database.\n     * @param {votesUpdateManyAndReturnArgs} args - Arguments to update many Votes.\n     * @example\n     * // Update many Votes\n     * const votes = await prisma.votes.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Votes and only return the `id`\n     * const votesWithIdOnly = await prisma.votes.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends votesUpdateManyAndReturnArgs>(args: SelectSubset<T, votesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$votesPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Votes.\n     * @param {votesUpsertArgs} args - Arguments to update or create a Votes.\n     * @example\n     * // Update or create a Votes\n     * const votes = await prisma.votes.upsert({\n     *   create: {\n     *     // ... data to create a Votes\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Votes we want to update\n     *   }\n     * })\n     */\n    upsert<T extends votesUpsertArgs>(args: SelectSubset<T, votesUpsertArgs<ExtArgs>>): Prisma__votesClient<$Result.GetResult<Prisma.$votesPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Votes.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {votesCountArgs} args - Arguments to filter Votes to count.\n     * @example\n     * // Count the number of Votes\n     * const count = await prisma.votes.count({\n     *   where: {\n     *     // ... the filter for the Votes we want to count\n     *   }\n     * })\n    **/\n    count<T extends votesCountArgs>(\n      args?: Subset<T, votesCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], VotesCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Votes.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {VotesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends VotesAggregateArgs>(args: Subset<T, VotesAggregateArgs>): Prisma.PrismaPromise<GetVotesAggregateType<T>>\n\n    /**\n     * Group by Votes.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {votesGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends votesGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: votesGroupByArgs['orderBy'] }\n        : { orderBy?: votesGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, votesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVotesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the votes model\n   */\n  readonly fields: votesFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for votes.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__votesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    post<T extends votes$postArgs<ExtArgs> = {}>(args?: Subset<T, votes$postArgs<ExtArgs>>): Prisma__postsClient<$Result.GetResult<Prisma.$postsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n    comment<T extends votes$commentArgs<ExtArgs> = {}>(args?: Subset<T, votes$commentArgs<ExtArgs>>): Prisma__commentsClient<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the votes model\n   */\n  interface votesFieldRefs {\n    readonly id: FieldRef<\"votes\", 'String'>\n    readonly user_id: FieldRef<\"votes\", 'String'>\n    readonly post_id: FieldRef<\"votes\", 'String'>\n    readonly comment_id: FieldRef<\"votes\", 'String'>\n    readonly value: FieldRef<\"votes\", 'Int'>\n    readonly created_at: FieldRef<\"votes\", 'DateTime'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * votes findUnique\n   */\n  export type votesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the votes\n     */\n    select?: votesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the votes\n     */\n    omit?: votesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: votesInclude<ExtArgs> | null\n    /**\n     * Filter, which votes to fetch.\n     */\n    where: votesWhereUniqueInput\n  }\n\n  /**\n   * votes findUniqueOrThrow\n   */\n  export type votesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the votes\n     */\n    select?: votesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the votes\n     */\n    omit?: votesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: votesInclude<ExtArgs> | null\n    /**\n     * Filter, which votes to fetch.\n     */\n    where: votesWhereUniqueInput\n  }\n\n  /**\n   * votes findFirst\n   */\n  export type votesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the votes\n     */\n    select?: votesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the votes\n     */\n    omit?: votesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: votesInclude<ExtArgs> | null\n    /**\n     * Filter, which votes to fetch.\n     */\n    where?: votesWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of votes to fetch.\n     */\n    orderBy?: votesOrderByWithRelationInput | votesOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for votes.\n     */\n    cursor?: votesWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` votes from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` votes.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of votes.\n     */\n    distinct?: VotesScalarFieldEnum | VotesScalarFieldEnum[]\n  }\n\n  /**\n   * votes findFirstOrThrow\n   */\n  export type votesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the votes\n     */\n    select?: votesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the votes\n     */\n    omit?: votesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: votesInclude<ExtArgs> | null\n    /**\n     * Filter, which votes to fetch.\n     */\n    where?: votesWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of votes to fetch.\n     */\n    orderBy?: votesOrderByWithRelationInput | votesOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for votes.\n     */\n    cursor?: votesWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` votes from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` votes.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of votes.\n     */\n    distinct?: VotesScalarFieldEnum | VotesScalarFieldEnum[]\n  }\n\n  /**\n   * votes findMany\n   */\n  export type votesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the votes\n     */\n    select?: votesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the votes\n     */\n    omit?: votesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: votesInclude<ExtArgs> | null\n    /**\n     * Filter, which votes to fetch.\n     */\n    where?: votesWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of votes to fetch.\n     */\n    orderBy?: votesOrderByWithRelationInput | votesOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing votes.\n     */\n    cursor?: votesWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` votes from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` votes.\n     */\n    skip?: number\n    distinct?: VotesScalarFieldEnum | VotesScalarFieldEnum[]\n  }\n\n  /**\n   * votes create\n   */\n  export type votesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the votes\n     */\n    select?: votesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the votes\n     */\n    omit?: votesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: votesInclude<ExtArgs> | null\n    /**\n     * The data needed to create a votes.\n     */\n    data: XOR<votesCreateInput, votesUncheckedCreateInput>\n  }\n\n  /**\n   * votes createMany\n   */\n  export type votesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many votes.\n     */\n    data: votesCreateManyInput | votesCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * votes createManyAndReturn\n   */\n  export type votesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the votes\n     */\n    select?: votesSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the votes\n     */\n    omit?: votesOmit<ExtArgs> | null\n    /**\n     * The data used to create many votes.\n     */\n    data: votesCreateManyInput | votesCreateManyInput[]\n    skipDuplicates?: boolean\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: votesIncludeCreateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * votes update\n   */\n  export type votesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the votes\n     */\n    select?: votesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the votes\n     */\n    omit?: votesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: votesInclude<ExtArgs> | null\n    /**\n     * The data needed to update a votes.\n     */\n    data: XOR<votesUpdateInput, votesUncheckedUpdateInput>\n    /**\n     * Choose, which votes to update.\n     */\n    where: votesWhereUniqueInput\n  }\n\n  /**\n   * votes updateMany\n   */\n  export type votesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update votes.\n     */\n    data: XOR<votesUpdateManyMutationInput, votesUncheckedUpdateManyInput>\n    /**\n     * Filter which votes to update\n     */\n    where?: votesWhereInput\n    /**\n     * Limit how many votes to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * votes updateManyAndReturn\n   */\n  export type votesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the votes\n     */\n    select?: votesSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the votes\n     */\n    omit?: votesOmit<ExtArgs> | null\n    /**\n     * The data used to update votes.\n     */\n    data: XOR<votesUpdateManyMutationInput, votesUncheckedUpdateManyInput>\n    /**\n     * Filter which votes to update\n     */\n    where?: votesWhereInput\n    /**\n     * Limit how many votes to update.\n     */\n    limit?: number\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: votesIncludeUpdateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * votes upsert\n   */\n  export type votesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the votes\n     */\n    select?: votesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the votes\n     */\n    omit?: votesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: votesInclude<ExtArgs> | null\n    /**\n     * The filter to search for the votes to update in case it exists.\n     */\n    where: votesWhereUniqueInput\n    /**\n     * In case the votes found by the `where` argument doesn't exist, create a new votes with this data.\n     */\n    create: XOR<votesCreateInput, votesUncheckedCreateInput>\n    /**\n     * In case the votes was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<votesUpdateInput, votesUncheckedUpdateInput>\n  }\n\n  /**\n   * votes delete\n   */\n  export type votesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the votes\n     */\n    select?: votesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the votes\n     */\n    omit?: votesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: votesInclude<ExtArgs> | null\n    /**\n     * Filter which votes to delete.\n     */\n    where: votesWhereUniqueInput\n  }\n\n  /**\n   * votes deleteMany\n   */\n  export type votesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which votes to delete\n     */\n    where?: votesWhereInput\n    /**\n     * Limit how many votes to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * votes.post\n   */\n  export type votes$postArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the posts\n     */\n    select?: postsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the posts\n     */\n    omit?: postsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: postsInclude<ExtArgs> | null\n    where?: postsWhereInput\n  }\n\n  /**\n   * votes.comment\n   */\n  export type votes$commentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the comments\n     */\n    select?: commentsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the comments\n     */\n    omit?: commentsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: commentsInclude<ExtArgs> | null\n    where?: commentsWhereInput\n  }\n\n  /**\n   * votes without action\n   */\n  export type votesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the votes\n     */\n    select?: votesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the votes\n     */\n    omit?: votesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: votesInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Enums\n   */\n\n  export const TransactionIsolationLevel: {\n    ReadUncommitted: 'ReadUncommitted',\n    ReadCommitted: 'ReadCommitted',\n    RepeatableRead: 'RepeatableRead',\n    Serializable: 'Serializable'\n  };\n\n  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]\n\n\n  export const UsersScalarFieldEnum: {\n    id: 'id',\n    user_role_id: 'user_role_id',\n    username: 'username',\n    email: 'email',\n    bio: 'bio',\n    password_hash: 'password_hash',\n    created_at: 'created_at',\n    updated_at: 'updated_at',\n    status: 'status'\n  };\n\n  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]\n\n\n  export const User_rolesScalarFieldEnum: {\n    id: 'id',\n    name: 'name',\n    description: 'description'\n  };\n\n  export type User_rolesScalarFieldEnum = (typeof User_rolesScalarFieldEnum)[keyof typeof User_rolesScalarFieldEnum]\n\n\n  export const CategoriesScalarFieldEnum: {\n    id: 'id',\n    name: 'name',\n    description: 'description',\n    created_at: 'created_at'\n  };\n\n  export type CategoriesScalarFieldEnum = (typeof CategoriesScalarFieldEnum)[keyof typeof CategoriesScalarFieldEnum]\n\n\n  export const PostsScalarFieldEnum: {\n    id: 'id',\n    user_id: 'user_id',\n    category_id: 'category_id',\n    title: 'title',\n    content: 'content',\n    created_at: 'created_at',\n    updated_at: 'updated_at',\n    deleted_at: 'deleted_at'\n  };\n\n  export type PostsScalarFieldEnum = (typeof PostsScalarFieldEnum)[keyof typeof PostsScalarFieldEnum]\n\n\n  export const CommentsScalarFieldEnum: {\n    id: 'id',\n    user_id: 'user_id',\n    post_id: 'post_id',\n    parent_id: 'parent_id',\n    content: 'content',\n    created_at: 'created_at',\n    updated_at: 'updated_at',\n    deleted_at: 'deleted_at'\n  };\n\n  export type CommentsScalarFieldEnum = (typeof CommentsScalarFieldEnum)[keyof typeof CommentsScalarFieldEnum]\n\n\n  export const VotesScalarFieldEnum: {\n    id: 'id',\n    user_id: 'user_id',\n    post_id: 'post_id',\n    comment_id: 'comment_id',\n    value: 'value',\n    created_at: 'created_at'\n  };\n\n  export type VotesScalarFieldEnum = (typeof VotesScalarFieldEnum)[keyof typeof VotesScalarFieldEnum]\n\n\n  export const SortOrder: {\n    asc: 'asc',\n    desc: 'desc'\n  };\n\n  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]\n\n\n  export const QueryMode: {\n    default: 'default',\n    insensitive: 'insensitive'\n  };\n\n  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]\n\n\n  export const NullsOrder: {\n    first: 'first',\n    last: 'last'\n  };\n\n  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]\n\n\n  /**\n   * Field references\n   */\n\n\n  /**\n   * Reference to a field of type 'String'\n   */\n  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>\n    \n\n\n  /**\n   * Reference to a field of type 'String[]'\n   */\n  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>\n    \n\n\n  /**\n   * Reference to a field of type 'DateTime'\n   */\n  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>\n    \n\n\n  /**\n   * Reference to a field of type 'DateTime[]'\n   */\n  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>\n    \n\n\n  /**\n   * Reference to a field of type 'Int'\n   */\n  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>\n    \n\n\n  /**\n   * Reference to a field of type 'Int[]'\n   */\n  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>\n    \n\n\n  /**\n   * Reference to a field of type 'Float'\n   */\n  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>\n    \n\n\n  /**\n   * Reference to a field of type 'Float[]'\n   */\n  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>\n    \n  /**\n   * Deep Input Types\n   */\n\n\n  export type usersWhereInput = {\n    AND?: usersWhereInput | usersWhereInput[]\n    OR?: usersWhereInput[]\n    NOT?: usersWhereInput | usersWhereInput[]\n    id?: UuidFilter<\"users\"> | string\n    user_role_id?: UuidFilter<\"users\"> | string\n    username?: StringFilter<\"users\"> | string\n    email?: StringFilter<\"users\"> | string\n    bio?: StringNullableFilter<\"users\"> | string | null\n    password_hash?: StringFilter<\"users\"> | string\n    created_at?: DateTimeFilter<\"users\"> | Date | string\n    updated_at?: DateTimeFilter<\"users\"> | Date | string\n    status?: StringFilter<\"users\"> | string\n    role?: XOR<User_rolesScalarRelationFilter, user_rolesWhereInput>\n    posts?: PostsListRelationFilter\n    comments?: CommentsListRelationFilter\n    votes?: VotesListRelationFilter\n  }\n\n  export type usersOrderByWithRelationInput = {\n    id?: SortOrder\n    user_role_id?: SortOrder\n    username?: SortOrder\n    email?: SortOrder\n    bio?: SortOrderInput | SortOrder\n    password_hash?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    status?: SortOrder\n    role?: user_rolesOrderByWithRelationInput\n    posts?: postsOrderByRelationAggregateInput\n    comments?: commentsOrderByRelationAggregateInput\n    votes?: votesOrderByRelationAggregateInput\n  }\n\n  export type usersWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    username?: string\n    email?: string\n    AND?: usersWhereInput | usersWhereInput[]\n    OR?: usersWhereInput[]\n    NOT?: usersWhereInput | usersWhereInput[]\n    user_role_id?: UuidFilter<\"users\"> | string\n    bio?: StringNullableFilter<\"users\"> | string | null\n    password_hash?: StringFilter<\"users\"> | string\n    created_at?: DateTimeFilter<\"users\"> | Date | string\n    updated_at?: DateTimeFilter<\"users\"> | Date | string\n    status?: StringFilter<\"users\"> | string\n    role?: XOR<User_rolesScalarRelationFilter, user_rolesWhereInput>\n    posts?: PostsListRelationFilter\n    comments?: CommentsListRelationFilter\n    votes?: VotesListRelationFilter\n  }, \"id\" | \"username\" | \"email\">\n\n  export type usersOrderByWithAggregationInput = {\n    id?: SortOrder\n    user_role_id?: SortOrder\n    username?: SortOrder\n    email?: SortOrder\n    bio?: SortOrderInput | SortOrder\n    password_hash?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    status?: SortOrder\n    _count?: usersCountOrderByAggregateInput\n    _max?: usersMaxOrderByAggregateInput\n    _min?: usersMinOrderByAggregateInput\n  }\n\n  export type usersScalarWhereWithAggregatesInput = {\n    AND?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]\n    OR?: usersScalarWhereWithAggregatesInput[]\n    NOT?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"users\"> | string\n    user_role_id?: UuidWithAggregatesFilter<\"users\"> | string\n    username?: StringWithAggregatesFilter<\"users\"> | string\n    email?: StringWithAggregatesFilter<\"users\"> | string\n    bio?: StringNullableWithAggregatesFilter<\"users\"> | string | null\n    password_hash?: StringWithAggregatesFilter<\"users\"> | string\n    created_at?: DateTimeWithAggregatesFilter<\"users\"> | Date | string\n    updated_at?: DateTimeWithAggregatesFilter<\"users\"> | Date | string\n    status?: StringWithAggregatesFilter<\"users\"> | string\n  }\n\n  export type user_rolesWhereInput = {\n    AND?: user_rolesWhereInput | user_rolesWhereInput[]\n    OR?: user_rolesWhereInput[]\n    NOT?: user_rolesWhereInput | user_rolesWhereInput[]\n    id?: UuidFilter<\"user_roles\"> | string\n    name?: StringFilter<\"user_roles\"> | string\n    description?: StringFilter<\"user_roles\"> | string\n    users?: UsersListRelationFilter\n  }\n\n  export type user_rolesOrderByWithRelationInput = {\n    id?: SortOrder\n    name?: SortOrder\n    description?: SortOrder\n    users?: usersOrderByRelationAggregateInput\n  }\n\n  export type user_rolesWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    name?: string\n    AND?: user_rolesWhereInput | user_rolesWhereInput[]\n    OR?: user_rolesWhereInput[]\n    NOT?: user_rolesWhereInput | user_rolesWhereInput[]\n    description?: StringFilter<\"user_roles\"> | string\n    users?: UsersListRelationFilter\n  }, \"id\" | \"name\">\n\n  export type user_rolesOrderByWithAggregationInput = {\n    id?: SortOrder\n    name?: SortOrder\n    description?: SortOrder\n    _count?: user_rolesCountOrderByAggregateInput\n    _max?: user_rolesMaxOrderByAggregateInput\n    _min?: user_rolesMinOrderByAggregateInput\n  }\n\n  export type user_rolesScalarWhereWithAggregatesInput = {\n    AND?: user_rolesScalarWhereWithAggregatesInput | user_rolesScalarWhereWithAggregatesInput[]\n    OR?: user_rolesScalarWhereWithAggregatesInput[]\n    NOT?: user_rolesScalarWhereWithAggregatesInput | user_rolesScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"user_roles\"> | string\n    name?: StringWithAggregatesFilter<\"user_roles\"> | string\n    description?: StringWithAggregatesFilter<\"user_roles\"> | string\n  }\n\n  export type categoriesWhereInput = {\n    AND?: categoriesWhereInput | categoriesWhereInput[]\n    OR?: categoriesWhereInput[]\n    NOT?: categoriesWhereInput | categoriesWhereInput[]\n    id?: UuidFilter<\"categories\"> | string\n    name?: StringFilter<\"categories\"> | string\n    description?: StringFilter<\"categories\"> | string\n    created_at?: DateTimeFilter<\"categories\"> | Date | string\n    posts?: PostsListRelationFilter\n  }\n\n  export type categoriesOrderByWithRelationInput = {\n    id?: SortOrder\n    name?: SortOrder\n    description?: SortOrder\n    created_at?: SortOrder\n    posts?: postsOrderByRelationAggregateInput\n  }\n\n  export type categoriesWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    name?: string\n    AND?: categoriesWhereInput | categoriesWhereInput[]\n    OR?: categoriesWhereInput[]\n    NOT?: categoriesWhereInput | categoriesWhereInput[]\n    description?: StringFilter<\"categories\"> | string\n    created_at?: DateTimeFilter<\"categories\"> | Date | string\n    posts?: PostsListRelationFilter\n  }, \"id\" | \"name\">\n\n  export type categoriesOrderByWithAggregationInput = {\n    id?: SortOrder\n    name?: SortOrder\n    description?: SortOrder\n    created_at?: SortOrder\n    _count?: categoriesCountOrderByAggregateInput\n    _max?: categoriesMaxOrderByAggregateInput\n    _min?: categoriesMinOrderByAggregateInput\n  }\n\n  export type categoriesScalarWhereWithAggregatesInput = {\n    AND?: categoriesScalarWhereWithAggregatesInput | categoriesScalarWhereWithAggregatesInput[]\n    OR?: categoriesScalarWhereWithAggregatesInput[]\n    NOT?: categoriesScalarWhereWithAggregatesInput | categoriesScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"categories\"> | string\n    name?: StringWithAggregatesFilter<\"categories\"> | string\n    description?: StringWithAggregatesFilter<\"categories\"> | string\n    created_at?: DateTimeWithAggregatesFilter<\"categories\"> | Date | string\n  }\n\n  export type postsWhereInput = {\n    AND?: postsWhereInput | postsWhereInput[]\n    OR?: postsWhereInput[]\n    NOT?: postsWhereInput | postsWhereInput[]\n    id?: UuidFilter<\"posts\"> | string\n    user_id?: UuidFilter<\"posts\"> | string\n    category_id?: UuidFilter<\"posts\"> | string\n    title?: StringFilter<\"posts\"> | string\n    content?: StringFilter<\"posts\"> | string\n    created_at?: DateTimeFilter<\"posts\"> | Date | string\n    updated_at?: DateTimeFilter<\"posts\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"posts\"> | Date | string | null\n    author?: XOR<UsersScalarRelationFilter, usersWhereInput>\n    category?: XOR<CategoriesScalarRelationFilter, categoriesWhereInput>\n    comments?: CommentsListRelationFilter\n    votes?: VotesListRelationFilter\n  }\n\n  export type postsOrderByWithRelationInput = {\n    id?: SortOrder\n    user_id?: SortOrder\n    category_id?: SortOrder\n    title?: SortOrder\n    content?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrderInput | SortOrder\n    author?: usersOrderByWithRelationInput\n    category?: categoriesOrderByWithRelationInput\n    comments?: commentsOrderByRelationAggregateInput\n    votes?: votesOrderByRelationAggregateInput\n  }\n\n  export type postsWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    AND?: postsWhereInput | postsWhereInput[]\n    OR?: postsWhereInput[]\n    NOT?: postsWhereInput | postsWhereInput[]\n    user_id?: UuidFilter<\"posts\"> | string\n    category_id?: UuidFilter<\"posts\"> | string\n    title?: StringFilter<\"posts\"> | string\n    content?: StringFilter<\"posts\"> | string\n    created_at?: DateTimeFilter<\"posts\"> | Date | string\n    updated_at?: DateTimeFilter<\"posts\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"posts\"> | Date | string | null\n    author?: XOR<UsersScalarRelationFilter, usersWhereInput>\n    category?: XOR<CategoriesScalarRelationFilter, categoriesWhereInput>\n    comments?: CommentsListRelationFilter\n    votes?: VotesListRelationFilter\n  }, \"id\">\n\n  export type postsOrderByWithAggregationInput = {\n    id?: SortOrder\n    user_id?: SortOrder\n    category_id?: SortOrder\n    title?: SortOrder\n    content?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrderInput | SortOrder\n    _count?: postsCountOrderByAggregateInput\n    _max?: postsMaxOrderByAggregateInput\n    _min?: postsMinOrderByAggregateInput\n  }\n\n  export type postsScalarWhereWithAggregatesInput = {\n    AND?: postsScalarWhereWithAggregatesInput | postsScalarWhereWithAggregatesInput[]\n    OR?: postsScalarWhereWithAggregatesInput[]\n    NOT?: postsScalarWhereWithAggregatesInput | postsScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"posts\"> | string\n    user_id?: UuidWithAggregatesFilter<\"posts\"> | string\n    category_id?: UuidWithAggregatesFilter<\"posts\"> | string\n    title?: StringWithAggregatesFilter<\"posts\"> | string\n    content?: StringWithAggregatesFilter<\"posts\"> | string\n    created_at?: DateTimeWithAggregatesFilter<\"posts\"> | Date | string\n    updated_at?: DateTimeWithAggregatesFilter<\"posts\"> | Date | string\n    deleted_at?: DateTimeNullableWithAggregatesFilter<\"posts\"> | Date | string | null\n  }\n\n  export type commentsWhereInput = {\n    AND?: commentsWhereInput | commentsWhereInput[]\n    OR?: commentsWhereInput[]\n    NOT?: commentsWhereInput | commentsWhereInput[]\n    id?: UuidFilter<\"comments\"> | string\n    user_id?: UuidFilter<\"comments\"> | string\n    post_id?: UuidFilter<\"comments\"> | string\n    parent_id?: UuidNullableFilter<\"comments\"> | string | null\n    content?: StringFilter<\"comments\"> | string\n    created_at?: DateTimeFilter<\"comments\"> | Date | string\n    updated_at?: DateTimeFilter<\"comments\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"comments\"> | Date | string | null\n    author?: XOR<UsersScalarRelationFilter, usersWhereInput>\n    post?: XOR<PostsScalarRelationFilter, postsWhereInput>\n    parent?: XOR<CommentsNullableScalarRelationFilter, commentsWhereInput> | null\n    recursive?: CommentsListRelationFilter\n    votes?: VotesListRelationFilter\n  }\n\n  export type commentsOrderByWithRelationInput = {\n    id?: SortOrder\n    user_id?: SortOrder\n    post_id?: SortOrder\n    parent_id?: SortOrderInput | SortOrder\n    content?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrderInput | SortOrder\n    author?: usersOrderByWithRelationInput\n    post?: postsOrderByWithRelationInput\n    parent?: commentsOrderByWithRelationInput\n    recursive?: commentsOrderByRelationAggregateInput\n    votes?: votesOrderByRelationAggregateInput\n  }\n\n  export type commentsWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    AND?: commentsWhereInput | commentsWhereInput[]\n    OR?: commentsWhereInput[]\n    NOT?: commentsWhereInput | commentsWhereInput[]\n    user_id?: UuidFilter<\"comments\"> | string\n    post_id?: UuidFilter<\"comments\"> | string\n    parent_id?: UuidNullableFilter<\"comments\"> | string | null\n    content?: StringFilter<\"comments\"> | string\n    created_at?: DateTimeFilter<\"comments\"> | Date | string\n    updated_at?: DateTimeFilter<\"comments\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"comments\"> | Date | string | null\n    author?: XOR<UsersScalarRelationFilter, usersWhereInput>\n    post?: XOR<PostsScalarRelationFilter, postsWhereInput>\n    parent?: XOR<CommentsNullableScalarRelationFilter, commentsWhereInput> | null\n    recursive?: CommentsListRelationFilter\n    votes?: VotesListRelationFilter\n  }, \"id\">\n\n  export type commentsOrderByWithAggregationInput = {\n    id?: SortOrder\n    user_id?: SortOrder\n    post_id?: SortOrder\n    parent_id?: SortOrderInput | SortOrder\n    content?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrderInput | SortOrder\n    _count?: commentsCountOrderByAggregateInput\n    _max?: commentsMaxOrderByAggregateInput\n    _min?: commentsMinOrderByAggregateInput\n  }\n\n  export type commentsScalarWhereWithAggregatesInput = {\n    AND?: commentsScalarWhereWithAggregatesInput | commentsScalarWhereWithAggregatesInput[]\n    OR?: commentsScalarWhereWithAggregatesInput[]\n    NOT?: commentsScalarWhereWithAggregatesInput | commentsScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"comments\"> | string\n    user_id?: UuidWithAggregatesFilter<\"comments\"> | string\n    post_id?: UuidWithAggregatesFilter<\"comments\"> | string\n    parent_id?: UuidNullableWithAggregatesFilter<\"comments\"> | string | null\n    content?: StringWithAggregatesFilter<\"comments\"> | string\n    created_at?: DateTimeWithAggregatesFilter<\"comments\"> | Date | string\n    updated_at?: DateTimeWithAggregatesFilter<\"comments\"> | Date | string\n    deleted_at?: DateTimeNullableWithAggregatesFilter<\"comments\"> | Date | string | null\n  }\n\n  export type votesWhereInput = {\n    AND?: votesWhereInput | votesWhereInput[]\n    OR?: votesWhereInput[]\n    NOT?: votesWhereInput | votesWhereInput[]\n    id?: UuidFilter<\"votes\"> | string\n    user_id?: UuidFilter<\"votes\"> | string\n    post_id?: UuidNullableFilter<\"votes\"> | string | null\n    comment_id?: UuidNullableFilter<\"votes\"> | string | null\n    value?: IntFilter<\"votes\"> | number\n    created_at?: DateTimeFilter<\"votes\"> | Date | string\n    user?: XOR<UsersScalarRelationFilter, usersWhereInput>\n    post?: XOR<PostsNullableScalarRelationFilter, postsWhereInput> | null\n    comment?: XOR<CommentsNullableScalarRelationFilter, commentsWhereInput> | null\n  }\n\n  export type votesOrderByWithRelationInput = {\n    id?: SortOrder\n    user_id?: SortOrder\n    post_id?: SortOrderInput | SortOrder\n    comment_id?: SortOrderInput | SortOrder\n    value?: SortOrder\n    created_at?: SortOrder\n    user?: usersOrderByWithRelationInput\n    post?: postsOrderByWithRelationInput\n    comment?: commentsOrderByWithRelationInput\n  }\n\n  export type votesWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    user_id_post_id?: votesUser_idPost_idCompoundUniqueInput\n    user_id_comment_id?: votesUser_idComment_idCompoundUniqueInput\n    AND?: votesWhereInput | votesWhereInput[]\n    OR?: votesWhereInput[]\n    NOT?: votesWhereInput | votesWhereInput[]\n    user_id?: UuidFilter<\"votes\"> | string\n    post_id?: UuidNullableFilter<\"votes\"> | string | null\n    comment_id?: UuidNullableFilter<\"votes\"> | string | null\n    value?: IntFilter<\"votes\"> | number\n    created_at?: DateTimeFilter<\"votes\"> | Date | string\n    user?: XOR<UsersScalarRelationFilter, usersWhereInput>\n    post?: XOR<PostsNullableScalarRelationFilter, postsWhereInput> | null\n    comment?: XOR<CommentsNullableScalarRelationFilter, commentsWhereInput> | null\n  }, \"id\" | \"user_id_post_id\" | \"user_id_comment_id\">\n\n  export type votesOrderByWithAggregationInput = {\n    id?: SortOrder\n    user_id?: SortOrder\n    post_id?: SortOrderInput | SortOrder\n    comment_id?: SortOrderInput | SortOrder\n    value?: SortOrder\n    created_at?: SortOrder\n    _count?: votesCountOrderByAggregateInput\n    _avg?: votesAvgOrderByAggregateInput\n    _max?: votesMaxOrderByAggregateInput\n    _min?: votesMinOrderByAggregateInput\n    _sum?: votesSumOrderByAggregateInput\n  }\n\n  export type votesScalarWhereWithAggregatesInput = {\n    AND?: votesScalarWhereWithAggregatesInput | votesScalarWhereWithAggregatesInput[]\n    OR?: votesScalarWhereWithAggregatesInput[]\n    NOT?: votesScalarWhereWithAggregatesInput | votesScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"votes\"> | string\n    user_id?: UuidWithAggregatesFilter<\"votes\"> | string\n    post_id?: UuidNullableWithAggregatesFilter<\"votes\"> | string | null\n    comment_id?: UuidNullableWithAggregatesFilter<\"votes\"> | string | null\n    value?: IntWithAggregatesFilter<\"votes\"> | number\n    created_at?: DateTimeWithAggregatesFilter<\"votes\"> | Date | string\n  }\n\n  export type usersCreateInput = {\n    id: string\n    username: string\n    email: string\n    bio?: string | null\n    password_hash: string\n    created_at: Date | string\n    updated_at: Date | string\n    status: string\n    role: user_rolesCreateNestedOneWithoutUsersInput\n    posts?: postsCreateNestedManyWithoutAuthorInput\n    comments?: commentsCreateNestedManyWithoutAuthorInput\n    votes?: votesCreateNestedManyWithoutUserInput\n  }\n\n  export type usersUncheckedCreateInput = {\n    id: string\n    user_role_id: string\n    username: string\n    email: string\n    bio?: string | null\n    password_hash: string\n    created_at: Date | string\n    updated_at: Date | string\n    status: string\n    posts?: postsUncheckedCreateNestedManyWithoutAuthorInput\n    comments?: commentsUncheckedCreateNestedManyWithoutAuthorInput\n    votes?: votesUncheckedCreateNestedManyWithoutUserInput\n  }\n\n  export type usersUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    username?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    bio?: NullableStringFieldUpdateOperationsInput | string | null\n    password_hash?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    status?: StringFieldUpdateOperationsInput | string\n    role?: user_rolesUpdateOneRequiredWithoutUsersNestedInput\n    posts?: postsUpdateManyWithoutAuthorNestedInput\n    comments?: commentsUpdateManyWithoutAuthorNestedInput\n    votes?: votesUpdateManyWithoutUserNestedInput\n  }\n\n  export type usersUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    user_role_id?: StringFieldUpdateOperationsInput | string\n    username?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    bio?: NullableStringFieldUpdateOperationsInput | string | null\n    password_hash?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    status?: StringFieldUpdateOperationsInput | string\n    posts?: postsUncheckedUpdateManyWithoutAuthorNestedInput\n    comments?: commentsUncheckedUpdateManyWithoutAuthorNestedInput\n    votes?: votesUncheckedUpdateManyWithoutUserNestedInput\n  }\n\n  export type usersCreateManyInput = {\n    id: string\n    user_role_id: string\n    username: string\n    email: string\n    bio?: string | null\n    password_hash: string\n    created_at: Date | string\n    updated_at: Date | string\n    status: string\n  }\n\n  export type usersUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    username?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    bio?: NullableStringFieldUpdateOperationsInput | string | null\n    password_hash?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    status?: StringFieldUpdateOperationsInput | string\n  }\n\n  export type usersUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    user_role_id?: StringFieldUpdateOperationsInput | string\n    username?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    bio?: NullableStringFieldUpdateOperationsInput | string | null\n    password_hash?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    status?: StringFieldUpdateOperationsInput | string\n  }\n\n  export type user_rolesCreateInput = {\n    id: string\n    name: string\n    description: string\n    users?: usersCreateNestedManyWithoutRoleInput\n  }\n\n  export type user_rolesUncheckedCreateInput = {\n    id: string\n    name: string\n    description: string\n    users?: usersUncheckedCreateNestedManyWithoutRoleInput\n  }\n\n  export type user_rolesUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: StringFieldUpdateOperationsInput | string\n    users?: usersUpdateManyWithoutRoleNestedInput\n  }\n\n  export type user_rolesUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: StringFieldUpdateOperationsInput | string\n    users?: usersUncheckedUpdateManyWithoutRoleNestedInput\n  }\n\n  export type user_rolesCreateManyInput = {\n    id: string\n    name: string\n    description: string\n  }\n\n  export type user_rolesUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: StringFieldUpdateOperationsInput | string\n  }\n\n  export type user_rolesUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: StringFieldUpdateOperationsInput | string\n  }\n\n  export type categoriesCreateInput = {\n    id: string\n    name: string\n    description: string\n    created_at: Date | string\n    posts?: postsCreateNestedManyWithoutCategoryInput\n  }\n\n  export type categoriesUncheckedCreateInput = {\n    id: string\n    name: string\n    description: string\n    created_at: Date | string\n    posts?: postsUncheckedCreateNestedManyWithoutCategoryInput\n  }\n\n  export type categoriesUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    posts?: postsUpdateManyWithoutCategoryNestedInput\n  }\n\n  export type categoriesUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    posts?: postsUncheckedUpdateManyWithoutCategoryNestedInput\n  }\n\n  export type categoriesCreateManyInput = {\n    id: string\n    name: string\n    description: string\n    created_at: Date | string\n  }\n\n  export type categoriesUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type categoriesUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type postsCreateInput = {\n    id: string\n    title: string\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    author: usersCreateNestedOneWithoutPostsInput\n    category: categoriesCreateNestedOneWithoutPostsInput\n    comments?: commentsCreateNestedManyWithoutPostInput\n    votes?: votesCreateNestedManyWithoutPostInput\n  }\n\n  export type postsUncheckedCreateInput = {\n    id: string\n    user_id: string\n    category_id: string\n    title: string\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    comments?: commentsUncheckedCreateNestedManyWithoutPostInput\n    votes?: votesUncheckedCreateNestedManyWithoutPostInput\n  }\n\n  export type postsUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    author?: usersUpdateOneRequiredWithoutPostsNestedInput\n    category?: categoriesUpdateOneRequiredWithoutPostsNestedInput\n    comments?: commentsUpdateManyWithoutPostNestedInput\n    votes?: votesUpdateManyWithoutPostNestedInput\n  }\n\n  export type postsUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    user_id?: StringFieldUpdateOperationsInput | string\n    category_id?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    comments?: commentsUncheckedUpdateManyWithoutPostNestedInput\n    votes?: votesUncheckedUpdateManyWithoutPostNestedInput\n  }\n\n  export type postsCreateManyInput = {\n    id: string\n    user_id: string\n    category_id: string\n    title: string\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type postsUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type postsUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    user_id?: StringFieldUpdateOperationsInput | string\n    category_id?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type commentsCreateInput = {\n    id: string\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    author: usersCreateNestedOneWithoutCommentsInput\n    post: postsCreateNestedOneWithoutCommentsInput\n    parent?: commentsCreateNestedOneWithoutRecursiveInput\n    recursive?: commentsCreateNestedManyWithoutParentInput\n    votes?: votesCreateNestedManyWithoutCommentInput\n  }\n\n  export type commentsUncheckedCreateInput = {\n    id: string\n    user_id: string\n    post_id: string\n    parent_id?: string | null\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    recursive?: commentsUncheckedCreateNestedManyWithoutParentInput\n    votes?: votesUncheckedCreateNestedManyWithoutCommentInput\n  }\n\n  export type commentsUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    author?: usersUpdateOneRequiredWithoutCommentsNestedInput\n    post?: postsUpdateOneRequiredWithoutCommentsNestedInput\n    parent?: commentsUpdateOneWithoutRecursiveNestedInput\n    recursive?: commentsUpdateManyWithoutParentNestedInput\n    votes?: votesUpdateManyWithoutCommentNestedInput\n  }\n\n  export type commentsUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    user_id?: StringFieldUpdateOperationsInput | string\n    post_id?: StringFieldUpdateOperationsInput | string\n    parent_id?: NullableStringFieldUpdateOperationsInput | string | null\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    recursive?: commentsUncheckedUpdateManyWithoutParentNestedInput\n    votes?: votesUncheckedUpdateManyWithoutCommentNestedInput\n  }\n\n  export type commentsCreateManyInput = {\n    id: string\n    user_id: string\n    post_id: string\n    parent_id?: string | null\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type commentsUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type commentsUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    user_id?: StringFieldUpdateOperationsInput | string\n    post_id?: StringFieldUpdateOperationsInput | string\n    parent_id?: NullableStringFieldUpdateOperationsInput | string | null\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type votesCreateInput = {\n    id: string\n    value: number\n    created_at: Date | string\n    user: usersCreateNestedOneWithoutVotesInput\n    post?: postsCreateNestedOneWithoutVotesInput\n    comment?: commentsCreateNestedOneWithoutVotesInput\n  }\n\n  export type votesUncheckedCreateInput = {\n    id: string\n    user_id: string\n    post_id?: string | null\n    comment_id?: string | null\n    value: number\n    created_at: Date | string\n  }\n\n  export type votesUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    value?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    user?: usersUpdateOneRequiredWithoutVotesNestedInput\n    post?: postsUpdateOneWithoutVotesNestedInput\n    comment?: commentsUpdateOneWithoutVotesNestedInput\n  }\n\n  export type votesUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    user_id?: StringFieldUpdateOperationsInput | string\n    post_id?: NullableStringFieldUpdateOperationsInput | string | null\n    comment_id?: NullableStringFieldUpdateOperationsInput | string | null\n    value?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type votesCreateManyInput = {\n    id: string\n    user_id: string\n    post_id?: string | null\n    comment_id?: string | null\n    value: number\n    created_at: Date | string\n  }\n\n  export type votesUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    value?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type votesUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    user_id?: StringFieldUpdateOperationsInput | string\n    post_id?: NullableStringFieldUpdateOperationsInput | string | null\n    comment_id?: NullableStringFieldUpdateOperationsInput | string | null\n    value?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type UuidFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    mode?: QueryMode\n    not?: NestedUuidFilter<$PrismaModel> | string\n  }\n\n  export type StringFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    contains?: string | StringFieldRefInput<$PrismaModel>\n    startsWith?: string | StringFieldRefInput<$PrismaModel>\n    endsWith?: string | StringFieldRefInput<$PrismaModel>\n    mode?: QueryMode\n    not?: NestedStringFilter<$PrismaModel> | string\n  }\n\n  export type StringNullableFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel> | null\n    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    contains?: string | StringFieldRefInput<$PrismaModel>\n    startsWith?: string | StringFieldRefInput<$PrismaModel>\n    endsWith?: string | StringFieldRefInput<$PrismaModel>\n    mode?: QueryMode\n    not?: NestedStringNullableFilter<$PrismaModel> | string | null\n  }\n\n  export type DateTimeFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeFilter<$PrismaModel> | Date | string\n  }\n\n  export type User_rolesScalarRelationFilter = {\n    is?: user_rolesWhereInput\n    isNot?: user_rolesWhereInput\n  }\n\n  export type PostsListRelationFilter = {\n    every?: postsWhereInput\n    some?: postsWhereInput\n    none?: postsWhereInput\n  }\n\n  export type CommentsListRelationFilter = {\n    every?: commentsWhereInput\n    some?: commentsWhereInput\n    none?: commentsWhereInput\n  }\n\n  export type VotesListRelationFilter = {\n    every?: votesWhereInput\n    some?: votesWhereInput\n    none?: votesWhereInput\n  }\n\n  export type SortOrderInput = {\n    sort: SortOrder\n    nulls?: NullsOrder\n  }\n\n  export type postsOrderByRelationAggregateInput = {\n    _count?: SortOrder\n  }\n\n  export type commentsOrderByRelationAggregateInput = {\n    _count?: SortOrder\n  }\n\n  export type votesOrderByRelationAggregateInput = {\n    _count?: SortOrder\n  }\n\n  export type usersCountOrderByAggregateInput = {\n    id?: SortOrder\n    user_role_id?: SortOrder\n    username?: SortOrder\n    email?: SortOrder\n    bio?: SortOrder\n    password_hash?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    status?: SortOrder\n  }\n\n  export type usersMaxOrderByAggregateInput = {\n    id?: SortOrder\n    user_role_id?: SortOrder\n    username?: SortOrder\n    email?: SortOrder\n    bio?: SortOrder\n    password_hash?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    status?: SortOrder\n  }\n\n  export type usersMinOrderByAggregateInput = {\n    id?: SortOrder\n    user_role_id?: SortOrder\n    username?: SortOrder\n    email?: SortOrder\n    bio?: SortOrder\n    password_hash?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    status?: SortOrder\n  }\n\n  export type UuidWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    mode?: QueryMode\n    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string\n    _count?: NestedIntFilter<$PrismaModel>\n    _min?: NestedStringFilter<$PrismaModel>\n    _max?: NestedStringFilter<$PrismaModel>\n  }\n\n  export type StringWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    contains?: string | StringFieldRefInput<$PrismaModel>\n    startsWith?: string | StringFieldRefInput<$PrismaModel>\n    endsWith?: string | StringFieldRefInput<$PrismaModel>\n    mode?: QueryMode\n    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string\n    _count?: NestedIntFilter<$PrismaModel>\n    _min?: NestedStringFilter<$PrismaModel>\n    _max?: NestedStringFilter<$PrismaModel>\n  }\n\n  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel> | null\n    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    contains?: string | StringFieldRefInput<$PrismaModel>\n    startsWith?: string | StringFieldRefInput<$PrismaModel>\n    endsWith?: string | StringFieldRefInput<$PrismaModel>\n    mode?: QueryMode\n    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null\n    _count?: NestedIntNullableFilter<$PrismaModel>\n    _min?: NestedStringNullableFilter<$PrismaModel>\n    _max?: NestedStringNullableFilter<$PrismaModel>\n  }\n\n  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string\n    _count?: NestedIntFilter<$PrismaModel>\n    _min?: NestedDateTimeFilter<$PrismaModel>\n    _max?: NestedDateTimeFilter<$PrismaModel>\n  }\n\n  export type UsersListRelationFilter = {\n    every?: usersWhereInput\n    some?: usersWhereInput\n    none?: usersWhereInput\n  }\n\n  export type usersOrderByRelationAggregateInput = {\n    _count?: SortOrder\n  }\n\n  export type user_rolesCountOrderByAggregateInput = {\n    id?: SortOrder\n    name?: SortOrder\n    description?: SortOrder\n  }\n\n  export type user_rolesMaxOrderByAggregateInput = {\n    id?: SortOrder\n    name?: SortOrder\n    description?: SortOrder\n  }\n\n  export type user_rolesMinOrderByAggregateInput = {\n    id?: SortOrder\n    name?: SortOrder\n    description?: SortOrder\n  }\n\n  export type categoriesCountOrderByAggregateInput = {\n    id?: SortOrder\n    name?: SortOrder\n    description?: SortOrder\n    created_at?: SortOrder\n  }\n\n  export type categoriesMaxOrderByAggregateInput = {\n    id?: SortOrder\n    name?: SortOrder\n    description?: SortOrder\n    created_at?: SortOrder\n  }\n\n  export type categoriesMinOrderByAggregateInput = {\n    id?: SortOrder\n    name?: SortOrder\n    description?: SortOrder\n    created_at?: SortOrder\n  }\n\n  export type DateTimeNullableFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null\n  }\n\n  export type UsersScalarRelationFilter = {\n    is?: usersWhereInput\n    isNot?: usersWhereInput\n  }\n\n  export type CategoriesScalarRelationFilter = {\n    is?: categoriesWhereInput\n    isNot?: categoriesWhereInput\n  }\n\n  export type postsCountOrderByAggregateInput = {\n    id?: SortOrder\n    user_id?: SortOrder\n    category_id?: SortOrder\n    title?: SortOrder\n    content?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type postsMaxOrderByAggregateInput = {\n    id?: SortOrder\n    user_id?: SortOrder\n    category_id?: SortOrder\n    title?: SortOrder\n    content?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type postsMinOrderByAggregateInput = {\n    id?: SortOrder\n    user_id?: SortOrder\n    category_id?: SortOrder\n    title?: SortOrder\n    content?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null\n    _count?: NestedIntNullableFilter<$PrismaModel>\n    _min?: NestedDateTimeNullableFilter<$PrismaModel>\n    _max?: NestedDateTimeNullableFilter<$PrismaModel>\n  }\n\n  export type UuidNullableFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel> | null\n    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    mode?: QueryMode\n    not?: NestedUuidNullableFilter<$PrismaModel> | string | null\n  }\n\n  export type PostsScalarRelationFilter = {\n    is?: postsWhereInput\n    isNot?: postsWhereInput\n  }\n\n  export type CommentsNullableScalarRelationFilter = {\n    is?: commentsWhereInput | null\n    isNot?: commentsWhereInput | null\n  }\n\n  export type commentsCountOrderByAggregateInput = {\n    id?: SortOrder\n    user_id?: SortOrder\n    post_id?: SortOrder\n    parent_id?: SortOrder\n    content?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type commentsMaxOrderByAggregateInput = {\n    id?: SortOrder\n    user_id?: SortOrder\n    post_id?: SortOrder\n    parent_id?: SortOrder\n    content?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type commentsMinOrderByAggregateInput = {\n    id?: SortOrder\n    user_id?: SortOrder\n    post_id?: SortOrder\n    parent_id?: SortOrder\n    content?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type UuidNullableWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel> | null\n    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    mode?: QueryMode\n    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null\n    _count?: NestedIntNullableFilter<$PrismaModel>\n    _min?: NestedStringNullableFilter<$PrismaModel>\n    _max?: NestedStringNullableFilter<$PrismaModel>\n  }\n\n  export type IntFilter<$PrismaModel = never> = {\n    equals?: number | IntFieldRefInput<$PrismaModel>\n    in?: number[] | ListIntFieldRefInput<$PrismaModel>\n    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>\n    lt?: number | IntFieldRefInput<$PrismaModel>\n    lte?: number | IntFieldRefInput<$PrismaModel>\n    gt?: number | IntFieldRefInput<$PrismaModel>\n    gte?: number | IntFieldRefInput<$PrismaModel>\n    not?: NestedIntFilter<$PrismaModel> | number\n  }\n\n  export type PostsNullableScalarRelationFilter = {\n    is?: postsWhereInput | null\n    isNot?: postsWhereInput | null\n  }\n\n  export type votesUser_idPost_idCompoundUniqueInput = {\n    user_id: string\n    post_id: string\n  }\n\n  export type votesUser_idComment_idCompoundUniqueInput = {\n    user_id: string\n    comment_id: string\n  }\n\n  export type votesCountOrderByAggregateInput = {\n    id?: SortOrder\n    user_id?: SortOrder\n    post_id?: SortOrder\n    comment_id?: SortOrder\n    value?: SortOrder\n    created_at?: SortOrder\n  }\n\n  export type votesAvgOrderByAggregateInput = {\n    value?: SortOrder\n  }\n\n  export type votesMaxOrderByAggregateInput = {\n    id?: SortOrder\n    user_id?: SortOrder\n    post_id?: SortOrder\n    comment_id?: SortOrder\n    value?: SortOrder\n    created_at?: SortOrder\n  }\n\n  export type votesMinOrderByAggregateInput = {\n    id?: SortOrder\n    user_id?: SortOrder\n    post_id?: SortOrder\n    comment_id?: SortOrder\n    value?: SortOrder\n    created_at?: SortOrder\n  }\n\n  export type votesSumOrderByAggregateInput = {\n    value?: SortOrder\n  }\n\n  export type IntWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: number | IntFieldRefInput<$PrismaModel>\n    in?: number[] | ListIntFieldRefInput<$PrismaModel>\n    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>\n    lt?: number | IntFieldRefInput<$PrismaModel>\n    lte?: number | IntFieldRefInput<$PrismaModel>\n    gt?: number | IntFieldRefInput<$PrismaModel>\n    gte?: number | IntFieldRefInput<$PrismaModel>\n    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number\n    _count?: NestedIntFilter<$PrismaModel>\n    _avg?: NestedFloatFilter<$PrismaModel>\n    _sum?: NestedIntFilter<$PrismaModel>\n    _min?: NestedIntFilter<$PrismaModel>\n    _max?: NestedIntFilter<$PrismaModel>\n  }\n\n  export type user_rolesCreateNestedOneWithoutUsersInput = {\n    create?: XOR<user_rolesCreateWithoutUsersInput, user_rolesUncheckedCreateWithoutUsersInput>\n    connectOrCreate?: user_rolesCreateOrConnectWithoutUsersInput\n    connect?: user_rolesWhereUniqueInput\n  }\n\n  export type postsCreateNestedManyWithoutAuthorInput = {\n    create?: XOR<postsCreateWithoutAuthorInput, postsUncheckedCreateWithoutAuthorInput> | postsCreateWithoutAuthorInput[] | postsUncheckedCreateWithoutAuthorInput[]\n    connectOrCreate?: postsCreateOrConnectWithoutAuthorInput | postsCreateOrConnectWithoutAuthorInput[]\n    createMany?: postsCreateManyAuthorInputEnvelope\n    connect?: postsWhereUniqueInput | postsWhereUniqueInput[]\n  }\n\n  export type commentsCreateNestedManyWithoutAuthorInput = {\n    create?: XOR<commentsCreateWithoutAuthorInput, commentsUncheckedCreateWithoutAuthorInput> | commentsCreateWithoutAuthorInput[] | commentsUncheckedCreateWithoutAuthorInput[]\n    connectOrCreate?: commentsCreateOrConnectWithoutAuthorInput | commentsCreateOrConnectWithoutAuthorInput[]\n    createMany?: commentsCreateManyAuthorInputEnvelope\n    connect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]\n  }\n\n  export type votesCreateNestedManyWithoutUserInput = {\n    create?: XOR<votesCreateWithoutUserInput, votesUncheckedCreateWithoutUserInput> | votesCreateWithoutUserInput[] | votesUncheckedCreateWithoutUserInput[]\n    connectOrCreate?: votesCreateOrConnectWithoutUserInput | votesCreateOrConnectWithoutUserInput[]\n    createMany?: votesCreateManyUserInputEnvelope\n    connect?: votesWhereUniqueInput | votesWhereUniqueInput[]\n  }\n\n  export type postsUncheckedCreateNestedManyWithoutAuthorInput = {\n    create?: XOR<postsCreateWithoutAuthorInput, postsUncheckedCreateWithoutAuthorInput> | postsCreateWithoutAuthorInput[] | postsUncheckedCreateWithoutAuthorInput[]\n    connectOrCreate?: postsCreateOrConnectWithoutAuthorInput | postsCreateOrConnectWithoutAuthorInput[]\n    createMany?: postsCreateManyAuthorInputEnvelope\n    connect?: postsWhereUniqueInput | postsWhereUniqueInput[]\n  }\n\n  export type commentsUncheckedCreateNestedManyWithoutAuthorInput = {\n    create?: XOR<commentsCreateWithoutAuthorInput, commentsUncheckedCreateWithoutAuthorInput> | commentsCreateWithoutAuthorInput[] | commentsUncheckedCreateWithoutAuthorInput[]\n    connectOrCreate?: commentsCreateOrConnectWithoutAuthorInput | commentsCreateOrConnectWithoutAuthorInput[]\n    createMany?: commentsCreateManyAuthorInputEnvelope\n    connect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]\n  }\n\n  export type votesUncheckedCreateNestedManyWithoutUserInput = {\n    create?: XOR<votesCreateWithoutUserInput, votesUncheckedCreateWithoutUserInput> | votesCreateWithoutUserInput[] | votesUncheckedCreateWithoutUserInput[]\n    connectOrCreate?: votesCreateOrConnectWithoutUserInput | votesCreateOrConnectWithoutUserInput[]\n    createMany?: votesCreateManyUserInputEnvelope\n    connect?: votesWhereUniqueInput | votesWhereUniqueInput[]\n  }\n\n  export type StringFieldUpdateOperationsInput = {\n    set?: string\n  }\n\n  export type NullableStringFieldUpdateOperationsInput = {\n    set?: string | null\n  }\n\n  export type DateTimeFieldUpdateOperationsInput = {\n    set?: Date | string\n  }\n\n  export type user_rolesUpdateOneRequiredWithoutUsersNestedInput = {\n    create?: XOR<user_rolesCreateWithoutUsersInput, user_rolesUncheckedCreateWithoutUsersInput>\n    connectOrCreate?: user_rolesCreateOrConnectWithoutUsersInput\n    upsert?: user_rolesUpsertWithoutUsersInput\n    connect?: user_rolesWhereUniqueInput\n    update?: XOR<XOR<user_rolesUpdateToOneWithWhereWithoutUsersInput, user_rolesUpdateWithoutUsersInput>, user_rolesUncheckedUpdateWithoutUsersInput>\n  }\n\n  export type postsUpdateManyWithoutAuthorNestedInput = {\n    create?: XOR<postsCreateWithoutAuthorInput, postsUncheckedCreateWithoutAuthorInput> | postsCreateWithoutAuthorInput[] | postsUncheckedCreateWithoutAuthorInput[]\n    connectOrCreate?: postsCreateOrConnectWithoutAuthorInput | postsCreateOrConnectWithoutAuthorInput[]\n    upsert?: postsUpsertWithWhereUniqueWithoutAuthorInput | postsUpsertWithWhereUniqueWithoutAuthorInput[]\n    createMany?: postsCreateManyAuthorInputEnvelope\n    set?: postsWhereUniqueInput | postsWhereUniqueInput[]\n    disconnect?: postsWhereUniqueInput | postsWhereUniqueInput[]\n    delete?: postsWhereUniqueInput | postsWhereUniqueInput[]\n    connect?: postsWhereUniqueInput | postsWhereUniqueInput[]\n    update?: postsUpdateWithWhereUniqueWithoutAuthorInput | postsUpdateWithWhereUniqueWithoutAuthorInput[]\n    updateMany?: postsUpdateManyWithWhereWithoutAuthorInput | postsUpdateManyWithWhereWithoutAuthorInput[]\n    deleteMany?: postsScalarWhereInput | postsScalarWhereInput[]\n  }\n\n  export type commentsUpdateManyWithoutAuthorNestedInput = {\n    create?: XOR<commentsCreateWithoutAuthorInput, commentsUncheckedCreateWithoutAuthorInput> | commentsCreateWithoutAuthorInput[] | commentsUncheckedCreateWithoutAuthorInput[]\n    connectOrCreate?: commentsCreateOrConnectWithoutAuthorInput | commentsCreateOrConnectWithoutAuthorInput[]\n    upsert?: commentsUpsertWithWhereUniqueWithoutAuthorInput | commentsUpsertWithWhereUniqueWithoutAuthorInput[]\n    createMany?: commentsCreateManyAuthorInputEnvelope\n    set?: commentsWhereUniqueInput | commentsWhereUniqueInput[]\n    disconnect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]\n    delete?: commentsWhereUniqueInput | commentsWhereUniqueInput[]\n    connect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]\n    update?: commentsUpdateWithWhereUniqueWithoutAuthorInput | commentsUpdateWithWhereUniqueWithoutAuthorInput[]\n    updateMany?: commentsUpdateManyWithWhereWithoutAuthorInput | commentsUpdateManyWithWhereWithoutAuthorInput[]\n    deleteMany?: commentsScalarWhereInput | commentsScalarWhereInput[]\n  }\n\n  export type votesUpdateManyWithoutUserNestedInput = {\n    create?: XOR<votesCreateWithoutUserInput, votesUncheckedCreateWithoutUserInput> | votesCreateWithoutUserInput[] | votesUncheckedCreateWithoutUserInput[]\n    connectOrCreate?: votesCreateOrConnectWithoutUserInput | votesCreateOrConnectWithoutUserInput[]\n    upsert?: votesUpsertWithWhereUniqueWithoutUserInput | votesUpsertWithWhereUniqueWithoutUserInput[]\n    createMany?: votesCreateManyUserInputEnvelope\n    set?: votesWhereUniqueInput | votesWhereUniqueInput[]\n    disconnect?: votesWhereUniqueInput | votesWhereUniqueInput[]\n    delete?: votesWhereUniqueInput | votesWhereUniqueInput[]\n    connect?: votesWhereUniqueInput | votesWhereUniqueInput[]\n    update?: votesUpdateWithWhereUniqueWithoutUserInput | votesUpdateWithWhereUniqueWithoutUserInput[]\n    updateMany?: votesUpdateManyWithWhereWithoutUserInput | votesUpdateManyWithWhereWithoutUserInput[]\n    deleteMany?: votesScalarWhereInput | votesScalarWhereInput[]\n  }\n\n  export type postsUncheckedUpdateManyWithoutAuthorNestedInput = {\n    create?: XOR<postsCreateWithoutAuthorInput, postsUncheckedCreateWithoutAuthorInput> | postsCreateWithoutAuthorInput[] | postsUncheckedCreateWithoutAuthorInput[]\n    connectOrCreate?: postsCreateOrConnectWithoutAuthorInput | postsCreateOrConnectWithoutAuthorInput[]\n    upsert?: postsUpsertWithWhereUniqueWithoutAuthorInput | postsUpsertWithWhereUniqueWithoutAuthorInput[]\n    createMany?: postsCreateManyAuthorInputEnvelope\n    set?: postsWhereUniqueInput | postsWhereUniqueInput[]\n    disconnect?: postsWhereUniqueInput | postsWhereUniqueInput[]\n    delete?: postsWhereUniqueInput | postsWhereUniqueInput[]\n    connect?: postsWhereUniqueInput | postsWhereUniqueInput[]\n    update?: postsUpdateWithWhereUniqueWithoutAuthorInput | postsUpdateWithWhereUniqueWithoutAuthorInput[]\n    updateMany?: postsUpdateManyWithWhereWithoutAuthorInput | postsUpdateManyWithWhereWithoutAuthorInput[]\n    deleteMany?: postsScalarWhereInput | postsScalarWhereInput[]\n  }\n\n  export type commentsUncheckedUpdateManyWithoutAuthorNestedInput = {\n    create?: XOR<commentsCreateWithoutAuthorInput, commentsUncheckedCreateWithoutAuthorInput> | commentsCreateWithoutAuthorInput[] | commentsUncheckedCreateWithoutAuthorInput[]\n    connectOrCreate?: commentsCreateOrConnectWithoutAuthorInput | commentsCreateOrConnectWithoutAuthorInput[]\n    upsert?: commentsUpsertWithWhereUniqueWithoutAuthorInput | commentsUpsertWithWhereUniqueWithoutAuthorInput[]\n    createMany?: commentsCreateManyAuthorInputEnvelope\n    set?: commentsWhereUniqueInput | commentsWhereUniqueInput[]\n    disconnect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]\n    delete?: commentsWhereUniqueInput | commentsWhereUniqueInput[]\n    connect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]\n    update?: commentsUpdateWithWhereUniqueWithoutAuthorInput | commentsUpdateWithWhereUniqueWithoutAuthorInput[]\n    updateMany?: commentsUpdateManyWithWhereWithoutAuthorInput | commentsUpdateManyWithWhereWithoutAuthorInput[]\n    deleteMany?: commentsScalarWhereInput | commentsScalarWhereInput[]\n  }\n\n  export type votesUncheckedUpdateManyWithoutUserNestedInput = {\n    create?: XOR<votesCreateWithoutUserInput, votesUncheckedCreateWithoutUserInput> | votesCreateWithoutUserInput[] | votesUncheckedCreateWithoutUserInput[]\n    connectOrCreate?: votesCreateOrConnectWithoutUserInput | votesCreateOrConnectWithoutUserInput[]\n    upsert?: votesUpsertWithWhereUniqueWithoutUserInput | votesUpsertWithWhereUniqueWithoutUserInput[]\n    createMany?: votesCreateManyUserInputEnvelope\n    set?: votesWhereUniqueInput | votesWhereUniqueInput[]\n    disconnect?: votesWhereUniqueInput | votesWhereUniqueInput[]\n    delete?: votesWhereUniqueInput | votesWhereUniqueInput[]\n    connect?: votesWhereUniqueInput | votesWhereUniqueInput[]\n    update?: votesUpdateWithWhereUniqueWithoutUserInput | votesUpdateWithWhereUniqueWithoutUserInput[]\n    updateMany?: votesUpdateManyWithWhereWithoutUserInput | votesUpdateManyWithWhereWithoutUserInput[]\n    deleteMany?: votesScalarWhereInput | votesScalarWhereInput[]\n  }\n\n  export type usersCreateNestedManyWithoutRoleInput = {\n    create?: XOR<usersCreateWithoutRoleInput, usersUncheckedCreateWithoutRoleInput> | usersCreateWithoutRoleInput[] | usersUncheckedCreateWithoutRoleInput[]\n    connectOrCreate?: usersCreateOrConnectWithoutRoleInput | usersCreateOrConnectWithoutRoleInput[]\n    createMany?: usersCreateManyRoleInputEnvelope\n    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]\n  }\n\n  export type usersUncheckedCreateNestedManyWithoutRoleInput = {\n    create?: XOR<usersCreateWithoutRoleInput, usersUncheckedCreateWithoutRoleInput> | usersCreateWithoutRoleInput[] | usersUncheckedCreateWithoutRoleInput[]\n    connectOrCreate?: usersCreateOrConnectWithoutRoleInput | usersCreateOrConnectWithoutRoleInput[]\n    createMany?: usersCreateManyRoleInputEnvelope\n    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]\n  }\n\n  export type usersUpdateManyWithoutRoleNestedInput = {\n    create?: XOR<usersCreateWithoutRoleInput, usersUncheckedCreateWithoutRoleInput> | usersCreateWithoutRoleInput[] | usersUncheckedCreateWithoutRoleInput[]\n    connectOrCreate?: usersCreateOrConnectWithoutRoleInput | usersCreateOrConnectWithoutRoleInput[]\n    upsert?: usersUpsertWithWhereUniqueWithoutRoleInput | usersUpsertWithWhereUniqueWithoutRoleInput[]\n    createMany?: usersCreateManyRoleInputEnvelope\n    set?: usersWhereUniqueInput | usersWhereUniqueInput[]\n    disconnect?: usersWhereUniqueInput | usersWhereUniqueInput[]\n    delete?: usersWhereUniqueInput | usersWhereUniqueInput[]\n    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]\n    update?: usersUpdateWithWhereUniqueWithoutRoleInput | usersUpdateWithWhereUniqueWithoutRoleInput[]\n    updateMany?: usersUpdateManyWithWhereWithoutRoleInput | usersUpdateManyWithWhereWithoutRoleInput[]\n    deleteMany?: usersScalarWhereInput | usersScalarWhereInput[]\n  }\n\n  export type usersUncheckedUpdateManyWithoutRoleNestedInput = {\n    create?: XOR<usersCreateWithoutRoleInput, usersUncheckedCreateWithoutRoleInput> | usersCreateWithoutRoleInput[] | usersUncheckedCreateWithoutRoleInput[]\n    connectOrCreate?: usersCreateOrConnectWithoutRoleInput | usersCreateOrConnectWithoutRoleInput[]\n    upsert?: usersUpsertWithWhereUniqueWithoutRoleInput | usersUpsertWithWhereUniqueWithoutRoleInput[]\n    createMany?: usersCreateManyRoleInputEnvelope\n    set?: usersWhereUniqueInput | usersWhereUniqueInput[]\n    disconnect?: usersWhereUniqueInput | usersWhereUniqueInput[]\n    delete?: usersWhereUniqueInput | usersWhereUniqueInput[]\n    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]\n    update?: usersUpdateWithWhereUniqueWithoutRoleInput | usersUpdateWithWhereUniqueWithoutRoleInput[]\n    updateMany?: usersUpdateManyWithWhereWithoutRoleInput | usersUpdateManyWithWhereWithoutRoleInput[]\n    deleteMany?: usersScalarWhereInput | usersScalarWhereInput[]\n  }\n\n  export type postsCreateNestedManyWithoutCategoryInput = {\n    create?: XOR<postsCreateWithoutCategoryInput, postsUncheckedCreateWithoutCategoryInput> | postsCreateWithoutCategoryInput[] | postsUncheckedCreateWithoutCategoryInput[]\n    connectOrCreate?: postsCreateOrConnectWithoutCategoryInput | postsCreateOrConnectWithoutCategoryInput[]\n    createMany?: postsCreateManyCategoryInputEnvelope\n    connect?: postsWhereUniqueInput | postsWhereUniqueInput[]\n  }\n\n  export type postsUncheckedCreateNestedManyWithoutCategoryInput = {\n    create?: XOR<postsCreateWithoutCategoryInput, postsUncheckedCreateWithoutCategoryInput> | postsCreateWithoutCategoryInput[] | postsUncheckedCreateWithoutCategoryInput[]\n    connectOrCreate?: postsCreateOrConnectWithoutCategoryInput | postsCreateOrConnectWithoutCategoryInput[]\n    createMany?: postsCreateManyCategoryInputEnvelope\n    connect?: postsWhereUniqueInput | postsWhereUniqueInput[]\n  }\n\n  export type postsUpdateManyWithoutCategoryNestedInput = {\n    create?: XOR<postsCreateWithoutCategoryInput, postsUncheckedCreateWithoutCategoryInput> | postsCreateWithoutCategoryInput[] | postsUncheckedCreateWithoutCategoryInput[]\n    connectOrCreate?: postsCreateOrConnectWithoutCategoryInput | postsCreateOrConnectWithoutCategoryInput[]\n    upsert?: postsUpsertWithWhereUniqueWithoutCategoryInput | postsUpsertWithWhereUniqueWithoutCategoryInput[]\n    createMany?: postsCreateManyCategoryInputEnvelope\n    set?: postsWhereUniqueInput | postsWhereUniqueInput[]\n    disconnect?: postsWhereUniqueInput | postsWhereUniqueInput[]\n    delete?: postsWhereUniqueInput | postsWhereUniqueInput[]\n    connect?: postsWhereUniqueInput | postsWhereUniqueInput[]\n    update?: postsUpdateWithWhereUniqueWithoutCategoryInput | postsUpdateWithWhereUniqueWithoutCategoryInput[]\n    updateMany?: postsUpdateManyWithWhereWithoutCategoryInput | postsUpdateManyWithWhereWithoutCategoryInput[]\n    deleteMany?: postsScalarWhereInput | postsScalarWhereInput[]\n  }\n\n  export type postsUncheckedUpdateManyWithoutCategoryNestedInput = {\n    create?: XOR<postsCreateWithoutCategoryInput, postsUncheckedCreateWithoutCategoryInput> | postsCreateWithoutCategoryInput[] | postsUncheckedCreateWithoutCategoryInput[]\n    connectOrCreate?: postsCreateOrConnectWithoutCategoryInput | postsCreateOrConnectWithoutCategoryInput[]\n    upsert?: postsUpsertWithWhereUniqueWithoutCategoryInput | postsUpsertWithWhereUniqueWithoutCategoryInput[]\n    createMany?: postsCreateManyCategoryInputEnvelope\n    set?: postsWhereUniqueInput | postsWhereUniqueInput[]\n    disconnect?: postsWhereUniqueInput | postsWhereUniqueInput[]\n    delete?: postsWhereUniqueInput | postsWhereUniqueInput[]\n    connect?: postsWhereUniqueInput | postsWhereUniqueInput[]\n    update?: postsUpdateWithWhereUniqueWithoutCategoryInput | postsUpdateWithWhereUniqueWithoutCategoryInput[]\n    updateMany?: postsUpdateManyWithWhereWithoutCategoryInput | postsUpdateManyWithWhereWithoutCategoryInput[]\n    deleteMany?: postsScalarWhereInput | postsScalarWhereInput[]\n  }\n\n  export type usersCreateNestedOneWithoutPostsInput = {\n    create?: XOR<usersCreateWithoutPostsInput, usersUncheckedCreateWithoutPostsInput>\n    connectOrCreate?: usersCreateOrConnectWithoutPostsInput\n    connect?: usersWhereUniqueInput\n  }\n\n  export type categoriesCreateNestedOneWithoutPostsInput = {\n    create?: XOR<categoriesCreateWithoutPostsInput, categoriesUncheckedCreateWithoutPostsInput>\n    connectOrCreate?: categoriesCreateOrConnectWithoutPostsInput\n    connect?: categoriesWhereUniqueInput\n  }\n\n  export type commentsCreateNestedManyWithoutPostInput = {\n    create?: XOR<commentsCreateWithoutPostInput, commentsUncheckedCreateWithoutPostInput> | commentsCreateWithoutPostInput[] | commentsUncheckedCreateWithoutPostInput[]\n    connectOrCreate?: commentsCreateOrConnectWithoutPostInput | commentsCreateOrConnectWithoutPostInput[]\n    createMany?: commentsCreateManyPostInputEnvelope\n    connect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]\n  }\n\n  export type votesCreateNestedManyWithoutPostInput = {\n    create?: XOR<votesCreateWithoutPostInput, votesUncheckedCreateWithoutPostInput> | votesCreateWithoutPostInput[] | votesUncheckedCreateWithoutPostInput[]\n    connectOrCreate?: votesCreateOrConnectWithoutPostInput | votesCreateOrConnectWithoutPostInput[]\n    createMany?: votesCreateManyPostInputEnvelope\n    connect?: votesWhereUniqueInput | votesWhereUniqueInput[]\n  }\n\n  export type commentsUncheckedCreateNestedManyWithoutPostInput = {\n    create?: XOR<commentsCreateWithoutPostInput, commentsUncheckedCreateWithoutPostInput> | commentsCreateWithoutPostInput[] | commentsUncheckedCreateWithoutPostInput[]\n    connectOrCreate?: commentsCreateOrConnectWithoutPostInput | commentsCreateOrConnectWithoutPostInput[]\n    createMany?: commentsCreateManyPostInputEnvelope\n    connect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]\n  }\n\n  export type votesUncheckedCreateNestedManyWithoutPostInput = {\n    create?: XOR<votesCreateWithoutPostInput, votesUncheckedCreateWithoutPostInput> | votesCreateWithoutPostInput[] | votesUncheckedCreateWithoutPostInput[]\n    connectOrCreate?: votesCreateOrConnectWithoutPostInput | votesCreateOrConnectWithoutPostInput[]\n    createMany?: votesCreateManyPostInputEnvelope\n    connect?: votesWhereUniqueInput | votesWhereUniqueInput[]\n  }\n\n  export type NullableDateTimeFieldUpdateOperationsInput = {\n    set?: Date | string | null\n  }\n\n  export type usersUpdateOneRequiredWithoutPostsNestedInput = {\n    create?: XOR<usersCreateWithoutPostsInput, usersUncheckedCreateWithoutPostsInput>\n    connectOrCreate?: usersCreateOrConnectWithoutPostsInput\n    upsert?: usersUpsertWithoutPostsInput\n    connect?: usersWhereUniqueInput\n    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutPostsInput, usersUpdateWithoutPostsInput>, usersUncheckedUpdateWithoutPostsInput>\n  }\n\n  export type categoriesUpdateOneRequiredWithoutPostsNestedInput = {\n    create?: XOR<categoriesCreateWithoutPostsInput, categoriesUncheckedCreateWithoutPostsInput>\n    connectOrCreate?: categoriesCreateOrConnectWithoutPostsInput\n    upsert?: categoriesUpsertWithoutPostsInput\n    connect?: categoriesWhereUniqueInput\n    update?: XOR<XOR<categoriesUpdateToOneWithWhereWithoutPostsInput, categoriesUpdateWithoutPostsInput>, categoriesUncheckedUpdateWithoutPostsInput>\n  }\n\n  export type commentsUpdateManyWithoutPostNestedInput = {\n    create?: XOR<commentsCreateWithoutPostInput, commentsUncheckedCreateWithoutPostInput> | commentsCreateWithoutPostInput[] | commentsUncheckedCreateWithoutPostInput[]\n    connectOrCreate?: commentsCreateOrConnectWithoutPostInput | commentsCreateOrConnectWithoutPostInput[]\n    upsert?: commentsUpsertWithWhereUniqueWithoutPostInput | commentsUpsertWithWhereUniqueWithoutPostInput[]\n    createMany?: commentsCreateManyPostInputEnvelope\n    set?: commentsWhereUniqueInput | commentsWhereUniqueInput[]\n    disconnect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]\n    delete?: commentsWhereUniqueInput | commentsWhereUniqueInput[]\n    connect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]\n    update?: commentsUpdateWithWhereUniqueWithoutPostInput | commentsUpdateWithWhereUniqueWithoutPostInput[]\n    updateMany?: commentsUpdateManyWithWhereWithoutPostInput | commentsUpdateManyWithWhereWithoutPostInput[]\n    deleteMany?: commentsScalarWhereInput | commentsScalarWhereInput[]\n  }\n\n  export type votesUpdateManyWithoutPostNestedInput = {\n    create?: XOR<votesCreateWithoutPostInput, votesUncheckedCreateWithoutPostInput> | votesCreateWithoutPostInput[] | votesUncheckedCreateWithoutPostInput[]\n    connectOrCreate?: votesCreateOrConnectWithoutPostInput | votesCreateOrConnectWithoutPostInput[]\n    upsert?: votesUpsertWithWhereUniqueWithoutPostInput | votesUpsertWithWhereUniqueWithoutPostInput[]\n    createMany?: votesCreateManyPostInputEnvelope\n    set?: votesWhereUniqueInput | votesWhereUniqueInput[]\n    disconnect?: votesWhereUniqueInput | votesWhereUniqueInput[]\n    delete?: votesWhereUniqueInput | votesWhereUniqueInput[]\n    connect?: votesWhereUniqueInput | votesWhereUniqueInput[]\n    update?: votesUpdateWithWhereUniqueWithoutPostInput | votesUpdateWithWhereUniqueWithoutPostInput[]\n    updateMany?: votesUpdateManyWithWhereWithoutPostInput | votesUpdateManyWithWhereWithoutPostInput[]\n    deleteMany?: votesScalarWhereInput | votesScalarWhereInput[]\n  }\n\n  export type commentsUncheckedUpdateManyWithoutPostNestedInput = {\n    create?: XOR<commentsCreateWithoutPostInput, commentsUncheckedCreateWithoutPostInput> | commentsCreateWithoutPostInput[] | commentsUncheckedCreateWithoutPostInput[]\n    connectOrCreate?: commentsCreateOrConnectWithoutPostInput | commentsCreateOrConnectWithoutPostInput[]\n    upsert?: commentsUpsertWithWhereUniqueWithoutPostInput | commentsUpsertWithWhereUniqueWithoutPostInput[]\n    createMany?: commentsCreateManyPostInputEnvelope\n    set?: commentsWhereUniqueInput | commentsWhereUniqueInput[]\n    disconnect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]\n    delete?: commentsWhereUniqueInput | commentsWhereUniqueInput[]\n    connect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]\n    update?: commentsUpdateWithWhereUniqueWithoutPostInput | commentsUpdateWithWhereUniqueWithoutPostInput[]\n    updateMany?: commentsUpdateManyWithWhereWithoutPostInput | commentsUpdateManyWithWhereWithoutPostInput[]\n    deleteMany?: commentsScalarWhereInput | commentsScalarWhereInput[]\n  }\n\n  export type votesUncheckedUpdateManyWithoutPostNestedInput = {\n    create?: XOR<votesCreateWithoutPostInput, votesUncheckedCreateWithoutPostInput> | votesCreateWithoutPostInput[] | votesUncheckedCreateWithoutPostInput[]\n    connectOrCreate?: votesCreateOrConnectWithoutPostInput | votesCreateOrConnectWithoutPostInput[]\n    upsert?: votesUpsertWithWhereUniqueWithoutPostInput | votesUpsertWithWhereUniqueWithoutPostInput[]\n    createMany?: votesCreateManyPostInputEnvelope\n    set?: votesWhereUniqueInput | votesWhereUniqueInput[]\n    disconnect?: votesWhereUniqueInput | votesWhereUniqueInput[]\n    delete?: votesWhereUniqueInput | votesWhereUniqueInput[]\n    connect?: votesWhereUniqueInput | votesWhereUniqueInput[]\n    update?: votesUpdateWithWhereUniqueWithoutPostInput | votesUpdateWithWhereUniqueWithoutPostInput[]\n    updateMany?: votesUpdateManyWithWhereWithoutPostInput | votesUpdateManyWithWhereWithoutPostInput[]\n    deleteMany?: votesScalarWhereInput | votesScalarWhereInput[]\n  }\n\n  export type usersCreateNestedOneWithoutCommentsInput = {\n    create?: XOR<usersCreateWithoutCommentsInput, usersUncheckedCreateWithoutCommentsInput>\n    connectOrCreate?: usersCreateOrConnectWithoutCommentsInput\n    connect?: usersWhereUniqueInput\n  }\n\n  export type postsCreateNestedOneWithoutCommentsInput = {\n    create?: XOR<postsCreateWithoutCommentsInput, postsUncheckedCreateWithoutCommentsInput>\n    connectOrCreate?: postsCreateOrConnectWithoutCommentsInput\n    connect?: postsWhereUniqueInput\n  }\n\n  export type commentsCreateNestedOneWithoutRecursiveInput = {\n    create?: XOR<commentsCreateWithoutRecursiveInput, commentsUncheckedCreateWithoutRecursiveInput>\n    connectOrCreate?: commentsCreateOrConnectWithoutRecursiveInput\n    connect?: commentsWhereUniqueInput\n  }\n\n  export type commentsCreateNestedManyWithoutParentInput = {\n    create?: XOR<commentsCreateWithoutParentInput, commentsUncheckedCreateWithoutParentInput> | commentsCreateWithoutParentInput[] | commentsUncheckedCreateWithoutParentInput[]\n    connectOrCreate?: commentsCreateOrConnectWithoutParentInput | commentsCreateOrConnectWithoutParentInput[]\n    createMany?: commentsCreateManyParentInputEnvelope\n    connect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]\n  }\n\n  export type votesCreateNestedManyWithoutCommentInput = {\n    create?: XOR<votesCreateWithoutCommentInput, votesUncheckedCreateWithoutCommentInput> | votesCreateWithoutCommentInput[] | votesUncheckedCreateWithoutCommentInput[]\n    connectOrCreate?: votesCreateOrConnectWithoutCommentInput | votesCreateOrConnectWithoutCommentInput[]\n    createMany?: votesCreateManyCommentInputEnvelope\n    connect?: votesWhereUniqueInput | votesWhereUniqueInput[]\n  }\n\n  export type commentsUncheckedCreateNestedManyWithoutParentInput = {\n    create?: XOR<commentsCreateWithoutParentInput, commentsUncheckedCreateWithoutParentInput> | commentsCreateWithoutParentInput[] | commentsUncheckedCreateWithoutParentInput[]\n    connectOrCreate?: commentsCreateOrConnectWithoutParentInput | commentsCreateOrConnectWithoutParentInput[]\n    createMany?: commentsCreateManyParentInputEnvelope\n    connect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]\n  }\n\n  export type votesUncheckedCreateNestedManyWithoutCommentInput = {\n    create?: XOR<votesCreateWithoutCommentInput, votesUncheckedCreateWithoutCommentInput> | votesCreateWithoutCommentInput[] | votesUncheckedCreateWithoutCommentInput[]\n    connectOrCreate?: votesCreateOrConnectWithoutCommentInput | votesCreateOrConnectWithoutCommentInput[]\n    createMany?: votesCreateManyCommentInputEnvelope\n    connect?: votesWhereUniqueInput | votesWhereUniqueInput[]\n  }\n\n  export type usersUpdateOneRequiredWithoutCommentsNestedInput = {\n    create?: XOR<usersCreateWithoutCommentsInput, usersUncheckedCreateWithoutCommentsInput>\n    connectOrCreate?: usersCreateOrConnectWithoutCommentsInput\n    upsert?: usersUpsertWithoutCommentsInput\n    connect?: usersWhereUniqueInput\n    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutCommentsInput, usersUpdateWithoutCommentsInput>, usersUncheckedUpdateWithoutCommentsInput>\n  }\n\n  export type postsUpdateOneRequiredWithoutCommentsNestedInput = {\n    create?: XOR<postsCreateWithoutCommentsInput, postsUncheckedCreateWithoutCommentsInput>\n    connectOrCreate?: postsCreateOrConnectWithoutCommentsInput\n    upsert?: postsUpsertWithoutCommentsInput\n    connect?: postsWhereUniqueInput\n    update?: XOR<XOR<postsUpdateToOneWithWhereWithoutCommentsInput, postsUpdateWithoutCommentsInput>, postsUncheckedUpdateWithoutCommentsInput>\n  }\n\n  export type commentsUpdateOneWithoutRecursiveNestedInput = {\n    create?: XOR<commentsCreateWithoutRecursiveInput, commentsUncheckedCreateWithoutRecursiveInput>\n    connectOrCreate?: commentsCreateOrConnectWithoutRecursiveInput\n    upsert?: commentsUpsertWithoutRecursiveInput\n    disconnect?: commentsWhereInput | boolean\n    delete?: commentsWhereInput | boolean\n    connect?: commentsWhereUniqueInput\n    update?: XOR<XOR<commentsUpdateToOneWithWhereWithoutRecursiveInput, commentsUpdateWithoutRecursiveInput>, commentsUncheckedUpdateWithoutRecursiveInput>\n  }\n\n  export type commentsUpdateManyWithoutParentNestedInput = {\n    create?: XOR<commentsCreateWithoutParentInput, commentsUncheckedCreateWithoutParentInput> | commentsCreateWithoutParentInput[] | commentsUncheckedCreateWithoutParentInput[]\n    connectOrCreate?: commentsCreateOrConnectWithoutParentInput | commentsCreateOrConnectWithoutParentInput[]\n    upsert?: commentsUpsertWithWhereUniqueWithoutParentInput | commentsUpsertWithWhereUniqueWithoutParentInput[]\n    createMany?: commentsCreateManyParentInputEnvelope\n    set?: commentsWhereUniqueInput | commentsWhereUniqueInput[]\n    disconnect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]\n    delete?: commentsWhereUniqueInput | commentsWhereUniqueInput[]\n    connect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]\n    update?: commentsUpdateWithWhereUniqueWithoutParentInput | commentsUpdateWithWhereUniqueWithoutParentInput[]\n    updateMany?: commentsUpdateManyWithWhereWithoutParentInput | commentsUpdateManyWithWhereWithoutParentInput[]\n    deleteMany?: commentsScalarWhereInput | commentsScalarWhereInput[]\n  }\n\n  export type votesUpdateManyWithoutCommentNestedInput = {\n    create?: XOR<votesCreateWithoutCommentInput, votesUncheckedCreateWithoutCommentInput> | votesCreateWithoutCommentInput[] | votesUncheckedCreateWithoutCommentInput[]\n    connectOrCreate?: votesCreateOrConnectWithoutCommentInput | votesCreateOrConnectWithoutCommentInput[]\n    upsert?: votesUpsertWithWhereUniqueWithoutCommentInput | votesUpsertWithWhereUniqueWithoutCommentInput[]\n    createMany?: votesCreateManyCommentInputEnvelope\n    set?: votesWhereUniqueInput | votesWhereUniqueInput[]\n    disconnect?: votesWhereUniqueInput | votesWhereUniqueInput[]\n    delete?: votesWhereUniqueInput | votesWhereUniqueInput[]\n    connect?: votesWhereUniqueInput | votesWhereUniqueInput[]\n    update?: votesUpdateWithWhereUniqueWithoutCommentInput | votesUpdateWithWhereUniqueWithoutCommentInput[]\n    updateMany?: votesUpdateManyWithWhereWithoutCommentInput | votesUpdateManyWithWhereWithoutCommentInput[]\n    deleteMany?: votesScalarWhereInput | votesScalarWhereInput[]\n  }\n\n  export type commentsUncheckedUpdateManyWithoutParentNestedInput = {\n    create?: XOR<commentsCreateWithoutParentInput, commentsUncheckedCreateWithoutParentInput> | commentsCreateWithoutParentInput[] | commentsUncheckedCreateWithoutParentInput[]\n    connectOrCreate?: commentsCreateOrConnectWithoutParentInput | commentsCreateOrConnectWithoutParentInput[]\n    upsert?: commentsUpsertWithWhereUniqueWithoutParentInput | commentsUpsertWithWhereUniqueWithoutParentInput[]\n    createMany?: commentsCreateManyParentInputEnvelope\n    set?: commentsWhereUniqueInput | commentsWhereUniqueInput[]\n    disconnect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]\n    delete?: commentsWhereUniqueInput | commentsWhereUniqueInput[]\n    connect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]\n    update?: commentsUpdateWithWhereUniqueWithoutParentInput | commentsUpdateWithWhereUniqueWithoutParentInput[]\n    updateMany?: commentsUpdateManyWithWhereWithoutParentInput | commentsUpdateManyWithWhereWithoutParentInput[]\n    deleteMany?: commentsScalarWhereInput | commentsScalarWhereInput[]\n  }\n\n  export type votesUncheckedUpdateManyWithoutCommentNestedInput = {\n    create?: XOR<votesCreateWithoutCommentInput, votesUncheckedCreateWithoutCommentInput> | votesCreateWithoutCommentInput[] | votesUncheckedCreateWithoutCommentInput[]\n    connectOrCreate?: votesCreateOrConnectWithoutCommentInput | votesCreateOrConnectWithoutCommentInput[]\n    upsert?: votesUpsertWithWhereUniqueWithoutCommentInput | votesUpsertWithWhereUniqueWithoutCommentInput[]\n    createMany?: votesCreateManyCommentInputEnvelope\n    set?: votesWhereUniqueInput | votesWhereUniqueInput[]\n    disconnect?: votesWhereUniqueInput | votesWhereUniqueInput[]\n    delete?: votesWhereUniqueInput | votesWhereUniqueInput[]\n    connect?: votesWhereUniqueInput | votesWhereUniqueInput[]\n    update?: votesUpdateWithWhereUniqueWithoutCommentInput | votesUpdateWithWhereUniqueWithoutCommentInput[]\n    updateMany?: votesUpdateManyWithWhereWithoutCommentInput | votesUpdateManyWithWhereWithoutCommentInput[]\n    deleteMany?: votesScalarWhereInput | votesScalarWhereInput[]\n  }\n\n  export type usersCreateNestedOneWithoutVotesInput = {\n    create?: XOR<usersCreateWithoutVotesInput, usersUncheckedCreateWithoutVotesInput>\n    connectOrCreate?: usersCreateOrConnectWithoutVotesInput\n    connect?: usersWhereUniqueInput\n  }\n\n  export type postsCreateNestedOneWithoutVotesInput = {\n    create?: XOR<postsCreateWithoutVotesInput, postsUncheckedCreateWithoutVotesInput>\n    connectOrCreate?: postsCreateOrConnectWithoutVotesInput\n    connect?: postsWhereUniqueInput\n  }\n\n  export type commentsCreateNestedOneWithoutVotesInput = {\n    create?: XOR<commentsCreateWithoutVotesInput, commentsUncheckedCreateWithoutVotesInput>\n    connectOrCreate?: commentsCreateOrConnectWithoutVotesInput\n    connect?: commentsWhereUniqueInput\n  }\n\n  export type IntFieldUpdateOperationsInput = {\n    set?: number\n    increment?: number\n    decrement?: number\n    multiply?: number\n    divide?: number\n  }\n\n  export type usersUpdateOneRequiredWithoutVotesNestedInput = {\n    create?: XOR<usersCreateWithoutVotesInput, usersUncheckedCreateWithoutVotesInput>\n    connectOrCreate?: usersCreateOrConnectWithoutVotesInput\n    upsert?: usersUpsertWithoutVotesInput\n    connect?: usersWhereUniqueInput\n    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutVotesInput, usersUpdateWithoutVotesInput>, usersUncheckedUpdateWithoutVotesInput>\n  }\n\n  export type postsUpdateOneWithoutVotesNestedInput = {\n    create?: XOR<postsCreateWithoutVotesInput, postsUncheckedCreateWithoutVotesInput>\n    connectOrCreate?: postsCreateOrConnectWithoutVotesInput\n    upsert?: postsUpsertWithoutVotesInput\n    disconnect?: postsWhereInput | boolean\n    delete?: postsWhereInput | boolean\n    connect?: postsWhereUniqueInput\n    update?: XOR<XOR<postsUpdateToOneWithWhereWithoutVotesInput, postsUpdateWithoutVotesInput>, postsUncheckedUpdateWithoutVotesInput>\n  }\n\n  export type commentsUpdateOneWithoutVotesNestedInput = {\n    create?: XOR<commentsCreateWithoutVotesInput, commentsUncheckedCreateWithoutVotesInput>\n    connectOrCreate?: commentsCreateOrConnectWithoutVotesInput\n    upsert?: commentsUpsertWithoutVotesInput\n    disconnect?: commentsWhereInput | boolean\n    delete?: commentsWhereInput | boolean\n    connect?: commentsWhereUniqueInput\n    update?: XOR<XOR<commentsUpdateToOneWithWhereWithoutVotesInput, commentsUpdateWithoutVotesInput>, commentsUncheckedUpdateWithoutVotesInput>\n  }\n\n  export type NestedUuidFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    not?: NestedUuidFilter<$PrismaModel> | string\n  }\n\n  export type NestedStringFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    contains?: string | StringFieldRefInput<$PrismaModel>\n    startsWith?: string | StringFieldRefInput<$PrismaModel>\n    endsWith?: string | StringFieldRefInput<$PrismaModel>\n    not?: NestedStringFilter<$PrismaModel> | string\n  }\n\n  export type NestedStringNullableFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel> | null\n    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    contains?: string | StringFieldRefInput<$PrismaModel>\n    startsWith?: string | StringFieldRefInput<$PrismaModel>\n    endsWith?: string | StringFieldRefInput<$PrismaModel>\n    not?: NestedStringNullableFilter<$PrismaModel> | string | null\n  }\n\n  export type NestedDateTimeFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeFilter<$PrismaModel> | Date | string\n  }\n\n  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string\n    _count?: NestedIntFilter<$PrismaModel>\n    _min?: NestedStringFilter<$PrismaModel>\n    _max?: NestedStringFilter<$PrismaModel>\n  }\n\n  export type NestedIntFilter<$PrismaModel = never> = {\n    equals?: number | IntFieldRefInput<$PrismaModel>\n    in?: number[] | ListIntFieldRefInput<$PrismaModel>\n    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>\n    lt?: number | IntFieldRefInput<$PrismaModel>\n    lte?: number | IntFieldRefInput<$PrismaModel>\n    gt?: number | IntFieldRefInput<$PrismaModel>\n    gte?: number | IntFieldRefInput<$PrismaModel>\n    not?: NestedIntFilter<$PrismaModel> | number\n  }\n\n  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    contains?: string | StringFieldRefInput<$PrismaModel>\n    startsWith?: string | StringFieldRefInput<$PrismaModel>\n    endsWith?: string | StringFieldRefInput<$PrismaModel>\n    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string\n    _count?: NestedIntFilter<$PrismaModel>\n    _min?: NestedStringFilter<$PrismaModel>\n    _max?: NestedStringFilter<$PrismaModel>\n  }\n\n  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel> | null\n    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    contains?: string | StringFieldRefInput<$PrismaModel>\n    startsWith?: string | StringFieldRefInput<$PrismaModel>\n    endsWith?: string | StringFieldRefInput<$PrismaModel>\n    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null\n    _count?: NestedIntNullableFilter<$PrismaModel>\n    _min?: NestedStringNullableFilter<$PrismaModel>\n    _max?: NestedStringNullableFilter<$PrismaModel>\n  }\n\n  export type NestedIntNullableFilter<$PrismaModel = never> = {\n    equals?: number | IntFieldRefInput<$PrismaModel> | null\n    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null\n    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null\n    lt?: number | IntFieldRefInput<$PrismaModel>\n    lte?: number | IntFieldRefInput<$PrismaModel>\n    gt?: number | IntFieldRefInput<$PrismaModel>\n    gte?: number | IntFieldRefInput<$PrismaModel>\n    not?: NestedIntNullableFilter<$PrismaModel> | number | null\n  }\n\n  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string\n    _count?: NestedIntFilter<$PrismaModel>\n    _min?: NestedDateTimeFilter<$PrismaModel>\n    _max?: NestedDateTimeFilter<$PrismaModel>\n  }\n\n  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null\n  }\n\n  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null\n    _count?: NestedIntNullableFilter<$PrismaModel>\n    _min?: NestedDateTimeNullableFilter<$PrismaModel>\n    _max?: NestedDateTimeNullableFilter<$PrismaModel>\n  }\n\n  export type NestedUuidNullableFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel> | null\n    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    not?: NestedUuidNullableFilter<$PrismaModel> | string | null\n  }\n\n  export type NestedUuidNullableWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel> | null\n    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null\n    _count?: NestedIntNullableFilter<$PrismaModel>\n    _min?: NestedStringNullableFilter<$PrismaModel>\n    _max?: NestedStringNullableFilter<$PrismaModel>\n  }\n\n  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: number | IntFieldRefInput<$PrismaModel>\n    in?: number[] | ListIntFieldRefInput<$PrismaModel>\n    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>\n    lt?: number | IntFieldRefInput<$PrismaModel>\n    lte?: number | IntFieldRefInput<$PrismaModel>\n    gt?: number | IntFieldRefInput<$PrismaModel>\n    gte?: number | IntFieldRefInput<$PrismaModel>\n    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number\n    _count?: NestedIntFilter<$PrismaModel>\n    _avg?: NestedFloatFilter<$PrismaModel>\n    _sum?: NestedIntFilter<$PrismaModel>\n    _min?: NestedIntFilter<$PrismaModel>\n    _max?: NestedIntFilter<$PrismaModel>\n  }\n\n  export type NestedFloatFilter<$PrismaModel = never> = {\n    equals?: number | FloatFieldRefInput<$PrismaModel>\n    in?: number[] | ListFloatFieldRefInput<$PrismaModel>\n    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>\n    lt?: number | FloatFieldRefInput<$PrismaModel>\n    lte?: number | FloatFieldRefInput<$PrismaModel>\n    gt?: number | FloatFieldRefInput<$PrismaModel>\n    gte?: number | FloatFieldRefInput<$PrismaModel>\n    not?: NestedFloatFilter<$PrismaModel> | number\n  }\n\n  export type user_rolesCreateWithoutUsersInput = {\n    id: string\n    name: string\n    description: string\n  }\n\n  export type user_rolesUncheckedCreateWithoutUsersInput = {\n    id: string\n    name: string\n    description: string\n  }\n\n  export type user_rolesCreateOrConnectWithoutUsersInput = {\n    where: user_rolesWhereUniqueInput\n    create: XOR<user_rolesCreateWithoutUsersInput, user_rolesUncheckedCreateWithoutUsersInput>\n  }\n\n  export type postsCreateWithoutAuthorInput = {\n    id: string\n    title: string\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    category: categoriesCreateNestedOneWithoutPostsInput\n    comments?: commentsCreateNestedManyWithoutPostInput\n    votes?: votesCreateNestedManyWithoutPostInput\n  }\n\n  export type postsUncheckedCreateWithoutAuthorInput = {\n    id: string\n    category_id: string\n    title: string\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    comments?: commentsUncheckedCreateNestedManyWithoutPostInput\n    votes?: votesUncheckedCreateNestedManyWithoutPostInput\n  }\n\n  export type postsCreateOrConnectWithoutAuthorInput = {\n    where: postsWhereUniqueInput\n    create: XOR<postsCreateWithoutAuthorInput, postsUncheckedCreateWithoutAuthorInput>\n  }\n\n  export type postsCreateManyAuthorInputEnvelope = {\n    data: postsCreateManyAuthorInput | postsCreateManyAuthorInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type commentsCreateWithoutAuthorInput = {\n    id: string\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    post: postsCreateNestedOneWithoutCommentsInput\n    parent?: commentsCreateNestedOneWithoutRecursiveInput\n    recursive?: commentsCreateNestedManyWithoutParentInput\n    votes?: votesCreateNestedManyWithoutCommentInput\n  }\n\n  export type commentsUncheckedCreateWithoutAuthorInput = {\n    id: string\n    post_id: string\n    parent_id?: string | null\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    recursive?: commentsUncheckedCreateNestedManyWithoutParentInput\n    votes?: votesUncheckedCreateNestedManyWithoutCommentInput\n  }\n\n  export type commentsCreateOrConnectWithoutAuthorInput = {\n    where: commentsWhereUniqueInput\n    create: XOR<commentsCreateWithoutAuthorInput, commentsUncheckedCreateWithoutAuthorInput>\n  }\n\n  export type commentsCreateManyAuthorInputEnvelope = {\n    data: commentsCreateManyAuthorInput | commentsCreateManyAuthorInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type votesCreateWithoutUserInput = {\n    id: string\n    value: number\n    created_at: Date | string\n    post?: postsCreateNestedOneWithoutVotesInput\n    comment?: commentsCreateNestedOneWithoutVotesInput\n  }\n\n  export type votesUncheckedCreateWithoutUserInput = {\n    id: string\n    post_id?: string | null\n    comment_id?: string | null\n    value: number\n    created_at: Date | string\n  }\n\n  export type votesCreateOrConnectWithoutUserInput = {\n    where: votesWhereUniqueInput\n    create: XOR<votesCreateWithoutUserInput, votesUncheckedCreateWithoutUserInput>\n  }\n\n  export type votesCreateManyUserInputEnvelope = {\n    data: votesCreateManyUserInput | votesCreateManyUserInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type user_rolesUpsertWithoutUsersInput = {\n    update: XOR<user_rolesUpdateWithoutUsersInput, user_rolesUncheckedUpdateWithoutUsersInput>\n    create: XOR<user_rolesCreateWithoutUsersInput, user_rolesUncheckedCreateWithoutUsersInput>\n    where?: user_rolesWhereInput\n  }\n\n  export type user_rolesUpdateToOneWithWhereWithoutUsersInput = {\n    where?: user_rolesWhereInput\n    data: XOR<user_rolesUpdateWithoutUsersInput, user_rolesUncheckedUpdateWithoutUsersInput>\n  }\n\n  export type user_rolesUpdateWithoutUsersInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: StringFieldUpdateOperationsInput | string\n  }\n\n  export type user_rolesUncheckedUpdateWithoutUsersInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: StringFieldUpdateOperationsInput | string\n  }\n\n  export type postsUpsertWithWhereUniqueWithoutAuthorInput = {\n    where: postsWhereUniqueInput\n    update: XOR<postsUpdateWithoutAuthorInput, postsUncheckedUpdateWithoutAuthorInput>\n    create: XOR<postsCreateWithoutAuthorInput, postsUncheckedCreateWithoutAuthorInput>\n  }\n\n  export type postsUpdateWithWhereUniqueWithoutAuthorInput = {\n    where: postsWhereUniqueInput\n    data: XOR<postsUpdateWithoutAuthorInput, postsUncheckedUpdateWithoutAuthorInput>\n  }\n\n  export type postsUpdateManyWithWhereWithoutAuthorInput = {\n    where: postsScalarWhereInput\n    data: XOR<postsUpdateManyMutationInput, postsUncheckedUpdateManyWithoutAuthorInput>\n  }\n\n  export type postsScalarWhereInput = {\n    AND?: postsScalarWhereInput | postsScalarWhereInput[]\n    OR?: postsScalarWhereInput[]\n    NOT?: postsScalarWhereInput | postsScalarWhereInput[]\n    id?: UuidFilter<\"posts\"> | string\n    user_id?: UuidFilter<\"posts\"> | string\n    category_id?: UuidFilter<\"posts\"> | string\n    title?: StringFilter<\"posts\"> | string\n    content?: StringFilter<\"posts\"> | string\n    created_at?: DateTimeFilter<\"posts\"> | Date | string\n    updated_at?: DateTimeFilter<\"posts\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"posts\"> | Date | string | null\n  }\n\n  export type commentsUpsertWithWhereUniqueWithoutAuthorInput = {\n    where: commentsWhereUniqueInput\n    update: XOR<commentsUpdateWithoutAuthorInput, commentsUncheckedUpdateWithoutAuthorInput>\n    create: XOR<commentsCreateWithoutAuthorInput, commentsUncheckedCreateWithoutAuthorInput>\n  }\n\n  export type commentsUpdateWithWhereUniqueWithoutAuthorInput = {\n    where: commentsWhereUniqueInput\n    data: XOR<commentsUpdateWithoutAuthorInput, commentsUncheckedUpdateWithoutAuthorInput>\n  }\n\n  export type commentsUpdateManyWithWhereWithoutAuthorInput = {\n    where: commentsScalarWhereInput\n    data: XOR<commentsUpdateManyMutationInput, commentsUncheckedUpdateManyWithoutAuthorInput>\n  }\n\n  export type commentsScalarWhereInput = {\n    AND?: commentsScalarWhereInput | commentsScalarWhereInput[]\n    OR?: commentsScalarWhereInput[]\n    NOT?: commentsScalarWhereInput | commentsScalarWhereInput[]\n    id?: UuidFilter<\"comments\"> | string\n    user_id?: UuidFilter<\"comments\"> | string\n    post_id?: UuidFilter<\"comments\"> | string\n    parent_id?: UuidNullableFilter<\"comments\"> | string | null\n    content?: StringFilter<\"comments\"> | string\n    created_at?: DateTimeFilter<\"comments\"> | Date | string\n    updated_at?: DateTimeFilter<\"comments\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"comments\"> | Date | string | null\n  }\n\n  export type votesUpsertWithWhereUniqueWithoutUserInput = {\n    where: votesWhereUniqueInput\n    update: XOR<votesUpdateWithoutUserInput, votesUncheckedUpdateWithoutUserInput>\n    create: XOR<votesCreateWithoutUserInput, votesUncheckedCreateWithoutUserInput>\n  }\n\n  export type votesUpdateWithWhereUniqueWithoutUserInput = {\n    where: votesWhereUniqueInput\n    data: XOR<votesUpdateWithoutUserInput, votesUncheckedUpdateWithoutUserInput>\n  }\n\n  export type votesUpdateManyWithWhereWithoutUserInput = {\n    where: votesScalarWhereInput\n    data: XOR<votesUpdateManyMutationInput, votesUncheckedUpdateManyWithoutUserInput>\n  }\n\n  export type votesScalarWhereInput = {\n    AND?: votesScalarWhereInput | votesScalarWhereInput[]\n    OR?: votesScalarWhereInput[]\n    NOT?: votesScalarWhereInput | votesScalarWhereInput[]\n    id?: UuidFilter<\"votes\"> | string\n    user_id?: UuidFilter<\"votes\"> | string\n    post_id?: UuidNullableFilter<\"votes\"> | string | null\n    comment_id?: UuidNullableFilter<\"votes\"> | string | null\n    value?: IntFilter<\"votes\"> | number\n    created_at?: DateTimeFilter<\"votes\"> | Date | string\n  }\n\n  export type usersCreateWithoutRoleInput = {\n    id: string\n    username: string\n    email: string\n    bio?: string | null\n    password_hash: string\n    created_at: Date | string\n    updated_at: Date | string\n    status: string\n    posts?: postsCreateNestedManyWithoutAuthorInput\n    comments?: commentsCreateNestedManyWithoutAuthorInput\n    votes?: votesCreateNestedManyWithoutUserInput\n  }\n\n  export type usersUncheckedCreateWithoutRoleInput = {\n    id: string\n    username: string\n    email: string\n    bio?: string | null\n    password_hash: string\n    created_at: Date | string\n    updated_at: Date | string\n    status: string\n    posts?: postsUncheckedCreateNestedManyWithoutAuthorInput\n    comments?: commentsUncheckedCreateNestedManyWithoutAuthorInput\n    votes?: votesUncheckedCreateNestedManyWithoutUserInput\n  }\n\n  export type usersCreateOrConnectWithoutRoleInput = {\n    where: usersWhereUniqueInput\n    create: XOR<usersCreateWithoutRoleInput, usersUncheckedCreateWithoutRoleInput>\n  }\n\n  export type usersCreateManyRoleInputEnvelope = {\n    data: usersCreateManyRoleInput | usersCreateManyRoleInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type usersUpsertWithWhereUniqueWithoutRoleInput = {\n    where: usersWhereUniqueInput\n    update: XOR<usersUpdateWithoutRoleInput, usersUncheckedUpdateWithoutRoleInput>\n    create: XOR<usersCreateWithoutRoleInput, usersUncheckedCreateWithoutRoleInput>\n  }\n\n  export type usersUpdateWithWhereUniqueWithoutRoleInput = {\n    where: usersWhereUniqueInput\n    data: XOR<usersUpdateWithoutRoleInput, usersUncheckedUpdateWithoutRoleInput>\n  }\n\n  export type usersUpdateManyWithWhereWithoutRoleInput = {\n    where: usersScalarWhereInput\n    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyWithoutRoleInput>\n  }\n\n  export type usersScalarWhereInput = {\n    AND?: usersScalarWhereInput | usersScalarWhereInput[]\n    OR?: usersScalarWhereInput[]\n    NOT?: usersScalarWhereInput | usersScalarWhereInput[]\n    id?: UuidFilter<\"users\"> | string\n    user_role_id?: UuidFilter<\"users\"> | string\n    username?: StringFilter<\"users\"> | string\n    email?: StringFilter<\"users\"> | string\n    bio?: StringNullableFilter<\"users\"> | string | null\n    password_hash?: StringFilter<\"users\"> | string\n    created_at?: DateTimeFilter<\"users\"> | Date | string\n    updated_at?: DateTimeFilter<\"users\"> | Date | string\n    status?: StringFilter<\"users\"> | string\n  }\n\n  export type postsCreateWithoutCategoryInput = {\n    id: string\n    title: string\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    author: usersCreateNestedOneWithoutPostsInput\n    comments?: commentsCreateNestedManyWithoutPostInput\n    votes?: votesCreateNestedManyWithoutPostInput\n  }\n\n  export type postsUncheckedCreateWithoutCategoryInput = {\n    id: string\n    user_id: string\n    title: string\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    comments?: commentsUncheckedCreateNestedManyWithoutPostInput\n    votes?: votesUncheckedCreateNestedManyWithoutPostInput\n  }\n\n  export type postsCreateOrConnectWithoutCategoryInput = {\n    where: postsWhereUniqueInput\n    create: XOR<postsCreateWithoutCategoryInput, postsUncheckedCreateWithoutCategoryInput>\n  }\n\n  export type postsCreateManyCategoryInputEnvelope = {\n    data: postsCreateManyCategoryInput | postsCreateManyCategoryInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type postsUpsertWithWhereUniqueWithoutCategoryInput = {\n    where: postsWhereUniqueInput\n    update: XOR<postsUpdateWithoutCategoryInput, postsUncheckedUpdateWithoutCategoryInput>\n    create: XOR<postsCreateWithoutCategoryInput, postsUncheckedCreateWithoutCategoryInput>\n  }\n\n  export type postsUpdateWithWhereUniqueWithoutCategoryInput = {\n    where: postsWhereUniqueInput\n    data: XOR<postsUpdateWithoutCategoryInput, postsUncheckedUpdateWithoutCategoryInput>\n  }\n\n  export type postsUpdateManyWithWhereWithoutCategoryInput = {\n    where: postsScalarWhereInput\n    data: XOR<postsUpdateManyMutationInput, postsUncheckedUpdateManyWithoutCategoryInput>\n  }\n\n  export type usersCreateWithoutPostsInput = {\n    id: string\n    username: string\n    email: string\n    bio?: string | null\n    password_hash: string\n    created_at: Date | string\n    updated_at: Date | string\n    status: string\n    role: user_rolesCreateNestedOneWithoutUsersInput\n    comments?: commentsCreateNestedManyWithoutAuthorInput\n    votes?: votesCreateNestedManyWithoutUserInput\n  }\n\n  export type usersUncheckedCreateWithoutPostsInput = {\n    id: string\n    user_role_id: string\n    username: string\n    email: string\n    bio?: string | null\n    password_hash: string\n    created_at: Date | string\n    updated_at: Date | string\n    status: string\n    comments?: commentsUncheckedCreateNestedManyWithoutAuthorInput\n    votes?: votesUncheckedCreateNestedManyWithoutUserInput\n  }\n\n  export type usersCreateOrConnectWithoutPostsInput = {\n    where: usersWhereUniqueInput\n    create: XOR<usersCreateWithoutPostsInput, usersUncheckedCreateWithoutPostsInput>\n  }\n\n  export type categoriesCreateWithoutPostsInput = {\n    id: string\n    name: string\n    description: string\n    created_at: Date | string\n  }\n\n  export type categoriesUncheckedCreateWithoutPostsInput = {\n    id: string\n    name: string\n    description: string\n    created_at: Date | string\n  }\n\n  export type categoriesCreateOrConnectWithoutPostsInput = {\n    where: categoriesWhereUniqueInput\n    create: XOR<categoriesCreateWithoutPostsInput, categoriesUncheckedCreateWithoutPostsInput>\n  }\n\n  export type commentsCreateWithoutPostInput = {\n    id: string\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    author: usersCreateNestedOneWithoutCommentsInput\n    parent?: commentsCreateNestedOneWithoutRecursiveInput\n    recursive?: commentsCreateNestedManyWithoutParentInput\n    votes?: votesCreateNestedManyWithoutCommentInput\n  }\n\n  export type commentsUncheckedCreateWithoutPostInput = {\n    id: string\n    user_id: string\n    parent_id?: string | null\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    recursive?: commentsUncheckedCreateNestedManyWithoutParentInput\n    votes?: votesUncheckedCreateNestedManyWithoutCommentInput\n  }\n\n  export type commentsCreateOrConnectWithoutPostInput = {\n    where: commentsWhereUniqueInput\n    create: XOR<commentsCreateWithoutPostInput, commentsUncheckedCreateWithoutPostInput>\n  }\n\n  export type commentsCreateManyPostInputEnvelope = {\n    data: commentsCreateManyPostInput | commentsCreateManyPostInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type votesCreateWithoutPostInput = {\n    id: string\n    value: number\n    created_at: Date | string\n    user: usersCreateNestedOneWithoutVotesInput\n    comment?: commentsCreateNestedOneWithoutVotesInput\n  }\n\n  export type votesUncheckedCreateWithoutPostInput = {\n    id: string\n    user_id: string\n    comment_id?: string | null\n    value: number\n    created_at: Date | string\n  }\n\n  export type votesCreateOrConnectWithoutPostInput = {\n    where: votesWhereUniqueInput\n    create: XOR<votesCreateWithoutPostInput, votesUncheckedCreateWithoutPostInput>\n  }\n\n  export type votesCreateManyPostInputEnvelope = {\n    data: votesCreateManyPostInput | votesCreateManyPostInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type usersUpsertWithoutPostsInput = {\n    update: XOR<usersUpdateWithoutPostsInput, usersUncheckedUpdateWithoutPostsInput>\n    create: XOR<usersCreateWithoutPostsInput, usersUncheckedCreateWithoutPostsInput>\n    where?: usersWhereInput\n  }\n\n  export type usersUpdateToOneWithWhereWithoutPostsInput = {\n    where?: usersWhereInput\n    data: XOR<usersUpdateWithoutPostsInput, usersUncheckedUpdateWithoutPostsInput>\n  }\n\n  export type usersUpdateWithoutPostsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    username?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    bio?: NullableStringFieldUpdateOperationsInput | string | null\n    password_hash?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    status?: StringFieldUpdateOperationsInput | string\n    role?: user_rolesUpdateOneRequiredWithoutUsersNestedInput\n    comments?: commentsUpdateManyWithoutAuthorNestedInput\n    votes?: votesUpdateManyWithoutUserNestedInput\n  }\n\n  export type usersUncheckedUpdateWithoutPostsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    user_role_id?: StringFieldUpdateOperationsInput | string\n    username?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    bio?: NullableStringFieldUpdateOperationsInput | string | null\n    password_hash?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    status?: StringFieldUpdateOperationsInput | string\n    comments?: commentsUncheckedUpdateManyWithoutAuthorNestedInput\n    votes?: votesUncheckedUpdateManyWithoutUserNestedInput\n  }\n\n  export type categoriesUpsertWithoutPostsInput = {\n    update: XOR<categoriesUpdateWithoutPostsInput, categoriesUncheckedUpdateWithoutPostsInput>\n    create: XOR<categoriesCreateWithoutPostsInput, categoriesUncheckedCreateWithoutPostsInput>\n    where?: categoriesWhereInput\n  }\n\n  export type categoriesUpdateToOneWithWhereWithoutPostsInput = {\n    where?: categoriesWhereInput\n    data: XOR<categoriesUpdateWithoutPostsInput, categoriesUncheckedUpdateWithoutPostsInput>\n  }\n\n  export type categoriesUpdateWithoutPostsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type categoriesUncheckedUpdateWithoutPostsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type commentsUpsertWithWhereUniqueWithoutPostInput = {\n    where: commentsWhereUniqueInput\n    update: XOR<commentsUpdateWithoutPostInput, commentsUncheckedUpdateWithoutPostInput>\n    create: XOR<commentsCreateWithoutPostInput, commentsUncheckedCreateWithoutPostInput>\n  }\n\n  export type commentsUpdateWithWhereUniqueWithoutPostInput = {\n    where: commentsWhereUniqueInput\n    data: XOR<commentsUpdateWithoutPostInput, commentsUncheckedUpdateWithoutPostInput>\n  }\n\n  export type commentsUpdateManyWithWhereWithoutPostInput = {\n    where: commentsScalarWhereInput\n    data: XOR<commentsUpdateManyMutationInput, commentsUncheckedUpdateManyWithoutPostInput>\n  }\n\n  export type votesUpsertWithWhereUniqueWithoutPostInput = {\n    where: votesWhereUniqueInput\n    update: XOR<votesUpdateWithoutPostInput, votesUncheckedUpdateWithoutPostInput>\n    create: XOR<votesCreateWithoutPostInput, votesUncheckedCreateWithoutPostInput>\n  }\n\n  export type votesUpdateWithWhereUniqueWithoutPostInput = {\n    where: votesWhereUniqueInput\n    data: XOR<votesUpdateWithoutPostInput, votesUncheckedUpdateWithoutPostInput>\n  }\n\n  export type votesUpdateManyWithWhereWithoutPostInput = {\n    where: votesScalarWhereInput\n    data: XOR<votesUpdateManyMutationInput, votesUncheckedUpdateManyWithoutPostInput>\n  }\n\n  export type usersCreateWithoutCommentsInput = {\n    id: string\n    username: string\n    email: string\n    bio?: string | null\n    password_hash: string\n    created_at: Date | string\n    updated_at: Date | string\n    status: string\n    role: user_rolesCreateNestedOneWithoutUsersInput\n    posts?: postsCreateNestedManyWithoutAuthorInput\n    votes?: votesCreateNestedManyWithoutUserInput\n  }\n\n  export type usersUncheckedCreateWithoutCommentsInput = {\n    id: string\n    user_role_id: string\n    username: string\n    email: string\n    bio?: string | null\n    password_hash: string\n    created_at: Date | string\n    updated_at: Date | string\n    status: string\n    posts?: postsUncheckedCreateNestedManyWithoutAuthorInput\n    votes?: votesUncheckedCreateNestedManyWithoutUserInput\n  }\n\n  export type usersCreateOrConnectWithoutCommentsInput = {\n    where: usersWhereUniqueInput\n    create: XOR<usersCreateWithoutCommentsInput, usersUncheckedCreateWithoutCommentsInput>\n  }\n\n  export type postsCreateWithoutCommentsInput = {\n    id: string\n    title: string\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    author: usersCreateNestedOneWithoutPostsInput\n    category: categoriesCreateNestedOneWithoutPostsInput\n    votes?: votesCreateNestedManyWithoutPostInput\n  }\n\n  export type postsUncheckedCreateWithoutCommentsInput = {\n    id: string\n    user_id: string\n    category_id: string\n    title: string\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    votes?: votesUncheckedCreateNestedManyWithoutPostInput\n  }\n\n  export type postsCreateOrConnectWithoutCommentsInput = {\n    where: postsWhereUniqueInput\n    create: XOR<postsCreateWithoutCommentsInput, postsUncheckedCreateWithoutCommentsInput>\n  }\n\n  export type commentsCreateWithoutRecursiveInput = {\n    id: string\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    author: usersCreateNestedOneWithoutCommentsInput\n    post: postsCreateNestedOneWithoutCommentsInput\n    parent?: commentsCreateNestedOneWithoutRecursiveInput\n    votes?: votesCreateNestedManyWithoutCommentInput\n  }\n\n  export type commentsUncheckedCreateWithoutRecursiveInput = {\n    id: string\n    user_id: string\n    post_id: string\n    parent_id?: string | null\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    votes?: votesUncheckedCreateNestedManyWithoutCommentInput\n  }\n\n  export type commentsCreateOrConnectWithoutRecursiveInput = {\n    where: commentsWhereUniqueInput\n    create: XOR<commentsCreateWithoutRecursiveInput, commentsUncheckedCreateWithoutRecursiveInput>\n  }\n\n  export type commentsCreateWithoutParentInput = {\n    id: string\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    author: usersCreateNestedOneWithoutCommentsInput\n    post: postsCreateNestedOneWithoutCommentsInput\n    recursive?: commentsCreateNestedManyWithoutParentInput\n    votes?: votesCreateNestedManyWithoutCommentInput\n  }\n\n  export type commentsUncheckedCreateWithoutParentInput = {\n    id: string\n    user_id: string\n    post_id: string\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    recursive?: commentsUncheckedCreateNestedManyWithoutParentInput\n    votes?: votesUncheckedCreateNestedManyWithoutCommentInput\n  }\n\n  export type commentsCreateOrConnectWithoutParentInput = {\n    where: commentsWhereUniqueInput\n    create: XOR<commentsCreateWithoutParentInput, commentsUncheckedCreateWithoutParentInput>\n  }\n\n  export type commentsCreateManyParentInputEnvelope = {\n    data: commentsCreateManyParentInput | commentsCreateManyParentInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type votesCreateWithoutCommentInput = {\n    id: string\n    value: number\n    created_at: Date | string\n    user: usersCreateNestedOneWithoutVotesInput\n    post?: postsCreateNestedOneWithoutVotesInput\n  }\n\n  export type votesUncheckedCreateWithoutCommentInput = {\n    id: string\n    user_id: string\n    post_id?: string | null\n    value: number\n    created_at: Date | string\n  }\n\n  export type votesCreateOrConnectWithoutCommentInput = {\n    where: votesWhereUniqueInput\n    create: XOR<votesCreateWithoutCommentInput, votesUncheckedCreateWithoutCommentInput>\n  }\n\n  export type votesCreateManyCommentInputEnvelope = {\n    data: votesCreateManyCommentInput | votesCreateManyCommentInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type usersUpsertWithoutCommentsInput = {\n    update: XOR<usersUpdateWithoutCommentsInput, usersUncheckedUpdateWithoutCommentsInput>\n    create: XOR<usersCreateWithoutCommentsInput, usersUncheckedCreateWithoutCommentsInput>\n    where?: usersWhereInput\n  }\n\n  export type usersUpdateToOneWithWhereWithoutCommentsInput = {\n    where?: usersWhereInput\n    data: XOR<usersUpdateWithoutCommentsInput, usersUncheckedUpdateWithoutCommentsInput>\n  }\n\n  export type usersUpdateWithoutCommentsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    username?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    bio?: NullableStringFieldUpdateOperationsInput | string | null\n    password_hash?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    status?: StringFieldUpdateOperationsInput | string\n    role?: user_rolesUpdateOneRequiredWithoutUsersNestedInput\n    posts?: postsUpdateManyWithoutAuthorNestedInput\n    votes?: votesUpdateManyWithoutUserNestedInput\n  }\n\n  export type usersUncheckedUpdateWithoutCommentsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    user_role_id?: StringFieldUpdateOperationsInput | string\n    username?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    bio?: NullableStringFieldUpdateOperationsInput | string | null\n    password_hash?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    status?: StringFieldUpdateOperationsInput | string\n    posts?: postsUncheckedUpdateManyWithoutAuthorNestedInput\n    votes?: votesUncheckedUpdateManyWithoutUserNestedInput\n  }\n\n  export type postsUpsertWithoutCommentsInput = {\n    update: XOR<postsUpdateWithoutCommentsInput, postsUncheckedUpdateWithoutCommentsInput>\n    create: XOR<postsCreateWithoutCommentsInput, postsUncheckedCreateWithoutCommentsInput>\n    where?: postsWhereInput\n  }\n\n  export type postsUpdateToOneWithWhereWithoutCommentsInput = {\n    where?: postsWhereInput\n    data: XOR<postsUpdateWithoutCommentsInput, postsUncheckedUpdateWithoutCommentsInput>\n  }\n\n  export type postsUpdateWithoutCommentsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    author?: usersUpdateOneRequiredWithoutPostsNestedInput\n    category?: categoriesUpdateOneRequiredWithoutPostsNestedInput\n    votes?: votesUpdateManyWithoutPostNestedInput\n  }\n\n  export type postsUncheckedUpdateWithoutCommentsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    user_id?: StringFieldUpdateOperationsInput | string\n    category_id?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    votes?: votesUncheckedUpdateManyWithoutPostNestedInput\n  }\n\n  export type commentsUpsertWithoutRecursiveInput = {\n    update: XOR<commentsUpdateWithoutRecursiveInput, commentsUncheckedUpdateWithoutRecursiveInput>\n    create: XOR<commentsCreateWithoutRecursiveInput, commentsUncheckedCreateWithoutRecursiveInput>\n    where?: commentsWhereInput\n  }\n\n  export type commentsUpdateToOneWithWhereWithoutRecursiveInput = {\n    where?: commentsWhereInput\n    data: XOR<commentsUpdateWithoutRecursiveInput, commentsUncheckedUpdateWithoutRecursiveInput>\n  }\n\n  export type commentsUpdateWithoutRecursiveInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    author?: usersUpdateOneRequiredWithoutCommentsNestedInput\n    post?: postsUpdateOneRequiredWithoutCommentsNestedInput\n    parent?: commentsUpdateOneWithoutRecursiveNestedInput\n    votes?: votesUpdateManyWithoutCommentNestedInput\n  }\n\n  export type commentsUncheckedUpdateWithoutRecursiveInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    user_id?: StringFieldUpdateOperationsInput | string\n    post_id?: StringFieldUpdateOperationsInput | string\n    parent_id?: NullableStringFieldUpdateOperationsInput | string | null\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    votes?: votesUncheckedUpdateManyWithoutCommentNestedInput\n  }\n\n  export type commentsUpsertWithWhereUniqueWithoutParentInput = {\n    where: commentsWhereUniqueInput\n    update: XOR<commentsUpdateWithoutParentInput, commentsUncheckedUpdateWithoutParentInput>\n    create: XOR<commentsCreateWithoutParentInput, commentsUncheckedCreateWithoutParentInput>\n  }\n\n  export type commentsUpdateWithWhereUniqueWithoutParentInput = {\n    where: commentsWhereUniqueInput\n    data: XOR<commentsUpdateWithoutParentInput, commentsUncheckedUpdateWithoutParentInput>\n  }\n\n  export type commentsUpdateManyWithWhereWithoutParentInput = {\n    where: commentsScalarWhereInput\n    data: XOR<commentsUpdateManyMutationInput, commentsUncheckedUpdateManyWithoutParentInput>\n  }\n\n  export type votesUpsertWithWhereUniqueWithoutCommentInput = {\n    where: votesWhereUniqueInput\n    update: XOR<votesUpdateWithoutCommentInput, votesUncheckedUpdateWithoutCommentInput>\n    create: XOR<votesCreateWithoutCommentInput, votesUncheckedCreateWithoutCommentInput>\n  }\n\n  export type votesUpdateWithWhereUniqueWithoutCommentInput = {\n    where: votesWhereUniqueInput\n    data: XOR<votesUpdateWithoutCommentInput, votesUncheckedUpdateWithoutCommentInput>\n  }\n\n  export type votesUpdateManyWithWhereWithoutCommentInput = {\n    where: votesScalarWhereInput\n    data: XOR<votesUpdateManyMutationInput, votesUncheckedUpdateManyWithoutCommentInput>\n  }\n\n  export type usersCreateWithoutVotesInput = {\n    id: string\n    username: string\n    email: string\n    bio?: string | null\n    password_hash: string\n    created_at: Date | string\n    updated_at: Date | string\n    status: string\n    role: user_rolesCreateNestedOneWithoutUsersInput\n    posts?: postsCreateNestedManyWithoutAuthorInput\n    comments?: commentsCreateNestedManyWithoutAuthorInput\n  }\n\n  export type usersUncheckedCreateWithoutVotesInput = {\n    id: string\n    user_role_id: string\n    username: string\n    email: string\n    bio?: string | null\n    password_hash: string\n    created_at: Date | string\n    updated_at: Date | string\n    status: string\n    posts?: postsUncheckedCreateNestedManyWithoutAuthorInput\n    comments?: commentsUncheckedCreateNestedManyWithoutAuthorInput\n  }\n\n  export type usersCreateOrConnectWithoutVotesInput = {\n    where: usersWhereUniqueInput\n    create: XOR<usersCreateWithoutVotesInput, usersUncheckedCreateWithoutVotesInput>\n  }\n\n  export type postsCreateWithoutVotesInput = {\n    id: string\n    title: string\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    author: usersCreateNestedOneWithoutPostsInput\n    category: categoriesCreateNestedOneWithoutPostsInput\n    comments?: commentsCreateNestedManyWithoutPostInput\n  }\n\n  export type postsUncheckedCreateWithoutVotesInput = {\n    id: string\n    user_id: string\n    category_id: string\n    title: string\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    comments?: commentsUncheckedCreateNestedManyWithoutPostInput\n  }\n\n  export type postsCreateOrConnectWithoutVotesInput = {\n    where: postsWhereUniqueInput\n    create: XOR<postsCreateWithoutVotesInput, postsUncheckedCreateWithoutVotesInput>\n  }\n\n  export type commentsCreateWithoutVotesInput = {\n    id: string\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    author: usersCreateNestedOneWithoutCommentsInput\n    post: postsCreateNestedOneWithoutCommentsInput\n    parent?: commentsCreateNestedOneWithoutRecursiveInput\n    recursive?: commentsCreateNestedManyWithoutParentInput\n  }\n\n  export type commentsUncheckedCreateWithoutVotesInput = {\n    id: string\n    user_id: string\n    post_id: string\n    parent_id?: string | null\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    recursive?: commentsUncheckedCreateNestedManyWithoutParentInput\n  }\n\n  export type commentsCreateOrConnectWithoutVotesInput = {\n    where: commentsWhereUniqueInput\n    create: XOR<commentsCreateWithoutVotesInput, commentsUncheckedCreateWithoutVotesInput>\n  }\n\n  export type usersUpsertWithoutVotesInput = {\n    update: XOR<usersUpdateWithoutVotesInput, usersUncheckedUpdateWithoutVotesInput>\n    create: XOR<usersCreateWithoutVotesInput, usersUncheckedCreateWithoutVotesInput>\n    where?: usersWhereInput\n  }\n\n  export type usersUpdateToOneWithWhereWithoutVotesInput = {\n    where?: usersWhereInput\n    data: XOR<usersUpdateWithoutVotesInput, usersUncheckedUpdateWithoutVotesInput>\n  }\n\n  export type usersUpdateWithoutVotesInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    username?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    bio?: NullableStringFieldUpdateOperationsInput | string | null\n    password_hash?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    status?: StringFieldUpdateOperationsInput | string\n    role?: user_rolesUpdateOneRequiredWithoutUsersNestedInput\n    posts?: postsUpdateManyWithoutAuthorNestedInput\n    comments?: commentsUpdateManyWithoutAuthorNestedInput\n  }\n\n  export type usersUncheckedUpdateWithoutVotesInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    user_role_id?: StringFieldUpdateOperationsInput | string\n    username?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    bio?: NullableStringFieldUpdateOperationsInput | string | null\n    password_hash?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    status?: StringFieldUpdateOperationsInput | string\n    posts?: postsUncheckedUpdateManyWithoutAuthorNestedInput\n    comments?: commentsUncheckedUpdateManyWithoutAuthorNestedInput\n  }\n\n  export type postsUpsertWithoutVotesInput = {\n    update: XOR<postsUpdateWithoutVotesInput, postsUncheckedUpdateWithoutVotesInput>\n    create: XOR<postsCreateWithoutVotesInput, postsUncheckedCreateWithoutVotesInput>\n    where?: postsWhereInput\n  }\n\n  export type postsUpdateToOneWithWhereWithoutVotesInput = {\n    where?: postsWhereInput\n    data: XOR<postsUpdateWithoutVotesInput, postsUncheckedUpdateWithoutVotesInput>\n  }\n\n  export type postsUpdateWithoutVotesInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    author?: usersUpdateOneRequiredWithoutPostsNestedInput\n    category?: categoriesUpdateOneRequiredWithoutPostsNestedInput\n    comments?: commentsUpdateManyWithoutPostNestedInput\n  }\n\n  export type postsUncheckedUpdateWithoutVotesInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    user_id?: StringFieldUpdateOperationsInput | string\n    category_id?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    comments?: commentsUncheckedUpdateManyWithoutPostNestedInput\n  }\n\n  export type commentsUpsertWithoutVotesInput = {\n    update: XOR<commentsUpdateWithoutVotesInput, commentsUncheckedUpdateWithoutVotesInput>\n    create: XOR<commentsCreateWithoutVotesInput, commentsUncheckedCreateWithoutVotesInput>\n    where?: commentsWhereInput\n  }\n\n  export type commentsUpdateToOneWithWhereWithoutVotesInput = {\n    where?: commentsWhereInput\n    data: XOR<commentsUpdateWithoutVotesInput, commentsUncheckedUpdateWithoutVotesInput>\n  }\n\n  export type commentsUpdateWithoutVotesInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    author?: usersUpdateOneRequiredWithoutCommentsNestedInput\n    post?: postsUpdateOneRequiredWithoutCommentsNestedInput\n    parent?: commentsUpdateOneWithoutRecursiveNestedInput\n    recursive?: commentsUpdateManyWithoutParentNestedInput\n  }\n\n  export type commentsUncheckedUpdateWithoutVotesInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    user_id?: StringFieldUpdateOperationsInput | string\n    post_id?: StringFieldUpdateOperationsInput | string\n    parent_id?: NullableStringFieldUpdateOperationsInput | string | null\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    recursive?: commentsUncheckedUpdateManyWithoutParentNestedInput\n  }\n\n  export type postsCreateManyAuthorInput = {\n    id: string\n    category_id: string\n    title: string\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type commentsCreateManyAuthorInput = {\n    id: string\n    post_id: string\n    parent_id?: string | null\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type votesCreateManyUserInput = {\n    id: string\n    post_id?: string | null\n    comment_id?: string | null\n    value: number\n    created_at: Date | string\n  }\n\n  export type postsUpdateWithoutAuthorInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    category?: categoriesUpdateOneRequiredWithoutPostsNestedInput\n    comments?: commentsUpdateManyWithoutPostNestedInput\n    votes?: votesUpdateManyWithoutPostNestedInput\n  }\n\n  export type postsUncheckedUpdateWithoutAuthorInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    category_id?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    comments?: commentsUncheckedUpdateManyWithoutPostNestedInput\n    votes?: votesUncheckedUpdateManyWithoutPostNestedInput\n  }\n\n  export type postsUncheckedUpdateManyWithoutAuthorInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    category_id?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type commentsUpdateWithoutAuthorInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    post?: postsUpdateOneRequiredWithoutCommentsNestedInput\n    parent?: commentsUpdateOneWithoutRecursiveNestedInput\n    recursive?: commentsUpdateManyWithoutParentNestedInput\n    votes?: votesUpdateManyWithoutCommentNestedInput\n  }\n\n  export type commentsUncheckedUpdateWithoutAuthorInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    post_id?: StringFieldUpdateOperationsInput | string\n    parent_id?: NullableStringFieldUpdateOperationsInput | string | null\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    recursive?: commentsUncheckedUpdateManyWithoutParentNestedInput\n    votes?: votesUncheckedUpdateManyWithoutCommentNestedInput\n  }\n\n  export type commentsUncheckedUpdateManyWithoutAuthorInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    post_id?: StringFieldUpdateOperationsInput | string\n    parent_id?: NullableStringFieldUpdateOperationsInput | string | null\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type votesUpdateWithoutUserInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    value?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    post?: postsUpdateOneWithoutVotesNestedInput\n    comment?: commentsUpdateOneWithoutVotesNestedInput\n  }\n\n  export type votesUncheckedUpdateWithoutUserInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    post_id?: NullableStringFieldUpdateOperationsInput | string | null\n    comment_id?: NullableStringFieldUpdateOperationsInput | string | null\n    value?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type votesUncheckedUpdateManyWithoutUserInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    post_id?: NullableStringFieldUpdateOperationsInput | string | null\n    comment_id?: NullableStringFieldUpdateOperationsInput | string | null\n    value?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type usersCreateManyRoleInput = {\n    id: string\n    username: string\n    email: string\n    bio?: string | null\n    password_hash: string\n    created_at: Date | string\n    updated_at: Date | string\n    status: string\n  }\n\n  export type usersUpdateWithoutRoleInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    username?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    bio?: NullableStringFieldUpdateOperationsInput | string | null\n    password_hash?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    status?: StringFieldUpdateOperationsInput | string\n    posts?: postsUpdateManyWithoutAuthorNestedInput\n    comments?: commentsUpdateManyWithoutAuthorNestedInput\n    votes?: votesUpdateManyWithoutUserNestedInput\n  }\n\n  export type usersUncheckedUpdateWithoutRoleInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    username?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    bio?: NullableStringFieldUpdateOperationsInput | string | null\n    password_hash?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    status?: StringFieldUpdateOperationsInput | string\n    posts?: postsUncheckedUpdateManyWithoutAuthorNestedInput\n    comments?: commentsUncheckedUpdateManyWithoutAuthorNestedInput\n    votes?: votesUncheckedUpdateManyWithoutUserNestedInput\n  }\n\n  export type usersUncheckedUpdateManyWithoutRoleInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    username?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    bio?: NullableStringFieldUpdateOperationsInput | string | null\n    password_hash?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    status?: StringFieldUpdateOperationsInput | string\n  }\n\n  export type postsCreateManyCategoryInput = {\n    id: string\n    user_id: string\n    title: string\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type postsUpdateWithoutCategoryInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    author?: usersUpdateOneRequiredWithoutPostsNestedInput\n    comments?: commentsUpdateManyWithoutPostNestedInput\n    votes?: votesUpdateManyWithoutPostNestedInput\n  }\n\n  export type postsUncheckedUpdateWithoutCategoryInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    user_id?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    comments?: commentsUncheckedUpdateManyWithoutPostNestedInput\n    votes?: votesUncheckedUpdateManyWithoutPostNestedInput\n  }\n\n  export type postsUncheckedUpdateManyWithoutCategoryInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    user_id?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type commentsCreateManyPostInput = {\n    id: string\n    user_id: string\n    parent_id?: string | null\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type votesCreateManyPostInput = {\n    id: string\n    user_id: string\n    comment_id?: string | null\n    value: number\n    created_at: Date | string\n  }\n\n  export type commentsUpdateWithoutPostInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    author?: usersUpdateOneRequiredWithoutCommentsNestedInput\n    parent?: commentsUpdateOneWithoutRecursiveNestedInput\n    recursive?: commentsUpdateManyWithoutParentNestedInput\n    votes?: votesUpdateManyWithoutCommentNestedInput\n  }\n\n  export type commentsUncheckedUpdateWithoutPostInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    user_id?: StringFieldUpdateOperationsInput | string\n    parent_id?: NullableStringFieldUpdateOperationsInput | string | null\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    recursive?: commentsUncheckedUpdateManyWithoutParentNestedInput\n    votes?: votesUncheckedUpdateManyWithoutCommentNestedInput\n  }\n\n  export type commentsUncheckedUpdateManyWithoutPostInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    user_id?: StringFieldUpdateOperationsInput | string\n    parent_id?: NullableStringFieldUpdateOperationsInput | string | null\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type votesUpdateWithoutPostInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    value?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    user?: usersUpdateOneRequiredWithoutVotesNestedInput\n    comment?: commentsUpdateOneWithoutVotesNestedInput\n  }\n\n  export type votesUncheckedUpdateWithoutPostInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    user_id?: StringFieldUpdateOperationsInput | string\n    comment_id?: NullableStringFieldUpdateOperationsInput | string | null\n    value?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type votesUncheckedUpdateManyWithoutPostInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    user_id?: StringFieldUpdateOperationsInput | string\n    comment_id?: NullableStringFieldUpdateOperationsInput | string | null\n    value?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type commentsCreateManyParentInput = {\n    id: string\n    user_id: string\n    post_id: string\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type votesCreateManyCommentInput = {\n    id: string\n    user_id: string\n    post_id?: string | null\n    value: number\n    created_at: Date | string\n  }\n\n  export type commentsUpdateWithoutParentInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    author?: usersUpdateOneRequiredWithoutCommentsNestedInput\n    post?: postsUpdateOneRequiredWithoutCommentsNestedInput\n    recursive?: commentsUpdateManyWithoutParentNestedInput\n    votes?: votesUpdateManyWithoutCommentNestedInput\n  }\n\n  export type commentsUncheckedUpdateWithoutParentInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    user_id?: StringFieldUpdateOperationsInput | string\n    post_id?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    recursive?: commentsUncheckedUpdateManyWithoutParentNestedInput\n    votes?: votesUncheckedUpdateManyWithoutCommentNestedInput\n  }\n\n  export type commentsUncheckedUpdateManyWithoutParentInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    user_id?: StringFieldUpdateOperationsInput | string\n    post_id?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type votesUpdateWithoutCommentInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    value?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    user?: usersUpdateOneRequiredWithoutVotesNestedInput\n    post?: postsUpdateOneWithoutVotesNestedInput\n  }\n\n  export type votesUncheckedUpdateWithoutCommentInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    user_id?: StringFieldUpdateOperationsInput | string\n    post_id?: NullableStringFieldUpdateOperationsInput | string | null\n    value?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type votesUncheckedUpdateManyWithoutCommentInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    user_id?: StringFieldUpdateOperationsInput | string\n    post_id?: NullableStringFieldUpdateOperationsInput | string | null\n    value?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n\n\n  /**\n   * Batch Payload for updateMany & deleteMany & createMany\n   */\n\n  export type BatchPayload = {\n    count: number\n  }\n\n  /**\n   * DMMF\n   */\n  export const dmmf: runtime.BaseDMMF\n}",
        "node_modules/.prisma/client/runtime/index-browser.d.ts": "declare class AnyNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\ndeclare type Args<T, F extends Operation> = T extends {\r\n    [K: symbol]: {\r\n        types: {\r\n            operations: {\r\n                [K in F]: {\r\n                    args: any;\r\n                };\r\n            };\r\n        };\r\n    };\r\n} ? T[symbol]['types']['operations'][F]['args'] : any;\r\n\r\ndeclare class DbNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\nexport declare function Decimal(n: Decimal.Value): Decimal;\r\n\r\nexport declare namespace Decimal {\r\n    export type Constructor = typeof Decimal;\r\n    export type Instance = Decimal;\r\n    export type Rounding = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8;\r\n    export type Modulo = Rounding | 9;\r\n    export type Value = string | number | Decimal;\r\n\r\n    // http://mikemcl.github.io/decimal.js/#constructor-properties\r\n    export interface Config {\r\n        precision?: number;\r\n        rounding?: Rounding;\r\n        toExpNeg?: number;\r\n        toExpPos?: number;\r\n        minE?: number;\r\n        maxE?: number;\r\n        crypto?: boolean;\r\n        modulo?: Modulo;\r\n        defaults?: boolean;\r\n    }\r\n}\r\n\r\nexport declare class Decimal {\r\n    readonly d: number[];\r\n    readonly e: number;\r\n    readonly s: number;\r\n\r\n    constructor(n: Decimal.Value);\r\n\r\n    absoluteValue(): Decimal;\r\n    abs(): Decimal;\r\n\r\n    ceil(): Decimal;\r\n\r\n    clampedTo(min: Decimal.Value, max: Decimal.Value): Decimal;\r\n    clamp(min: Decimal.Value, max: Decimal.Value): Decimal;\r\n\r\n    comparedTo(n: Decimal.Value): number;\r\n    cmp(n: Decimal.Value): number;\r\n\r\n    cosine(): Decimal;\r\n    cos(): Decimal;\r\n\r\n    cubeRoot(): Decimal;\r\n    cbrt(): Decimal;\r\n\r\n    decimalPlaces(): number;\r\n    dp(): number;\r\n\r\n    dividedBy(n: Decimal.Value): Decimal;\r\n    div(n: Decimal.Value): Decimal;\r\n\r\n    dividedToIntegerBy(n: Decimal.Value): Decimal;\r\n    divToInt(n: Decimal.Value): Decimal;\r\n\r\n    equals(n: Decimal.Value): boolean;\r\n    eq(n: Decimal.Value): boolean;\r\n\r\n    floor(): Decimal;\r\n\r\n    greaterThan(n: Decimal.Value): boolean;\r\n    gt(n: Decimal.Value): boolean;\r\n\r\n    greaterThanOrEqualTo(n: Decimal.Value): boolean;\r\n    gte(n: Decimal.Value): boolean;\r\n\r\n    hyperbolicCosine(): Decimal;\r\n    cosh(): Decimal;\r\n\r\n    hyperbolicSine(): Decimal;\r\n    sinh(): Decimal;\r\n\r\n    hyperbolicTangent(): Decimal;\r\n    tanh(): Decimal;\r\n\r\n    inverseCosine(): Decimal;\r\n    acos(): Decimal;\r\n\r\n    inverseHyperbolicCosine(): Decimal;\r\n    acosh(): Decimal;\r\n\r\n    inverseHyperbolicSine(): Decimal;\r\n    asinh(): Decimal;\r\n\r\n    inverseHyperbolicTangent(): Decimal;\r\n    atanh(): Decimal;\r\n\r\n    inverseSine(): Decimal;\r\n    asin(): Decimal;\r\n\r\n    inverseTangent(): Decimal;\r\n    atan(): Decimal;\r\n\r\n    isFinite(): boolean;\r\n\r\n    isInteger(): boolean;\r\n    isInt(): boolean;\r\n\r\n    isNaN(): boolean;\r\n\r\n    isNegative(): boolean;\r\n    isNeg(): boolean;\r\n\r\n    isPositive(): boolean;\r\n    isPos(): boolean;\r\n\r\n    isZero(): boolean;\r\n\r\n    lessThan(n: Decimal.Value): boolean;\r\n    lt(n: Decimal.Value): boolean;\r\n\r\n    lessThanOrEqualTo(n: Decimal.Value): boolean;\r\n    lte(n: Decimal.Value): boolean;\r\n\r\n    logarithm(n?: Decimal.Value): Decimal;\r\n    log(n?: Decimal.Value): Decimal;\r\n\r\n    minus(n: Decimal.Value): Decimal;\r\n    sub(n: Decimal.Value): Decimal;\r\n\r\n    modulo(n: Decimal.Value): Decimal;\r\n    mod(n: Decimal.Value): Decimal;\r\n\r\n    naturalExponential(): Decimal;\r\n    exp(): Decimal;\r\n\r\n    naturalLogarithm(): Decimal;\r\n    ln(): Decimal;\r\n\r\n    negated(): Decimal;\r\n    neg(): Decimal;\r\n\r\n    plus(n: Decimal.Value): Decimal;\r\n    add(n: Decimal.Value): Decimal;\r\n\r\n    precision(includeZeros?: boolean): number;\r\n    sd(includeZeros?: boolean): number;\r\n\r\n    round(): Decimal;\r\n\r\n    sine() : Decimal;\r\n    sin() : Decimal;\r\n\r\n    squareRoot(): Decimal;\r\n    sqrt(): Decimal;\r\n\r\n    tangent() : Decimal;\r\n    tan() : Decimal;\r\n\r\n    times(n: Decimal.Value): Decimal;\r\n    mul(n: Decimal.Value) : Decimal;\r\n\r\n    toBinary(significantDigits?: number): string;\r\n    toBinary(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toDecimalPlaces(decimalPlaces?: number): Decimal;\r\n    toDecimalPlaces(decimalPlaces: number, rounding: Decimal.Rounding): Decimal;\r\n    toDP(decimalPlaces?: number): Decimal;\r\n    toDP(decimalPlaces: number, rounding: Decimal.Rounding): Decimal;\r\n\r\n    toExponential(decimalPlaces?: number): string;\r\n    toExponential(decimalPlaces: number, rounding: Decimal.Rounding): string;\r\n\r\n    toFixed(decimalPlaces?: number): string;\r\n    toFixed(decimalPlaces: number, rounding: Decimal.Rounding): string;\r\n\r\n    toFraction(max_denominator?: Decimal.Value): Decimal[];\r\n\r\n    toHexadecimal(significantDigits?: number): string;\r\n    toHexadecimal(significantDigits: number, rounding: Decimal.Rounding): string;\r\n    toHex(significantDigits?: number): string;\r\n    toHex(significantDigits: number, rounding?: Decimal.Rounding): string;\r\n\r\n    toJSON(): string;\r\n\r\n    toNearest(n: Decimal.Value, rounding?: Decimal.Rounding): Decimal;\r\n\r\n    toNumber(): number;\r\n\r\n    toOctal(significantDigits?: number): string;\r\n    toOctal(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toPower(n: Decimal.Value): Decimal;\r\n    pow(n: Decimal.Value): Decimal;\r\n\r\n    toPrecision(significantDigits?: number): string;\r\n    toPrecision(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toSignificantDigits(significantDigits?: number): Decimal;\r\n    toSignificantDigits(significantDigits: number, rounding: Decimal.Rounding): Decimal;\r\n    toSD(significantDigits?: number): Decimal;\r\n    toSD(significantDigits: number, rounding: Decimal.Rounding): Decimal;\r\n\r\n    toString(): string;\r\n\r\n    truncated(): Decimal;\r\n    trunc(): Decimal;\r\n\r\n    valueOf(): string;\r\n\r\n    static abs(n: Decimal.Value): Decimal;\r\n    static acos(n: Decimal.Value): Decimal;\r\n    static acosh(n: Decimal.Value): Decimal;\r\n    static add(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static asin(n: Decimal.Value): Decimal;\r\n    static asinh(n: Decimal.Value): Decimal;\r\n    static atan(n: Decimal.Value): Decimal;\r\n    static atanh(n: Decimal.Value): Decimal;\r\n    static atan2(y: Decimal.Value, x: Decimal.Value): Decimal;\r\n    static cbrt(n: Decimal.Value): Decimal;\r\n    static ceil(n: Decimal.Value): Decimal;\r\n    static clamp(n: Decimal.Value, min: Decimal.Value, max: Decimal.Value): Decimal;\r\n    static clone(object?: Decimal.Config): Decimal.Constructor;\r\n    static config(object: Decimal.Config): Decimal.Constructor;\r\n    static cos(n: Decimal.Value): Decimal;\r\n    static cosh(n: Decimal.Value): Decimal;\r\n    static div(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static exp(n: Decimal.Value): Decimal;\r\n    static floor(n: Decimal.Value): Decimal;\r\n    static hypot(...n: Decimal.Value[]): Decimal;\r\n    static isDecimal(object: any): object is Decimal;\r\n    static ln(n: Decimal.Value): Decimal;\r\n    static log(n: Decimal.Value, base?: Decimal.Value): Decimal;\r\n    static log2(n: Decimal.Value): Decimal;\r\n    static log10(n: Decimal.Value): Decimal;\r\n    static max(...n: Decimal.Value[]): Decimal;\r\n    static min(...n: Decimal.Value[]): Decimal;\r\n    static mod(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static mul(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static noConflict(): Decimal.Constructor;   // Browser only\r\n    static pow(base: Decimal.Value, exponent: Decimal.Value): Decimal;\r\n    static random(significantDigits?: number): Decimal;\r\n    static round(n: Decimal.Value): Decimal;\r\n    static set(object: Decimal.Config): Decimal.Constructor;\r\n    static sign(n: Decimal.Value): number;\r\n    static sin(n: Decimal.Value): Decimal;\r\n    static sinh(n: Decimal.Value): Decimal;\r\n    static sqrt(n: Decimal.Value): Decimal;\r\n    static sub(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static sum(...n: Decimal.Value[]): Decimal;\r\n    static tan(n: Decimal.Value): Decimal;\r\n    static tanh(n: Decimal.Value): Decimal;\r\n    static trunc(n: Decimal.Value): Decimal;\r\n\r\n    static readonly default?: Decimal.Constructor;\r\n    static readonly Decimal?: Decimal.Constructor;\r\n\r\n    static readonly precision: number;\r\n    static readonly rounding: Decimal.Rounding;\r\n    static readonly toExpNeg: number;\r\n    static readonly toExpPos: number;\r\n    static readonly minE: number;\r\n    static readonly maxE: number;\r\n    static readonly crypto: boolean;\r\n    static readonly modulo: Decimal.Modulo;\r\n\r\n    static readonly ROUND_UP: 0;\r\n    static readonly ROUND_DOWN: 1;\r\n    static readonly ROUND_CEIL: 2;\r\n    static readonly ROUND_FLOOR: 3;\r\n    static readonly ROUND_HALF_UP: 4;\r\n    static readonly ROUND_HALF_DOWN: 5;\r\n    static readonly ROUND_HALF_EVEN: 6;\r\n    static readonly ROUND_HALF_CEIL: 7;\r\n    static readonly ROUND_HALF_FLOOR: 8;\r\n    static readonly EUCLID: 9;\r\n}\r\n\r\ndeclare type Exact<A, W> = (A extends unknown ? (W extends A ? {\r\n    [K in keyof A]: Exact<A[K], W[K]>;\r\n} : W) : never) | (A extends Narrowable ? A : never);\r\n\r\nexport declare function getRuntime(): GetRuntimeOutput;\r\n\r\ndeclare type GetRuntimeOutput = {\r\n    id: RuntimeName;\r\n    prettyName: string;\r\n    isEdge: boolean;\r\n};\r\n\r\ndeclare class JsonNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\n/**\r\n * Generates more strict variant of an enum which, unlike regular enum,\r\n * throws on non-existing property access. This can be useful in following situations:\r\n * - we have an API, that accepts both `undefined` and `SomeEnumType` as an input\r\n * - enum values are generated dynamically from DMMF.\r\n *\r\n * In that case, if using normal enums and no compile-time typechecking, using non-existing property\r\n * will result in `undefined` value being used, which will be accepted. Using strict enum\r\n * in this case will help to have a runtime exception, telling you that you are probably doing something wrong.\r\n *\r\n * Note: if you need to check for existence of a value in the enum you can still use either\r\n * `in` operator or `hasOwnProperty` function.\r\n *\r\n * @param definition\r\n * @returns\r\n */\r\nexport declare function makeStrictEnum<T extends Record<PropertyKey, string | number>>(definition: T): T;\r\n\r\ndeclare type Narrowable = string | number | bigint | boolean | [];\r\n\r\ndeclare class NullTypesEnumValue extends ObjectEnumValue {\r\n    _getNamespace(): string;\r\n}\r\n\r\n/**\r\n * Base class for unique values of object-valued enums.\r\n */\r\ndeclare abstract class ObjectEnumValue {\r\n    constructor(arg?: symbol);\r\n    abstract _getNamespace(): string;\r\n    _getName(): string;\r\n    toString(): string;\r\n}\r\n\r\nexport declare const objectEnumValues: {\r\n    classes: {\r\n        DbNull: typeof DbNull;\r\n        JsonNull: typeof JsonNull;\r\n        AnyNull: typeof AnyNull;\r\n    };\r\n    instances: {\r\n        DbNull: DbNull;\r\n        JsonNull: JsonNull;\r\n        AnyNull: AnyNull;\r\n    };\r\n};\r\n\r\ndeclare type Operation = 'findFirst' | 'findFirstOrThrow' | 'findUnique' | 'findUniqueOrThrow' | 'findMany' | 'create' | 'createMany' | 'createManyAndReturn' | 'update' | 'updateMany' | 'updateManyAndReturn' | 'upsert' | 'delete' | 'deleteMany' | 'aggregate' | 'count' | 'groupBy' | '$queryRaw' | '$executeRaw' | '$queryRawUnsafe' | '$executeRawUnsafe' | 'findRaw' | 'aggregateRaw' | '$runCommandRaw';\r\n\r\ndeclare namespace Public {\r\n    export {\r\n        validator\r\n    }\r\n}\r\nexport { Public }\r\n\r\ndeclare type RuntimeName = 'workerd' | 'deno' | 'netlify' | 'node' | 'bun' | 'edge-light' | '';\r\n\r\ndeclare function validator<V>(): <S>(select: Exact<S, V>) => S;\r\n\r\ndeclare function validator<C, M extends Exclude<keyof C, `$${string}`>, O extends keyof C[M] & Operation>(client: C, model: M, operation: O): <S>(select: Exact<S, Args<C[M], O>>) => S;\r\n\r\ndeclare function validator<C, M extends Exclude<keyof C, `$${string}`>, O extends keyof C[M] & Operation, P extends keyof Args<C[M], O>>(client: C, model: M, operation: O, prop: P): <S>(select: Exact<S, Args<C[M], O>[P]>) => S;\r\n\r\nexport { }\r\n",
        "node_modules/.prisma/client/runtime/library.d.ts": "/**\r\n * @param this\r\n */\r\ndeclare function $extends(this: Client, extension: ExtensionArgs | ((client: Client) => Client)): Client;\r\n\r\ndeclare type AccelerateEngineConfig = {\r\n    inlineSchema: EngineConfig['inlineSchema'];\r\n    inlineSchemaHash: EngineConfig['inlineSchemaHash'];\r\n    env: EngineConfig['env'];\r\n    generator?: {\r\n        previewFeatures: string[];\r\n    };\r\n    inlineDatasources: EngineConfig['inlineDatasources'];\r\n    overrideDatasources: EngineConfig['overrideDatasources'];\r\n    clientVersion: EngineConfig['clientVersion'];\r\n    engineVersion: EngineConfig['engineVersion'];\r\n    logEmitter: EngineConfig['logEmitter'];\r\n    logQueries?: EngineConfig['logQueries'];\r\n    logLevel?: EngineConfig['logLevel'];\r\n    tracingHelper: EngineConfig['tracingHelper'];\r\n    accelerateUtils?: AccelerateUtils;\r\n};\r\n\r\ndeclare type AccelerateUtils = EngineConfig['accelerateUtils'];\r\n\r\nexport declare type Action = keyof typeof DMMF_2.ModelAction | 'executeRaw' | 'queryRaw' | 'runCommandRaw';\r\n\r\ndeclare type ActiveConnectorType = Exclude<ConnectorType, 'postgres' | 'prisma+postgres'>;\r\n\r\n/**\r\n * An interface that exposes some basic information about the\r\n * adapter like its name and provider type.\r\n */\r\ndeclare interface AdapterInfo {\r\n    readonly provider: Provider;\r\n    readonly adapterName: (typeof officialPrismaAdapters)[number] | (string & {});\r\n}\r\n\r\nexport declare type Aggregate = '_count' | '_max' | '_min' | '_avg' | '_sum';\r\n\r\nexport declare type AllModelsToStringIndex<TypeMap extends TypeMapDef, Args extends Record<string, any>, K extends PropertyKey> = Args extends {\r\n    [P in K]: {\r\n        $allModels: infer AllModels;\r\n    };\r\n} ? {\r\n    [P in K]: Record<TypeMap['meta']['modelProps'], AllModels>;\r\n} : {};\r\n\r\ndeclare class AnyNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\nexport declare type ApplyOmit<T, OmitConfig> = Compute<{\r\n    [K in keyof T as OmitValue<OmitConfig, K> extends true ? never : K]: T[K];\r\n}>;\r\n\r\nexport declare type Args<T, F extends Operation> = T extends {\r\n    [K: symbol]: {\r\n        types: {\r\n            operations: {\r\n                [K in F]: {\r\n                    args: any;\r\n                };\r\n            };\r\n        };\r\n    };\r\n} ? T[symbol]['types']['operations'][F]['args'] : any;\r\n\r\nexport declare type Args_3<T, F extends Operation> = Args<T, F>;\r\n\r\n/**\r\n * Original `quaint::ValueType` enum tag from Prisma's `quaint`.\r\n * Query arguments marked with this type are sanitized before being sent to the database.\r\n * Notice while a query argument may be `null`, `ArgType` is guaranteed to be defined.\r\n */\r\ndeclare type ArgType = 'Int32' | 'Int64' | 'Float' | 'Double' | 'Text' | 'Enum' | 'EnumArray' | 'Bytes' | 'Boolean' | 'Char' | 'Array' | 'Numeric' | 'Json' | 'Xml' | 'Uuid' | 'DateTime' | 'Date' | 'Time' | 'Unknown';\r\n\r\n/**\r\n * Attributes is a map from string to attribute values.\r\n *\r\n * Note: only the own enumerable keys are counted as valid attribute keys.\r\n */\r\ndeclare interface Attributes {\r\n    [attributeKey: string]: AttributeValue | undefined;\r\n}\r\n\r\n/**\r\n * Attribute values may be any non-nullish primitive value except an object.\r\n *\r\n * null or undefined attribute values are invalid and will result in undefined behavior.\r\n */\r\ndeclare type AttributeValue = string | number | boolean | Array<null | undefined | string> | Array<null | undefined | number> | Array<null | undefined | boolean>;\r\n\r\nexport declare type BaseDMMF = {\r\n    readonly datamodel: Omit<DMMF_2.Datamodel, 'indexes'>;\r\n};\r\n\r\ndeclare type BatchArgs = {\r\n    queries: BatchQuery[];\r\n    transaction?: {\r\n        isolationLevel?: IsolationLevel;\r\n    };\r\n};\r\n\r\ndeclare type BatchInternalParams = {\r\n    requests: RequestParams[];\r\n    customDataProxyFetch?: CustomDataProxyFetch;\r\n};\r\n\r\ndeclare type BatchQuery = {\r\n    model: string | undefined;\r\n    operation: string;\r\n    args: JsArgs | RawQueryArgs;\r\n};\r\n\r\ndeclare type BatchQueryEngineResult<T> = QueryEngineResultData<T> | Error;\r\n\r\ndeclare type BatchQueryOptionsCb = (args: BatchQueryOptionsCbArgs) => Promise<any>;\r\n\r\ndeclare type BatchQueryOptionsCbArgs = {\r\n    args: BatchArgs;\r\n    query: (args: BatchArgs, __internalParams?: BatchInternalParams) => Promise<unknown[]>;\r\n    __internalParams: BatchInternalParams;\r\n};\r\n\r\ndeclare type BatchResponse = MultiBatchResponse | CompactedBatchResponse;\r\n\r\ndeclare type BatchTransactionOptions = {\r\n    isolationLevel?: IsolationLevel;\r\n};\r\n\r\ndeclare interface BinaryTargetsEnvValue {\r\n    fromEnvVar: string | null;\r\n    value: string;\r\n    native?: boolean;\r\n}\r\n\r\nexport declare type Call<F extends Fn, P> = (F & {\r\n    params: P;\r\n})['returns'];\r\n\r\ndeclare interface CallSite {\r\n    getLocation(): LocationInFile | null;\r\n}\r\n\r\nexport declare type Cast<A, W> = A extends W ? A : W;\r\n\r\ndeclare type Client = ReturnType<typeof getPrismaClient> extends new () => infer T ? T : never;\r\n\r\nexport declare type ClientArg = {\r\n    [MethodName in string]: unknown;\r\n};\r\n\r\nexport declare type ClientArgs = {\r\n    client: ClientArg;\r\n};\r\n\r\nexport declare type ClientBuiltInProp = keyof DynamicClientExtensionThisBuiltin<never, never, never>;\r\n\r\nexport declare type ClientOptionDef = undefined | {\r\n    [K in string]: any;\r\n};\r\n\r\nexport declare type ClientOtherOps = {\r\n    $queryRaw<T = unknown>(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise<T>;\r\n    $queryRawTyped<T>(query: TypedSql<unknown[], T>): PrismaPromise<T[]>;\r\n    $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;\r\n    $executeRaw(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise<number>;\r\n    $executeRawUnsafe(query: string, ...values: any[]): PrismaPromise<number>;\r\n    $runCommandRaw(command: InputJsonObject): PrismaPromise<JsonObject>;\r\n};\r\n\r\ndeclare type ColumnType = (typeof ColumnTypeEnum)[keyof typeof ColumnTypeEnum];\r\n\r\ndeclare const ColumnTypeEnum: {\r\n    readonly Int32: 0;\r\n    readonly Int64: 1;\r\n    readonly Float: 2;\r\n    readonly Double: 3;\r\n    readonly Numeric: 4;\r\n    readonly Boolean: 5;\r\n    readonly Character: 6;\r\n    readonly Text: 7;\r\n    readonly Date: 8;\r\n    readonly Time: 9;\r\n    readonly DateTime: 10;\r\n    readonly Json: 11;\r\n    readonly Enum: 12;\r\n    readonly Bytes: 13;\r\n    readonly Set: 14;\r\n    readonly Uuid: 15;\r\n    readonly Int32Array: 64;\r\n    readonly Int64Array: 65;\r\n    readonly FloatArray: 66;\r\n    readonly DoubleArray: 67;\r\n    readonly NumericArray: 68;\r\n    readonly BooleanArray: 69;\r\n    readonly CharacterArray: 70;\r\n    readonly TextArray: 71;\r\n    readonly DateArray: 72;\r\n    readonly TimeArray: 73;\r\n    readonly DateTimeArray: 74;\r\n    readonly JsonArray: 75;\r\n    readonly EnumArray: 76;\r\n    readonly BytesArray: 77;\r\n    readonly UuidArray: 78;\r\n    readonly UnknownNumber: 128;\r\n};\r\n\r\ndeclare type CompactedBatchResponse = {\r\n    type: 'compacted';\r\n    plan: object;\r\n    arguments: Record<string, {}>[];\r\n    nestedSelection: string[];\r\n    keys: string[];\r\n    expectNonEmpty: boolean;\r\n};\r\n\r\ndeclare type CompilerWasmLoadingConfig = {\r\n    /**\r\n     * WASM-bindgen runtime for corresponding module\r\n     */\r\n    getRuntime: () => Promise<{\r\n        __wbg_set_wasm(exports: unknown): void;\r\n        QueryCompiler: QueryCompilerConstructor;\r\n    }>;\r\n    /**\r\n     * Loads the raw wasm module for the wasm compiler engine. This configuration is\r\n     * generated specifically for each type of client, eg. Node.js client and Edge\r\n     * clients will have different implementations.\r\n     * @remarks this is a callback on purpose, we only load the wasm if needed.\r\n     * @remarks only used by ClientEngine\r\n     */\r\n    getQueryCompilerWasmModule: () => Promise<unknown>;\r\n};\r\n\r\nexport declare type Compute<T> = T extends Function ? T : {\r\n    [K in keyof T]: T[K];\r\n} & unknown;\r\n\r\nexport declare type ComputeDeep<T> = T extends Function ? T : {\r\n    [K in keyof T]: ComputeDeep<T[K]>;\r\n} & unknown;\r\n\r\ndeclare type ComputedField = {\r\n    name: string;\r\n    needs: string[];\r\n    compute: ResultArgsFieldCompute;\r\n};\r\n\r\ndeclare type ComputedFieldsMap = {\r\n    [fieldName: string]: ComputedField;\r\n};\r\n\r\ndeclare type ConnectionInfo = {\r\n    schemaName?: string;\r\n    maxBindValues?: number;\r\n};\r\n\r\ndeclare type ConnectorType = 'mysql' | 'mongodb' | 'sqlite' | 'postgresql' | 'postgres' | 'prisma+postgres' | 'sqlserver' | 'cockroachdb';\r\n\r\ndeclare interface Context {\r\n    /**\r\n     * Get a value from the context.\r\n     *\r\n     * @param key key which identifies a context value\r\n     */\r\n    getValue(key: symbol): unknown;\r\n    /**\r\n     * Create a new context which inherits from this context and has\r\n     * the given key set to the given value.\r\n     *\r\n     * @param key context key for which to set the value\r\n     * @param value value to set for the given key\r\n     */\r\n    setValue(key: symbol, value: unknown): Context;\r\n    /**\r\n     * Return a new context which inherits from this context but does\r\n     * not contain a value for the given key.\r\n     *\r\n     * @param key context key for which to clear a value\r\n     */\r\n    deleteValue(key: symbol): Context;\r\n}\r\n\r\ndeclare type Context_2<T> = T extends {\r\n    [K: symbol]: {\r\n        ctx: infer C;\r\n    };\r\n} ? C & T & {\r\n    /**\r\n     * @deprecated Use `$name` instead.\r\n     */\r\n    name?: string;\r\n    $name?: string;\r\n    $parent?: unknown;\r\n} : T & {\r\n    /**\r\n     * @deprecated Use `$name` instead.\r\n     */\r\n    name?: string;\r\n    $name?: string;\r\n    $parent?: unknown;\r\n};\r\n\r\nexport declare type Count<O> = {\r\n    [K in keyof O]: Count<number>;\r\n} & {};\r\n\r\nexport declare function createParam(name: string): Param<unknown, string>;\r\n\r\n/**\r\n * Custom fetch function for `DataProxyEngine`.\r\n *\r\n * We can't use the actual type of `globalThis.fetch` because this will result\r\n * in API Extractor referencing Node.js type definitions in the `.d.ts` bundle\r\n * for the client runtime. We can only use such types in internal types that\r\n * don't end up exported anywhere.\r\n\r\n * It's also not possible to write a definition of `fetch` that would accept the\r\n * actual `fetch` function from different environments such as Node.js and\r\n * Cloudflare Workers (with their extensions to `RequestInit` and `Response`).\r\n * `fetch` is used in both covariant and contravariant positions in\r\n * `CustomDataProxyFetch`, making it invariant, so we need the exact same type.\r\n * Even if we removed the argument and left `fetch` in covariant position only,\r\n * then for an extension-supplied function to be assignable to `customDataProxyFetch`,\r\n * the platform-specific (or custom) `fetch` function needs to be assignable\r\n * to our `fetch` definition. This, in turn, requires the third-party `Response`\r\n * to be a subtype of our `Response` (which is not a problem, we could declare\r\n * a minimal `Response` type that only includes what we use) *and* requires the\r\n * third-party `RequestInit` to be a supertype of our `RequestInit` (i.e. we\r\n * have to declare all properties any `RequestInit` implementation in existence\r\n * could possibly have), which is not possible.\r\n *\r\n * Since `@prisma/extension-accelerate` redefines the type of\r\n * `__internalParams.customDataProxyFetch` to its own type anyway (probably for\r\n * exactly this reason), our definition is never actually used and is completely\r\n * ignored, so it doesn't matter, and we can just use `unknown` as the type of\r\n * `fetch` here.\r\n */\r\ndeclare type CustomDataProxyFetch = (fetch: unknown) => unknown;\r\n\r\ndeclare class DataLoader<T = unknown> {\r\n    private options;\r\n    batches: {\r\n        [key: string]: Job[];\r\n    };\r\n    private tickActive;\r\n    constructor(options: DataLoaderOptions<T>);\r\n    request(request: T): Promise<any>;\r\n    private dispatchBatches;\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\ndeclare type DataLoaderOptions<T> = {\r\n    singleLoader: (request: T) => Promise<any>;\r\n    batchLoader: (request: T[]) => Promise<any[]>;\r\n    batchBy: (request: T) => string | undefined;\r\n    batchOrder: (requestA: T, requestB: T) => number;\r\n};\r\n\r\ndeclare type Datamodel = ReadonlyDeep_2<{\r\n    models: Model[];\r\n    enums: DatamodelEnum[];\r\n    types: Model[];\r\n    indexes: Index[];\r\n}>;\r\n\r\ndeclare type DatamodelEnum = ReadonlyDeep_2<{\r\n    name: string;\r\n    values: EnumValue[];\r\n    dbName?: string | null;\r\n    documentation?: string;\r\n}>;\r\n\r\ndeclare function datamodelEnumToSchemaEnum(datamodelEnum: DatamodelEnum): SchemaEnum;\r\n\r\ndeclare type Datasource = {\r\n    url?: string;\r\n};\r\n\r\ndeclare type Datasources = {\r\n    [name in string]: Datasource;\r\n};\r\n\r\ndeclare class DbNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\nexport declare const Debug: typeof debugCreate & {\r\n    enable(namespace: any): void;\r\n    disable(): any;\r\n    enabled(namespace: string): boolean;\r\n    log: (...args: string[]) => void;\r\n    formatters: {};\r\n};\r\n\r\n/**\r\n * Create a new debug instance with the given namespace.\r\n *\r\n * @example\r\n * ```ts\r\n * import Debug from '@prisma/debug'\r\n * const debug = Debug('prisma:client')\r\n * debug('Hello World')\r\n * ```\r\n */\r\ndeclare function debugCreate(namespace: string): ((...args: any[]) => void) & {\r\n    color: string;\r\n    enabled: boolean;\r\n    namespace: string;\r\n    log: (...args: string[]) => void;\r\n    extend: () => void;\r\n};\r\n\r\nexport declare function Decimal(n: Decimal.Value): Decimal;\r\n\r\nexport declare namespace Decimal {\r\n    export type Constructor = typeof Decimal;\r\n    export type Instance = Decimal;\r\n    export type Rounding = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8;\r\n    export type Modulo = Rounding | 9;\r\n    export type Value = string | number | Decimal;\r\n\r\n    // http://mikemcl.github.io/decimal.js/#constructor-properties\r\n    export interface Config {\r\n        precision?: number;\r\n        rounding?: Rounding;\r\n        toExpNeg?: number;\r\n        toExpPos?: number;\r\n        minE?: number;\r\n        maxE?: number;\r\n        crypto?: boolean;\r\n        modulo?: Modulo;\r\n        defaults?: boolean;\r\n    }\r\n}\r\n\r\nexport declare class Decimal {\r\n    readonly d: number[];\r\n    readonly e: number;\r\n    readonly s: number;\r\n\r\n    constructor(n: Decimal.Value);\r\n\r\n    absoluteValue(): Decimal;\r\n    abs(): Decimal;\r\n\r\n    ceil(): Decimal;\r\n\r\n    clampedTo(min: Decimal.Value, max: Decimal.Value): Decimal;\r\n    clamp(min: Decimal.Value, max: Decimal.Value): Decimal;\r\n\r\n    comparedTo(n: Decimal.Value): number;\r\n    cmp(n: Decimal.Value): number;\r\n\r\n    cosine(): Decimal;\r\n    cos(): Decimal;\r\n\r\n    cubeRoot(): Decimal;\r\n    cbrt(): Decimal;\r\n\r\n    decimalPlaces(): number;\r\n    dp(): number;\r\n\r\n    dividedBy(n: Decimal.Value): Decimal;\r\n    div(n: Decimal.Value): Decimal;\r\n\r\n    dividedToIntegerBy(n: Decimal.Value): Decimal;\r\n    divToInt(n: Decimal.Value): Decimal;\r\n\r\n    equals(n: Decimal.Value): boolean;\r\n    eq(n: Decimal.Value): boolean;\r\n\r\n    floor(): Decimal;\r\n\r\n    greaterThan(n: Decimal.Value): boolean;\r\n    gt(n: Decimal.Value): boolean;\r\n\r\n    greaterThanOrEqualTo(n: Decimal.Value): boolean;\r\n    gte(n: Decimal.Value): boolean;\r\n\r\n    hyperbolicCosine(): Decimal;\r\n    cosh(): Decimal;\r\n\r\n    hyperbolicSine(): Decimal;\r\n    sinh(): Decimal;\r\n\r\n    hyperbolicTangent(): Decimal;\r\n    tanh(): Decimal;\r\n\r\n    inverseCosine(): Decimal;\r\n    acos(): Decimal;\r\n\r\n    inverseHyperbolicCosine(): Decimal;\r\n    acosh(): Decimal;\r\n\r\n    inverseHyperbolicSine(): Decimal;\r\n    asinh(): Decimal;\r\n\r\n    inverseHyperbolicTangent(): Decimal;\r\n    atanh(): Decimal;\r\n\r\n    inverseSine(): Decimal;\r\n    asin(): Decimal;\r\n\r\n    inverseTangent(): Decimal;\r\n    atan(): Decimal;\r\n\r\n    isFinite(): boolean;\r\n\r\n    isInteger(): boolean;\r\n    isInt(): boolean;\r\n\r\n    isNaN(): boolean;\r\n\r\n    isNegative(): boolean;\r\n    isNeg(): boolean;\r\n\r\n    isPositive(): boolean;\r\n    isPos(): boolean;\r\n\r\n    isZero(): boolean;\r\n\r\n    lessThan(n: Decimal.Value): boolean;\r\n    lt(n: Decimal.Value): boolean;\r\n\r\n    lessThanOrEqualTo(n: Decimal.Value): boolean;\r\n    lte(n: Decimal.Value): boolean;\r\n\r\n    logarithm(n?: Decimal.Value): Decimal;\r\n    log(n?: Decimal.Value): Decimal;\r\n\r\n    minus(n: Decimal.Value): Decimal;\r\n    sub(n: Decimal.Value): Decimal;\r\n\r\n    modulo(n: Decimal.Value): Decimal;\r\n    mod(n: Decimal.Value): Decimal;\r\n\r\n    naturalExponential(): Decimal;\r\n    exp(): Decimal;\r\n\r\n    naturalLogarithm(): Decimal;\r\n    ln(): Decimal;\r\n\r\n    negated(): Decimal;\r\n    neg(): Decimal;\r\n\r\n    plus(n: Decimal.Value): Decimal;\r\n    add(n: Decimal.Value): Decimal;\r\n\r\n    precision(includeZeros?: boolean): number;\r\n    sd(includeZeros?: boolean): number;\r\n\r\n    round(): Decimal;\r\n\r\n    sine() : Decimal;\r\n    sin() : Decimal;\r\n\r\n    squareRoot(): Decimal;\r\n    sqrt(): Decimal;\r\n\r\n    tangent() : Decimal;\r\n    tan() : Decimal;\r\n\r\n    times(n: Decimal.Value): Decimal;\r\n    mul(n: Decimal.Value) : Decimal;\r\n\r\n    toBinary(significantDigits?: number): string;\r\n    toBinary(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toDecimalPlaces(decimalPlaces?: number): Decimal;\r\n    toDecimalPlaces(decimalPlaces: number, rounding: Decimal.Rounding): Decimal;\r\n    toDP(decimalPlaces?: number): Decimal;\r\n    toDP(decimalPlaces: number, rounding: Decimal.Rounding): Decimal;\r\n\r\n    toExponential(decimalPlaces?: number): string;\r\n    toExponential(decimalPlaces: number, rounding: Decimal.Rounding): string;\r\n\r\n    toFixed(decimalPlaces?: number): string;\r\n    toFixed(decimalPlaces: number, rounding: Decimal.Rounding): string;\r\n\r\n    toFraction(max_denominator?: Decimal.Value): Decimal[];\r\n\r\n    toHexadecimal(significantDigits?: number): string;\r\n    toHexadecimal(significantDigits: number, rounding: Decimal.Rounding): string;\r\n    toHex(significantDigits?: number): string;\r\n    toHex(significantDigits: number, rounding?: Decimal.Rounding): string;\r\n\r\n    toJSON(): string;\r\n\r\n    toNearest(n: Decimal.Value, rounding?: Decimal.Rounding): Decimal;\r\n\r\n    toNumber(): number;\r\n\r\n    toOctal(significantDigits?: number): string;\r\n    toOctal(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toPower(n: Decimal.Value): Decimal;\r\n    pow(n: Decimal.Value): Decimal;\r\n\r\n    toPrecision(significantDigits?: number): string;\r\n    toPrecision(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toSignificantDigits(significantDigits?: number): Decimal;\r\n    toSignificantDigits(significantDigits: number, rounding: Decimal.Rounding): Decimal;\r\n    toSD(significantDigits?: number): Decimal;\r\n    toSD(significantDigits: number, rounding: Decimal.Rounding): Decimal;\r\n\r\n    toString(): string;\r\n\r\n    truncated(): Decimal;\r\n    trunc(): Decimal;\r\n\r\n    valueOf(): string;\r\n\r\n    static abs(n: Decimal.Value): Decimal;\r\n    static acos(n: Decimal.Value): Decimal;\r\n    static acosh(n: Decimal.Value): Decimal;\r\n    static add(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static asin(n: Decimal.Value): Decimal;\r\n    static asinh(n: Decimal.Value): Decimal;\r\n    static atan(n: Decimal.Value): Decimal;\r\n    static atanh(n: Decimal.Value): Decimal;\r\n    static atan2(y: Decimal.Value, x: Decimal.Value): Decimal;\r\n    static cbrt(n: Decimal.Value): Decimal;\r\n    static ceil(n: Decimal.Value): Decimal;\r\n    static clamp(n: Decimal.Value, min: Decimal.Value, max: Decimal.Value): Decimal;\r\n    static clone(object?: Decimal.Config): Decimal.Constructor;\r\n    static config(object: Decimal.Config): Decimal.Constructor;\r\n    static cos(n: Decimal.Value): Decimal;\r\n    static cosh(n: Decimal.Value): Decimal;\r\n    static div(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static exp(n: Decimal.Value): Decimal;\r\n    static floor(n: Decimal.Value): Decimal;\r\n    static hypot(...n: Decimal.Value[]): Decimal;\r\n    static isDecimal(object: any): object is Decimal;\r\n    static ln(n: Decimal.Value): Decimal;\r\n    static log(n: Decimal.Value, base?: Decimal.Value): Decimal;\r\n    static log2(n: Decimal.Value): Decimal;\r\n    static log10(n: Decimal.Value): Decimal;\r\n    static max(...n: Decimal.Value[]): Decimal;\r\n    static min(...n: Decimal.Value[]): Decimal;\r\n    static mod(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static mul(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static noConflict(): Decimal.Constructor;   // Browser only\r\n    static pow(base: Decimal.Value, exponent: Decimal.Value): Decimal;\r\n    static random(significantDigits?: number): Decimal;\r\n    static round(n: Decimal.Value): Decimal;\r\n    static set(object: Decimal.Config): Decimal.Constructor;\r\n    static sign(n: Decimal.Value): number;\r\n    static sin(n: Decimal.Value): Decimal;\r\n    static sinh(n: Decimal.Value): Decimal;\r\n    static sqrt(n: Decimal.Value): Decimal;\r\n    static sub(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static sum(...n: Decimal.Value[]): Decimal;\r\n    static tan(n: Decimal.Value): Decimal;\r\n    static tanh(n: Decimal.Value): Decimal;\r\n    static trunc(n: Decimal.Value): Decimal;\r\n\r\n    static readonly default?: Decimal.Constructor;\r\n    static readonly Decimal?: Decimal.Constructor;\r\n\r\n    static readonly precision: number;\r\n    static readonly rounding: Decimal.Rounding;\r\n    static readonly toExpNeg: number;\r\n    static readonly toExpPos: number;\r\n    static readonly minE: number;\r\n    static readonly maxE: number;\r\n    static readonly crypto: boolean;\r\n    static readonly modulo: Decimal.Modulo;\r\n\r\n    static readonly ROUND_UP: 0;\r\n    static readonly ROUND_DOWN: 1;\r\n    static readonly ROUND_CEIL: 2;\r\n    static readonly ROUND_FLOOR: 3;\r\n    static readonly ROUND_HALF_UP: 4;\r\n    static readonly ROUND_HALF_DOWN: 5;\r\n    static readonly ROUND_HALF_EVEN: 6;\r\n    static readonly ROUND_HALF_CEIL: 7;\r\n    static readonly ROUND_HALF_FLOOR: 8;\r\n    static readonly EUCLID: 9;\r\n}\r\n\r\n/**\r\n * Interface for any Decimal.js-like library\r\n * Allows us to accept Decimal.js from different\r\n * versions and some compatible alternatives\r\n */\r\nexport declare interface DecimalJsLike {\r\n    d: number[];\r\n    e: number;\r\n    s: number;\r\n    toFixed(): string;\r\n}\r\n\r\nexport declare type DefaultArgs = InternalArgs<{}, {}, {}, {}>;\r\n\r\nexport declare type DefaultSelection<Payload extends OperationPayload, Args = {}, GlobalOmitOptions = {}> = Args extends {\r\n    omit: infer LocalOmit;\r\n} ? ApplyOmit<UnwrapPayload<{\r\n    default: Payload;\r\n}>['default'], PatchFlat<LocalOmit, ExtractGlobalOmit<GlobalOmitOptions, Uncapitalize<Payload['name']>>>> : ApplyOmit<UnwrapPayload<{\r\n    default: Payload;\r\n}>['default'], ExtractGlobalOmit<GlobalOmitOptions, Uncapitalize<Payload['name']>>>;\r\n\r\nexport declare function defineDmmfProperty(target: object, runtimeDataModel: RuntimeDataModel): void;\r\n\r\ndeclare function defineExtension(ext: ExtensionArgs | ((client: Client) => Client)): (client: Client) => Client;\r\n\r\ndeclare const denylist: readonly [\"$connect\", \"$disconnect\", \"$on\", \"$transaction\", \"$use\", \"$extends\"];\r\n\r\ndeclare type Deprecation = ReadonlyDeep_2<{\r\n    sinceVersion: string;\r\n    reason: string;\r\n    plannedRemovalVersion?: string;\r\n}>;\r\n\r\ndeclare type DeserializedResponse = Array<Record<string, unknown>>;\r\n\r\nexport declare function deserializeJsonResponse(result: unknown): unknown;\r\n\r\nexport declare function deserializeRawResult(response: RawResponse): DeserializedResponse;\r\n\r\nexport declare type DevTypeMapDef = {\r\n    meta: {\r\n        modelProps: string;\r\n    };\r\n    model: {\r\n        [Model in PropertyKey]: {\r\n            [Operation in PropertyKey]: DevTypeMapFnDef;\r\n        };\r\n    };\r\n    other: {\r\n        [Operation in PropertyKey]: DevTypeMapFnDef;\r\n    };\r\n};\r\n\r\nexport declare type DevTypeMapFnDef = {\r\n    args: any;\r\n    result: any;\r\n    payload: OperationPayload;\r\n};\r\n\r\nexport declare namespace DMMF {\r\n    export {\r\n        datamodelEnumToSchemaEnum,\r\n        Document_2 as Document,\r\n        Mappings,\r\n        OtherOperationMappings,\r\n        DatamodelEnum,\r\n        SchemaEnum,\r\n        EnumValue,\r\n        Datamodel,\r\n        uniqueIndex,\r\n        PrimaryKey,\r\n        Model,\r\n        FieldKind,\r\n        FieldNamespace,\r\n        FieldLocation,\r\n        Field,\r\n        FieldDefault,\r\n        FieldDefaultScalar,\r\n        Index,\r\n        IndexType,\r\n        IndexField,\r\n        SortOrder,\r\n        Schema,\r\n        Query,\r\n        QueryOutput,\r\n        TypeRef,\r\n        InputTypeRef,\r\n        SchemaArg,\r\n        OutputType,\r\n        SchemaField,\r\n        OutputTypeRef,\r\n        Deprecation,\r\n        InputType,\r\n        FieldRefType,\r\n        FieldRefAllowType,\r\n        ModelMapping,\r\n        ModelAction\r\n    }\r\n}\r\n\r\ndeclare namespace DMMF_2 {\r\n    export {\r\n        datamodelEnumToSchemaEnum,\r\n        Document_2 as Document,\r\n        Mappings,\r\n        OtherOperationMappings,\r\n        DatamodelEnum,\r\n        SchemaEnum,\r\n        EnumValue,\r\n        Datamodel,\r\n        uniqueIndex,\r\n        PrimaryKey,\r\n        Model,\r\n        FieldKind,\r\n        FieldNamespace,\r\n        FieldLocation,\r\n        Field,\r\n        FieldDefault,\r\n        FieldDefaultScalar,\r\n        Index,\r\n        IndexType,\r\n        IndexField,\r\n        SortOrder,\r\n        Schema,\r\n        Query,\r\n        QueryOutput,\r\n        TypeRef,\r\n        InputTypeRef,\r\n        SchemaArg,\r\n        OutputType,\r\n        SchemaField,\r\n        OutputTypeRef,\r\n        Deprecation,\r\n        InputType,\r\n        FieldRefType,\r\n        FieldRefAllowType,\r\n        ModelMapping,\r\n        ModelAction\r\n    }\r\n}\r\n\r\nexport declare function dmmfToRuntimeDataModel(dmmfDataModel: DMMF_2.Datamodel): RuntimeDataModel;\r\n\r\ndeclare type Document_2 = ReadonlyDeep_2<{\r\n    datamodel: Datamodel;\r\n    schema: Schema;\r\n    mappings: Mappings;\r\n}>;\r\n\r\n/**\r\n * A generic driver adapter factory that allows the user to instantiate a\r\n * driver adapter. The query and result types are specific to the adapter.\r\n */\r\ndeclare interface DriverAdapterFactory<Query, Result> extends AdapterInfo {\r\n    /**\r\n     * Instantiate a driver adapter.\r\n     */\r\n    connect(): Promise<Queryable<Query, Result>>;\r\n}\r\n\r\n/** Client */\r\nexport declare type DynamicClientExtensionArgs<C_, TypeMap extends TypeMapDef, TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>> = {\r\n    [P in keyof C_]: unknown;\r\n} & {\r\n    [K: symbol]: {\r\n        ctx: Optional<DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>, ITXClientDenyList> & {\r\n            $parent: Optional<DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>, ITXClientDenyList>;\r\n        };\r\n    };\r\n};\r\n\r\nexport declare type DynamicClientExtensionThis<TypeMap extends TypeMapDef, TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>> = {\r\n    [P in keyof ExtArgs['client']]: Return<ExtArgs['client'][P]>;\r\n} & {\r\n    [P in Exclude<TypeMap['meta']['modelProps'], keyof ExtArgs['client']>]: DynamicModelExtensionThis<TypeMap, ModelKey<TypeMap, P>, ExtArgs>;\r\n} & {\r\n    [P in Exclude<keyof TypeMap['other']['operations'], keyof ExtArgs['client']>]: P extends keyof ClientOtherOps ? ClientOtherOps[P] : never;\r\n} & {\r\n    [P in Exclude<ClientBuiltInProp, keyof ExtArgs['client']>]: DynamicClientExtensionThisBuiltin<TypeMap, TypeMapCb, ExtArgs>[P];\r\n} & {\r\n    [K: symbol]: {\r\n        types: TypeMap['other'];\r\n    };\r\n};\r\n\r\nexport declare type DynamicClientExtensionThisBuiltin<TypeMap extends TypeMapDef, TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>> = {\r\n    $extends: ExtendsHook<'extends', TypeMapCb, ExtArgs, Call<TypeMapCb, {\r\n        extArgs: ExtArgs;\r\n    }>>;\r\n    $transaction<P extends PrismaPromise<any>[]>(arg: [...P], options?: {\r\n        isolationLevel?: TypeMap['meta']['txIsolationLevel'];\r\n    }): Promise<UnwrapTuple<P>>;\r\n    $transaction<R>(fn: (client: Omit<DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>, ITXClientDenyList>) => Promise<R>, options?: {\r\n        maxWait?: number;\r\n        timeout?: number;\r\n        isolationLevel?: TypeMap['meta']['txIsolationLevel'];\r\n    }): Promise<R>;\r\n    $disconnect(): Promise<void>;\r\n    $connect(): Promise<void>;\r\n};\r\n\r\n/** Model */\r\nexport declare type DynamicModelExtensionArgs<M_, TypeMap extends TypeMapDef, TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>> = {\r\n    [K in keyof M_]: K extends '$allModels' ? {\r\n        [P in keyof M_[K]]?: unknown;\r\n    } & {\r\n        [K: symbol]: {};\r\n    } : K extends TypeMap['meta']['modelProps'] ? {\r\n        [P in keyof M_[K]]?: unknown;\r\n    } & {\r\n        [K: symbol]: {\r\n            ctx: DynamicModelExtensionThis<TypeMap, ModelKey<TypeMap, K>, ExtArgs> & {\r\n                $parent: DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>;\r\n            } & {\r\n                $name: ModelKey<TypeMap, K>;\r\n            } & {\r\n                /**\r\n                 * @deprecated Use `$name` instead.\r\n                 */\r\n                name: ModelKey<TypeMap, K>;\r\n            };\r\n        };\r\n    } : never;\r\n};\r\n\r\nexport declare type DynamicModelExtensionFluentApi<TypeMap extends TypeMapDef, M extends PropertyKey, P extends PropertyKey, Null> = {\r\n    [K in keyof TypeMap['model'][M]['payload']['objects']]: <A>(args?: Exact<A, Path<TypeMap['model'][M]['operations'][P]['args']['select'], [K]>>) => PrismaPromise<Path<DynamicModelExtensionFnResultBase<TypeMap, M, {\r\n        select: {\r\n            [P in K]: A;\r\n        };\r\n    }, P>, [K]> | Null> & DynamicModelExtensionFluentApi<TypeMap, (TypeMap['model'][M]['payload']['objects'][K] & {})['name'], P, Null | Select<TypeMap['model'][M]['payload']['objects'][K], null>>;\r\n};\r\n\r\nexport declare type DynamicModelExtensionFnResult<TypeMap extends TypeMapDef, M extends PropertyKey, A, P extends PropertyKey, Null> = P extends FluentOperation ? DynamicModelExtensionFluentApi<TypeMap, M, P, Null> & PrismaPromise<DynamicModelExtensionFnResultBase<TypeMap, M, A, P> | Null> : PrismaPromise<DynamicModelExtensionFnResultBase<TypeMap, M, A, P>>;\r\n\r\nexport declare type DynamicModelExtensionFnResultBase<TypeMap extends TypeMapDef, M extends PropertyKey, A, P extends PropertyKey> = GetResult<TypeMap['model'][M]['payload'], A, P & Operation, TypeMap['globalOmitOptions']>;\r\n\r\nexport declare type DynamicModelExtensionFnResultNull<P extends PropertyKey> = P extends 'findUnique' | 'findFirst' ? null : never;\r\n\r\nexport declare type DynamicModelExtensionOperationFn<TypeMap extends TypeMapDef, M extends PropertyKey, P extends PropertyKey> = {} extends TypeMap['model'][M]['operations'][P]['args'] ? <A extends TypeMap['model'][M]['operations'][P]['args']>(args?: Exact<A, TypeMap['model'][M]['operations'][P]['args']>) => DynamicModelExtensionFnResult<TypeMap, M, A, P, DynamicModelExtensionFnResultNull<P>> : <A extends TypeMap['model'][M]['operations'][P]['args']>(args: Exact<A, TypeMap['model'][M]['operations'][P]['args']>) => DynamicModelExtensionFnResult<TypeMap, M, A, P, DynamicModelExtensionFnResultNull<P>>;\r\n\r\nexport declare type DynamicModelExtensionThis<TypeMap extends TypeMapDef, M extends PropertyKey, ExtArgs extends Record<string, any>> = {\r\n    [P in keyof ExtArgs['model'][Uncapitalize<M & string>]]: Return<ExtArgs['model'][Uncapitalize<M & string>][P]>;\r\n} & {\r\n    [P in Exclude<keyof TypeMap['model'][M]['operations'], keyof ExtArgs['model'][Uncapitalize<M & string>]>]: DynamicModelExtensionOperationFn<TypeMap, M, P>;\r\n} & {\r\n    [P in Exclude<'fields', keyof ExtArgs['model'][Uncapitalize<M & string>]>]: TypeMap['model'][M]['fields'];\r\n} & {\r\n    [K: symbol]: {\r\n        types: TypeMap['model'][M];\r\n    };\r\n};\r\n\r\n/** Query */\r\nexport declare type DynamicQueryExtensionArgs<Q_, TypeMap extends TypeMapDef> = {\r\n    [K in keyof Q_]: K extends '$allOperations' ? (args: {\r\n        model?: string;\r\n        operation: string;\r\n        args: any;\r\n        query: (args: any) => PrismaPromise<any>;\r\n    }) => Promise<any> : K extends '$allModels' ? {\r\n        [P in keyof Q_[K] | keyof TypeMap['model'][keyof TypeMap['model']]['operations'] | '$allOperations']?: P extends '$allOperations' ? DynamicQueryExtensionCb<TypeMap, 'model', keyof TypeMap['model'], keyof TypeMap['model'][keyof TypeMap['model']]['operations']> : P extends keyof TypeMap['model'][keyof TypeMap['model']]['operations'] ? DynamicQueryExtensionCb<TypeMap, 'model', keyof TypeMap['model'], P> : never;\r\n    } : K extends TypeMap['meta']['modelProps'] ? {\r\n        [P in keyof Q_[K] | keyof TypeMap['model'][ModelKey<TypeMap, K>]['operations'] | '$allOperations']?: P extends '$allOperations' ? DynamicQueryExtensionCb<TypeMap, 'model', ModelKey<TypeMap, K>, keyof TypeMap['model'][ModelKey<TypeMap, K>]['operations']> : P extends keyof TypeMap['model'][ModelKey<TypeMap, K>]['operations'] ? DynamicQueryExtensionCb<TypeMap, 'model', ModelKey<TypeMap, K>, P> : never;\r\n    } : K extends keyof TypeMap['other']['operations'] ? DynamicQueryExtensionCb<[TypeMap], 0, 'other', K> : never;\r\n};\r\n\r\nexport declare type DynamicQueryExtensionCb<TypeMap extends TypeMapDef, _0 extends PropertyKey, _1 extends PropertyKey, _2 extends PropertyKey> = <A extends DynamicQueryExtensionCbArgs<TypeMap, _0, _1, _2>>(args: A) => Promise<TypeMap[_0][_1][_2]['result']>;\r\n\r\nexport declare type DynamicQueryExtensionCbArgs<TypeMap extends TypeMapDef, _0 extends PropertyKey, _1 extends PropertyKey, _2 extends PropertyKey> = (_1 extends unknown ? _2 extends unknown ? {\r\n    args: DynamicQueryExtensionCbArgsArgs<TypeMap, _0, _1, _2>;\r\n    model: _0 extends 0 ? undefined : _1;\r\n    operation: _2;\r\n    query: <A extends DynamicQueryExtensionCbArgsArgs<TypeMap, _0, _1, _2>>(args: A) => PrismaPromise<TypeMap[_0][_1]['operations'][_2]['result']>;\r\n} : never : never) & {\r\n    query: (args: DynamicQueryExtensionCbArgsArgs<TypeMap, _0, _1, _2>) => PrismaPromise<TypeMap[_0][_1]['operations'][_2]['result']>;\r\n};\r\n\r\nexport declare type DynamicQueryExtensionCbArgsArgs<TypeMap extends TypeMapDef, _0 extends PropertyKey, _1 extends PropertyKey, _2 extends PropertyKey> = _2 extends '$queryRaw' | '$executeRaw' ? Sql : TypeMap[_0][_1]['operations'][_2]['args'];\r\n\r\n/** Result */\r\nexport declare type DynamicResultExtensionArgs<R_, TypeMap extends TypeMapDef> = {\r\n    [K in keyof R_]: {\r\n        [P in keyof R_[K]]?: {\r\n            needs?: DynamicResultExtensionNeeds<TypeMap, ModelKey<TypeMap, K>, R_[K][P]>;\r\n            compute(data: DynamicResultExtensionData<TypeMap, ModelKey<TypeMap, K>, R_[K][P]>): any;\r\n        };\r\n    };\r\n};\r\n\r\nexport declare type DynamicResultExtensionData<TypeMap extends TypeMapDef, M extends PropertyKey, S> = GetFindResult<TypeMap['model'][M]['payload'], {\r\n    select: S;\r\n}, {}>;\r\n\r\nexport declare type DynamicResultExtensionNeeds<TypeMap extends TypeMapDef, M extends PropertyKey, S> = {\r\n    [K in keyof S]: K extends keyof TypeMap['model'][M]['payload']['scalars'] ? S[K] : never;\r\n} & {\r\n    [N in keyof TypeMap['model'][M]['payload']['scalars']]?: boolean;\r\n};\r\n\r\n/**\r\n * Placeholder value for \"no text\".\r\n */\r\nexport declare const empty: Sql;\r\n\r\nexport declare type EmptyToUnknown<T> = T;\r\n\r\ndeclare interface Engine<InteractiveTransactionPayload = unknown> {\r\n    /** The name of the engine. This is meant to be consumed externally */\r\n    readonly name: string;\r\n    onBeforeExit(callback: () => Promise<void>): void;\r\n    start(): Promise<void>;\r\n    stop(): Promise<void>;\r\n    version(forceRun?: boolean): Promise<string> | string;\r\n    request<T>(query: JsonQuery, options: RequestOptions<InteractiveTransactionPayload>): Promise<QueryEngineResultData<T>>;\r\n    requestBatch<T>(queries: JsonQuery[], options: RequestBatchOptions<InteractiveTransactionPayload>): Promise<BatchQueryEngineResult<T>[]>;\r\n    transaction(action: 'start', headers: Transaction_2.TransactionHeaders, options: Transaction_2.Options): Promise<Transaction_2.InteractiveTransactionInfo<unknown>>;\r\n    transaction(action: 'commit', headers: Transaction_2.TransactionHeaders, info: Transaction_2.InteractiveTransactionInfo<unknown>): Promise<void>;\r\n    transaction(action: 'rollback', headers: Transaction_2.TransactionHeaders, info: Transaction_2.InteractiveTransactionInfo<unknown>): Promise<void>;\r\n    metrics(options: MetricsOptionsJson): Promise<Metrics>;\r\n    metrics(options: MetricsOptionsPrometheus): Promise<string>;\r\n    applyPendingMigrations(): Promise<void>;\r\n}\r\n\r\ndeclare interface EngineConfig {\r\n    cwd: string;\r\n    dirname: string;\r\n    enableDebugLogs?: boolean;\r\n    allowTriggerPanic?: boolean;\r\n    prismaPath?: string;\r\n    generator?: GeneratorConfig;\r\n    /**\r\n     * @remarks this field is used internally by Policy, do not rename or remove\r\n     */\r\n    overrideDatasources: Datasources;\r\n    showColors?: boolean;\r\n    logQueries?: boolean;\r\n    logLevel?: 'info' | 'warn';\r\n    env: Record<string, string>;\r\n    flags?: string[];\r\n    clientVersion: string;\r\n    engineVersion: string;\r\n    previewFeatures?: string[];\r\n    engineEndpoint?: string;\r\n    activeProvider?: string;\r\n    logEmitter: LogEmitter;\r\n    transactionOptions: Transaction_2.Options;\r\n    /**\r\n     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`.\r\n     * If set, this is only used in the library engine, and all queries would be performed through it,\r\n     * rather than Prisma's Rust drivers.\r\n     * @remarks only used by LibraryEngine.ts\r\n     */\r\n    adapter?: SqlDriverAdapterFactory;\r\n    /**\r\n     * The contents of the schema encoded into a string\r\n     */\r\n    inlineSchema: string;\r\n    /**\r\n     * The contents of the datasource url saved in a string\r\n     * @remarks only used by DataProxyEngine.ts\r\n     * @remarks this field is used internally by Policy, do not rename or remove\r\n     */\r\n    inlineDatasources: GetPrismaClientConfig['inlineDatasources'];\r\n    /**\r\n     * The string hash that was produced for a given schema\r\n     * @remarks only used by DataProxyEngine.ts\r\n     */\r\n    inlineSchemaHash: string;\r\n    /**\r\n     * The helper for interaction with OTEL tracing\r\n     * @remarks enabling is determined by the client and @prisma/instrumentation package\r\n     */\r\n    tracingHelper: TracingHelper;\r\n    /**\r\n     * Information about whether we have not found a schema.prisma file in the\r\n     * default location, and that we fell back to finding the schema.prisma file\r\n     * in the current working directory. This usually means it has been bundled.\r\n     */\r\n    isBundled?: boolean;\r\n    /**\r\n     * Web Assembly module loading configuration\r\n     */\r\n    engineWasm?: EngineWasmLoadingConfig;\r\n    compilerWasm?: CompilerWasmLoadingConfig;\r\n    /**\r\n     * Allows Accelerate to use runtime utilities from the client. These are\r\n     * necessary for the AccelerateEngine to function correctly.\r\n     */\r\n    accelerateUtils?: {\r\n        resolveDatasourceUrl: typeof resolveDatasourceUrl;\r\n        getBatchRequestPayload: typeof getBatchRequestPayload;\r\n        prismaGraphQLToJSError: typeof prismaGraphQLToJSError;\r\n        PrismaClientUnknownRequestError: typeof PrismaClientUnknownRequestError;\r\n        PrismaClientInitializationError: typeof PrismaClientInitializationError;\r\n        PrismaClientKnownRequestError: typeof PrismaClientKnownRequestError;\r\n        debug: (...args: any[]) => void;\r\n        engineVersion: string;\r\n        clientVersion: string;\r\n    };\r\n}\r\n\r\ndeclare type EngineEvent<E extends EngineEventType> = E extends QueryEventType ? QueryEvent : LogEvent;\r\n\r\ndeclare type EngineEventType = QueryEventType | LogEventType;\r\n\r\ndeclare type EngineSpan = {\r\n    id: EngineSpanId;\r\n    parentId: string | null;\r\n    name: string;\r\n    startTime: HrTime;\r\n    endTime: HrTime;\r\n    kind: EngineSpanKind;\r\n    attributes?: Record<string, unknown>;\r\n    links?: EngineSpanId[];\r\n};\r\n\r\ndeclare type EngineSpanId = string;\r\n\r\ndeclare type EngineSpanKind = 'client' | 'internal';\r\n\r\ndeclare type EngineWasmLoadingConfig = {\r\n    /**\r\n     * WASM-bindgen runtime for corresponding module\r\n     */\r\n    getRuntime: () => Promise<{\r\n        __wbg_set_wasm(exports: unknown): void;\r\n        QueryEngine: QueryEngineConstructor;\r\n    }>;\r\n    /**\r\n     * Loads the raw wasm module for the wasm query engine. This configuration is\r\n     * generated specifically for each type of client, eg. Node.js client and Edge\r\n     * clients will have different implementations.\r\n     * @remarks this is a callback on purpose, we only load the wasm if needed.\r\n     * @remarks only used by LibraryEngine\r\n     */\r\n    getQueryEngineWasmModule: () => Promise<unknown>;\r\n};\r\n\r\ndeclare type EnumValue = ReadonlyDeep_2<{\r\n    name: string;\r\n    dbName: string | null;\r\n}>;\r\n\r\ndeclare type EnvPaths = {\r\n    rootEnvPath: string | null;\r\n    schemaEnvPath: string | undefined;\r\n};\r\n\r\ndeclare interface EnvValue {\r\n    fromEnvVar: null | string;\r\n    value: null | string;\r\n}\r\n\r\nexport declare type Equals<A, B> = (<T>() => T extends A ? 1 : 2) extends (<T>() => T extends B ? 1 : 2) ? 1 : 0;\r\n\r\ndeclare type Error_2 = {\r\n    kind: 'GenericJs';\r\n    id: number;\r\n} | {\r\n    kind: 'UnsupportedNativeDataType';\r\n    type: string;\r\n} | {\r\n    kind: 'InvalidIsolationLevel';\r\n    level: string;\r\n} | {\r\n    kind: 'LengthMismatch';\r\n    column?: string;\r\n} | {\r\n    kind: 'UniqueConstraintViolation';\r\n    fields: string[];\r\n} | {\r\n    kind: 'NullConstraintViolation';\r\n    fields: string[];\r\n} | {\r\n    kind: 'ForeignKeyConstraintViolation';\r\n    constraint?: {\r\n        fields: string[];\r\n    } | {\r\n        index: string;\r\n    } | {\r\n        foreignKey: {};\r\n    };\r\n} | {\r\n    kind: 'DatabaseDoesNotExist';\r\n    db?: string;\r\n} | {\r\n    kind: 'DatabaseAlreadyExists';\r\n    db?: string;\r\n} | {\r\n    kind: 'DatabaseAccessDenied';\r\n    db?: string;\r\n} | {\r\n    kind: 'AuthenticationFailed';\r\n    user?: string;\r\n} | {\r\n    kind: 'TransactionWriteConflict';\r\n} | {\r\n    kind: 'TableDoesNotExist';\r\n    table?: string;\r\n} | {\r\n    kind: 'ColumnNotFound';\r\n    column?: string;\r\n} | {\r\n    kind: 'TooManyConnections';\r\n    cause: string;\r\n} | {\r\n    kind: 'SocketTimeout';\r\n} | {\r\n    kind: 'postgres';\r\n    code: string;\r\n    severity: string;\r\n    message: string;\r\n    detail: string | undefined;\r\n    column: string | undefined;\r\n    hint: string | undefined;\r\n} | {\r\n    kind: 'mysql';\r\n    code: number;\r\n    message: string;\r\n    state: string;\r\n} | {\r\n    kind: 'sqlite';\r\n    /**\r\n     * Sqlite extended error code: https://www.sqlite.org/rescode.html\r\n     */\r\n    extendedCode: number;\r\n    message: string;\r\n};\r\n\r\ndeclare type ErrorCapturingFunction<T> = T extends (...args: infer A) => Promise<infer R> ? (...args: A) => Promise<Result_4<ErrorCapturingInterface<R>>> : T extends (...args: infer A) => infer R ? (...args: A) => Result_4<ErrorCapturingInterface<R>> : T;\r\n\r\ndeclare type ErrorCapturingInterface<T> = {\r\n    [K in keyof T]: ErrorCapturingFunction<T[K]>;\r\n};\r\n\r\ndeclare interface ErrorCapturingSqlDriverAdapter extends ErrorCapturingInterface<SqlDriverAdapter> {\r\n    readonly errorRegistry: ErrorRegistry;\r\n}\r\n\r\ndeclare type ErrorFormat = 'pretty' | 'colorless' | 'minimal';\r\n\r\ndeclare type ErrorRecord = {\r\n    error: unknown;\r\n};\r\n\r\ndeclare interface ErrorRegistry {\r\n    consumeError(id: number): ErrorRecord | undefined;\r\n}\r\n\r\ndeclare interface ErrorWithBatchIndex {\r\n    batchRequestIdx?: number;\r\n}\r\n\r\ndeclare type EventCallback<E extends ExtendedEventType> = [E] extends ['beforeExit'] ? () => Promise<void> : [E] extends [LogLevel] ? (event: EngineEvent<E>) => void : never;\r\n\r\nexport declare type Exact<A, W> = (A extends unknown ? (W extends A ? {\r\n    [K in keyof A]: Exact<A[K], W[K]>;\r\n} : W) : never) | (A extends Narrowable ? A : never);\r\n\r\n/**\r\n * Defines Exception.\r\n *\r\n * string or an object with one of (message or name or code) and optional stack\r\n */\r\ndeclare type Exception = ExceptionWithCode | ExceptionWithMessage | ExceptionWithName | string;\r\n\r\ndeclare interface ExceptionWithCode {\r\n    code: string | number;\r\n    name?: string;\r\n    message?: string;\r\n    stack?: string;\r\n}\r\n\r\ndeclare interface ExceptionWithMessage {\r\n    code?: string | number;\r\n    message: string;\r\n    name?: string;\r\n    stack?: string;\r\n}\r\n\r\ndeclare interface ExceptionWithName {\r\n    code?: string | number;\r\n    message?: string;\r\n    name: string;\r\n    stack?: string;\r\n}\r\n\r\ndeclare type ExtendedEventType = LogLevel | 'beforeExit';\r\n\r\ndeclare type ExtendedSpanOptions = SpanOptions & {\r\n    /** The name of the span */\r\n    name: string;\r\n    internal?: boolean;\r\n    middleware?: boolean;\r\n    /** Whether it propagates context (?=true) */\r\n    active?: boolean;\r\n    /** The context to append the span to */\r\n    context?: Context;\r\n};\r\n\r\n/** $extends, defineExtension */\r\nexport declare interface ExtendsHook<Variant extends 'extends' | 'define', TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>, TypeMap extends TypeMapDef = Call<TypeMapCb, {\r\n    extArgs: ExtArgs;\r\n}>> {\r\n    extArgs: ExtArgs;\r\n    <R_ extends {\r\n        [K in TypeMap['meta']['modelProps'] | '$allModels']?: unknown;\r\n    }, R, M_ extends {\r\n        [K in TypeMap['meta']['modelProps'] | '$allModels']?: unknown;\r\n    }, M, Q_ extends {\r\n        [K in TypeMap['meta']['modelProps'] | '$allModels' | keyof TypeMap['other']['operations'] | '$allOperations']?: unknown;\r\n    }, C_ extends {\r\n        [K in string]?: unknown;\r\n    }, C, Args extends InternalArgs = InternalArgs<R, M, {}, C>, MergedArgs extends InternalArgs = MergeExtArgs<TypeMap, ExtArgs, Args>>(extension: ((client: DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>) => {\r\n        $extends: {\r\n            extArgs: Args;\r\n        };\r\n    }) | {\r\n        name?: string;\r\n        query?: DynamicQueryExtensionArgs<Q_, TypeMap>;\r\n        result?: DynamicResultExtensionArgs<R_, TypeMap> & R;\r\n        model?: DynamicModelExtensionArgs<M_, TypeMap, TypeMapCb, ExtArgs> & M;\r\n        client?: DynamicClientExtensionArgs<C_, TypeMap, TypeMapCb, ExtArgs> & C;\r\n    }): {\r\n        extends: DynamicClientExtensionThis<Call<TypeMapCb, {\r\n            extArgs: MergedArgs;\r\n        }>, TypeMapCb, MergedArgs>;\r\n        define: (client: any) => {\r\n            $extends: {\r\n                extArgs: Args;\r\n            };\r\n        };\r\n    }[Variant];\r\n}\r\n\r\nexport declare type ExtensionArgs = Optional<RequiredExtensionArgs>;\r\n\r\ndeclare namespace Extensions {\r\n    export {\r\n        defineExtension,\r\n        getExtensionContext\r\n    }\r\n}\r\nexport { Extensions }\r\n\r\ndeclare namespace Extensions_2 {\r\n    export {\r\n        InternalArgs,\r\n        DefaultArgs,\r\n        GetPayloadResultExtensionKeys,\r\n        GetPayloadResultExtensionObject,\r\n        GetPayloadResult,\r\n        GetSelect,\r\n        GetOmit,\r\n        DynamicQueryExtensionArgs,\r\n        DynamicQueryExtensionCb,\r\n        DynamicQueryExtensionCbArgs,\r\n        DynamicQueryExtensionCbArgsArgs,\r\n        DynamicResultExtensionArgs,\r\n        DynamicResultExtensionNeeds,\r\n        DynamicResultExtensionData,\r\n        DynamicModelExtensionArgs,\r\n        DynamicModelExtensionThis,\r\n        DynamicModelExtensionOperationFn,\r\n        DynamicModelExtensionFnResult,\r\n        DynamicModelExtensionFnResultBase,\r\n        DynamicModelExtensionFluentApi,\r\n        DynamicModelExtensionFnResultNull,\r\n        DynamicClientExtensionArgs,\r\n        DynamicClientExtensionThis,\r\n        ClientBuiltInProp,\r\n        DynamicClientExtensionThisBuiltin,\r\n        ExtendsHook,\r\n        MergeExtArgs,\r\n        AllModelsToStringIndex,\r\n        TypeMapDef,\r\n        DevTypeMapDef,\r\n        DevTypeMapFnDef,\r\n        ClientOptionDef,\r\n        ClientOtherOps,\r\n        TypeMapCbDef,\r\n        ModelKey,\r\n        RequiredExtensionArgs as UserArgs\r\n    }\r\n}\r\n\r\nexport declare type ExtractGlobalOmit<Options, ModelName extends string> = Options extends {\r\n    omit: {\r\n        [K in ModelName]: infer GlobalOmit;\r\n    };\r\n} ? GlobalOmit : {};\r\n\r\ndeclare type Field = ReadonlyDeep_2<{\r\n    kind: FieldKind;\r\n    name: string;\r\n    isRequired: boolean;\r\n    isList: boolean;\r\n    isUnique: boolean;\r\n    isId: boolean;\r\n    isReadOnly: boolean;\r\n    isGenerated?: boolean;\r\n    isUpdatedAt?: boolean;\r\n    /**\r\n     * Describes the data type in the same the way it is defined in the Prisma schema:\r\n     * BigInt, Boolean, Bytes, DateTime, Decimal, Float, Int, JSON, String, $ModelName\r\n     */\r\n    type: string;\r\n    /**\r\n     * Native database type, if specified.\r\n     * For example, `@db.VarChar(191)` is encoded as `['VarChar', ['191']]`,\r\n     * `@db.Text` is encoded as `['Text', []]`.\r\n     */\r\n    nativeType?: [string, string[]] | null;\r\n    dbName?: string | null;\r\n    hasDefaultValue: boolean;\r\n    default?: FieldDefault | FieldDefaultScalar | FieldDefaultScalar[];\r\n    relationFromFields?: string[];\r\n    relationToFields?: string[];\r\n    relationOnDelete?: string;\r\n    relationOnUpdate?: string;\r\n    relationName?: string;\r\n    documentation?: string;\r\n}>;\r\n\r\ndeclare type FieldDefault = ReadonlyDeep_2<{\r\n    name: string;\r\n    args: Array<string | number>;\r\n}>;\r\n\r\ndeclare type FieldDefaultScalar = string | boolean | number;\r\n\r\ndeclare type FieldKind = 'scalar' | 'object' | 'enum' | 'unsupported';\r\n\r\ndeclare type FieldLocation = 'scalar' | 'inputObjectTypes' | 'outputObjectTypes' | 'enumTypes' | 'fieldRefTypes';\r\n\r\ndeclare type FieldNamespace = 'model' | 'prisma';\r\n\r\n/**\r\n * A reference to a specific field of a specific model\r\n */\r\nexport declare interface FieldRef<Model, FieldType> {\r\n    readonly modelName: Model;\r\n    readonly name: string;\r\n    readonly typeName: FieldType;\r\n    readonly isList: boolean;\r\n}\r\n\r\ndeclare type FieldRefAllowType = TypeRef<'scalar' | 'enumTypes'>;\r\n\r\ndeclare type FieldRefType = ReadonlyDeep_2<{\r\n    name: string;\r\n    allowTypes: FieldRefAllowType[];\r\n    fields: SchemaArg[];\r\n}>;\r\n\r\ndeclare type FluentOperation = 'findUnique' | 'findUniqueOrThrow' | 'findFirst' | 'findFirstOrThrow' | 'create' | 'update' | 'upsert' | 'delete';\r\n\r\nexport declare interface Fn<Params = unknown, Returns = unknown> {\r\n    params: Params;\r\n    returns: Returns;\r\n}\r\n\r\ndeclare interface GeneratorConfig {\r\n    name: string;\r\n    output: EnvValue | null;\r\n    isCustomOutput?: boolean;\r\n    provider: EnvValue;\r\n    config: {\r\n        /** `output` is a reserved name and will only be available directly at `generator.output` */\r\n        output?: never;\r\n        /** `provider` is a reserved name and will only be available directly at `generator.provider` */\r\n        provider?: never;\r\n        /** `binaryTargets` is a reserved name and will only be available directly at `generator.binaryTargets` */\r\n        binaryTargets?: never;\r\n        /** `previewFeatures` is a reserved name and will only be available directly at `generator.previewFeatures` */\r\n        previewFeatures?: never;\r\n    } & {\r\n        [key: string]: string | string[] | undefined;\r\n    };\r\n    binaryTargets: BinaryTargetsEnvValue[];\r\n    previewFeatures: string[];\r\n    envPaths?: EnvPaths;\r\n    sourceFilePath: string;\r\n}\r\n\r\nexport declare type GetAggregateResult<P extends OperationPayload, A> = {\r\n    [K in keyof A as K extends Aggregate ? K : never]: K extends '_count' ? A[K] extends true ? number : Count<A[K]> : {\r\n        [J in keyof A[K] & string]: P['scalars'][J] | null;\r\n    };\r\n};\r\n\r\ndeclare function getBatchRequestPayload(batch: JsonQuery[], transaction?: TransactionOptions_3<unknown>): QueryEngineBatchRequest;\r\n\r\nexport declare type GetBatchResult = {\r\n    count: number;\r\n};\r\n\r\nexport declare type GetCountResult<A> = A extends {\r\n    select: infer S;\r\n} ? (S extends true ? number : Count<S>) : number;\r\n\r\ndeclare function getExtensionContext<T>(that: T): Context_2<T>;\r\n\r\nexport declare type GetFindResult<P extends OperationPayload, A, GlobalOmitOptions> = Equals<A, any> extends 1 ? DefaultSelection<P, A, GlobalOmitOptions> : A extends {\r\n    select: infer S extends object;\r\n} & Record<string, unknown> | {\r\n    include: infer I extends object;\r\n} & Record<string, unknown> ? {\r\n    [K in keyof S | keyof I as (S & I)[K] extends false | undefined | Skip | null ? never : K]: (S & I)[K] extends object ? P extends SelectablePayloadFields<K, (infer O)[]> ? O extends OperationPayload ? GetFindResult<O, (S & I)[K], GlobalOmitOptions>[] : never : P extends SelectablePayloadFields<K, infer O | null> ? O extends OperationPayload ? GetFindResult<O, (S & I)[K], GlobalOmitOptions> | SelectField<P, K> & null : never : K extends '_count' ? Count<GetFindResult<P, (S & I)[K], GlobalOmitOptions>> : never : P extends SelectablePayloadFields<K, (infer O)[]> ? O extends OperationPayload ? DefaultSelection<O, {}, GlobalOmitOptions>[] : never : P extends SelectablePayloadFields<K, infer O | null> ? O extends OperationPayload ? DefaultSelection<O, {}, GlobalOmitOptions> | SelectField<P, K> & null : never : P extends {\r\n        scalars: {\r\n            [k in K]: infer O;\r\n        };\r\n    } ? O : K extends '_count' ? Count<P['objects']> : never;\r\n} & (A extends {\r\n    include: any;\r\n} & Record<string, unknown> ? DefaultSelection<P, A & {\r\n    omit: A['omit'];\r\n}, GlobalOmitOptions> : unknown) : DefaultSelection<P, A, GlobalOmitOptions>;\r\n\r\nexport declare type GetGroupByResult<P extends OperationPayload, A> = A extends {\r\n    by: string[];\r\n} ? Array<GetAggregateResult<P, A> & {\r\n    [K in A['by'][number]]: P['scalars'][K];\r\n}> : A extends {\r\n    by: string;\r\n} ? Array<GetAggregateResult<P, A> & {\r\n    [K in A['by']]: P['scalars'][K];\r\n}> : {}[];\r\n\r\nexport declare type GetOmit<BaseKeys extends string, R extends InternalArgs['result'][string], ExtraType = never> = {\r\n    [K in (string extends keyof R ? never : keyof R) | BaseKeys]?: boolean | ExtraType;\r\n};\r\n\r\nexport declare type GetPayloadResult<Base extends Record<any, any>, R extends InternalArgs['result'][string]> = Omit<Base, GetPayloadResultExtensionKeys<R>> & GetPayloadResultExtensionObject<R>;\r\n\r\nexport declare type GetPayloadResultExtensionKeys<R extends InternalArgs['result'][string], KR extends keyof R = string extends keyof R ? never : keyof R> = KR;\r\n\r\nexport declare type GetPayloadResultExtensionObject<R extends InternalArgs['result'][string]> = {\r\n    [K in GetPayloadResultExtensionKeys<R>]: R[K] extends () => {\r\n        compute: (...args: any) => infer C;\r\n    } ? C : never;\r\n};\r\n\r\nexport declare function getPrismaClient(config: GetPrismaClientConfig): {\r\n    new (optionsArg?: PrismaClientOptions): {\r\n        _originalClient: any;\r\n        _runtimeDataModel: RuntimeDataModel;\r\n        _requestHandler: RequestHandler;\r\n        _connectionPromise?: Promise<any> | undefined;\r\n        _disconnectionPromise?: Promise<any> | undefined;\r\n        _engineConfig: EngineConfig;\r\n        _accelerateEngineConfig: AccelerateEngineConfig;\r\n        _clientVersion: string;\r\n        _errorFormat: ErrorFormat;\r\n        _tracingHelper: TracingHelper;\r\n        _middlewares: MiddlewareHandler<QueryMiddleware>;\r\n        _previewFeatures: string[];\r\n        _activeProvider: string;\r\n        _globalOmit?: GlobalOmitOptions | undefined;\r\n        _extensions: MergedExtensionsList;\r\n        /**\r\n         * @remarks This is used internally by Policy, do not rename or remove\r\n         */\r\n        _engine: Engine;\r\n        /**\r\n         * A fully constructed/applied Client that references the parent\r\n         * PrismaClient. This is used for Client extensions only.\r\n         */\r\n        _appliedParent: any;\r\n        _createPrismaPromise: PrismaPromiseFactory;\r\n        /**\r\n         * Hook a middleware into the client\r\n         * @param middleware to hook\r\n         */\r\n        $use(middleware: QueryMiddleware): void;\r\n        $on<E extends ExtendedEventType>(eventType: E, callback: EventCallback<E>): any;\r\n        $connect(): Promise<void>;\r\n        /**\r\n         * Disconnect from the database\r\n         */\r\n        $disconnect(): Promise<void>;\r\n        /**\r\n         * Executes a raw query and always returns a number\r\n         */\r\n        $executeRawInternal(transaction: PrismaPromiseTransaction | undefined, clientMethod: string, args: RawQueryArgs, middlewareArgsMapper?: MiddlewareArgsMapper<unknown, unknown>): Promise<number>;\r\n        /**\r\n         * Executes a raw query provided through a safe tag function\r\n         * @see https://github.com/prisma/prisma/issues/7142\r\n         *\r\n         * @param query\r\n         * @param values\r\n         * @returns\r\n         */\r\n        $executeRaw(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Unsafe counterpart of `$executeRaw` that is susceptible to SQL injections\r\n         * @see https://github.com/prisma/prisma/issues/7142\r\n         *\r\n         * @param query\r\n         * @param values\r\n         * @returns\r\n         */\r\n        $executeRawUnsafe(query: string, ...values: RawValue[]): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Executes a raw command only for MongoDB\r\n         *\r\n         * @param command\r\n         * @returns\r\n         */\r\n        $runCommandRaw(command: Record<string, JsInputValue>): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Executes a raw query and returns selected data\r\n         */\r\n        $queryRawInternal(transaction: PrismaPromiseTransaction | undefined, clientMethod: string, args: RawQueryArgs, middlewareArgsMapper?: MiddlewareArgsMapper<unknown, unknown>): Promise<any>;\r\n        /**\r\n         * Executes a raw query provided through a safe tag function\r\n         * @see https://github.com/prisma/prisma/issues/7142\r\n         *\r\n         * @param query\r\n         * @param values\r\n         * @returns\r\n         */\r\n        $queryRaw(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Counterpart to $queryRaw, that returns strongly typed results\r\n         * @param typedSql\r\n         */\r\n        $queryRawTyped(typedSql: UnknownTypedSql): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Unsafe counterpart of `$queryRaw` that is susceptible to SQL injections\r\n         * @see https://github.com/prisma/prisma/issues/7142\r\n         *\r\n         * @param query\r\n         * @param values\r\n         * @returns\r\n         */\r\n        $queryRawUnsafe(query: string, ...values: RawValue[]): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Execute a batch of requests in a transaction\r\n         * @param requests\r\n         * @param options\r\n         */\r\n        _transactionWithArray({ promises, options, }: {\r\n            promises: Array<PrismaPromise_2<any>>;\r\n            options?: BatchTransactionOptions;\r\n        }): Promise<any>;\r\n        /**\r\n         * Perform a long-running transaction\r\n         * @param callback\r\n         * @param options\r\n         * @returns\r\n         */\r\n        _transactionWithCallback({ callback, options, }: {\r\n            callback: (client: Client) => Promise<unknown>;\r\n            options?: TransactionOptions_2;\r\n        }): Promise<unknown>;\r\n        _createItxClient(transaction: PrismaPromiseInteractiveTransaction): Client;\r\n        /**\r\n         * Execute queries within a transaction\r\n         * @param input a callback or a query list\r\n         * @param options to set timeouts (callback)\r\n         * @returns\r\n         */\r\n        $transaction(input: any, options?: any): Promise<any>;\r\n        /**\r\n         * Runs the middlewares over params before executing a request\r\n         * @param internalParams\r\n         * @returns\r\n         */\r\n        _request(internalParams: InternalRequestParams): Promise<any>;\r\n        _executeRequest({ args, clientMethod, dataPath, callsite, action, model, argsMapper, transaction, unpacker, otelParentCtx, customDataProxyFetch, }: InternalRequestParams): Promise<any>;\r\n        $metrics: MetricsClient;\r\n        /**\r\n         * Shortcut for checking a preview flag\r\n         * @param feature preview flag\r\n         * @returns\r\n         */\r\n        _hasPreviewFlag(feature: string): boolean;\r\n        $applyPendingMigrations(): Promise<void>;\r\n        $extends: typeof $extends;\r\n        readonly [Symbol.toStringTag]: string;\r\n    };\r\n};\r\n\r\n/**\r\n * Config that is stored into the generated client. When the generated client is\r\n * loaded, this same config is passed to {@link getPrismaClient} which creates a\r\n * closure with that config around a non-instantiated [[PrismaClient]].\r\n */\r\nexport declare type GetPrismaClientConfig = {\r\n    runtimeDataModel: RuntimeDataModel;\r\n    generator?: GeneratorConfig;\r\n    relativeEnvPaths?: {\r\n        rootEnvPath?: string | null;\r\n        schemaEnvPath?: string | null;\r\n    };\r\n    relativePath: string;\r\n    dirname: string;\r\n    clientVersion: string;\r\n    engineVersion: string;\r\n    datasourceNames: string[];\r\n    activeProvider: ActiveConnectorType;\r\n    /**\r\n     * The contents of the schema encoded into a string\r\n     * @remarks only used for the purpose of data proxy\r\n     */\r\n    inlineSchema: string;\r\n    /**\r\n     * A special env object just for the data proxy edge runtime.\r\n     * Allows bundlers to inject their own env variables (Vercel).\r\n     * Allows platforms to declare global variables as env (Workers).\r\n     * @remarks only used for the purpose of data proxy\r\n     */\r\n    injectableEdgeEnv?: () => LoadedEnv;\r\n    /**\r\n     * The contents of the datasource url saved in a string.\r\n     * This can either be an env var name or connection string.\r\n     * It is needed by the client to connect to the Data Proxy.\r\n     * @remarks only used for the purpose of data proxy\r\n     */\r\n    inlineDatasources: {\r\n        [name in string]: {\r\n            url: EnvValue;\r\n        };\r\n    };\r\n    /**\r\n     * The string hash that was produced for a given schema\r\n     * @remarks only used for the purpose of data proxy\r\n     */\r\n    inlineSchemaHash: string;\r\n    /**\r\n     * A marker to indicate that the client was not generated via `prisma\r\n     * generate` but was generated via `generate --postinstall` script instead.\r\n     * @remarks used to error for Vercel/Netlify for schema caching issues\r\n     */\r\n    postinstall?: boolean;\r\n    /**\r\n     * Information about the CI where the Prisma Client has been generated. The\r\n     * name of the CI environment is stored at generation time because CI\r\n     * information is not always available at runtime. Moreover, the edge client\r\n     * has no notion of environment variables, so this works around that.\r\n     * @remarks used to error for Vercel/Netlify for schema caching issues\r\n     */\r\n    ciName?: string;\r\n    /**\r\n     * Information about whether we have not found a schema.prisma file in the\r\n     * default location, and that we fell back to finding the schema.prisma file\r\n     * in the current working directory. This usually means it has been bundled.\r\n     */\r\n    isBundled?: boolean;\r\n    /**\r\n     * A boolean that is `false` when the client was generated with --no-engine. At\r\n     * runtime, this means the client will be bound to be using the Data Proxy.\r\n     */\r\n    copyEngine?: boolean;\r\n    /**\r\n     * Optional wasm loading configuration\r\n     */\r\n    engineWasm?: EngineWasmLoadingConfig;\r\n    compilerWasm?: CompilerWasmLoadingConfig;\r\n};\r\n\r\nexport declare type GetResult<Payload extends OperationPayload, Args, OperationName extends Operation = 'findUniqueOrThrow', GlobalOmitOptions = {}> = {\r\n    findUnique: GetFindResult<Payload, Args, GlobalOmitOptions> | null;\r\n    findUniqueOrThrow: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    findFirst: GetFindResult<Payload, Args, GlobalOmitOptions> | null;\r\n    findFirstOrThrow: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    findMany: GetFindResult<Payload, Args, GlobalOmitOptions>[];\r\n    create: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    createMany: GetBatchResult;\r\n    createManyAndReturn: GetFindResult<Payload, Args, GlobalOmitOptions>[];\r\n    update: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    updateMany: GetBatchResult;\r\n    updateManyAndReturn: GetFindResult<Payload, Args, GlobalOmitOptions>[];\r\n    upsert: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    delete: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    deleteMany: GetBatchResult;\r\n    aggregate: GetAggregateResult<Payload, Args>;\r\n    count: GetCountResult<Args>;\r\n    groupBy: GetGroupByResult<Payload, Args>;\r\n    $queryRaw: unknown;\r\n    $queryRawTyped: unknown;\r\n    $executeRaw: number;\r\n    $queryRawUnsafe: unknown;\r\n    $executeRawUnsafe: number;\r\n    $runCommandRaw: JsonObject;\r\n    findRaw: JsonObject;\r\n    aggregateRaw: JsonObject;\r\n}[OperationName];\r\n\r\nexport declare function getRuntime(): GetRuntimeOutput;\r\n\r\ndeclare type GetRuntimeOutput = {\r\n    id: RuntimeName;\r\n    prettyName: string;\r\n    isEdge: boolean;\r\n};\r\n\r\nexport declare type GetSelect<Base extends Record<any, any>, R extends InternalArgs['result'][string], KR extends keyof R = string extends keyof R ? never : keyof R> = {\r\n    [K in KR | keyof Base]?: K extends KR ? boolean : Base[K];\r\n};\r\n\r\ndeclare type GlobalOmitOptions = {\r\n    [modelName: string]: {\r\n        [fieldName: string]: boolean;\r\n    };\r\n};\r\n\r\ndeclare type HandleErrorParams = {\r\n    args: JsArgs;\r\n    error: any;\r\n    clientMethod: string;\r\n    callsite?: CallSite;\r\n    transaction?: PrismaPromiseTransaction;\r\n    modelName?: string;\r\n    globalOmit?: GlobalOmitOptions;\r\n};\r\n\r\ndeclare type HrTime = [number, number];\r\n\r\n/**\r\n * Defines High-Resolution Time.\r\n *\r\n * The first number, HrTime[0], is UNIX Epoch time in seconds since 00:00:00 UTC on 1 January 1970.\r\n * The second number, HrTime[1], represents the partial second elapsed since Unix Epoch time represented by first number in nanoseconds.\r\n * For example, 2021-01-01T12:30:10.150Z in UNIX Epoch time in milliseconds is represented as 1609504210150.\r\n * The first number is calculated by converting and truncating the Epoch time in milliseconds to seconds:\r\n * HrTime[0] = Math.trunc(1609504210150 / 1000) = 1609504210.\r\n * The second number is calculated by converting the digits after the decimal point of the subtraction, (1609504210150 / 1000) - HrTime[0], to nanoseconds:\r\n * HrTime[1] = Number((1609504210.150 - HrTime[0]).toFixed(9)) * 1e9 = 150000000.\r\n * This is represented in HrTime format as [1609504210, 150000000].\r\n */\r\ndeclare type HrTime_2 = [number, number];\r\n\r\ndeclare type Index = ReadonlyDeep_2<{\r\n    model: string;\r\n    type: IndexType;\r\n    isDefinedOnField: boolean;\r\n    name?: string;\r\n    dbName?: string;\r\n    algorithm?: string;\r\n    clustered?: boolean;\r\n    fields: IndexField[];\r\n}>;\r\n\r\ndeclare type IndexField = ReadonlyDeep_2<{\r\n    name: string;\r\n    sortOrder?: SortOrder;\r\n    length?: number;\r\n    operatorClass?: string;\r\n}>;\r\n\r\ndeclare type IndexType = 'id' | 'normal' | 'unique' | 'fulltext';\r\n\r\n/**\r\n * Matches a JSON array.\r\n * Unlike \\`JsonArray\\`, readonly arrays are assignable to this type.\r\n */\r\nexport declare interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {\r\n}\r\n\r\n/**\r\n * Matches a JSON object.\r\n * Unlike \\`JsonObject\\`, this type allows undefined and read-only properties.\r\n */\r\nexport declare type InputJsonObject = {\r\n    readonly [Key in string]?: InputJsonValue | null;\r\n};\r\n\r\n/**\r\n * Matches any valid value that can be used as an input for operations like\r\n * create and update as the value of a JSON field. Unlike \\`JsonValue\\`, this\r\n * type allows read-only arrays and read-only object properties and disallows\r\n * \\`null\\` at the top level.\r\n *\r\n * \\`null\\` cannot be used as the value of a JSON field because its meaning\r\n * would be ambiguous. Use \\`Prisma.JsonNull\\` to store the JSON null value or\r\n * \\`Prisma.DbNull\\` to clear the JSON value and set the field to the database\r\n * NULL value instead.\r\n *\r\n * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values\r\n */\r\nexport declare type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | {\r\n    toJSON(): unknown;\r\n};\r\n\r\ndeclare type InputType = ReadonlyDeep_2<{\r\n    name: string;\r\n    constraints: {\r\n        maxNumFields: number | null;\r\n        minNumFields: number | null;\r\n        fields?: string[];\r\n    };\r\n    meta?: {\r\n        source?: string;\r\n        grouping?: string;\r\n    };\r\n    fields: SchemaArg[];\r\n}>;\r\n\r\ndeclare type InputTypeRef = TypeRef<'scalar' | 'inputObjectTypes' | 'enumTypes' | 'fieldRefTypes'>;\r\n\r\ndeclare type InteractiveTransactionInfo<Payload = unknown> = {\r\n    /**\r\n     * Transaction ID returned by the query engine.\r\n     */\r\n    id: string;\r\n    /**\r\n     * Arbitrary payload the meaning of which depends on the `Engine` implementation.\r\n     * For example, `DataProxyEngine` needs to associate different API endpoints with transactions.\r\n     * In `LibraryEngine` and `BinaryEngine` it is currently not used.\r\n     */\r\n    payload: Payload;\r\n};\r\n\r\ndeclare type InteractiveTransactionOptions<Payload> = Transaction_2.InteractiveTransactionInfo<Payload>;\r\n\r\nexport declare type InternalArgs<R = {\r\n    [K in string]: {\r\n        [K in string]: unknown;\r\n    };\r\n}, M = {\r\n    [K in string]: {\r\n        [K in string]: unknown;\r\n    };\r\n}, Q = {\r\n    [K in string]: {\r\n        [K in string]: unknown;\r\n    };\r\n}, C = {\r\n    [K in string]: unknown;\r\n}> = {\r\n    result: {\r\n        [K in keyof R]: {\r\n            [P in keyof R[K]]: () => R[K][P];\r\n        };\r\n    };\r\n    model: {\r\n        [K in keyof M]: {\r\n            [P in keyof M[K]]: () => M[K][P];\r\n        };\r\n    };\r\n    query: {\r\n        [K in keyof Q]: {\r\n            [P in keyof Q[K]]: () => Q[K][P];\r\n        };\r\n    };\r\n    client: {\r\n        [K in keyof C]: () => C[K];\r\n    };\r\n};\r\n\r\ndeclare type InternalRequestParams = {\r\n    /**\r\n     * The original client method being called.\r\n     * Even though the rootField / operation can be changed,\r\n     * this method stays as it is, as it's what the user's\r\n     * code looks like\r\n     */\r\n    clientMethod: string;\r\n    /**\r\n     * Name of js model that triggered the request. Might be used\r\n     * for warnings or error messages\r\n     */\r\n    jsModelName?: string;\r\n    callsite?: CallSite;\r\n    transaction?: PrismaPromiseTransaction;\r\n    unpacker?: Unpacker;\r\n    otelParentCtx?: Context;\r\n    /** Used to \"desugar\" a user input into an \"expanded\" one */\r\n    argsMapper?: (args?: UserArgs_2) => UserArgs_2;\r\n    /** Used to convert args for middleware and back */\r\n    middlewareArgsMapper?: MiddlewareArgsMapper<unknown, unknown>;\r\n    /** Used for Accelerate client extension via Data Proxy */\r\n    customDataProxyFetch?: CustomDataProxyFetch;\r\n} & Omit<QueryMiddlewareParams, 'runInTransaction'>;\r\n\r\ndeclare type IsolationLevel = 'READ UNCOMMITTED' | 'READ COMMITTED' | 'REPEATABLE READ' | 'SNAPSHOT' | 'SERIALIZABLE';\r\n\r\ndeclare function isSkip(value: unknown): value is Skip;\r\n\r\nexport declare function isTypedSql(value: unknown): value is UnknownTypedSql;\r\n\r\nexport declare type ITXClientDenyList = (typeof denylist)[number];\r\n\r\nexport declare const itxClientDenyList: readonly (string | symbol)[];\r\n\r\ndeclare interface Job {\r\n    resolve: (data: any) => void;\r\n    reject: (data: any) => void;\r\n    request: any;\r\n}\r\n\r\n/**\r\n * Create a SQL query for a list of values.\r\n */\r\nexport declare function join(values: readonly RawValue[], separator?: string, prefix?: string, suffix?: string): Sql;\r\n\r\nexport declare type JsArgs = {\r\n    select?: Selection_2;\r\n    include?: Selection_2;\r\n    omit?: Omission;\r\n    [argName: string]: JsInputValue;\r\n};\r\n\r\nexport declare type JsInputValue = null | undefined | string | number | boolean | bigint | Uint8Array | Date | DecimalJsLike | ObjectEnumValue | RawParameters | JsonConvertible | FieldRef<string, unknown> | JsInputValue[] | Skip | {\r\n    [key: string]: JsInputValue;\r\n};\r\n\r\ndeclare type JsonArgumentValue = number | string | boolean | null | RawTaggedValue | JsonArgumentValue[] | {\r\n    [key: string]: JsonArgumentValue;\r\n};\r\n\r\n/**\r\n * From https://github.com/sindresorhus/type-fest/\r\n * Matches a JSON array.\r\n */\r\nexport declare interface JsonArray extends Array<JsonValue> {\r\n}\r\n\r\nexport declare type JsonBatchQuery = {\r\n    batch: JsonQuery[];\r\n    transaction?: {\r\n        isolationLevel?: IsolationLevel;\r\n    };\r\n};\r\n\r\nexport declare interface JsonConvertible {\r\n    toJSON(): unknown;\r\n}\r\n\r\ndeclare type JsonFieldSelection = {\r\n    arguments?: Record<string, JsonArgumentValue> | RawTaggedValue;\r\n    selection: JsonSelectionSet;\r\n};\r\n\r\ndeclare class JsonNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\n/**\r\n * From https://github.com/sindresorhus/type-fest/\r\n * Matches a JSON object.\r\n * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from.\r\n */\r\nexport declare type JsonObject = {\r\n    [Key in string]?: JsonValue;\r\n};\r\n\r\nexport declare type JsonQuery = {\r\n    modelName?: string;\r\n    action: JsonQueryAction;\r\n    query: JsonFieldSelection;\r\n};\r\n\r\ndeclare type JsonQueryAction = 'findUnique' | 'findUniqueOrThrow' | 'findFirst' | 'findFirstOrThrow' | 'findMany' | 'createOne' | 'createMany' | 'createManyAndReturn' | 'updateOne' | 'updateMany' | 'updateManyAndReturn' | 'deleteOne' | 'deleteMany' | 'upsertOne' | 'aggregate' | 'groupBy' | 'executeRaw' | 'queryRaw' | 'runCommandRaw' | 'findRaw' | 'aggregateRaw';\r\n\r\ndeclare type JsonSelectionSet = {\r\n    $scalars?: boolean;\r\n    $composites?: boolean;\r\n} & {\r\n    [fieldName: string]: boolean | JsonFieldSelection;\r\n};\r\n\r\n/**\r\n * From https://github.com/sindresorhus/type-fest/\r\n * Matches any valid JSON value.\r\n */\r\nexport declare type JsonValue = string | number | boolean | JsonObject | JsonArray | null;\r\n\r\nexport declare type JsOutputValue = null | string | number | boolean | bigint | Uint8Array | Date | Decimal | JsOutputValue[] | {\r\n    [key: string]: JsOutputValue;\r\n};\r\n\r\nexport declare type JsPromise<T> = Promise<T> & {};\r\n\r\ndeclare type KnownErrorParams = {\r\n    code: string;\r\n    clientVersion: string;\r\n    meta?: Record<string, unknown>;\r\n    batchRequestIdx?: number;\r\n};\r\n\r\n/**\r\n * A pointer from the current {@link Span} to another span in the same trace or\r\n * in a different trace.\r\n * Few examples of Link usage.\r\n * 1. Batch Processing: A batch of elements may contain elements associated\r\n *    with one or more traces/spans. Since there can only be one parent\r\n *    SpanContext, Link is used to keep reference to SpanContext of all\r\n *    elements in the batch.\r\n * 2. Public Endpoint: A SpanContext in incoming client request on a public\r\n *    endpoint is untrusted from service provider perspective. In such case it\r\n *    is advisable to start a new trace with appropriate sampling decision.\r\n *    However, it is desirable to associate incoming SpanContext to new trace\r\n *    initiated on service provider side so two traces (from Client and from\r\n *    Service Provider) can be correlated.\r\n */\r\ndeclare interface Link {\r\n    /** The {@link SpanContext} of a linked span. */\r\n    context: SpanContext;\r\n    /** A set of {@link SpanAttributes} on the link. */\r\n    attributes?: SpanAttributes;\r\n    /** Count of attributes of the link that were dropped due to collection limits */\r\n    droppedAttributesCount?: number;\r\n}\r\n\r\ndeclare type LoadedEnv = {\r\n    message?: string;\r\n    parsed: {\r\n        [x: string]: string;\r\n    };\r\n} | undefined;\r\n\r\ndeclare type LocationInFile = {\r\n    fileName: string;\r\n    lineNumber: number | null;\r\n    columnNumber: number | null;\r\n};\r\n\r\ndeclare type LogDefinition = {\r\n    level: LogLevel;\r\n    emit: 'stdout' | 'event';\r\n};\r\n\r\n/**\r\n * Typings for the events we emit.\r\n *\r\n * @remarks\r\n * If this is updated, our edge runtime shim needs to be updated as well.\r\n */\r\ndeclare type LogEmitter = {\r\n    on<E extends EngineEventType>(event: E, listener: (event: EngineEvent<E>) => void): LogEmitter;\r\n    emit(event: QueryEventType, payload: QueryEvent): boolean;\r\n    emit(event: LogEventType, payload: LogEvent): boolean;\r\n};\r\n\r\ndeclare type LogEvent = {\r\n    timestamp: Date;\r\n    message: string;\r\n    target: string;\r\n};\r\n\r\ndeclare type LogEventType = 'info' | 'warn' | 'error';\r\n\r\ndeclare type LogLevel = 'info' | 'query' | 'warn' | 'error';\r\n\r\n/**\r\n * Generates more strict variant of an enum which, unlike regular enum,\r\n * throws on non-existing property access. This can be useful in following situations:\r\n * - we have an API, that accepts both `undefined` and `SomeEnumType` as an input\r\n * - enum values are generated dynamically from DMMF.\r\n *\r\n * In that case, if using normal enums and no compile-time typechecking, using non-existing property\r\n * will result in `undefined` value being used, which will be accepted. Using strict enum\r\n * in this case will help to have a runtime exception, telling you that you are probably doing something wrong.\r\n *\r\n * Note: if you need to check for existence of a value in the enum you can still use either\r\n * `in` operator or `hasOwnProperty` function.\r\n *\r\n * @param definition\r\n * @returns\r\n */\r\nexport declare function makeStrictEnum<T extends Record<PropertyKey, string | number>>(definition: T): T;\r\n\r\nexport declare function makeTypedQueryFactory(sql: string): (...values: any[]) => TypedSql<any[], unknown>;\r\n\r\ndeclare type Mappings = ReadonlyDeep_2<{\r\n    modelOperations: ModelMapping[];\r\n    otherOperations: {\r\n        read: string[];\r\n        write: string[];\r\n    };\r\n}>;\r\n\r\n/**\r\n * Class that holds the list of all extensions, applied to particular instance,\r\n * as well as resolved versions of the components that need to apply on\r\n * different levels. Main idea of this class: avoid re-resolving as much of the\r\n * stuff as possible when new extensions are added while also delaying the\r\n * resolve until the point it is actually needed. For example, computed fields\r\n * of the model won't be resolved unless the model is actually queried. Neither\r\n * adding extensions with `client` component only cause other components to\r\n * recompute.\r\n */\r\ndeclare class MergedExtensionsList {\r\n    private head?;\r\n    private constructor();\r\n    static empty(): MergedExtensionsList;\r\n    static single(extension: ExtensionArgs): MergedExtensionsList;\r\n    isEmpty(): boolean;\r\n    append(extension: ExtensionArgs): MergedExtensionsList;\r\n    getAllComputedFields(dmmfModelName: string): ComputedFieldsMap | undefined;\r\n    getAllClientExtensions(): ClientArg | undefined;\r\n    getAllModelExtensions(dmmfModelName: string): ModelArg | undefined;\r\n    getAllQueryCallbacks(jsModelName: string, operation: string): any;\r\n    getAllBatchQueryCallbacks(): BatchQueryOptionsCb[];\r\n}\r\n\r\nexport declare type MergeExtArgs<TypeMap extends TypeMapDef, ExtArgs extends Record<any, any>, Args extends Record<any, any>> = ComputeDeep<ExtArgs & Args & AllModelsToStringIndex<TypeMap, Args, 'result'> & AllModelsToStringIndex<TypeMap, Args, 'model'>>;\r\n\r\nexport declare type Metric<T> = {\r\n    key: string;\r\n    value: T;\r\n    labels: Record<string, string>;\r\n    description: string;\r\n};\r\n\r\nexport declare type MetricHistogram = {\r\n    buckets: MetricHistogramBucket[];\r\n    sum: number;\r\n    count: number;\r\n};\r\n\r\nexport declare type MetricHistogramBucket = [maxValue: number, count: number];\r\n\r\nexport declare type Metrics = {\r\n    counters: Metric<number>[];\r\n    gauges: Metric<number>[];\r\n    histograms: Metric<MetricHistogram>[];\r\n};\r\n\r\nexport declare class MetricsClient {\r\n    private _client;\r\n    constructor(client: Client);\r\n    /**\r\n     * Returns all metrics gathered up to this point in prometheus format.\r\n     * Result of this call can be exposed directly to prometheus scraping endpoint\r\n     *\r\n     * @param options\r\n     * @returns\r\n     */\r\n    prometheus(options?: MetricsOptions): Promise<string>;\r\n    /**\r\n     * Returns all metrics gathered up to this point in prometheus format.\r\n     *\r\n     * @param options\r\n     * @returns\r\n     */\r\n    json(options?: MetricsOptions): Promise<Metrics>;\r\n}\r\n\r\ndeclare type MetricsOptions = {\r\n    /**\r\n     * Labels to add to every metrics in key-value format\r\n     */\r\n    globalLabels?: Record<string, string>;\r\n};\r\n\r\ndeclare type MetricsOptionsCommon = {\r\n    globalLabels?: Record<string, string>;\r\n};\r\n\r\ndeclare type MetricsOptionsJson = {\r\n    format: 'json';\r\n} & MetricsOptionsCommon;\r\n\r\ndeclare type MetricsOptionsPrometheus = {\r\n    format: 'prometheus';\r\n} & MetricsOptionsCommon;\r\n\r\ndeclare type MiddlewareArgsMapper<RequestArgs, MiddlewareArgs> = {\r\n    requestArgsToMiddlewareArgs(requestArgs: RequestArgs): MiddlewareArgs;\r\n    middlewareArgsToRequestArgs(middlewareArgs: MiddlewareArgs): RequestArgs;\r\n};\r\n\r\ndeclare class MiddlewareHandler<M extends Function> {\r\n    private _middlewares;\r\n    use(middleware: M): void;\r\n    get(id: number): M | undefined;\r\n    has(id: number): boolean;\r\n    length(): number;\r\n}\r\n\r\ndeclare type Model = ReadonlyDeep_2<{\r\n    name: string;\r\n    dbName: string | null;\r\n    schema: string | null;\r\n    fields: Field[];\r\n    uniqueFields: string[][];\r\n    uniqueIndexes: uniqueIndex[];\r\n    documentation?: string;\r\n    primaryKey: PrimaryKey | null;\r\n    isGenerated?: boolean;\r\n}>;\r\n\r\ndeclare enum ModelAction {\r\n    findUnique = \"findUnique\",\r\n    findUniqueOrThrow = \"findUniqueOrThrow\",\r\n    findFirst = \"findFirst\",\r\n    findFirstOrThrow = \"findFirstOrThrow\",\r\n    findMany = \"findMany\",\r\n    create = \"create\",\r\n    createMany = \"createMany\",\r\n    createManyAndReturn = \"createManyAndReturn\",\r\n    update = \"update\",\r\n    updateMany = \"updateMany\",\r\n    updateManyAndReturn = \"updateManyAndReturn\",\r\n    upsert = \"upsert\",\r\n    delete = \"delete\",\r\n    deleteMany = \"deleteMany\",\r\n    groupBy = \"groupBy\",\r\n    count = \"count\",// TODO: count does not actually exist in DMMF\r\n    aggregate = \"aggregate\",\r\n    findRaw = \"findRaw\",\r\n    aggregateRaw = \"aggregateRaw\"\r\n}\r\n\r\nexport declare type ModelArg = {\r\n    [MethodName in string]: unknown;\r\n};\r\n\r\nexport declare type ModelArgs = {\r\n    model: {\r\n        [ModelName in string]: ModelArg;\r\n    };\r\n};\r\n\r\nexport declare type ModelKey<TypeMap extends TypeMapDef, M extends PropertyKey> = M extends keyof TypeMap['model'] ? M : Capitalize<M & string>;\r\n\r\ndeclare type ModelMapping = ReadonlyDeep_2<{\r\n    model: string;\r\n    plural: string;\r\n    findUnique?: string | null;\r\n    findUniqueOrThrow?: string | null;\r\n    findFirst?: string | null;\r\n    findFirstOrThrow?: string | null;\r\n    findMany?: string | null;\r\n    create?: string | null;\r\n    createMany?: string | null;\r\n    createManyAndReturn?: string | null;\r\n    update?: string | null;\r\n    updateMany?: string | null;\r\n    updateManyAndReturn?: string | null;\r\n    upsert?: string | null;\r\n    delete?: string | null;\r\n    deleteMany?: string | null;\r\n    aggregate?: string | null;\r\n    groupBy?: string | null;\r\n    count?: string | null;\r\n    findRaw?: string | null;\r\n    aggregateRaw?: string | null;\r\n}>;\r\n\r\nexport declare type ModelQueryOptionsCb = (args: ModelQueryOptionsCbArgs) => Promise<any>;\r\n\r\nexport declare type ModelQueryOptionsCbArgs = {\r\n    model: string;\r\n    operation: string;\r\n    args: JsArgs;\r\n    query: (args: JsArgs) => Promise<unknown>;\r\n};\r\n\r\ndeclare type MultiBatchResponse = {\r\n    type: 'multi';\r\n    plans: object[];\r\n};\r\n\r\nexport declare type NameArgs = {\r\n    name?: string;\r\n};\r\n\r\nexport declare type Narrow<A> = {\r\n    [K in keyof A]: A[K] extends Function ? A[K] : Narrow<A[K]>;\r\n} | (A extends Narrowable ? A : never);\r\n\r\nexport declare type Narrowable = string | number | bigint | boolean | [];\r\n\r\nexport declare type NeverToUnknown<T> = [T] extends [never] ? unknown : T;\r\n\r\ndeclare class NullTypesEnumValue extends ObjectEnumValue {\r\n    _getNamespace(): string;\r\n}\r\n\r\n/**\r\n * Base class for unique values of object-valued enums.\r\n */\r\nexport declare abstract class ObjectEnumValue {\r\n    constructor(arg?: symbol);\r\n    abstract _getNamespace(): string;\r\n    _getName(): string;\r\n    toString(): string;\r\n}\r\n\r\nexport declare const objectEnumValues: {\r\n    classes: {\r\n        DbNull: typeof DbNull;\r\n        JsonNull: typeof JsonNull;\r\n        AnyNull: typeof AnyNull;\r\n    };\r\n    instances: {\r\n        DbNull: DbNull;\r\n        JsonNull: JsonNull;\r\n        AnyNull: AnyNull;\r\n    };\r\n};\r\n\r\ndeclare const officialPrismaAdapters: readonly [\"@prisma/adapter-planetscale\", \"@prisma/adapter-neon\", \"@prisma/adapter-libsql\", \"@prisma/adapter-d1\", \"@prisma/adapter-pg\", \"@prisma/adapter-pg-worker\"];\r\n\r\nexport declare type Omission = Record<string, boolean | Skip>;\r\n\r\ndeclare type Omit_2<T, K extends string | number | symbol> = {\r\n    [P in keyof T as P extends K ? never : P]: T[P];\r\n};\r\nexport { Omit_2 as Omit }\r\n\r\nexport declare type OmitValue<Omit, Key> = Key extends keyof Omit ? Omit[Key] : false;\r\n\r\nexport declare type Operation = 'findFirst' | 'findFirstOrThrow' | 'findUnique' | 'findUniqueOrThrow' | 'findMany' | 'create' | 'createMany' | 'createManyAndReturn' | 'update' | 'updateMany' | 'updateManyAndReturn' | 'upsert' | 'delete' | 'deleteMany' | 'aggregate' | 'count' | 'groupBy' | '$queryRaw' | '$executeRaw' | '$queryRawUnsafe' | '$executeRawUnsafe' | 'findRaw' | 'aggregateRaw' | '$runCommandRaw';\r\n\r\nexport declare type OperationPayload = {\r\n    name: string;\r\n    scalars: {\r\n        [ScalarName in string]: unknown;\r\n    };\r\n    objects: {\r\n        [ObjectName in string]: unknown;\r\n    };\r\n    composites: {\r\n        [CompositeName in string]: unknown;\r\n    };\r\n};\r\n\r\nexport declare type Optional<O, K extends keyof any = keyof O> = {\r\n    [P in K & keyof O]?: O[P];\r\n} & {\r\n    [P in Exclude<keyof O, K>]: O[P];\r\n};\r\n\r\nexport declare type OptionalFlat<T> = {\r\n    [K in keyof T]?: T[K];\r\n};\r\n\r\nexport declare type OptionalKeys<O> = {\r\n    [K in keyof O]-?: {} extends Pick_2<O, K> ? K : never;\r\n}[keyof O];\r\n\r\ndeclare type Options = {\r\n    clientVersion: string;\r\n};\r\n\r\nexport declare type Or<A extends 1 | 0, B extends 1 | 0> = {\r\n    0: {\r\n        0: 0;\r\n        1: 1;\r\n    };\r\n    1: {\r\n        0: 1;\r\n        1: 1;\r\n    };\r\n}[A][B];\r\n\r\ndeclare type OtherOperationMappings = ReadonlyDeep_2<{\r\n    read: string[];\r\n    write: string[];\r\n}>;\r\n\r\ndeclare type OutputType = ReadonlyDeep_2<{\r\n    name: string;\r\n    fields: SchemaField[];\r\n}>;\r\n\r\ndeclare type OutputTypeRef = TypeRef<'scalar' | 'outputObjectTypes' | 'enumTypes'>;\r\n\r\nexport declare function Param<$Type, $Value extends string>(name: $Value): Param<$Type, $Value>;\r\n\r\nexport declare type Param<out $Type, $Value extends string> = {\r\n    readonly name: $Value;\r\n};\r\n\r\nexport declare type PatchFlat<O1, O2> = O1 & Omit_2<O2, keyof O1>;\r\n\r\nexport declare type Path<O, P, Default = never> = O extends unknown ? P extends [infer K, ...infer R] ? K extends keyof O ? Path<O[K], R> : Default : O : never;\r\n\r\nexport declare type Payload<T, F extends Operation = never> = T extends {\r\n    [K: symbol]: {\r\n        types: {\r\n            payload: any;\r\n        };\r\n    };\r\n} ? T[symbol]['types']['payload'] : any;\r\n\r\nexport declare type PayloadToResult<P, O extends Record_2<any, any> = RenameAndNestPayloadKeys<P>> = {\r\n    [K in keyof O]?: O[K][K] extends any[] ? PayloadToResult<O[K][K][number]>[] : O[K][K] extends object ? PayloadToResult<O[K][K]> : O[K][K];\r\n};\r\n\r\ndeclare type Pick_2<T, K extends string | number | symbol> = {\r\n    [P in keyof T as P extends K ? P : never]: T[P];\r\n};\r\nexport { Pick_2 as Pick }\r\n\r\ndeclare type PrimaryKey = ReadonlyDeep_2<{\r\n    name: string | null;\r\n    fields: string[];\r\n}>;\r\n\r\nexport declare class PrismaClientInitializationError extends Error {\r\n    clientVersion: string;\r\n    errorCode?: string;\r\n    retryable?: boolean;\r\n    constructor(message: string, clientVersion: string, errorCode?: string);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\nexport declare class PrismaClientKnownRequestError extends Error implements ErrorWithBatchIndex {\r\n    code: string;\r\n    meta?: Record<string, unknown>;\r\n    clientVersion: string;\r\n    batchRequestIdx?: number;\r\n    constructor(message: string, { code, clientVersion, meta, batchRequestIdx }: KnownErrorParams);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\nexport declare type PrismaClientOptions = {\r\n    /**\r\n     * Overwrites the primary datasource url from your schema.prisma file\r\n     */\r\n    datasourceUrl?: string;\r\n    /**\r\n     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale.\r\n     */\r\n    adapter?: SqlDriverAdapterFactory | null;\r\n    /**\r\n     * Overwrites the datasource url from your schema.prisma file\r\n     */\r\n    datasources?: Datasources;\r\n    /**\r\n     * @default \"colorless\"\r\n     */\r\n    errorFormat?: ErrorFormat;\r\n    /**\r\n     * The default values for Transaction options\r\n     * maxWait ?= 2000\r\n     * timeout ?= 5000\r\n     */\r\n    transactionOptions?: Transaction_2.Options;\r\n    /**\r\n     * @example\r\n     * \\`\\`\\`\r\n     * // Defaults to stdout\r\n     * log: ['query', 'info', 'warn']\r\n     *\r\n     * // Emit as events\r\n     * log: [\r\n     *  { emit: 'stdout', level: 'query' },\r\n     *  { emit: 'stdout', level: 'info' },\r\n     *  { emit: 'stdout', level: 'warn' }\r\n     * ]\r\n     * \\`\\`\\`\r\n     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).\r\n     */\r\n    log?: Array<LogLevel | LogDefinition>;\r\n    omit?: GlobalOmitOptions;\r\n    /**\r\n     * @internal\r\n     * You probably don't want to use this. \\`__internal\\` is used by internal tooling.\r\n     */\r\n    __internal?: {\r\n        debug?: boolean;\r\n        engine?: {\r\n            cwd?: string;\r\n            binaryPath?: string;\r\n            endpoint?: string;\r\n            allowTriggerPanic?: boolean;\r\n        };\r\n        /** This can be used for testing purposes */\r\n        configOverride?: (config: GetPrismaClientConfig) => GetPrismaClientConfig;\r\n    };\r\n};\r\n\r\nexport declare class PrismaClientRustPanicError extends Error {\r\n    clientVersion: string;\r\n    constructor(message: string, clientVersion: string);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\nexport declare class PrismaClientUnknownRequestError extends Error implements ErrorWithBatchIndex {\r\n    clientVersion: string;\r\n    batchRequestIdx?: number;\r\n    constructor(message: string, { clientVersion, batchRequestIdx }: UnknownErrorParams);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\nexport declare class PrismaClientValidationError extends Error {\r\n    name: string;\r\n    clientVersion: string;\r\n    constructor(message: string, { clientVersion }: Options);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\ndeclare function prismaGraphQLToJSError({ error, user_facing_error }: RequestError, clientVersion: string, activeProvider: string): PrismaClientKnownRequestError | PrismaClientUnknownRequestError;\r\n\r\ndeclare type PrismaOperationSpec<TArgs, TAction = string> = {\r\n    args: TArgs;\r\n    action: TAction;\r\n    model: string;\r\n};\r\n\r\nexport declare interface PrismaPromise<T> extends Promise<T> {\r\n    [Symbol.toStringTag]: 'PrismaPromise';\r\n}\r\n\r\n/**\r\n * Prisma's `Promise` that is backwards-compatible. All additions on top of the\r\n * original `Promise` are optional so that it can be backwards-compatible.\r\n * @see [[createPrismaPromise]]\r\n */\r\ndeclare interface PrismaPromise_2<TResult, TSpec extends PrismaOperationSpec<unknown> = any> extends Promise<TResult> {\r\n    get spec(): TSpec;\r\n    /**\r\n     * Extension of the original `.then` function\r\n     * @param onfulfilled same as regular promises\r\n     * @param onrejected same as regular promises\r\n     * @param transaction transaction options\r\n     */\r\n    then<R1 = TResult, R2 = never>(onfulfilled?: (value: TResult) => R1 | PromiseLike<R1>, onrejected?: (error: unknown) => R2 | PromiseLike<R2>, transaction?: PrismaPromiseTransaction): Promise<R1 | R2>;\r\n    /**\r\n     * Extension of the original `.catch` function\r\n     * @param onrejected same as regular promises\r\n     * @param transaction transaction options\r\n     */\r\n    catch<R = never>(onrejected?: ((reason: any) => R | PromiseLike<R>) | undefined | null, transaction?: PrismaPromiseTransaction): Promise<TResult | R>;\r\n    /**\r\n     * Extension of the original `.finally` function\r\n     * @param onfinally same as regular promises\r\n     * @param transaction transaction options\r\n     */\r\n    finally(onfinally?: (() => void) | undefined | null, transaction?: PrismaPromiseTransaction): Promise<TResult>;\r\n    /**\r\n     * Called when executing a batch of regular tx\r\n     * @param transaction transaction options for batch tx\r\n     */\r\n    requestTransaction?(transaction: PrismaPromiseBatchTransaction): PromiseLike<unknown>;\r\n}\r\n\r\ndeclare type PrismaPromiseBatchTransaction = {\r\n    kind: 'batch';\r\n    id: number;\r\n    isolationLevel?: IsolationLevel;\r\n    index: number;\r\n    lock: PromiseLike<void>;\r\n};\r\n\r\ndeclare type PrismaPromiseCallback = (transaction?: PrismaPromiseTransaction) => Promise<unknown>;\r\n\r\n/**\r\n * Creates a [[PrismaPromise]]. It is Prisma's implementation of `Promise` which\r\n * is essentially a proxy for `Promise`. All the transaction-compatible client\r\n * methods return one, this allows for pre-preparing queries without executing\r\n * them until `.then` is called. It's the foundation of Prisma's query batching.\r\n * @param callback that will be wrapped within our promise implementation\r\n * @see [[PrismaPromise]]\r\n * @returns\r\n */\r\ndeclare type PrismaPromiseFactory = <T extends PrismaOperationSpec<unknown>>(callback: PrismaPromiseCallback, op?: T) => PrismaPromise_2<unknown>;\r\n\r\ndeclare type PrismaPromiseInteractiveTransaction<PayloadType = unknown> = {\r\n    kind: 'itx';\r\n    id: string;\r\n    payload: PayloadType;\r\n};\r\n\r\ndeclare type PrismaPromiseTransaction<PayloadType = unknown> = PrismaPromiseBatchTransaction | PrismaPromiseInteractiveTransaction<PayloadType>;\r\n\r\nexport declare const PrivateResultType: unique symbol;\r\n\r\ndeclare type Provider = 'mysql' | 'postgres' | 'sqlite';\r\n\r\ndeclare namespace Public {\r\n    export {\r\n        validator\r\n    }\r\n}\r\nexport { Public }\r\n\r\ndeclare namespace Public_2 {\r\n    export {\r\n        Args,\r\n        Result,\r\n        Payload,\r\n        PrismaPromise,\r\n        Operation,\r\n        Exact\r\n    }\r\n}\r\n\r\ndeclare type Query = ReadonlyDeep_2<{\r\n    name: string;\r\n    args: SchemaArg[];\r\n    output: QueryOutput;\r\n}>;\r\n\r\ndeclare interface Queryable<Query, Result> extends AdapterInfo {\r\n    /**\r\n     * Execute a query and return its result.\r\n     */\r\n    queryRaw(params: Query): Promise<Result>;\r\n    /**\r\n     * Execute a query and return the number of affected rows.\r\n     */\r\n    executeRaw(params: Query): Promise<number>;\r\n}\r\n\r\ndeclare type QueryCompiler = {\r\n    compile(request: string): string;\r\n    compileBatch(batchRequest: string): BatchResponse;\r\n};\r\n\r\ndeclare interface QueryCompilerConstructor {\r\n    new (options: QueryCompilerOptions): QueryCompiler;\r\n}\r\n\r\ndeclare type QueryCompilerOptions = {\r\n    datamodel: string;\r\n    provider: Provider;\r\n    connectionInfo: ConnectionInfo;\r\n};\r\n\r\ndeclare type QueryEngineBatchGraphQLRequest = {\r\n    batch: QueryEngineRequest[];\r\n    transaction?: boolean;\r\n    isolationLevel?: IsolationLevel;\r\n};\r\n\r\ndeclare type QueryEngineBatchRequest = QueryEngineBatchGraphQLRequest | JsonBatchQuery;\r\n\r\ndeclare type QueryEngineConfig = {\r\n    datamodel: string;\r\n    configDir: string;\r\n    logQueries: boolean;\r\n    ignoreEnvVarErrors: boolean;\r\n    datasourceOverrides: Record<string, string>;\r\n    env: Record<string, string | undefined>;\r\n    logLevel: QueryEngineLogLevel;\r\n    engineProtocol: QueryEngineProtocol;\r\n    enableTracing: boolean;\r\n};\r\n\r\ndeclare interface QueryEngineConstructor {\r\n    new (config: QueryEngineConfig, logger: (log: string) => void, adapter?: ErrorCapturingSqlDriverAdapter): QueryEngineInstance;\r\n}\r\n\r\ndeclare type QueryEngineInstance = {\r\n    connect(headers: string, requestId: string): Promise<void>;\r\n    disconnect(headers: string, requestId: string): Promise<void>;\r\n    /**\r\n     * @param requestStr JSON.stringified `QueryEngineRequest | QueryEngineBatchRequest`\r\n     * @param headersStr JSON.stringified `QueryEngineRequestHeaders`\r\n     */\r\n    query(requestStr: string, headersStr: string, transactionId: string | undefined, requestId: string): Promise<string>;\r\n    sdlSchema?(): Promise<string>;\r\n    startTransaction(options: string, traceHeaders: string, requestId: string): Promise<string>;\r\n    commitTransaction(id: string, traceHeaders: string, requestId: string): Promise<string>;\r\n    rollbackTransaction(id: string, traceHeaders: string, requestId: string): Promise<string>;\r\n    metrics?(options: string): Promise<string>;\r\n    applyPendingMigrations?(): Promise<void>;\r\n    trace(requestId: string): Promise<string | null>;\r\n};\r\n\r\ndeclare type QueryEngineLogLevel = 'trace' | 'debug' | 'info' | 'warn' | 'error' | 'off';\r\n\r\ndeclare type QueryEngineProtocol = 'graphql' | 'json';\r\n\r\ndeclare type QueryEngineRequest = {\r\n    query: string;\r\n    variables: Object;\r\n};\r\n\r\ndeclare type QueryEngineResultData<T> = {\r\n    data: T;\r\n};\r\n\r\ndeclare type QueryEvent = {\r\n    timestamp: Date;\r\n    query: string;\r\n    params: string;\r\n    duration: number;\r\n    target: string;\r\n};\r\n\r\ndeclare type QueryEventType = 'query';\r\n\r\ndeclare type QueryIntrospectionBuiltinType = 'int' | 'bigint' | 'float' | 'double' | 'string' | 'enum' | 'bytes' | 'bool' | 'char' | 'decimal' | 'json' | 'xml' | 'uuid' | 'datetime' | 'date' | 'time' | 'int-array' | 'bigint-array' | 'float-array' | 'double-array' | 'string-array' | 'char-array' | 'bytes-array' | 'bool-array' | 'decimal-array' | 'json-array' | 'xml-array' | 'uuid-array' | 'datetime-array' | 'date-array' | 'time-array' | 'null' | 'unknown';\r\n\r\ndeclare type QueryMiddleware = (params: QueryMiddlewareParams, next: (params: QueryMiddlewareParams) => Promise<unknown>) => Promise<unknown>;\r\n\r\ndeclare type QueryMiddlewareParams = {\r\n    /** The model this is executed on */\r\n    model?: string;\r\n    /** The action that is being handled */\r\n    action: Action;\r\n    /** TODO what is this */\r\n    dataPath: string[];\r\n    /** TODO what is this */\r\n    runInTransaction: boolean;\r\n    args?: UserArgs_2;\r\n};\r\n\r\nexport declare type QueryOptions = {\r\n    query: {\r\n        [ModelName in string]: {\r\n            [ModelAction in string]: ModelQueryOptionsCb;\r\n        } | QueryOptionsCb;\r\n    };\r\n};\r\n\r\nexport declare type QueryOptionsCb = (args: QueryOptionsCbArgs) => Promise<any>;\r\n\r\nexport declare type QueryOptionsCbArgs = {\r\n    model?: string;\r\n    operation: string;\r\n    args: JsArgs | RawQueryArgs;\r\n    query: (args: JsArgs | RawQueryArgs) => Promise<unknown>;\r\n};\r\n\r\ndeclare type QueryOutput = ReadonlyDeep_2<{\r\n    name: string;\r\n    isRequired: boolean;\r\n    isList: boolean;\r\n}>;\r\n\r\n/**\r\n * Create raw SQL statement.\r\n */\r\nexport declare function raw(value: string): Sql;\r\n\r\nexport declare type RawParameters = {\r\n    __prismaRawParameters__: true;\r\n    values: string;\r\n};\r\n\r\nexport declare type RawQueryArgs = Sql | UnknownTypedSql | [query: string, ...values: RawValue[]];\r\n\r\ndeclare type RawResponse = {\r\n    columns: string[];\r\n    types: QueryIntrospectionBuiltinType[];\r\n    rows: unknown[][];\r\n};\r\n\r\ndeclare type RawTaggedValue = {\r\n    $type: 'Raw';\r\n    value: unknown;\r\n};\r\n\r\n/**\r\n * Supported value or SQL instance.\r\n */\r\nexport declare type RawValue = Value | Sql;\r\n\r\nexport declare type ReadonlyDeep<T> = {\r\n    readonly [K in keyof T]: ReadonlyDeep<T[K]>;\r\n};\r\n\r\ndeclare type ReadonlyDeep_2<O> = {\r\n    +readonly [K in keyof O]: ReadonlyDeep_2<O[K]>;\r\n};\r\n\r\ndeclare type Record_2<T extends string | number | symbol, U> = {\r\n    [P in T]: U;\r\n};\r\nexport { Record_2 as Record }\r\n\r\nexport declare type RenameAndNestPayloadKeys<P> = {\r\n    [K in keyof P as K extends 'scalars' | 'objects' | 'composites' ? keyof P[K] : never]: P[K];\r\n};\r\n\r\ndeclare type RequestBatchOptions<InteractiveTransactionPayload> = {\r\n    transaction?: TransactionOptions_3<InteractiveTransactionPayload>;\r\n    traceparent?: string;\r\n    numTry?: number;\r\n    containsWrite: boolean;\r\n    customDataProxyFetch?: CustomDataProxyFetch;\r\n};\r\n\r\ndeclare interface RequestError {\r\n    error: string;\r\n    user_facing_error: {\r\n        is_panic: boolean;\r\n        message: string;\r\n        meta?: Record<string, unknown>;\r\n        error_code?: string;\r\n        batch_request_idx?: number;\r\n    };\r\n}\r\n\r\ndeclare class RequestHandler {\r\n    client: Client;\r\n    dataloader: DataLoader<RequestParams>;\r\n    private logEmitter?;\r\n    constructor(client: Client, logEmitter?: LogEmitter);\r\n    request(params: RequestParams): Promise<any>;\r\n    mapQueryEngineResult({ dataPath, unpacker }: RequestParams, response: QueryEngineResultData<any>): any;\r\n    /**\r\n     * Handles the error and logs it, logging the error is done synchronously waiting for the event\r\n     * handlers to finish.\r\n     */\r\n    handleAndLogRequestError(params: HandleErrorParams): never;\r\n    handleRequestError({ error, clientMethod, callsite, transaction, args, modelName, globalOmit, }: HandleErrorParams): never;\r\n    sanitizeMessage(message: any): any;\r\n    unpack(data: unknown, dataPath: string[], unpacker?: Unpacker): any;\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\ndeclare type RequestOptions<InteractiveTransactionPayload> = {\r\n    traceparent?: string;\r\n    numTry?: number;\r\n    interactiveTransaction?: InteractiveTransactionOptions<InteractiveTransactionPayload>;\r\n    isWrite: boolean;\r\n    customDataProxyFetch?: CustomDataProxyFetch;\r\n};\r\n\r\ndeclare type RequestParams = {\r\n    modelName?: string;\r\n    action: Action;\r\n    protocolQuery: JsonQuery;\r\n    dataPath: string[];\r\n    clientMethod: string;\r\n    callsite?: CallSite;\r\n    transaction?: PrismaPromiseTransaction;\r\n    extensions: MergedExtensionsList;\r\n    args?: any;\r\n    headers?: Record<string, string>;\r\n    unpacker?: Unpacker;\r\n    otelParentCtx?: Context;\r\n    otelChildCtx?: Context;\r\n    globalOmit?: GlobalOmitOptions;\r\n    customDataProxyFetch?: CustomDataProxyFetch;\r\n};\r\n\r\ndeclare type RequiredExtensionArgs = NameArgs & ResultArgs & ModelArgs & ClientArgs & QueryOptions;\r\nexport { RequiredExtensionArgs }\r\nexport { RequiredExtensionArgs as UserArgs }\r\n\r\nexport declare type RequiredKeys<O> = {\r\n    [K in keyof O]-?: {} extends Pick_2<O, K> ? never : K;\r\n}[keyof O];\r\n\r\ndeclare function resolveDatasourceUrl({ inlineDatasources, overrideDatasources, env, clientVersion, }: {\r\n    inlineDatasources: GetPrismaClientConfig['inlineDatasources'];\r\n    overrideDatasources: Datasources;\r\n    env: Record<string, string | undefined>;\r\n    clientVersion: string;\r\n}): string;\r\n\r\nexport declare type Result<T, A, F extends Operation> = T extends {\r\n    [K: symbol]: {\r\n        types: {\r\n            payload: any;\r\n        };\r\n    };\r\n} ? GetResult<T[symbol]['types']['payload'], A, F> : GetResult<{\r\n    composites: {};\r\n    objects: {};\r\n    scalars: {};\r\n    name: '';\r\n}, {}, F>;\r\n\r\nexport declare type Result_2<T, A, F extends Operation> = Result<T, A, F>;\r\n\r\ndeclare namespace Result_3 {\r\n    export {\r\n        Count,\r\n        GetFindResult,\r\n        SelectablePayloadFields,\r\n        SelectField,\r\n        DefaultSelection,\r\n        UnwrapPayload,\r\n        ApplyOmit,\r\n        OmitValue,\r\n        GetCountResult,\r\n        Aggregate,\r\n        GetAggregateResult,\r\n        GetBatchResult,\r\n        GetGroupByResult,\r\n        GetResult,\r\n        ExtractGlobalOmit\r\n    }\r\n}\r\n\r\ndeclare type Result_4<T> = {\r\n    map<U>(fn: (value: T) => U): Result_4<U>;\r\n    flatMap<U>(fn: (value: T) => Result_4<U>): Result_4<U>;\r\n} & ({\r\n    readonly ok: true;\r\n    readonly value: T;\r\n} | {\r\n    readonly ok: false;\r\n    readonly error: Error_2;\r\n});\r\n\r\nexport declare type ResultArg = {\r\n    [FieldName in string]: ResultFieldDefinition;\r\n};\r\n\r\nexport declare type ResultArgs = {\r\n    result: {\r\n        [ModelName in string]: ResultArg;\r\n    };\r\n};\r\n\r\nexport declare type ResultArgsFieldCompute = (model: any) => unknown;\r\n\r\nexport declare type ResultFieldDefinition = {\r\n    needs?: {\r\n        [FieldName in string]: boolean;\r\n    };\r\n    compute: ResultArgsFieldCompute;\r\n};\r\n\r\nexport declare type Return<T> = T extends (...args: any[]) => infer R ? R : T;\r\n\r\nexport declare type RuntimeDataModel = {\r\n    readonly models: Record<string, RuntimeModel>;\r\n    readonly enums: Record<string, RuntimeEnum>;\r\n    readonly types: Record<string, RuntimeModel>;\r\n};\r\n\r\ndeclare type RuntimeEnum = Omit<DMMF_2.DatamodelEnum, 'name'>;\r\n\r\ndeclare type RuntimeModel = Omit<DMMF_2.Model, 'name'>;\r\n\r\ndeclare type RuntimeName = 'workerd' | 'deno' | 'netlify' | 'node' | 'bun' | 'edge-light' | '';\r\n\r\ndeclare type Schema = ReadonlyDeep_2<{\r\n    rootQueryType?: string;\r\n    rootMutationType?: string;\r\n    inputObjectTypes: {\r\n        model?: InputType[];\r\n        prisma: InputType[];\r\n    };\r\n    outputObjectTypes: {\r\n        model: OutputType[];\r\n        prisma: OutputType[];\r\n    };\r\n    enumTypes: {\r\n        model?: SchemaEnum[];\r\n        prisma: SchemaEnum[];\r\n    };\r\n    fieldRefTypes: {\r\n        prisma?: FieldRefType[];\r\n    };\r\n}>;\r\n\r\ndeclare type SchemaArg = ReadonlyDeep_2<{\r\n    name: string;\r\n    comment?: string;\r\n    isNullable: boolean;\r\n    isRequired: boolean;\r\n    inputTypes: InputTypeRef[];\r\n    deprecation?: Deprecation;\r\n}>;\r\n\r\ndeclare type SchemaEnum = ReadonlyDeep_2<{\r\n    name: string;\r\n    values: string[];\r\n}>;\r\n\r\ndeclare type SchemaField = ReadonlyDeep_2<{\r\n    name: string;\r\n    isNullable?: boolean;\r\n    outputType: OutputTypeRef;\r\n    args: SchemaArg[];\r\n    deprecation?: Deprecation;\r\n    documentation?: string;\r\n}>;\r\n\r\nexport declare type Select<T, U> = T extends U ? T : never;\r\n\r\nexport declare type SelectablePayloadFields<K extends PropertyKey, O> = {\r\n    objects: {\r\n        [k in K]: O;\r\n    };\r\n} | {\r\n    composites: {\r\n        [k in K]: O;\r\n    };\r\n};\r\n\r\nexport declare type SelectField<P extends SelectablePayloadFields<any, any>, K extends PropertyKey> = P extends {\r\n    objects: Record<K, any>;\r\n} ? P['objects'][K] : P extends {\r\n    composites: Record<K, any>;\r\n} ? P['composites'][K] : never;\r\n\r\ndeclare type Selection_2 = Record<string, boolean | Skip | JsArgs>;\r\nexport { Selection_2 as Selection }\r\n\r\nexport declare function serializeJsonQuery({ modelName, action, args, runtimeDataModel, extensions, callsite, clientMethod, errorFormat, clientVersion, previewFeatures, globalOmit, }: SerializeParams): JsonQuery;\r\n\r\ndeclare type SerializeParams = {\r\n    runtimeDataModel: RuntimeDataModel;\r\n    modelName?: string;\r\n    action: Action;\r\n    args?: JsArgs;\r\n    extensions?: MergedExtensionsList;\r\n    callsite?: CallSite;\r\n    clientMethod: string;\r\n    clientVersion: string;\r\n    errorFormat: ErrorFormat;\r\n    previewFeatures: string[];\r\n    globalOmit?: GlobalOmitOptions;\r\n};\r\n\r\ndeclare class Skip {\r\n    constructor(param?: symbol);\r\n    ifUndefined<T>(value: T | undefined): T | Skip;\r\n}\r\n\r\nexport declare const skip: Skip;\r\n\r\ndeclare type SortOrder = 'asc' | 'desc';\r\n\r\n/**\r\n * An interface that represents a span. A span represents a single operation\r\n * within a trace. Examples of span might include remote procedure calls or a\r\n * in-process function calls to sub-components. A Trace has a single, top-level\r\n * \"root\" Span that in turn may have zero or more child Spans, which in turn\r\n * may have children.\r\n *\r\n * Spans are created by the {@link Tracer.startSpan} method.\r\n */\r\ndeclare interface Span {\r\n    /**\r\n     * Returns the {@link SpanContext} object associated with this Span.\r\n     *\r\n     * Get an immutable, serializable identifier for this span that can be used\r\n     * to create new child spans. Returned SpanContext is usable even after the\r\n     * span ends.\r\n     *\r\n     * @returns the SpanContext object associated with this Span.\r\n     */\r\n    spanContext(): SpanContext;\r\n    /**\r\n     * Sets an attribute to the span.\r\n     *\r\n     * Sets a single Attribute with the key and value passed as arguments.\r\n     *\r\n     * @param key the key for this attribute.\r\n     * @param value the value for this attribute. Setting a value null or\r\n     *              undefined is invalid and will result in undefined behavior.\r\n     */\r\n    setAttribute(key: string, value: SpanAttributeValue): this;\r\n    /**\r\n     * Sets attributes to the span.\r\n     *\r\n     * @param attributes the attributes that will be added.\r\n     *                   null or undefined attribute values\r\n     *                   are invalid and will result in undefined behavior.\r\n     */\r\n    setAttributes(attributes: SpanAttributes): this;\r\n    /**\r\n     * Adds an event to the Span.\r\n     *\r\n     * @param name the name of the event.\r\n     * @param [attributesOrStartTime] the attributes that will be added; these are\r\n     *     associated with this event. Can be also a start time\r\n     *     if type is {@type TimeInput} and 3rd param is undefined\r\n     * @param [startTime] start time of the event.\r\n     */\r\n    addEvent(name: string, attributesOrStartTime?: SpanAttributes | TimeInput, startTime?: TimeInput): this;\r\n    /**\r\n     * Adds a single link to the span.\r\n     *\r\n     * Links added after the creation will not affect the sampling decision.\r\n     * It is preferred span links be added at span creation.\r\n     *\r\n     * @param link the link to add.\r\n     */\r\n    addLink(link: Link): this;\r\n    /**\r\n     * Adds multiple links to the span.\r\n     *\r\n     * Links added after the creation will not affect the sampling decision.\r\n     * It is preferred span links be added at span creation.\r\n     *\r\n     * @param links the links to add.\r\n     */\r\n    addLinks(links: Link[]): this;\r\n    /**\r\n     * Sets a status to the span. If used, this will override the default Span\r\n     * status. Default is {@link SpanStatusCode.UNSET}. SetStatus overrides the value\r\n     * of previous calls to SetStatus on the Span.\r\n     *\r\n     * @param status the SpanStatus to set.\r\n     */\r\n    setStatus(status: SpanStatus): this;\r\n    /**\r\n     * Updates the Span name.\r\n     *\r\n     * This will override the name provided via {@link Tracer.startSpan}.\r\n     *\r\n     * Upon this update, any sampling behavior based on Span name will depend on\r\n     * the implementation.\r\n     *\r\n     * @param name the Span name.\r\n     */\r\n    updateName(name: string): this;\r\n    /**\r\n     * Marks the end of Span execution.\r\n     *\r\n     * Call to End of a Span MUST not have any effects on child spans. Those may\r\n     * still be running and can be ended later.\r\n     *\r\n     * Do not return `this`. The Span generally should not be used after it\r\n     * is ended so chaining is not desired in this context.\r\n     *\r\n     * @param [endTime] the time to set as Span's end time. If not provided,\r\n     *     use the current time as the span's end time.\r\n     */\r\n    end(endTime?: TimeInput): void;\r\n    /**\r\n     * Returns the flag whether this span will be recorded.\r\n     *\r\n     * @returns true if this Span is active and recording information like events\r\n     *     with the `AddEvent` operation and attributes using `setAttributes`.\r\n     */\r\n    isRecording(): boolean;\r\n    /**\r\n     * Sets exception as a span event\r\n     * @param exception the exception the only accepted values are string or Error\r\n     * @param [time] the time to set as Span's event time. If not provided,\r\n     *     use the current time.\r\n     */\r\n    recordException(exception: Exception, time?: TimeInput): void;\r\n}\r\n\r\n/**\r\n * @deprecated please use {@link Attributes}\r\n */\r\ndeclare type SpanAttributes = Attributes;\r\n\r\n/**\r\n * @deprecated please use {@link AttributeValue}\r\n */\r\ndeclare type SpanAttributeValue = AttributeValue;\r\n\r\ndeclare type SpanCallback<R> = (span?: Span, context?: Context) => R;\r\n\r\n/**\r\n * A SpanContext represents the portion of a {@link Span} which must be\r\n * serialized and propagated along side of a {@link Baggage}.\r\n */\r\ndeclare interface SpanContext {\r\n    /**\r\n     * The ID of the trace that this span belongs to. It is worldwide unique\r\n     * with practically sufficient probability by being made as 16 randomly\r\n     * generated bytes, encoded as a 32 lowercase hex characters corresponding to\r\n     * 128 bits.\r\n     */\r\n    traceId: string;\r\n    /**\r\n     * The ID of the Span. It is globally unique with practically sufficient\r\n     * probability by being made as 8 randomly generated bytes, encoded as a 16\r\n     * lowercase hex characters corresponding to 64 bits.\r\n     */\r\n    spanId: string;\r\n    /**\r\n     * Only true if the SpanContext was propagated from a remote parent.\r\n     */\r\n    isRemote?: boolean;\r\n    /**\r\n     * Trace flags to propagate.\r\n     *\r\n     * It is represented as 1 byte (bitmap). Bit to represent whether trace is\r\n     * sampled or not. When set, the least significant bit documents that the\r\n     * caller may have recorded trace data. A caller who does not record trace\r\n     * data out-of-band leaves this flag unset.\r\n     *\r\n     * see {@link TraceFlags} for valid flag values.\r\n     */\r\n    traceFlags: number;\r\n    /**\r\n     * Tracing-system-specific info to propagate.\r\n     *\r\n     * The tracestate field value is a `list` as defined below. The `list` is a\r\n     * series of `list-members` separated by commas `,`, and a list-member is a\r\n     * key/value pair separated by an equals sign `=`. Spaces and horizontal tabs\r\n     * surrounding `list-members` are ignored. There can be a maximum of 32\r\n     * `list-members` in a `list`.\r\n     * More Info: https://www.w3.org/TR/trace-context/#tracestate-field\r\n     *\r\n     * Examples:\r\n     *     Single tracing system (generic format):\r\n     *         tracestate: rojo=00f067aa0ba902b7\r\n     *     Multiple tracing systems (with different formatting):\r\n     *         tracestate: rojo=00f067aa0ba902b7,congo=t61rcWkgMzE\r\n     */\r\n    traceState?: TraceState;\r\n}\r\n\r\ndeclare enum SpanKind {\r\n    /** Default value. Indicates that the span is used internally. */\r\n    INTERNAL = 0,\r\n    /**\r\n     * Indicates that the span covers server-side handling of an RPC or other\r\n     * remote request.\r\n     */\r\n    SERVER = 1,\r\n    /**\r\n     * Indicates that the span covers the client-side wrapper around an RPC or\r\n     * other remote request.\r\n     */\r\n    CLIENT = 2,\r\n    /**\r\n     * Indicates that the span describes producer sending a message to a\r\n     * broker. Unlike client and server, there is no direct critical path latency\r\n     * relationship between producer and consumer spans.\r\n     */\r\n    PRODUCER = 3,\r\n    /**\r\n     * Indicates that the span describes consumer receiving a message from a\r\n     * broker. Unlike client and server, there is no direct critical path latency\r\n     * relationship between producer and consumer spans.\r\n     */\r\n    CONSUMER = 4\r\n}\r\n\r\n/**\r\n * Options needed for span creation\r\n */\r\ndeclare interface SpanOptions {\r\n    /**\r\n     * The SpanKind of a span\r\n     * @default {@link SpanKind.INTERNAL}\r\n     */\r\n    kind?: SpanKind;\r\n    /** A span's attributes */\r\n    attributes?: SpanAttributes;\r\n    /** {@link Link}s span to other spans */\r\n    links?: Link[];\r\n    /** A manually specified start time for the created `Span` object. */\r\n    startTime?: TimeInput;\r\n    /** The new span should be a root span. (Ignore parent from context). */\r\n    root?: boolean;\r\n}\r\n\r\ndeclare interface SpanStatus {\r\n    /** The status code of this message. */\r\n    code: SpanStatusCode;\r\n    /** A developer-facing error message. */\r\n    message?: string;\r\n}\r\n\r\n/**\r\n * An enumeration of status codes.\r\n */\r\ndeclare enum SpanStatusCode {\r\n    /**\r\n     * The default status.\r\n     */\r\n    UNSET = 0,\r\n    /**\r\n     * The operation has been validated by an Application developer or\r\n     * Operator to have completed successfully.\r\n     */\r\n    OK = 1,\r\n    /**\r\n     * The operation contains an error.\r\n     */\r\n    ERROR = 2\r\n}\r\n\r\n/**\r\n * A SQL instance can be nested within each other to build SQL strings.\r\n */\r\nexport declare class Sql {\r\n    readonly values: Value[];\r\n    readonly strings: string[];\r\n    constructor(rawStrings: readonly string[], rawValues: readonly RawValue[]);\r\n    get sql(): string;\r\n    get statement(): string;\r\n    get text(): string;\r\n    inspect(): {\r\n        sql: string;\r\n        statement: string;\r\n        text: string;\r\n        values: unknown[];\r\n    };\r\n}\r\n\r\ndeclare interface SqlDriverAdapter extends SqlQueryable {\r\n    /**\r\n     * Execute multiple SQL statements separated by semicolon.\r\n     */\r\n    executeScript(script: string): Promise<void>;\r\n    /**\r\n     * Start new transaction.\r\n     */\r\n    startTransaction(isolationLevel?: IsolationLevel): Promise<Transaction>;\r\n    /**\r\n     * Optional method that returns extra connection info\r\n     */\r\n    getConnectionInfo?(): ConnectionInfo;\r\n    /**\r\n     * Dispose of the connection and release any resources.\r\n     */\r\n    dispose(): Promise<void>;\r\n}\r\n\r\nexport declare interface SqlDriverAdapterFactory extends DriverAdapterFactory<SqlQuery, SqlResultSet> {\r\n    connect(): Promise<SqlDriverAdapter>;\r\n}\r\n\r\ndeclare type SqlQuery = {\r\n    sql: string;\r\n    args: Array<unknown>;\r\n    argTypes: Array<ArgType>;\r\n};\r\n\r\ndeclare interface SqlQueryable extends Queryable<SqlQuery, SqlResultSet> {\r\n}\r\n\r\ndeclare interface SqlResultSet {\r\n    /**\r\n     * List of column types appearing in a database query, in the same order as `columnNames`.\r\n     * They are used within the Query Engine to convert values from JS to Quaint values.\r\n     */\r\n    columnTypes: Array<ColumnType>;\r\n    /**\r\n     * List of column names appearing in a database query, in the same order as `columnTypes`.\r\n     */\r\n    columnNames: Array<string>;\r\n    /**\r\n     * List of rows retrieved from a database query.\r\n     * Each row is a list of values, whose length matches `columnNames` and `columnTypes`.\r\n     */\r\n    rows: Array<Array<unknown>>;\r\n    /**\r\n     * The last ID of an `INSERT` statement, if any.\r\n     * This is required for `AUTO_INCREMENT` columns in databases based on MySQL and SQLite.\r\n     */\r\n    lastInsertId?: string;\r\n}\r\n\r\n/**\r\n * Create a SQL object from a template string.\r\n */\r\nexport declare function sqltag(strings: readonly string[], ...values: readonly RawValue[]): Sql;\r\n\r\n/**\r\n * Defines TimeInput.\r\n *\r\n * hrtime, epoch milliseconds, performance.now() or Date\r\n */\r\ndeclare type TimeInput = HrTime_2 | number | Date;\r\n\r\nexport declare type ToTuple<T> = T extends any[] ? T : [T];\r\n\r\ndeclare interface TraceState {\r\n    /**\r\n     * Create a new TraceState which inherits from this TraceState and has the\r\n     * given key set.\r\n     * The new entry will always be added in the front of the list of states.\r\n     *\r\n     * @param key key of the TraceState entry.\r\n     * @param value value of the TraceState entry.\r\n     */\r\n    set(key: string, value: string): TraceState;\r\n    /**\r\n     * Return a new TraceState which inherits from this TraceState but does not\r\n     * contain the given key.\r\n     *\r\n     * @param key the key for the TraceState entry to be removed.\r\n     */\r\n    unset(key: string): TraceState;\r\n    /**\r\n     * Returns the value to which the specified key is mapped, or `undefined` if\r\n     * this map contains no mapping for the key.\r\n     *\r\n     * @param key with which the specified value is to be associated.\r\n     * @returns the value to which the specified key is mapped, or `undefined` if\r\n     *     this map contains no mapping for the key.\r\n     */\r\n    get(key: string): string | undefined;\r\n    /**\r\n     * Serializes the TraceState to a `list` as defined below. The `list` is a\r\n     * series of `list-members` separated by commas `,`, and a list-member is a\r\n     * key/value pair separated by an equals sign `=`. Spaces and horizontal tabs\r\n     * surrounding `list-members` are ignored. There can be a maximum of 32\r\n     * `list-members` in a `list`.\r\n     *\r\n     * @returns the serialized string.\r\n     */\r\n    serialize(): string;\r\n}\r\n\r\ndeclare interface TracingHelper {\r\n    isEnabled(): boolean;\r\n    getTraceParent(context?: Context): string;\r\n    dispatchEngineSpans(spans: EngineSpan[]): void;\r\n    getActiveContext(): Context | undefined;\r\n    runInChildSpan<R>(nameOrOptions: string | ExtendedSpanOptions, callback: SpanCallback<R>): R;\r\n}\r\n\r\ndeclare interface Transaction extends AdapterInfo, SqlQueryable {\r\n    /**\r\n     * Transaction options.\r\n     */\r\n    readonly options: TransactionOptions;\r\n    /**\r\n     * Commit the transaction.\r\n     */\r\n    commit(): Promise<void>;\r\n    /**\r\n     * Roll back the transaction.\r\n     */\r\n    rollback(): Promise<void>;\r\n}\r\n\r\ndeclare namespace Transaction_2 {\r\n    export {\r\n        TransactionOptions_2 as Options,\r\n        InteractiveTransactionInfo,\r\n        TransactionHeaders\r\n    }\r\n}\r\n\r\ndeclare type TransactionHeaders = {\r\n    traceparent?: string;\r\n};\r\n\r\ndeclare type TransactionOptions = {\r\n    usePhantomQuery: boolean;\r\n};\r\n\r\ndeclare type TransactionOptions_2 = {\r\n    maxWait?: number;\r\n    timeout?: number;\r\n    isolationLevel?: IsolationLevel;\r\n};\r\n\r\ndeclare type TransactionOptions_3<InteractiveTransactionPayload> = {\r\n    kind: 'itx';\r\n    options: InteractiveTransactionOptions<InteractiveTransactionPayload>;\r\n} | {\r\n    kind: 'batch';\r\n    options: BatchTransactionOptions;\r\n};\r\n\r\nexport declare class TypedSql<Values extends readonly unknown[], Result> {\r\n    [PrivateResultType]: Result;\r\n    constructor(sql: string, values: Values);\r\n    get sql(): string;\r\n    get values(): Values;\r\n}\r\n\r\nexport declare type TypeMapCbDef = Fn<{\r\n    extArgs: InternalArgs;\r\n}, TypeMapDef>;\r\n\r\n/** Shared */\r\nexport declare type TypeMapDef = Record<any, any>;\r\n\r\ndeclare type TypeRef<AllowedLocations extends FieldLocation> = {\r\n    isList: boolean;\r\n    type: string;\r\n    location: AllowedLocations;\r\n    namespace?: FieldNamespace;\r\n};\r\n\r\ndeclare namespace Types {\r\n    export {\r\n        Result_3 as Result,\r\n        Extensions_2 as Extensions,\r\n        Utils,\r\n        Public_2 as Public,\r\n        isSkip,\r\n        Skip,\r\n        skip,\r\n        UnknownTypedSql,\r\n        OperationPayload as Payload\r\n    }\r\n}\r\nexport { Types }\r\n\r\ndeclare type uniqueIndex = ReadonlyDeep_2<{\r\n    name: string;\r\n    fields: string[];\r\n}>;\r\n\r\ndeclare type UnknownErrorParams = {\r\n    clientVersion: string;\r\n    batchRequestIdx?: number;\r\n};\r\n\r\nexport declare type UnknownTypedSql = TypedSql<unknown[], unknown>;\r\n\r\ndeclare type Unpacker = (data: any) => any;\r\n\r\nexport declare type UnwrapPayload<P> = {} extends P ? unknown : {\r\n    [K in keyof P]: P[K] extends {\r\n        scalars: infer S;\r\n        composites: infer C;\r\n    }[] ? Array<S & UnwrapPayload<C>> : P[K] extends {\r\n        scalars: infer S;\r\n        composites: infer C;\r\n    } | null ? S & UnwrapPayload<C> | Select<P[K], null> : never;\r\n};\r\n\r\nexport declare type UnwrapPromise<P> = P extends Promise<infer R> ? R : P;\r\n\r\nexport declare type UnwrapTuple<Tuple extends readonly unknown[]> = {\r\n    [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>;\r\n};\r\n\r\n/**\r\n * Input that flows from the user into the Client.\r\n */\r\ndeclare type UserArgs_2 = any;\r\n\r\ndeclare namespace Utils {\r\n    export {\r\n        EmptyToUnknown,\r\n        NeverToUnknown,\r\n        PatchFlat,\r\n        Omit_2 as Omit,\r\n        Pick_2 as Pick,\r\n        ComputeDeep,\r\n        Compute,\r\n        OptionalFlat,\r\n        ReadonlyDeep,\r\n        Narrowable,\r\n        Narrow,\r\n        Exact,\r\n        Cast,\r\n        Record_2 as Record,\r\n        UnwrapPromise,\r\n        UnwrapTuple,\r\n        Path,\r\n        Fn,\r\n        Call,\r\n        RequiredKeys,\r\n        OptionalKeys,\r\n        Optional,\r\n        Return,\r\n        ToTuple,\r\n        RenameAndNestPayloadKeys,\r\n        PayloadToResult,\r\n        Select,\r\n        Equals,\r\n        Or,\r\n        JsPromise\r\n    }\r\n}\r\n\r\ndeclare function validator<V>(): <S>(select: Exact<S, V>) => S;\r\n\r\ndeclare function validator<C, M extends Exclude<keyof C, `$${string}`>, O extends keyof C[M] & Operation>(client: C, model: M, operation: O): <S>(select: Exact<S, Args<C[M], O>>) => S;\r\n\r\ndeclare function validator<C, M extends Exclude<keyof C, `$${string}`>, O extends keyof C[M] & Operation, P extends keyof Args<C[M], O>>(client: C, model: M, operation: O, prop: P): <S>(select: Exact<S, Args<C[M], O>[P]>) => S;\r\n\r\n/**\r\n * Values supported by SQL engine.\r\n */\r\nexport declare type Value = unknown;\r\n\r\nexport declare function warnEnvConflicts(envPaths: any): void;\r\n\r\nexport declare const warnOnce: (key: string, message: string, ...args: unknown[]) => void;\r\n\r\nexport { }\r\n",
        "node_modules/.prisma/client/wasm.d.ts": "export * from \"./index\"",
        "node_modules/@prisma/client/index.d.ts": "export * from '.prisma/client/default'"
      },
      "document": "# Prisma Markdown\n\n> Generated by [`prisma-markdown`](https://github.com/samchon/prisma-markdown)\n\n- [Core](#core)\n- [Posts](#posts)\n- [Votes](#votes)\n\n## Core\n\n```mermaid\nerDiagram\n\"users\" {\n  String id PK\n  String user_role_id FK\n  String username UK\n  String email UK\n  String bio \"nullable\"\n  String password_hash\n  DateTime created_at\n  DateTime updated_at\n  String status\n}\n\"user_roles\" {\n  String id PK\n  String name UK\n  String description\n}\n\"categories\" {\n  String id PK\n  String name UK\n  String description\n  DateTime created_at\n}\n\"users\" }o--|| \"user_roles\" : role\n```\n\n### `users`\n\nUser information - This implements the 'User' entity from the requirements analysis document (03_data_structure_and_business_rules.md). \n\nRepresents registered members of the discussion board. Each user record holds public profile data and permissions (role and status). For example, Alice with email alice@email.com can be a regular user, moderator, or admin.\n\nKey relationships: references user_roles for permission, and relates to posts, comments, and votes they create.\nSpecial behaviors: emails are unique; passwords are stored securely; role assignment required.\n\nProperties as follows:\n\n- `id`\n  > Primary Key.\n  > Unique identifier for each user.\n- `user_role_id`\n  > Role of the user. Target model's [user_roles.id](#user_roles).\n  > Determines user permissions such as regular member, moderator, or administrator.\n- `username`: Username visible on the platform - Implements profile display requirement. Must be unique and public. For example, 'politicoFan88'.\n- `email`: User's email address - Used for login and notifications. Must be unique. For example, 'user@example.com'.\n- `bio`: Optional short biography - Lets users share info about themselves. For example, 'Economics student, debate enthusiast.'\n- `password_hash`: Hashed password - Implements security requirement. Stores a hashed version of the user password for authentication. Example: long hash string. Not public.\n- `created_at`: Account creation timestamp - Implements auditability. For example, '2024-06-09T10:00:00+09:00'.\n- `updated_at`: Timestamp of last profile update - Implements history/auth traceability. For example, '2024-07-01T12:30:00+09:00'.\n- `status`: Account status - Implements moderation/authentication rules. For example, 'active', 'suspended', or 'banned'.\n\n### `user_roles`\n\nUser role definitions - This implements the role structure outlined in user roles section of the requirements analysis document (02_key_features_and_user_roles.md).\n\nDefines different permissions and capabilities for users. For example, 'member', 'moderator', 'administrator'.\n\nKey relationships: referenced by users table; no direct link to posts or comments.\nSpecial behaviors: role 'name' must be unique.\n\nProperties as follows:\n\n- `id`: Primary Key. Unique identifier for user role.\n- `name`: Role label - Implements user roles requirement. Example: 'member', 'moderator', 'administrator'. Must be unique.\n- `description`: Role description - Gives context about permissions and duties; e.g., 'Can moderate comments and suspend users' for moderators.\n\n### `categories`\n\nDiscussion categories - This covers the 'Category' entity from the requirements document (03_data_structure_and_business_rules.md).\n\nRepresents the main topic divisions organizing posts. For example, 'Politics', 'Economics', 'International Affairs'.\n\nKey relationships: referenced by posts; managed by administrators.\nSpecial behaviors: unique name required, can be suggested by users but created by admin.\n\nProperties as follows:\n\n- `id`: Primary Key. Unique identifier for category.\n- `name`: Category name - Implements content organization and navigation requirement. For example, 'Politics'. Must be unique per category.\n- `description`: Category description - Explains scope. For example, 'Discussion about domestic and international political systems, governance, and related events.'\n- `created_at`: Timestamp when the category was added - Implements audit trail. Example: '2024-06-09T09:00:00+09:00'.\n\n## Posts\n\n```mermaid\nerDiagram\n\"posts\" {\n  String id PK\n  String user_id FK\n  String category_id FK\n  String title\n  String content\n  DateTime created_at\n  DateTime updated_at\n  DateTime deleted_at \"nullable\"\n}\n\"comments\" {\n  String id PK\n  String user_id FK\n  String post_id FK\n  String parent_id FK \"nullable\"\n  String content\n  DateTime created_at\n  DateTime updated_at\n  DateTime deleted_at \"nullable\"\n}\n\"comments\" }o--|| \"posts\" : post\n\"comments\" }o--o| \"comments\" : parent\n```\n\n### `posts`\n\nPost entity - This implements the 'Post' entity from the requirements document (see Data Structure and Business Rules, section 1, and Example Scenario). \n\nRepresents discussion topics or articles submitted by users. Provides a core construct to enable users to initiate threads, share analysis, and start community debates. For example, a user posts a discussion about inflation in the 'Economics' category. \n\nKey relationships: Each post belongs to one user (author) and one category. Each post can have many comments and votes. \nSpecial behaviors: A post must be assigned to a category, may be edited/deleted by its author, and is visible to all users. Vote tally and creation metadata are key for surfacing relevant content.\n\nProperties as follows:\n\n- `id`: Primary Key. Unique identifier for each post.\n- `user_id`: Author's [users.id](#users) - Links each post to its authoring user account. Enforces the association between posts and registered users. Required for accountability and profile-related features.\n- `category_id`: Category's [categories.id](#categories) - Associates the post with a topic/category, used for board structure and navigation. Enforces the requirement that every post has a topical context.\n- `title`: Title of the post - Implements the requirement that each post has a headline/subject. Business meaning: summary/subject line visible in post lists and thread views. For example, 'Economic Impact of Inflation in 2025'.\n- `content`: Body content of the post - Implements the rule that posts have main text where users express opinions, share news, analysis, etc. For example, a 400-word analysis of current economic events. Allows rich content or text.\n- `created_at`: Creation timestamp - Implements transparency and audit requirements by recording when the post was created. Business use: shows recency in lists, allows moderation tracking.\n- `updated_at`: Last edited timestamp - Allows tracking of post edits for evidence/history. Enforces business constraint of allowing users to edit posts within the permitted window. For example, updated_at is changed when a user fixes a typo.\n- `deleted_at`: Soft deletion timestamp - Implements moderation rules (see Moderation and User Roles). Posts are not hard deleted but marked with this field if removed for rule violations or by user request. For example, moderators mark spam here for audit/history.\n\n### `comments`\n\nComment entity - This implements the 'Comment' entity from the requirements (see Data Structure and Business Rules section 1, and Example Scenario).\n\nRepresents replies to posts or other comments, allowing for nested conversations and community discussion. For example, a user comments on a post about inflation, or replies to another comment with their opinion.\n\nKey relationships: Each comment is written by a user and is attached either directly to a post or as a nested reply to another comment. Each comment can have multiple votes. Replies form a hierarchy.\nSpecial behaviors: Only registered users can comment. Comments may be deleted/edited by their author within constraints. Vote tally supports surfacing relevant replies. Threaded (self-referential) relations supported.\n\nProperties as follows:\n\n- `id`: Primary Key. Unique identifier for each comment.\n- `user_id`: Author's [users.id](#users) - Indicates the owner/author of the comment. Enforces accountability, links to profile and reputation system. Required for audit and moderation.\n- `post_id`: Parent post's [posts.id](#posts) - The post that this comment is in response to. Implements the association between comments and discussions. Required unless it's a reply to another comment only.\n- `parent_id`: Parent comment's [comments.id](#comments) - Implements threaded/nested replies, allowing for comment hierarchies. Enables conversations to branch. Nullable for top-level comments (direct responses to posts).\n- `content`: Comment body - Implements the rule that each comment consists of user-written text/content. Used for replies, opinions, and ongoing discussion. For example, 'I agree and here’s why...'.\n- `created_at`: Creation timestamp - Implements audit/history requirement for comment posting, tracking the date and time for moderation and display ordering. For example, enables 'most recent first' sorting.\n- `updated_at`: Last edited timestamp - Implements edit history tracking for evidence and transparency. If a user updates their comment, this records when.\n- `deleted_at`: Soft deletion timestamp - Implements moderation controls by marking comments removed (not hard deleted) for evidence/history. Used if comment violates rules, is self-removed, or by moderator action.\n\n## Votes\n\n```mermaid\nerDiagram\n\"votes\" {\n  String id PK\n  String user_id FK\n  String post_id FK \"nullable\"\n  String comment_id FK \"nullable\"\n  Int value\n  DateTime created_at\n}\n```\n\n### `votes`\n\nVote records - This implements the voting/feedback requirements section described in the requirements analysis, enabling users to provide positive or negative feedback on posts and comments in the discussion board. \n\nBusiness purpose: Allows users to upvote or downvote content, surfacing high-quality posts and comments, while discouraging low-quality contributions. Only registered users can cast votes and only one vote per content item per user is allowed, enforcing fairness and preventing manipulation. Used to calculate real-time content ranking and trust metrics.\n\nKey relationships: Votes always belong to a user and point to either a post or a comment. The voted target is mutually exclusive: each row references either a post or a comment, but never both. \n\nSpecial behaviors: Unique constraint ensures one vote per user per post or comment. Cascade deletion if the user or voted content is removed, to maintain data integrity.\n\nProperties as follows:\n\n- `id`: Primary Key. Unique identifier for each vote record.\n- `user_id`: Voter's user reference - Links each vote to the user who cast it. Implements the requirement that only registered users can vote. Business meaning: Tracks voting history and enforces unique voting constraints. Example: User 'U' upvotes a comment, linking the vote to 'U's user_id.\n- `post_id`: Target post's reference - References the post being voted on, if the vote relates to a post (and not a comment). Implements mutual exclusivity rule and enables vote tallies for posts. Example: Voting on a thread increases the tally on the referenced post. Constraint: Only one of post_id or comment_id is non-null per row.\n- `comment_id`: Target comment's reference - References the comment being voted on, if applicable. Implements mutual exclusivity rule as with posts. Example: Voting on a reply records the vote linked to this comment. Only one of post_id or comment_id is set per vote record.\n- `value`: Vote value - Implements the upvote/downvote requirement. Stores +1 for upvote, -1 for downvote. Business meaning: This value is aggregated to produce content rankings. Example: A +1 value indicates an upvote from a user.\n- `created_at`: Vote timestamp - Implements auditing requirements for vote tracking. Stores the date and time the vote was made. Used for analytics and to enforce time-based voting limits, if ever required by policy.\n",
      "diagrams": {
        "Core": "```mermaid\nerDiagram\n\"users\" {\n  String id PK\n  String user_role_id FK\n  String username UK\n  String email UK\n  String bio \"nullable\"\n  String password_hash\n  DateTime created_at\n  DateTime updated_at\n  String status\n}\n\"user_roles\" {\n  String id PK\n  String name UK\n  String description\n}\n\"categories\" {\n  String id PK\n  String name UK\n  String description\n  DateTime created_at\n}\n\"users\" }o--|| \"user_roles\" : role\n```",
        "Posts": "```mermaid\nerDiagram\n\"posts\" {\n  String id PK\n  String user_id FK\n  String category_id FK\n  String title\n  String content\n  DateTime created_at\n  DateTime updated_at\n  DateTime deleted_at \"nullable\"\n}\n\"comments\" {\n  String id PK\n  String user_id FK\n  String post_id FK\n  String parent_id FK \"nullable\"\n  String content\n  DateTime created_at\n  DateTime updated_at\n  DateTime deleted_at \"nullable\"\n}\n\"comments\" }o--|| \"posts\" : post\n\"comments\" }o--o| \"comments\" : parent\n```",
        "Votes": "```mermaid\nerDiagram\n\"votes\" {\n  String id PK\n  String user_id FK\n  String post_id FK \"nullable\"\n  String comment_id FK \"nullable\"\n  Int value\n  DateTime created_at\n}\n```"
      }
    },
    "step": 0
  },
  {
    "type": "interface",
    "id": "2c45f041-9cd7-4220-92b6-d1272a9a455d",
    "document": {
      "operations": [
        {
          "specification": "Retrieve a paginated, searchable, and sortable list of all registered users from the 'users' table. Should support filtering by role, status, registration date, email, or username. This operation implements user management and browsing by moderators and administrators, referencing the users Prisma model. Results must be appropriately paginated to maximize performance and usability. Eager loading of basic user role information is recommended. Security policies must restrict access to authorized administrative or moderator roles.",
          "description": "This operation enables privileged users (moderators, administrators) to retrieve a paginated list of all users registered on the discussion board. The returned user data includes public profile information (username, email, bio), their user role, account status, and registration metadata. Filtering and searching capabilities provide powerful moderation and community management tools, allowing admins to quickly investigate misuse, track new registrations, or query dormant/suspended accounts. Pagination parameters prevent excessive database load. The endpoint ensures security by requiring bearer authentication and restricting access to users with sufficient privileges (moderator or administrator). This operation references the users Prisma schema model, specifically all columns described (id, user_role_id, username, email, bio, status, created_at, updated_at). The response should not include password hashes. Validation includes correct filter types, secure pagination defaults, and correct authorization checks. This operation may be combined with single-user lookup or management operations for a full user administration workflow.",
          "summary": "List users with search, filtering, and pagination (users table).",
          "parameters": [],
          "requestBody": {
            "description": "Request parameters for user list/search, including filters, pagination, and sort details.",
            "typeName": "IBbsUsers.IRequest"
          },
          "responseBody": {
            "description": "Paginated list of users matching search and filter criteria.",
            "typeName": "IPageIBbsUsers"
          },
          "authorization": {
            "role": [
              "user_roles"
            ],
            "type": "Bearer"
          },
          "path": "/bbs/users",
          "method": "patch"
        },
        {
          "specification": "Retrieve a single user's public profile and administrative information from the 'users' Prisma table. Uses the user ID as a lookup parameter, which must be a UUID. Supports full audit trail access as required by moderation and administrative business rules. All returned data must mask sensitive/private fields (e.g., password hash must never be returned).",
          "description": "This endpoint retrieves the full account and public profile information for a specific user, as identified by their UUID. It is used for account management, profile viewing, and moderation. The returned details include username, bio, email, role (with full description), account status, and timestamps (created_at, updated_at). Account credentials (such as the password_hash) are never returned for security reasons. The endpoint may be used by administrators or moderators during audits, dispute resolution, or assisting users. Follows the users Prisma schema for all properties and relationships. Handles missing/deleted users gracefully with informative error responses. Security validation restricts access to authorized roles only, typically moderator or administrator.",
          "summary": "Retrieve a user's profile/account by user ID (users table).",
          "parameters": [
            {
              "name": "id",
              "description": "Target user's UUID",
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            }
          ],
          "requestBody": null,
          "responseBody": {
            "description": "User profile and account metadata, excluding sensitive credential data.",
            "typeName": "IBbsUsers"
          },
          "authorization": {
            "role": [
              "user_roles"
            ],
            "type": "Bearer"
          },
          "path": "/bbs/users/{id}",
          "method": "get"
        },
        {
          "specification": "Register a new user account in the 'users' table. Requires role assignment, unique username, and unique email. Password must be provided (hashed on storage) and is never returned by API. Strict validation applies to all fields, enforcing business rules found in the users and user_roles Prisma models. Audit fields are written automatically by backend. Security validation ensures only self-registration or privileged roles can create users.",
          "description": "This operation allows either new users to self-register (signup) or administrative users to create new user accounts. Inputs include: username, email, password (plain, which will be hashed), role, and optional biography. Usernames and emails must be unique system-wide as enforced by the DB. Role assignment references the user_roles table (role name or ID). On successful creation, returns full non-sensitive account data (never returns password hash or plain password). Validation includes strong password policies, correctly-formed emails, unique username check, assignment of allowed roles, and correct audit metadata. Security policies ensure only authorized clients can create moderator/administrator accounts. Relationship: users references user_roles via user_role_id (UUID). The operation complements authentication endpoints and supports user onboarding workflows. Error handling includes duplicate entries, invalid roles, and input format errors.",
          "summary": "Register a new user account (users table).",
          "parameters": [],
          "requestBody": {
            "description": "User account registration information, including username, email, password, role, and optional bio.",
            "typeName": "IBbsUsers.ICreate"
          },
          "responseBody": {
            "description": "Newly created user profile (excluding credential data).",
            "typeName": "IBbsUsers"
          },
          "authorization": {
            "role": [
              "user_roles"
            ],
            "type": "Bearer"
          },
          "path": "/bbs/users",
          "method": "post"
        },
        {
          "specification": "Update an existing user's profile or administrative properties in the 'users' table. The target user is identified by UUID. Supports changes to username, email, bio, status, and user_role assignment; password updates are managed separately. Full validation on all fields: usernames/emails must remain unique, role assignment references user_roles, and only authorized administrative or self-updating contexts are permitted. Audit trail updated on successful modification.",
          "description": "This endpoint lets administrators or the users themselves update user profile information (username, email, bio), administrative account status (active, suspended, banned, etc.), or reassign user role (referencing user_roles table). Changing credentials (password) is handled by a separate workflow, but email and username uniqueness is always enforced. Security rules ensure only allowed users (self, moderator, admin) can update the target account. All changes are subject to full validation against the business rules in the requirements document and Prisma schema. Audit fields (updated_at) are set by the backend. The endpoint can be used in workflows for profile updates, role upgrades, or moderation actions. Errors include duplicate username/email or unpermitted actions.",
          "summary": "Update an existing user profile or account (users table).",
          "parameters": [
            {
              "name": "id",
              "description": "Target user's UUID",
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            }
          ],
          "requestBody": {
            "description": "Profile/account update payload (username, bio, email, role, status, but not password).",
            "typeName": "IBbsUsers.IUpdate"
          },
          "responseBody": {
            "description": "Updated user profile/account, excluding secret fields.",
            "typeName": "IBbsUsers"
          },
          "authorization": {
            "role": [
              "user_roles"
            ],
            "type": "Bearer"
          },
          "path": "/bbs/users/{id}",
          "method": "put"
        },
        {
          "specification": "Soft-delete (deactivate) a user by setting account status to an appropriate value (e.g., 'deleted', 'banned', etc.) in the 'users' table. The user is specified by UUID. This implements moderation, account management, or self-service deletion as per business rules. Real deletion from database is not supported; only status or flagging is allowed for traceability and audit.",
          "description": "This operation allows administrators or moderators to deactivate or remove a user account without physically deleting the record from the database, preserving audit trails and possible restoration. Actual implementation sets the status field of the user record (users table) to a value like 'deleted', 'banned', or 'suspended'. Only privileged users (administrators, moderators) may execute this unless it's for self-removal. Associated content (posts/comments) are retained. This operation references account removal business logic from requirements and Prisma schema business rules. All necessary validation, audit, and error handling logic are included. Deactivation is irreversible except by subsequent restoration workflow.",
          "summary": "Soft-delete (deactivate) a user by status update (users table).",
          "parameters": [
            {
              "name": "id",
              "description": "Target user's UUID",
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            }
          ],
          "requestBody": null,
          "responseBody": {
            "description": "Deleted/deactivated user profile for audit/reference.",
            "typeName": "IBbsUsers"
          },
          "authorization": {
            "role": [
              "user_roles"
            ],
            "type": "Bearer"
          },
          "path": "/bbs/users/{id}",
          "method": "delete"
        },
        {
          "specification": "Query the list of all user roles defined in 'user_roles'. Supports optional filtering/searching and pagination. Implements the management view, onboarding/registration role selection dialog, and administrative role auditing. Results include all role metadata fields from the Prisma schema. Only authorized users may access this endpoint for audit or registration workflow management.",
          "description": "List the roles available for assignment to users, as per the user_roles business table (roles like member, moderator, administrator). Supports pagination, filtering, and search on role names or descriptions, assisting administrators and registration workflows in finding or displaying available roles. Related to users table by user_role_id. The endpoint returns role information but does not expose any linked user personal data. Supports role management, onboarding, and auditing. Authorization is required, typically for system administration staff. Used alongside user creation and update APIs to ensure valid references.",
          "summary": "List user roles with search and pagination (user_roles table).",
          "parameters": [],
          "requestBody": {
            "description": "Request parameters for user role list/search, supporting filtering and pagination.",
            "typeName": "IBbsUserRoles.IRequest"
          },
          "responseBody": {
            "description": "Paginated list of user roles matching the query.",
            "typeName": "IPageIBbsUserRoles"
          },
          "authorization": {
            "role": [
              "user_roles"
            ],
            "type": "Bearer"
          },
          "path": "/bbs/userRoles",
          "method": "patch"
        },
        {
          "specification": "Retrieve a single user role record (by UUID) from the 'user_roles' table. Used for administrative inspection, onboarding flows (role selection), and validation. Input is role ID (UUID). Operation returns all role metadata. No user personal information is accessible via this endpoint.",
          "description": "Get metadata about a specific user role, identified by its UUID. Returns the unique name and full description of role authority, as defined in the user_roles Prisma table and associated requirements. Used for audit checks, onboarding selection, or administrative validation (e.g., displaying what a moderator can do). Access is required for system administrators or similar privileged roles. Handles missing/invalid IDs gracefully. The endpoint does not expose user information, only the role metadata.",
          "summary": "Retrieve a user role by ID (user_roles table).",
          "parameters": [
            {
              "name": "id",
              "description": "Target role's UUID",
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            }
          ],
          "requestBody": null,
          "responseBody": {
            "description": "Role label and description from user_roles table.",
            "typeName": "IBbsUserRoles"
          },
          "authorization": {
            "role": [
              "user_roles"
            ],
            "type": "Bearer"
          },
          "path": "/bbs/userRoles/{id}",
          "method": "get"
        },
        {
          "specification": "Create a new user role record in 'user_roles'. Requires unique role name and a descriptive string. Implements custom roles or onboarding flows. Only administrators or system staff may create new roles. References user_roles table and registration requirements. Enforces uniqueness on name and full validation on all fields.",
          "description": "This operation allows system administrators to define and create new user roles, expanding the range of permissions and governance on the discussion board. Input includes the unique role name (e.g., 'community_manager'), and a text description outlining permissions and duties. Validation enforces uniqueness of the role name, and the description is required for audit and clarity. May be used in onboarding or registration flows to offer new kinds of user experiences (e.g., temporary roles). All relationships and constraints are as defined in user_roles Prisma model. Error handling covers duplicates and format errors. Audit metadata is tracked by the backend.",
          "summary": "Create a new user role (user_roles table).",
          "parameters": [],
          "requestBody": {
            "description": "Role creation payload (unique name, descriptive text).",
            "typeName": "IBbsUserRoles.ICreate"
          },
          "responseBody": {
            "description": "Details for the newly created user role.",
            "typeName": "IBbsUserRoles"
          },
          "authorization": {
            "role": [
              "user_roles"
            ],
            "type": "Bearer"
          },
          "path": "/bbs/userRoles",
          "method": "post"
        },
        {
          "specification": "Update an existing user role record in 'user_roles'. The role is specified by UUID. Enables renaming or changing the description, for administrative governance or onboarding logic. Role name uniqueness enforced. Only privileged users (administrators) may update roles. References user_roles field definitions and relationships.",
          "description": "This operation edits the label and description of an existing user role, updating governance or onboarding configuration. Only permitted users (administrators) can invoke it. Input: role ID (UUID), new name, and/or new description. Enforces unique name and proper validation. Responses include the updated role descriptor. Used along with other role management APIs for dynamic permissions adjustments. Covers all role metadata per user_roles Prisma schema. Handles invalid input, duplicate names, or permissions errors. Returns updated user role metadata for confirmation.",
          "summary": "Update existing user role by role ID (user_roles table).",
          "parameters": [
            {
              "name": "id",
              "description": "Target role's UUID",
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            }
          ],
          "requestBody": {
            "description": "User role update payload (new name, description).",
            "typeName": "IBbsUserRoles.IUpdate"
          },
          "responseBody": {
            "description": "Updated user role metadata.",
            "typeName": "IBbsUserRoles"
          },
          "authorization": {
            "role": [
              "user_roles"
            ],
            "type": "Bearer"
          },
          "path": "/bbs/userRoles/{id}",
          "method": "put"
        },
        {
          "specification": "Delete/deactivate a user role by setting an appropriate state or flag in 'user_roles'. Input is the role UUID. Only authorized staff can invoke this - typically administrators. Real deletion is not supported; status flag or similar audit mechanism should be used. This enables safe governance flow and role record preservation for auditing. The endpoint references user_roles schema and soft-delete business logic.",
          "description": "Allows system administrators to deactivate a role in the user_roles table. In practice, this might mean preventing new users from being assigned this role, but the role metadata remains for audit and traceability. The endpoint does not physically remove the record. Input is the role's UUID. Can be combined with user management endpoints for full administrative functionality. Authorization and permissions are strictly enforced. Responses document the now-inactive/deleted state. Error handling includes referencing non-existent or protected roles. Audit/meta info is retained.",
          "summary": "Deactivate (soft-delete) user role by ID (user_roles table).",
          "parameters": [
            {
              "name": "id",
              "description": "Target role's UUID",
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            }
          ],
          "requestBody": null,
          "responseBody": {
            "description": "Deactivated user role metadata for audit/reference.",
            "typeName": "IBbsUserRoles"
          },
          "authorization": {
            "role": [
              "user_roles"
            ],
            "type": "Bearer"
          },
          "path": "/bbs/userRoles/{id}",
          "method": "delete"
        },
        {
          "specification": "Retrieve the list of all post categories, supporting optional search or filtering, with pagination. The operation uses the 'categories' table from the Prisma schema. Used in post submission, content exploration, or administrative monitoring workflows. Should only return category metadata (not post data) and be accessible to all users (including public/unauthenticated users for onboarding).",
          "description": "This endpoint allows clients to list the discussion categories (topic areas, such as 'Politics', 'Economics') under which posts are organized. Supports optional filtering/search, useful for navigation, onboarding, and content creation flows. Uses pagination for performance. Does not disclose posts, only the category metadata (id, name, description, created_at) from the categories Prisma schema. No relationships to users are returned. Accessible to all users, including visitors without authentication by default, but may also support administrative filtering enhancements. Commonly used to build navigation bars or prompt users to choose a category when creating content. Handles invalid filters and pagination gracefully.",
          "summary": "List post categories with search and pagination (categories table).",
          "parameters": [],
          "requestBody": {
            "description": "Category query/search/pagination options.",
            "typeName": "IBbsCategories.IRequest"
          },
          "responseBody": {
            "description": "Paginated list of discussion categories.",
            "typeName": "IPageIBbsCategories"
          },
          "authorization": {
            "role": [
              "user_roles"
            ],
            "type": "Bearer"
          },
          "path": "/bbs/categories",
          "method": "patch"
        },
        {
          "specification": "Get all metadata for a single discussion category by its UUID, from the 'categories' table. Used to show full details in creation, administration, or browsing flows. Returns only category attributes, not posts themselves. Handles audit fields. Input is the category ID (UUID). No authentication required for basic usage.",
          "description": "This endpoint fetches the name, description, and creation date for a specific discussion category. The input is the category's UUID. Used by clients or admins to display detailed category information (such as when viewing the category page or offering category selection in post creation). Does not return post data itself, only the category metadata as defined in the categories Prisma schema. Handles invalid/missing category gracefully. No relationships are exposed, only direct metadata. Authorization is open by default but may enforce further checks for admin/management views. Used in category navigation, post composition, or audit reporting. Audit trail (created_at) is returned for management.",
          "summary": "Get a single category's details by ID (categories table).",
          "parameters": [
            {
              "name": "id",
              "description": "Target category's UUID",
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            }
          ],
          "requestBody": null,
          "responseBody": {
            "description": "Category metadata (name, description, created date etc).",
            "typeName": "IBbsCategories"
          },
          "authorization": {
            "role": [
              "user_roles"
            ],
            "type": "Bearer"
          },
          "path": "/bbs/categories/{id}",
          "method": "get"
        },
        {
          "specification": "Creates a new category in the BBS (Bulletin Board System) discussion platform. This operation allows administrators to add a new category, enabling organization and classification of posts according to topic, such as 'Politics', 'Economics', or 'International Affairs'. The underlying Prisma DB table is 'categories', which tracks category names, descriptions, and creation timestamps. New categories must have unique names and a clear description for effective navigation and moderation.",
          "description": "This API allows an administrator to create a new discussion category in the BBS platform. By supplying necessary information such as category name and description, the system adds a new record to the 'categories' table. Administrators should ensure names are unique to avoid conflicts with existing categories.\n\nAccess to this API is restricted to authenticated administrators, as only they may modify the set of available discussion categories. Upon successful creation, a new category entry is visible and available for post assignment by all users, supporting better board organization.\n\nIf the submitted category name already exists, the API will return an error indicating the name must be unique. Validation rules also require non-empty strings for both name and description fields.\n\nRelated operations include listing categories, updating (PUT), and deleting (DELETE) existing categories. This endpoint is essential for maintaining the topical structure of the BBS, making it easier for users to navigate and participate in relevant discussions.",
          "summary": "Create a new category (BBS: categories table).",
          "parameters": [],
          "requestBody": {
            "description": "Information about the new category to create, including name and description.",
            "typeName": "bbsCategories.ICreate"
          },
          "responseBody": {
            "description": "Data of the newly created category.",
            "typeName": "bbsCategories"
          },
          "authorization": {
            "role": [
              "user_roles"
            ],
            "type": "Bearer"
          },
          "path": "/bbs/categories",
          "method": "post"
        },
        {
          "specification": "Updates the information of an existing discussion category in the BBS platform. This operation applies changes to a specific entry in the 'categories' Prisma table, such as renaming or updating the description of a category. It is used by administrators to manage and reorganize discussion topics efficiently.",
          "description": "This API allows authenticated administrators to update the name or description of a discussion category identified by its unique 'id'. The update operation references the 'categories' table and enforces uniqueness for category names and requires non-empty values. Only administrators may perform this action, and each request must specify the category's identifier in the path. \n\nAttempts to change the category name to one already in use will result in a validation error. The update operation also prevents accidental erasure of required information by ensuring both the name and description remain populated after editing. Related endpoints include category creation (POST), deletion (DELETE), and listing/searching operations for categories.\n\nOn success, the endpoint returns the updated category information, reflecting all changes for immediate use in the system.",
          "summary": "Update a category's details (BBS: categories table).",
          "parameters": [
            {
              "name": "id",
              "description": "The identifier of the category to update.",
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            }
          ],
          "requestBody": {
            "description": "Updated information for the specified category.",
            "typeName": "bbsCategories.IUpdate"
          },
          "responseBody": {
            "description": "The updated category data.",
            "typeName": "bbsCategories"
          },
          "authorization": {
            "role": [
              "user_roles"
            ],
            "type": "Bearer"
          },
          "path": "/bbs/categories/{id}",
          "method": "put"
        },
        {
          "specification": "Removes an existing category from the BBS discussion platform. This operation deletes a record in the 'categories' Prisma table using a unique category identifier. The endpoint ensures no posts are left orphaned by handling dependencies per business rules before deletion. Only administrators can access this endpoint.",
          "description": "This API endpoint allows an authenticated administrator to delete a discussion category by its ID from the BBS system. It removes the specified record from the 'categories' table. Prior to deletion, the system checks for posts referencing this category; administrators may need to reassign or handle these posts to maintain board integrity.\n\nOnly users with appropriate administrator roles (as defined in the 'user_roles' table) are permitted to invoke this operation. Attempts to delete a category with dependent posts may result in an error until those dependencies are resolved. On successful completion, the category is permanently removed from the database; deleted category names can be reused when creating new categories.\n\nRelated endpoints include creating, updating, and listing categories.",
          "summary": "Delete a category by ID (BBS: categories table).",
          "parameters": [
            {
              "name": "id",
              "description": "The identifier of the category to delete.",
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            }
          ],
          "requestBody": null,
          "responseBody": {
            "description": "Confirmation of deletion or details about the deleted category.",
            "typeName": "bbsCategories"
          },
          "authorization": {
            "role": [
              "user_roles"
            ],
            "type": "Bearer"
          },
          "path": "/bbs/categories/{id}",
          "method": "delete"
        },
        {
          "specification": "Retrieves a list of posts from the BBS platform with optional filters, search terms, pagination, and sorting. This operation targets the 'posts' Prisma table to provide members and visitors a way to explore ongoing discussions, analyze content, and locate relevant threads efficiently. The response may include summary data for each post and basic pagination information.",
          "description": "This API allows users to list and search through discussion posts on the BBS platform by querying the 'posts' table. The endpoint supports pagination, keyword search, category-based filtering, sorting by date or popularity, and other advanced query options as per best practice standards.\n\nBoth registered members and visitors can use this endpoint (though access to full content or additional metadata may be limited for visitors). Results typically return basic post details—such as title, author summary, vote tallies, timestamps—and allow users to quickly find, browse, and analyze current discussions.\n\nIf the query contains unsupported or invalid parameters, the system returns an appropriate error. This endpoint is commonly used alongside post creation (POST), update (PUT), detail view (GET), and deletion (DELETE) operations.",
          "summary": "Search and list posts with filtering and pagination (BBS: posts table).",
          "parameters": [],
          "requestBody": {
            "description": "Search, filter, and pagination options for retrieving posts.",
            "typeName": "bbsPosts.IRequest"
          },
          "responseBody": {
            "description": "A paginated list of post summaries or details.",
            "typeName": "IPageBbsPosts"
          },
          "authorization": {
            "role": [
              "users"
            ],
            "type": "Bearer"
          },
          "path": "/bbs/posts",
          "method": "patch"
        },
        {
          "specification": "Retrieves detailed information for a specific post on the BBS platform by unique identifier. This operation targets the 'posts' Prisma table, allowing users to view the full details of a discussion thread, including metadata such as author, category, content, and creation time. It supports navigation from summary lists to individual posts.",
          "description": "This API endpoint allows a user to fetch complete details about a single post, identified by its UUID. It is tied to the 'posts' table and is available to visitors and registered members. Returned data includes the post title, content, author summary, associated category, creation and update times, and vote tallies. \n\nThis operation is essential for navigating from post lists to detailed thread views, supporting actions such as voting or commenting (when logged in). If the requested post does not exist, the API returns an appropriate not-found error. Related endpoints include post listing (PATCH /bbs/posts), post creation (POST), updating (PUT), and deletion (DELETE).",
          "summary": "Get detailed info for a specific post (BBS: posts table).",
          "parameters": [
            {
              "name": "id",
              "description": "The unique identifier of the post to retrieve.",
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            }
          ],
          "requestBody": null,
          "responseBody": {
            "description": "Full details for the specified post.",
            "typeName": "bbsPosts"
          },
          "authorization": {
            "role": [
              "users"
            ],
            "type": "Bearer"
          },
          "path": "/bbs/posts/{id}",
          "method": "get"
        },
        {
          "specification": "Creates a new discussion post in the BBS platform. This operation inserts a new record into the 'posts' Prisma table, enabling a user to start a thread on a relevant topic or question. Creating a post requires a category assignment and sufficient content to meet system validation rules.",
          "description": "This API endpoint enables registered users to start a new discussion by submitting a post to the BBS platform. The client must provide all required information: title, body content, associated category, and, implicitly, the user's identity (via authentication). \n\nThe system records each new post in the 'posts' table and links it to the author's user record and the assigned category. Constraints ensure titles and content are non-empty, with a valid category reference. \n\nUpon success, the new post (with its ID and relevant metadata) is immediately available for searching, viewing, and commenting. The operation enforces organization and content standards, returning validation errors if requirements are unmet. \n\nPost-creation, users may view, edit, or delete their posts, while moderators can perform additional actions as per role. This endpoint is closely related to GET, PUT, and DELETE operations on posts.",
          "summary": "Create a new post (BBS: posts table).",
          "parameters": [],
          "requestBody": {
            "description": "Information for the new post, including title, content, and category ID.",
            "typeName": "bbsPosts.ICreate"
          },
          "responseBody": {
            "description": "Data for the newly created post, including all metadata.",
            "typeName": "bbsPosts"
          },
          "authorization": {
            "role": [
              "users"
            ],
            "type": "Bearer"
          },
          "path": "/bbs/posts",
          "method": "post"
        },
        {
          "specification": "Updates the information of an existing post in the BBS platform. This operation applies changes to a specific post in the 'posts' Prisma table, such as editing the title or content. The endpoint ensures only the author or users with elevated privileges (moderators/administrators) may update posts, adhering to business rules for auditability and content preservation.",
          "description": "This API allows the original author (or, in special cases, a moderator/administrator) to update an existing post identified by its UUID. The client supplies updated values for title, content, or other modifiable fields. The 'posts' table enforces that only the recorded author or privileged account can submit updates to a given post record.\n\nThe system maintains a history of 'updated_at' timestamps and can restrict updates to within certain time windows, as described by business requirements. Attempting to update with invalid data (missing or duplicate title, empty content, invalid references) produces an error. Related endpoints include post creation (POST), detailed retrieval (GET), and deletion (DELETE).\n\nThe API returns the updated post data upon success, immediately reflecting any changes in subsequent queries.",
          "summary": "Update a post's details (BBS: posts table).",
          "parameters": [
            {
              "name": "id",
              "description": "The unique post identifier to update.",
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            }
          ],
          "requestBody": {
            "description": "Updated values for the target post (title, content, category, etc.).",
            "typeName": "bbsPosts.IUpdate"
          },
          "responseBody": {
            "description": "The modified post record after update.",
            "typeName": "bbsPosts"
          },
          "authorization": {
            "role": [
              "users"
            ],
            "type": "Bearer"
          },
          "path": "/bbs/posts/{id}",
          "method": "put"
        },
        {
          "specification": "Deletes a discussion post from the BBS platform by its unique identifier. This operation removes or marks as deleted a record in the 'posts' Prisma table. The endpoint enforces business logic by allowing only the author or privileged roles (moderator/administrator) to perform deletion, supporting content integrity, audit trails, and platform moderation needs.",
          "description": "This API allows a post author or an authorized moderator/administrator to remove a post from the BBS platform. The system marks the post as deleted (soft delete) or permanently deletes the record from the 'posts' table per business and moderation rules. \n\nAccess controls ensure only the post's author or properly credentialed staff may invoke this endpoint. The system prevents posts with active dependency violations (such as non-removable comments) from being deleted outright and may require additional steps.\n\nUpon success, the response confirms deletion status, and the post is hidden from general listing and searches. Related API endpoints: post creation (POST), detail view (GET), update (PUT), and comment management for associated replies.",
          "summary": "Delete a post by ID (BBS: posts table).",
          "parameters": [
            {
              "name": "id",
              "description": "The unique post identifier to delete.",
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            }
          ],
          "requestBody": null,
          "responseBody": {
            "description": "Confirmation or record of post deletion.",
            "typeName": "bbsPosts"
          },
          "authorization": {
            "role": [
              "users"
            ],
            "type": "Bearer"
          },
          "path": "/bbs/posts/{id}",
          "method": "delete"
        },
        {
          "specification": "Searches or lists comments attached to a specific post in the BBS platform, with support for filtering, pagination, and sorting. This operation targets the 'comments' Prisma table, enabling users and visitors to explore threads and reply-chains belonging to a post.",
          "description": "This API allows users to retrieve a list of comments for a specific post, identified by 'postId'. Supports query options for filtering by author, time range, reply depth, and more—including pagination and sort order. The underlying 'comments' table returns summaries or basics details of each comment thread or reply chain, supporting threaded conversation navigation.\n\nBoth authenticated users and visitors can access this operation, but may see different levels of detail according to permissions. The endpoint is closely linked with comment creation (POST), update (PUT), and deletion (DELETE) for participation and moderation flows. Only comments belonging to the target postId are returned, supporting thread-based exploration and analysis.",
          "summary": "List or search comments for a specified post (BBS: comments table).",
          "parameters": [
            {
              "name": "postId",
              "description": "The unique identifier of the post whose comments are being queried.",
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            }
          ],
          "requestBody": {
            "description": "Options for filtering, pagination, etc., when listing comments.",
            "typeName": "bbsComments.IRequest"
          },
          "responseBody": {
            "description": "A paginated or filtered list of relevant comments.",
            "typeName": "IPageBbsComments"
          },
          "authorization": {
            "role": [
              "users"
            ],
            "type": "Bearer"
          },
          "path": "/bbs/posts/{postId}/comments",
          "method": "patch"
        },
        {
          "specification": "Retrieves the full details of a single comment attached to a post in the BBS platform, by both the parent post's identifier (postId) and the comment's ID. This queries the 'comments' Prisma table, supporting thread views and reply navigation for deeply nested conversation chains.",
          "description": "This API allows users to fetch all available information for one specific comment within the context of a post. The identifiers ('postId' for the parent thread, 'id' for the comment itself) ensure accuracy in comment threading and navigation. The operation returns comment content, author and timestamp details, metadata, and relations (such as parent reply or nested replies).\n\nThe endpoint supports use cases like displaying a reply in context, enabling further replies, or feeding comment moderation workflows. If a comment is not found or the identifiers do not match, the API returns a not-found error. Related endpoints include comment listing (PATCH), creation (POST), updating (PUT), and deletion (DELETE).",
          "summary": "Get details for a specific comment (BBS: comments table).",
          "parameters": [
            {
              "name": "postId",
              "description": "The unique post to which the comment belongs.",
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            },
            {
              "name": "id",
              "description": "The specific comment identifier to retrieve.",
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            }
          ],
          "requestBody": null,
          "responseBody": {
            "description": "Full comment details and metadata.",
            "typeName": "bbsComments"
          },
          "authorization": {
            "role": [
              "users"
            ],
            "type": "Bearer"
          },
          "path": "/bbs/posts/{postId}/comments/{id}",
          "method": "get"
        },
        {
          "specification": "Creates a new comment in response to a specific post in the BBS platform. This operation inserts a comment record in the 'comments' Prisma table, enabling users to participate in ongoing discussions, reply to threads, and contribute nested or direct responses. Parent-child threading is supported for reply chains.",
          "description": "This API endpoint lets users (or, in special cases, moderators/administrators) add a new comment to a discussion post. The caller specifies the parent 'postId' and supplies the comment content. Optional threading is permitted by providing a parent comment ID for nested replies—enabling conversations to branch.\n\nThe 'comments' table links the new comment with both the author (via authentication) and the parent post (and optionally a parent comment), satisfying data integrity rules and supporting navigation through reply trees. Only authenticated users are allowed to create comments. The system enforces validation that content is non-empty and—if threading—a valid parent comment ID is supplied.\n\nUpon success, the new comment becomes searchable, viewable, and ready for follow-up replies or moderation actions. Related endpoints: list/search comments, update, delete.",
          "summary": "Create a new comment for a specific post (BBS: comments table).",
          "parameters": [
            {
              "name": "postId",
              "description": "Identifier of the post to which the comment will be added.",
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            }
          ],
          "requestBody": {
            "description": "Information for the new comment (content, parent comment if threading, etc.).",
            "typeName": "bbsComments.ICreate"
          },
          "responseBody": {
            "description": "Data of the newly created comment, including identifiers and metadata.",
            "typeName": "bbsComments"
          },
          "authorization": {
            "role": [
              "users"
            ],
            "type": "Bearer"
          },
          "path": "/bbs/posts/{postId}/comments",
          "method": "post"
        },
        {
          "specification": "Updates the information of a specific comment on a post in the BBS platform. This operation modifies a 'comments' record in the Prisma table by unique post ('postId') and comment ('id') identifiers, enforcing rules that only the author or privileged users may update comment contents.",
          "description": "This API lets an authenticated user (comment author or, under special permissions, a moderator/administrator) update an existing comment identified by both parent postId and comment id. The system enforces that updates may only be made to comments the user owns, or by authorized moderation roles, with all validation constraints on content and threading.\n\nRequest must specify the target post and comment, supplying new content and/or thread associations. Invalid references or blank content produces errors, with history tracking updated timestamps. On success, the new comment details are returned.\n\nBusiness rules ensure audit trails and uphold moderation policies. Related endpoints include comment creation, deletion, and listing under post/group context.",
          "summary": "Update an existing comment for a post (BBS: comments table).",
          "parameters": [
            {
              "name": "postId",
              "description": "The post to which the comment belongs.",
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            },
            {
              "name": "id",
              "description": "The unique identifier of the comment to update.",
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            }
          ],
          "requestBody": {
            "description": "Updated values for the comment (e.g., new content, parentId for re-threading).",
            "typeName": "bbsComments.IUpdate"
          },
          "responseBody": {
            "description": "The updated comment record, reflecting all changes.",
            "typeName": "bbsComments"
          },
          "authorization": {
            "role": [
              "users"
            ],
            "type": "Bearer"
          },
          "path": "/bbs/posts/{postId}/comments/{id}",
          "method": "put"
        },
        {
          "specification": "Implements the delete operation for a nested comment resource under a specific post. This endpoint enables an authorized user (such as the comment's author or a moderator) to delete a specific comment belonging to a post. The operation checks that the comment is indeed a direct child of the specified post. The underlying table is 'comments', and enforcement of proper soft-delete logic and audit trail is referenced from schema comments. Authorization must ensure that only legitimate actors can perform this action. Error handling is required if either the post or comment does not exist or the relationship is invalid.",
          "description": "This operation deletes a comment associated with a particular post in the political/economic discussion board application. According to the Prisma schema for the 'comments' table, deleting a comment does not remove the record from the database, but marks it as deleted by updating the 'deleted_at' timestamp. This is in line with moderation and audit requirements described in both the requirement analysis and schema documentation.\n\nAuthorization is necessary, and only the comment's author, a moderator, or an administrator may perform this action. Permissions are determined by checking the user's role, which is represented in the 'users' and 'user_roles' tables. The endpoint ensures that the specified comment exists, is associated with the given post, and is not already deleted. Attempting to delete a non-existent or unrelated comment results in an error response showing the appropriate message.\n\nAdditionally, the operation maintains an audit trail by recording the timestamp of deletion, as outlined in the comments schema. The deleted comment remains for future moderation or review, and cannot be interacted with by regular members after deletion. Error responses must comply with API design for invalid IDs, unauthorized access, and logical violations (such as trying to delete an already deleted comment).",
          "summary": "Delete a specific comment under a post (comments table, soft-delete logic).",
          "parameters": [
            {
              "name": "postId",
              "description": "Target post's ID (the parent of the comment).",
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            },
            {
              "name": "id",
              "description": "Target comment's ID to be deleted.",
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            }
          ],
          "requestBody": null,
          "responseBody": null,
          "authorization": {
            "role": [
              "users",
              "user_roles"
            ],
            "type": "Bearer"
          },
          "path": "/bbs/posts/{postId}/comments/{id}",
          "method": "delete"
        },
        {
          "specification": "Fetches a list of nested comment replies to a specific comment (threaded/nested reply support) using the 'comments' table. This is a patch operation with advanced searching or filtering capabilities (e.g., pagination, query, sort order). Only direct replies to the specified parent comment are retrieved. This is compliant with the threaded/nested structure described in requirement analysis and Prisma comments model.",
          "description": "This operation retrieves a paginated and optionally filtered list of replies to a specific parent comment. The 'comments' table supports self-referential relationships for nested replies via the 'parent_id' field. Each retrieved comment must have 'parent_id' matching the provided 'commentId'.\n\nStandard search, filtering, and pagination options are supported via the request body. Only direct (not deeply nested) children are included. The operation checks if the parent comment exists and is not deleted. If access to the replies is restricted (e.g., if the parent comment is deleted or private), the API must enforce rules accordingly.\n\nThis operation is commonly used in threaded conversation UIs and supports constructing the hierarchy of replies for discussion depth and transparency.",
          "summary": "List all direct replies to a specific comment (comments table, threaded replies).",
          "parameters": [
            {
              "name": "commentId",
              "description": "Target parent comment's ID whose direct children are queried.",
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            }
          ],
          "requestBody": {
            "description": "Search and pagination options for replies to the comment.",
            "typeName": "IBbsCommentReply.IRequest"
          },
          "responseBody": {
            "description": "Paginated list of replies to the specified comment.",
            "typeName": "IPageIBbsCommentReply"
          },
          "authorization": {
            "role": [
              "users"
            ],
            "type": "Bearer"
          },
          "path": "/bbs/comments/{commentId}/comments",
          "method": "patch"
        },
        {
          "specification": "Retrieves details of a specific reply to a comment, identified by both the parent comment and the reply ID. This ensures the context is that of a direct reply within a thread. The resource is the 'comments' table, filtered by both IDs. Used to fetch reply details (such as content, author, timestamps, votes) for viewing or further editing.",
          "description": "This operation fetches the details of a specific reply to a given parent comment, leveraging the 'comments' table's self-referential structure. It checks that the reply exists, has its 'parent_id' set to the specified 'commentId', and is not marked as deleted (soft delete logic).\n\nUseful for showing reply detail pages or in-line replies in the UI. Access control ensures that deleted replies or those hidden for moderation are not shown to ordinary users. The response includes all major comment fields (content, author, created time, votes, etc.), as well as any relevant metadata for thread navigation and moderation.",
          "summary": "Get information for a specific reply to a comment (comments table, threaded comment).",
          "parameters": [
            {
              "name": "commentId",
              "description": "Parent comment's ID (pid for threaded reply context).",
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            },
            {
              "name": "id",
              "description": "Reply comment's ID to retrieve.",
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            }
          ],
          "requestBody": null,
          "responseBody": {
            "description": "Reply comment detail information.",
            "typeName": "IBbsCommentReply"
          },
          "authorization": {
            "role": [
              "users"
            ],
            "type": "Bearer"
          },
          "path": "/bbs/comments/{commentId}/comments/{id}",
          "method": "get"
        },
        {
          "specification": "Creates a new reply to a specific parent comment (i.e., posts a nested comment under another comment). Operating on the 'comments' table, this operation supports threaded/nested replies as required in the requirements analysis and implemented in the database schema. Only registered members (users) are permitted to reply.",
          "description": "This operation allows registered users to create a new nested reply to an existing comment. The parent comment is specified by 'commentId'. Input data includes the reply content and optional metadata (e.g., authored by user, timestamp auto-handled). The association is created by setting the new comment's 'parent_id' to the specified 'commentId'.\n\nThe 'comments' table enforces this hierarchy and business rules such as only registered users may reply, and soft deletion logic applies. Error handling ensures the parent comment exists and is not deleted. Moderation or anti-spam business rules (e.g., rate limiting, sensitive word checks) are referenced from business context but not detailed in schema.",
          "summary": "Create a new reply to a specific parent comment (comments table, nested reply).",
          "parameters": [
            {
              "name": "commentId",
              "description": "Parent comment's ID for threading context.",
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            }
          ],
          "requestBody": {
            "description": "Reply creation data (e.g., content, optional metadata).",
            "typeName": "IBbsCommentReply.ICreate"
          },
          "responseBody": {
            "description": "Created reply comment, including ID and metadata.",
            "typeName": "IBbsCommentReply"
          },
          "authorization": {
            "role": [
              "users"
            ],
            "type": "Bearer"
          },
          "path": "/bbs/comments/{commentId}/comments",
          "method": "post"
        },
        {
          "specification": "Updates the contents or status of a specific reply comment under a parent comment by ID. Supports editing of replies (content or possibly metadata) as required by business rules (edited by author within allowed period, or by moderator).",
          "description": "This operation updates a reply to a given parent comment in the 'comments' table. The system ensures that the target reply exists, is a direct reply to the specified 'commentId', and is not deleted. Only allowed roles (the author, moderators, administrators) may update the reply, subject to possible time window constraints (business logic).\n\nValid edits include changing the reply's text content and, where business rules allow, updating moderation status, or fixing accidental errors. The history is retained via an updated_at timestamp. Editing is restricted if a reply has been deleted (soft delete) or if the editing time window has expired. Response provides the updated reply details.",
          "summary": "Update a reply to a specific comment (comments table, edit threaded reply).",
          "parameters": [
            {
              "name": "commentId",
              "description": "Parent comment's ID for context.",
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            },
            {
              "name": "id",
              "description": "Reply comment's ID to update.",
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            }
          ],
          "requestBody": {
            "description": "Fields to update in the reply (e.g., new content, metadata).",
            "typeName": "IBbsCommentReply.IUpdate"
          },
          "responseBody": {
            "description": "Updated reply comment information.",
            "typeName": "IBbsCommentReply"
          },
          "authorization": {
            "role": [
              "users",
              "user_roles"
            ],
            "type": "Bearer"
          },
          "path": "/bbs/comments/{commentId}/comments/{id}",
          "method": "put"
        },
        {
          "specification": "Deletes a specific reply (nested comment) under a given parent comment by ID. This operation supports moderation and user self-deletion and implements soft deletion according to the schema by updating the 'deleted_at' timestamp in the comments table. Permissions must check authorship, moderator, or admin role.",
          "description": "This operation deletes a reply (nested comment) from a parent comment, as defined in the self-referential structure of the 'comments' table. Instead of a hard delete, it sets the 'deleted_at' field, preserving the reply for moderation history and audit purposes.\n\nOnly the reply's author, moderators, or administrators are authorized to perform this action. Role mapping is enforced using data from 'users' and 'user_roles' tables. The operation checks that the reply exists and is a direct child of the specified parent comment.\n\nOn error (e.g., invalid parent-child relationship, reply already deleted, lack of permission), the system returns appropriate error codes/messages. This ensures clean handling of thread integrity and preserves conversation structure.",
          "summary": "Delete a reply to a specific comment (comments table, soft-delete moderation logic).",
          "parameters": [
            {
              "name": "commentId",
              "description": "Parent comment's ID for context.",
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            },
            {
              "name": "id",
              "description": "Reply comment's ID to delete.",
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            }
          ],
          "requestBody": null,
          "responseBody": null,
          "authorization": {
            "role": [
              "users",
              "user_roles"
            ],
            "type": "Bearer"
          },
          "path": "/bbs/comments/{commentId}/comments/{id}",
          "method": "delete"
        },
        {
          "specification": "Retrieves a list of votes for posts/comments, with search, pagination, and filtering options. This PATCH endpoint enables advanced querying of vote records in the 'votes' table. Use cases: moderation, content ranking, or user activity views. Response follows pagination standards.",
          "description": "This operation returns a paginated and/or filtered list of votes. The 'votes' table supports querying by voter, content (post or comment), vote value, and timestamp. Filtering and pagination information are specified via the request body. This operation is intended for use by administrators, moderators, or analytics tools. Business rules enforce visibility (e.g., users see only their own votes unless they have elevated permissions).\n\nStandard pagination, search, and sorting are provided. Errors for invalid parameters or unauthorized access are handled according to platform requirements.",
          "summary": "Query/search all votes across posts/comments (votes table, patch for advanced search).",
          "parameters": [],
          "requestBody": {
            "description": "Filters, pagination, and search fields for querying vote records.",
            "typeName": "IBbsVote.IRequest"
          },
          "responseBody": {
            "description": "Paginated result of vote records matching query.",
            "typeName": "IPageIBbsVote"
          },
          "authorization": {
            "role": [
              "users",
              "user_roles"
            ],
            "type": "Bearer"
          },
          "path": "/bbs/votes",
          "method": "patch"
        },
        {
          "specification": "Fetches the detail of a specific vote record by its ID, showing the voter, target (post or comment), value (+1/-1), and metadata. The resource is the 'votes' table. Authorization must ensure privacy so that only allowed users (e.g., voter, moderator, admin) may view full details.",
          "description": "This operation retrieves a single vote by its ID. Information includes which user cast the vote (user_id), what it targeted (either a post or comment), the value (+1 or -1, as per schema), and relevant timestamps. The operation consults the 'votes' table directly by primary key.\n\nBusiness logic ensures that vote records are visible only to the voter themselves or users with elevated privileges. Sensitive data handling observes privacy, as votes reflect user opinions which may need to remain confidential, per the requirements analysis. Errors are returned for invalid IDs or unauthorized access.",
          "summary": "Get a single vote record's details (votes table, role/visibility protection).",
          "parameters": [
            {
              "name": "id",
              "description": "Vote record's ID to be fetched.",
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            }
          ],
          "requestBody": null,
          "responseBody": {
            "description": "Vote detail resource record.",
            "typeName": "IBbsVote"
          },
          "authorization": {
            "role": [
              "users",
              "user_roles"
            ],
            "type": "Bearer"
          },
          "path": "/bbs/votes/{id}",
          "method": "get"
        },
        {
          "specification": "Creates a new vote for a post or comment. Operates on 'votes' table and applies business logic: a user may vote once per target (enforced by a unique constraint), and the value must be +1 or -1. Only authenticated users can vote. The system determines if the vote is on a post or comment, as per schema constraints.",
          "description": "This operation creates a new vote record for the given user on the specified target (either a post or a comment) as per the 'votes' table structure. The request body must specify which target is being voted on, and the value (either +1 or -1 per business rule).\n\nBusiness logic includes unique user/target constraint (a user cannot vote twice on the same post or comment). On success, returns the created vote resource. If the vote already exists, the system returns an appropriate error or suggests updating the vote. Only authenticated users may vote. Permissions and audit trail are enforced as per requirements analysis and database comments.",
          "summary": "Create a new vote for a post or comment (votes table, upvote/downvote logic).",
          "parameters": [],
          "requestBody": {
            "description": "Vote creation input (target type, target ID, value).",
            "typeName": "IBbsVote.ICreate"
          },
          "responseBody": {
            "description": "Created vote resource.",
            "typeName": "IBbsVote"
          },
          "authorization": {
            "role": [
              "users"
            ],
            "type": "Bearer"
          },
          "path": "/bbs/votes",
          "method": "post"
        },
        {
          "specification": "Updates the value or details of a vote. Operates on the 'votes' table, allowing visible users (the voter or an administrator/moderator) to change a prior vote, e.g., from upvote to downvote. Uniqueness constraint applies. Only specified fields may be updated, per business logic documented in the schema.",
          "description": "This operation updates an existing vote, which is identified by its unique ID. Only the owner (voter) of the vote or privileged roles (moderator/admin) may perform updates. Fields that can be changed include 'value' (e.g., switch an upvote to a downvote) and potentially metadata (e.g., audit fields). The business rules from the schema and requirements analysis govern what can be changed and by whom.\n\nChanges are reflected in the database and in derived content tallies. Errors are returned if update rules are violated (e.g., changing someone else's vote, updating a vote that doesn't exist, improper value assignment). On success, returns updated vote resource.",
          "summary": "Update an existing vote (votes table, upvote/downvote change).",
          "parameters": [
            {
              "name": "id",
              "description": "Vote record's ID to update.",
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            }
          ],
          "requestBody": {
            "description": "Updated vote fields (e.g., value).",
            "typeName": "IBbsVote.IUpdate"
          },
          "responseBody": {
            "description": "Updated vote resource.",
            "typeName": "IBbsVote"
          },
          "authorization": {
            "role": [
              "users",
              "user_roles"
            ],
            "type": "Bearer"
          },
          "path": "/bbs/votes/{id}",
          "method": "put"
        },
        {
          "specification": "Deletes or removes a vote (typically by the voter, a moderator, or admin). The record is physically removed from the 'votes' table, following business logic and unique vote constraints.",
          "description": "This operation deletes a vote record from the database. Only the vote's owner (voter) or privileged roles (moderator/admin, based on 'user_roles') can perform this operation. It removes the vote, freeing up the user to vote again on the same post or comment in the future (as controlled by unique constraints in the votes schema).\n\nError responses are returned if the request is forbidden, the vote does not exist, or the operation is not permitted for the resource. The operation complies with audit and permission rules from requirements analysis and schema.",
          "summary": "Delete a vote (votes table, enforced by unique user/target constraint).",
          "parameters": [
            {
              "name": "id",
              "description": "Vote record's ID to delete.",
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            }
          ],
          "requestBody": null,
          "responseBody": null,
          "authorization": {
            "role": [
              "users",
              "user_roles"
            ],
            "type": "Bearer"
          },
          "path": "/bbs/votes/{id}",
          "method": "delete"
        }
      ],
      "components": {
        "schemas": {
          "IBbsUsers.IRequest": {
            "type": "object",
            "properties": {
              "page": {
                "oneOf": [
                  {
                    "type": "integer",
                    "description": "Page number for paginated user listing.\n\nCorresponds to IPage.IRequest. Optional; if omitted, results default to the first page. Referenced in user administration and search flows."
                  },
                  {
                    "type": "null",
                    "description": "Page number for paginated user listing.\n\nCorresponds to IPage.IRequest. Optional; if omitted, results default to the first page. Referenced in user administration and search flows."
                  }
                ],
                "description": "Page number for paginated user listing.\n\nCorresponds to IPage.IRequest. Optional; if omitted, results default to the first page. Referenced in user administration and search flows."
              },
              "limit": {
                "oneOf": [
                  {
                    "type": "integer",
                    "description": "Limitation of records per page for user search.\n\nDefaults to 100. Allows tuning the result batch size for moderation or administrative user views."
                  },
                  {
                    "type": "null",
                    "description": "Limitation of records per page for user search.\n\nDefaults to 100. Allows tuning the result batch size for moderation or administrative user views."
                  }
                ],
                "description": "Limitation of records per page for user search.\n\nDefaults to 100. Allows tuning the result batch size for moderation or administrative user views."
              },
              "role": {
                "oneOf": [
                  {
                    "type": "string",
                    "description": "User role filter. Return only users with this role (matches user_roles.id or name).\n\nSupports moderator/admin filtering by user class (member, administrator, etc.)."
                  },
                  {
                    "type": "null",
                    "description": "User role filter. Return only users with this role (matches user_roles.id or name).\n\nSupports moderator/admin filtering by user class (member, administrator, etc.)."
                  }
                ],
                "description": "User role filter. Return only users with this role (matches user_roles.id or name).\n\nSupports moderator/admin filtering by user class (member, administrator, etc.)."
              },
              "status": {
                "oneOf": [
                  {
                    "type": "string",
                    "description": "Filter users by account status (e.g., active, suspended, banned).\n\nSupports workflow for monitoring and moderation of access levels."
                  },
                  {
                    "type": "null",
                    "description": "Filter users by account status (e.g., active, suspended, banned).\n\nSupports workflow for monitoring and moderation of access levels."
                  }
                ],
                "description": "Filter users by account status (e.g., active, suspended, banned).\n\nSupports workflow for monitoring and moderation of access levels."
              },
              "email": {
                "oneOf": [
                  {
                    "type": "string",
                    "description": "Filter by exact or partial match on user email.\n\nAssists in locating specific accounts for administrative intervention or support."
                  },
                  {
                    "type": "null",
                    "description": "Filter by exact or partial match on user email.\n\nAssists in locating specific accounts for administrative intervention or support."
                  }
                ],
                "description": "Filter by exact or partial match on user email.\n\nAssists in locating specific accounts for administrative intervention or support."
              },
              "username": {
                "oneOf": [
                  {
                    "type": "string",
                    "description": "Filter by username (complete or partial match).\n\nUsed for public moderation, searching individual participants, or audit tasks."
                  },
                  {
                    "type": "null",
                    "description": "Filter by username (complete or partial match).\n\nUsed for public moderation, searching individual participants, or audit tasks."
                  }
                ],
                "description": "Filter by username (complete or partial match).\n\nUsed for public moderation, searching individual participants, or audit tasks."
              },
              "registered_after": {
                "oneOf": [
                  {
                    "type": "string",
                    "format": "date-time",
                    "description": "Filter for users registered after the given timestamp (ISO8601 format).\n\nUsed to find recent registrations or perform time-based audits."
                  },
                  {
                    "type": "null",
                    "format": "date-time",
                    "description": "Filter for users registered after the given timestamp (ISO8601 format).\n\nUsed to find recent registrations or perform time-based audits."
                  }
                ],
                "description": "Filter for users registered after the given timestamp (ISO8601 format).\n\nUsed to find recent registrations or perform time-based audits."
              },
              "registered_before": {
                "oneOf": [
                  {
                    "type": "string",
                    "format": "date-time",
                    "description": "Filter for users registered before the given timestamp (ISO8601 format).\n\nUsed to look up users registered before a certain date."
                  },
                  {
                    "type": "null",
                    "format": "date-time",
                    "description": "Filter for users registered before the given timestamp (ISO8601 format).\n\nUsed to look up users registered before a certain date."
                  }
                ],
                "description": "Filter for users registered before the given timestamp (ISO8601 format).\n\nUsed to look up users registered before a certain date."
              },
              "sort_by": {
                "oneOf": [
                  {
                    "const": "username",
                    "description": "Sort order (username, email, created_at).\n\nFor user management screens, allows control of user list ordering."
                  },
                  {
                    "const": "email",
                    "description": "Sort order (username, email, created_at).\n\nFor user management screens, allows control of user list ordering."
                  },
                  {
                    "const": "created_at",
                    "description": "Sort order (username, email, created_at).\n\nFor user management screens, allows control of user list ordering."
                  },
                  {
                    "type": "null",
                    "enum": [
                      "username",
                      "email",
                      "created_at"
                    ],
                    "description": "Sort order (username, email, created_at).\n\nFor user management screens, allows control of user list ordering."
                  }
                ],
                "description": "Sort order (username, email, created_at).\n\nFor user management screens, allows control of user list ordering."
              },
              "sort_order": {
                "oneOf": [
                  {
                    "const": "asc",
                    "description": "Sorting direction for user list.\n\n'asc' for ascending, 'desc' for descending."
                  },
                  {
                    "const": "desc",
                    "description": "Sorting direction for user list.\n\n'asc' for ascending, 'desc' for descending."
                  },
                  {
                    "type": "null",
                    "enum": [
                      "asc",
                      "desc"
                    ],
                    "description": "Sorting direction for user list.\n\n'asc' for ascending, 'desc' for descending."
                  }
                ],
                "description": "Sorting direction for user list.\n\n'asc' for ascending, 'desc' for descending."
              }
            },
            "description": "User search/list/filter request.\n\nUsed in user administration and browsing interfaces to retrieve filtered, paginated user lists as described in requirements analysis (moderators/administrators). Properties correspond to search and filter dimensions for the users Prisma table.",
            "required": []
          },
          "IPageIBbsUsers": {
            "type": "object",
            "properties": {
              "pagination": {
                "$ref": "#/components/schemas/IPage.IPagination"
              },
              "data": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/IBbsUsers"
                },
                "description": "Array of user objects on this page of results.\n\nEach entry is a non-sensitive user representation for administration or moderation."
              }
            },
            "required": [
              "pagination",
              "data"
            ],
            "description": "Paginated user list container.\n\nStandard paginated interface (see IPage), adapted for listing users, corresponding to search, moderation, or audit interface needs."
          },
          "IBbsUsers": {
            "type": "object",
            "properties": {
              "id": {
                "type": "string",
                "format": "uuid",
                "description": "Unique identifier for this user (UUID).\n\nPrimary key in users table. Referenced for moderation, profile editing, and all user-based operations."
              },
              "user_role_id": {
                "type": "string",
                "format": "uuid",
                "description": "User's assigned role (UUID, references user_roles.id).\n\nProvides permissions and grants system; links user to allowable actions."
              },
              "username": {
                "type": "string",
                "description": "Unique public handle for the user, visible on posts and comments.\n\nAs outlined in requirements analysis, serves as user identity for platform interaction."
              },
              "email": {
                "type": "string",
                "description": "User's registered email address.\n\nUsed for notifications, authentication, and support. Not public by default."
              },
              "bio": {
                "oneOf": [
                  {
                    "type": "string",
                    "description": "Short biographical text the user may choose to display.\n\nUser-supplied for platform personalization; optional."
                  },
                  {
                    "type": "null",
                    "description": "Short biographical text the user may choose to display.\n\nUser-supplied for platform personalization; optional."
                  }
                ],
                "description": "Short biographical text the user may choose to display.\n\nUser-supplied for platform personalization; optional."
              },
              "created_at": {
                "type": "string",
                "format": "date-time",
                "description": "Registration timestamp (ISO8601).\n\nWhen this user joined the platform. Used for audits, sorting, compliance."
              },
              "updated_at": {
                "type": "string",
                "format": "date-time",
                "description": "Timestamp of last profile/account update (ISO8601).\n\nTracks account edit history/maintenance."
              },
              "status": {
                "type": "string",
                "description": "Current account state (e.g., active, suspended, banned).\n\nEssential for enforcing moderation/business logic as described in requirements."
              },
              "role": {
                "$ref": "#/components/schemas/IBbsUserRoles",
                "description": "Full role record for this user (joined on user_role_id).\n\nProvides name and description for UI display and permissions checks."
              }
            },
            "required": [
              "id",
              "user_role_id",
              "username",
              "email",
              "created_at",
              "updated_at",
              "status",
              "role"
            ],
            "description": "User profile record (non-sensitive).\n\nImplements all fields in users Prisma model except password_hash. Used in administration, moderation, onboarding, audit, and display. Documentation references requirements document and Prisma schema comment."
          },
          "IBbsUsers.ICreate": {
            "type": "object",
            "properties": {
              "username": {
                "type": "string",
                "description": "Desired username (must be unique).\n\nMandatory for registration and public identity, per requirements analysis."
              },
              "email": {
                "type": "string",
                "description": "Email address to register (unique, notified on events).\n\nUsed for login and notifications."
              },
              "password": {
                "type": "string",
                "description": "Initial user password (supplied in plain form, will be hashed on storage).\n\nNever returned in API. Enforced by strong password policies."
              },
              "bio": {
                "oneOf": [
                  {
                    "type": "string",
                    "description": "Optional biographical text.\n\nUser profile customization, as outlined in requirements."
                  },
                  {
                    "type": "null",
                    "description": "Optional biographical text.\n\nUser profile customization, as outlined in requirements."
                  }
                ],
                "description": "Optional biographical text.\n\nUser profile customization, as outlined in requirements."
              },
              "role_id": {
                "type": "string",
                "format": "uuid",
                "description": "Role assignment (UUID from user_roles.id).\n\nSpecifies initial user permissions (e.g., member, moderator, administrator).\nDetermines access scope for new account creation."
              }
            },
            "required": [
              "username",
              "email",
              "password",
              "role_id"
            ],
            "description": "Registration payload for new users.\n\nImplements onboarding/registration parameters as described in requirements and reflected in Prisma users table. Only non-sensitive initial account data permitted."
          },
          "IBbsUsers.IUpdate": {
            "type": "object",
            "properties": {
              "username": {
                "oneOf": [
                  {
                    "type": "string",
                    "description": "New username, if changing. Must remain unique.\n\nMay only be updated by the user or privileged roles."
                  },
                  {
                    "type": "null",
                    "description": "New username, if changing. Must remain unique.\n\nMay only be updated by the user or privileged roles."
                  }
                ],
                "description": "New username, if changing. Must remain unique.\n\nMay only be updated by the user or privileged roles."
              },
              "email": {
                "oneOf": [
                  {
                    "type": "string",
                    "description": "Email address for changing login/notifications. Must remain unique.\n\nAdmin or user-only operation."
                  },
                  {
                    "type": "null",
                    "description": "Email address for changing login/notifications. Must remain unique.\n\nAdmin or user-only operation."
                  }
                ],
                "description": "Email address for changing login/notifications. Must remain unique.\n\nAdmin or user-only operation."
              },
              "bio": {
                "oneOf": [
                  {
                    "type": "string",
                    "description": "Updated bio (profile description).\n\nUsed for user self-edit or admin-moderator workflow."
                  },
                  {
                    "type": "null",
                    "description": "Updated bio (profile description).\n\nUsed for user self-edit or admin-moderator workflow."
                  }
                ],
                "description": "Updated bio (profile description).\n\nUsed for user self-edit or admin-moderator workflow."
              },
              "status": {
                "oneOf": [
                  {
                    "type": "string",
                    "description": "Status value (active, suspended, banned, etc).\n\nMay be set by authorized roles per moderation/business rules."
                  },
                  {
                    "type": "null",
                    "description": "Status value (active, suspended, banned, etc).\n\nMay be set by authorized roles per moderation/business rules."
                  }
                ],
                "description": "Status value (active, suspended, banned, etc).\n\nMay be set by authorized roles per moderation/business rules."
              },
              "role_id": {
                "oneOf": [
                  {
                    "type": "string",
                    "format": "uuid",
                    "description": "New role assignment for the user (user_roles.id).\n\nFor admin-only role changes (e.g., promotion to moderator/administrator)."
                  },
                  {
                    "type": "null",
                    "format": "uuid",
                    "description": "New role assignment for the user (user_roles.id).\n\nFor admin-only role changes (e.g., promotion to moderator/administrator)."
                  }
                ],
                "description": "New role assignment for the user (user_roles.id).\n\nFor admin-only role changes (e.g., promotion to moderator/administrator)."
              }
            },
            "description": "Update payload for user profile/account.\n\nImplements the user and administrative self-update, moderation, and profile-edit flows described in requirements analysis and Prisma schema. All fields optional for PATCH/PUT semantics.",
            "required": []
          },
          "IBbsUserRoles.IRequest": {
            "type": "object",
            "properties": {
              "page": {
                "oneOf": [
                  {
                    "type": "integer",
                    "description": "Requested page of role results.\n\nAdheres to pagination standard (see IPage.IRequest)."
                  },
                  {
                    "type": "null",
                    "description": "Requested page of role results.\n\nAdheres to pagination standard (see IPage.IRequest)."
                  }
                ],
                "description": "Requested page of role results.\n\nAdheres to pagination standard (see IPage.IRequest)."
              },
              "limit": {
                "oneOf": [
                  {
                    "type": "integer",
                    "description": "Maximum number of roles per page.\n\nDefault is 100; supports admin audit or onboarding configuration."
                  },
                  {
                    "type": "null",
                    "description": "Maximum number of roles per page.\n\nDefault is 100; supports admin audit or onboarding configuration."
                  }
                ],
                "description": "Maximum number of roles per page.\n\nDefault is 100; supports admin audit or onboarding configuration."
              },
              "name": {
                "oneOf": [
                  {
                    "type": "string",
                    "description": "Role name filter (exact or pattern match).\n\nFor filtering available roles by label in role management interface."
                  },
                  {
                    "type": "null",
                    "description": "Role name filter (exact or pattern match).\n\nFor filtering available roles by label in role management interface."
                  }
                ],
                "description": "Role name filter (exact or pattern match).\n\nFor filtering available roles by label in role management interface."
              },
              "description": {
                "oneOf": [
                  {
                    "type": "string",
                    "description": "Keyword match on the role description.\n\nHelps administrators or business workflows find newly created roles or audit permissions."
                  },
                  {
                    "type": "null",
                    "description": "Keyword match on the role description.\n\nHelps administrators or business workflows find newly created roles or audit permissions."
                  }
                ],
                "description": "Keyword match on the role description.\n\nHelps administrators or business workflows find newly created roles or audit permissions."
              }
            },
            "description": "Filter/search payload for user_roles listing.\n\nEnables administrative workflows for governance, onboarding, and audit per requirements analysis.",
            "required": []
          },
          "IPageIBbsUserRoles": {
            "type": "object",
            "properties": {
              "pagination": {
                "$ref": "#/components/schemas/IPage.IPagination"
              },
              "data": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/IBbsUserRoles"
                },
                "description": "List of user role objects for this result page."
              }
            },
            "required": [
              "pagination",
              "data"
            ],
            "description": "Paginated user role results container.\n\nStandard pagination (see IPage), extended for user role record listing, used in administrative and onboarding contexts."
          },
          "IBbsUserRoles": {
            "type": "object",
            "properties": {
              "id": {
                "type": "string",
                "format": "uuid",
                "description": "Unique identifier for user role (UUID).\n\nPrimary key from user_roles."
              },
              "name": {
                "type": "string",
                "description": "Unique label for the user role (e.g., member, moderator, administrator).\n\nFulfills role business logic and governance, per requirements."
              },
              "description": {
                "type": "string",
                "description": "Detailed explanation of the role's permissions, scope, or duties.\n\nShown in onboarding and administration to explain role scope."
              }
            },
            "required": [
              "id",
              "name",
              "description"
            ],
            "description": "User role metadata record.\n\nImplements the business logic of platform roles as described in requirements and user_roles table."
          },
          "IBbsUserRoles.ICreate": {
            "type": "object",
            "properties": {
              "name": {
                "type": "string",
                "description": "Role label (unique, required).\n\nRequired for creating new permissions classes in system governance."
              },
              "description": {
                "type": "string",
                "description": "Human-readable explanation of the role's authority and purpose.\n\nFor oversight and onboarding display."
              }
            },
            "required": [
              "name",
              "description"
            ],
            "description": "Payload to create a new user role.\n\nUsed for onboarding/registration configuration and extending moderation/business model, as per requirements and schema."
          },
          "IBbsUserRoles.IUpdate": {
            "type": "object",
            "properties": {
              "name": {
                "oneOf": [
                  {
                    "type": "string",
                    "description": "New name/label for user role, if changing.\n\nMust remain unique if provided."
                  },
                  {
                    "type": "null",
                    "description": "New name/label for user role, if changing.\n\nMust remain unique if provided."
                  }
                ],
                "description": "New name/label for user role, if changing.\n\nMust remain unique if provided."
              },
              "description": {
                "oneOf": [
                  {
                    "type": "string",
                    "description": "Updated explanation for the role (e.g., changing duties, scope).\n\nAdministrative update only."
                  },
                  {
                    "type": "null",
                    "description": "Updated explanation for the role (e.g., changing duties, scope).\n\nAdministrative update only."
                  }
                ],
                "description": "Updated explanation for the role (e.g., changing duties, scope).\n\nAdministrative update only."
              }
            },
            "description": "Payload to update an existing role.\n\nAll fields optional for PUT/PATCH behaviors, as per requirements analysis and schema comments.",
            "required": []
          },
          "IBbsCategories.IRequest": {
            "type": "object",
            "properties": {
              "page": {
                "oneOf": [
                  {
                    "type": "integer",
                    "description": "Requested page number for category result listing.\n\nSupports pagination consistent with IPage.IRequest standard."
                  },
                  {
                    "type": "null",
                    "description": "Requested page number for category result listing.\n\nSupports pagination consistent with IPage.IRequest standard."
                  }
                ],
                "description": "Requested page number for category result listing.\n\nSupports pagination consistent with IPage.IRequest standard."
              },
              "limit": {
                "oneOf": [
                  {
                    "type": "integer",
                    "description": "Maximum categories to return per page (default 100).\n\nUsed to manage category lists in creation, onboarding, or admin flows."
                  },
                  {
                    "type": "null",
                    "description": "Maximum categories to return per page (default 100).\n\nUsed to manage category lists in creation, onboarding, or admin flows."
                  }
                ],
                "description": "Maximum categories to return per page (default 100).\n\nUsed to manage category lists in creation, onboarding, or admin flows."
              },
              "name": {
                "oneOf": [
                  {
                    "type": "string",
                    "description": "Filter/search by category name (pattern or exact match).\n\nSupports navigation and management per requirements logic."
                  },
                  {
                    "type": "null",
                    "description": "Filter/search by category name (pattern or exact match).\n\nSupports navigation and management per requirements logic."
                  }
                ],
                "description": "Filter/search by category name (pattern or exact match).\n\nSupports navigation and management per requirements logic."
              },
              "description": {
                "oneOf": [
                  {
                    "type": "string",
                    "description": "Filter/search by category description content.\n\nAllows admin management and onboarding support for new users."
                  },
                  {
                    "type": "null",
                    "description": "Filter/search by category description content.\n\nAllows admin management and onboarding support for new users."
                  }
                ],
                "description": "Filter/search by category description content.\n\nAllows admin management and onboarding support for new users."
              }
            },
            "description": "Category list/search request payload.\n\nImplements category exploration, onboarding, navigation, and administrative audit flows from requirements analysis.",
            "required": []
          },
          "IPageIBbsCategories": {
            "type": "object",
            "properties": {
              "pagination": {
                "$ref": "#/components/schemas/IPage.IPagination"
              },
              "data": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/IBbsCategories"
                },
                "description": "Array of category metadata objects on this page."
              }
            },
            "required": [
              "pagination",
              "data"
            ],
            "description": "Paginated category listing container.\n\nStandard interface for listing available topic categories for post assignment, UI navigation, or admin workflows."
          },
          "IBbsCategories": {
            "type": "object",
            "properties": {
              "id": {
                "type": "string",
                "format": "uuid",
                "description": "Unique identifier for the category, corresponding to the `id` primary key in the categories Prisma model.\n\nThis ID is system-generated and is used throughout API requests when referencing categories. Fulfills the 'Category' entity requirements from the business and data structure specifications."
              },
              "name": {
                "type": "string",
                "description": "The human-readable name of the category, corresponding to the `name` column in the categories table.\n\nThis value must be unique. It is used in navigation, filtering posts, and display for end users. As per the requirements, examples might be 'Politics', 'Economics', or 'International Affairs'."
              },
              "description": {
                "type": "string",
                "description": "A description of the category, corresponding to the `description` column in the database.\n\nThis field clarifies the scope and focus of the discussion for posts under this category, e.g., 'Discussion about domestic and international political systems, governance, and related events.'"
              },
              "created_at": {
                "type": "string",
                "format": "date-time",
                "description": "The timestamp when the category was created, matching `created_at` in the categories schema.\n\nUsed for audit trails, admin reporting, and chronological display of categories."
              }
            },
            "required": [
              "id",
              "name",
              "description",
              "created_at"
            ],
            "description": "Represents discussion board categories, such as Politics or Economics.\n\nReflects the categories entity from the business requirements and the `categories` table in the Prisma schema. Contains a unique ID, name, description, and creation timestamp. Categories organize posts and are managed by administrators."
          },
          "IPage.IPagination": {
            "type": "object",
            "properties": {
              "current": {
                "type": "integer",
                "format": "uint32",
                "description": "Current page number."
              },
              "limit": {
                "type": "integer",
                "format": "uint32",
                "description": "Number of records per page. Default is 100."
              },
              "records": {
                "type": "integer",
                "format": "uint32",
                "description": "Total number of records in the result set."
              },
              "pages": {
                "type": "integer",
                "format": "uint32",
                "description": "Total pages. Equal to records/limit with ceiling."
              }
            },
            "required": [
              "current",
              "limit",
              "records",
              "pages"
            ],
            "description": "Pagination information for paginated results. Used in all IPage<T> structures; see standard type definition."
          },
          "bbsCategories.ICreate": {
            "type": "object",
            "properties": {
              "name": {
                "type": "string",
                "description": "The unique name for the new category, as per the `name` field in the categories table.\n\nMust be non-empty and unique among all categories. Used for users to navigate posts and choose topics."
              },
              "description": {
                "type": "string",
                "description": "Description for the new category, giving users information about the scope and focus. Taken from the `description` field in the categories schema.\n\nMust be non-empty. This is shown to users when posting or browsing."
              }
            },
            "required": [
              "name",
              "description"
            ],
            "description": "Payload for creating a new category.\n\nUsed by administrators via the create category API to add organizational topics, matching the 'categories' table structure."
          },
          "bbsCategories": {
            "$ref": "#/components/schemas/IBbsCategories",
            "description": "Alias to IBbsCategories. Used for legacy/type consistency in endpoints referring to category entities. Ensures consistent documentation and code use."
          },
          "bbsCategories.IUpdate": {
            "type": "object",
            "properties": {
              "name": {
                "type": "string",
                "description": "The new or updated name for this category, as per the `name` column in the categories table.\n\nMust remain unique and non-empty."
              },
              "description": {
                "type": "string",
                "description": "Updated description for the category, as per the `description` column in the schema.\n\nMust also be non-empty."
              }
            },
            "required": [
              "name",
              "description"
            ],
            "description": "Payload for updating an existing category.\n\nSent by administrators to modify category name or description. Matches structure and constraints of the `categories` table."
          },
          "bbsPosts.IRequest": {
            "type": "object",
            "properties": {
              "query": {
                "type": "string",
                "description": "A search string to filter posts by keyword in the title or content.\n\nHelps users find posts matching specific topics. May use advanced search or simple substring matching."
              },
              "category_id": {
                "type": "string",
                "format": "uuid",
                "description": "Filters posts to those belonging to this category, referencing `category_id` in the posts table.\n\nEnables category-based navigation or analysis."
              },
              "sort_by": {
                "oneOf": [
                  {
                    "const": "created_at",
                    "description": "The field to sort posts by when listing results.\n\nTypically one of: 'created_at' (date posted), 'updated_at', 'title', or 'votes' (tally of upvotes/downvotes)."
                  },
                  {
                    "const": "updated_at",
                    "description": "The field to sort posts by when listing results.\n\nTypically one of: 'created_at' (date posted), 'updated_at', 'title', or 'votes' (tally of upvotes/downvotes)."
                  },
                  {
                    "const": "title",
                    "description": "The field to sort posts by when listing results.\n\nTypically one of: 'created_at' (date posted), 'updated_at', 'title', or 'votes' (tally of upvotes/downvotes)."
                  },
                  {
                    "const": "votes",
                    "description": "The field to sort posts by when listing results.\n\nTypically one of: 'created_at' (date posted), 'updated_at', 'title', or 'votes' (tally of upvotes/downvotes)."
                  }
                ],
                "description": "The field to sort posts by when listing results.\n\nTypically one of: 'created_at' (date posted), 'updated_at', 'title', or 'votes' (tally of upvotes/downvotes)."
              },
              "order": {
                "oneOf": [
                  {
                    "const": "asc",
                    "description": "Specifies the order (ascending or descending) of the sort. Example: 'desc' for newest first, 'asc' for alphabetical."
                  },
                  {
                    "const": "desc",
                    "description": "Specifies the order (ascending or descending) of the sort. Example: 'desc' for newest first, 'asc' for alphabetical."
                  }
                ],
                "description": "Specifies the order (ascending or descending) of the sort. Example: 'desc' for newest first, 'asc' for alphabetical."
              },
              "page": {
                "type": "integer",
                "format": "int32",
                "description": "The page number to request (for pagination).\n\nDefaults to 1 if omitted."
              },
              "limit": {
                "type": "integer",
                "format": "int32",
                "description": "Maximum number of posts to return per page (pagination limit).\n\nTypical values are 10, 20, or 50 per page. Defaults may apply if omitted."
              }
            },
            "required": [],
            "description": "Request parameters for listing or searching posts in the discussion board.\n\nImplements filtering, sorting, and pagination features for the `posts` entity. Matches 'bbsPosts.IRequest' business requirements and supports advanced exploration of post listings."
          },
          "IPageBbsPosts": {
            "type": "object",
            "properties": {
              "pagination": {
                "$ref": "#/components/schemas/IPage.IPagination"
              },
              "data": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/bbsPosts"
                },
                "description": "List of post records for this page, matching the query/filter."
              }
            },
            "required": [
              "pagination",
              "data"
            ],
            "description": "Paginated result wrapper for posts listing operations.\n\nHolds an array of post records and pagination metadata, following IPage<T> business conventions."
          },
          "bbsPosts": {
            "type": "object",
            "properties": {
              "id": {
                "type": "string",
                "format": "uuid",
                "description": "Unique identifier of the post. The `id` field in the posts model.\n\nUsed for referencing the post in API calls or links."
              },
              "user_id": {
                "type": "string",
                "format": "uuid",
                "description": "UUID of the user (author) who created this post, corresponding to `user_id` in the posts table.\n\nProvides author traceability and links to user profiles."
              },
              "category_id": {
                "type": "string",
                "format": "uuid",
                "description": "UUID of the category under which the post was published, referencing `category_id` in the posts table.\n\nSupports topic-based navigation and organization."
              },
              "title": {
                "type": "string",
                "description": "The post's headline/title. Implements the required `title` property in the posts schema.\n\nProminently displayed in thread lists and views."
              },
              "content": {
                "type": "string",
                "description": "Main content/body of the post, from the `content` field in the posts table.\n\nIncludes long-form text, opinion, or analysis. Critical for community discussion."
              },
              "created_at": {
                "type": "string",
                "format": "date-time",
                "description": "The timestamp when the post was created, matching `created_at` in the database.\n\nDisplayed in lists, used for freshness ordering, and necessary for audits."
              },
              "updated_at": {
                "type": "string",
                "format": "date-time",
                "description": "Last modification timestamp, from `updated_at` in the posts record.\n\nEnables edit history tracking and evidence of moderation or typo corrections."
              },
              "deleted_at": {
                "oneOf": [
                  {
                    "type": "string",
                    "format": "date-time",
                    "description": "If present, this timestamp indicates when the post was soft-deleted (not physically removed), in line with moderation and audit business rules.\n\nNull if the post is currently visible."
                  },
                  {
                    "type": "null"
                  }
                ],
                "description": "If present, this timestamp indicates when the post was soft-deleted (not physically removed), in line with moderation and audit business rules.\n\nNull if the post is currently visible."
              }
            },
            "required": [
              "id",
              "user_id",
              "category_id",
              "title",
              "content",
              "created_at",
              "updated_at"
            ],
            "description": "Represents a discussion post (thread) on the platform, matching the posts entity from the requirements analysis and the posts table in the Prisma schema.\n\nProvides all information about the post, including subject/title, content, author ID, category, timestamps, and deletion flag for moderation."
          },
          "bbsPosts.ICreate": {
            "type": "object",
            "properties": {
              "category_id": {
                "type": "string",
                "format": "uuid",
                "description": "UUID for the category where the post is to be published. Implements the business logic in the posts model requiring category assignment.\n\nMust refer to an existing category."
              },
              "title": {
                "type": "string",
                "description": "Headline/title for the post. Required field representing the core subject or summary for the thread.\n\nMust be non-empty, per business and schema rules."
              },
              "content": {
                "type": "string",
                "description": "Main content/body of the post. Required for meaningful discussion.\n\nMust be non-empty, and may include text, links, or analysis."
              }
            },
            "required": [
              "category_id",
              "title",
              "content"
            ],
            "description": "Payload for creating a new post in the discussion board.\n\nLinks the new post to a specific category, supplies a title and content. Used by regular users during post creation workflows."
          },
          "bbsPosts.IUpdate": {
            "type": "object",
            "properties": {
              "category_id": {
                "type": "string",
                "format": "uuid",
                "description": "New or updated UUID for the category the post is assigned to.\n\nChanges the post's topical placement. Must reference an existing category."
              },
              "title": {
                "type": "string",
                "description": "New or updated headline/title for the post. Subject to uniqueness or non-emptiness per business and schema rules."
              },
              "content": {
                "type": "string",
                "description": "Updated body/content of the post. Required for substantial updates. Subject to moderation and editability constraints."
              }
            },
            "required": [
              "category_id",
              "title",
              "content"
            ],
            "description": "Payload for updating a post. Sent by the author, moderator, or admin to edit post category, headline, or content.\n\nAll fields are required; aligns with edit operation semantics in business requirements."
          },
          "bbsComments.IRequest": {
            "type": "object",
            "properties": {
              "author_id": {
                "type": "string",
                "format": "uuid",
                "description": "Optional filter to list only comments written by the specified user, matching `user_id` in comments table.\n\nSupports audit and user-based navigation."
              },
              "created_after": {
                "type": "string",
                "format": "date-time",
                "description": "Optional start date/time for filtering comments.\n\nUsed for moderating recent activity, historical review, or analytics."
              },
              "created_before": {
                "type": "string",
                "format": "date-time",
                "description": "Optional end date/time for filtering comments."
              },
              "sort_by": {
                "oneOf": [
                  {
                    "const": "created_at",
                    "description": "Defines the sorting field for the comment list. Typical values are 'created_at' or 'updated_at'."
                  },
                  {
                    "const": "updated_at",
                    "description": "Defines the sorting field for the comment list. Typical values are 'created_at' or 'updated_at'."
                  }
                ],
                "description": "Defines the sorting field for the comment list. Typical values are 'created_at' or 'updated_at'."
              },
              "order": {
                "oneOf": [
                  {
                    "const": "asc",
                    "description": "Direction of sorting order applied. 'desc' for most recent first, 'asc' for chronological."
                  },
                  {
                    "const": "desc",
                    "description": "Direction of sorting order applied. 'desc' for most recent first, 'asc' for chronological."
                  }
                ],
                "description": "Direction of sorting order applied. 'desc' for most recent first, 'asc' for chronological."
              },
              "page": {
                "type": "integer",
                "format": "int32",
                "description": "Result page number for pagination. Defaults to 1 if omitted."
              },
              "limit": {
                "type": "integer",
                "format": "int32",
                "description": "Maximum number of comments per page, supporting pagination for large threads."
              }
            },
            "required": [],
            "description": "Request parameters for listing/searching comments under a post.\n\nSupports author filtering, time range selection, sorting, and pagination—matching audit and moderation needs for nested comment threads."
          },
          "IPageBbsComments": {
            "type": "object",
            "properties": {
              "pagination": {
                "$ref": "#/components/schemas/IPage.IPagination"
              },
              "data": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/bbsComments"
                },
                "description": "Array of comments for the result page."
              }
            },
            "required": [
              "pagination",
              "data"
            ],
            "description": "Paginated response wrapper for comments list/search APIs.\n\nHolds the page of comment records and pagination info, conforming to platform standards for large thread handling."
          },
          "bbsComments": {
            "type": "object",
            "properties": {
              "id": {
                "type": "string",
                "format": "uuid",
                "description": "Unique identifier for the comment, `id` primary key from the comments table.\n\nUsed system-wide to reference comments in API operations and thread navigation."
              },
              "user_id": {
                "type": "string",
                "format": "uuid",
                "description": "UUID of the user who wrote this comment, matching `user_id` in comments table.\n\nUsed for author audits, reply tracking, and profile linking."
              },
              "post_id": {
                "type": "string",
                "format": "uuid",
                "description": "UUID of the post this comment is attached to, from `post_id` in the comments table.\n\nCritical for threading, structure, and navigation of discussion posts."
              },
              "parent_id": {
                "oneOf": [
                  {
                    "type": "string",
                    "format": "uuid",
                    "description": "If present, this is the UUID of the parent comment, enabling threading/nesting of replies. Nullable for top-level comments.\n\nImplements self-referential comment hierarchy as explained in requirements and Prisma schema."
                  },
                  {
                    "type": "null"
                  }
                ],
                "description": "If present, this is the UUID of the parent comment, enabling threading/nesting of replies. Nullable for top-level comments.\n\nImplements self-referential comment hierarchy as explained in requirements and Prisma schema."
              },
              "content": {
                "type": "string",
                "description": "Body/content of the comment, from the `content` field in comments table.\n\nCarries user opinion, replies, and substantive discussion."
              },
              "created_at": {
                "type": "string",
                "format": "date-time",
                "description": "Timestamp for comment creation, from `created_at` column.\n\nUsed in chronological sorting, audit, and moderation."
              },
              "updated_at": {
                "type": "string",
                "format": "date-time",
                "description": "Timestamp for last update of the comment, as per `updated_at` field.\n\nReflects edit history and moderation actions."
              },
              "deleted_at": {
                "oneOf": [
                  {
                    "type": "string",
                    "format": "date-time",
                    "description": "Soft deletion flag (if present) indicating when this comment was 'deleted' for moderation, but not physically removed from the database.\n\nNull if currently active."
                  },
                  {
                    "type": "null"
                  }
                ],
                "description": "Soft deletion flag (if present) indicating when this comment was 'deleted' for moderation, but not physically removed from the database.\n\nNull if currently active."
              }
            },
            "required": [
              "id",
              "user_id",
              "post_id",
              "content",
              "created_at",
              "updated_at"
            ],
            "description": "Represents a comment entity in the discussion board. Used for both top-level and nested/threaded replies.\n\nFully aligns with the comments entity as specified in the requirements and comments table in the Prisma schema, including parent-child threading, audit, and moderation soft-delete support."
          },
          "bbsComments.ICreate": {
            "type": "object",
            "properties": {
              "content": {
                "type": "string",
                "description": "Comment body text.\n\nThis property contains the text that will be displayed as the content of the comment. It implements the rule that each comment consists of user-written content. For example: 'I agree and here’s why...'. Referenced from the 'content' column in the Prisma comments model and per requirements in 03_data_structure_and_business_rules.md."
              },
              "parent_id": {
                "oneOf": [
                  {
                    "type": "string",
                    "format": "uuid",
                    "description": "The ID of the parent comment for nested/threaded replies. Nullable for top-level comments (direct replies to posts).\n\nReferenced from 'parent_id' in the comments Prisma schema. Implements thread/nesting support and conversation branching per requirements."
                  },
                  {
                    "type": "null",
                    "format": "uuid",
                    "description": "The ID of the parent comment for nested/threaded replies. Nullable for top-level comments (direct replies to posts).\n\nReferenced from 'parent_id' in the comments Prisma schema. Implements thread/nesting support and conversation branching per requirements."
                  }
                ],
                "description": "The ID of the parent comment for nested/threaded replies. Nullable for top-level comments (direct replies to posts).\n\nReferenced from 'parent_id' in the comments Prisma schema. Implements thread/nesting support and conversation branching per requirements."
              }
            },
            "required": [
              "content"
            ],
            "description": "Model for creating a new comment on a post or as a reply to another comment.\n\nBased on the requirements document and comments schema, this interface allows users to create either a top-level comment or a nested reply. Only registered users may comment. Thread assignment is supported via optional parent_id."
          },
          "bbsComments.IUpdate": {
            "type": "object",
            "properties": {
              "content": {
                "type": "string",
                "description": "Updated comment body text.\n\nChanged content for this comment. Enforces non-empty value and transparent audit trails, per the 'content' column in comments Prisma model."
              }
            },
            "required": [
              "content"
            ],
            "description": "Model for updating an existing comment. Allows comment text to be edited subject to audit and ownership rules (see Prisma comment model and requirements analysis)."
          },
          "IBbsCommentReply.IRequest": {
            "type": "object",
            "properties": {
              "page": {
                "oneOf": [
                  {
                    "type": "integer",
                    "format": "uint32",
                    "description": "Page number for pagination (optional). Allows navigating through multiple pages of replies. See standard 'IPage' interface definition."
                  },
                  {
                    "type": "null",
                    "format": "uint32",
                    "description": "Page number for pagination (optional). Allows navigating through multiple pages of replies. See standard 'IPage' interface definition."
                  }
                ],
                "description": "Page number for pagination (optional). Allows navigating through multiple pages of replies. See standard 'IPage' interface definition."
              },
              "limit": {
                "oneOf": [
                  {
                    "type": "integer",
                    "format": "uint32",
                    "description": "Number of replies per page (optional). Defaults to 100 if not specified. See IPage.IRequest standard type."
                  },
                  {
                    "type": "null",
                    "format": "uint32",
                    "description": "Number of replies per page (optional). Defaults to 100 if not specified. See IPage.IRequest standard type."
                  }
                ],
                "description": "Number of replies per page (optional). Defaults to 100 if not specified. See IPage.IRequest standard type."
              }
            },
            "description": "Parameters for listing or searching child replies to a specific comment. Implements filtering/pagination for nested replies based on standard IPage IRequest schema.",
            "required": []
          },
          "IPageIBbsCommentReply": {
            "type": "object",
            "properties": {
              "pagination": {
                "$ref": "#/components/schemas/IPage.IPagination"
              },
              "data": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/IBbsCommentReply"
                },
                "description": "List of reply comments matching the search/pagination criteria. Each item is an IBbsCommentReply instance."
              }
            },
            "required": [
              "pagination",
              "data"
            ],
            "description": "Paginated container for replies to a specific comment.\n\nImplements the IPage structure for consistent pagination information and reply lists. Used in threaded/nested comment UIs and admin moderation tools."
          },
          "IBbsCommentReply": {
            "type": "object",
            "properties": {
              "id": {
                "type": "string",
                "format": "uuid",
                "description": "Unique identifier for the comment reply.\n\nPrimary key from the comments Prisma model. Used for programmatic operations and API lookups."
              },
              "user_id": {
                "type": "string",
                "format": "uuid",
                "description": "Identifier for the authoring user of this reply comment.\n\nReferences users.id. Used for attribution, audit, and profile summary features."
              },
              "post_id": {
                "type": "string",
                "format": "uuid",
                "description": "Identifier for the parent post to which this reply (comment) belongs.\n\nReferences posts.id. Required for evidence/auditing, threading context, and navigation (see ERD and comments model)."
              },
              "parent_id": {
                "oneOf": [
                  {
                    "type": "string",
                    "format": "uuid",
                    "description": "Identifier for the parent comment if this is a reply (threading hierarchy). Null for top-level (post) replies, set for nested replies.\n\nMapped from comments.parent_id in the Prisma schema."
                  },
                  {
                    "type": "null",
                    "format": "uuid",
                    "description": "Identifier for the parent comment if this is a reply (threading hierarchy). Null for top-level (post) replies, set for nested replies.\n\nMapped from comments.parent_id in the Prisma schema."
                  }
                ],
                "description": "Identifier for the parent comment if this is a reply (threading hierarchy). Null for top-level (post) replies, set for nested replies.\n\nMapped from comments.parent_id in the Prisma schema."
              },
              "content": {
                "type": "string",
                "description": "Reply body text for this comment. Business meaning: user-supplied message or opinion as per 'content' in Prisma model."
              },
              "created_at": {
                "type": "string",
                "format": "date-time",
                "description": "Timestamp for when the reply comment was created (ISO 8601 format).\n\nTaken from comments.created_at. Important for audit/history, proper ordering, and moderation evidence."
              },
              "updated_at": {
                "type": "string",
                "format": "date-time",
                "description": "Timestamp for last edit. Reflects edit history and transparency for users/moderators. Maps to comments.updated_at field."
              },
              "deleted_at": {
                "oneOf": [
                  {
                    "type": "string",
                    "format": "date-time",
                    "description": "If set, indicates the reply was deleted (soft delete logic). Used for moderation/audit preservation. Matches comments.deleted_at."
                  },
                  {
                    "type": "null",
                    "format": "date-time",
                    "description": "If set, indicates the reply was deleted (soft delete logic). Used for moderation/audit preservation. Matches comments.deleted_at."
                  }
                ],
                "description": "If set, indicates the reply was deleted (soft delete logic). Used for moderation/audit preservation. Matches comments.deleted_at."
              }
            },
            "required": [
              "id",
              "user_id",
              "post_id",
              "content",
              "created_at",
              "updated_at"
            ],
            "description": "A single reply comment/nested reply object.\n\nRepresents a direct response to a parent comment (or a top-level post reply).\nIncludes all evidence required for auditing, threading, and moderation. Referenced from threaded/nested replies in comments Prisma model."
          },
          "IBbsCommentReply.ICreate": {
            "type": "object",
            "properties": {
              "content": {
                "type": "string",
                "description": "Reply content (body text). User-supplied message or opinion contributed as a nested reply. From comments.content Prisma field."
              }
            },
            "required": [
              "content"
            ],
            "description": "Payload for creating a new reply (nested comment) to a parent comment. Enforces required comment body, referenced from comments Prisma model and requirements analysis."
          },
          "IBbsCommentReply.IUpdate": {
            "type": "object",
            "properties": {
              "content": {
                "type": "string",
                "description": "Updated reply content (body text). Used when editing reply within allowed window, per requirements."
              }
            },
            "required": [
              "content"
            ],
            "description": "Edit/update payload for a reply comment (nested thread). Allows the reply content to be changed. Ownership and audit rules apply."
          },
          "IBbsVote.IRequest": {
            "type": "object",
            "properties": {
              "page": {
                "oneOf": [
                  {
                    "type": "integer",
                    "format": "uint32",
                    "description": "Page number for result pagination. Used for navigating through vote records. See IPage.IRequest guidelines."
                  },
                  {
                    "type": "null",
                    "format": "uint32",
                    "description": "Page number for result pagination. Used for navigating through vote records. See IPage.IRequest guidelines."
                  }
                ],
                "description": "Page number for result pagination. Used for navigating through vote records. See IPage.IRequest guidelines."
              },
              "limit": {
                "oneOf": [
                  {
                    "type": "integer",
                    "format": "uint32",
                    "description": "Number of vote records per page. Default is 100. Controls batch size returned. See IPage.IRequest."
                  },
                  {
                    "type": "null",
                    "format": "uint32",
                    "description": "Number of vote records per page. Default is 100. Controls batch size returned. See IPage.IRequest."
                  }
                ],
                "description": "Number of vote records per page. Default is 100. Controls batch size returned. See IPage.IRequest."
              },
              "user_id": {
                "oneOf": [
                  {
                    "type": "string",
                    "format": "uuid",
                    "description": "Filter by the voter's (user's) UUID. Useful for auditing or personal history views. From votes.user_id."
                  },
                  {
                    "type": "null",
                    "format": "uuid",
                    "description": "Filter by the voter's (user's) UUID. Useful for auditing or personal history views. From votes.user_id."
                  }
                ],
                "description": "Filter by the voter's (user's) UUID. Useful for auditing or personal history views. From votes.user_id."
              },
              "post_id": {
                "oneOf": [
                  {
                    "type": "string",
                    "format": "uuid",
                    "description": "Filter by a specific post (UUID) - returns votes associated with the given post ID. From votes.post_id."
                  },
                  {
                    "type": "null",
                    "format": "uuid",
                    "description": "Filter by a specific post (UUID) - returns votes associated with the given post ID. From votes.post_id."
                  }
                ],
                "description": "Filter by a specific post (UUID) - returns votes associated with the given post ID. From votes.post_id."
              },
              "comment_id": {
                "oneOf": [
                  {
                    "type": "string",
                    "format": "uuid",
                    "description": "Filter votes associated with a particular comment (UUID). Enables lookup of votes for a comment thread/reply (votes.comment_id)."
                  },
                  {
                    "type": "null",
                    "format": "uuid",
                    "description": "Filter votes associated with a particular comment (UUID). Enables lookup of votes for a comment thread/reply (votes.comment_id)."
                  }
                ],
                "description": "Filter votes associated with a particular comment (UUID). Enables lookup of votes for a comment thread/reply (votes.comment_id)."
              },
              "value": {
                "oneOf": [
                  {
                    "const": -1,
                    "description": "Filter by vote value: +1 (upvote) or -1 (downvote). Optional. From votes.value."
                  },
                  {
                    "const": 1,
                    "description": "Filter by vote value: +1 (upvote) or -1 (downvote). Optional. From votes.value."
                  },
                  {
                    "type": "null",
                    "enum": [
                      -1,
                      1
                    ],
                    "description": "Filter by vote value: +1 (upvote) or -1 (downvote). Optional. From votes.value."
                  }
                ],
                "description": "Filter by vote value: +1 (upvote) or -1 (downvote). Optional. From votes.value."
              },
              "created_after": {
                "oneOf": [
                  {
                    "type": "string",
                    "format": "date-time",
                    "description": "Include votes created after this date/time (ISO-8601). Audit/analytics tool."
                  },
                  {
                    "type": "null",
                    "format": "date-time",
                    "description": "Include votes created after this date/time (ISO-8601). Audit/analytics tool."
                  }
                ],
                "description": "Include votes created after this date/time (ISO-8601). Audit/analytics tool."
              },
              "created_before": {
                "oneOf": [
                  {
                    "type": "string",
                    "format": "date-time",
                    "description": "Include votes created before this date/time (ISO-8601). Audit/analytics/periodic analysis."
                  },
                  {
                    "type": "null",
                    "format": "date-time",
                    "description": "Include votes created before this date/time (ISO-8601). Audit/analytics/periodic analysis."
                  }
                ],
                "description": "Include votes created before this date/time (ISO-8601). Audit/analytics/periodic analysis."
              }
            },
            "description": "Request/query object for searching votes table. Implements voting auditability, moderation, and analytics as detailed in Prisma model and requirements analysis.",
            "required": []
          },
          "IPageIBbsVote": {
            "type": "object",
            "properties": {
              "pagination": {
                "$ref": "#/components/schemas/IPage.IPagination"
              },
              "data": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/IBbsVote"
                },
                "description": "Vote records for the query window, each as an IBbsVote object."
              }
            },
            "required": [
              "pagination",
              "data"
            ],
            "description": "Paginated result structure for queries on the votes table.\n\nStandardized as IPage<T>, with pagination and vote data array. Used in moderation, analytics, and voting integrity checks."
          },
          "IBbsVote": {
            "type": "object",
            "properties": {
              "id": {
                "type": "string",
                "format": "uuid",
                "description": "Unique identifier for the vote record. Maps to votes.id in Prisma schema."
              },
              "user_id": {
                "type": "string",
                "format": "uuid",
                "description": "User (voter) UUID that cast this vote. From votes.user_id. Used for auditing and per-user history."
              },
              "post_id": {
                "oneOf": [
                  {
                    "type": "string",
                    "format": "uuid",
                    "description": "UUID of the post being voted on, if applicable. From votes.post_id. Mutually exclusive with comment_id per schema."
                  },
                  {
                    "type": "null",
                    "format": "uuid",
                    "description": "UUID of the post being voted on, if applicable. From votes.post_id. Mutually exclusive with comment_id per schema."
                  }
                ],
                "description": "UUID of the post being voted on, if applicable. From votes.post_id. Mutually exclusive with comment_id per schema."
              },
              "comment_id": {
                "oneOf": [
                  {
                    "type": "string",
                    "format": "uuid",
                    "description": "UUID of the comment being voted on, if applicable. From votes.comment_id. Mutually exclusive with post_id."
                  },
                  {
                    "type": "null",
                    "format": "uuid",
                    "description": "UUID of the comment being voted on, if applicable. From votes.comment_id. Mutually exclusive with post_id."
                  }
                ],
                "description": "UUID of the comment being voted on, if applicable. From votes.comment_id. Mutually exclusive with post_id."
              },
              "value": {
                "oneOf": [
                  {
                    "const": -1,
                    "description": "Vote value: +1 for upvote, -1 for downvote. Enforced by DB check and business rules. From votes.value."
                  },
                  {
                    "const": 1,
                    "description": "Vote value: +1 for upvote, -1 for downvote. Enforced by DB check and business rules. From votes.value."
                  }
                ],
                "description": "Vote value: +1 for upvote, -1 for downvote. Enforced by DB check and business rules. From votes.value."
              },
              "created_at": {
                "type": "string",
                "format": "date-time",
                "description": "Timestamp when the vote was made. From votes.created_at. Used for auditing, reporting, and analytics."
              }
            },
            "required": [
              "id",
              "user_id",
              "value",
              "created_at"
            ],
            "description": "A single vote record (post or comment vote).\n\nDefines the core information about a user-provided upvote/downvote for either a post or comment. Per schema, only one of post_id or comment_id is populated for each record. Business rules for voting integrity apply."
          },
          "IBbsVote.ICreate": {
            "type": "object",
            "properties": {
              "post_id": {
                "oneOf": [
                  {
                    "type": "string",
                    "format": "uuid",
                    "description": "ID of the post to be voted on. Set this or comment_id, but not both. Enforced by business logic and unique constraint (see votes.post_id)."
                  },
                  {
                    "type": "null",
                    "format": "uuid",
                    "description": "ID of the post to be voted on. Set this or comment_id, but not both. Enforced by business logic and unique constraint (see votes.post_id)."
                  }
                ],
                "description": "ID of the post to be voted on. Set this or comment_id, but not both. Enforced by business logic and unique constraint (see votes.post_id)."
              },
              "comment_id": {
                "oneOf": [
                  {
                    "type": "string",
                    "format": "uuid",
                    "description": "ID of the comment to be voted on. Set this or post_id, but not both. Only one target can be set. From votes.comment_id."
                  },
                  {
                    "type": "null",
                    "format": "uuid",
                    "description": "ID of the comment to be voted on. Set this or post_id, but not both. Only one target can be set. From votes.comment_id."
                  }
                ],
                "description": "ID of the comment to be voted on. Set this or post_id, but not both. Only one target can be set. From votes.comment_id."
              },
              "value": {
                "oneOf": [
                  {
                    "const": -1,
                    "description": "Required. Vote value: +1 (upvote) or -1 (downvote). Enforced by schema and business rules."
                  },
                  {
                    "const": 1,
                    "description": "Required. Vote value: +1 (upvote) or -1 (downvote). Enforced by schema and business rules."
                  }
                ],
                "description": "Required. Vote value: +1 (upvote) or -1 (downvote). Enforced by schema and business rules."
              }
            },
            "required": [
              "value"
            ],
            "description": "Object for creating a vote on a post or comment.\n\nSpecifies the target entity (post_id or comment_id) and the value (+1/-1). Enforces one-vote-per-target-per-user as described in requirements and Prisma schema."
          },
          "IBbsVote.IUpdate": {
            "type": "object",
            "properties": {
              "value": {
                "oneOf": [
                  {
                    "const": -1,
                    "description": "New vote value: +1 or -1. Only allowed update. Alters the score on the target entity."
                  },
                  {
                    "const": 1,
                    "description": "New vote value: +1 or -1. Only allowed update. Alters the score on the target entity."
                  }
                ],
                "description": "New vote value: +1 or -1. Only allowed update. Alters the score on the target entity."
              }
            },
            "required": [
              "value"
            ],
            "description": "Edit/update payload for an existing vote record.\n\nAllows switching between upvote/downvote. Subject to audit and moderator/admin permission checks."
          }
        }
      }
    },
    "files": {
      ".env.local": "API_PORT=37001",
      ".eslintrc.cjs": "module.exports = {\n  root: true,\n  plugins: [\"@typescript-eslint\", \"deprecation\"],\n  extends: [\"plugin:@typescript-eslint/recommended\"],\n  parser: \"@typescript-eslint/parser\",\n  parserOptions: {\n    project: [\"tsconfig.json\", \"test/tsconfig.json\"],\n  },\n  overrides: [\n    {\n      files: [\"src/**/*.ts\", \"test/**/*.ts\"],\n      rules: {\n        \"@typescript-eslint/consistent-type-definitions\": \"off\",\n        \"@typescript-eslint/no-empty-function\": \"off\",\n        \"@typescript-eslint/no-empty-interface\": \"off\",\n        \"@typescript-eslint/no-explicit-any\": \"off\",\n        \"@typescript-eslint/no-inferrable-types\": \"off\",\n        \"@typescript-eslint/no-namespace\": \"off\",\n        \"@typescript-eslint/no-non-null-assertion\": \"off\",\n        \"@typescript-eslint/no-unused-vars\": \"off\",\n        \"@typescript-eslint/no-var-requires\": \"off\",\n        \"@typescript-eslint/no-floating-promises\": \"error\",\n        \"@typescript-eslint/no-require-imports\": \"off\",\n        \"@typescript-eslint/no-empty-object-type\": \"off\",\n      },\n    },\n  ],\n};\n",
      ".github/workflows/build.yml": "name: build\non:\n  pull_request:\n    paths:\n      - 'src/**'\n      - 'test/**'\n      - 'package.json'\njobs:\n  Ubuntu:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n        with:\n          node-version: 20.x\n      - uses: pnpm/action-setup@v4\n        with:\n          version: 8\n      \n      - name: Install Backend-Server\n        run: pnpm install\n\n      - name: Build Swagger\n        run: npm run build:swagger\n\n      - name: Build SDK\n        run: npm run build:sdk\n\n      - name: Compile Backend-Server\n        run: npm run build\n\n      - name: Run Test Program\n        run: npm run test -- --simultaneous 16\n\n      - name: EsLint\n        run: npm run eslint\n",
      ".github/workflows/typos.yml": "name: typos\non:\n  pull_request:\n\njobs:\n  typos:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout Actions Repository\n        uses: actions/checkout@v4\n\n      - uses: crate-ci/typos@master\n        with:\n          config: ./typos.toml\n",
      ".gitignore": ".git/\nbin/\ndist/\nlib/\nnode_modules/\npackages/api/lib/\n\n.env\npackage-lock.json\npnpm-lock.yaml",
      ".prettierignore": "dist\nbin\nnode_modules\npackages\nsrc/api/functional\nsrc/api/utils/NestiaSimulator.ts\nREADME.md\ntsconfig.json",
      ".vscode/launch.json": "{\n  // Use IntelliSense to learn about possible Node.js debug attributes.\n  // Hover to view descriptions of existing attributes.\n  // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387\n  \"version\": \"0.2.0\",\n  \"configurations\": [\n  {\n    \"type\": \"node\",\n    \"request\": \"launch\",\n    \"name\": \"Backend Test\",\n    \"program\": \"${workspaceRoot}/test/index.ts\",\n    \"cwd\": \"${workspaceRoot}\",\n    \"args\": [\n      // //----\n      // // Not possible to reset DB in debugging mode\n      // //\n      // // Therefore, if you need DB reset, then do it \n      // // through `npm run reset-for-debugging` command\n      // //----\n      // \"--reset\", \"false\",\n      // \"--mode\", \"local\",\n      \n      //----\n      // You can run specific test functions\n      //\n      // If you want to include or exclude multiple words,\n      // then separate them with space character\n      //----\n      // \"--include\", \"some-words-to-include\",\n      // \"--exclude\", \"some-word another-word\",\n  ],\n    \"outFiles\": [\"${workspaceRoot}/bin/**/*.js\"],\n  }\n]\n}",
      ".vscode/settings.json": "{\n  \"editor.tabSize\": 2,\n  \"editor.formatOnSave\": true,\n  \"[javascript][typescript]\": {\n    \"editor.defaultFormatter\": \"esbenp.prettier-vscode\",\n    \"editor.codeActionsOnSave\": {\n      \"source.fixAll.eslint\": \"explicit\"\n    },\n  }\n}",
      "LICENSE": "MIT License\n\nCopyright (c) 2022 Jeongho Nam\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n",
      "README.md": "# Nestia Template\n## Outline\n[![Build Status](https://github.com/samchon/nestia-start/workflows/build/badge.svg)](https://github.com/samchon/nestia-start/actions?query=workflow%3Abuild)\n\nA template repository for backend projects using [nestia](https://github.com/samchon/nestia).\n\nYou can create a new project from this boilerplate by running below command:\n\n```bash\nnpx nestia start <directory>\n```\n\nFor reference, this is a minimal boilerplate project concentrating only on [nestia](https://github.com/samchon/nestia) SDK generation. \n\nIf you wanna much detailed boilerplate project, visit [`@samchon/backend`](https://github.com/samchon/backend).\n\n\n\n\n## Directories and Files\nThis template project has categorized directories like below.\n\nAs you can see from the below, all of the Backend source files are placed into the [src](src/) directory. When you build the TypeScript source files, compiled files would be placed into the `lib` directory following the [tsconfig.json](tsconfig.json) configuration. Otherwise you build client [SDK](#32-sdk) library for npm publishing and their compiled files would be placed into the [packages](packages) directory.\n\n  - [packages/api/](packages/api): SDK module built by `npm run build:api`\n  - [src/](src): Backend source directory\n    - [src/api/](src/api/): Client SDK that would be published to the `@ORGANIZATION/PROJECT-api`\n      - [**src/api/functional/**](src/api/functional/): API functions generated by the [`nestia`](https://github.com/samchon/nestia)\n      - [**src/api/structures/**](src/api/structures/): DTO structures\n    - [src/controllers/](src/controllers/): Controller classes of the Main Program\n  - [**test/**](test): Test Automation Program\n  - [nestia.config.ts](nestia.config.ts): Configuration file of [`nestia`](https://github.com/samchon/nestia)\n  - [package.json](package.json): NPM configuration\n  - [tsconfig.json](tsconfig.json): TypeScript configuration for the main program\n\n\n\n\n## NPM Run Commands\nList of the run commands defined in the [package.json](package.json) are like below:\n\n  - Test\n    - **`test`**: Run test automation program\n    - `benchmark`: Run performance benchmark program\n  - Build\n    - `build`: Build everything\n    - `build:main`: Build main program (`src` directory)\n    - `build:test` Build test automation program (`test` directory)\n    - `build:sdk`: Build SDK into main program only\n    - `build:swagger`: Build Swagger Documents\n    - **`dev`**: Incremental build for development (test program)\n  - Deploy\n    - `package:api`: Build and deploy the SDK library to the NPM\n    - `start`: Start the backend server\n    - `start:dev`: Start the backend server with incremental build and reload\n  - Webpack\n    - `webpack`: Run webpack bundler\n    - `webpack:start`: Start the backend server built by webpack\n    - `webpack:test`: Run test program to the webpack built\n\n\n\n\n## Specialization\nTransform this template project to be yours.\n\nWhen you've created a new backend project through this template project, you can specialize it to be suitable for you by changing some words. Replace below words through IDE specific function like `Edit > Replace in Files` (*Ctrl + Shift + H*), who've been supported by the VSCode.\n\n| Before          | After\n|-----------------|----------------------------------------\n| ORGANIZATION | Your account or corporation name\n| PROJECT      | Your own project name\n| AUTHOR       | Author name\n| https://github.com/samchon/nestia-start | Your repository URL\n\n\n\n\n## Test Driven Development\nWith [nestia](https://github.com/samchon/nestia) helps to accomplish TDD (Test Driven Development). \n\nJust define DTOs and API controllers' methods (only declarations) first. After the definitions, and build SDK (Software Development Kit) through [nestia](https://github.com/samchon/nestia) (`npm run build:sdk`). After buildling those SDK, develop test automation program using the SDK, following use-case scenarios in the framework of client side.\n\nDuring the test automation program development, you can find that which API is miss-designed or which requirement analysis is not exact. Development of the main program must be the last step after such validation process during TDD.\n\n> Visit the [samchon/backend](https://github.com/samchon/backend), then you may find much detailed story about this TDD.\n>\n> 1. Definitions\n> 2. SDK\n> 3. Test Automation Program\n> 4. Main Program\n\n```typescript\nimport {\n  ArrayUtil,\n  GaffComparator,\n  RandomGenerator,\n  TestValidator,\n} from \"@nestia/e2e\";\n\nimport api from \"@ORGANIZATION/PROJECT-api/lib/index\";\nimport { IBbsArticle } from \"@ORGANIZATION/PROJECT-api/lib/structures/bbs/IBbsArticle\";\nimport { IPage } from \"@ORGANIZATION/PROJECT-api/lib/structures/common/IPage\";\n\nexport async function test_api_bbs_article_index_sort(\n  connection: api.IConnection,\n): Promise<void> {\n  // GENERATE 100 ARTICLES\n  const section: string = \"general\";\n  await ArrayUtil.asyncRepeat(100)(() =>\n    api.functional.bbs.articles.create(connection, section, {\n      writer: RandomGenerator.name(),\n      title: RandomGenerator.paragraph(5)(),\n      body: RandomGenerator.content(8)()(),\n      format: \"txt\",\n      files: [],\n      password: RandomGenerator.alphabets(8),\n    }),\n  );\n\n  // PREPARE VALIDATOR\n  const validator = TestValidator.sort(\"BbsArticleProvider.index()\")(async (\n    sort: IPage.Sort<IBbsArticle.IRequest.SortableColumns>,\n  ) => {\n    const page: IPage<IBbsArticle.ISummary> =\n      await api.functional.bbs.articles.index(connection, section, {\n        limit: 100,\n        sort,\n      });\n    return page.data;\n  });\n\n  // DO VALIDATE\n  const components = [\n    validator(\"created_at\")(GaffComparator.dates((x) => x.created_at)),\n    validator(\"updated_at\")(GaffComparator.dates((x) => x.updated_at)),\n    validator(\"title\")(GaffComparator.strings((x) => x.title)),\n    validator(\"writer\")(GaffComparator.strings((x) => x.writer)),\n    validator(\n      \"writer\",\n      \"title\",\n    )(GaffComparator.strings((x) => [x.writer, x.title])),\n  ];\n  for (const comp of components) {\n    await comp(\"+\", false);\n    await comp(\"-\", false);\n  }\n}\n```\n\nFor reference, if you run `npm run benchmark` command, your test functions defined in the [test/features/api](test/features/api) directory would be utilized for performance benchmarking. If you want to see the performance bench result earlier, visit below link please:\n\n  - [docs/benchmarks/AMD Ryzen 9 7940HS w Radeon 780M Graphics.md](https://github.com/samchon/nestia-start/blob/master/docs/benchmarks/AMD%20Ryzen%209%207940HS%20w%20Radeon%20780M%20Graphics.md)",
      "build/env.ts": "import fs from \"fs\";\n\nif (fs.existsSync(`${__dirname}/../.env`) === false)\n  fs.copyFileSync(`${__dirname}/../.env.local`, `${__dirname}/../.env`);\n",
      "docs/benchmarks/AMD Ryzen 9 7940HS w Radeon 780M Graphics.md": "# Benchmark Report\n> Generated by [`@nestia/benchmark`](https://github.com/samchon/nestia)\n\n  - Specifications\n    - CPU: AMD Ryzen 9 7940HS w/ Radeon 780M Graphics     \n    - RAM: 31 GB\n    - NodeJS Version: v20.10.0\n    - Backend Server: 1 core / 1 thread\n  - Arguments\n    - Count: 40,000\n    - Threads: 4\n    - Simultaneous: 32\n  - Time\n    - Start: 2024-10-29T19:14:35.941Z\n    - Complete: 2024-10-29T19:16:11.418Z\n    - Elapsed: 95,477 ms\n\nType | Count | Success | Mean. | Stdev. | Minimum | Maximum\n----|----|----|----|----|----|----\nTotal | 41,586 | 41,586 | 69.24 | 73.05 | 5 | 546\n\n> Unit: milliseconds\n\n## Memory Consumptions\n```mermaid\nxychart-beta\n  x-axis \"Time (second)\"\n  y-axis \"Memory (MB)\"\n  line \"Resident Set Size\" [122, 156, 159, 142, 154, 165, 184, 185, 187, 189, 200, 205, 209, 217, 221, 225, 229, 224, 230, 235, 242, 250, 256, 262, 267, 272, 234, 237, 249, 259, 266, 273, 285, 292, 291, 216, 225, 235, 243, 200, 208, 214, 186, 186, 171, 177, 187, 199, 185, 192, 205, 171, 180, 158, 170, 179, 163, 163, 176, 188, 193, 202, 213, 219, 230, 239, 256, 265, 283, 301, 240, 249, 257, 267, 284, 282, 290, 202, 213, 166, 178, 188, 200, 203, 208, 180, 191, 199, 175]\n  line \"Heap Total\" [85, 116, 120, 103, 114, 124, 146, 146, 147, 148, 158, 166, 170, 176, 180, 184, 187, 185, 190, 195, 203, 211, 217, 222, 225, 229, 194, 197, 209, 218, 225, 232, 241, 249, 247, 176, 185, 194, 202, 160, 168, 173, 146, 146, 130, 136, 146, 158, 145, 151, 165, 129, 139, 116, 128, 137, 120, 123, 136, 148, 152, 161, 172, 179, 189, 198, 215, 223, 241, 257, 200, 209, 216, 227, 244, 242, 249, 163, 174, 127, 136, 147, 159, 162, 166, 138, 150, 158, 132]\n  line \"Heap Used + External\" [69, 94, 62, 82, 88, 107, 71, 83, 93, 107, 136, 72, 76, 85, 92, 106, 139, 48, 68, 69, 86, 95, 108, 116, 140, 175, 67, 74, 88, 112, 125, 136, 142, 169, 180, 91, 104, 105, 121, 60, 71, 91, 64, 74, 86, 110, 121, 135, 76, 82, 103, 70, 93, 66, 91, 107, 76, 75, 95, 101, 115, 127, 136, 154, 165, 168, 196, 193, 214, 232, 84, 94, 101, 118, 145, 147, 149, 86, 96, 72, 90, 112, 126, 133, 132, 78, 87, 107, 88]\n  line \"Heap Used Only\" [66, 89, 59, 78, 83, 100, 68, 79, 88, 101, 129, 68, 72, 80, 86, 100, 131, 45, 64, 65, 81, 90, 103, 110, 133, 168, 64, 71, 84, 108, 120, 130, 136, 162, 173, 88, 100, 101, 117, 58, 68, 87, 61, 71, 83, 107, 118, 130, 73, 79, 99, 67, 89, 63, 88, 103, 74, 72, 91, 98, 111, 123, 132, 149, 160, 163, 190, 187, 208, 225, 81, 90, 97, 114, 140, 143, 145, 83, 93, 70, 87, 108, 122, 130, 128, 76, 84, 104, 85]\n```\n\n> - 🟦 Resident Set Size\n> - 🟢 Heap Total\n> - 🔴 Heap Used + External\n> - 🟡 Heap Used Only\n\n## Endpoints\nType | Count | Success | Mean. | Stdev. | Minimum | Maximum\n----|----|----|----|----|----|----\nPATCH /bbs/articles/:section | 6,439 | 6,439 | 108.37 | 76.56 | 6 | 546\nPUT /bbs/articles/:section/:id | 380 | 380 | 78.52 | 69.03 | 6 | 296\nGET /bbs/articles/:section/:id | 917 | 917 | 77.65 | 69.84 | 6 | 463\nDELETE /bbs/articles/:section/:id | 201 | 201 | 73.89 | 63.55 | 7 | 307\nPOST /bbs/articles/:section | 33,649 | 33,649 | 61.39 | 70.04 | 5 | 546\n\n> Unit: milliseconds\n\n## Failures\nMethod | Path | Count | Failures\n-------|------|-------|----------",
      "nest-cli.json": "{\n  \"$schema\": \"https://json.schemastore.org/nest-cli\",\n  \"collection\": \"@nestjs/schematics\",\n  \"sourceRoot\": \"src\",\n  \"entryFile\": \"executable/server\",\n  \"compilerOptions\": {\n    \"deleteOutDir\": true\n  }\n}\n",
      "nestia.config.ts": "// nestia configuration file\nimport type sdk from \"@nestia/sdk\";\nimport { NestFactory } from \"@nestjs/core\";\n\nimport { MyModule } from \"./src/MyModule\";\n\nconst NESTIA_CONFIG: sdk.INestiaConfig = {\n  input: () => NestFactory.create(MyModule),\n  output: \"src/api\",\n  swagger: {\n    output: \"packages/api/swagger.json\",\n    servers: [\n      {\n        url: \"http://localhost:37001\",\n        description: \"Local Server\",\n      },\n    ],\n    beautify: true,\n  },\n  distribute: \"packages/api\",\n  primitive: false,\n  simulate: true,\n};\nexport default NESTIA_CONFIG;\n",
      "package.json": "{\n  \"private\": true,\n  \"name\": \"@ORGANIZATION/PROJECT\",\n  \"version\": \"0.1.0\",\n  \"description\": \"Starter kit of Nestia\",\n  \"main\": \"lib/index.js\",\n  \"scripts\": {\n    \"benchmark\": \"node bin/test/benchmark\",\n    \"test\": \"node bin/test\",\n    \"test:webpack\": \"npm run webpack && node bin/test/webpack.js\",\n    \"------------------------BUILDS------------------------\": \"\",\n    \"build\": \"npm run build:sdk && npm run build:main && npm run build:test\",\n    \"build:api\": \"rimraf packages/api/lib && nestia all && rimraf packages/api/lib && tsc -p packages/api/tsconfig.json && rollup -c packages/api/rollup.config.js\",\n    \"build:main\": \"rimraf lib && tsc\",\n    \"build:sdk\": \"rimraf src/api/functional && nestia sdk\",\n    \"build:swagger\": \"npx nestia swagger\",\n    \"build:test\": \"rimraf bin && tsc -p test/tsconfig.json\",\n    \"dev\": \"npm run build:test -- --watch\",\n    \"eslint\": \"eslint src && eslint test\",\n    \"eslint:fix\": \"eslint --fix src && eslint --fix test\",\n    \"prepare\": \"ts-patch install && ts-node build/env.ts\",\n    \"prettier\": \"prettier src --write && prettier test --write\",\n    \"------------------------WEBPACK------------------------\": \"\",\n    \"webpack\": \"rimraf dist && webpack\",\n    \"webpack:start\": \"cd dist && node dist/server\",\n    \"webpack:test\": \"npm run webpack && node bin/test/webpack.js\",\n    \"------------------------DEPLOYS------------------------\": \"\",\n    \"package:api\": \"npm run build:api && cd packages/api && npm publish\",\n    \"start\": \"node lib/executable/server\",\n    \"start:dev\": \"nest start --watch\",\n    \"start:swagger\": \"ts-node src/executable/swagger.ts\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/samchon/nestia-start\"\n  },\n  \"keywords\": [\n    \"nestia\",\n    \"template\",\n    \"boilerplate\"\n  ],\n  \"author\": \"AUTHOR\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/samchon/nestia-start/issues\"\n  },\n  \"homepage\": \"https://github.com/samchon/nestia-start#readme\",\n  \"devDependencies\": {\n    \"@nestia/benchmark\": \"^6.0.6\",\n    \"@nestia/e2e\": \"^6.0.6\",\n    \"@nestia/sdk\": \"^7.0.0\",\n    \"@nestjs/cli\": \"^11.0.7\",\n    \"@rollup/plugin-terser\": \"^0.4.4\",\n    \"@rollup/plugin-typescript\": \"^11.1.6\",\n    \"@trivago/prettier-plugin-sort-imports\": \"^4.3.0\",\n    \"@types/cli\": \"^0.11.21\",\n    \"@types/cli-progress\": \"^3.11.5\",\n    \"@types/express\": \"^4.17.21\",\n    \"@types/inquirer\": \"^8.2.5\",\n    \"@types/node\": \"^18.11.0\",\n    \"@types/uuid\": \"^8.3.4\",\n    \"@typescript-eslint/eslint-plugin\": \"^8.1.0\",\n    \"@typescript-eslint/parser\": \"^8.1.0\",\n    \"chalk\": \"^4.1.2\",\n    \"cli\": \"^1.0.1\",\n    \"cli-progress\": \"^3.12.0\",\n    \"copy-webpack-plugin\": \"^11.0.0\",\n    \"eslint-plugin-deprecation\": \"^3.0.0\",\n    \"express\": \"^4.18.2\",\n    \"nestia\": \"^7.0.0\",\n    \"prettier\": \"^3.2.4\",\n    \"prettier-plugin-prisma\": \"^5.0.0\",\n    \"rimraf\": \"^3.0.2\",\n    \"rollup\": \"^4.18.0\",\n    \"source-map-support\": \"^0.5.21\",\n    \"swagger-ui-express\": \"^5.0.0\",\n    \"ts-loader\": \"^9.5.1\",\n    \"ts-node\": \"^10.9.1\",\n    \"ts-patch\": \"^3.3.0\",\n    \"typescript\": \"~5.8.3\",\n    \"typescript-transform-paths\": \"^3.5.5\",\n    \"webpack\": \"^5.89.0\",\n    \"webpack-cli\": \"^5.1.4\",\n    \"write-file-webpack-plugin\": \"^4.5.1\"\n  },\n  \"dependencies\": {\n    \"@nestia/core\": \"^7.0.0\",\n    \"@nestia/fetcher\": \"^7.0.0\",\n    \"@nestjs/common\": \"^11.1.3\",\n    \"@nestjs/core\": \"^11.1.3\",\n    \"@nestjs/platform-express\": \"^11.1.3\",\n    \"@prisma/client\": \"^6.11.1\",\n    \"commander\": \"10.0.0\",\n    \"dotenv\": \"^16.3.1\",\n    \"dotenv-expand\": \"^10.0.0\",\n    \"inquirer\": \"8.2.5\",\n    \"prisma\": \"^6.11.1\",\n    \"serialize-error\": \"^4.1.0\",\n    \"tgrid\": \"^1.1.0\",\n    \"tstl\": \"^3.0.0\",\n    \"typia\": \"^9.3.1\",\n    \"uuid\": \"^9.0.0\"\n  },\n  \"stackblitz\": {\n    \"startCommand\": \"npm run prepare && npm run build:test && npm run test -- --simultaneous 1\"\n  }\n}\n",
      "packages/api/.gitignore": "lib/\nnode_modules/\n\nswagger.json\nopenai.json",
      "packages/api/LICENSE": "MIT License\n\nCopyright (c) 2021 ORGANIZATION\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.",
      "packages/api/README.md": "# SDK Library\nThis is a SDK library generated by [`nestia`](https://nestia.io).\n\nWith this SDK library, you can easily and safely interact with backend server.\n\nJust import and call some API functions like gif image below:\n\n![nestia-sdk-demo](https://user-images.githubusercontent.com/13158709/215004990-368c589d-7101-404e-b81b-fbc936382f05.gif)\n\n> Left is server code, and right is client code utilizing the SDK\n\n\n\n\n# What [`Nestia`](https://nestia.io) is:\n![Nestia Logo](https://nestia.io/logo.png)\n\n[![GitHub license](https://img.shields.io/badge/license-MIT-blue.svg)](https://github.com/samchon/nestia/blob/master/LICENSE)\n[![npm version](https://img.shields.io/npm/v/@nestia/core.svg)](https://www.npmjs.com/package/@nestia/core)\n[![Downloads](https://img.shields.io/npm/dm/@nestia/core.svg)](https://www.npmjs.com/package/@nestia/core)\n[![Build Status](https://github.com/samchon/nestia/workflows/build/badge.svg)](https://github.com/samchon/nestia/actions?query=workflow%3Abuild)\n[![Guide Documents](https://img.shields.io/badge/guide-documents-forestgreen)](https://nestia.io/docs/)\n\nNestia is a set of helper libraries for NestJS, supporting below features:\n\n  - `@nestia/core`: super-fast decorators\n  - `@nestia/sdk`:\n    - Swagger generator evolved than ever\n    - SDK library generator for clients\n    - Mockup Simulator for client applications\n    - Automatic E2E test functions generator\n  - `@nestia/migrate`: migration from Swagger to NestJS\n  - `nestia`: just CLI (command line interface) tool\n\n> **Note**\n> \n> - **Only one line** required, with pure TypeScript type\n> - Enhance performance **30x** up\n>   - Runtime validator is **20,000x faster** than `class-validator`\n>   - JSON serialization is **200x faster** than `class-transformer`\n> - Software Development Kit\n>   - SDK is a collection of `fetch` functions with type definitions like [tRPC](https://trpc.io/)\n>   - Mockup simulator means embedded backend simulator in SDK\n>     - similar with [msw](https://mswjs.io/), but fully automated",
      "packages/api/package.json": "{\n  \"name\": \"@ORGANIZATION/PROJECT-api\",\n  \"version\": \"0.1.0\",\n  \"description\": \"SDK library generated by Nestia\",\n  \"main\": \"lib/index.js\",\n  \"module\": \"lib/index.mjs\",\n  \"typings\": \"lib/index.d.ts\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/samchon/nestia\"\n  },\n  \"author\": \"Jeongho Nam\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/samchon/nestia/issues\"\n  },\n  \"homepage\": \"https://nestia.io\",\n  \"files\": [\n    \"lib\",\n    \"package.json\",\n    \"swagger.json\",\n    \"openai.json\",\n    \"README.md\"\n  ],\n  \"dependencies\": {\n    \"@nestia/fetcher\": \"^7.0.0\",\n    \"tgrid\": \"^1.1.0\",\n    \"typia\": \"^9.3.1\"\n  }\n}",
      "packages/api/rollup.config.js": "const typescript = require(\"@rollup/plugin-typescript\");\nconst terser = require(\"@rollup/plugin-terser\");\n\nmodule.exports = {\n  input: `${__dirname}/../../src/api/index.ts`,\n  output: {\n    dir: `${__dirname}/lib`,\n    format: \"esm\",\n    entryFileNames: \"[name].mjs\",\n    sourcemap: true,\n  },\n  plugins: [\n    typescript({\n      tsconfig: `${__dirname}/tsconfig.json`,\n      module: \"ESNext\",\n      target: \"ESNext\",\n    }),\n    terser({\n      format: {\n        comments: \"some\",\n        beautify: true,\n        ecma: \"2020\",\n      },\n      compress: false,\n      mangle: false,\n      module: true,\n    }),\n  ],\n};\n",
      "packages/api/tsconfig.json": "{\n  \"compilerOptions\": {\n    /* Visit https://aka.ms/tsconfig to read more about this file */\n    /* Projects */\n    // \"incremental\": true,                              /* Save .tsbuildinfo files to allow for incremental compilation of projects. */\n    // \"composite\": true,                                /* Enable constraints that allow a TypeScript project to be used with project references. */\n    // \"tsBuildInfoFile\": \"./.tsbuildinfo\",              /* Specify the path to .tsbuildinfo incremental compilation file. */\n    // \"disableSourceOfProjectReferenceRedirect\": true,  /* Disable preferring source files instead of declaration files when referencing composite projects. */\n    // \"disableSolutionSearching\": true,                 /* Opt a project out of multi-project reference checking when editing. */\n    // \"disableReferencedProjectLoad\": true,             /* Reduce the number of projects loaded automatically by TypeScript. */\n    /* Language and Environment */\n    \"target\": \"ES5\", /* Set the JavaScript language version for emitted JavaScript and include compatible library declarations. */\n    \"lib\": [\n      \"DOM\",\n      \"ES2015\"\n    ], /* Specify a set of bundled library declaration files that describe the target runtime environment. */// \"jsx\": \"preserve\",                                /* Specify what JSX code is generated. */\n    // \"experimentalDecorators\": true,                   /* Enable experimental support for TC39 stage 2 draft decorators. */\n    // \"emitDecoratorMetadata\": true,                    /* Emit design-type metadata for decorated declarations in source files. */\n    // \"jsxFactory\": \"\",                                 /* Specify the JSX factory function used when targeting React JSX emit, e.g. 'React.createElement' or 'h'. */\n    // \"jsxFragmentFactory\": \"\",                         /* Specify the JSX Fragment reference used for fragments when targeting React JSX emit e.g. 'React.Fragment' or 'Fragment'. */\n    // \"jsxImportSource\": \"\",                            /* Specify module specifier used to import the JSX factory functions when using 'jsx: react-jsx*'. */\n    // \"reactNamespace\": \"\",                             /* Specify the object invoked for 'createElement'. This only applies when targeting 'react' JSX emit. */\n    // \"noLib\": true,                                    /* Disable including any library files, including the default lib.d.ts. */\n    // \"useDefineForClassFields\": true,                  /* Emit ECMAScript-standard-compliant class fields. */\n    // \"moduleDetection\": \"auto\",                        /* Control what method is used to detect module-format JS files. */\n    /* Modules */\n    \"module\": \"commonjs\", /* Specify what module code is generated. */// \"rootDir\": \"./\",                                  /* Specify the root folder within your source files. */\n    // \"moduleResolution\": \"node\",                       /* Specify how TypeScript looks up a file from a given module specifier. */\n    // \"baseUrl\": \"./\",                                  /* Specify the base directory to resolve non-relative module names. */\n    // \"paths\": {},                                      /* Specify a set of entries that re-map imports to additional lookup locations. */\n    // \"rootDirs\": [],                                   /* Allow multiple folders to be treated as one when resolving modules. */\n    // \"typeRoots\": [],                                  /* Specify multiple folders that act like './node_modules/@types'. */\n    // \"types\": [],                                      /* Specify type package names to be included without being referenced in a source file. */\n    // \"allowUmdGlobalAccess\": true,                     /* Allow accessing UMD globals from modules. */\n    // \"moduleSuffixes\": [],                             /* List of file name suffixes to search when resolving a module. */\n    // \"resolveJsonModule\": true,                        /* Enable importing .json files. */\n    // \"noResolve\": true,                                /* Disallow 'import's, 'require's or '<reference>'s from expanding the number of files TypeScript should add to a project. */\n    /* JavaScript Support */\n    // \"allowJs\": true,                                  /* Allow JavaScript files to be a part of your program. Use the 'checkJS' option to get errors from these files. */\n    // \"checkJs\": true,                                  /* Enable error reporting in type-checked JavaScript files. */\n    // \"maxNodeModuleJsDepth\": 1,                        /* Specify the maximum folder depth used for checking JavaScript files from 'node_modules'. Only applicable with 'allowJs'. */\n    /* Emit */\n    \"declaration\": true, /* Generate .d.ts files from TypeScript and JavaScript files in your project. */// \"declarationMap\": true,                           /* Create sourcemaps for d.ts files. */\n    // \"emitDeclarationOnly\": true,                      /* Only output d.ts files and not JavaScript files. */\n    \"sourceMap\": true, /* Create source map files for emitted JavaScript files. */// \"outFile\": \"./\",                                  /* Specify a file that bundles all outputs into one JavaScript file. If 'declaration' is true, also designates a file that bundles all .d.ts output. */\n    \"outDir\": \"./lib\", /* Specify an output folder for all emitted files. */// \"removeComments\": true,                           /* Disable emitting comments. */\n    // \"noEmit\": true,                                   /* Disable emitting files from a compilation. */\n    // \"importHelpers\": true,                            /* Allow importing helper functions from tslib once per project, instead of including them per-file. */\n    // \"importsNotUsedAsValues\": \"remove\",               /* Specify emit/checking behavior for imports that are only used for types. */\n    \"downlevelIteration\": true, /* Emit more compliant, but verbose and less performant JavaScript for iteration. */// \"sourceRoot\": \"\",                                 /* Specify the root path for debuggers to find the reference source code. */\n    // \"mapRoot\": \"\",                                    /* Specify the location where debugger should locate map files instead of generated locations. */\n    // \"inlineSourceMap\": true,                          /* Include sourcemap files inside the emitted JavaScript. */\n    // \"inlineSources\": true,                            /* Include source code in the sourcemaps inside the emitted JavaScript. */\n    // \"emitBOM\": true,                                  /* Emit a UTF-8 Byte Order Mark (BOM) in the beginning of output files. */\n    \"newLine\": \"lf\", /* Set the newline character for emitting files. */// \"stripInternal\": true,                            /* Disable emitting declarations that have '@internal' in their JSDoc comments. */\n    // \"noEmitHelpers\": true,                            /* Disable generating custom helper functions like '__extends' in compiled output. */\n    // \"noEmitOnError\": true,                            /* Disable emitting files if any type checking errors are reported. */\n    // \"preserveConstEnums\": true,                       /* Disable erasing 'const enum' declarations in generated code. */\n    // \"declarationDir\": \"./\",                           /* Specify the output directory for generated declaration files. */\n    // \"preserveValueImports\": true,                     /* Preserve unused imported values in the JavaScript output that would otherwise be removed. */\n    /* Interop Constraints */\n    // \"isolatedModules\": true,                          /* Ensure that each file can be safely transpiled without relying on other imports. */\n    // \"allowSyntheticDefaultImports\": true,             /* Allow 'import x from y' when a module doesn't have a default export. */\n    \"esModuleInterop\": true, /* Emit additional JavaScript to ease support for importing CommonJS modules. This enables 'allowSyntheticDefaultImports' for type compatibility. */// \"preserveSymlinks\": true,                         /* Disable resolving symlinks to their realpath. This correlates to the same flag in node. */\n    \"forceConsistentCasingInFileNames\": true, /* Ensure that casing is correct in imports. *//* Type Checking */\n    \"strict\": true, /* Enable all strict type-checking options. */// \"noImplicitAny\": true,                            /* Enable error reporting for expressions and declarations with an implied 'any' type. */\n    // \"strictNullChecks\": true,                         /* When type checking, take into account 'null' and 'undefined'. */\n    // \"strictFunctionTypes\": true,                      /* When assigning functions, check to ensure parameters and the return values are subtype-compatible. */\n    // \"strictBindCallApply\": true,                      /* Check that the arguments for 'bind', 'call', and 'apply' methods match the original function. */\n    // \"strictPropertyInitialization\": true,             /* Check for class properties that are declared but not set in the constructor. */\n    // \"noImplicitThis\": true,                           /* Enable error reporting when 'this' is given the type 'any'. */\n    // \"useUnknownInCatchVariables\": true,               /* Default catch clause variables as 'unknown' instead of 'any'. */\n    // \"alwaysStrict\": true,                             /* Ensure 'use strict' is always emitted. */\n    // \"noUnusedLocals\": true,                           /* Enable error reporting when local variables aren't read. */\n    // \"noUnusedParameters\": true,                       /* Raise an error when a function parameter isn't read. */\n    // \"exactOptionalPropertyTypes\": true,               /* Interpret optional property types as written, rather than adding 'undefined'. */\n    // \"noImplicitReturns\": true,                        /* Enable error reporting for codepaths that do not explicitly return in a function. */\n    // \"noFallthroughCasesInSwitch\": true,               /* Enable error reporting for fallthrough cases in switch statements. */\n    // \"noUncheckedIndexedAccess\": true,                 /* Add 'undefined' to a type when accessed using an index. */\n    // \"noImplicitOverride\": true,                       /* Ensure overriding members in derived classes are marked with an override modifier. */\n    // \"noPropertyAccessFromIndexSignature\": true,       /* Enforces using indexed accessors for keys declared using an indexed type. */\n    // \"allowUnusedLabels\": true,                        /* Disable error reporting for unused labels. */\n    // \"allowUnreachableCode\": true,                     /* Disable error reporting for unreachable code. */\n    /* Completeness */\n    // \"skipDefaultLibCheck\": true,                      /* Skip type checking .d.ts files that are included with TypeScript. */\n    \"skipLibCheck\": true, /* Skip type checking all .d.ts files. */\n    \"plugins\": [\n      {\n        \"transform\": \"typia/lib/transform\"\n      }\n    ],\n    \"strictNullChecks\": true\n  },\n  \"include\": [\n    \"../../src/api\"\n  ]\n}",
      "prettier.config.js": "module.exports = {\n  // DEFAULT CONFIGURATIONS\n  parser: \"typescript\",\n  printWidth: 80,\n  semi: true,\n  tabWidth: 2,\n  trailingComma: \"all\",\n\n  // PLUG-IN CONFIGURATIONS\n  plugins: [\"@trivago/prettier-plugin-sort-imports\"],\n  importOrder: [\n    \"<THIRD_PARTY_MODULES>\",\n    \"^@ORGANIZATION/PROJECT-api(.*)$\",\n    \"^[./]\",\n  ],\n  importOrderSeparation: true,\n  importOrderSortSpecifiers: true,\n  importOrderParserPlugins: [\"decorators-legacy\", \"typescript\"],\n};\n",
      "src/MyBackend.ts": "import { WebSocketAdaptor } from \"@nestia/core\";\nimport { INestApplication } from \"@nestjs/common\";\nimport { NestFactory } from \"@nestjs/core\";\n\nimport { MyConfiguration } from \"./MyConfiguration\";\nimport { MyModule } from \"./MyModule\";\n\nexport class MyBackend {\n  private application_?: INestApplication;\n\n  public async open(): Promise<void> {\n    //----\n    // OPEN THE BACKEND SERVER\n    //----\n    // MOUNT CONTROLLERS\n    this.application_ = await NestFactory.create(MyModule, { logger: false });\n    await WebSocketAdaptor.upgrade(this.application_);\n\n    // DO OPEN\n    this.application_.enableCors();\n    await this.application_.listen(MyConfiguration.API_PORT(), \"0.0.0.0\");\n\n    //----\n    // POST-PROCESSES\n    //----\n    // INFORM TO THE PM2\n    if (process.send) process.send(\"ready\");\n\n    // WHEN KILL COMMAND COMES\n    process.on(\"SIGINT\", async () => {\n      await this.close();\n      process.exit(0);\n    });\n  }\n\n  public async close(): Promise<void> {\n    if (this.application_ === undefined) return;\n\n    // DO CLOSE\n    await this.application_.close();\n    delete this.application_;\n  }\n}\n",
      "src/MyConfiguration.ts": "import fs from \"fs\";\nimport path from \"path\";\n\nimport { MyGlobal } from \"./MyGlobal\";\n\nexport namespace MyConfiguration {\n  export const API_PORT = () => Number(MyGlobal.env.API_PORT);\n\n  export const ROOT = (() => {\n    const split: string[] = __dirname.split(path.sep);\n    return split.at(-1) === \"src\" && split.at(-2) === \"bin\"\n      ? path.resolve(__dirname + \"/../..\")\n      : fs.existsSync(__dirname + \"/.env\")\n        ? __dirname\n        : path.resolve(__dirname + \"/..\");\n  })();\n}\n",
      "src/MyGlobal.ts": "import { PrismaClient } from \"@prisma/client\";\nimport dotenv from \"dotenv\";\nimport dotenvExpand from \"dotenv-expand\";\nimport { Singleton } from \"tstl\";\nimport typia from \"typia\";\n\n/* eslint-disable */\nexport class MyGlobal {\n  public static readonly prisma: PrismaClient = new PrismaClient();\n  public static testing: boolean = false;\n  public static get env(): MyGlobal.IEnvironments {\n    return environments.get();\n  }\n}\nexport namespace MyGlobal {\n  export interface IEnvironments {\n    API_PORT: `${number}`;\n  }\n}\nconst environments = new Singleton(() => {\n  const env = dotenv.config();\n  dotenvExpand.expand(env);\n  return typia.assert<MyGlobal.IEnvironments>(process.env);\n});\n",
      "src/api/HttpError.ts": "export { HttpError } from \"@nestia/fetcher\";\n",
      "src/api/IConnection.ts": "export type { IConnection } from \"@nestia/fetcher\";\n",
      "src/api/Primitive.ts": "export type { Primitive } from \"typia\";\n",
      "src/api/Resolved.ts": "export type { Resolved } from \"typia\";\n",
      "src/api/index.ts": "import * as api from \"./module\";\n\nexport * from \"./module\";\nexport default api;\n",
      "src/api/module.ts": "export type * from \"./IConnection\";\nexport * from \"./HttpError\";\n\nexport * as functional from \"./functional\";\n",
      "src/executable/server.ts": "import { MyBackend } from \"../MyBackend\";\n\nconst EXTENSION = __filename.substring(__filename.length - 2);\nif (EXTENSION === \"js\") require(\"source-map-support/register\");\n\nasync function main(): Promise<void> {\n  // BACKEND SEVER\n  const backend: MyBackend = new MyBackend();\n  await backend.open();\n\n  // UNEXPECTED ERRORS\n  global.process.on(\"uncaughtException\", console.error);\n  global.process.on(\"unhandledRejection\", console.error);\n}\nmain().catch((exp) => {\n  console.log(exp);\n  process.exit(-1);\n});\n",
      "src/executable/swagger.ts": "import cp from \"child_process\";\nimport express from \"express\";\n\nconst execute = (command: string): void => {\n  console.log(`\\n$ ${command}\\n`);\n  cp.execSync(command, { stdio: \"inherit\" });\n};\n\nconst main = async (): Promise<void> => {\n  if (!process.argv.some((str) => str === \"--skipBuild\"))\n    execute(\"npm run build:swagger\");\n\n  const docs = await import(\"../../packages/api/swagger.json\" as any);\n\n  const app = express();\n  const swaggerUi = require(\"swagger-ui-express\");\n  app.use(\"/api-docs\", swaggerUi.serve, swaggerUi.setup(docs));\n  app.listen(37810);\n\n  console.log(\"\\n\");\n  console.log(\"-----------------------------------------------------------\");\n  console.log(\"\\n Swagger UI Address: http://127.0.0.1:37810/api-docs \\n\");\n  console.log(\"-----------------------------------------------------------\");\n};\nmain().catch((exp) => {\n  console.log(exp);\n  process.exit(-1);\n});\n",
      "src/utils/ErrorUtil.ts": "import serializeError = require(\"serialize-error\");\n\nexport namespace ErrorUtil {\n  export const toJSON = (err: any): object =>\n    err instanceof Object && err.toJSON instanceof Function\n      ? err.toJSON()\n      : serializeError(err);\n}\n",
      "src/utils/MapUtil.ts": "export namespace MapUtil {\n  export function take<Key, T>(\n    dict: Map<Key, T>,\n    key: Key,\n    generator: () => T,\n  ): T {\n    const oldbie: T | undefined = dict.get(key);\n    if (oldbie) return oldbie;\n\n    const value: T = generator();\n    dict.set(key, value);\n    return value;\n  }\n}\n",
      "test/TestAutomation.ts": "import { DynamicExecutor } from \"@nestia/e2e\";\nimport chalk from \"chalk\";\nimport { sleep_for } from \"tstl\";\n\nimport { MyConfiguration } from \"../src/MyConfiguration\";\nimport api from \"../src/api\";\nimport { ArgumentParser } from \"./helpers/ArgumentParser\";\n\nexport namespace TestAutomation {\n  export interface IProps<T> {\n    open(options: IOptions): Promise<T>;\n    close(backend: T): Promise<void>;\n  }\n\n  export interface IOptions {\n    simultaneous: number;\n    include?: string[];\n    exclude?: string[];\n  }\n\n  export const execute = async <T,>(props: IProps<T>): Promise<void> => {\n    // OPEN BACKEND\n    const options: IOptions = await getOptions();\n    const backend: T = await props.open(options);\n\n    // DO TEST\n    const connection: api.IConnection = {\n      host: `http://127.0.0.1:${MyConfiguration.API_PORT()}`,\n    };\n    const report: DynamicExecutor.IReport = await DynamicExecutor.validate({\n      prefix: \"test\",\n      location: __dirname + \"/features\",\n      parameters: () => [\n        {\n          host: connection.host,\n          encryption: connection.encryption,\n        },\n      ],\n      filter: (func) =>\n        (!options.include?.length ||\n          (options.include ?? []).some((str) => func.includes(str))) &&\n        (!options.exclude?.length ||\n          (options.exclude ?? []).every((str) => !func.includes(str))),\n      onComplete: (exec) => {\n        const trace = (str: string) =>\n          console.log(`  - ${chalk.green(exec.name)}: ${str}`);\n        if (exec.error === null) {\n          const elapsed: number =\n            new Date(exec.completed_at).getTime() -\n            new Date(exec.started_at).getTime();\n          trace(`${chalk.yellow(elapsed.toLocaleString())} ms`);\n        } else trace(chalk.red(exec.error.name));\n      },\n      simultaneous: options.simultaneous,\n    });\n\n    // TERMINATE - WAIT FOR BACKGROUND EVENTS\n    await sleep_for(2500);\n    await props.close(backend);\n\n    const failures: DynamicExecutor.IExecution[] = report.executions.filter(\n      (exec) => exec.error !== null,\n    );\n    if (failures.length === 0) {\n      console.log(\"Success\");\n      console.log(\"Elapsed time\", report.time.toLocaleString(), `ms`);\n    } else {\n      for (const f of failures) console.log(f.error);\n      process.exit(-1);\n    }\n\n    console.log(\n      [\n        `All: #${report.executions.length}`,\n        `Success: #${report.executions.length - failures.length}`,\n        `Failed: #${failures.length}`,\n      ].join(\"\\n\"),\n    );\n  };\n}\n\nconst getOptions = () =>\n  ArgumentParser.parse<TestAutomation.IOptions>(\n    async (command, prompt, action) => {\n      command.option(\n        \"--simultaneous <number>\",\n        \"number of simultaneous requests\",\n      );\n      command.option(\"--include <string...>\", \"include feature files\");\n      command.option(\"--exclude <string...>\", \"exclude feature files\");\n\n      return action(async (options) => {\n        options.simultaneous = Number(\n          options.simultaneous ??\n            (await prompt.number(\"simultaneous\")(\n              \"Number of simultaneous requests to make\",\n            )),\n        );\n        if (isNaN(options.simultaneous) || options.simultaneous <= 0)\n          options.simultaneous = 1;\n        return options as TestAutomation.IOptions;\n      });\n    },\n  );\n",
      "test/benchmark/index.ts": "import { DynamicBenchmarker } from \"@nestia/benchmark\";\nimport cliProgress from \"cli-progress\";\nimport fs from \"fs\";\nimport os from \"os\";\nimport { IPointer } from \"tstl\";\n\nimport { MyBackend } from \"../../src/MyBackend\";\nimport { MyConfiguration } from \"../../src/MyConfiguration\";\nimport { MyGlobal } from \"../../src/MyGlobal\";\nimport { ArgumentParser } from \"../helpers/ArgumentParser\";\n\ninterface IOptions {\n  include?: string[];\n  exclude?: string[];\n  count: number;\n  threads: number;\n  simultaneous: number;\n}\n\nconst getOptions = () =>\n  ArgumentParser.parse<IOptions>(async (command, prompt, action) => {\n    // command.option(\"--mode <string>\", \"target mode\");\n    // command.option(\"--reset <true|false>\", \"reset local DB or not\");\n    command.option(\"--include <string...>\", \"include feature files\");\n    command.option(\"--exclude <string...>\", \"exclude feature files\");\n    command.option(\"--count <number>\", \"number of requests to make\");\n    command.option(\"--threads <number>\", \"number of threads to use\");\n    command.option(\n      \"--simultaneous <number>\",\n      \"number of simultaneous requests to make\",\n    );\n    return action(async (options) => {\n      // if (typeof options.reset === \"string\")\n      //     options.reset = options.reset === \"true\";\n      // options.mode ??= await prompt.select(\"mode\")(\"Select mode\")([\n      //     \"LOCAL\",\n      //     \"DEV\",\n      //     \"REAL\",\n      // ]);\n      // options.reset ??= await prompt.boolean(\"reset\")(\"Reset local DB\");\n      options.count = Number(\n        options.count ??\n          (await prompt.number(\"count\")(\"Number of requests to make\")),\n      );\n      options.threads = Number(\n        options.threads ??\n          (await prompt.number(\"threads\")(\"Number of threads to use\")),\n      );\n      options.simultaneous = Number(\n        options.simultaneous ??\n          (await prompt.number(\"simultaneous\")(\n            \"Number of simultaneous requests to make\",\n          )),\n      );\n      return options as IOptions;\n    });\n  });\n\nconst main = async (): Promise<void> => {\n  // CONFIGURATIONS\n  const options: IOptions = await getOptions();\n  MyGlobal.testing = true;\n\n  // BACKEND SERVER\n  const backend: MyBackend = new MyBackend();\n  await backend.open();\n\n  // DO BENCHMARK\n  const prev: IPointer<number> = { value: 0 };\n  const bar: cliProgress.SingleBar = new cliProgress.SingleBar(\n    {},\n    cliProgress.Presets.shades_classic,\n  );\n  bar.start(options.count, 0);\n\n  const report: DynamicBenchmarker.IReport = await DynamicBenchmarker.master({\n    servant: `${__dirname}/servant.js`,\n    count: options.count,\n    threads: options.threads,\n    simultaneous: options.simultaneous,\n    filter: (func) =>\n      (!options.include?.length ||\n        (options.include ?? []).some((str) => func.includes(str))) &&\n      (!options.exclude?.length ||\n        (options.exclude ?? []).every((str) => !func.includes(str))),\n    progress: (value: number) => {\n      if (value >= 100 + prev.value) {\n        bar.update(value);\n        prev.value = value;\n      }\n    },\n    stdio: \"ignore\",\n  });\n  bar.stop();\n\n  // DOCUMENTATION\n  try {\n    await fs.promises.mkdir(`${MyConfiguration.ROOT}/docs/benchmarks`, {\n      recursive: true,\n    });\n  } catch {}\n  await fs.promises.writeFile(\n    `${MyConfiguration.ROOT}/docs/benchmarks/${os\n      .cpus()[0]\n      .model.trim()\n      .split(\"\\\\\")\n      .join(\"\")\n      .split(\"/\")\n      .join(\"\")}.md`,\n    DynamicBenchmarker.markdown(report),\n    \"utf8\",\n  );\n\n  // CLOSE\n  await backend.close();\n};\nmain().catch((exp) => {\n  console.error(exp);\n  process.exit(-1);\n});\n",
      "test/benchmark/servant.ts": "import { DynamicBenchmarker } from \"@nestia/benchmark\";\n\nimport { MyConfiguration } from \"../../src/MyConfiguration\";\n\nDynamicBenchmarker.servant({\n  connection: {\n    host: `http://127.0.0.1:${MyConfiguration.API_PORT()}`,\n  },\n  location: `${__dirname}/../features`,\n  parameters: (connection) => [connection],\n  prefix: \"test_api_\",\n}).catch((exp) => {\n  console.error(exp);\n  process.exit(-1);\n});\n",
      "test/helpers/ArgumentParser.ts": "import commander from \"commander\";\nimport * as inquirer from \"inquirer\";\n\nexport namespace ArgumentParser {\n  export type Inquiry<T> = (\n    command: commander.Command,\n    prompt: (opt?: inquirer.StreamOptions) => inquirer.PromptModule,\n    action: (closure: (options: Partial<T>) => Promise<T>) => Promise<T>,\n  ) => Promise<T>;\n\n  export interface Prompt {\n    select: (\n      name: string,\n    ) => (\n      message: string,\n    ) => <Choice extends string>(choices: Choice[]) => Promise<Choice>;\n    boolean: (name: string) => (message: string) => Promise<boolean>;\n    number: (name: string) => (message: string) => Promise<number>;\n  }\n\n  export const parse = async <T,>(\n    inquiry: (\n      command: commander.Command,\n      prompt: Prompt,\n      action: (closure: (options: Partial<T>) => Promise<T>) => Promise<T>,\n    ) => Promise<T>,\n  ): Promise<T> => {\n    // TAKE OPTIONS\n    const action = (closure: (options: Partial<T>) => Promise<T>) =>\n      new Promise<T>((resolve, reject) => {\n        commander.program.action(async (options) => {\n          try {\n            resolve(await closure(options));\n          } catch (exp) {\n            reject(exp);\n          }\n        });\n        commander.program.parseAsync().catch(reject);\n      });\n\n    const select =\n      (name: string) =>\n      (message: string) =>\n      async <Choice extends string>(choices: Choice[]): Promise<Choice> =>\n        (\n          await inquirer.createPromptModule()({\n            type: \"list\",\n            name,\n            message,\n            choices,\n          })\n        )[name];\n    const boolean = (name: string) => async (message: string) =>\n      (\n        await inquirer.createPromptModule()({\n          type: \"confirm\",\n          name,\n          message,\n        })\n      )[name] as boolean;\n    const number = (name: string) => async (message: string) =>\n      Number(\n        (\n          await inquirer.createPromptModule()({\n            type: \"number\",\n            name,\n            message,\n          })\n        )[name],\n      );\n\n    const output: T | Error = await (async () => {\n      try {\n        return await inquiry(\n          commander.program,\n          { select, boolean, number },\n          action,\n        );\n      } catch (error) {\n        return error as Error;\n      }\n    })();\n\n    // RETURNS\n    if (output instanceof Error) throw output;\n    return output;\n  };\n}\n",
      "test/index.ts": "import { MyBackend } from \"../src/MyBackend\";\nimport { MyGlobal } from \"../src/MyGlobal\";\nimport { TestAutomation } from \"./TestAutomation\";\n\nconst main = async (): Promise<void> => {\n  MyGlobal.testing = true;\n  await TestAutomation.execute({\n    open: async () => {\n      const backend: MyBackend = new MyBackend();\n      await backend.open();\n      return backend;\n    },\n    close: (backend) => backend.close(),\n  });\n};\nmain().catch((exp) => {\n  console.log(exp);\n  process.exit(-1);\n});\n",
      "test/tsconfig.json": "{\n  \"extends\": \"../tsconfig.json\",\n  \"compilerOptions\": {\n    \"outDir\": \"../bin\",\n    \"noUnusedLocals\": false,\n  },\n  \"include\": [\".\", \"../src\"]\n}",
      "test/webpack.ts": "import cp from \"child_process\";\nimport { sleep_for } from \"tstl\";\n\nimport { MyConfiguration } from \"../src/MyConfiguration\";\nimport { MyGlobal } from \"../src/MyGlobal\";\nimport { TestAutomation } from \"./TestAutomation\";\n\nconst wait = async (): Promise<void> => {\n  while (true)\n    try {\n      await fetch(`http://localhost:${MyConfiguration.API_PORT()}/dsafdsafsd`);\n      return;\n    } catch (exp) {\n      await sleep_for(100);\n    }\n};\n\nconst main = async (): Promise<void> => {\n  MyGlobal.testing = true;\n  await TestAutomation.execute({\n    open: async () => {\n      const backend: cp.ChildProcess = cp.fork(\n        `${MyConfiguration.ROOT}/dist/server.js`,\n        {\n          cwd: `${MyConfiguration.ROOT}/dist`,\n        },\n      );\n      await wait();\n      return backend;\n    },\n    close: async (backend) => {\n      backend.kill();\n    },\n  });\n};\nmain().catch((exp) => {\n  console.log(exp);\n  process.exit(-1);\n});\n",
      "tsconfig.json": "{\n  \"compilerOptions\": {\n    /* Visit https://aka.ms/tsconfig to read more about this file */\n\n    /* Projects */\n    // \"incremental\": true,                              /* Save .tsbuildinfo files to allow for incremental compilation of projects. */\n    // \"composite\": true,                                /* Enable constraints that allow a TypeScript project to be used with project references. */\n    // \"tsBuildInfoFile\": \"./.tsbuildinfo\",              /* Specify the path to .tsbuildinfo incremental compilation file. */\n    // \"disableSourceOfProjectReferenceRedirect\": true,  /* Disable preferring source files instead of declaration files when referencing composite projects. */\n    // \"disableSolutionSearching\": true,                 /* Opt a project out of multi-project reference checking when editing. */\n    // \"disableReferencedProjectLoad\": true,             /* Reduce the number of projects loaded automatically by TypeScript. */\n\n    /* Language and Environment */\n    \"target\": \"ES2015\",                                  /* Set the JavaScript language version for emitted JavaScript and include compatible library declarations. */\n    // \"lib\": [],                                        /* Specify a set of bundled library declaration files that describe the target runtime environment. */\n    // \"jsx\": \"preserve\",                                /* Specify what JSX code is generated. */\n    \"experimentalDecorators\": true,                   /* Enable experimental support for TC39 stage 2 draft decorators. */\n    \"emitDecoratorMetadata\": true,                    /* Emit design-type metadata for decorated declarations in source files. */\n    // \"jsxFactory\": \"\",                                 /* Specify the JSX factory function used when targeting React JSX emit, e.g. 'React.createElement' or 'h'. */\n    // \"jsxFragmentFactory\": \"\",                         /* Specify the JSX Fragment reference used for fragments when targeting React JSX emit e.g. 'React.Fragment' or 'Fragment'. */\n    // \"jsxImportSource\": \"\",                            /* Specify module specifier used to import the JSX factory functions when using 'jsx: react-jsx*'. */\n    // \"reactNamespace\": \"\",                             /* Specify the object invoked for 'createElement'. This only applies when targeting 'react' JSX emit. */\n    // \"noLib\": true,                                    /* Disable including any library files, including the default lib.d.ts. */\n    // \"useDefineForClassFields\": true,                  /* Emit ECMAScript-standard-compliant class fields. */\n    // \"moduleDetection\": \"auto\",                        /* Control what method is used to detect module-format JS files. */\n\n    /* Modules */\n    \"module\": \"commonjs\",                                /* Specify what module code is generated. */\n    // \"rootDir\": \"./\",                                  /* Specify the root folder within your source files. */\n    // \"moduleResolution\": \"node\",                       /* Specify how TypeScript looks up a file from a given module specifier. */\n    // \"baseUrl\": \"./\",                                  /* Specify the base directory to resolve non-relative module names. */\n    \"paths\": {\n      \"@ORGANIZATION/PROJECT-api/lib/*\": [\"./src/api/*\"],\n      \"@ORGANIZATION/PROJECT-api\": [\"./src/api\"],\n    },                                      /* Specify a set of entries that re-map imports to additional lookup locations. */\n    // \"rootDirs\": [],                                   /* Allow multiple folders to be treated as one when resolving modules. */\n    // \"typeRoots\": [],                                  /* Specify multiple folders that act like './node_modules/@types'. */\n    // \"types\": [],                                      /* Specify type package names to be included without being referenced in a source file. */\n    // \"allowUmdGlobalAccess\": true,                     /* Allow accessing UMD globals from modules. */\n    // \"moduleSuffixes\": [],                             /* List of file name suffixes to search when resolving a module. */\n    // \"resolveJsonModule\": true,                        /* Enable importing .json files. */\n    // \"noResolve\": true,                                /* Disallow 'import's, 'require's or '<reference>'s from expanding the number of files TypeScript should add to a project. */\n\n    /* JavaScript Support */\n    // \"allowJs\": true,                                  /* Allow JavaScript files to be a part of your program. Use the 'checkJS' option to get errors from these files. */\n    // \"checkJs\": true,                                  /* Enable error reporting in type-checked JavaScript files. */\n    // \"maxNodeModuleJsDepth\": 1,                        /* Specify the maximum folder depth used for checking JavaScript files from 'node_modules'. Only applicable with 'allowJs'. */\n\n    /* Emit */\n    // \"declaration\": true,                              /* Generate .d.ts files from TypeScript and JavaScript files in your project. */\n    // \"declarationMap\": true,                           /* Create sourcemaps for d.ts files. */\n    // \"emitDeclarationOnly\": true,                      /* Only output d.ts files and not JavaScript files. */\n    \"sourceMap\": true,                                /* Create source map files for emitted JavaScript files. */\n    // \"outFile\": \"./\",                                  /* Specify a file that bundles all outputs into one JavaScript file. If 'declaration' is true, also designates a file that bundles all .d.ts output. */\n    \"outDir\": \"./lib\",                                   /* Specify an output folder for all emitted files. */\n    // \"removeComments\": true,                           /* Disable emitting comments. */\n    // \"noEmit\": true,                                   /* Disable emitting files from a compilation. */\n    // \"importHelpers\": true,                            /* Allow importing helper functions from tslib once per project, instead of including them per-file. */\n    // \"importsNotUsedAsValues\": \"remove\",               /* Specify emit/checking behavior for imports that are only used for types. */\n    // \"downlevelIteration\": true,                       /* Emit more compliant, but verbose and less performant JavaScript for iteration. */\n    // \"sourceRoot\": \"\",                                 /* Specify the root path for debuggers to find the reference source code. */\n    // \"mapRoot\": \"\",                                    /* Specify the location where debugger should locate map files instead of generated locations. */\n    // \"inlineSourceMap\": true,                          /* Include sourcemap files inside the emitted JavaScript. */\n    // \"inlineSources\": true,                            /* Include source code in the sourcemaps inside the emitted JavaScript. */\n    // \"emitBOM\": true,                                  /* Emit a UTF-8 Byte Order Mark (BOM) in the beginning of output files. */\n    \"newLine\": \"lf\",                                /* Set the newline character for emitting files. */\n    \"stripInternal\": true,                            /* Disable emitting declarations that have '@internal' in their JSDoc comments. */\n    // \"noEmitHelpers\": true,                            /* Disable generating custom helper functions like '__extends' in compiled output. */\n    // \"noEmitOnError\": true,                            /* Disable emitting files if any type checking errors are reported. */\n    // \"preserveConstEnums\": true,                       /* Disable erasing 'const enum' declarations in generated code. */\n    // \"declarationDir\": \"./\",                           /* Specify the output directory for generated declaration files. */\n    // \"preserveValueImports\": true,                     /* Preserve unused imported values in the JavaScript output that would otherwise be removed. */\n\n    /* Interop Constraints */\n    // \"isolatedModules\": true,                          /* Ensure that each file can be safely transpiled without relying on other imports. */\n    // \"allowSyntheticDefaultImports\": true,             /* Allow 'import x from y' when a module doesn't have a default export. */\n    \"esModuleInterop\": true,                             /* Emit additional JavaScript to ease support for importing CommonJS modules. This enables 'allowSyntheticDefaultImports' for type compatibility. */\n    // \"preserveSymlinks\": true,                         /* Disable resolving symlinks to their realpath. This correlates to the same flag in node. */\n    \"forceConsistentCasingInFileNames\": true,            /* Ensure that casing is correct in imports. */\n\n    /* Type Checking */\n    \"strict\": true,                                      /* Enable all strict type-checking options. */\n    // \"noImplicitAny\": true,                            /* Enable error reporting for expressions and declarations with an implied 'any' type. */\n    // \"strictNullChecks\": true,                         /* When type checking, take into account 'null' and 'undefined'. */\n    // \"strictFunctionTypes\": true,                      /* When assigning functions, check to ensure parameters and the return values are subtype-compatible. */\n    // \"strictBindCallApply\": true,                      /* Check that the arguments for 'bind', 'call', and 'apply' methods match the original function. */\n    // \"strictPropertyInitialization\": true,             /* Check for class properties that are declared but not set in the constructor. */\n    // \"noImplicitThis\": true,                           /* Enable error reporting when 'this' is given the type 'any'. */\n    // \"useUnknownInCatchVariables\": true,               /* Default catch clause variables as 'unknown' instead of 'any'. */\n    // \"alwaysStrict\": true,                             /* Ensure 'use strict' is always emitted. */\n    \"noUnusedLocals\": true,                           /* Enable error reporting when local variables aren't read. */\n    \"noUnusedParameters\": true,                       /* Raise an error when a function parameter isn't read. */\n    // \"exactOptionalPropertyTypes\": true,               /* Interpret optional property types as written, rather than adding 'undefined'. */\n    \"noImplicitReturns\": true,                        /* Enable error reporting for codepaths that do not explicitly return in a function. */\n    \"noFallthroughCasesInSwitch\": true,               /* Enable error reporting for fallthrough cases in switch statements. */\n    // \"noUncheckedIndexedAccess\": true,                 /* Add 'undefined' to a type when accessed using an index. */\n    // \"noImplicitOverride\": true,                       /* Ensure overriding members in derived classes are marked with an override modifier. */\n    // \"noPropertyAccessFromIndexSignature\": true,       /* Enforces using indexed accessors for keys declared using an indexed type. */\n    // \"allowUnusedLabels\": true,                        /* Disable error reporting for unused labels. */\n    // \"allowUnreachableCode\": true,                     /* Disable error reporting for unreachable code. */\n\n    /* Completeness */\n    // \"skipDefaultLibCheck\": true,                      /* Skip type checking .d.ts files that are included with TypeScript. */\n    \"skipLibCheck\": true,                                 /* Skip type checking all .d.ts files. */\n    \"plugins\": [\n      { \"transform\": \"typescript-transform-paths\" },\n      { \"transform\": \"typia/lib/transform\" },\n      { \n        \"transform\": \"@nestia/core/lib/transform\",\n        /**\n         * Validate request body.\n         * \n         *   - \"assert\": Use typia.assert() function\n         *   - \"is\": Use typia.is() function\n         *   - \"validate\": Use typia.validate() function\n         *   - \"assertEquals\": Use typia.assertEquals() function\n         *   - \"equals\": Use typia.equals() function\n         *   - \"validateEquals\": Use typia.validateEquals() function\n         */\n        \"validate\": \"validate\",\n        /**\n         * Validate JSON typed response body.\n         * \n         *   - \"assert\": Use typia.assertStringify() function\n         *   - \"is\": Use typia.isStringify() function\n         *   - \"validate\": Use typia.validateStringify() function\n         *   - \"validate.log\": typia.validateStringify(), but do not throw and just log it\n         *   - \"stringify\": Use typia.stringify() function, but dangerous\n         *   - null: Just use JSON.stringify() function, without boosting\n         */\n        \"stringify\": \"assert\",\n      },\n    ]\n  },\n  \"include\": [\n    \"src\"\n  ],\n  \"exclude\": [\n    \"node_modules\",\n    \"packages\",\n  ]\n}\n",
      "typos.toml": "[default]\nlocale = 'en-us'\nextend-ignore-re = [\n  \"(?Rm)^.*(<!--|#|//)\\\\s*spellchecker:disable-line(-->|\\n)?$\",\n  \"(?s)(<!--|#|//)\\\\s*spellchecker:off\\\\s*(-->|\\n).*?(<!--|#|//)\\\\s*spellchecker:on\",\n]\n\n[default.extend-words]\nJeongho = \"Jeongho\"\nNam = \"Nam\"\ntypia = \"typia\"\n\n[files]\nextend-exclude = [\"*.json\"]",
      "webpack.config.js": "const path = require(\"path\");\n\nconst CopyWebpackPlugin = require(\"copy-webpack-plugin\");\nconst WriteFilePlugin = require(\"write-file-webpack-plugin\");\nconst { IgnorePlugin } = require(\"webpack\");\n\nconst lazyImports = [\n  \"@fastify/static\",\n  \"@fastify/view\",\n  \"@nestjs/microservices\",\n  \"@nestjs/websockets\",\n  \"class-transformer\",\n  \"class-validator\",\n];\n\n// @reference https://tech-blog.s-yoshiki.com/entry/297\nmodule.exports = {\n  // CUSTOMIZE HERE\n  entry: {\n    server: \"./src/executable/server.ts\",\n  },\n  output: {\n    path: path.join(__dirname, \"dist\"),\n    filename: \"[name].js\",\n  },\n  optimization: {\n    minimize: true,\n  },\n\n  // JUST KEEP THEM\n  mode: \"production\",\n  target: \"node\",\n  module: {\n    rules: [\n      {\n        test: /\\.ts$/,\n        exclude: /node_modules/,\n        loader: \"ts-loader\",\n      },\n    ],\n  },\n  resolve: {\n    extensions: [\".tsx\", \".ts\", \".js\"],\n  },\n  plugins: [\n    new CopyWebpackPlugin({\n      patterns: [\n        {\n          from: \".env\",\n          to: \"[name][ext]\",\n        },\n        // {\n        //   from: \"./node_modules/.prisma/client/*.node\",\n        //   to: () => Promise.resolve(\"[path][name][ext]\"),\n        //   globOptions: {\n        //     dot: true,\n        //   },\n        // },\n      ],\n    }),\n    new WriteFilePlugin(),\n    new IgnorePlugin({\n      checkResource: (resource) => {\n        if (lazyImports.some((modulo) => resource.startsWith(modulo))) {\n          try {\n            require.resolve(resource);\n          } catch (err) {\n            return true;\n          }\n        }\n        return false;\n      },\n    }),\n  ],\n};\n",
      "src/MyModule.ts": "import { Module } from \"@nestjs/common\";\n\nimport { BbsUsersController } from \"./controllers/bbs/users/BbsUsersController\";\nimport { BbsUserrolesController } from \"./controllers/bbs/userRoles/BbsUserrolesController\";\nimport { BbsCategoriesController } from \"./controllers/bbs/categories/BbsCategoriesController\";\nimport { BbsPostsController } from \"./controllers/bbs/posts/BbsPostsController\";\nimport { BbsPostsCommentsController } from \"./controllers/bbs/posts/comments/BbsPostsCommentsController\";\nimport { BbsCommentsCommentsController } from \"./controllers/bbs/comments/comments/BbsCommentsCommentsController\";\nimport { BbsVotesController } from \"./controllers/bbs/votes/BbsVotesController\";\n\n@Module({\n  controllers: [\n    BbsUsersController,\n    BbsUserrolesController,\n    BbsCategoriesController,\n    BbsPostsController,\n    BbsPostsCommentsController,\n    BbsCommentsCommentsController,\n    BbsVotesController,\n  ],\n})\nexport class MyModule {}\n",
      "src/controllers/bbs/users/BbsUsersController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody, TypedParam } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IBbsUsers } from \"../../../api/structures/IBbsUsers\";\nimport { IPageIBbsUsers } from \"../../../api/structures/IPageIBbsUsers\";\n\n@Controller(\"/bbs/users\")\nexport class BbsUsersController {\n  /**\n   * Register a new user account (users table).\n   *\n   * This operation allows either new users to self-register (signup) or\n   * administrative users to create new user accounts. Inputs include:\n   * username, email, password (plain, which will be hashed), role, and\n   * optional biography. Usernames and emails must be unique system-wide as\n   * enforced by the DB. Role assignment references the user_roles table (role\n   * name or ID). On successful creation, returns full non-sensitive account\n   * data (never returns password hash or plain password). Validation includes\n   * strong password policies, correctly-formed emails, unique username check,\n   * assignment of allowed roles, and correct audit metadata. Security\n   * policies ensure only authorized clients can create\n   * moderator/administrator accounts. Relationship: users references\n   * user_roles via user_role_id (UUID). The operation complements\n   * authentication endpoints and supports user onboarding workflows. Error\n   * handling includes duplicate entries, invalid roles, and input format\n   * errors.\n   *\n   * @param connection\n   * @param body User account registration information, including username,\n   *   email, password, role, and optional bio.\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Post()\n  public async post(\n    @TypedBody()\n    body: IBbsUsers.ICreate,\n  ): Promise<IBbsUsers> {\n    body;\n    return typia.random<IBbsUsers>();\n  }\n\n  /**\n   * List users with search, filtering, and pagination (users table).\n   *\n   * This operation enables privileged users (moderators, administrators) to\n   * retrieve a paginated list of all users registered on the discussion\n   * board. The returned user data includes public profile information\n   * (username, email, bio), their user role, account status, and registration\n   * metadata. Filtering and searching capabilities provide powerful\n   * moderation and community management tools, allowing admins to quickly\n   * investigate misuse, track new registrations, or query dormant/suspended\n   * accounts. Pagination parameters prevent excessive database load. The\n   * endpoint ensures security by requiring bearer authentication and\n   * restricting access to users with sufficient privileges (moderator or\n   * administrator). This operation references the users Prisma schema model,\n   * specifically all columns described (id, user_role_id, username, email,\n   * bio, status, created_at, updated_at). The response should not include\n   * password hashes. Validation includes correct filter types, secure\n   * pagination defaults, and correct authorization checks. This operation may\n   * be combined with single-user lookup or management operations for a full\n   * user administration workflow.\n   *\n   * @param connection\n   * @param body Request parameters for user list/search, including filters,\n   *   pagination, and sort details.\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patch(\n    @TypedBody()\n    body: IBbsUsers.IRequest,\n  ): Promise<IPageIBbsUsers> {\n    body;\n    return typia.random<IPageIBbsUsers>();\n  }\n\n  /**\n   * Retrieve a user's profile/account by user ID (users table).\n   *\n   * This endpoint retrieves the full account and public profile information\n   * for a specific user, as identified by their UUID. It is used for account\n   * management, profile viewing, and moderation. The returned details include\n   * username, bio, email, role (with full description), account status, and\n   * timestamps (created_at, updated_at). Account credentials (such as the\n   * password_hash) are never returned for security reasons. The endpoint may\n   * be used by administrators or moderators during audits, dispute\n   * resolution, or assisting users. Follows the users Prisma schema for all\n   * properties and relationships. Handles missing/deleted users gracefully\n   * with informative error responses. Security validation restricts access to\n   * authorized roles only, typically moderator or administrator.\n   *\n   * @param connection\n   * @param id Target user's UUID\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get(\":id\")\n  public async getById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<IBbsUsers> {\n    id;\n    return typia.random<IBbsUsers>();\n  }\n\n  /**\n   * Update an existing user profile or account (users table).\n   *\n   * This endpoint lets administrators or the users themselves update user\n   * profile information (username, email, bio), administrative account status\n   * (active, suspended, banned, etc.), or reassign user role (referencing\n   * user_roles table). Changing credentials (password) is handled by a\n   * separate workflow, but email and username uniqueness is always enforced.\n   * Security rules ensure only allowed users (self, moderator, admin) can\n   * update the target account. All changes are subject to full validation\n   * against the business rules in the requirements document and Prisma\n   * schema. Audit fields (updated_at) are set by the backend. The endpoint\n   * can be used in workflows for profile updates, role upgrades, or\n   * moderation actions. Errors include duplicate username/email or\n   * unpermitted actions.\n   *\n   * @param connection\n   * @param id Target user's UUID\n   * @param body Profile/account update payload (username, bio, email, role,\n   *   status, but not password).\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Put(\":id\")\n  public async putById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IBbsUsers.IUpdate,\n  ): Promise<IBbsUsers> {\n    id;\n    body;\n    return typia.random<IBbsUsers>();\n  }\n\n  /**\n   * Soft-delete (deactivate) a user by status update (users table).\n   *\n   * This operation allows administrators or moderators to deactivate or\n   * remove a user account without physically deleting the record from the\n   * database, preserving audit trails and possible restoration. Actual\n   * implementation sets the status field of the user record (users table) to\n   * a value like 'deleted', 'banned', or 'suspended'. Only privileged users\n   * (administrators, moderators) may execute this unless it's for\n   * self-removal. Associated content (posts/comments) are retained. This\n   * operation references account removal business logic from requirements and\n   * Prisma schema business rules. All necessary validation, audit, and error\n   * handling logic are included. Deactivation is irreversible except by\n   * subsequent restoration workflow.\n   *\n   * @param connection\n   * @param id Target user's UUID\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Delete(\":id\")\n  public async eraseById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<IBbsUsers> {\n    id;\n    return typia.random<IBbsUsers>();\n  }\n}\n",
      "src/controllers/bbs/userRoles/BbsUserrolesController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody, TypedParam } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IBbsUserRoles } from \"../../../api/structures/IBbsUserRoles\";\nimport { IPageIBbsUserRoles } from \"../../../api/structures/IPageIBbsUserRoles\";\n\n@Controller(\"/bbs/userRoles\")\nexport class BbsUserrolesController {\n  /**\n   * Create a new user role (user_roles table).\n   *\n   * This operation allows system administrators to define and create new user\n   * roles, expanding the range of permissions and governance on the\n   * discussion board. Input includes the unique role name (e.g.,\n   * 'community_manager'), and a text description outlining permissions and\n   * duties. Validation enforces uniqueness of the role name, and the\n   * description is required for audit and clarity. May be used in onboarding\n   * or registration flows to offer new kinds of user experiences (e.g.,\n   * temporary roles). All relationships and constraints are as defined in\n   * user_roles Prisma model. Error handling covers duplicates and format\n   * errors. Audit metadata is tracked by the backend.\n   *\n   * @param connection\n   * @param body Role creation payload (unique name, descriptive text).\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Post()\n  public async post(\n    @TypedBody()\n    body: IBbsUserRoles.ICreate,\n  ): Promise<IBbsUserRoles> {\n    body;\n    return typia.random<IBbsUserRoles>();\n  }\n\n  /**\n   * List user roles with search and pagination (user_roles table).\n   *\n   * List the roles available for assignment to users, as per the user_roles\n   * business table (roles like member, moderator, administrator). Supports\n   * pagination, filtering, and search on role names or descriptions,\n   * assisting administrators and registration workflows in finding or\n   * displaying available roles. Related to users table by user_role_id. The\n   * endpoint returns role information but does not expose any linked user\n   * personal data. Supports role management, onboarding, and auditing.\n   * Authorization is required, typically for system administration staff.\n   * Used alongside user creation and update APIs to ensure valid references.\n   *\n   * @param connection\n   * @param body Request parameters for user role list/search, supporting\n   *   filtering and pagination.\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patch(\n    @TypedBody()\n    body: IBbsUserRoles.IRequest,\n  ): Promise<IPageIBbsUserRoles> {\n    body;\n    return typia.random<IPageIBbsUserRoles>();\n  }\n\n  /**\n   * Retrieve a user role by ID (user_roles table).\n   *\n   * Get metadata about a specific user role, identified by its UUID. Returns\n   * the unique name and full description of role authority, as defined in the\n   * user_roles Prisma table and associated requirements. Used for audit\n   * checks, onboarding selection, or administrative validation (e.g.,\n   * displaying what a moderator can do). Access is required for system\n   * administrators or similar privileged roles. Handles missing/invalid IDs\n   * gracefully. The endpoint does not expose user information, only the role\n   * metadata.\n   *\n   * @param connection\n   * @param id Target role's UUID\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get(\":id\")\n  public async getById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<IBbsUserRoles> {\n    id;\n    return typia.random<IBbsUserRoles>();\n  }\n\n  /**\n   * Update existing user role by role ID (user_roles table).\n   *\n   * This operation edits the label and description of an existing user role,\n   * updating governance or onboarding configuration. Only permitted users\n   * (administrators) can invoke it. Input: role ID (UUID), new name, and/or\n   * new description. Enforces unique name and proper validation. Responses\n   * include the updated role descriptor. Used along with other role\n   * management APIs for dynamic permissions adjustments. Covers all role\n   * metadata per user_roles Prisma schema. Handles invalid input, duplicate\n   * names, or permissions errors. Returns updated user role metadata for\n   * confirmation.\n   *\n   * @param connection\n   * @param id Target role's UUID\n   * @param body User role update payload (new name, description).\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Put(\":id\")\n  public async putById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IBbsUserRoles.IUpdate,\n  ): Promise<IBbsUserRoles> {\n    id;\n    body;\n    return typia.random<IBbsUserRoles>();\n  }\n\n  /**\n   * Deactivate (soft-delete) user role by ID (user_roles table).\n   *\n   * Allows system administrators to deactivate a role in the user_roles\n   * table. In practice, this might mean preventing new users from being\n   * assigned this role, but the role metadata remains for audit and\n   * traceability. The endpoint does not physically remove the record. Input\n   * is the role's UUID. Can be combined with user management endpoints for\n   * full administrative functionality. Authorization and permissions are\n   * strictly enforced. Responses document the now-inactive/deleted state.\n   * Error handling includes referencing non-existent or protected roles.\n   * Audit/meta info is retained.\n   *\n   * @param connection\n   * @param id Target role's UUID\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Delete(\":id\")\n  public async eraseById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<IBbsUserRoles> {\n    id;\n    return typia.random<IBbsUserRoles>();\n  }\n}\n",
      "src/controllers/bbs/categories/BbsCategoriesController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody, TypedParam } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { bbsCategories } from \"../../../api/structures/bbsCategories\";\nimport { IPageIBbsCategories } from \"../../../api/structures/IPageIBbsCategories\";\nimport { IBbsCategories } from \"../../../api/structures/IBbsCategories\";\n\n@Controller(\"/bbs/categories\")\nexport class BbsCategoriesController {\n  /**\n   * Create a new category (BBS: categories table).\n   *\n   * This API allows an administrator to create a new discussion category in\n   * the BBS platform. By supplying necessary information such as category\n   * name and description, the system adds a new record to the 'categories'\n   * table. Administrators should ensure names are unique to avoid conflicts\n   * with existing categories.\n   *\n   * Access to this API is restricted to authenticated administrators, as only\n   * they may modify the set of available discussion categories. Upon\n   * successful creation, a new category entry is visible and available for\n   * post assignment by all users, supporting better board organization.\n   *\n   * If the submitted category name already exists, the API will return an\n   * error indicating the name must be unique. Validation rules also require\n   * non-empty strings for both name and description fields.\n   *\n   * Related operations include listing categories, updating (PUT), and\n   * deleting (DELETE) existing categories. This endpoint is essential for\n   * maintaining the topical structure of the BBS, making it easier for users\n   * to navigate and participate in relevant discussions.\n   *\n   * @param connection\n   * @param body Information about the new category to create, including name\n   *   and description.\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Post()\n  public async post(\n    @TypedBody()\n    body: bbsCategories.ICreate,\n  ): Promise<bbsCategories> {\n    body;\n    return typia.random<bbsCategories>();\n  }\n\n  /**\n   * List post categories with search and pagination (categories table).\n   *\n   * This endpoint allows clients to list the discussion categories (topic\n   * areas, such as 'Politics', 'Economics') under which posts are organized.\n   * Supports optional filtering/search, useful for navigation, onboarding,\n   * and content creation flows. Uses pagination for performance. Does not\n   * disclose posts, only the category metadata (id, name, description,\n   * created_at) from the categories Prisma schema. No relationships to users\n   * are returned. Accessible to all users, including visitors without\n   * authentication by default, but may also support administrative filtering\n   * enhancements. Commonly used to build navigation bars or prompt users to\n   * choose a category when creating content. Handles invalid filters and\n   * pagination gracefully.\n   *\n   * @param connection\n   * @param body Category query/search/pagination options.\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patch(\n    @TypedBody()\n    body: IBbsCategories.IRequest,\n  ): Promise<IPageIBbsCategories> {\n    body;\n    return typia.random<IPageIBbsCategories>();\n  }\n\n  /**\n   * Get a single category's details by ID (categories table).\n   *\n   * This endpoint fetches the name, description, and creation date for a\n   * specific discussion category. The input is the category's UUID. Used by\n   * clients or admins to display detailed category information (such as when\n   * viewing the category page or offering category selection in post\n   * creation). Does not return post data itself, only the category metadata\n   * as defined in the categories Prisma schema. Handles invalid/missing\n   * category gracefully. No relationships are exposed, only direct metadata.\n   * Authorization is open by default but may enforce further checks for\n   * admin/management views. Used in category navigation, post composition, or\n   * audit reporting. Audit trail (created_at) is returned for management.\n   *\n   * @param connection\n   * @param id Target category's UUID\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get(\":id\")\n  public async getById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<IBbsCategories> {\n    id;\n    return typia.random<IBbsCategories>();\n  }\n\n  /**\n   * Update a category's details (BBS: categories table).\n   *\n   * This API allows authenticated administrators to update the name or\n   * description of a discussion category identified by its unique 'id'. The\n   * update operation references the 'categories' table and enforces\n   * uniqueness for category names and requires non-empty values. Only\n   * administrators may perform this action, and each request must specify the\n   * category's identifier in the path.\n   *\n   * Attempts to change the category name to one already in use will result in\n   * a validation error. The update operation also prevents accidental erasure\n   * of required information by ensuring both the name and description remain\n   * populated after editing. Related endpoints include category creation\n   * (POST), deletion (DELETE), and listing/searching operations for\n   * categories.\n   *\n   * On success, the endpoint returns the updated category information,\n   * reflecting all changes for immediate use in the system.\n   *\n   * @param connection\n   * @param id The identifier of the category to update.\n   * @param body Updated information for the specified category.\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Put(\":id\")\n  public async putById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: bbsCategories.IUpdate,\n  ): Promise<bbsCategories> {\n    id;\n    body;\n    return typia.random<bbsCategories>();\n  }\n\n  /**\n   * Delete a category by ID (BBS: categories table).\n   *\n   * This API endpoint allows an authenticated administrator to delete a\n   * discussion category by its ID from the BBS system. It removes the\n   * specified record from the 'categories' table. Prior to deletion, the\n   * system checks for posts referencing this category; administrators may\n   * need to reassign or handle these posts to maintain board integrity.\n   *\n   * Only users with appropriate administrator roles (as defined in the\n   * 'user_roles' table) are permitted to invoke this operation. Attempts to\n   * delete a category with dependent posts may result in an error until those\n   * dependencies are resolved. On successful completion, the category is\n   * permanently removed from the database; deleted category names can be\n   * reused when creating new categories.\n   *\n   * Related endpoints include creating, updating, and listing categories.\n   *\n   * @param connection\n   * @param id The identifier of the category to delete.\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Delete(\":id\")\n  public async eraseById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<bbsCategories> {\n    id;\n    return typia.random<bbsCategories>();\n  }\n}\n",
      "src/controllers/bbs/posts/BbsPostsController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody, TypedParam } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { bbsPosts } from \"../../../api/structures/bbsPosts\";\nimport { IPageBbsPosts } from \"../../../api/structures/IPageBbsPosts\";\n\n@Controller(\"/bbs/posts\")\nexport class BbsPostsController {\n  /**\n   * Create a new post (BBS: posts table).\n   *\n   * This API endpoint enables registered users to start a new discussion by\n   * submitting a post to the BBS platform. The client must provide all\n   * required information: title, body content, associated category, and,\n   * implicitly, the user's identity (via authentication).\n   *\n   * The system records each new post in the 'posts' table and links it to the\n   * author's user record and the assigned category. Constraints ensure titles\n   * and content are non-empty, with a valid category reference.\n   *\n   * Upon success, the new post (with its ID and relevant metadata) is\n   * immediately available for searching, viewing, and commenting. The\n   * operation enforces organization and content standards, returning\n   * validation errors if requirements are unmet.\n   *\n   * Post-creation, users may view, edit, or delete their posts, while\n   * moderators can perform additional actions as per role. This endpoint is\n   * closely related to GET, PUT, and DELETE operations on posts.\n   *\n   * @param connection\n   * @param body Information for the new post, including title, content, and\n   *   category ID.\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Post()\n  public async post(\n    @TypedBody()\n    body: bbsPosts.ICreate,\n  ): Promise<bbsPosts> {\n    body;\n    return typia.random<bbsPosts>();\n  }\n\n  /**\n   * Search and list posts with filtering and pagination (BBS: posts table).\n   *\n   * This API allows users to list and search through discussion posts on the\n   * BBS platform by querying the 'posts' table. The endpoint supports\n   * pagination, keyword search, category-based filtering, sorting by date or\n   * popularity, and other advanced query options as per best practice\n   * standards.\n   *\n   * Both registered members and visitors can use this endpoint (though access\n   * to full content or additional metadata may be limited for visitors).\n   * Results typically return basic post details—such as title, author\n   * summary, vote tallies, timestamps—and allow users to quickly find,\n   * browse, and analyze current discussions.\n   *\n   * If the query contains unsupported or invalid parameters, the system\n   * returns an appropriate error. This endpoint is commonly used alongside\n   * post creation (POST), update (PUT), detail view (GET), and deletion\n   * (DELETE) operations.\n   *\n   * @param connection\n   * @param body Search, filter, and pagination options for retrieving posts.\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patch(\n    @TypedBody()\n    body: bbsPosts.IRequest,\n  ): Promise<IPageBbsPosts> {\n    body;\n    return typia.random<IPageBbsPosts>();\n  }\n\n  /**\n   * Get detailed info for a specific post (BBS: posts table).\n   *\n   * This API endpoint allows a user to fetch complete details about a single\n   * post, identified by its UUID. It is tied to the 'posts' table and is\n   * available to visitors and registered members. Returned data includes the\n   * post title, content, author summary, associated category, creation and\n   * update times, and vote tallies.\n   *\n   * This operation is essential for navigating from post lists to detailed\n   * thread views, supporting actions such as voting or commenting (when\n   * logged in). If the requested post does not exist, the API returns an\n   * appropriate not-found error. Related endpoints include post listing\n   * (PATCH /bbs/posts), post creation (POST), updating (PUT), and deletion\n   * (DELETE).\n   *\n   * @param connection\n   * @param id The unique identifier of the post to retrieve.\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get(\":id\")\n  public async getById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<bbsPosts> {\n    id;\n    return typia.random<bbsPosts>();\n  }\n\n  /**\n   * Update a post's details (BBS: posts table).\n   *\n   * This API allows the original author (or, in special cases, a\n   * moderator/administrator) to update an existing post identified by its\n   * UUID. The client supplies updated values for title, content, or other\n   * modifiable fields. The 'posts' table enforces that only the recorded\n   * author or privileged account can submit updates to a given post record.\n   *\n   * The system maintains a history of 'updated_at' timestamps and can\n   * restrict updates to within certain time windows, as described by business\n   * requirements. Attempting to update with invalid data (missing or\n   * duplicate title, empty content, invalid references) produces an error.\n   * Related endpoints include post creation (POST), detailed retrieval (GET),\n   * and deletion (DELETE).\n   *\n   * The API returns the updated post data upon success, immediately\n   * reflecting any changes in subsequent queries.\n   *\n   * @param connection\n   * @param id The unique post identifier to update.\n   * @param body Updated values for the target post (title, content, category,\n   *   etc.).\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Put(\":id\")\n  public async putById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: bbsPosts.IUpdate,\n  ): Promise<bbsPosts> {\n    id;\n    body;\n    return typia.random<bbsPosts>();\n  }\n\n  /**\n   * Delete a post by ID (BBS: posts table).\n   *\n   * This API allows a post author or an authorized moderator/administrator to\n   * remove a post from the BBS platform. The system marks the post as deleted\n   * (soft delete) or permanently deletes the record from the 'posts' table\n   * per business and moderation rules.\n   *\n   * Access controls ensure only the post's author or properly credentialed\n   * staff may invoke this endpoint. The system prevents posts with active\n   * dependency violations (such as non-removable comments) from being deleted\n   * outright and may require additional steps.\n   *\n   * Upon success, the response confirms deletion status, and the post is\n   * hidden from general listing and searches. Related API endpoints: post\n   * creation (POST), detail view (GET), update (PUT), and comment management\n   * for associated replies.\n   *\n   * @param connection\n   * @param id The unique post identifier to delete.\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Delete(\":id\")\n  public async eraseById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<bbsPosts> {\n    id;\n    return typia.random<bbsPosts>();\n  }\n}\n",
      "src/controllers/bbs/posts/comments/BbsPostsCommentsController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedParam, TypedBody } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { bbsComments } from \"../../../../api/structures/bbsComments\";\nimport { IPageBbsComments } from \"../../../../api/structures/IPageBbsComments\";\n\n@Controller(\"/bbs/posts/:postId/comments\")\nexport class BbsPostsCommentsController {\n  /**\n   * Create a new comment for a specific post (BBS: comments table).\n   *\n   * This API endpoint lets users (or, in special cases,\n   * moderators/administrators) add a new comment to a discussion post. The\n   * caller specifies the parent 'postId' and supplies the comment content.\n   * Optional threading is permitted by providing a parent comment ID for\n   * nested replies—enabling conversations to branch.\n   *\n   * The 'comments' table links the new comment with both the author (via\n   * authentication) and the parent post (and optionally a parent comment),\n   * satisfying data integrity rules and supporting navigation through reply\n   * trees. Only authenticated users are allowed to create comments. The\n   * system enforces validation that content is non-empty and—if threading—a\n   * valid parent comment ID is supplied.\n   *\n   * Upon success, the new comment becomes searchable, viewable, and ready for\n   * follow-up replies or moderation actions. Related endpoints: list/search\n   * comments, update, delete.\n   *\n   * @param connection\n   * @param postId Identifier of the post to which the comment will be added.\n   * @param body Information for the new comment (content, parent comment if\n   *   threading, etc.).\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Post()\n  public async postByPostid(\n    @TypedParam(\"postId\")\n    postId: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: bbsComments.ICreate,\n  ): Promise<bbsComments> {\n    postId;\n    body;\n    return typia.random<bbsComments>();\n  }\n\n  /**\n   * List or search comments for a specified post (BBS: comments table).\n   *\n   * This API allows users to retrieve a list of comments for a specific post,\n   * identified by 'postId'. Supports query options for filtering by author,\n   * time range, reply depth, and more—including pagination and sort order.\n   * The underlying 'comments' table returns summaries or basics details of\n   * each comment thread or reply chain, supporting threaded conversation\n   * navigation.\n   *\n   * Both authenticated users and visitors can access this operation, but may\n   * see different levels of detail according to permissions. The endpoint is\n   * closely linked with comment creation (POST), update (PUT), and deletion\n   * (DELETE) for participation and moderation flows. Only comments belonging\n   * to the target postId are returned, supporting thread-based exploration\n   * and analysis.\n   *\n   * @param connection\n   * @param postId The unique identifier of the post whose comments are being\n   *   queried.\n   * @param body Options for filtering, pagination, etc., when listing\n   *   comments.\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patchByPostid(\n    @TypedParam(\"postId\")\n    postId: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: bbsComments.IRequest,\n  ): Promise<IPageBbsComments> {\n    postId;\n    body;\n    return typia.random<IPageBbsComments>();\n  }\n\n  /**\n   * Get details for a specific comment (BBS: comments table).\n   *\n   * This API allows users to fetch all available information for one specific\n   * comment within the context of a post. The identifiers ('postId' for the\n   * parent thread, 'id' for the comment itself) ensure accuracy in comment\n   * threading and navigation. The operation returns comment content, author\n   * and timestamp details, metadata, and relations (such as parent reply or\n   * nested replies).\n   *\n   * The endpoint supports use cases like displaying a reply in context,\n   * enabling further replies, or feeding comment moderation workflows. If a\n   * comment is not found or the identifiers do not match, the API returns a\n   * not-found error. Related endpoints include comment listing (PATCH),\n   * creation (POST), updating (PUT), and deletion (DELETE).\n   *\n   * @param connection\n   * @param postId The unique post to which the comment belongs.\n   * @param id The specific comment identifier to retrieve.\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get(\":id\")\n  public async getByPostidAndId(\n    @TypedParam(\"postId\")\n    postId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<bbsComments> {\n    postId;\n    id;\n    return typia.random<bbsComments>();\n  }\n\n  /**\n   * Update an existing comment for a post (BBS: comments table).\n   *\n   * This API lets an authenticated user (comment author or, under special\n   * permissions, a moderator/administrator) update an existing comment\n   * identified by both parent postId and comment id. The system enforces that\n   * updates may only be made to comments the user owns, or by authorized\n   * moderation roles, with all validation constraints on content and\n   * threading.\n   *\n   * Request must specify the target post and comment, supplying new content\n   * and/or thread associations. Invalid references or blank content produces\n   * errors, with history tracking updated timestamps. On success, the new\n   * comment details are returned.\n   *\n   * Business rules ensure audit trails and uphold moderation policies.\n   * Related endpoints include comment creation, deletion, and listing under\n   * post/group context.\n   *\n   * @param connection\n   * @param postId The post to which the comment belongs.\n   * @param id The unique identifier of the comment to update.\n   * @param body Updated values for the comment (e.g., new content, parentId\n   *   for re-threading).\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Put(\":id\")\n  public async putByPostidAndId(\n    @TypedParam(\"postId\")\n    postId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: bbsComments.IUpdate,\n  ): Promise<bbsComments> {\n    postId;\n    id;\n    body;\n    return typia.random<bbsComments>();\n  }\n\n  /**\n   * Delete a specific comment under a post (comments table, soft-delete\n   * logic).\n   *\n   * This operation deletes a comment associated with a particular post in the\n   * political/economic discussion board application. According to the Prisma\n   * schema for the 'comments' table, deleting a comment does not remove the\n   * record from the database, but marks it as deleted by updating the\n   * 'deleted_at' timestamp. This is in line with moderation and audit\n   * requirements described in both the requirement analysis and schema\n   * documentation.\n   *\n   * Authorization is necessary, and only the comment's author, a moderator,\n   * or an administrator may perform this action. Permissions are determined\n   * by checking the user's role, which is represented in the 'users' and\n   * 'user_roles' tables. The endpoint ensures that the specified comment\n   * exists, is associated with the given post, and is not already deleted.\n   * Attempting to delete a non-existent or unrelated comment results in an\n   * error response showing the appropriate message.\n   *\n   * Additionally, the operation maintains an audit trail by recording the\n   * timestamp of deletion, as outlined in the comments schema. The deleted\n   * comment remains for future moderation or review, and cannot be interacted\n   * with by regular members after deletion. Error responses must comply with\n   * API design for invalid IDs, unauthorized access, and logical violations\n   * (such as trying to delete an already deleted comment).\n   *\n   * @param connection\n   * @param postId Target post's ID (the parent of the comment).\n   * @param id Target comment's ID to be deleted.\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Delete(\":id\")\n  public async eraseByPostidAndId(\n    @TypedParam(\"postId\")\n    postId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<void> {\n    postId;\n    id;\n    return typia.random<void>();\n  }\n}\n",
      "src/controllers/bbs/comments/comments/BbsCommentsCommentsController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedParam, TypedBody } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IBbsCommentReply } from \"../../../../api/structures/IBbsCommentReply\";\nimport { IPageIBbsCommentReply } from \"../../../../api/structures/IPageIBbsCommentReply\";\n\n@Controller(\"/bbs/comments/:commentId/comments\")\nexport class BbsCommentsCommentsController {\n  /**\n   * Create a new reply to a specific parent comment (comments table, nested\n   * reply).\n   *\n   * This operation allows registered users to create a new nested reply to an\n   * existing comment. The parent comment is specified by 'commentId'. Input\n   * data includes the reply content and optional metadata (e.g., authored by\n   * user, timestamp auto-handled). The association is created by setting the\n   * new comment's 'parent_id' to the specified 'commentId'.\n   *\n   * The 'comments' table enforces this hierarchy and business rules such as\n   * only registered users may reply, and soft deletion logic applies. Error\n   * handling ensures the parent comment exists and is not deleted. Moderation\n   * or anti-spam business rules (e.g., rate limiting, sensitive word checks)\n   * are referenced from business context but not detailed in schema.\n   *\n   * @param connection\n   * @param commentId Parent comment's ID for threading context.\n   * @param body Reply creation data (e.g., content, optional metadata).\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Post()\n  public async postByCommentid(\n    @TypedParam(\"commentId\")\n    commentId: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IBbsCommentReply.ICreate,\n  ): Promise<IBbsCommentReply> {\n    commentId;\n    body;\n    return typia.random<IBbsCommentReply>();\n  }\n\n  /**\n   * List all direct replies to a specific comment (comments table, threaded\n   * replies).\n   *\n   * This operation retrieves a paginated and optionally filtered list of\n   * replies to a specific parent comment. The 'comments' table supports\n   * self-referential relationships for nested replies via the 'parent_id'\n   * field. Each retrieved comment must have 'parent_id' matching the provided\n   * 'commentId'.\n   *\n   * Standard search, filtering, and pagination options are supported via the\n   * request body. Only direct (not deeply nested) children are included. The\n   * operation checks if the parent comment exists and is not deleted. If\n   * access to the replies is restricted (e.g., if the parent comment is\n   * deleted or private), the API must enforce rules accordingly.\n   *\n   * This operation is commonly used in threaded conversation UIs and supports\n   * constructing the hierarchy of replies for discussion depth and\n   * transparency.\n   *\n   * @param connection\n   * @param commentId Target parent comment's ID whose direct children are\n   *   queried.\n   * @param body Search and pagination options for replies to the comment.\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patchByCommentid(\n    @TypedParam(\"commentId\")\n    commentId: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IBbsCommentReply.IRequest,\n  ): Promise<IPageIBbsCommentReply> {\n    commentId;\n    body;\n    return typia.random<IPageIBbsCommentReply>();\n  }\n\n  /**\n   * Get information for a specific reply to a comment (comments table,\n   * threaded comment).\n   *\n   * This operation fetches the details of a specific reply to a given parent\n   * comment, leveraging the 'comments' table's self-referential structure. It\n   * checks that the reply exists, has its 'parent_id' set to the specified\n   * 'commentId', and is not marked as deleted (soft delete logic).\n   *\n   * Useful for showing reply detail pages or in-line replies in the UI.\n   * Access control ensures that deleted replies or those hidden for\n   * moderation are not shown to ordinary users. The response includes all\n   * major comment fields (content, author, created time, votes, etc.), as\n   * well as any relevant metadata for thread navigation and moderation.\n   *\n   * @param connection\n   * @param commentId Parent comment's ID (pid for threaded reply context).\n   * @param id Reply comment's ID to retrieve.\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get(\":id\")\n  public async getByCommentidAndId(\n    @TypedParam(\"commentId\")\n    commentId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<IBbsCommentReply> {\n    commentId;\n    id;\n    return typia.random<IBbsCommentReply>();\n  }\n\n  /**\n   * Update a reply to a specific comment (comments table, edit threaded\n   * reply).\n   *\n   * This operation updates a reply to a given parent comment in the\n   * 'comments' table. The system ensures that the target reply exists, is a\n   * direct reply to the specified 'commentId', and is not deleted. Only\n   * allowed roles (the author, moderators, administrators) may update the\n   * reply, subject to possible time window constraints (business logic).\n   *\n   * Valid edits include changing the reply's text content and, where business\n   * rules allow, updating moderation status, or fixing accidental errors. The\n   * history is retained via an updated_at timestamp. Editing is restricted if\n   * a reply has been deleted (soft delete) or if the editing time window has\n   * expired. Response provides the updated reply details.\n   *\n   * @param connection\n   * @param commentId Parent comment's ID for context.\n   * @param id Reply comment's ID to update.\n   * @param body Fields to update in the reply (e.g., new content, metadata).\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Put(\":id\")\n  public async putByCommentidAndId(\n    @TypedParam(\"commentId\")\n    commentId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IBbsCommentReply.IUpdate,\n  ): Promise<IBbsCommentReply> {\n    commentId;\n    id;\n    body;\n    return typia.random<IBbsCommentReply>();\n  }\n\n  /**\n   * Delete a reply to a specific comment (comments table, soft-delete\n   * moderation logic).\n   *\n   * This operation deletes a reply (nested comment) from a parent comment, as\n   * defined in the self-referential structure of the 'comments' table.\n   * Instead of a hard delete, it sets the 'deleted_at' field, preserving the\n   * reply for moderation history and audit purposes.\n   *\n   * Only the reply's author, moderators, or administrators are authorized to\n   * perform this action. Role mapping is enforced using data from 'users' and\n   * 'user_roles' tables. The operation checks that the reply exists and is a\n   * direct child of the specified parent comment.\n   *\n   * On error (e.g., invalid parent-child relationship, reply already deleted,\n   * lack of permission), the system returns appropriate error codes/messages.\n   * This ensures clean handling of thread integrity and preserves\n   * conversation structure.\n   *\n   * @param connection\n   * @param commentId Parent comment's ID for context.\n   * @param id Reply comment's ID to delete.\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Delete(\":id\")\n  public async eraseByCommentidAndId(\n    @TypedParam(\"commentId\")\n    commentId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<void> {\n    commentId;\n    id;\n    return typia.random<void>();\n  }\n}\n",
      "src/controllers/bbs/votes/BbsVotesController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody, TypedParam } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IBbsVote } from \"../../../api/structures/IBbsVote\";\nimport { IPageIBbsVote } from \"../../../api/structures/IPageIBbsVote\";\n\n@Controller(\"/bbs/votes\")\nexport class BbsVotesController {\n  /**\n   * Create a new vote for a post or comment (votes table, upvote/downvote\n   * logic).\n   *\n   * This operation creates a new vote record for the given user on the\n   * specified target (either a post or a comment) as per the 'votes' table\n   * structure. The request body must specify which target is being voted on,\n   * and the value (either +1 or -1 per business rule).\n   *\n   * Business logic includes unique user/target constraint (a user cannot vote\n   * twice on the same post or comment). On success, returns the created vote\n   * resource. If the vote already exists, the system returns an appropriate\n   * error or suggests updating the vote. Only authenticated users may vote.\n   * Permissions and audit trail are enforced as per requirements analysis and\n   * database comments.\n   *\n   * @param connection\n   * @param body Vote creation input (target type, target ID, value).\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Post()\n  public async post(\n    @TypedBody()\n    body: IBbsVote.ICreate,\n  ): Promise<IBbsVote> {\n    body;\n    return typia.random<IBbsVote>();\n  }\n\n  /**\n   * Query/search all votes across posts/comments (votes table, patch for\n   * advanced search).\n   *\n   * This operation returns a paginated and/or filtered list of votes. The\n   * 'votes' table supports querying by voter, content (post or comment), vote\n   * value, and timestamp. Filtering and pagination information are specified\n   * via the request body. This operation is intended for use by\n   * administrators, moderators, or analytics tools. Business rules enforce\n   * visibility (e.g., users see only their own votes unless they have\n   * elevated permissions).\n   *\n   * Standard pagination, search, and sorting are provided. Errors for invalid\n   * parameters or unauthorized access are handled according to platform\n   * requirements.\n   *\n   * @param connection\n   * @param body Filters, pagination, and search fields for querying vote\n   *   records.\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patch(\n    @TypedBody()\n    body: IBbsVote.IRequest,\n  ): Promise<IPageIBbsVote> {\n    body;\n    return typia.random<IPageIBbsVote>();\n  }\n\n  /**\n   * Get a single vote record's details (votes table, role/visibility\n   * protection).\n   *\n   * This operation retrieves a single vote by its ID. Information includes\n   * which user cast the vote (user_id), what it targeted (either a post or\n   * comment), the value (+1 or -1, as per schema), and relevant timestamps.\n   * The operation consults the 'votes' table directly by primary key.\n   *\n   * Business logic ensures that vote records are visible only to the voter\n   * themselves or users with elevated privileges. Sensitive data handling\n   * observes privacy, as votes reflect user opinions which may need to remain\n   * confidential, per the requirements analysis. Errors are returned for\n   * invalid IDs or unauthorized access.\n   *\n   * @param connection\n   * @param id Vote record's ID to be fetched.\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get(\":id\")\n  public async getById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<IBbsVote> {\n    id;\n    return typia.random<IBbsVote>();\n  }\n\n  /**\n   * Update an existing vote (votes table, upvote/downvote change).\n   *\n   * This operation updates an existing vote, which is identified by its\n   * unique ID. Only the owner (voter) of the vote or privileged roles\n   * (moderator/admin) may perform updates. Fields that can be changed include\n   * 'value' (e.g., switch an upvote to a downvote) and potentially metadata\n   * (e.g., audit fields). The business rules from the schema and requirements\n   * analysis govern what can be changed and by whom.\n   *\n   * Changes are reflected in the database and in derived content tallies.\n   * Errors are returned if update rules are violated (e.g., changing someone\n   * else's vote, updating a vote that doesn't exist, improper value\n   * assignment). On success, returns updated vote resource.\n   *\n   * @param connection\n   * @param id Vote record's ID to update.\n   * @param body Updated vote fields (e.g., value).\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Put(\":id\")\n  public async putById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IBbsVote.IUpdate,\n  ): Promise<IBbsVote> {\n    id;\n    body;\n    return typia.random<IBbsVote>();\n  }\n\n  /**\n   * Delete a vote (votes table, enforced by unique user/target constraint).\n   *\n   * This operation deletes a vote record from the database. Only the vote's\n   * owner (voter) or privileged roles (moderator/admin, based on\n   * 'user_roles') can perform this operation. It removes the vote, freeing up\n   * the user to vote again on the same post or comment in the future (as\n   * controlled by unique constraints in the votes schema).\n   *\n   * Error responses are returned if the request is forbidden, the vote does\n   * not exist, or the operation is not permitted for the resource. The\n   * operation complies with audit and permission rules from requirements\n   * analysis and schema.\n   *\n   * @param connection\n   * @param id Vote record's ID to delete.\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Delete(\":id\")\n  public async eraseById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<void> {\n    id;\n    return typia.random<void>();\n  }\n}\n",
      "src/api/structures/IBbsUsers.ts": "import { tags } from \"typia\";\n\nimport { IBbsUserRoles } from \"./IBbsUserRoles\";\n\n/**\n * User profile record (non-sensitive).\n *\n * Implements all fields in users Prisma model except password_hash. Used in\n * administration, moderation, onboarding, audit, and display. Documentation\n * references requirements document and Prisma schema comment.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IBbsUsers = {\n  /**\n   * Unique identifier for this user (UUID).\n   *\n   * Primary key in users table. Referenced for moderation, profile editing,\n   * and all user-based operations.\n   */\n  id: string & tags.Format<\"uuid\">;\n\n  /**\n   * User's assigned role (UUID, references user_roles.id).\n   *\n   * Provides permissions and grants system; links user to allowable actions.\n   */\n  user_role_id: string & tags.Format<\"uuid\">;\n\n  /**\n   * Unique public handle for the user, visible on posts and comments.\n   *\n   * As outlined in requirements analysis, serves as user identity for\n   * platform interaction.\n   */\n  username: string;\n\n  /**\n   * User's registered email address.\n   *\n   * Used for notifications, authentication, and support. Not public by\n   * default.\n   */\n  email: string;\n\n  /**\n   * Short biographical text the user may choose to display.\n   *\n   * User-supplied for platform personalization; optional.\n   */\n  bio?: string | null;\n\n  /**\n   * Registration timestamp (ISO8601).\n   *\n   * When this user joined the platform. Used for audits, sorting, compliance.\n   */\n  created_at: string & tags.Format<\"date-time\">;\n\n  /**\n   * Timestamp of last profile/account update (ISO8601).\n   *\n   * Tracks account edit history/maintenance.\n   */\n  updated_at: string & tags.Format<\"date-time\">;\n\n  /**\n   * Current account state (e.g., active, suspended, banned).\n   *\n   * Essential for enforcing moderation/business logic as described in\n   * requirements.\n   */\n  status: string;\n\n  /**\n   * Full role record for this user (joined on user_role_id).\n   *\n   * Provides name and description for UI display and permissions checks.\n   */\n  role: IBbsUserRoles;\n};\nexport namespace IBbsUsers {\n  /**\n   * User search/list/filter request.\n   *\n   * Used in user administration and browsing interfaces to retrieve filtered,\n   * paginated user lists as described in requirements analysis\n   * (moderators/administrators). Properties correspond to search and filter\n   * dimensions for the users Prisma table.\n   */\n  export type IRequest = {\n    /**\n     * Page number for paginated user listing.\n     *\n     * Corresponds to IPage.IRequest. Optional; if omitted, results default\n     * to the first page. Referenced in user administration and search\n     * flows.\n     */\n    page?: (number & tags.Type<\"int32\">) | null;\n\n    /**\n     * Limitation of records per page for user search.\n     *\n     * Defaults to 100. Allows tuning the result batch size for moderation\n     * or administrative user views.\n     */\n    limit?: (number & tags.Type<\"int32\">) | null;\n\n    /**\n     * User role filter. Return only users with this role (matches\n     * user_roles.id or name).\n     *\n     * Supports moderator/admin filtering by user class (member,\n     * administrator, etc.).\n     */\n    role?: string | null;\n\n    /**\n     * Filter users by account status (e.g., active, suspended, banned).\n     *\n     * Supports workflow for monitoring and moderation of access levels.\n     */\n    status?: string | null;\n\n    /**\n     * Filter by exact or partial match on user email.\n     *\n     * Assists in locating specific accounts for administrative intervention\n     * or support.\n     */\n    email?: string | null;\n\n    /**\n     * Filter by username (complete or partial match).\n     *\n     * Used for public moderation, searching individual participants, or\n     * audit tasks.\n     */\n    username?: string | null;\n\n    /**\n     * Filter for users registered after the given timestamp (ISO8601\n     * format).\n     *\n     * Used to find recent registrations or perform time-based audits.\n     */\n    registered_after?: (string & tags.Format<\"date-time\">) | null;\n\n    /**\n     * Filter for users registered before the given timestamp (ISO8601\n     * format).\n     *\n     * Used to look up users registered before a certain date.\n     */\n    registered_before?: (string & tags.Format<\"date-time\">) | null;\n\n    /**\n     * Sort order (username, email, created_at).\n     *\n     * For user management screens, allows control of user list ordering.\n     */\n    sort_by?: \"username\" | \"email\" | \"created_at\" | null;\n\n    /**\n     * Sorting direction for user list.\n     *\n     * 'asc' for ascending, 'desc' for descending.\n     */\n    sort_order?: \"asc\" | \"desc\" | null;\n  };\n\n  /**\n   * Registration payload for new users.\n   *\n   * Implements onboarding/registration parameters as described in\n   * requirements and reflected in Prisma users table. Only non-sensitive\n   * initial account data permitted.\n   */\n  export type ICreate = {\n    /**\n     * Desired username (must be unique).\n     *\n     * Mandatory for registration and public identity, per requirements\n     * analysis.\n     */\n    username: string;\n\n    /**\n     * Email address to register (unique, notified on events).\n     *\n     * Used for login and notifications.\n     */\n    email: string;\n\n    /**\n     * Initial user password (supplied in plain form, will be hashed on\n     * storage).\n     *\n     * Never returned in API. Enforced by strong password policies.\n     */\n    password: string;\n\n    /**\n     * Optional biographical text.\n     *\n     * User profile customization, as outlined in requirements.\n     */\n    bio?: string | null;\n\n    /**\n     * Role assignment (UUID from user_roles.id).\n     *\n     * Specifies initial user permissions (e.g., member, moderator,\n     * administrator). Determines access scope for new account creation.\n     */\n    role_id: string & tags.Format<\"uuid\">;\n  };\n\n  /**\n   * Update payload for user profile/account.\n   *\n   * Implements the user and administrative self-update, moderation, and\n   * profile-edit flows described in requirements analysis and Prisma schema.\n   * All fields optional for PATCH/PUT semantics.\n   */\n  export type IUpdate = {\n    /**\n     * New username, if changing. Must remain unique.\n     *\n     * May only be updated by the user or privileged roles.\n     */\n    username?: string | null;\n\n    /**\n     * Email address for changing login/notifications. Must remain unique.\n     *\n     * Admin or user-only operation.\n     */\n    email?: string | null;\n\n    /**\n     * Updated bio (profile description).\n     *\n     * Used for user self-edit or admin-moderator workflow.\n     */\n    bio?: string | null;\n\n    /**\n     * Status value (active, suspended, banned, etc).\n     *\n     * May be set by authorized roles per moderation/business rules.\n     */\n    status?: string | null;\n\n    /**\n     * New role assignment for the user (user_roles.id).\n     *\n     * For admin-only role changes (e.g., promotion to\n     * moderator/administrator).\n     */\n    role_id?: (string & tags.Format<\"uuid\">) | null;\n  };\n}\n",
      "src/api/structures/IPageIBbsUsers.ts": "import { IPage } from \"./IPage\";\nimport { IBbsUsers } from \"./IBbsUsers\";\n\n/**\n * Paginated user list container.\n *\n * Standard paginated interface (see IPage), adapted for listing users,\n * corresponding to search, moderation, or audit interface needs.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IPageIBbsUsers = {\n  pagination: IPage.IPagination;\n\n  /**\n   * Array of user objects on this page of results.\n   *\n   * Each entry is a non-sensitive user representation for administration or\n   * moderation.\n   */\n  data: IBbsUsers[];\n};\n",
      "src/api/structures/IBbsUserRoles.ts": "import { tags } from \"typia\";\n\n/**\n * User role metadata record.\n *\n * Implements the business logic of platform roles as described in requirements\n * and user_roles table.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IBbsUserRoles = {\n  /**\n   * Unique identifier for user role (UUID).\n   *\n   * Primary key from user_roles.\n   */\n  id: string & tags.Format<\"uuid\">;\n\n  /**\n   * Unique label for the user role (e.g., member, moderator, administrator).\n   *\n   * Fulfills role business logic and governance, per requirements.\n   */\n  name: string;\n\n  /**\n   * Detailed explanation of the role's permissions, scope, or duties.\n   *\n   * Shown in onboarding and administration to explain role scope.\n   */\n  description: string;\n};\nexport namespace IBbsUserRoles {\n  /**\n   * Filter/search payload for user_roles listing.\n   *\n   * Enables administrative workflows for governance, onboarding, and audit\n   * per requirements analysis.\n   */\n  export type IRequest = {\n    /**\n     * Requested page of role results.\n     *\n     * Adheres to pagination standard (see IPage.IRequest).\n     */\n    page?: (number & tags.Type<\"int32\">) | null;\n\n    /**\n     * Maximum number of roles per page.\n     *\n     * Default is 100; supports admin audit or onboarding configuration.\n     */\n    limit?: (number & tags.Type<\"int32\">) | null;\n\n    /**\n     * Role name filter (exact or pattern match).\n     *\n     * For filtering available roles by label in role management interface.\n     */\n    name?: string | null;\n\n    /**\n     * Keyword match on the role description.\n     *\n     * Helps administrators or business workflows find newly created roles\n     * or audit permissions.\n     */\n    description?: string | null;\n  };\n\n  /**\n   * Payload to create a new user role.\n   *\n   * Used for onboarding/registration configuration and extending\n   * moderation/business model, as per requirements and schema.\n   */\n  export type ICreate = {\n    /**\n     * Role label (unique, required).\n     *\n     * Required for creating new permissions classes in system governance.\n     */\n    name: string;\n\n    /**\n     * Human-readable explanation of the role's authority and purpose.\n     *\n     * For oversight and onboarding display.\n     */\n    description: string;\n  };\n\n  /**\n   * Payload to update an existing role.\n   *\n   * All fields optional for PUT/PATCH behaviors, as per requirements analysis\n   * and schema comments.\n   */\n  export type IUpdate = {\n    /**\n     * New name/label for user role, if changing.\n     *\n     * Must remain unique if provided.\n     */\n    name?: string | null;\n\n    /**\n     * Updated explanation for the role (e.g., changing duties, scope).\n     *\n     * Administrative update only.\n     */\n    description?: string | null;\n  };\n}\n",
      "src/api/structures/IPageIBbsUserRoles.ts": "import { IPage } from \"./IPage\";\nimport { IBbsUserRoles } from \"./IBbsUserRoles\";\n\n/**\n * Paginated user role results container.\n *\n * Standard pagination (see IPage), extended for user role record listing, used\n * in administrative and onboarding contexts.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IPageIBbsUserRoles = {\n  pagination: IPage.IPagination;\n\n  /** List of user role objects for this result page. */\n  data: IBbsUserRoles[];\n};\n",
      "src/api/structures/IBbsCategories.ts": "import { tags } from \"typia\";\n\n/**\n * Represents discussion board categories, such as Politics or Economics.\n *\n * Reflects the categories entity from the business requirements and the\n * `categories` table in the Prisma schema. Contains a unique ID, name,\n * description, and creation timestamp. Categories organize posts and are\n * managed by administrators.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IBbsCategories = {\n  /**\n   * Unique identifier for the category, corresponding to the `id` primary key\n   * in the categories Prisma model.\n   *\n   * This ID is system-generated and is used throughout API requests when\n   * referencing categories. Fulfills the 'Category' entity requirements from\n   * the business and data structure specifications.\n   */\n  id: string & tags.Format<\"uuid\">;\n\n  /**\n   * The human-readable name of the category, corresponding to the `name`\n   * column in the categories table.\n   *\n   * This value must be unique. It is used in navigation, filtering posts, and\n   * display for end users. As per the requirements, examples might be\n   * 'Politics', 'Economics', or 'International Affairs'.\n   */\n  name: string;\n\n  /**\n   * A description of the category, corresponding to the `description` column\n   * in the database.\n   *\n   * This field clarifies the scope and focus of the discussion for posts\n   * under this category, e.g., 'Discussion about domestic and international\n   * political systems, governance, and related events.'\n   */\n  description: string;\n\n  /**\n   * The timestamp when the category was created, matching `created_at` in the\n   * categories schema.\n   *\n   * Used for audit trails, admin reporting, and chronological display of\n   * categories.\n   */\n  created_at: string & tags.Format<\"date-time\">;\n};\nexport namespace IBbsCategories {\n  /**\n   * Category list/search request payload.\n   *\n   * Implements category exploration, onboarding, navigation, and\n   * administrative audit flows from requirements analysis.\n   */\n  export type IRequest = {\n    /**\n     * Requested page number for category result listing.\n     *\n     * Supports pagination consistent with IPage.IRequest standard.\n     */\n    page?: (number & tags.Type<\"int32\">) | null;\n\n    /**\n     * Maximum categories to return per page (default 100).\n     *\n     * Used to manage category lists in creation, onboarding, or admin\n     * flows.\n     */\n    limit?: (number & tags.Type<\"int32\">) | null;\n\n    /**\n     * Filter/search by category name (pattern or exact match).\n     *\n     * Supports navigation and management per requirements logic.\n     */\n    name?: string | null;\n\n    /**\n     * Filter/search by category description content.\n     *\n     * Allows admin management and onboarding support for new users.\n     */\n    description?: string | null;\n  };\n}\n",
      "src/api/structures/IPageIBbsCategories.ts": "import { IPage } from \"./IPage\";\nimport { IBbsCategories } from \"./IBbsCategories\";\n\n/**\n * Paginated category listing container.\n *\n * Standard interface for listing available topic categories for post\n * assignment, UI navigation, or admin workflows.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IPageIBbsCategories = {\n  pagination: IPage.IPagination;\n\n  /** Array of category metadata objects on this page. */\n  data: IBbsCategories[];\n};\n",
      "src/api/structures/IPage.ts": "import { tags } from \"typia\";\n\nexport namespace IPage {\n  /**\n   * Pagination information for paginated results. Used in all IPage<T>\n   * structures; see standard type definition.\n   */\n  export type IPagination = {\n    /** Current page number. */\n    current: number &\n      tags.Type<\"int32\"> &\n      tags.JsonSchemaPlugin<{\n        format: \"uint32\";\n      }>;\n\n    /** Number of records per page. Default is 100. */\n    limit: number &\n      tags.Type<\"int32\"> &\n      tags.JsonSchemaPlugin<{\n        format: \"uint32\";\n      }>;\n\n    /** Total number of records in the result set. */\n    records: number &\n      tags.Type<\"int32\"> &\n      tags.JsonSchemaPlugin<{\n        format: \"uint32\";\n      }>;\n\n    /** Total pages. Equal to records/limit with ceiling. */\n    pages: number &\n      tags.Type<\"int32\"> &\n      tags.JsonSchemaPlugin<{\n        format: \"uint32\";\n      }>;\n  };\n}\n",
      "src/api/structures/bbsCategories.ts": "import { IBbsCategories } from \"./IBbsCategories\";\n\n/**\n * Alias to IBbsCategories. Used for legacy/type consistency in endpoints\n * referring to category entities. Ensures consistent documentation and code\n * use.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type bbsCategories = IBbsCategories;\nexport namespace bbsCategories {\n  /**\n   * Payload for creating a new category.\n   *\n   * Used by administrators via the create category API to add organizational\n   * topics, matching the 'categories' table structure.\n   */\n  export type ICreate = {\n    /**\n     * The unique name for the new category, as per the `name` field in the\n     * categories table.\n     *\n     * Must be non-empty and unique among all categories. Used for users to\n     * navigate posts and choose topics.\n     */\n    name: string;\n\n    /**\n     * Description for the new category, giving users information about the\n     * scope and focus. Taken from the `description` field in the categories\n     * schema.\n     *\n     * Must be non-empty. This is shown to users when posting or browsing.\n     */\n    description: string;\n  };\n\n  /**\n   * Payload for updating an existing category.\n   *\n   * Sent by administrators to modify category name or description. Matches\n   * structure and constraints of the `categories` table.\n   */\n  export type IUpdate = {\n    /**\n     * The new or updated name for this category, as per the `name` column\n     * in the categories table.\n     *\n     * Must remain unique and non-empty.\n     */\n    name: string;\n\n    /**\n     * Updated description for the category, as per the `description` column\n     * in the schema.\n     *\n     * Must also be non-empty.\n     */\n    description: string;\n  };\n}\n",
      "src/api/structures/bbsPosts.ts": "import { tags } from \"typia\";\n\n/**\n * Represents a discussion post (thread) on the platform, matching the posts\n * entity from the requirements analysis and the posts table in the Prisma\n * schema.\n *\n * Provides all information about the post, including subject/title, content,\n * author ID, category, timestamps, and deletion flag for moderation.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type bbsPosts = {\n  /**\n   * Unique identifier of the post. The `id` field in the posts model.\n   *\n   * Used for referencing the post in API calls or links.\n   */\n  id: string & tags.Format<\"uuid\">;\n\n  /**\n   * UUID of the user (author) who created this post, corresponding to\n   * `user_id` in the posts table.\n   *\n   * Provides author traceability and links to user profiles.\n   */\n  user_id: string & tags.Format<\"uuid\">;\n\n  /**\n   * UUID of the category under which the post was published, referencing\n   * `category_id` in the posts table.\n   *\n   * Supports topic-based navigation and organization.\n   */\n  category_id: string & tags.Format<\"uuid\">;\n\n  /**\n   * The post's headline/title. Implements the required `title` property in\n   * the posts schema.\n   *\n   * Prominently displayed in thread lists and views.\n   */\n  title: string;\n\n  /**\n   * Main content/body of the post, from the `content` field in the posts\n   * table.\n   *\n   * Includes long-form text, opinion, or analysis. Critical for community\n   * discussion.\n   */\n  content: string;\n\n  /**\n   * The timestamp when the post was created, matching `created_at` in the\n   * database.\n   *\n   * Displayed in lists, used for freshness ordering, and necessary for\n   * audits.\n   */\n  created_at: string & tags.Format<\"date-time\">;\n\n  /**\n   * Last modification timestamp, from `updated_at` in the posts record.\n   *\n   * Enables edit history tracking and evidence of moderation or typo\n   * corrections.\n   */\n  updated_at: string & tags.Format<\"date-time\">;\n\n  /**\n   * If present, this timestamp indicates when the post was soft-deleted (not\n   * physically removed), in line with moderation and audit business rules.\n   *\n   * Null if the post is currently visible.\n   */\n  deleted_at?: (string & tags.Format<\"date-time\">) | null;\n};\nexport namespace bbsPosts {\n  /**\n   * Request parameters for listing or searching posts in the discussion\n   * board.\n   *\n   * Implements filtering, sorting, and pagination features for the `posts`\n   * entity. Matches 'bbsPosts.IRequest' business requirements and supports\n   * advanced exploration of post listings.\n   */\n  export type IRequest = {\n    /**\n     * A search string to filter posts by keyword in the title or content.\n     *\n     * Helps users find posts matching specific topics. May use advanced\n     * search or simple substring matching.\n     */\n    query?: string;\n\n    /**\n     * Filters posts to those belonging to this category, referencing\n     * `category_id` in the posts table.\n     *\n     * Enables category-based navigation or analysis.\n     */\n    category_id?: string & tags.Format<\"uuid\">;\n\n    /**\n     * The field to sort posts by when listing results.\n     *\n     * Typically one of: 'created_at' (date posted), 'updated_at', 'title',\n     * or 'votes' (tally of upvotes/downvotes).\n     */\n    sort_by?: \"created_at\" | \"updated_at\" | \"title\" | \"votes\";\n\n    /**\n     * Specifies the order (ascending or descending) of the sort. Example:\n     * 'desc' for newest first, 'asc' for alphabetical.\n     */\n    order?: \"asc\" | \"desc\";\n\n    /**\n     * The page number to request (for pagination).\n     *\n     * Defaults to 1 if omitted.\n     */\n    page?: number &\n      tags.Type<\"int32\"> &\n      tags.JsonSchemaPlugin<{\n        format: \"int32\";\n      }>;\n\n    /**\n     * Maximum number of posts to return per page (pagination limit).\n     *\n     * Typical values are 10, 20, or 50 per page. Defaults may apply if\n     * omitted.\n     */\n    limit?: number &\n      tags.Type<\"int32\"> &\n      tags.JsonSchemaPlugin<{\n        format: \"int32\";\n      }>;\n  };\n\n  /**\n   * Payload for creating a new post in the discussion board.\n   *\n   * Links the new post to a specific category, supplies a title and content.\n   * Used by regular users during post creation workflows.\n   */\n  export type ICreate = {\n    /**\n     * UUID for the category where the post is to be published. Implements\n     * the business logic in the posts model requiring category assignment.\n     *\n     * Must refer to an existing category.\n     */\n    category_id: string & tags.Format<\"uuid\">;\n\n    /**\n     * Headline/title for the post. Required field representing the core\n     * subject or summary for the thread.\n     *\n     * Must be non-empty, per business and schema rules.\n     */\n    title: string;\n\n    /**\n     * Main content/body of the post. Required for meaningful discussion.\n     *\n     * Must be non-empty, and may include text, links, or analysis.\n     */\n    content: string;\n  };\n\n  /**\n   * Payload for updating a post. Sent by the author, moderator, or admin to\n   * edit post category, headline, or content.\n   *\n   * All fields are required; aligns with edit operation semantics in business\n   * requirements.\n   */\n  export type IUpdate = {\n    /**\n     * New or updated UUID for the category the post is assigned to.\n     *\n     * Changes the post's topical placement. Must reference an existing\n     * category.\n     */\n    category_id: string & tags.Format<\"uuid\">;\n\n    /**\n     * New or updated headline/title for the post. Subject to uniqueness or\n     * non-emptiness per business and schema rules.\n     */\n    title: string;\n\n    /**\n     * Updated body/content of the post. Required for substantial updates.\n     * Subject to moderation and editability constraints.\n     */\n    content: string;\n  };\n}\n",
      "src/api/structures/IPageBbsPosts.ts": "import { IPage } from \"./IPage\";\nimport { bbsPosts } from \"./bbsPosts\";\n\n/**\n * Paginated result wrapper for posts listing operations.\n *\n * Holds an array of post records and pagination metadata, following IPage<T>\n * business conventions.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IPageBbsPosts = {\n  pagination: IPage.IPagination;\n\n  /** List of post records for this page, matching the query/filter. */\n  data: bbsPosts[];\n};\n",
      "src/api/structures/bbsComments.ts": "import { tags } from \"typia\";\n\n/**\n * Represents a comment entity in the discussion board. Used for both top-level\n * and nested/threaded replies.\n *\n * Fully aligns with the comments entity as specified in the requirements and\n * comments table in the Prisma schema, including parent-child threading, audit,\n * and moderation soft-delete support.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type bbsComments = {\n  /**\n   * Unique identifier for the comment, `id` primary key from the comments\n   * table.\n   *\n   * Used system-wide to reference comments in API operations and thread\n   * navigation.\n   */\n  id: string & tags.Format<\"uuid\">;\n\n  /**\n   * UUID of the user who wrote this comment, matching `user_id` in comments\n   * table.\n   *\n   * Used for author audits, reply tracking, and profile linking.\n   */\n  user_id: string & tags.Format<\"uuid\">;\n\n  /**\n   * UUID of the post this comment is attached to, from `post_id` in the\n   * comments table.\n   *\n   * Critical for threading, structure, and navigation of discussion posts.\n   */\n  post_id: string & tags.Format<\"uuid\">;\n\n  /**\n   * If present, this is the UUID of the parent comment, enabling\n   * threading/nesting of replies. Nullable for top-level comments.\n   *\n   * Implements self-referential comment hierarchy as explained in\n   * requirements and Prisma schema.\n   */\n  parent_id?: (string & tags.Format<\"uuid\">) | null;\n\n  /**\n   * Body/content of the comment, from the `content` field in comments table.\n   *\n   * Carries user opinion, replies, and substantive discussion.\n   */\n  content: string;\n\n  /**\n   * Timestamp for comment creation, from `created_at` column.\n   *\n   * Used in chronological sorting, audit, and moderation.\n   */\n  created_at: string & tags.Format<\"date-time\">;\n\n  /**\n   * Timestamp for last update of the comment, as per `updated_at` field.\n   *\n   * Reflects edit history and moderation actions.\n   */\n  updated_at: string & tags.Format<\"date-time\">;\n\n  /**\n   * Soft deletion flag (if present) indicating when this comment was\n   * 'deleted' for moderation, but not physically removed from the database.\n   *\n   * Null if currently active.\n   */\n  deleted_at?: (string & tags.Format<\"date-time\">) | null;\n};\nexport namespace bbsComments {\n  /**\n   * Request parameters for listing/searching comments under a post.\n   *\n   * Supports author filtering, time range selection, sorting, and\n   * pagination—matching audit and moderation needs for nested comment\n   * threads.\n   */\n  export type IRequest = {\n    /**\n     * Optional filter to list only comments written by the specified user,\n     * matching `user_id` in comments table.\n     *\n     * Supports audit and user-based navigation.\n     */\n    author_id?: string & tags.Format<\"uuid\">;\n\n    /**\n     * Optional start date/time for filtering comments.\n     *\n     * Used for moderating recent activity, historical review, or analytics.\n     */\n    created_after?: string & tags.Format<\"date-time\">;\n\n    /** Optional end date/time for filtering comments. */\n    created_before?: string & tags.Format<\"date-time\">;\n\n    /**\n     * Defines the sorting field for the comment list. Typical values are\n     * 'created_at' or 'updated_at'.\n     */\n    sort_by?: \"created_at\" | \"updated_at\";\n\n    /**\n     * Direction of sorting order applied. 'desc' for most recent first,\n     * 'asc' for chronological.\n     */\n    order?: \"asc\" | \"desc\";\n\n    /** Result page number for pagination. Defaults to 1 if omitted. */\n    page?: number &\n      tags.Type<\"int32\"> &\n      tags.JsonSchemaPlugin<{\n        format: \"int32\";\n      }>;\n\n    /**\n     * Maximum number of comments per page, supporting pagination for large\n     * threads.\n     */\n    limit?: number &\n      tags.Type<\"int32\"> &\n      tags.JsonSchemaPlugin<{\n        format: \"int32\";\n      }>;\n  };\n\n  /**\n   * Model for creating a new comment on a post or as a reply to another\n   * comment.\n   *\n   * Based on the requirements document and comments schema, this interface\n   * allows users to create either a top-level comment or a nested reply. Only\n   * registered users may comment. Thread assignment is supported via optional\n   * parent_id.\n   */\n  export type ICreate = {\n    /**\n     * Comment body text.\n     *\n     * This property contains the text that will be displayed as the content\n     * of the comment. It implements the rule that each comment consists of\n     * user-written content. For example: 'I agree and here’s why...'.\n     * Referenced from the 'content' column in the Prisma comments model and\n     * per requirements in 03_data_structure_and_business_rules.md.\n     */\n    content: string;\n\n    /**\n     * The ID of the parent comment for nested/threaded replies. Nullable\n     * for top-level comments (direct replies to posts).\n     *\n     * Referenced from 'parent_id' in the comments Prisma schema. Implements\n     * thread/nesting support and conversation branching per requirements.\n     */\n    parent_id?: (string & tags.Format<\"uuid\">) | null;\n  };\n\n  /**\n   * Model for updating an existing comment. Allows comment text to be edited\n   * subject to audit and ownership rules (see Prisma comment model and\n   * requirements analysis).\n   */\n  export type IUpdate = {\n    /**\n     * Updated comment body text.\n     *\n     * Changed content for this comment. Enforces non-empty value and\n     * transparent audit trails, per the 'content' column in comments Prisma\n     * model.\n     */\n    content: string;\n  };\n}\n",
      "src/api/structures/IPageBbsComments.ts": "import { IPage } from \"./IPage\";\nimport { bbsComments } from \"./bbsComments\";\n\n/**\n * Paginated response wrapper for comments list/search APIs.\n *\n * Holds the page of comment records and pagination info, conforming to platform\n * standards for large thread handling.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IPageBbsComments = {\n  pagination: IPage.IPagination;\n\n  /** Array of comments for the result page. */\n  data: bbsComments[];\n};\n",
      "src/api/structures/IBbsCommentReply.ts": "import { tags } from \"typia\";\n\n/**\n * A single reply comment/nested reply object.\n *\n * Represents a direct response to a parent comment (or a top-level post reply).\n * Includes all evidence required for auditing, threading, and moderation.\n * Referenced from threaded/nested replies in comments Prisma model.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IBbsCommentReply = {\n  /**\n   * Unique identifier for the comment reply.\n   *\n   * Primary key from the comments Prisma model. Used for programmatic\n   * operations and API lookups.\n   */\n  id: string & tags.Format<\"uuid\">;\n\n  /**\n   * Identifier for the authoring user of this reply comment.\n   *\n   * References users.id. Used for attribution, audit, and profile summary\n   * features.\n   */\n  user_id: string & tags.Format<\"uuid\">;\n\n  /**\n   * Identifier for the parent post to which this reply (comment) belongs.\n   *\n   * References posts.id. Required for evidence/auditing, threading context,\n   * and navigation (see ERD and comments model).\n   */\n  post_id: string & tags.Format<\"uuid\">;\n\n  /**\n   * Identifier for the parent comment if this is a reply (threading\n   * hierarchy). Null for top-level (post) replies, set for nested replies.\n   *\n   * Mapped from comments.parent_id in the Prisma schema.\n   */\n  parent_id?: (string & tags.Format<\"uuid\">) | null;\n\n  /**\n   * Reply body text for this comment. Business meaning: user-supplied message\n   * or opinion as per 'content' in Prisma model.\n   */\n  content: string;\n\n  /**\n   * Timestamp for when the reply comment was created (ISO 8601 format).\n   *\n   * Taken from comments.created_at. Important for audit/history, proper\n   * ordering, and moderation evidence.\n   */\n  created_at: string & tags.Format<\"date-time\">;\n\n  /**\n   * Timestamp for last edit. Reflects edit history and transparency for\n   * users/moderators. Maps to comments.updated_at field.\n   */\n  updated_at: string & tags.Format<\"date-time\">;\n\n  /**\n   * If set, indicates the reply was deleted (soft delete logic). Used for\n   * moderation/audit preservation. Matches comments.deleted_at.\n   */\n  deleted_at?: (string & tags.Format<\"date-time\">) | null;\n};\nexport namespace IBbsCommentReply {\n  /**\n   * Parameters for listing or searching child replies to a specific comment.\n   * Implements filtering/pagination for nested replies based on standard\n   * IPage IRequest schema.\n   */\n  export type IRequest = {\n    /**\n     * Page number for pagination (optional). Allows navigating through\n     * multiple pages of replies. See standard 'IPage' interface\n     * definition.\n     */\n    page?:\n      | (number &\n          tags.Type<\"int32\"> &\n          tags.JsonSchemaPlugin<{\n            format: \"uint32\";\n          }>)\n      | null;\n\n    /**\n     * Number of replies per page (optional). Defaults to 100 if not\n     * specified. See IPage.IRequest standard type.\n     */\n    limit?:\n      | (number &\n          tags.Type<\"int32\"> &\n          tags.JsonSchemaPlugin<{\n            format: \"uint32\";\n          }>)\n      | null;\n  };\n\n  /**\n   * Payload for creating a new reply (nested comment) to a parent comment.\n   * Enforces required comment body, referenced from comments Prisma model and\n   * requirements analysis.\n   */\n  export type ICreate = {\n    /**\n     * Reply content (body text). User-supplied message or opinion\n     * contributed as a nested reply. From comments.content Prisma field.\n     */\n    content: string;\n  };\n\n  /**\n   * Edit/update payload for a reply comment (nested thread). Allows the reply\n   * content to be changed. Ownership and audit rules apply.\n   */\n  export type IUpdate = {\n    /**\n     * Updated reply content (body text). Used when editing reply within\n     * allowed window, per requirements.\n     */\n    content: string;\n  };\n}\n",
      "src/api/structures/IPageIBbsCommentReply.ts": "import { IPage } from \"./IPage\";\nimport { IBbsCommentReply } from \"./IBbsCommentReply\";\n\n/**\n * Paginated container for replies to a specific comment.\n *\n * Implements the IPage structure for consistent pagination information and\n * reply lists. Used in threaded/nested comment UIs and admin moderation tools.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IPageIBbsCommentReply = {\n  pagination: IPage.IPagination;\n\n  /**\n   * List of reply comments matching the search/pagination criteria. Each item\n   * is an IBbsCommentReply instance.\n   */\n  data: IBbsCommentReply[];\n};\n",
      "src/api/structures/IBbsVote.ts": "import { tags } from \"typia\";\n\n/**\n * A single vote record (post or comment vote).\n *\n * Defines the core information about a user-provided upvote/downvote for either\n * a post or comment. Per schema, only one of post_id or comment_id is populated\n * for each record. Business rules for voting integrity apply.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IBbsVote = {\n  /** Unique identifier for the vote record. Maps to votes.id in Prisma schema. */\n  id: string & tags.Format<\"uuid\">;\n\n  /**\n   * User (voter) UUID that cast this vote. From votes.user_id. Used for\n   * auditing and per-user history.\n   */\n  user_id: string & tags.Format<\"uuid\">;\n\n  /**\n   * UUID of the post being voted on, if applicable. From votes.post_id.\n   * Mutually exclusive with comment_id per schema.\n   */\n  post_id?: (string & tags.Format<\"uuid\">) | null;\n\n  /**\n   * UUID of the comment being voted on, if applicable. From votes.comment_id.\n   * Mutually exclusive with post_id.\n   */\n  comment_id?: (string & tags.Format<\"uuid\">) | null;\n\n  /**\n   * Vote value: +1 for upvote, -1 for downvote. Enforced by DB check and\n   * business rules. From votes.value.\n   */\n  value: -1 | 1;\n\n  /**\n   * Timestamp when the vote was made. From votes.created_at. Used for\n   * auditing, reporting, and analytics.\n   */\n  created_at: string & tags.Format<\"date-time\">;\n};\nexport namespace IBbsVote {\n  /**\n   * Request/query object for searching votes table. Implements voting\n   * auditability, moderation, and analytics as detailed in Prisma model and\n   * requirements analysis.\n   */\n  export type IRequest = {\n    /**\n     * Page number for result pagination. Used for navigating through vote\n     * records. See IPage.IRequest guidelines.\n     */\n    page?:\n      | (number &\n          tags.Type<\"int32\"> &\n          tags.JsonSchemaPlugin<{\n            format: \"uint32\";\n          }>)\n      | null;\n\n    /**\n     * Number of vote records per page. Default is 100. Controls batch size\n     * returned. See IPage.IRequest.\n     */\n    limit?:\n      | (number &\n          tags.Type<\"int32\"> &\n          tags.JsonSchemaPlugin<{\n            format: \"uint32\";\n          }>)\n      | null;\n\n    /**\n     * Filter by the voter's (user's) UUID. Useful for auditing or personal\n     * history views. From votes.user_id.\n     */\n    user_id?: (string & tags.Format<\"uuid\">) | null;\n\n    /**\n     * Filter by a specific post (UUID) - returns votes associated with the\n     * given post ID. From votes.post_id.\n     */\n    post_id?: (string & tags.Format<\"uuid\">) | null;\n\n    /**\n     * Filter votes associated with a particular comment (UUID). Enables\n     * lookup of votes for a comment thread/reply (votes.comment_id).\n     */\n    comment_id?: (string & tags.Format<\"uuid\">) | null;\n\n    /**\n     * Filter by vote value: +1 (upvote) or -1 (downvote). Optional. From\n     * votes.value.\n     */\n    value?: -1 | 1 | null;\n\n    /**\n     * Include votes created after this date/time (ISO-8601).\n     * Audit/analytics tool.\n     */\n    created_after?: (string & tags.Format<\"date-time\">) | null;\n\n    /**\n     * Include votes created before this date/time (ISO-8601).\n     * Audit/analytics/periodic analysis.\n     */\n    created_before?: (string & tags.Format<\"date-time\">) | null;\n  };\n\n  /**\n   * Object for creating a vote on a post or comment.\n   *\n   * Specifies the target entity (post_id or comment_id) and the value\n   * (+1/-1). Enforces one-vote-per-target-per-user as described in\n   * requirements and Prisma schema.\n   */\n  export type ICreate = {\n    /**\n     * ID of the post to be voted on. Set this or comment_id, but not both.\n     * Enforced by business logic and unique constraint (see\n     * votes.post_id).\n     */\n    post_id?: (string & tags.Format<\"uuid\">) | null;\n\n    /**\n     * ID of the comment to be voted on. Set this or post_id, but not both.\n     * Only one target can be set. From votes.comment_id.\n     */\n    comment_id?: (string & tags.Format<\"uuid\">) | null;\n\n    /**\n     * Required. Vote value: +1 (upvote) or -1 (downvote). Enforced by\n     * schema and business rules.\n     */\n    value: -1 | 1;\n  };\n\n  /**\n   * Edit/update payload for an existing vote record.\n   *\n   * Allows switching between upvote/downvote. Subject to audit and\n   * moderator/admin permission checks.\n   */\n  export type IUpdate = {\n    /**\n     * New vote value: +1 or -1. Only allowed update. Alters the score on\n     * the target entity.\n     */\n    value: -1 | 1;\n  };\n}\n",
      "src/api/structures/IPageIBbsVote.ts": "import { IPage } from \"./IPage\";\nimport { IBbsVote } from \"./IBbsVote\";\n\n/**\n * Paginated result structure for queries on the votes table.\n *\n * Standardized as IPage<T>, with pagination and vote data array. Used in\n * moderation, analytics, and voting integrity checks.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IPageIBbsVote = {\n  pagination: IPage.IPagination;\n\n  /** Vote records for the query window, each as an IBbsVote object. */\n  data: IBbsVote[];\n};\n",
      "src/api/functional/bbs/users/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IBbsUsers } from \"../../../structures/IBbsUsers\";\nimport { IPageIBbsUsers } from \"../../../structures/IPageIBbsUsers\";\n\n/**\n * Register a new user account (users table).\n *\n * This operation allows either new users to self-register (signup) or\n * administrative users to create new user accounts. Inputs include: username,\n * email, password (plain, which will be hashed), role, and optional biography.\n * Usernames and emails must be unique system-wide as enforced by the DB. Role\n * assignment references the user_roles table (role name or ID). On successful\n * creation, returns full non-sensitive account data (never returns password\n * hash or plain password). Validation includes strong password policies,\n * correctly-formed emails, unique username check, assignment of allowed roles,\n * and correct audit metadata. Security policies ensure only authorized clients\n * can create moderator/administrator accounts. Relationship: users references\n * user_roles via user_role_id (UUID). The operation complements authentication\n * endpoints and supports user onboarding workflows. Error handling includes\n * duplicate entries, invalid roles, and input format errors.\n *\n * @param props.connection\n * @param props.body User account registration information, including username,\n *   email, password, role, and optional bio.\n * @path /bbs/users\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function post(\n  connection: IConnection,\n  props: post.Props,\n): Promise<post.Response> {\n  return !!connection.simulate\n    ? post.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...post.METADATA,\n          path: post.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace post {\n  export type Props = {\n    /**\n     * User account registration information, including username, email,\n     * password, role, and optional bio.\n     */\n    body: IBbsUsers.ICreate;\n  };\n  export type Body = IBbsUsers.ICreate;\n  export type Response = IBbsUsers;\n\n  export const METADATA = {\n    method: \"POST\",\n    path: \"/bbs/users\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/bbs/users\";\n  export const random = (g?: Partial<typia.IRandomGenerator>): IBbsUsers =>\n    typia.random<IBbsUsers>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: post.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: post.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * List users with search, filtering, and pagination (users table).\n *\n * This operation enables privileged users (moderators, administrators) to\n * retrieve a paginated list of all users registered on the discussion board.\n * The returned user data includes public profile information (username, email,\n * bio), their user role, account status, and registration metadata. Filtering\n * and searching capabilities provide powerful moderation and community\n * management tools, allowing admins to quickly investigate misuse, track new\n * registrations, or query dormant/suspended accounts. Pagination parameters\n * prevent excessive database load. The endpoint ensures security by requiring\n * bearer authentication and restricting access to users with sufficient\n * privileges (moderator or administrator). This operation references the users\n * Prisma schema model, specifically all columns described (id, user_role_id,\n * username, email, bio, status, created_at, updated_at). The response should\n * not include password hashes. Validation includes correct filter types, secure\n * pagination defaults, and correct authorization checks. This operation may be\n * combined with single-user lookup or management operations for a full user\n * administration workflow.\n *\n * @param props.connection\n * @param props.body Request parameters for user list/search, including filters,\n *   pagination, and sort details.\n * @path /bbs/users\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patch(\n  connection: IConnection,\n  props: patch.Props,\n): Promise<patch.Response> {\n  return !!connection.simulate\n    ? patch.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patch.METADATA,\n          path: patch.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace patch {\n  export type Props = {\n    /**\n     * Request parameters for user list/search, including filters,\n     * pagination, and sort details.\n     */\n    body: IBbsUsers.IRequest;\n  };\n  export type Body = IBbsUsers.IRequest;\n  export type Response = IPageIBbsUsers;\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/bbs/users\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/bbs/users\";\n  export const random = (g?: Partial<typia.IRandomGenerator>): IPageIBbsUsers =>\n    typia.random<IPageIBbsUsers>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: patch.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patch.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Retrieve a user's profile/account by user ID (users table).\n *\n * This endpoint retrieves the full account and public profile information for a\n * specific user, as identified by their UUID. It is used for account\n * management, profile viewing, and moderation. The returned details include\n * username, bio, email, role (with full description), account status, and\n * timestamps (created_at, updated_at). Account credentials (such as the\n * password_hash) are never returned for security reasons. The endpoint may be\n * used by administrators or moderators during audits, dispute resolution, or\n * assisting users. Follows the users Prisma schema for all properties and\n * relationships. Handles missing/deleted users gracefully with informative\n * error responses. Security validation restricts access to authorized roles\n * only, typically moderator or administrator.\n *\n * @param props.connection\n * @param props.id Target user's UUID\n * @path /bbs/users/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getById(\n  connection: IConnection,\n  props: getById.Props,\n): Promise<getById.Response> {\n  return !!connection.simulate\n    ? getById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getById.METADATA,\n          path: getById.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace getById {\n  export type Props = {\n    /** Target user's UUID */\n    id: string & tags.Format<\"uuid\">;\n  };\n  export type Response = IBbsUsers;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/bbs/users/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/bbs/users/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): IBbsUsers =>\n    typia.random<IBbsUsers>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: getById.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Update an existing user profile or account (users table).\n *\n * This endpoint lets administrators or the users themselves update user profile\n * information (username, email, bio), administrative account status (active,\n * suspended, banned, etc.), or reassign user role (referencing user_roles\n * table). Changing credentials (password) is handled by a separate workflow,\n * but email and username uniqueness is always enforced. Security rules ensure\n * only allowed users (self, moderator, admin) can update the target account.\n * All changes are subject to full validation against the business rules in the\n * requirements document and Prisma schema. Audit fields (updated_at) are set by\n * the backend. The endpoint can be used in workflows for profile updates, role\n * upgrades, or moderation actions. Errors include duplicate username/email or\n * unpermitted actions.\n *\n * @param props.connection\n * @param props.id Target user's UUID\n * @param props.body Profile/account update payload (username, bio, email, role,\n *   status, but not password).\n * @path /bbs/users/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function putById(\n  connection: IConnection,\n  props: putById.Props,\n): Promise<putById.Response> {\n  return !!connection.simulate\n    ? putById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...putById.METADATA,\n          path: putById.path(props),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace putById {\n  export type Props = {\n    /** Target user's UUID */\n    id: string & tags.Format<\"uuid\">;\n\n    /**\n     * Profile/account update payload (username, bio, email, role, status,\n     * but not password).\n     */\n    body: IBbsUsers.IUpdate;\n  };\n  export type Body = IBbsUsers.IUpdate;\n  export type Response = IBbsUsers;\n\n  export const METADATA = {\n    method: \"PUT\",\n    path: \"/bbs/users/:id\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Omit<Props, \"body\">) =>\n    `/bbs/users/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): IBbsUsers =>\n    typia.random<IBbsUsers>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: putById.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: putById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Soft-delete (deactivate) a user by status update (users table).\n *\n * This operation allows administrators or moderators to deactivate or remove a\n * user account without physically deleting the record from the database,\n * preserving audit trails and possible restoration. Actual implementation sets\n * the status field of the user record (users table) to a value like 'deleted',\n * 'banned', or 'suspended'. Only privileged users (administrators, moderators)\n * may execute this unless it's for self-removal. Associated content\n * (posts/comments) are retained. This operation references account removal\n * business logic from requirements and Prisma schema business rules. All\n * necessary validation, audit, and error handling logic are included.\n * Deactivation is irreversible except by subsequent restoration workflow.\n *\n * @param props.connection\n * @param props.id Target user's UUID\n * @path /bbs/users/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function eraseById(\n  connection: IConnection,\n  props: eraseById.Props,\n): Promise<eraseById.Response> {\n  return !!connection.simulate\n    ? eraseById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...eraseById.METADATA,\n          path: eraseById.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace eraseById {\n  export type Props = {\n    /** Target user's UUID */\n    id: string & tags.Format<\"uuid\">;\n  };\n  export type Response = IBbsUsers;\n\n  export const METADATA = {\n    method: \"DELETE\",\n    path: \"/bbs/users/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/bbs/users/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): IBbsUsers =>\n    typia.random<IBbsUsers>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: eraseById.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: eraseById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
      "src/api/functional/bbs/index.ts": "export * as users from \"./users\";\nexport * as userRoles from \"./userRoles\";\nexport * as categories from \"./categories\";\nexport * as posts from \"./posts\";\nexport * as comments from \"./comments\";\nexport * as votes from \"./votes\";\n",
      "src/api/functional/index.ts": "export * as bbs from \"./bbs\";\n",
      "src/api/functional/bbs/userRoles/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IBbsUserRoles } from \"../../../structures/IBbsUserRoles\";\nimport { IPageIBbsUserRoles } from \"../../../structures/IPageIBbsUserRoles\";\n\n/**\n * Create a new user role (user_roles table).\n *\n * This operation allows system administrators to define and create new user\n * roles, expanding the range of permissions and governance on the discussion\n * board. Input includes the unique role name (e.g., 'community_manager'), and a\n * text description outlining permissions and duties. Validation enforces\n * uniqueness of the role name, and the description is required for audit and\n * clarity. May be used in onboarding or registration flows to offer new kinds\n * of user experiences (e.g., temporary roles). All relationships and\n * constraints are as defined in user_roles Prisma model. Error handling covers\n * duplicates and format errors. Audit metadata is tracked by the backend.\n *\n * @param props.connection\n * @param props.body Role creation payload (unique name, descriptive text).\n * @path /bbs/userRoles\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function post(\n  connection: IConnection,\n  props: post.Props,\n): Promise<post.Response> {\n  return !!connection.simulate\n    ? post.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...post.METADATA,\n          path: post.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace post {\n  export type Props = {\n    /** Role creation payload (unique name, descriptive text). */\n    body: IBbsUserRoles.ICreate;\n  };\n  export type Body = IBbsUserRoles.ICreate;\n  export type Response = IBbsUserRoles;\n\n  export const METADATA = {\n    method: \"POST\",\n    path: \"/bbs/userRoles\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/bbs/userRoles\";\n  export const random = (g?: Partial<typia.IRandomGenerator>): IBbsUserRoles =>\n    typia.random<IBbsUserRoles>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: post.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: post.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * List user roles with search and pagination (user_roles table).\n *\n * List the roles available for assignment to users, as per the user_roles\n * business table (roles like member, moderator, administrator). Supports\n * pagination, filtering, and search on role names or descriptions, assisting\n * administrators and registration workflows in finding or displaying available\n * roles. Related to users table by user_role_id. The endpoint returns role\n * information but does not expose any linked user personal data. Supports role\n * management, onboarding, and auditing. Authorization is required, typically\n * for system administration staff. Used alongside user creation and update APIs\n * to ensure valid references.\n *\n * @param props.connection\n * @param props.body Request parameters for user role list/search, supporting\n *   filtering and pagination.\n * @path /bbs/userRoles\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patch(\n  connection: IConnection,\n  props: patch.Props,\n): Promise<patch.Response> {\n  return !!connection.simulate\n    ? patch.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patch.METADATA,\n          path: patch.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace patch {\n  export type Props = {\n    /**\n     * Request parameters for user role list/search, supporting filtering\n     * and pagination.\n     */\n    body: IBbsUserRoles.IRequest;\n  };\n  export type Body = IBbsUserRoles.IRequest;\n  export type Response = IPageIBbsUserRoles;\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/bbs/userRoles\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/bbs/userRoles\";\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IPageIBbsUserRoles => typia.random<IPageIBbsUserRoles>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: patch.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patch.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Retrieve a user role by ID (user_roles table).\n *\n * Get metadata about a specific user role, identified by its UUID. Returns the\n * unique name and full description of role authority, as defined in the\n * user_roles Prisma table and associated requirements. Used for audit checks,\n * onboarding selection, or administrative validation (e.g., displaying what a\n * moderator can do). Access is required for system administrators or similar\n * privileged roles. Handles missing/invalid IDs gracefully. The endpoint does\n * not expose user information, only the role metadata.\n *\n * @param props.connection\n * @param props.id Target role's UUID\n * @path /bbs/userRoles/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getById(\n  connection: IConnection,\n  props: getById.Props,\n): Promise<getById.Response> {\n  return !!connection.simulate\n    ? getById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getById.METADATA,\n          path: getById.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace getById {\n  export type Props = {\n    /** Target role's UUID */\n    id: string & tags.Format<\"uuid\">;\n  };\n  export type Response = IBbsUserRoles;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/bbs/userRoles/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/bbs/userRoles/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): IBbsUserRoles =>\n    typia.random<IBbsUserRoles>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: getById.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Update existing user role by role ID (user_roles table).\n *\n * This operation edits the label and description of an existing user role,\n * updating governance or onboarding configuration. Only permitted users\n * (administrators) can invoke it. Input: role ID (UUID), new name, and/or new\n * description. Enforces unique name and proper validation. Responses include\n * the updated role descriptor. Used along with other role management APIs for\n * dynamic permissions adjustments. Covers all role metadata per user_roles\n * Prisma schema. Handles invalid input, duplicate names, or permissions errors.\n * Returns updated user role metadata for confirmation.\n *\n * @param props.connection\n * @param props.id Target role's UUID\n * @param props.body User role update payload (new name, description).\n * @path /bbs/userRoles/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function putById(\n  connection: IConnection,\n  props: putById.Props,\n): Promise<putById.Response> {\n  return !!connection.simulate\n    ? putById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...putById.METADATA,\n          path: putById.path(props),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace putById {\n  export type Props = {\n    /** Target role's UUID */\n    id: string & tags.Format<\"uuid\">;\n\n    /** User role update payload (new name, description). */\n    body: IBbsUserRoles.IUpdate;\n  };\n  export type Body = IBbsUserRoles.IUpdate;\n  export type Response = IBbsUserRoles;\n\n  export const METADATA = {\n    method: \"PUT\",\n    path: \"/bbs/userRoles/:id\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Omit<Props, \"body\">) =>\n    `/bbs/userRoles/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): IBbsUserRoles =>\n    typia.random<IBbsUserRoles>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: putById.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: putById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Deactivate (soft-delete) user role by ID (user_roles table).\n *\n * Allows system administrators to deactivate a role in the user_roles table. In\n * practice, this might mean preventing new users from being assigned this role,\n * but the role metadata remains for audit and traceability. The endpoint does\n * not physically remove the record. Input is the role's UUID. Can be combined\n * with user management endpoints for full administrative functionality.\n * Authorization and permissions are strictly enforced. Responses document the\n * now-inactive/deleted state. Error handling includes referencing non-existent\n * or protected roles. Audit/meta info is retained.\n *\n * @param props.connection\n * @param props.id Target role's UUID\n * @path /bbs/userRoles/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function eraseById(\n  connection: IConnection,\n  props: eraseById.Props,\n): Promise<eraseById.Response> {\n  return !!connection.simulate\n    ? eraseById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...eraseById.METADATA,\n          path: eraseById.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace eraseById {\n  export type Props = {\n    /** Target role's UUID */\n    id: string & tags.Format<\"uuid\">;\n  };\n  export type Response = IBbsUserRoles;\n\n  export const METADATA = {\n    method: \"DELETE\",\n    path: \"/bbs/userRoles/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/bbs/userRoles/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): IBbsUserRoles =>\n    typia.random<IBbsUserRoles>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: eraseById.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: eraseById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
      "src/api/functional/bbs/categories/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { bbsCategories } from \"../../../structures/bbsCategories\";\nimport { IBbsCategories } from \"../../../structures/IBbsCategories\";\nimport { IPageIBbsCategories } from \"../../../structures/IPageIBbsCategories\";\n\n/**\n * Create a new category (BBS: categories table).\n *\n * This API allows an administrator to create a new discussion category in the\n * BBS platform. By supplying necessary information such as category name and\n * description, the system adds a new record to the 'categories' table.\n * Administrators should ensure names are unique to avoid conflicts with\n * existing categories.\n *\n * Access to this API is restricted to authenticated administrators, as only\n * they may modify the set of available discussion categories. Upon successful\n * creation, a new category entry is visible and available for post assignment\n * by all users, supporting better board organization.\n *\n * If the submitted category name already exists, the API will return an error\n * indicating the name must be unique. Validation rules also require non-empty\n * strings for both name and description fields.\n *\n * Related operations include listing categories, updating (PUT), and deleting\n * (DELETE) existing categories. This endpoint is essential for maintaining the\n * topical structure of the BBS, making it easier for users to navigate and\n * participate in relevant discussions.\n *\n * @param props.connection\n * @param props.body Information about the new category to create, including\n *   name and description.\n * @path /bbs/categories\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function post(\n  connection: IConnection,\n  props: post.Props,\n): Promise<post.Response> {\n  return !!connection.simulate\n    ? post.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...post.METADATA,\n          path: post.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace post {\n  export type Props = {\n    /**\n     * Information about the new category to create, including name and\n     * description.\n     */\n    body: bbsCategories.ICreate;\n  };\n  export type Body = bbsCategories.ICreate;\n  export type Response = bbsCategories;\n\n  export const METADATA = {\n    method: \"POST\",\n    path: \"/bbs/categories\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/bbs/categories\";\n  export const random = (g?: Partial<typia.IRandomGenerator>): bbsCategories =>\n    typia.random<bbsCategories>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: post.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: post.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * List post categories with search and pagination (categories table).\n *\n * This endpoint allows clients to list the discussion categories (topic areas,\n * such as 'Politics', 'Economics') under which posts are organized. Supports\n * optional filtering/search, useful for navigation, onboarding, and content\n * creation flows. Uses pagination for performance. Does not disclose posts,\n * only the category metadata (id, name, description, created_at) from the\n * categories Prisma schema. No relationships to users are returned. Accessible\n * to all users, including visitors without authentication by default, but may\n * also support administrative filtering enhancements. Commonly used to build\n * navigation bars or prompt users to choose a category when creating content.\n * Handles invalid filters and pagination gracefully.\n *\n * @param props.connection\n * @param props.body Category query/search/pagination options.\n * @path /bbs/categories\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patch(\n  connection: IConnection,\n  props: patch.Props,\n): Promise<patch.Response> {\n  return !!connection.simulate\n    ? patch.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patch.METADATA,\n          path: patch.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace patch {\n  export type Props = {\n    /** Category query/search/pagination options. */\n    body: IBbsCategories.IRequest;\n  };\n  export type Body = IBbsCategories.IRequest;\n  export type Response = IPageIBbsCategories;\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/bbs/categories\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/bbs/categories\";\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IPageIBbsCategories => typia.random<IPageIBbsCategories>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: patch.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patch.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Get a single category's details by ID (categories table).\n *\n * This endpoint fetches the name, description, and creation date for a specific\n * discussion category. The input is the category's UUID. Used by clients or\n * admins to display detailed category information (such as when viewing the\n * category page or offering category selection in post creation). Does not\n * return post data itself, only the category metadata as defined in the\n * categories Prisma schema. Handles invalid/missing category gracefully. No\n * relationships are exposed, only direct metadata. Authorization is open by\n * default but may enforce further checks for admin/management views. Used in\n * category navigation, post composition, or audit reporting. Audit trail\n * (created_at) is returned for management.\n *\n * @param props.connection\n * @param props.id Target category's UUID\n * @path /bbs/categories/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getById(\n  connection: IConnection,\n  props: getById.Props,\n): Promise<getById.Response> {\n  return !!connection.simulate\n    ? getById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getById.METADATA,\n          path: getById.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace getById {\n  export type Props = {\n    /** Target category's UUID */\n    id: string & tags.Format<\"uuid\">;\n  };\n  export type Response = IBbsCategories;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/bbs/categories/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/bbs/categories/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): IBbsCategories =>\n    typia.random<IBbsCategories>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: getById.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Update a category's details (BBS: categories table).\n *\n * This API allows authenticated administrators to update the name or\n * description of a discussion category identified by its unique 'id'. The\n * update operation references the 'categories' table and enforces uniqueness\n * for category names and requires non-empty values. Only administrators may\n * perform this action, and each request must specify the category's identifier\n * in the path.\n *\n * Attempts to change the category name to one already in use will result in a\n * validation error. The update operation also prevents accidental erasure of\n * required information by ensuring both the name and description remain\n * populated after editing. Related endpoints include category creation (POST),\n * deletion (DELETE), and listing/searching operations for categories.\n *\n * On success, the endpoint returns the updated category information, reflecting\n * all changes for immediate use in the system.\n *\n * @param props.connection\n * @param props.id The identifier of the category to update.\n * @param props.body Updated information for the specified category.\n * @path /bbs/categories/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function putById(\n  connection: IConnection,\n  props: putById.Props,\n): Promise<putById.Response> {\n  return !!connection.simulate\n    ? putById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...putById.METADATA,\n          path: putById.path(props),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace putById {\n  export type Props = {\n    /** The identifier of the category to update. */\n    id: string & tags.Format<\"uuid\">;\n\n    /** Updated information for the specified category. */\n    body: bbsCategories.IUpdate;\n  };\n  export type Body = bbsCategories.IUpdate;\n  export type Response = bbsCategories;\n\n  export const METADATA = {\n    method: \"PUT\",\n    path: \"/bbs/categories/:id\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Omit<Props, \"body\">) =>\n    `/bbs/categories/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): bbsCategories =>\n    typia.random<bbsCategories>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: putById.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: putById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Delete a category by ID (BBS: categories table).\n *\n * This API endpoint allows an authenticated administrator to delete a\n * discussion category by its ID from the BBS system. It removes the specified\n * record from the 'categories' table. Prior to deletion, the system checks for\n * posts referencing this category; administrators may need to reassign or\n * handle these posts to maintain board integrity.\n *\n * Only users with appropriate administrator roles (as defined in the\n * 'user_roles' table) are permitted to invoke this operation. Attempts to\n * delete a category with dependent posts may result in an error until those\n * dependencies are resolved. On successful completion, the category is\n * permanently removed from the database; deleted category names can be reused\n * when creating new categories.\n *\n * Related endpoints include creating, updating, and listing categories.\n *\n * @param props.connection\n * @param props.id The identifier of the category to delete.\n * @path /bbs/categories/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function eraseById(\n  connection: IConnection,\n  props: eraseById.Props,\n): Promise<eraseById.Response> {\n  return !!connection.simulate\n    ? eraseById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...eraseById.METADATA,\n          path: eraseById.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace eraseById {\n  export type Props = {\n    /** The identifier of the category to delete. */\n    id: string & tags.Format<\"uuid\">;\n  };\n  export type Response = bbsCategories;\n\n  export const METADATA = {\n    method: \"DELETE\",\n    path: \"/bbs/categories/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/bbs/categories/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): bbsCategories =>\n    typia.random<bbsCategories>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: eraseById.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: eraseById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
      "src/api/functional/bbs/posts/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { bbsPosts } from \"../../../structures/bbsPosts\";\nimport { IPageBbsPosts } from \"../../../structures/IPageBbsPosts\";\nexport * as comments from \"./comments\";\n\n/**\n * Create a new post (BBS: posts table).\n *\n * This API endpoint enables registered users to start a new discussion by\n * submitting a post to the BBS platform. The client must provide all required\n * information: title, body content, associated category, and, implicitly, the\n * user's identity (via authentication).\n *\n * The system records each new post in the 'posts' table and links it to the\n * author's user record and the assigned category. Constraints ensure titles and\n * content are non-empty, with a valid category reference.\n *\n * Upon success, the new post (with its ID and relevant metadata) is immediately\n * available for searching, viewing, and commenting. The operation enforces\n * organization and content standards, returning validation errors if\n * requirements are unmet.\n *\n * Post-creation, users may view, edit, or delete their posts, while moderators\n * can perform additional actions as per role. This endpoint is closely related\n * to GET, PUT, and DELETE operations on posts.\n *\n * @param props.connection\n * @param props.body Information for the new post, including title, content, and\n *   category ID.\n * @path /bbs/posts\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function post(\n  connection: IConnection,\n  props: post.Props,\n): Promise<post.Response> {\n  return !!connection.simulate\n    ? post.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...post.METADATA,\n          path: post.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace post {\n  export type Props = {\n    /**\n     * Information for the new post, including title, content, and category\n     * ID.\n     */\n    body: bbsPosts.ICreate;\n  };\n  export type Body = bbsPosts.ICreate;\n  export type Response = bbsPosts;\n\n  export const METADATA = {\n    method: \"POST\",\n    path: \"/bbs/posts\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/bbs/posts\";\n  export const random = (g?: Partial<typia.IRandomGenerator>): bbsPosts =>\n    typia.random<bbsPosts>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: post.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: post.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Search and list posts with filtering and pagination (BBS: posts table).\n *\n * This API allows users to list and search through discussion posts on the BBS\n * platform by querying the 'posts' table. The endpoint supports pagination,\n * keyword search, category-based filtering, sorting by date or popularity, and\n * other advanced query options as per best practice standards.\n *\n * Both registered members and visitors can use this endpoint (though access to\n * full content or additional metadata may be limited for visitors). Results\n * typically return basic post details—such as title, author summary, vote\n * tallies, timestamps—and allow users to quickly find, browse, and analyze\n * current discussions.\n *\n * If the query contains unsupported or invalid parameters, the system returns\n * an appropriate error. This endpoint is commonly used alongside post creation\n * (POST), update (PUT), detail view (GET), and deletion (DELETE) operations.\n *\n * @param props.connection\n * @param props.body Search, filter, and pagination options for retrieving\n *   posts.\n * @path /bbs/posts\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patch(\n  connection: IConnection,\n  props: patch.Props,\n): Promise<patch.Response> {\n  return !!connection.simulate\n    ? patch.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patch.METADATA,\n          path: patch.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace patch {\n  export type Props = {\n    /** Search, filter, and pagination options for retrieving posts. */\n    body: bbsPosts.IRequest;\n  };\n  export type Body = bbsPosts.IRequest;\n  export type Response = IPageBbsPosts;\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/bbs/posts\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/bbs/posts\";\n  export const random = (g?: Partial<typia.IRandomGenerator>): IPageBbsPosts =>\n    typia.random<IPageBbsPosts>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: patch.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patch.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Get detailed info for a specific post (BBS: posts table).\n *\n * This API endpoint allows a user to fetch complete details about a single\n * post, identified by its UUID. It is tied to the 'posts' table and is\n * available to visitors and registered members. Returned data includes the post\n * title, content, author summary, associated category, creation and update\n * times, and vote tallies.\n *\n * This operation is essential for navigating from post lists to detailed thread\n * views, supporting actions such as voting or commenting (when logged in). If\n * the requested post does not exist, the API returns an appropriate not-found\n * error. Related endpoints include post listing (PATCH /bbs/posts), post\n * creation (POST), updating (PUT), and deletion (DELETE).\n *\n * @param props.connection\n * @param props.id The unique identifier of the post to retrieve.\n * @path /bbs/posts/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getById(\n  connection: IConnection,\n  props: getById.Props,\n): Promise<getById.Response> {\n  return !!connection.simulate\n    ? getById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getById.METADATA,\n          path: getById.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace getById {\n  export type Props = {\n    /** The unique identifier of the post to retrieve. */\n    id: string & tags.Format<\"uuid\">;\n  };\n  export type Response = bbsPosts;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/bbs/posts/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/bbs/posts/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): bbsPosts =>\n    typia.random<bbsPosts>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: getById.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Update a post's details (BBS: posts table).\n *\n * This API allows the original author (or, in special cases, a\n * moderator/administrator) to update an existing post identified by its UUID.\n * The client supplies updated values for title, content, or other modifiable\n * fields. The 'posts' table enforces that only the recorded author or\n * privileged account can submit updates to a given post record.\n *\n * The system maintains a history of 'updated_at' timestamps and can restrict\n * updates to within certain time windows, as described by business\n * requirements. Attempting to update with invalid data (missing or duplicate\n * title, empty content, invalid references) produces an error. Related\n * endpoints include post creation (POST), detailed retrieval (GET), and\n * deletion (DELETE).\n *\n * The API returns the updated post data upon success, immediately reflecting\n * any changes in subsequent queries.\n *\n * @param props.connection\n * @param props.id The unique post identifier to update.\n * @param props.body Updated values for the target post (title, content,\n *   category, etc.).\n * @path /bbs/posts/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function putById(\n  connection: IConnection,\n  props: putById.Props,\n): Promise<putById.Response> {\n  return !!connection.simulate\n    ? putById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...putById.METADATA,\n          path: putById.path(props),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace putById {\n  export type Props = {\n    /** The unique post identifier to update. */\n    id: string & tags.Format<\"uuid\">;\n\n    /** Updated values for the target post (title, content, category, etc.). */\n    body: bbsPosts.IUpdate;\n  };\n  export type Body = bbsPosts.IUpdate;\n  export type Response = bbsPosts;\n\n  export const METADATA = {\n    method: \"PUT\",\n    path: \"/bbs/posts/:id\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Omit<Props, \"body\">) =>\n    `/bbs/posts/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): bbsPosts =>\n    typia.random<bbsPosts>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: putById.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: putById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Delete a post by ID (BBS: posts table).\n *\n * This API allows a post author or an authorized moderator/administrator to\n * remove a post from the BBS platform. The system marks the post as deleted\n * (soft delete) or permanently deletes the record from the 'posts' table per\n * business and moderation rules.\n *\n * Access controls ensure only the post's author or properly credentialed staff\n * may invoke this endpoint. The system prevents posts with active dependency\n * violations (such as non-removable comments) from being deleted outright and\n * may require additional steps.\n *\n * Upon success, the response confirms deletion status, and the post is hidden\n * from general listing and searches. Related API endpoints: post creation\n * (POST), detail view (GET), update (PUT), and comment management for\n * associated replies.\n *\n * @param props.connection\n * @param props.id The unique post identifier to delete.\n * @path /bbs/posts/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function eraseById(\n  connection: IConnection,\n  props: eraseById.Props,\n): Promise<eraseById.Response> {\n  return !!connection.simulate\n    ? eraseById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...eraseById.METADATA,\n          path: eraseById.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace eraseById {\n  export type Props = {\n    /** The unique post identifier to delete. */\n    id: string & tags.Format<\"uuid\">;\n  };\n  export type Response = bbsPosts;\n\n  export const METADATA = {\n    method: \"DELETE\",\n    path: \"/bbs/posts/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/bbs/posts/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): bbsPosts =>\n    typia.random<bbsPosts>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: eraseById.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: eraseById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
      "src/api/functional/bbs/posts/comments/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { bbsComments } from \"../../../../structures/bbsComments\";\nimport { IPageBbsComments } from \"../../../../structures/IPageBbsComments\";\n\n/**\n * Create a new comment for a specific post (BBS: comments table).\n *\n * This API endpoint lets users (or, in special cases,\n * moderators/administrators) add a new comment to a discussion post. The caller\n * specifies the parent 'postId' and supplies the comment content. Optional\n * threading is permitted by providing a parent comment ID for nested\n * replies—enabling conversations to branch.\n *\n * The 'comments' table links the new comment with both the author (via\n * authentication) and the parent post (and optionally a parent comment),\n * satisfying data integrity rules and supporting navigation through reply\n * trees. Only authenticated users are allowed to create comments. The system\n * enforces validation that content is non-empty and—if threading—a valid parent\n * comment ID is supplied.\n *\n * Upon success, the new comment becomes searchable, viewable, and ready for\n * follow-up replies or moderation actions. Related endpoints: list/search\n * comments, update, delete.\n *\n * @param props.connection\n * @param props.postId Identifier of the post to which the comment will be\n *   added.\n * @param props.body Information for the new comment (content, parent comment if\n *   threading, etc.).\n * @path /bbs/posts/:postId/comments\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function postByPostid(\n  connection: IConnection,\n  props: postByPostid.Props,\n): Promise<postByPostid.Response> {\n  return !!connection.simulate\n    ? postByPostid.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...postByPostid.METADATA,\n          path: postByPostid.path(props),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace postByPostid {\n  export type Props = {\n    /** Identifier of the post to which the comment will be added. */\n    postId: string & tags.Format<\"uuid\">;\n\n    /**\n     * Information for the new comment (content, parent comment if\n     * threading, etc.).\n     */\n    body: bbsComments.ICreate;\n  };\n  export type Body = bbsComments.ICreate;\n  export type Response = bbsComments;\n\n  export const METADATA = {\n    method: \"POST\",\n    path: \"/bbs/posts/:postId/comments\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Omit<Props, \"body\">) =>\n    `/bbs/posts/${encodeURIComponent(props.postId ?? \"null\")}/comments`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): bbsComments =>\n    typia.random<bbsComments>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: postByPostid.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: postByPostid.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"postId\")(() => typia.assert(props.postId));\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * List or search comments for a specified post (BBS: comments table).\n *\n * This API allows users to retrieve a list of comments for a specific post,\n * identified by 'postId'. Supports query options for filtering by author, time\n * range, reply depth, and more—including pagination and sort order. The\n * underlying 'comments' table returns summaries or basics details of each\n * comment thread or reply chain, supporting threaded conversation navigation.\n *\n * Both authenticated users and visitors can access this operation, but may see\n * different levels of detail according to permissions. The endpoint is closely\n * linked with comment creation (POST), update (PUT), and deletion (DELETE) for\n * participation and moderation flows. Only comments belonging to the target\n * postId are returned, supporting thread-based exploration and analysis.\n *\n * @param props.connection\n * @param props.postId The unique identifier of the post whose comments are\n *   being queried.\n * @param props.body Options for filtering, pagination, etc., when listing\n *   comments.\n * @path /bbs/posts/:postId/comments\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patchByPostid(\n  connection: IConnection,\n  props: patchByPostid.Props,\n): Promise<patchByPostid.Response> {\n  return !!connection.simulate\n    ? patchByPostid.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patchByPostid.METADATA,\n          path: patchByPostid.path(props),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace patchByPostid {\n  export type Props = {\n    /** The unique identifier of the post whose comments are being queried. */\n    postId: string & tags.Format<\"uuid\">;\n\n    /** Options for filtering, pagination, etc., when listing comments. */\n    body: bbsComments.IRequest;\n  };\n  export type Body = bbsComments.IRequest;\n  export type Response = IPageBbsComments;\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/bbs/posts/:postId/comments\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Omit<Props, \"body\">) =>\n    `/bbs/posts/${encodeURIComponent(props.postId ?? \"null\")}/comments`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IPageBbsComments => typia.random<IPageBbsComments>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: patchByPostid.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patchByPostid.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"postId\")(() => typia.assert(props.postId));\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Get details for a specific comment (BBS: comments table).\n *\n * This API allows users to fetch all available information for one specific\n * comment within the context of a post. The identifiers ('postId' for the\n * parent thread, 'id' for the comment itself) ensure accuracy in comment\n * threading and navigation. The operation returns comment content, author and\n * timestamp details, metadata, and relations (such as parent reply or nested\n * replies).\n *\n * The endpoint supports use cases like displaying a reply in context, enabling\n * further replies, or feeding comment moderation workflows. If a comment is not\n * found or the identifiers do not match, the API returns a not-found error.\n * Related endpoints include comment listing (PATCH), creation (POST), updating\n * (PUT), and deletion (DELETE).\n *\n * @param props.connection\n * @param props.postId The unique post to which the comment belongs.\n * @param props.id The specific comment identifier to retrieve.\n * @path /bbs/posts/:postId/comments/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getByPostidAndId(\n  connection: IConnection,\n  props: getByPostidAndId.Props,\n): Promise<getByPostidAndId.Response> {\n  return !!connection.simulate\n    ? getByPostidAndId.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getByPostidAndId.METADATA,\n          path: getByPostidAndId.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace getByPostidAndId {\n  export type Props = {\n    /** The unique post to which the comment belongs. */\n    postId: string & tags.Format<\"uuid\">;\n\n    /** The specific comment identifier to retrieve. */\n    id: string & tags.Format<\"uuid\">;\n  };\n  export type Response = bbsComments;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/bbs/posts/:postId/comments/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/bbs/posts/${encodeURIComponent(props.postId ?? \"null\")}/comments/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): bbsComments =>\n    typia.random<bbsComments>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: getByPostidAndId.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getByPostidAndId.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"postId\")(() => typia.assert(props.postId));\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Update an existing comment for a post (BBS: comments table).\n *\n * This API lets an authenticated user (comment author or, under special\n * permissions, a moderator/administrator) update an existing comment identified\n * by both parent postId and comment id. The system enforces that updates may\n * only be made to comments the user owns, or by authorized moderation roles,\n * with all validation constraints on content and threading.\n *\n * Request must specify the target post and comment, supplying new content\n * and/or thread associations. Invalid references or blank content produces\n * errors, with history tracking updated timestamps. On success, the new comment\n * details are returned.\n *\n * Business rules ensure audit trails and uphold moderation policies. Related\n * endpoints include comment creation, deletion, and listing under post/group\n * context.\n *\n * @param props.connection\n * @param props.postId The post to which the comment belongs.\n * @param props.id The unique identifier of the comment to update.\n * @param props.body Updated values for the comment (e.g., new content, parentId\n *   for re-threading).\n * @path /bbs/posts/:postId/comments/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function putByPostidAndId(\n  connection: IConnection,\n  props: putByPostidAndId.Props,\n): Promise<putByPostidAndId.Response> {\n  return !!connection.simulate\n    ? putByPostidAndId.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...putByPostidAndId.METADATA,\n          path: putByPostidAndId.path(props),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace putByPostidAndId {\n  export type Props = {\n    /** The post to which the comment belongs. */\n    postId: string & tags.Format<\"uuid\">;\n\n    /** The unique identifier of the comment to update. */\n    id: string & tags.Format<\"uuid\">;\n\n    /**\n     * Updated values for the comment (e.g., new content, parentId for\n     * re-threading).\n     */\n    body: bbsComments.IUpdate;\n  };\n  export type Body = bbsComments.IUpdate;\n  export type Response = bbsComments;\n\n  export const METADATA = {\n    method: \"PUT\",\n    path: \"/bbs/posts/:postId/comments/:id\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Omit<Props, \"body\">) =>\n    `/bbs/posts/${encodeURIComponent(props.postId ?? \"null\")}/comments/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): bbsComments =>\n    typia.random<bbsComments>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: putByPostidAndId.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: putByPostidAndId.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"postId\")(() => typia.assert(props.postId));\n      assert.param(\"id\")(() => typia.assert(props.id));\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Delete a specific comment under a post (comments table, soft-delete logic).\n *\n * This operation deletes a comment associated with a particular post in the\n * political/economic discussion board application. According to the Prisma\n * schema for the 'comments' table, deleting a comment does not remove the\n * record from the database, but marks it as deleted by updating the\n * 'deleted_at' timestamp. This is in line with moderation and audit\n * requirements described in both the requirement analysis and schema\n * documentation.\n *\n * Authorization is necessary, and only the comment's author, a moderator, or an\n * administrator may perform this action. Permissions are determined by checking\n * the user's role, which is represented in the 'users' and 'user_roles' tables.\n * The endpoint ensures that the specified comment exists, is associated with\n * the given post, and is not already deleted. Attempting to delete a\n * non-existent or unrelated comment results in an error response showing the\n * appropriate message.\n *\n * Additionally, the operation maintains an audit trail by recording the\n * timestamp of deletion, as outlined in the comments schema. The deleted\n * comment remains for future moderation or review, and cannot be interacted\n * with by regular members after deletion. Error responses must comply with API\n * design for invalid IDs, unauthorized access, and logical violations (such as\n * trying to delete an already deleted comment).\n *\n * @param props.connection\n * @param props.postId Target post's ID (the parent of the comment).\n * @param props.id Target comment's ID to be deleted.\n * @path /bbs/posts/:postId/comments/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function eraseByPostidAndId(\n  connection: IConnection,\n  props: eraseByPostidAndId.Props,\n): Promise<void> {\n  return !!connection.simulate\n    ? eraseByPostidAndId.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...eraseByPostidAndId.METADATA,\n          path: eraseByPostidAndId.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace eraseByPostidAndId {\n  export type Props = {\n    /** Target post's ID (the parent of the comment). */\n    postId: string & tags.Format<\"uuid\">;\n\n    /** Target comment's ID to be deleted. */\n    id: string & tags.Format<\"uuid\">;\n  };\n\n  export const METADATA = {\n    method: \"DELETE\",\n    path: \"/bbs/posts/:postId/comments/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/bbs/posts/${encodeURIComponent(props.postId ?? \"null\")}/comments/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): void =>\n    typia.random<void>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: eraseByPostidAndId.Props,\n  ): void => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: eraseByPostidAndId.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"postId\")(() => typia.assert(props.postId));\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
      "src/api/functional/bbs/comments/comments/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IBbsCommentReply } from \"../../../../structures/IBbsCommentReply\";\nimport { IPageIBbsCommentReply } from \"../../../../structures/IPageIBbsCommentReply\";\n\n/**\n * Create a new reply to a specific parent comment (comments table, nested\n * reply).\n *\n * This operation allows registered users to create a new nested reply to an\n * existing comment. The parent comment is specified by 'commentId'. Input data\n * includes the reply content and optional metadata (e.g., authored by user,\n * timestamp auto-handled). The association is created by setting the new\n * comment's 'parent_id' to the specified 'commentId'.\n *\n * The 'comments' table enforces this hierarchy and business rules such as only\n * registered users may reply, and soft deletion logic applies. Error handling\n * ensures the parent comment exists and is not deleted. Moderation or anti-spam\n * business rules (e.g., rate limiting, sensitive word checks) are referenced\n * from business context but not detailed in schema.\n *\n * @param props.connection\n * @param props.commentId Parent comment's ID for threading context.\n * @param props.body Reply creation data (e.g., content, optional metadata).\n * @path /bbs/comments/:commentId/comments\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function postByCommentid(\n  connection: IConnection,\n  props: postByCommentid.Props,\n): Promise<postByCommentid.Response> {\n  return !!connection.simulate\n    ? postByCommentid.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...postByCommentid.METADATA,\n          path: postByCommentid.path(props),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace postByCommentid {\n  export type Props = {\n    /** Parent comment's ID for threading context. */\n    commentId: string & tags.Format<\"uuid\">;\n\n    /** Reply creation data (e.g., content, optional metadata). */\n    body: IBbsCommentReply.ICreate;\n  };\n  export type Body = IBbsCommentReply.ICreate;\n  export type Response = IBbsCommentReply;\n\n  export const METADATA = {\n    method: \"POST\",\n    path: \"/bbs/comments/:commentId/comments\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Omit<Props, \"body\">) =>\n    `/bbs/comments/${encodeURIComponent(props.commentId ?? \"null\")}/comments`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IBbsCommentReply => typia.random<IBbsCommentReply>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: postByCommentid.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: postByCommentid.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"commentId\")(() => typia.assert(props.commentId));\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * List all direct replies to a specific comment (comments table, threaded\n * replies).\n *\n * This operation retrieves a paginated and optionally filtered list of replies\n * to a specific parent comment. The 'comments' table supports self-referential\n * relationships for nested replies via the 'parent_id' field. Each retrieved\n * comment must have 'parent_id' matching the provided 'commentId'.\n *\n * Standard search, filtering, and pagination options are supported via the\n * request body. Only direct (not deeply nested) children are included. The\n * operation checks if the parent comment exists and is not deleted. If access\n * to the replies is restricted (e.g., if the parent comment is deleted or\n * private), the API must enforce rules accordingly.\n *\n * This operation is commonly used in threaded conversation UIs and supports\n * constructing the hierarchy of replies for discussion depth and transparency.\n *\n * @param props.connection\n * @param props.commentId Target parent comment's ID whose direct children are\n *   queried.\n * @param props.body Search and pagination options for replies to the comment.\n * @path /bbs/comments/:commentId/comments\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patchByCommentid(\n  connection: IConnection,\n  props: patchByCommentid.Props,\n): Promise<patchByCommentid.Response> {\n  return !!connection.simulate\n    ? patchByCommentid.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patchByCommentid.METADATA,\n          path: patchByCommentid.path(props),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace patchByCommentid {\n  export type Props = {\n    /** Target parent comment's ID whose direct children are queried. */\n    commentId: string & tags.Format<\"uuid\">;\n\n    /** Search and pagination options for replies to the comment. */\n    body: IBbsCommentReply.IRequest;\n  };\n  export type Body = IBbsCommentReply.IRequest;\n  export type Response = IPageIBbsCommentReply;\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/bbs/comments/:commentId/comments\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Omit<Props, \"body\">) =>\n    `/bbs/comments/${encodeURIComponent(props.commentId ?? \"null\")}/comments`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IPageIBbsCommentReply => typia.random<IPageIBbsCommentReply>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: patchByCommentid.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patchByCommentid.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"commentId\")(() => typia.assert(props.commentId));\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Get information for a specific reply to a comment (comments table, threaded\n * comment).\n *\n * This operation fetches the details of a specific reply to a given parent\n * comment, leveraging the 'comments' table's self-referential structure. It\n * checks that the reply exists, has its 'parent_id' set to the specified\n * 'commentId', and is not marked as deleted (soft delete logic).\n *\n * Useful for showing reply detail pages or in-line replies in the UI. Access\n * control ensures that deleted replies or those hidden for moderation are not\n * shown to ordinary users. The response includes all major comment fields\n * (content, author, created time, votes, etc.), as well as any relevant\n * metadata for thread navigation and moderation.\n *\n * @param props.connection\n * @param props.commentId Parent comment's ID (pid for threaded reply context).\n * @param props.id Reply comment's ID to retrieve.\n * @path /bbs/comments/:commentId/comments/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getByCommentidAndId(\n  connection: IConnection,\n  props: getByCommentidAndId.Props,\n): Promise<getByCommentidAndId.Response> {\n  return !!connection.simulate\n    ? getByCommentidAndId.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getByCommentidAndId.METADATA,\n          path: getByCommentidAndId.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace getByCommentidAndId {\n  export type Props = {\n    /** Parent comment's ID (pid for threaded reply context). */\n    commentId: string & tags.Format<\"uuid\">;\n\n    /** Reply comment's ID to retrieve. */\n    id: string & tags.Format<\"uuid\">;\n  };\n  export type Response = IBbsCommentReply;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/bbs/comments/:commentId/comments/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/bbs/comments/${encodeURIComponent(props.commentId ?? \"null\")}/comments/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IBbsCommentReply => typia.random<IBbsCommentReply>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: getByCommentidAndId.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getByCommentidAndId.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"commentId\")(() => typia.assert(props.commentId));\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Update a reply to a specific comment (comments table, edit threaded reply).\n *\n * This operation updates a reply to a given parent comment in the 'comments'\n * table. The system ensures that the target reply exists, is a direct reply to\n * the specified 'commentId', and is not deleted. Only allowed roles (the\n * author, moderators, administrators) may update the reply, subject to possible\n * time window constraints (business logic).\n *\n * Valid edits include changing the reply's text content and, where business\n * rules allow, updating moderation status, or fixing accidental errors. The\n * history is retained via an updated_at timestamp. Editing is restricted if a\n * reply has been deleted (soft delete) or if the editing time window has\n * expired. Response provides the updated reply details.\n *\n * @param props.connection\n * @param props.commentId Parent comment's ID for context.\n * @param props.id Reply comment's ID to update.\n * @param props.body Fields to update in the reply (e.g., new content,\n *   metadata).\n * @path /bbs/comments/:commentId/comments/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function putByCommentidAndId(\n  connection: IConnection,\n  props: putByCommentidAndId.Props,\n): Promise<putByCommentidAndId.Response> {\n  return !!connection.simulate\n    ? putByCommentidAndId.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...putByCommentidAndId.METADATA,\n          path: putByCommentidAndId.path(props),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace putByCommentidAndId {\n  export type Props = {\n    /** Parent comment's ID for context. */\n    commentId: string & tags.Format<\"uuid\">;\n\n    /** Reply comment's ID to update. */\n    id: string & tags.Format<\"uuid\">;\n\n    /** Fields to update in the reply (e.g., new content, metadata). */\n    body: IBbsCommentReply.IUpdate;\n  };\n  export type Body = IBbsCommentReply.IUpdate;\n  export type Response = IBbsCommentReply;\n\n  export const METADATA = {\n    method: \"PUT\",\n    path: \"/bbs/comments/:commentId/comments/:id\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Omit<Props, \"body\">) =>\n    `/bbs/comments/${encodeURIComponent(props.commentId ?? \"null\")}/comments/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IBbsCommentReply => typia.random<IBbsCommentReply>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: putByCommentidAndId.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: putByCommentidAndId.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"commentId\")(() => typia.assert(props.commentId));\n      assert.param(\"id\")(() => typia.assert(props.id));\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Delete a reply to a specific comment (comments table, soft-delete moderation\n * logic).\n *\n * This operation deletes a reply (nested comment) from a parent comment, as\n * defined in the self-referential structure of the 'comments' table. Instead of\n * a hard delete, it sets the 'deleted_at' field, preserving the reply for\n * moderation history and audit purposes.\n *\n * Only the reply's author, moderators, or administrators are authorized to\n * perform this action. Role mapping is enforced using data from 'users' and\n * 'user_roles' tables. The operation checks that the reply exists and is a\n * direct child of the specified parent comment.\n *\n * On error (e.g., invalid parent-child relationship, reply already deleted,\n * lack of permission), the system returns appropriate error codes/messages.\n * This ensures clean handling of thread integrity and preserves conversation\n * structure.\n *\n * @param props.connection\n * @param props.commentId Parent comment's ID for context.\n * @param props.id Reply comment's ID to delete.\n * @path /bbs/comments/:commentId/comments/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function eraseByCommentidAndId(\n  connection: IConnection,\n  props: eraseByCommentidAndId.Props,\n): Promise<void> {\n  return !!connection.simulate\n    ? eraseByCommentidAndId.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...eraseByCommentidAndId.METADATA,\n          path: eraseByCommentidAndId.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace eraseByCommentidAndId {\n  export type Props = {\n    /** Parent comment's ID for context. */\n    commentId: string & tags.Format<\"uuid\">;\n\n    /** Reply comment's ID to delete. */\n    id: string & tags.Format<\"uuid\">;\n  };\n\n  export const METADATA = {\n    method: \"DELETE\",\n    path: \"/bbs/comments/:commentId/comments/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/bbs/comments/${encodeURIComponent(props.commentId ?? \"null\")}/comments/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): void =>\n    typia.random<void>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: eraseByCommentidAndId.Props,\n  ): void => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: eraseByCommentidAndId.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"commentId\")(() => typia.assert(props.commentId));\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
      "src/api/functional/bbs/comments/index.ts": "export * as comments from \"./comments\";\n",
      "src/api/functional/bbs/votes/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IBbsVote } from \"../../../structures/IBbsVote\";\nimport { IPageIBbsVote } from \"../../../structures/IPageIBbsVote\";\n\n/**\n * Create a new vote for a post or comment (votes table, upvote/downvote logic).\n *\n * This operation creates a new vote record for the given user on the specified\n * target (either a post or a comment) as per the 'votes' table structure. The\n * request body must specify which target is being voted on, and the value\n * (either +1 or -1 per business rule).\n *\n * Business logic includes unique user/target constraint (a user cannot vote\n * twice on the same post or comment). On success, returns the created vote\n * resource. If the vote already exists, the system returns an appropriate error\n * or suggests updating the vote. Only authenticated users may vote. Permissions\n * and audit trail are enforced as per requirements analysis and database\n * comments.\n *\n * @param props.connection\n * @param props.body Vote creation input (target type, target ID, value).\n * @path /bbs/votes\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function post(\n  connection: IConnection,\n  props: post.Props,\n): Promise<post.Response> {\n  return !!connection.simulate\n    ? post.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...post.METADATA,\n          path: post.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace post {\n  export type Props = {\n    /** Vote creation input (target type, target ID, value). */\n    body: IBbsVote.ICreate;\n  };\n  export type Body = IBbsVote.ICreate;\n  export type Response = IBbsVote;\n\n  export const METADATA = {\n    method: \"POST\",\n    path: \"/bbs/votes\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/bbs/votes\";\n  export const random = (g?: Partial<typia.IRandomGenerator>): IBbsVote =>\n    typia.random<IBbsVote>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: post.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: post.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Query/search all votes across posts/comments (votes table, patch for advanced\n * search).\n *\n * This operation returns a paginated and/or filtered list of votes. The 'votes'\n * table supports querying by voter, content (post or comment), vote value, and\n * timestamp. Filtering and pagination information are specified via the request\n * body. This operation is intended for use by administrators, moderators, or\n * analytics tools. Business rules enforce visibility (e.g., users see only\n * their own votes unless they have elevated permissions).\n *\n * Standard pagination, search, and sorting are provided. Errors for invalid\n * parameters or unauthorized access are handled according to platform\n * requirements.\n *\n * @param props.connection\n * @param props.body Filters, pagination, and search fields for querying vote\n *   records.\n * @path /bbs/votes\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patch(\n  connection: IConnection,\n  props: patch.Props,\n): Promise<patch.Response> {\n  return !!connection.simulate\n    ? patch.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patch.METADATA,\n          path: patch.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace patch {\n  export type Props = {\n    /** Filters, pagination, and search fields for querying vote records. */\n    body: IBbsVote.IRequest;\n  };\n  export type Body = IBbsVote.IRequest;\n  export type Response = IPageIBbsVote;\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/bbs/votes\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/bbs/votes\";\n  export const random = (g?: Partial<typia.IRandomGenerator>): IPageIBbsVote =>\n    typia.random<IPageIBbsVote>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: patch.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patch.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Get a single vote record's details (votes table, role/visibility protection).\n *\n * This operation retrieves a single vote by its ID. Information includes which\n * user cast the vote (user_id), what it targeted (either a post or comment),\n * the value (+1 or -1, as per schema), and relevant timestamps. The operation\n * consults the 'votes' table directly by primary key.\n *\n * Business logic ensures that vote records are visible only to the voter\n * themselves or users with elevated privileges. Sensitive data handling\n * observes privacy, as votes reflect user opinions which may need to remain\n * confidential, per the requirements analysis. Errors are returned for invalid\n * IDs or unauthorized access.\n *\n * @param props.connection\n * @param props.id Vote record's ID to be fetched.\n * @path /bbs/votes/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getById(\n  connection: IConnection,\n  props: getById.Props,\n): Promise<getById.Response> {\n  return !!connection.simulate\n    ? getById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getById.METADATA,\n          path: getById.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace getById {\n  export type Props = {\n    /** Vote record's ID to be fetched. */\n    id: string & tags.Format<\"uuid\">;\n  };\n  export type Response = IBbsVote;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/bbs/votes/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/bbs/votes/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): IBbsVote =>\n    typia.random<IBbsVote>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: getById.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Update an existing vote (votes table, upvote/downvote change).\n *\n * This operation updates an existing vote, which is identified by its unique\n * ID. Only the owner (voter) of the vote or privileged roles (moderator/admin)\n * may perform updates. Fields that can be changed include 'value' (e.g., switch\n * an upvote to a downvote) and potentially metadata (e.g., audit fields). The\n * business rules from the schema and requirements analysis govern what can be\n * changed and by whom.\n *\n * Changes are reflected in the database and in derived content tallies. Errors\n * are returned if update rules are violated (e.g., changing someone else's\n * vote, updating a vote that doesn't exist, improper value assignment). On\n * success, returns updated vote resource.\n *\n * @param props.connection\n * @param props.id Vote record's ID to update.\n * @param props.body Updated vote fields (e.g., value).\n * @path /bbs/votes/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function putById(\n  connection: IConnection,\n  props: putById.Props,\n): Promise<putById.Response> {\n  return !!connection.simulate\n    ? putById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...putById.METADATA,\n          path: putById.path(props),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace putById {\n  export type Props = {\n    /** Vote record's ID to update. */\n    id: string & tags.Format<\"uuid\">;\n\n    /** Updated vote fields (e.g., value). */\n    body: IBbsVote.IUpdate;\n  };\n  export type Body = IBbsVote.IUpdate;\n  export type Response = IBbsVote;\n\n  export const METADATA = {\n    method: \"PUT\",\n    path: \"/bbs/votes/:id\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Omit<Props, \"body\">) =>\n    `/bbs/votes/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): IBbsVote =>\n    typia.random<IBbsVote>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: putById.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: putById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Delete a vote (votes table, enforced by unique user/target constraint).\n *\n * This operation deletes a vote record from the database. Only the vote's owner\n * (voter) or privileged roles (moderator/admin, based on 'user_roles') can\n * perform this operation. It removes the vote, freeing up the user to vote\n * again on the same post or comment in the future (as controlled by unique\n * constraints in the votes schema).\n *\n * Error responses are returned if the request is forbidden, the vote does not\n * exist, or the operation is not permitted for the resource. The operation\n * complies with audit and permission rules from requirements analysis and\n * schema.\n *\n * @param props.connection\n * @param props.id Vote record's ID to delete.\n * @path /bbs/votes/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function eraseById(\n  connection: IConnection,\n  props: eraseById.Props,\n): Promise<void> {\n  return !!connection.simulate\n    ? eraseById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...eraseById.METADATA,\n          path: eraseById.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace eraseById {\n  export type Props = {\n    /** Vote record's ID to delete. */\n    id: string & tags.Format<\"uuid\">;\n  };\n\n  export const METADATA = {\n    method: \"DELETE\",\n    path: \"/bbs/votes/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/bbs/votes/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): void =>\n    typia.random<void>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: eraseById.Props,\n  ): void => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: eraseById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
      "test/features/api/test_api_bbs_users_post.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\n\nimport { IBbsUsers } from \"@ORGANIZATION/PROJECT-api/lib/structures/IBbsUsers\";\n\nexport async function test_api_bbs_users_post(connection: api.IConnection) {\n  const output: IBbsUsers = await api.functional.bbs.users.post(connection, {\n    body: typia.random<IBbsUsers.ICreate>(),\n  });\n  typia.assert(output);\n}\n",
      "test/features/api/test_api_bbs_users_patch.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\n\nimport { IPageIBbsUsers } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIBbsUsers\";\nimport { IBbsUsers } from \"@ORGANIZATION/PROJECT-api/lib/structures/IBbsUsers\";\n\nexport async function test_api_bbs_users_patch(connection: api.IConnection) {\n  const output: IPageIBbsUsers = await api.functional.bbs.users.patch(\n    connection,\n    {\n      body: typia.random<IBbsUsers.IRequest>(),\n    },\n  );\n  typia.assert(output);\n}\n",
      "test/features/api/test_api_bbs_users_getById.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { IBbsUsers } from \"@ORGANIZATION/PROJECT-api/lib/structures/IBbsUsers\";\n\nexport async function test_api_bbs_users_getById(connection: api.IConnection) {\n  const output: IBbsUsers = await api.functional.bbs.users.getById(connection, {\n    id: typia.random<string & tags.Format<\"uuid\">>(),\n  });\n  typia.assert(output);\n}\n",
      "test/features/api/test_api_bbs_users_putById.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { IBbsUsers } from \"@ORGANIZATION/PROJECT-api/lib/structures/IBbsUsers\";\n\nexport async function test_api_bbs_users_putById(connection: api.IConnection) {\n  const output: IBbsUsers = await api.functional.bbs.users.putById(connection, {\n    id: typia.random<string & tags.Format<\"uuid\">>(),\n    body: typia.random<IBbsUsers.IUpdate>(),\n  });\n  typia.assert(output);\n}\n",
      "test/features/api/test_api_bbs_users_eraseById.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { IBbsUsers } from \"@ORGANIZATION/PROJECT-api/lib/structures/IBbsUsers\";\n\nexport async function test_api_bbs_users_eraseById(\n  connection: api.IConnection,\n) {\n  const output: IBbsUsers = await api.functional.bbs.users.eraseById(\n    connection,\n    {\n      id: typia.random<string & tags.Format<\"uuid\">>(),\n    },\n  );\n  typia.assert(output);\n}\n",
      "test/features/api/test_api_bbs_userRoles_post.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\n\nimport { IBbsUserRoles } from \"@ORGANIZATION/PROJECT-api/lib/structures/IBbsUserRoles\";\n\nexport async function test_api_bbs_userRoles_post(connection: api.IConnection) {\n  const output: IBbsUserRoles = await api.functional.bbs.userRoles.post(\n    connection,\n    {\n      body: typia.random<IBbsUserRoles.ICreate>(),\n    },\n  );\n  typia.assert(output);\n}\n",
      "test/features/api/test_api_bbs_userRoles_patch.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\n\nimport { IPageIBbsUserRoles } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIBbsUserRoles\";\nimport { IBbsUserRoles } from \"@ORGANIZATION/PROJECT-api/lib/structures/IBbsUserRoles\";\n\nexport async function test_api_bbs_userRoles_patch(\n  connection: api.IConnection,\n) {\n  const output: IPageIBbsUserRoles = await api.functional.bbs.userRoles.patch(\n    connection,\n    {\n      body: typia.random<IBbsUserRoles.IRequest>(),\n    },\n  );\n  typia.assert(output);\n}\n",
      "test/features/api/test_api_bbs_userRoles_getById.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { IBbsUserRoles } from \"@ORGANIZATION/PROJECT-api/lib/structures/IBbsUserRoles\";\n\nexport async function test_api_bbs_userRoles_getById(\n  connection: api.IConnection,\n) {\n  const output: IBbsUserRoles = await api.functional.bbs.userRoles.getById(\n    connection,\n    {\n      id: typia.random<string & tags.Format<\"uuid\">>(),\n    },\n  );\n  typia.assert(output);\n}\n",
      "test/features/api/test_api_bbs_userRoles_putById.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { IBbsUserRoles } from \"@ORGANIZATION/PROJECT-api/lib/structures/IBbsUserRoles\";\n\nexport async function test_api_bbs_userRoles_putById(\n  connection: api.IConnection,\n) {\n  const output: IBbsUserRoles = await api.functional.bbs.userRoles.putById(\n    connection,\n    {\n      id: typia.random<string & tags.Format<\"uuid\">>(),\n      body: typia.random<IBbsUserRoles.IUpdate>(),\n    },\n  );\n  typia.assert(output);\n}\n",
      "test/features/api/test_api_bbs_userRoles_eraseById.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { IBbsUserRoles } from \"@ORGANIZATION/PROJECT-api/lib/structures/IBbsUserRoles\";\n\nexport async function test_api_bbs_userRoles_eraseById(\n  connection: api.IConnection,\n) {\n  const output: IBbsUserRoles = await api.functional.bbs.userRoles.eraseById(\n    connection,\n    {\n      id: typia.random<string & tags.Format<\"uuid\">>(),\n    },\n  );\n  typia.assert(output);\n}\n",
      "test/features/api/test_api_bbs_categories_post.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\n\nimport { bbsCategories } from \"@ORGANIZATION/PROJECT-api/lib/structures/bbsCategories\";\n\nexport async function test_api_bbs_categories_post(\n  connection: api.IConnection,\n) {\n  const output: bbsCategories = await api.functional.bbs.categories.post(\n    connection,\n    {\n      body: typia.random<bbsCategories.ICreate>(),\n    },\n  );\n  typia.assert(output);\n}\n",
      "test/features/api/test_api_bbs_categories_patch.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\n\nimport { IPageIBbsCategories } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIBbsCategories\";\nimport { IBbsCategories } from \"@ORGANIZATION/PROJECT-api/lib/structures/IBbsCategories\";\n\nexport async function test_api_bbs_categories_patch(\n  connection: api.IConnection,\n) {\n  const output: IPageIBbsCategories = await api.functional.bbs.categories.patch(\n    connection,\n    {\n      body: typia.random<IBbsCategories.IRequest>(),\n    },\n  );\n  typia.assert(output);\n}\n",
      "test/features/api/test_api_bbs_categories_getById.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { IBbsCategories } from \"@ORGANIZATION/PROJECT-api/lib/structures/IBbsCategories\";\n\nexport async function test_api_bbs_categories_getById(\n  connection: api.IConnection,\n) {\n  const output: IBbsCategories = await api.functional.bbs.categories.getById(\n    connection,\n    {\n      id: typia.random<string & tags.Format<\"uuid\">>(),\n    },\n  );\n  typia.assert(output);\n}\n",
      "test/features/api/test_api_bbs_categories_putById.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { bbsCategories } from \"@ORGANIZATION/PROJECT-api/lib/structures/bbsCategories\";\n\nexport async function test_api_bbs_categories_putById(\n  connection: api.IConnection,\n) {\n  const output: bbsCategories = await api.functional.bbs.categories.putById(\n    connection,\n    {\n      id: typia.random<string & tags.Format<\"uuid\">>(),\n      body: typia.random<bbsCategories.IUpdate>(),\n    },\n  );\n  typia.assert(output);\n}\n",
      "test/features/api/test_api_bbs_categories_eraseById.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { bbsCategories } from \"@ORGANIZATION/PROJECT-api/lib/structures/bbsCategories\";\n\nexport async function test_api_bbs_categories_eraseById(\n  connection: api.IConnection,\n) {\n  const output: bbsCategories = await api.functional.bbs.categories.eraseById(\n    connection,\n    {\n      id: typia.random<string & tags.Format<\"uuid\">>(),\n    },\n  );\n  typia.assert(output);\n}\n",
      "test/features/api/test_api_bbs_posts_post.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\n\nimport { bbsPosts } from \"@ORGANIZATION/PROJECT-api/lib/structures/bbsPosts\";\n\nexport async function test_api_bbs_posts_post(connection: api.IConnection) {\n  const output: bbsPosts = await api.functional.bbs.posts.post(connection, {\n    body: typia.random<bbsPosts.ICreate>(),\n  });\n  typia.assert(output);\n}\n",
      "test/features/api/test_api_bbs_posts_patch.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\n\nimport { IPageBbsPosts } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageBbsPosts\";\nimport { bbsPosts } from \"@ORGANIZATION/PROJECT-api/lib/structures/bbsPosts\";\n\nexport async function test_api_bbs_posts_patch(connection: api.IConnection) {\n  const output: IPageBbsPosts = await api.functional.bbs.posts.patch(\n    connection,\n    {\n      body: typia.random<bbsPosts.IRequest>(),\n    },\n  );\n  typia.assert(output);\n}\n",
      "test/features/api/test_api_bbs_posts_getById.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { bbsPosts } from \"@ORGANIZATION/PROJECT-api/lib/structures/bbsPosts\";\n\nexport async function test_api_bbs_posts_getById(connection: api.IConnection) {\n  const output: bbsPosts = await api.functional.bbs.posts.getById(connection, {\n    id: typia.random<string & tags.Format<\"uuid\">>(),\n  });\n  typia.assert(output);\n}\n",
      "test/features/api/test_api_bbs_posts_putById.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { bbsPosts } from \"@ORGANIZATION/PROJECT-api/lib/structures/bbsPosts\";\n\nexport async function test_api_bbs_posts_putById(connection: api.IConnection) {\n  const output: bbsPosts = await api.functional.bbs.posts.putById(connection, {\n    id: typia.random<string & tags.Format<\"uuid\">>(),\n    body: typia.random<bbsPosts.IUpdate>(),\n  });\n  typia.assert(output);\n}\n",
      "test/features/api/test_api_bbs_posts_eraseById.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { bbsPosts } from \"@ORGANIZATION/PROJECT-api/lib/structures/bbsPosts\";\n\nexport async function test_api_bbs_posts_eraseById(\n  connection: api.IConnection,\n) {\n  const output: bbsPosts = await api.functional.bbs.posts.eraseById(\n    connection,\n    {\n      id: typia.random<string & tags.Format<\"uuid\">>(),\n    },\n  );\n  typia.assert(output);\n}\n",
      "test/features/api/test_api_bbs_posts_comments_postByPostid.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { bbsComments } from \"@ORGANIZATION/PROJECT-api/lib/structures/bbsComments\";\n\nexport async function test_api_bbs_posts_comments_postByPostid(\n  connection: api.IConnection,\n) {\n  const output: bbsComments =\n    await api.functional.bbs.posts.comments.postByPostid(connection, {\n      postId: typia.random<string & tags.Format<\"uuid\">>(),\n      body: typia.random<bbsComments.ICreate>(),\n    });\n  typia.assert(output);\n}\n",
      "test/features/api/test_api_bbs_posts_comments_patchByPostid.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { IPageBbsComments } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageBbsComments\";\nimport { bbsComments } from \"@ORGANIZATION/PROJECT-api/lib/structures/bbsComments\";\n\nexport async function test_api_bbs_posts_comments_patchByPostid(\n  connection: api.IConnection,\n) {\n  const output: IPageBbsComments =\n    await api.functional.bbs.posts.comments.patchByPostid(connection, {\n      postId: typia.random<string & tags.Format<\"uuid\">>(),\n      body: typia.random<bbsComments.IRequest>(),\n    });\n  typia.assert(output);\n}\n",
      "test/features/api/test_api_bbs_posts_comments_getByPostidAndId.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { bbsComments } from \"@ORGANIZATION/PROJECT-api/lib/structures/bbsComments\";\n\nexport async function test_api_bbs_posts_comments_getByPostidAndId(\n  connection: api.IConnection,\n) {\n  const output: bbsComments =\n    await api.functional.bbs.posts.comments.getByPostidAndId(connection, {\n      postId: typia.random<string & tags.Format<\"uuid\">>(),\n      id: typia.random<string & tags.Format<\"uuid\">>(),\n    });\n  typia.assert(output);\n}\n",
      "test/features/api/test_api_bbs_posts_comments_putByPostidAndId.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { bbsComments } from \"@ORGANIZATION/PROJECT-api/lib/structures/bbsComments\";\n\nexport async function test_api_bbs_posts_comments_putByPostidAndId(\n  connection: api.IConnection,\n) {\n  const output: bbsComments =\n    await api.functional.bbs.posts.comments.putByPostidAndId(connection, {\n      postId: typia.random<string & tags.Format<\"uuid\">>(),\n      id: typia.random<string & tags.Format<\"uuid\">>(),\n      body: typia.random<bbsComments.IUpdate>(),\n    });\n  typia.assert(output);\n}\n",
      "test/features/api/test_api_bbs_posts_comments_eraseByPostidAndId.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nexport async function test_api_bbs_posts_comments_eraseByPostidAndId(\n  connection: api.IConnection,\n) {\n  const output = await api.functional.bbs.posts.comments.eraseByPostidAndId(\n    connection,\n    {\n      postId: typia.random<string & tags.Format<\"uuid\">>(),\n      id: typia.random<string & tags.Format<\"uuid\">>(),\n    },\n  );\n  typia.assert(output);\n}\n",
      "test/features/api/test_api_bbs_comments_comments_postByCommentid.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { IBbsCommentReply } from \"@ORGANIZATION/PROJECT-api/lib/structures/IBbsCommentReply\";\n\nexport async function test_api_bbs_comments_comments_postByCommentid(\n  connection: api.IConnection,\n) {\n  const output: IBbsCommentReply =\n    await api.functional.bbs.comments.comments.postByCommentid(connection, {\n      commentId: typia.random<string & tags.Format<\"uuid\">>(),\n      body: typia.random<IBbsCommentReply.ICreate>(),\n    });\n  typia.assert(output);\n}\n",
      "test/features/api/test_api_bbs_comments_comments_patchByCommentid.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { IPageIBbsCommentReply } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIBbsCommentReply\";\nimport { IBbsCommentReply } from \"@ORGANIZATION/PROJECT-api/lib/structures/IBbsCommentReply\";\n\nexport async function test_api_bbs_comments_comments_patchByCommentid(\n  connection: api.IConnection,\n) {\n  const output: IPageIBbsCommentReply =\n    await api.functional.bbs.comments.comments.patchByCommentid(connection, {\n      commentId: typia.random<string & tags.Format<\"uuid\">>(),\n      body: typia.random<IBbsCommentReply.IRequest>(),\n    });\n  typia.assert(output);\n}\n",
      "test/features/api/test_api_bbs_comments_comments_getByCommentidAndId.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { IBbsCommentReply } from \"@ORGANIZATION/PROJECT-api/lib/structures/IBbsCommentReply\";\n\nexport async function test_api_bbs_comments_comments_getByCommentidAndId(\n  connection: api.IConnection,\n) {\n  const output: IBbsCommentReply =\n    await api.functional.bbs.comments.comments.getByCommentidAndId(connection, {\n      commentId: typia.random<string & tags.Format<\"uuid\">>(),\n      id: typia.random<string & tags.Format<\"uuid\">>(),\n    });\n  typia.assert(output);\n}\n",
      "test/features/api/test_api_bbs_comments_comments_putByCommentidAndId.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { IBbsCommentReply } from \"@ORGANIZATION/PROJECT-api/lib/structures/IBbsCommentReply\";\n\nexport async function test_api_bbs_comments_comments_putByCommentidAndId(\n  connection: api.IConnection,\n) {\n  const output: IBbsCommentReply =\n    await api.functional.bbs.comments.comments.putByCommentidAndId(connection, {\n      commentId: typia.random<string & tags.Format<\"uuid\">>(),\n      id: typia.random<string & tags.Format<\"uuid\">>(),\n      body: typia.random<IBbsCommentReply.IUpdate>(),\n    });\n  typia.assert(output);\n}\n",
      "test/features/api/test_api_bbs_comments_comments_eraseByCommentidAndId.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nexport async function test_api_bbs_comments_comments_eraseByCommentidAndId(\n  connection: api.IConnection,\n) {\n  const output =\n    await api.functional.bbs.comments.comments.eraseByCommentidAndId(\n      connection,\n      {\n        commentId: typia.random<string & tags.Format<\"uuid\">>(),\n        id: typia.random<string & tags.Format<\"uuid\">>(),\n      },\n    );\n  typia.assert(output);\n}\n",
      "test/features/api/test_api_bbs_votes_post.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\n\nimport { IBbsVote } from \"@ORGANIZATION/PROJECT-api/lib/structures/IBbsVote\";\n\nexport async function test_api_bbs_votes_post(connection: api.IConnection) {\n  const output: IBbsVote = await api.functional.bbs.votes.post(connection, {\n    body: typia.random<IBbsVote.ICreate>(),\n  });\n  typia.assert(output);\n}\n",
      "test/features/api/test_api_bbs_votes_patch.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\n\nimport { IPageIBbsVote } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIBbsVote\";\nimport { IBbsVote } from \"@ORGANIZATION/PROJECT-api/lib/structures/IBbsVote\";\n\nexport async function test_api_bbs_votes_patch(connection: api.IConnection) {\n  const output: IPageIBbsVote = await api.functional.bbs.votes.patch(\n    connection,\n    {\n      body: typia.random<IBbsVote.IRequest>(),\n    },\n  );\n  typia.assert(output);\n}\n",
      "test/features/api/test_api_bbs_votes_getById.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { IBbsVote } from \"@ORGANIZATION/PROJECT-api/lib/structures/IBbsVote\";\n\nexport async function test_api_bbs_votes_getById(connection: api.IConnection) {\n  const output: IBbsVote = await api.functional.bbs.votes.getById(connection, {\n    id: typia.random<string & tags.Format<\"uuid\">>(),\n  });\n  typia.assert(output);\n}\n",
      "test/features/api/test_api_bbs_votes_putById.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { IBbsVote } from \"@ORGANIZATION/PROJECT-api/lib/structures/IBbsVote\";\n\nexport async function test_api_bbs_votes_putById(connection: api.IConnection) {\n  const output: IBbsVote = await api.functional.bbs.votes.putById(connection, {\n    id: typia.random<string & tags.Format<\"uuid\">>(),\n    body: typia.random<IBbsVote.IUpdate>(),\n  });\n  typia.assert(output);\n}\n",
      "test/features/api/test_api_bbs_votes_eraseById.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nexport async function test_api_bbs_votes_eraseById(\n  connection: api.IConnection,\n) {\n  const output = await api.functional.bbs.votes.eraseById(connection, {\n    id: typia.random<string & tags.Format<\"uuid\">>(),\n  });\n  typia.assert(output);\n}\n",
      "packages/api/swagger.json": "{\n  \"openapi\": \"3.1.0\",\n  \"paths\": {\n    \"/bbs/users\": {\n      \"patch\": {\n        \"summary\": \"List users with search, filtering, and pagination (users table).\",\n        \"description\": \"This operation enables privileged users (moderators, administrators) to retrieve a paginated list of all users registered on the discussion board. The returned user data includes public profile information (username, email, bio), their user role, account status, and registration metadata. Filtering and searching capabilities provide powerful moderation and community management tools, allowing admins to quickly investigate misuse, track new registrations, or query dormant/suspended accounts. Pagination parameters prevent excessive database load. The endpoint ensures security by requiring bearer authentication and restricting access to users with sufficient privileges (moderator or administrator). This operation references the users Prisma schema model, specifically all columns described (id, user_role_id, username, email, bio, status, created_at, updated_at). The response should not include password hashes. Validation includes correct filter types, secure pagination defaults, and correct authorization checks. This operation may be combined with single-user lookup or management operations for a full user administration workflow.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IBbsUsers.IRequest\"\n              }\n            }\n          },\n          \"description\": \"Request parameters for user list/search, including filters, pagination, and sort details.\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPageIBbsUsers\"\n                }\n              }\n            },\n            \"description\": \"Paginated list of users matching search and filter criteria.\"\n          }\n        }\n      },\n      \"post\": {\n        \"summary\": \"Register a new user account (users table).\",\n        \"description\": \"This operation allows either new users to self-register (signup) or administrative users to create new user accounts. Inputs include: username, email, password (plain, which will be hashed), role, and optional biography. Usernames and emails must be unique system-wide as enforced by the DB. Role assignment references the user_roles table (role name or ID). On successful creation, returns full non-sensitive account data (never returns password hash or plain password). Validation includes strong password policies, correctly-formed emails, unique username check, assignment of allowed roles, and correct audit metadata. Security policies ensure only authorized clients can create moderator/administrator accounts. Relationship: users references user_roles via user_role_id (UUID). The operation complements authentication endpoints and supports user onboarding workflows. Error handling includes duplicate entries, invalid roles, and input format errors.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IBbsUsers.ICreate\"\n              }\n            }\n          },\n          \"description\": \"User account registration information, including username, email, password, role, and optional bio.\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"201\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IBbsUsers\"\n                }\n              }\n            },\n            \"description\": \"Newly created user profile (excluding credential data).\"\n          }\n        }\n      }\n    },\n    \"/bbs/users/{id}\": {\n      \"get\": {\n        \"summary\": \"Retrieve a user's profile/account by user ID (users table).\",\n        \"description\": \"This endpoint retrieves the full account and public profile information for a specific user, as identified by their UUID. It is used for account management, profile viewing, and moderation. The returned details include username, bio, email, role (with full description), account status, and timestamps (created_at, updated_at). Account credentials (such as the password_hash) are never returned for security reasons. The endpoint may be used by administrators or moderators during audits, dispute resolution, or assisting users. Follows the users Prisma schema for all properties and relationships. Handles missing/deleted users gracefully with informative error responses. Security validation restricts access to authorized roles only, typically moderator or administrator.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Target user's UUID\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IBbsUsers\"\n                }\n              }\n            },\n            \"description\": \"User profile and account metadata, excluding sensitive credential data.\"\n          }\n        }\n      },\n      \"put\": {\n        \"summary\": \"Update an existing user profile or account (users table).\",\n        \"description\": \"This endpoint lets administrators or the users themselves update user profile information (username, email, bio), administrative account status (active, suspended, banned, etc.), or reassign user role (referencing user_roles table). Changing credentials (password) is handled by a separate workflow, but email and username uniqueness is always enforced. Security rules ensure only allowed users (self, moderator, admin) can update the target account. All changes are subject to full validation against the business rules in the requirements document and Prisma schema. Audit fields (updated_at) are set by the backend. The endpoint can be used in workflows for profile updates, role upgrades, or moderation actions. Errors include duplicate username/email or unpermitted actions.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Target user's UUID\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IBbsUsers.IUpdate\"\n              }\n            }\n          },\n          \"description\": \"Profile/account update payload (username, bio, email, role, status, but not password).\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IBbsUsers\"\n                }\n              }\n            },\n            \"description\": \"Updated user profile/account, excluding secret fields.\"\n          }\n        }\n      },\n      \"delete\": {\n        \"summary\": \"Soft-delete (deactivate) a user by status update (users table).\",\n        \"description\": \"This operation allows administrators or moderators to deactivate or remove a user account without physically deleting the record from the database, preserving audit trails and possible restoration. Actual implementation sets the status field of the user record (users table) to a value like 'deleted', 'banned', or 'suspended'. Only privileged users (administrators, moderators) may execute this unless it's for self-removal. Associated content (posts/comments) are retained. This operation references account removal business logic from requirements and Prisma schema business rules. All necessary validation, audit, and error handling logic are included. Deactivation is irreversible except by subsequent restoration workflow.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Target user's UUID\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IBbsUsers\"\n                }\n              }\n            },\n            \"description\": \"Deleted/deactivated user profile for audit/reference.\"\n          }\n        }\n      }\n    },\n    \"/bbs/userRoles\": {\n      \"patch\": {\n        \"summary\": \"List user roles with search and pagination (user_roles table).\",\n        \"description\": \"List the roles available for assignment to users, as per the user_roles business table (roles like member, moderator, administrator). Supports pagination, filtering, and search on role names or descriptions, assisting administrators and registration workflows in finding or displaying available roles. Related to users table by user_role_id. The endpoint returns role information but does not expose any linked user personal data. Supports role management, onboarding, and auditing. Authorization is required, typically for system administration staff. Used alongside user creation and update APIs to ensure valid references.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IBbsUserRoles.IRequest\"\n              }\n            }\n          },\n          \"description\": \"Request parameters for user role list/search, supporting filtering and pagination.\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPageIBbsUserRoles\"\n                }\n              }\n            },\n            \"description\": \"Paginated list of user roles matching the query.\"\n          }\n        }\n      },\n      \"post\": {\n        \"summary\": \"Create a new user role (user_roles table).\",\n        \"description\": \"This operation allows system administrators to define and create new user roles, expanding the range of permissions and governance on the discussion board. Input includes the unique role name (e.g., 'community_manager'), and a text description outlining permissions and duties. Validation enforces uniqueness of the role name, and the description is required for audit and clarity. May be used in onboarding or registration flows to offer new kinds of user experiences (e.g., temporary roles). All relationships and constraints are as defined in user_roles Prisma model. Error handling covers duplicates and format errors. Audit metadata is tracked by the backend.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IBbsUserRoles.ICreate\"\n              }\n            }\n          },\n          \"description\": \"Role creation payload (unique name, descriptive text).\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"201\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IBbsUserRoles\"\n                }\n              }\n            },\n            \"description\": \"Details for the newly created user role.\"\n          }\n        }\n      }\n    },\n    \"/bbs/userRoles/{id}\": {\n      \"get\": {\n        \"summary\": \"Retrieve a user role by ID (user_roles table).\",\n        \"description\": \"Get metadata about a specific user role, identified by its UUID. Returns the unique name and full description of role authority, as defined in the user_roles Prisma table and associated requirements. Used for audit checks, onboarding selection, or administrative validation (e.g., displaying what a moderator can do). Access is required for system administrators or similar privileged roles. Handles missing/invalid IDs gracefully. The endpoint does not expose user information, only the role metadata.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Target role's UUID\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IBbsUserRoles\"\n                }\n              }\n            },\n            \"description\": \"Role label and description from user_roles table.\"\n          }\n        }\n      },\n      \"put\": {\n        \"summary\": \"Update existing user role by role ID (user_roles table).\",\n        \"description\": \"This operation edits the label and description of an existing user role, updating governance or onboarding configuration. Only permitted users (administrators) can invoke it. Input: role ID (UUID), new name, and/or new description. Enforces unique name and proper validation. Responses include the updated role descriptor. Used along with other role management APIs for dynamic permissions adjustments. Covers all role metadata per user_roles Prisma schema. Handles invalid input, duplicate names, or permissions errors. Returns updated user role metadata for confirmation.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Target role's UUID\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IBbsUserRoles.IUpdate\"\n              }\n            }\n          },\n          \"description\": \"User role update payload (new name, description).\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IBbsUserRoles\"\n                }\n              }\n            },\n            \"description\": \"Updated user role metadata.\"\n          }\n        }\n      },\n      \"delete\": {\n        \"summary\": \"Deactivate (soft-delete) user role by ID (user_roles table).\",\n        \"description\": \"Allows system administrators to deactivate a role in the user_roles table. In practice, this might mean preventing new users from being assigned this role, but the role metadata remains for audit and traceability. The endpoint does not physically remove the record. Input is the role's UUID. Can be combined with user management endpoints for full administrative functionality. Authorization and permissions are strictly enforced. Responses document the now-inactive/deleted state. Error handling includes referencing non-existent or protected roles. Audit/meta info is retained.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Target role's UUID\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IBbsUserRoles\"\n                }\n              }\n            },\n            \"description\": \"Deactivated user role metadata for audit/reference.\"\n          }\n        }\n      }\n    },\n    \"/bbs/categories\": {\n      \"patch\": {\n        \"summary\": \"List post categories with search and pagination (categories table).\",\n        \"description\": \"This endpoint allows clients to list the discussion categories (topic areas, such as 'Politics', 'Economics') under which posts are organized. Supports optional filtering/search, useful for navigation, onboarding, and content creation flows. Uses pagination for performance. Does not disclose posts, only the category metadata (id, name, description, created_at) from the categories Prisma schema. No relationships to users are returned. Accessible to all users, including visitors without authentication by default, but may also support administrative filtering enhancements. Commonly used to build navigation bars or prompt users to choose a category when creating content. Handles invalid filters and pagination gracefully.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IBbsCategories.IRequest\"\n              }\n            }\n          },\n          \"description\": \"Category query/search/pagination options.\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPageIBbsCategories\"\n                }\n              }\n            },\n            \"description\": \"Paginated list of discussion categories.\"\n          }\n        }\n      },\n      \"post\": {\n        \"summary\": \"Create a new category (BBS: categories table).\",\n        \"description\": \"This API allows an administrator to create a new discussion category in the BBS platform. By supplying necessary information such as category name and description, the system adds a new record to the 'categories' table. Administrators should ensure names are unique to avoid conflicts with existing categories.\\n\\nAccess to this API is restricted to authenticated administrators, as only they may modify the set of available discussion categories. Upon successful creation, a new category entry is visible and available for post assignment by all users, supporting better board organization.\\n\\nIf the submitted category name already exists, the API will return an error indicating the name must be unique. Validation rules also require non-empty strings for both name and description fields.\\n\\nRelated operations include listing categories, updating (PUT), and deleting (DELETE) existing categories. This endpoint is essential for maintaining the topical structure of the BBS, making it easier for users to navigate and participate in relevant discussions.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/bbsCategories.ICreate\"\n              }\n            }\n          },\n          \"description\": \"Information about the new category to create, including name and description.\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"201\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/bbsCategories\"\n                }\n              }\n            },\n            \"description\": \"Data of the newly created category.\"\n          }\n        }\n      }\n    },\n    \"/bbs/categories/{id}\": {\n      \"get\": {\n        \"summary\": \"Get a single category's details by ID (categories table).\",\n        \"description\": \"This endpoint fetches the name, description, and creation date for a specific discussion category. The input is the category's UUID. Used by clients or admins to display detailed category information (such as when viewing the category page or offering category selection in post creation). Does not return post data itself, only the category metadata as defined in the categories Prisma schema. Handles invalid/missing category gracefully. No relationships are exposed, only direct metadata. Authorization is open by default but may enforce further checks for admin/management views. Used in category navigation, post composition, or audit reporting. Audit trail (created_at) is returned for management.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Target category's UUID\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IBbsCategories\"\n                }\n              }\n            },\n            \"description\": \"Category metadata (name, description, created date etc).\"\n          }\n        }\n      },\n      \"put\": {\n        \"summary\": \"Update a category's details (BBS: categories table).\",\n        \"description\": \"This API allows authenticated administrators to update the name or description of a discussion category identified by its unique 'id'. The update operation references the 'categories' table and enforces uniqueness for category names and requires non-empty values. Only administrators may perform this action, and each request must specify the category's identifier in the path. \\n\\nAttempts to change the category name to one already in use will result in a validation error. The update operation also prevents accidental erasure of required information by ensuring both the name and description remain populated after editing. Related endpoints include category creation (POST), deletion (DELETE), and listing/searching operations for categories.\\n\\nOn success, the endpoint returns the updated category information, reflecting all changes for immediate use in the system.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"The identifier of the category to update.\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/bbsCategories.IUpdate\"\n              }\n            }\n          },\n          \"description\": \"Updated information for the specified category.\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/bbsCategories\"\n                }\n              }\n            },\n            \"description\": \"The updated category data.\"\n          }\n        }\n      },\n      \"delete\": {\n        \"summary\": \"Delete a category by ID (BBS: categories table).\",\n        \"description\": \"This API endpoint allows an authenticated administrator to delete a discussion category by its ID from the BBS system. It removes the specified record from the 'categories' table. Prior to deletion, the system checks for posts referencing this category; administrators may need to reassign or handle these posts to maintain board integrity.\\n\\nOnly users with appropriate administrator roles (as defined in the 'user_roles' table) are permitted to invoke this operation. Attempts to delete a category with dependent posts may result in an error until those dependencies are resolved. On successful completion, the category is permanently removed from the database; deleted category names can be reused when creating new categories.\\n\\nRelated endpoints include creating, updating, and listing categories.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"The identifier of the category to delete.\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/bbsCategories\"\n                }\n              }\n            },\n            \"description\": \"Confirmation of deletion or details about the deleted category.\"\n          }\n        }\n      }\n    },\n    \"/bbs/posts\": {\n      \"patch\": {\n        \"summary\": \"Search and list posts with filtering and pagination (BBS: posts table).\",\n        \"description\": \"This API allows users to list and search through discussion posts on the BBS platform by querying the 'posts' table. The endpoint supports pagination, keyword search, category-based filtering, sorting by date or popularity, and other advanced query options as per best practice standards.\\n\\nBoth registered members and visitors can use this endpoint (though access to full content or additional metadata may be limited for visitors). Results typically return basic post details—such as title, author summary, vote tallies, timestamps—and allow users to quickly find, browse, and analyze current discussions.\\n\\nIf the query contains unsupported or invalid parameters, the system returns an appropriate error. This endpoint is commonly used alongside post creation (POST), update (PUT), detail view (GET), and deletion (DELETE) operations.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/bbsPosts.IRequest\"\n              }\n            }\n          },\n          \"description\": \"Search, filter, and pagination options for retrieving posts.\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPageBbsPosts\"\n                }\n              }\n            },\n            \"description\": \"A paginated list of post summaries or details.\"\n          }\n        }\n      },\n      \"post\": {\n        \"summary\": \"Create a new post (BBS: posts table).\",\n        \"description\": \"This API endpoint enables registered users to start a new discussion by submitting a post to the BBS platform. The client must provide all required information: title, body content, associated category, and, implicitly, the user's identity (via authentication). \\n\\nThe system records each new post in the 'posts' table and links it to the author's user record and the assigned category. Constraints ensure titles and content are non-empty, with a valid category reference. \\n\\nUpon success, the new post (with its ID and relevant metadata) is immediately available for searching, viewing, and commenting. The operation enforces organization and content standards, returning validation errors if requirements are unmet. \\n\\nPost-creation, users may view, edit, or delete their posts, while moderators can perform additional actions as per role. This endpoint is closely related to GET, PUT, and DELETE operations on posts.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/bbsPosts.ICreate\"\n              }\n            }\n          },\n          \"description\": \"Information for the new post, including title, content, and category ID.\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"201\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/bbsPosts\"\n                }\n              }\n            },\n            \"description\": \"Data for the newly created post, including all metadata.\"\n          }\n        }\n      }\n    },\n    \"/bbs/posts/{id}\": {\n      \"get\": {\n        \"summary\": \"Get detailed info for a specific post (BBS: posts table).\",\n        \"description\": \"This API endpoint allows a user to fetch complete details about a single post, identified by its UUID. It is tied to the 'posts' table and is available to visitors and registered members. Returned data includes the post title, content, author summary, associated category, creation and update times, and vote tallies. \\n\\nThis operation is essential for navigating from post lists to detailed thread views, supporting actions such as voting or commenting (when logged in). If the requested post does not exist, the API returns an appropriate not-found error. Related endpoints include post listing (PATCH /bbs/posts), post creation (POST), updating (PUT), and deletion (DELETE).\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"The unique identifier of the post to retrieve.\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/bbsPosts\"\n                }\n              }\n            },\n            \"description\": \"Full details for the specified post.\"\n          }\n        }\n      },\n      \"put\": {\n        \"summary\": \"Update a post's details (BBS: posts table).\",\n        \"description\": \"This API allows the original author (or, in special cases, a moderator/administrator) to update an existing post identified by its UUID. The client supplies updated values for title, content, or other modifiable fields. The 'posts' table enforces that only the recorded author or privileged account can submit updates to a given post record.\\n\\nThe system maintains a history of 'updated_at' timestamps and can restrict updates to within certain time windows, as described by business requirements. Attempting to update with invalid data (missing or duplicate title, empty content, invalid references) produces an error. Related endpoints include post creation (POST), detailed retrieval (GET), and deletion (DELETE).\\n\\nThe API returns the updated post data upon success, immediately reflecting any changes in subsequent queries.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"The unique post identifier to update.\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/bbsPosts.IUpdate\"\n              }\n            }\n          },\n          \"description\": \"Updated values for the target post (title, content, category, etc.).\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/bbsPosts\"\n                }\n              }\n            },\n            \"description\": \"The modified post record after update.\"\n          }\n        }\n      },\n      \"delete\": {\n        \"summary\": \"Delete a post by ID (BBS: posts table).\",\n        \"description\": \"This API allows a post author or an authorized moderator/administrator to remove a post from the BBS platform. The system marks the post as deleted (soft delete) or permanently deletes the record from the 'posts' table per business and moderation rules. \\n\\nAccess controls ensure only the post's author or properly credentialed staff may invoke this endpoint. The system prevents posts with active dependency violations (such as non-removable comments) from being deleted outright and may require additional steps.\\n\\nUpon success, the response confirms deletion status, and the post is hidden from general listing and searches. Related API endpoints: post creation (POST), detail view (GET), update (PUT), and comment management for associated replies.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"The unique post identifier to delete.\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/bbsPosts\"\n                }\n              }\n            },\n            \"description\": \"Confirmation or record of post deletion.\"\n          }\n        }\n      }\n    },\n    \"/bbs/posts/{postId}/comments\": {\n      \"patch\": {\n        \"summary\": \"List or search comments for a specified post (BBS: comments table).\",\n        \"description\": \"This API allows users to retrieve a list of comments for a specific post, identified by 'postId'. Supports query options for filtering by author, time range, reply depth, and more—including pagination and sort order. The underlying 'comments' table returns summaries or basics details of each comment thread or reply chain, supporting threaded conversation navigation.\\n\\nBoth authenticated users and visitors can access this operation, but may see different levels of detail according to permissions. The endpoint is closely linked with comment creation (POST), update (PUT), and deletion (DELETE) for participation and moderation flows. Only comments belonging to the target postId are returned, supporting thread-based exploration and analysis.\",\n        \"parameters\": [\n          {\n            \"name\": \"postId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"The unique identifier of the post whose comments are being queried.\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/bbsComments.IRequest\"\n              }\n            }\n          },\n          \"description\": \"Options for filtering, pagination, etc., when listing comments.\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPageBbsComments\"\n                }\n              }\n            },\n            \"description\": \"A paginated or filtered list of relevant comments.\"\n          }\n        }\n      },\n      \"post\": {\n        \"summary\": \"Create a new comment for a specific post (BBS: comments table).\",\n        \"description\": \"This API endpoint lets users (or, in special cases, moderators/administrators) add a new comment to a discussion post. The caller specifies the parent 'postId' and supplies the comment content. Optional threading is permitted by providing a parent comment ID for nested replies—enabling conversations to branch.\\n\\nThe 'comments' table links the new comment with both the author (via authentication) and the parent post (and optionally a parent comment), satisfying data integrity rules and supporting navigation through reply trees. Only authenticated users are allowed to create comments. The system enforces validation that content is non-empty and—if threading—a valid parent comment ID is supplied.\\n\\nUpon success, the new comment becomes searchable, viewable, and ready for follow-up replies or moderation actions. Related endpoints: list/search comments, update, delete.\",\n        \"parameters\": [\n          {\n            \"name\": \"postId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Identifier of the post to which the comment will be added.\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/bbsComments.ICreate\"\n              }\n            }\n          },\n          \"description\": \"Information for the new comment (content, parent comment if threading, etc.).\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"201\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/bbsComments\"\n                }\n              }\n            },\n            \"description\": \"Data of the newly created comment, including identifiers and metadata.\"\n          }\n        }\n      }\n    },\n    \"/bbs/posts/{postId}/comments/{id}\": {\n      \"get\": {\n        \"summary\": \"Get details for a specific comment (BBS: comments table).\",\n        \"description\": \"This API allows users to fetch all available information for one specific comment within the context of a post. The identifiers ('postId' for the parent thread, 'id' for the comment itself) ensure accuracy in comment threading and navigation. The operation returns comment content, author and timestamp details, metadata, and relations (such as parent reply or nested replies).\\n\\nThe endpoint supports use cases like displaying a reply in context, enabling further replies, or feeding comment moderation workflows. If a comment is not found or the identifiers do not match, the API returns a not-found error. Related endpoints include comment listing (PATCH), creation (POST), updating (PUT), and deletion (DELETE).\",\n        \"parameters\": [\n          {\n            \"name\": \"postId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"The unique post to which the comment belongs.\",\n            \"required\": true\n          },\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"The specific comment identifier to retrieve.\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/bbsComments\"\n                }\n              }\n            },\n            \"description\": \"Full comment details and metadata.\"\n          }\n        }\n      },\n      \"put\": {\n        \"summary\": \"Update an existing comment for a post (BBS: comments table).\",\n        \"description\": \"This API lets an authenticated user (comment author or, under special permissions, a moderator/administrator) update an existing comment identified by both parent postId and comment id. The system enforces that updates may only be made to comments the user owns, or by authorized moderation roles, with all validation constraints on content and threading.\\n\\nRequest must specify the target post and comment, supplying new content and/or thread associations. Invalid references or blank content produces errors, with history tracking updated timestamps. On success, the new comment details are returned.\\n\\nBusiness rules ensure audit trails and uphold moderation policies. Related endpoints include comment creation, deletion, and listing under post/group context.\",\n        \"parameters\": [\n          {\n            \"name\": \"postId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"The post to which the comment belongs.\",\n            \"required\": true\n          },\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"The unique identifier of the comment to update.\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/bbsComments.IUpdate\"\n              }\n            }\n          },\n          \"description\": \"Updated values for the comment (e.g., new content, parentId for re-threading).\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/bbsComments\"\n                }\n              }\n            },\n            \"description\": \"The updated comment record, reflecting all changes.\"\n          }\n        }\n      },\n      \"delete\": {\n        \"summary\": \"Delete a specific comment under a post (comments table, soft-delete logic).\",\n        \"description\": \"This operation deletes a comment associated with a particular post in the political/economic discussion board application. According to the Prisma schema for the 'comments' table, deleting a comment does not remove the record from the database, but marks it as deleted by updating the 'deleted_at' timestamp. This is in line with moderation and audit requirements described in both the requirement analysis and schema documentation.\\n\\nAuthorization is necessary, and only the comment's author, a moderator, or an administrator may perform this action. Permissions are determined by checking the user's role, which is represented in the 'users' and 'user_roles' tables. The endpoint ensures that the specified comment exists, is associated with the given post, and is not already deleted. Attempting to delete a non-existent or unrelated comment results in an error response showing the appropriate message.\\n\\nAdditionally, the operation maintains an audit trail by recording the timestamp of deletion, as outlined in the comments schema. The deleted comment remains for future moderation or review, and cannot be interacted with by regular members after deletion. Error responses must comply with API design for invalid IDs, unauthorized access, and logical violations (such as trying to delete an already deleted comment).\",\n        \"parameters\": [\n          {\n            \"name\": \"postId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Target post's ID (the parent of the comment).\",\n            \"required\": true\n          },\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Target comment's ID to be deleted.\",\n            \"required\": true\n          }\n        ]\n      }\n    },\n    \"/bbs/comments/{commentId}/comments\": {\n      \"patch\": {\n        \"summary\": \"List all direct replies to a specific comment (comments table, threaded replies).\",\n        \"description\": \"This operation retrieves a paginated and optionally filtered list of replies to a specific parent comment. The 'comments' table supports self-referential relationships for nested replies via the 'parent_id' field. Each retrieved comment must have 'parent_id' matching the provided 'commentId'.\\n\\nStandard search, filtering, and pagination options are supported via the request body. Only direct (not deeply nested) children are included. The operation checks if the parent comment exists and is not deleted. If access to the replies is restricted (e.g., if the parent comment is deleted or private), the API must enforce rules accordingly.\\n\\nThis operation is commonly used in threaded conversation UIs and supports constructing the hierarchy of replies for discussion depth and transparency.\",\n        \"parameters\": [\n          {\n            \"name\": \"commentId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Target parent comment's ID whose direct children are queried.\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IBbsCommentReply.IRequest\"\n              }\n            }\n          },\n          \"description\": \"Search and pagination options for replies to the comment.\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPageIBbsCommentReply\"\n                }\n              }\n            },\n            \"description\": \"Paginated list of replies to the specified comment.\"\n          }\n        }\n      },\n      \"post\": {\n        \"summary\": \"Create a new reply to a specific parent comment (comments table, nested reply).\",\n        \"description\": \"This operation allows registered users to create a new nested reply to an existing comment. The parent comment is specified by 'commentId'. Input data includes the reply content and optional metadata (e.g., authored by user, timestamp auto-handled). The association is created by setting the new comment's 'parent_id' to the specified 'commentId'.\\n\\nThe 'comments' table enforces this hierarchy and business rules such as only registered users may reply, and soft deletion logic applies. Error handling ensures the parent comment exists and is not deleted. Moderation or anti-spam business rules (e.g., rate limiting, sensitive word checks) are referenced from business context but not detailed in schema.\",\n        \"parameters\": [\n          {\n            \"name\": \"commentId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Parent comment's ID for threading context.\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IBbsCommentReply.ICreate\"\n              }\n            }\n          },\n          \"description\": \"Reply creation data (e.g., content, optional metadata).\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"201\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IBbsCommentReply\"\n                }\n              }\n            },\n            \"description\": \"Created reply comment, including ID and metadata.\"\n          }\n        }\n      }\n    },\n    \"/bbs/comments/{commentId}/comments/{id}\": {\n      \"get\": {\n        \"summary\": \"Get information for a specific reply to a comment (comments table, threaded comment).\",\n        \"description\": \"This operation fetches the details of a specific reply to a given parent comment, leveraging the 'comments' table's self-referential structure. It checks that the reply exists, has its 'parent_id' set to the specified 'commentId', and is not marked as deleted (soft delete logic).\\n\\nUseful for showing reply detail pages or in-line replies in the UI. Access control ensures that deleted replies or those hidden for moderation are not shown to ordinary users. The response includes all major comment fields (content, author, created time, votes, etc.), as well as any relevant metadata for thread navigation and moderation.\",\n        \"parameters\": [\n          {\n            \"name\": \"commentId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Parent comment's ID (pid for threaded reply context).\",\n            \"required\": true\n          },\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Reply comment's ID to retrieve.\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IBbsCommentReply\"\n                }\n              }\n            },\n            \"description\": \"Reply comment detail information.\"\n          }\n        }\n      },\n      \"put\": {\n        \"summary\": \"Update a reply to a specific comment (comments table, edit threaded reply).\",\n        \"description\": \"This operation updates a reply to a given parent comment in the 'comments' table. The system ensures that the target reply exists, is a direct reply to the specified 'commentId', and is not deleted. Only allowed roles (the author, moderators, administrators) may update the reply, subject to possible time window constraints (business logic).\\n\\nValid edits include changing the reply's text content and, where business rules allow, updating moderation status, or fixing accidental errors. The history is retained via an updated_at timestamp. Editing is restricted if a reply has been deleted (soft delete) or if the editing time window has expired. Response provides the updated reply details.\",\n        \"parameters\": [\n          {\n            \"name\": \"commentId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Parent comment's ID for context.\",\n            \"required\": true\n          },\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Reply comment's ID to update.\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IBbsCommentReply.IUpdate\"\n              }\n            }\n          },\n          \"description\": \"Fields to update in the reply (e.g., new content, metadata).\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IBbsCommentReply\"\n                }\n              }\n            },\n            \"description\": \"Updated reply comment information.\"\n          }\n        }\n      },\n      \"delete\": {\n        \"summary\": \"Delete a reply to a specific comment (comments table, soft-delete moderation logic).\",\n        \"description\": \"This operation deletes a reply (nested comment) from a parent comment, as defined in the self-referential structure of the 'comments' table. Instead of a hard delete, it sets the 'deleted_at' field, preserving the reply for moderation history and audit purposes.\\n\\nOnly the reply's author, moderators, or administrators are authorized to perform this action. Role mapping is enforced using data from 'users' and 'user_roles' tables. The operation checks that the reply exists and is a direct child of the specified parent comment.\\n\\nOn error (e.g., invalid parent-child relationship, reply already deleted, lack of permission), the system returns appropriate error codes/messages. This ensures clean handling of thread integrity and preserves conversation structure.\",\n        \"parameters\": [\n          {\n            \"name\": \"commentId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Parent comment's ID for context.\",\n            \"required\": true\n          },\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Reply comment's ID to delete.\",\n            \"required\": true\n          }\n        ]\n      }\n    },\n    \"/bbs/votes\": {\n      \"patch\": {\n        \"summary\": \"Query/search all votes across posts/comments (votes table, patch for advanced search).\",\n        \"description\": \"This operation returns a paginated and/or filtered list of votes. The 'votes' table supports querying by voter, content (post or comment), vote value, and timestamp. Filtering and pagination information are specified via the request body. This operation is intended for use by administrators, moderators, or analytics tools. Business rules enforce visibility (e.g., users see only their own votes unless they have elevated permissions).\\n\\nStandard pagination, search, and sorting are provided. Errors for invalid parameters or unauthorized access are handled according to platform requirements.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IBbsVote.IRequest\"\n              }\n            }\n          },\n          \"description\": \"Filters, pagination, and search fields for querying vote records.\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPageIBbsVote\"\n                }\n              }\n            },\n            \"description\": \"Paginated result of vote records matching query.\"\n          }\n        }\n      },\n      \"post\": {\n        \"summary\": \"Create a new vote for a post or comment (votes table, upvote/downvote logic).\",\n        \"description\": \"This operation creates a new vote record for the given user on the specified target (either a post or a comment) as per the 'votes' table structure. The request body must specify which target is being voted on, and the value (either +1 or -1 per business rule).\\n\\nBusiness logic includes unique user/target constraint (a user cannot vote twice on the same post or comment). On success, returns the created vote resource. If the vote already exists, the system returns an appropriate error or suggests updating the vote. Only authenticated users may vote. Permissions and audit trail are enforced as per requirements analysis and database comments.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IBbsVote.ICreate\"\n              }\n            }\n          },\n          \"description\": \"Vote creation input (target type, target ID, value).\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"201\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IBbsVote\"\n                }\n              }\n            },\n            \"description\": \"Created vote resource.\"\n          }\n        }\n      }\n    },\n    \"/bbs/votes/{id}\": {\n      \"get\": {\n        \"summary\": \"Get a single vote record's details (votes table, role/visibility protection).\",\n        \"description\": \"This operation retrieves a single vote by its ID. Information includes which user cast the vote (user_id), what it targeted (either a post or comment), the value (+1 or -1, as per schema), and relevant timestamps. The operation consults the 'votes' table directly by primary key.\\n\\nBusiness logic ensures that vote records are visible only to the voter themselves or users with elevated privileges. Sensitive data handling observes privacy, as votes reflect user opinions which may need to remain confidential, per the requirements analysis. Errors are returned for invalid IDs or unauthorized access.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Vote record's ID to be fetched.\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IBbsVote\"\n                }\n              }\n            },\n            \"description\": \"Vote detail resource record.\"\n          }\n        }\n      },\n      \"put\": {\n        \"summary\": \"Update an existing vote (votes table, upvote/downvote change).\",\n        \"description\": \"This operation updates an existing vote, which is identified by its unique ID. Only the owner (voter) of the vote or privileged roles (moderator/admin) may perform updates. Fields that can be changed include 'value' (e.g., switch an upvote to a downvote) and potentially metadata (e.g., audit fields). The business rules from the schema and requirements analysis govern what can be changed and by whom.\\n\\nChanges are reflected in the database and in derived content tallies. Errors are returned if update rules are violated (e.g., changing someone else's vote, updating a vote that doesn't exist, improper value assignment). On success, returns updated vote resource.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Vote record's ID to update.\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IBbsVote.IUpdate\"\n              }\n            }\n          },\n          \"description\": \"Updated vote fields (e.g., value).\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IBbsVote\"\n                }\n              }\n            },\n            \"description\": \"Updated vote resource.\"\n          }\n        }\n      },\n      \"delete\": {\n        \"summary\": \"Delete a vote (votes table, enforced by unique user/target constraint).\",\n        \"description\": \"This operation deletes a vote record from the database. Only the vote's owner (voter) or privileged roles (moderator/admin, based on 'user_roles') can perform this operation. It removes the vote, freeing up the user to vote again on the same post or comment in the future (as controlled by unique constraints in the votes schema).\\n\\nError responses are returned if the request is forbidden, the vote does not exist, or the operation is not permitted for the resource. The operation complies with audit and permission rules from requirements analysis and schema.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Vote record's ID to delete.\",\n            \"required\": true\n          }\n        ]\n      }\n    }\n  },\n  \"components\": {\n    \"schemas\": {\n      \"IBbsUsers.IRequest\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"page\": {\n            \"oneOf\": [\n              {\n                \"type\": \"integer\",\n                \"description\": \"Page number for paginated user listing.\\n\\nCorresponds to IPage.IRequest. Optional; if omitted, results default to the first page. Referenced in user administration and search flows.\"\n              },\n              {\n                \"type\": \"null\",\n                \"description\": \"Page number for paginated user listing.\\n\\nCorresponds to IPage.IRequest. Optional; if omitted, results default to the first page. Referenced in user administration and search flows.\"\n              }\n            ],\n            \"description\": \"Page number for paginated user listing.\\n\\nCorresponds to IPage.IRequest. Optional; if omitted, results default to the first page. Referenced in user administration and search flows.\"\n          },\n          \"limit\": {\n            \"oneOf\": [\n              {\n                \"type\": \"integer\",\n                \"description\": \"Limitation of records per page for user search.\\n\\nDefaults to 100. Allows tuning the result batch size for moderation or administrative user views.\"\n              },\n              {\n                \"type\": \"null\",\n                \"description\": \"Limitation of records per page for user search.\\n\\nDefaults to 100. Allows tuning the result batch size for moderation or administrative user views.\"\n              }\n            ],\n            \"description\": \"Limitation of records per page for user search.\\n\\nDefaults to 100. Allows tuning the result batch size for moderation or administrative user views.\"\n          },\n          \"role\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"description\": \"User role filter. Return only users with this role (matches user_roles.id or name).\\n\\nSupports moderator/admin filtering by user class (member, administrator, etc.).\"\n              },\n              {\n                \"type\": \"null\",\n                \"description\": \"User role filter. Return only users with this role (matches user_roles.id or name).\\n\\nSupports moderator/admin filtering by user class (member, administrator, etc.).\"\n              }\n            ],\n            \"description\": \"User role filter. Return only users with this role (matches user_roles.id or name).\\n\\nSupports moderator/admin filtering by user class (member, administrator, etc.).\"\n          },\n          \"status\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"description\": \"Filter users by account status (e.g., active, suspended, banned).\\n\\nSupports workflow for monitoring and moderation of access levels.\"\n              },\n              {\n                \"type\": \"null\",\n                \"description\": \"Filter users by account status (e.g., active, suspended, banned).\\n\\nSupports workflow for monitoring and moderation of access levels.\"\n              }\n            ],\n            \"description\": \"Filter users by account status (e.g., active, suspended, banned).\\n\\nSupports workflow for monitoring and moderation of access levels.\"\n          },\n          \"email\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"description\": \"Filter by exact or partial match on user email.\\n\\nAssists in locating specific accounts for administrative intervention or support.\"\n              },\n              {\n                \"type\": \"null\",\n                \"description\": \"Filter by exact or partial match on user email.\\n\\nAssists in locating specific accounts for administrative intervention or support.\"\n              }\n            ],\n            \"description\": \"Filter by exact or partial match on user email.\\n\\nAssists in locating specific accounts for administrative intervention or support.\"\n          },\n          \"username\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"description\": \"Filter by username (complete or partial match).\\n\\nUsed for public moderation, searching individual participants, or audit tasks.\"\n              },\n              {\n                \"type\": \"null\",\n                \"description\": \"Filter by username (complete or partial match).\\n\\nUsed for public moderation, searching individual participants, or audit tasks.\"\n              }\n            ],\n            \"description\": \"Filter by username (complete or partial match).\\n\\nUsed for public moderation, searching individual participants, or audit tasks.\"\n          },\n          \"registered_after\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"format\": \"date-time\",\n                \"description\": \"Filter for users registered after the given timestamp (ISO8601 format).\\n\\nUsed to find recent registrations or perform time-based audits.\"\n              },\n              {\n                \"type\": \"null\",\n                \"format\": \"date-time\",\n                \"description\": \"Filter for users registered after the given timestamp (ISO8601 format).\\n\\nUsed to find recent registrations or perform time-based audits.\"\n              }\n            ],\n            \"description\": \"Filter for users registered after the given timestamp (ISO8601 format).\\n\\nUsed to find recent registrations or perform time-based audits.\"\n          },\n          \"registered_before\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"format\": \"date-time\",\n                \"description\": \"Filter for users registered before the given timestamp (ISO8601 format).\\n\\nUsed to look up users registered before a certain date.\"\n              },\n              {\n                \"type\": \"null\",\n                \"format\": \"date-time\",\n                \"description\": \"Filter for users registered before the given timestamp (ISO8601 format).\\n\\nUsed to look up users registered before a certain date.\"\n              }\n            ],\n            \"description\": \"Filter for users registered before the given timestamp (ISO8601 format).\\n\\nUsed to look up users registered before a certain date.\"\n          },\n          \"sort_by\": {\n            \"oneOf\": [\n              {\n                \"const\": \"username\",\n                \"description\": \"Sort order (username, email, created_at).\\n\\nFor user management screens, allows control of user list ordering.\"\n              },\n              {\n                \"const\": \"email\",\n                \"description\": \"Sort order (username, email, created_at).\\n\\nFor user management screens, allows control of user list ordering.\"\n              },\n              {\n                \"const\": \"created_at\",\n                \"description\": \"Sort order (username, email, created_at).\\n\\nFor user management screens, allows control of user list ordering.\"\n              },\n              {\n                \"type\": \"null\",\n                \"enum\": [\n                  \"username\",\n                  \"email\",\n                  \"created_at\"\n                ],\n                \"description\": \"Sort order (username, email, created_at).\\n\\nFor user management screens, allows control of user list ordering.\"\n              }\n            ],\n            \"description\": \"Sort order (username, email, created_at).\\n\\nFor user management screens, allows control of user list ordering.\"\n          },\n          \"sort_order\": {\n            \"oneOf\": [\n              {\n                \"const\": \"asc\",\n                \"description\": \"Sorting direction for user list.\\n\\n'asc' for ascending, 'desc' for descending.\"\n              },\n              {\n                \"const\": \"desc\",\n                \"description\": \"Sorting direction for user list.\\n\\n'asc' for ascending, 'desc' for descending.\"\n              },\n              {\n                \"type\": \"null\",\n                \"enum\": [\n                  \"asc\",\n                  \"desc\"\n                ],\n                \"description\": \"Sorting direction for user list.\\n\\n'asc' for ascending, 'desc' for descending.\"\n              }\n            ],\n            \"description\": \"Sorting direction for user list.\\n\\n'asc' for ascending, 'desc' for descending.\"\n          }\n        },\n        \"description\": \"User search/list/filter request.\\n\\nUsed in user administration and browsing interfaces to retrieve filtered, paginated user lists as described in requirements analysis (moderators/administrators). Properties correspond to search and filter dimensions for the users Prisma table.\",\n        \"required\": []\n      },\n      \"IPageIBbsUsers\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"pagination\": {\n            \"$ref\": \"#/components/schemas/IPage.IPagination\"\n          },\n          \"data\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IBbsUsers\"\n            },\n            \"description\": \"Array of user objects on this page of results.\\n\\nEach entry is a non-sensitive user representation for administration or moderation.\"\n          }\n        },\n        \"required\": [\n          \"pagination\",\n          \"data\"\n        ],\n        \"description\": \"Paginated user list container.\\n\\nStandard paginated interface (see IPage), adapted for listing users, corresponding to search, moderation, or audit interface needs.\"\n      },\n      \"IBbsUsers\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"Unique identifier for this user (UUID).\\n\\nPrimary key in users table. Referenced for moderation, profile editing, and all user-based operations.\"\n          },\n          \"user_role_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"User's assigned role (UUID, references user_roles.id).\\n\\nProvides permissions and grants system; links user to allowable actions.\"\n          },\n          \"username\": {\n            \"type\": \"string\",\n            \"description\": \"Unique public handle for the user, visible on posts and comments.\\n\\nAs outlined in requirements analysis, serves as user identity for platform interaction.\"\n          },\n          \"email\": {\n            \"type\": \"string\",\n            \"description\": \"User's registered email address.\\n\\nUsed for notifications, authentication, and support. Not public by default.\"\n          },\n          \"bio\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"description\": \"Short biographical text the user may choose to display.\\n\\nUser-supplied for platform personalization; optional.\"\n              },\n              {\n                \"type\": \"null\",\n                \"description\": \"Short biographical text the user may choose to display.\\n\\nUser-supplied for platform personalization; optional.\"\n              }\n            ],\n            \"description\": \"Short biographical text the user may choose to display.\\n\\nUser-supplied for platform personalization; optional.\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"description\": \"Registration timestamp (ISO8601).\\n\\nWhen this user joined the platform. Used for audits, sorting, compliance.\"\n          },\n          \"updated_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"description\": \"Timestamp of last profile/account update (ISO8601).\\n\\nTracks account edit history/maintenance.\"\n          },\n          \"status\": {\n            \"type\": \"string\",\n            \"description\": \"Current account state (e.g., active, suspended, banned).\\n\\nEssential for enforcing moderation/business logic as described in requirements.\"\n          },\n          \"role\": {\n            \"$ref\": \"#/components/schemas/IBbsUserRoles\",\n            \"description\": \"Full role record for this user (joined on user_role_id).\\n\\nProvides name and description for UI display and permissions checks.\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"user_role_id\",\n          \"username\",\n          \"email\",\n          \"created_at\",\n          \"updated_at\",\n          \"status\",\n          \"role\"\n        ],\n        \"description\": \"User profile record (non-sensitive).\\n\\nImplements all fields in users Prisma model except password_hash. Used in administration, moderation, onboarding, audit, and display. Documentation references requirements document and Prisma schema comment.\"\n      },\n      \"IBbsUsers.ICreate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"username\": {\n            \"type\": \"string\",\n            \"description\": \"Desired username (must be unique).\\n\\nMandatory for registration and public identity, per requirements analysis.\"\n          },\n          \"email\": {\n            \"type\": \"string\",\n            \"description\": \"Email address to register (unique, notified on events).\\n\\nUsed for login and notifications.\"\n          },\n          \"password\": {\n            \"type\": \"string\",\n            \"description\": \"Initial user password (supplied in plain form, will be hashed on storage).\\n\\nNever returned in API. Enforced by strong password policies.\"\n          },\n          \"bio\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"description\": \"Optional biographical text.\\n\\nUser profile customization, as outlined in requirements.\"\n              },\n              {\n                \"type\": \"null\",\n                \"description\": \"Optional biographical text.\\n\\nUser profile customization, as outlined in requirements.\"\n              }\n            ],\n            \"description\": \"Optional biographical text.\\n\\nUser profile customization, as outlined in requirements.\"\n          },\n          \"role_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"Role assignment (UUID from user_roles.id).\\n\\nSpecifies initial user permissions (e.g., member, moderator, administrator).\\nDetermines access scope for new account creation.\"\n          }\n        },\n        \"required\": [\n          \"username\",\n          \"email\",\n          \"password\",\n          \"role_id\"\n        ],\n        \"description\": \"Registration payload for new users.\\n\\nImplements onboarding/registration parameters as described in requirements and reflected in Prisma users table. Only non-sensitive initial account data permitted.\"\n      },\n      \"IBbsUsers.IUpdate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"username\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"description\": \"New username, if changing. Must remain unique.\\n\\nMay only be updated by the user or privileged roles.\"\n              },\n              {\n                \"type\": \"null\",\n                \"description\": \"New username, if changing. Must remain unique.\\n\\nMay only be updated by the user or privileged roles.\"\n              }\n            ],\n            \"description\": \"New username, if changing. Must remain unique.\\n\\nMay only be updated by the user or privileged roles.\"\n          },\n          \"email\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"description\": \"Email address for changing login/notifications. Must remain unique.\\n\\nAdmin or user-only operation.\"\n              },\n              {\n                \"type\": \"null\",\n                \"description\": \"Email address for changing login/notifications. Must remain unique.\\n\\nAdmin or user-only operation.\"\n              }\n            ],\n            \"description\": \"Email address for changing login/notifications. Must remain unique.\\n\\nAdmin or user-only operation.\"\n          },\n          \"bio\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"description\": \"Updated bio (profile description).\\n\\nUsed for user self-edit or admin-moderator workflow.\"\n              },\n              {\n                \"type\": \"null\",\n                \"description\": \"Updated bio (profile description).\\n\\nUsed for user self-edit or admin-moderator workflow.\"\n              }\n            ],\n            \"description\": \"Updated bio (profile description).\\n\\nUsed for user self-edit or admin-moderator workflow.\"\n          },\n          \"status\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"description\": \"Status value (active, suspended, banned, etc).\\n\\nMay be set by authorized roles per moderation/business rules.\"\n              },\n              {\n                \"type\": \"null\",\n                \"description\": \"Status value (active, suspended, banned, etc).\\n\\nMay be set by authorized roles per moderation/business rules.\"\n              }\n            ],\n            \"description\": \"Status value (active, suspended, banned, etc).\\n\\nMay be set by authorized roles per moderation/business rules.\"\n          },\n          \"role_id\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"format\": \"uuid\",\n                \"description\": \"New role assignment for the user (user_roles.id).\\n\\nFor admin-only role changes (e.g., promotion to moderator/administrator).\"\n              },\n              {\n                \"type\": \"null\",\n                \"format\": \"uuid\",\n                \"description\": \"New role assignment for the user (user_roles.id).\\n\\nFor admin-only role changes (e.g., promotion to moderator/administrator).\"\n              }\n            ],\n            \"description\": \"New role assignment for the user (user_roles.id).\\n\\nFor admin-only role changes (e.g., promotion to moderator/administrator).\"\n          }\n        },\n        \"description\": \"Update payload for user profile/account.\\n\\nImplements the user and administrative self-update, moderation, and profile-edit flows described in requirements analysis and Prisma schema. All fields optional for PATCH/PUT semantics.\",\n        \"required\": []\n      },\n      \"IBbsUserRoles.IRequest\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"page\": {\n            \"oneOf\": [\n              {\n                \"type\": \"integer\",\n                \"description\": \"Requested page of role results.\\n\\nAdheres to pagination standard (see IPage.IRequest).\"\n              },\n              {\n                \"type\": \"null\",\n                \"description\": \"Requested page of role results.\\n\\nAdheres to pagination standard (see IPage.IRequest).\"\n              }\n            ],\n            \"description\": \"Requested page of role results.\\n\\nAdheres to pagination standard (see IPage.IRequest).\"\n          },\n          \"limit\": {\n            \"oneOf\": [\n              {\n                \"type\": \"integer\",\n                \"description\": \"Maximum number of roles per page.\\n\\nDefault is 100; supports admin audit or onboarding configuration.\"\n              },\n              {\n                \"type\": \"null\",\n                \"description\": \"Maximum number of roles per page.\\n\\nDefault is 100; supports admin audit or onboarding configuration.\"\n              }\n            ],\n            \"description\": \"Maximum number of roles per page.\\n\\nDefault is 100; supports admin audit or onboarding configuration.\"\n          },\n          \"name\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"description\": \"Role name filter (exact or pattern match).\\n\\nFor filtering available roles by label in role management interface.\"\n              },\n              {\n                \"type\": \"null\",\n                \"description\": \"Role name filter (exact or pattern match).\\n\\nFor filtering available roles by label in role management interface.\"\n              }\n            ],\n            \"description\": \"Role name filter (exact or pattern match).\\n\\nFor filtering available roles by label in role management interface.\"\n          },\n          \"description\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"description\": \"Keyword match on the role description.\\n\\nHelps administrators or business workflows find newly created roles or audit permissions.\"\n              },\n              {\n                \"type\": \"null\",\n                \"description\": \"Keyword match on the role description.\\n\\nHelps administrators or business workflows find newly created roles or audit permissions.\"\n              }\n            ],\n            \"description\": \"Keyword match on the role description.\\n\\nHelps administrators or business workflows find newly created roles or audit permissions.\"\n          }\n        },\n        \"description\": \"Filter/search payload for user_roles listing.\\n\\nEnables administrative workflows for governance, onboarding, and audit per requirements analysis.\",\n        \"required\": []\n      },\n      \"IPageIBbsUserRoles\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"pagination\": {\n            \"$ref\": \"#/components/schemas/IPage.IPagination\"\n          },\n          \"data\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IBbsUserRoles\"\n            },\n            \"description\": \"List of user role objects for this result page.\"\n          }\n        },\n        \"required\": [\n          \"pagination\",\n          \"data\"\n        ],\n        \"description\": \"Paginated user role results container.\\n\\nStandard pagination (see IPage), extended for user role record listing, used in administrative and onboarding contexts.\"\n      },\n      \"IBbsUserRoles\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"Unique identifier for user role (UUID).\\n\\nPrimary key from user_roles.\"\n          },\n          \"name\": {\n            \"type\": \"string\",\n            \"description\": \"Unique label for the user role (e.g., member, moderator, administrator).\\n\\nFulfills role business logic and governance, per requirements.\"\n          },\n          \"description\": {\n            \"type\": \"string\",\n            \"description\": \"Detailed explanation of the role's permissions, scope, or duties.\\n\\nShown in onboarding and administration to explain role scope.\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"name\",\n          \"description\"\n        ],\n        \"description\": \"User role metadata record.\\n\\nImplements the business logic of platform roles as described in requirements and user_roles table.\"\n      },\n      \"IBbsUserRoles.ICreate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"name\": {\n            \"type\": \"string\",\n            \"description\": \"Role label (unique, required).\\n\\nRequired for creating new permissions classes in system governance.\"\n          },\n          \"description\": {\n            \"type\": \"string\",\n            \"description\": \"Human-readable explanation of the role's authority and purpose.\\n\\nFor oversight and onboarding display.\"\n          }\n        },\n        \"required\": [\n          \"name\",\n          \"description\"\n        ],\n        \"description\": \"Payload to create a new user role.\\n\\nUsed for onboarding/registration configuration and extending moderation/business model, as per requirements and schema.\"\n      },\n      \"IBbsUserRoles.IUpdate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"name\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"description\": \"New name/label for user role, if changing.\\n\\nMust remain unique if provided.\"\n              },\n              {\n                \"type\": \"null\",\n                \"description\": \"New name/label for user role, if changing.\\n\\nMust remain unique if provided.\"\n              }\n            ],\n            \"description\": \"New name/label for user role, if changing.\\n\\nMust remain unique if provided.\"\n          },\n          \"description\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"description\": \"Updated explanation for the role (e.g., changing duties, scope).\\n\\nAdministrative update only.\"\n              },\n              {\n                \"type\": \"null\",\n                \"description\": \"Updated explanation for the role (e.g., changing duties, scope).\\n\\nAdministrative update only.\"\n              }\n            ],\n            \"description\": \"Updated explanation for the role (e.g., changing duties, scope).\\n\\nAdministrative update only.\"\n          }\n        },\n        \"description\": \"Payload to update an existing role.\\n\\nAll fields optional for PUT/PATCH behaviors, as per requirements analysis and schema comments.\",\n        \"required\": []\n      },\n      \"IBbsCategories.IRequest\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"page\": {\n            \"oneOf\": [\n              {\n                \"type\": \"integer\",\n                \"description\": \"Requested page number for category result listing.\\n\\nSupports pagination consistent with IPage.IRequest standard.\"\n              },\n              {\n                \"type\": \"null\",\n                \"description\": \"Requested page number for category result listing.\\n\\nSupports pagination consistent with IPage.IRequest standard.\"\n              }\n            ],\n            \"description\": \"Requested page number for category result listing.\\n\\nSupports pagination consistent with IPage.IRequest standard.\"\n          },\n          \"limit\": {\n            \"oneOf\": [\n              {\n                \"type\": \"integer\",\n                \"description\": \"Maximum categories to return per page (default 100).\\n\\nUsed to manage category lists in creation, onboarding, or admin flows.\"\n              },\n              {\n                \"type\": \"null\",\n                \"description\": \"Maximum categories to return per page (default 100).\\n\\nUsed to manage category lists in creation, onboarding, or admin flows.\"\n              }\n            ],\n            \"description\": \"Maximum categories to return per page (default 100).\\n\\nUsed to manage category lists in creation, onboarding, or admin flows.\"\n          },\n          \"name\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"description\": \"Filter/search by category name (pattern or exact match).\\n\\nSupports navigation and management per requirements logic.\"\n              },\n              {\n                \"type\": \"null\",\n                \"description\": \"Filter/search by category name (pattern or exact match).\\n\\nSupports navigation and management per requirements logic.\"\n              }\n            ],\n            \"description\": \"Filter/search by category name (pattern or exact match).\\n\\nSupports navigation and management per requirements logic.\"\n          },\n          \"description\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"description\": \"Filter/search by category description content.\\n\\nAllows admin management and onboarding support for new users.\"\n              },\n              {\n                \"type\": \"null\",\n                \"description\": \"Filter/search by category description content.\\n\\nAllows admin management and onboarding support for new users.\"\n              }\n            ],\n            \"description\": \"Filter/search by category description content.\\n\\nAllows admin management and onboarding support for new users.\"\n          }\n        },\n        \"description\": \"Category list/search request payload.\\n\\nImplements category exploration, onboarding, navigation, and administrative audit flows from requirements analysis.\",\n        \"required\": []\n      },\n      \"IPageIBbsCategories\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"pagination\": {\n            \"$ref\": \"#/components/schemas/IPage.IPagination\"\n          },\n          \"data\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IBbsCategories\"\n            },\n            \"description\": \"Array of category metadata objects on this page.\"\n          }\n        },\n        \"required\": [\n          \"pagination\",\n          \"data\"\n        ],\n        \"description\": \"Paginated category listing container.\\n\\nStandard interface for listing available topic categories for post assignment, UI navigation, or admin workflows.\"\n      },\n      \"IBbsCategories\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"Unique identifier for the category, corresponding to the `id` primary key in the categories Prisma model.\\n\\nThis ID is system-generated and is used throughout API requests when referencing categories. Fulfills the 'Category' entity requirements from the business and data structure specifications.\"\n          },\n          \"name\": {\n            \"type\": \"string\",\n            \"description\": \"The human-readable name of the category, corresponding to the `name` column in the categories table.\\n\\nThis value must be unique. It is used in navigation, filtering posts, and display for end users. As per the requirements, examples might be 'Politics', 'Economics', or 'International Affairs'.\"\n          },\n          \"description\": {\n            \"type\": \"string\",\n            \"description\": \"A description of the category, corresponding to the `description` column in the database.\\n\\nThis field clarifies the scope and focus of the discussion for posts under this category, e.g., 'Discussion about domestic and international political systems, governance, and related events.'\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"description\": \"The timestamp when the category was created, matching `created_at` in the categories schema.\\n\\nUsed for audit trails, admin reporting, and chronological display of categories.\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"name\",\n          \"description\",\n          \"created_at\"\n        ],\n        \"description\": \"Represents discussion board categories, such as Politics or Economics.\\n\\nReflects the categories entity from the business requirements and the `categories` table in the Prisma schema. Contains a unique ID, name, description, and creation timestamp. Categories organize posts and are managed by administrators.\"\n      },\n      \"IPage.IPagination\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"current\": {\n            \"type\": \"integer\",\n            \"format\": \"uint32\",\n            \"description\": \"Current page number.\"\n          },\n          \"limit\": {\n            \"type\": \"integer\",\n            \"format\": \"uint32\",\n            \"description\": \"Number of records per page. Default is 100.\"\n          },\n          \"records\": {\n            \"type\": \"integer\",\n            \"format\": \"uint32\",\n            \"description\": \"Total number of records in the result set.\"\n          },\n          \"pages\": {\n            \"type\": \"integer\",\n            \"format\": \"uint32\",\n            \"description\": \"Total pages. Equal to records/limit with ceiling.\"\n          }\n        },\n        \"required\": [\n          \"current\",\n          \"limit\",\n          \"records\",\n          \"pages\"\n        ],\n        \"description\": \"Pagination information for paginated results. Used in all IPage<T> structures; see standard type definition.\"\n      },\n      \"bbsCategories.ICreate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"name\": {\n            \"type\": \"string\",\n            \"description\": \"The unique name for the new category, as per the `name` field in the categories table.\\n\\nMust be non-empty and unique among all categories. Used for users to navigate posts and choose topics.\"\n          },\n          \"description\": {\n            \"type\": \"string\",\n            \"description\": \"Description for the new category, giving users information about the scope and focus. Taken from the `description` field in the categories schema.\\n\\nMust be non-empty. This is shown to users when posting or browsing.\"\n          }\n        },\n        \"required\": [\n          \"name\",\n          \"description\"\n        ],\n        \"description\": \"Payload for creating a new category.\\n\\nUsed by administrators via the create category API to add organizational topics, matching the 'categories' table structure.\"\n      },\n      \"bbsCategories\": {\n        \"$ref\": \"#/components/schemas/IBbsCategories\",\n        \"description\": \"Alias to IBbsCategories. Used for legacy/type consistency in endpoints referring to category entities. Ensures consistent documentation and code use.\"\n      },\n      \"bbsCategories.IUpdate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"name\": {\n            \"type\": \"string\",\n            \"description\": \"The new or updated name for this category, as per the `name` column in the categories table.\\n\\nMust remain unique and non-empty.\"\n          },\n          \"description\": {\n            \"type\": \"string\",\n            \"description\": \"Updated description for the category, as per the `description` column in the schema.\\n\\nMust also be non-empty.\"\n          }\n        },\n        \"required\": [\n          \"name\",\n          \"description\"\n        ],\n        \"description\": \"Payload for updating an existing category.\\n\\nSent by administrators to modify category name or description. Matches structure and constraints of the `categories` table.\"\n      },\n      \"bbsPosts.IRequest\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"query\": {\n            \"type\": \"string\",\n            \"description\": \"A search string to filter posts by keyword in the title or content.\\n\\nHelps users find posts matching specific topics. May use advanced search or simple substring matching.\"\n          },\n          \"category_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"Filters posts to those belonging to this category, referencing `category_id` in the posts table.\\n\\nEnables category-based navigation or analysis.\"\n          },\n          \"sort_by\": {\n            \"oneOf\": [\n              {\n                \"const\": \"created_at\",\n                \"description\": \"The field to sort posts by when listing results.\\n\\nTypically one of: 'created_at' (date posted), 'updated_at', 'title', or 'votes' (tally of upvotes/downvotes).\"\n              },\n              {\n                \"const\": \"updated_at\",\n                \"description\": \"The field to sort posts by when listing results.\\n\\nTypically one of: 'created_at' (date posted), 'updated_at', 'title', or 'votes' (tally of upvotes/downvotes).\"\n              },\n              {\n                \"const\": \"title\",\n                \"description\": \"The field to sort posts by when listing results.\\n\\nTypically one of: 'created_at' (date posted), 'updated_at', 'title', or 'votes' (tally of upvotes/downvotes).\"\n              },\n              {\n                \"const\": \"votes\",\n                \"description\": \"The field to sort posts by when listing results.\\n\\nTypically one of: 'created_at' (date posted), 'updated_at', 'title', or 'votes' (tally of upvotes/downvotes).\"\n              }\n            ],\n            \"description\": \"The field to sort posts by when listing results.\\n\\nTypically one of: 'created_at' (date posted), 'updated_at', 'title', or 'votes' (tally of upvotes/downvotes).\"\n          },\n          \"order\": {\n            \"oneOf\": [\n              {\n                \"const\": \"asc\",\n                \"description\": \"Specifies the order (ascending or descending) of the sort. Example: 'desc' for newest first, 'asc' for alphabetical.\"\n              },\n              {\n                \"const\": \"desc\",\n                \"description\": \"Specifies the order (ascending or descending) of the sort. Example: 'desc' for newest first, 'asc' for alphabetical.\"\n              }\n            ],\n            \"description\": \"Specifies the order (ascending or descending) of the sort. Example: 'desc' for newest first, 'asc' for alphabetical.\"\n          },\n          \"page\": {\n            \"type\": \"integer\",\n            \"format\": \"int32\",\n            \"description\": \"The page number to request (for pagination).\\n\\nDefaults to 1 if omitted.\"\n          },\n          \"limit\": {\n            \"type\": \"integer\",\n            \"format\": \"int32\",\n            \"description\": \"Maximum number of posts to return per page (pagination limit).\\n\\nTypical values are 10, 20, or 50 per page. Defaults may apply if omitted.\"\n          }\n        },\n        \"required\": [],\n        \"description\": \"Request parameters for listing or searching posts in the discussion board.\\n\\nImplements filtering, sorting, and pagination features for the `posts` entity. Matches 'bbsPosts.IRequest' business requirements and supports advanced exploration of post listings.\"\n      },\n      \"IPageBbsPosts\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"pagination\": {\n            \"$ref\": \"#/components/schemas/IPage.IPagination\"\n          },\n          \"data\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/bbsPosts\"\n            },\n            \"description\": \"List of post records for this page, matching the query/filter.\"\n          }\n        },\n        \"required\": [\n          \"pagination\",\n          \"data\"\n        ],\n        \"description\": \"Paginated result wrapper for posts listing operations.\\n\\nHolds an array of post records and pagination metadata, following IPage<T> business conventions.\"\n      },\n      \"bbsPosts\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"Unique identifier of the post. The `id` field in the posts model.\\n\\nUsed for referencing the post in API calls or links.\"\n          },\n          \"user_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"UUID of the user (author) who created this post, corresponding to `user_id` in the posts table.\\n\\nProvides author traceability and links to user profiles.\"\n          },\n          \"category_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"UUID of the category under which the post was published, referencing `category_id` in the posts table.\\n\\nSupports topic-based navigation and organization.\"\n          },\n          \"title\": {\n            \"type\": \"string\",\n            \"description\": \"The post's headline/title. Implements the required `title` property in the posts schema.\\n\\nProminently displayed in thread lists and views.\"\n          },\n          \"content\": {\n            \"type\": \"string\",\n            \"description\": \"Main content/body of the post, from the `content` field in the posts table.\\n\\nIncludes long-form text, opinion, or analysis. Critical for community discussion.\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"description\": \"The timestamp when the post was created, matching `created_at` in the database.\\n\\nDisplayed in lists, used for freshness ordering, and necessary for audits.\"\n          },\n          \"updated_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"description\": \"Last modification timestamp, from `updated_at` in the posts record.\\n\\nEnables edit history tracking and evidence of moderation or typo corrections.\"\n          },\n          \"deleted_at\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"format\": \"date-time\",\n                \"description\": \"If present, this timestamp indicates when the post was soft-deleted (not physically removed), in line with moderation and audit business rules.\\n\\nNull if the post is currently visible.\"\n              },\n              {\n                \"type\": \"null\"\n              }\n            ],\n            \"description\": \"If present, this timestamp indicates when the post was soft-deleted (not physically removed), in line with moderation and audit business rules.\\n\\nNull if the post is currently visible.\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"user_id\",\n          \"category_id\",\n          \"title\",\n          \"content\",\n          \"created_at\",\n          \"updated_at\"\n        ],\n        \"description\": \"Represents a discussion post (thread) on the platform, matching the posts entity from the requirements analysis and the posts table in the Prisma schema.\\n\\nProvides all information about the post, including subject/title, content, author ID, category, timestamps, and deletion flag for moderation.\"\n      },\n      \"bbsPosts.ICreate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"category_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"UUID for the category where the post is to be published. Implements the business logic in the posts model requiring category assignment.\\n\\nMust refer to an existing category.\"\n          },\n          \"title\": {\n            \"type\": \"string\",\n            \"description\": \"Headline/title for the post. Required field representing the core subject or summary for the thread.\\n\\nMust be non-empty, per business and schema rules.\"\n          },\n          \"content\": {\n            \"type\": \"string\",\n            \"description\": \"Main content/body of the post. Required for meaningful discussion.\\n\\nMust be non-empty, and may include text, links, or analysis.\"\n          }\n        },\n        \"required\": [\n          \"category_id\",\n          \"title\",\n          \"content\"\n        ],\n        \"description\": \"Payload for creating a new post in the discussion board.\\n\\nLinks the new post to a specific category, supplies a title and content. Used by regular users during post creation workflows.\"\n      },\n      \"bbsPosts.IUpdate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"category_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"New or updated UUID for the category the post is assigned to.\\n\\nChanges the post's topical placement. Must reference an existing category.\"\n          },\n          \"title\": {\n            \"type\": \"string\",\n            \"description\": \"New or updated headline/title for the post. Subject to uniqueness or non-emptiness per business and schema rules.\"\n          },\n          \"content\": {\n            \"type\": \"string\",\n            \"description\": \"Updated body/content of the post. Required for substantial updates. Subject to moderation and editability constraints.\"\n          }\n        },\n        \"required\": [\n          \"category_id\",\n          \"title\",\n          \"content\"\n        ],\n        \"description\": \"Payload for updating a post. Sent by the author, moderator, or admin to edit post category, headline, or content.\\n\\nAll fields are required; aligns with edit operation semantics in business requirements.\"\n      },\n      \"bbsComments.IRequest\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"author_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"Optional filter to list only comments written by the specified user, matching `user_id` in comments table.\\n\\nSupports audit and user-based navigation.\"\n          },\n          \"created_after\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"description\": \"Optional start date/time for filtering comments.\\n\\nUsed for moderating recent activity, historical review, or analytics.\"\n          },\n          \"created_before\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"description\": \"Optional end date/time for filtering comments.\"\n          },\n          \"sort_by\": {\n            \"oneOf\": [\n              {\n                \"const\": \"created_at\",\n                \"description\": \"Defines the sorting field for the comment list. Typical values are 'created_at' or 'updated_at'.\"\n              },\n              {\n                \"const\": \"updated_at\",\n                \"description\": \"Defines the sorting field for the comment list. Typical values are 'created_at' or 'updated_at'.\"\n              }\n            ],\n            \"description\": \"Defines the sorting field for the comment list. Typical values are 'created_at' or 'updated_at'.\"\n          },\n          \"order\": {\n            \"oneOf\": [\n              {\n                \"const\": \"asc\",\n                \"description\": \"Direction of sorting order applied. 'desc' for most recent first, 'asc' for chronological.\"\n              },\n              {\n                \"const\": \"desc\",\n                \"description\": \"Direction of sorting order applied. 'desc' for most recent first, 'asc' for chronological.\"\n              }\n            ],\n            \"description\": \"Direction of sorting order applied. 'desc' for most recent first, 'asc' for chronological.\"\n          },\n          \"page\": {\n            \"type\": \"integer\",\n            \"format\": \"int32\",\n            \"description\": \"Result page number for pagination. Defaults to 1 if omitted.\"\n          },\n          \"limit\": {\n            \"type\": \"integer\",\n            \"format\": \"int32\",\n            \"description\": \"Maximum number of comments per page, supporting pagination for large threads.\"\n          }\n        },\n        \"required\": [],\n        \"description\": \"Request parameters for listing/searching comments under a post.\\n\\nSupports author filtering, time range selection, sorting, and pagination—matching audit and moderation needs for nested comment threads.\"\n      },\n      \"IPageBbsComments\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"pagination\": {\n            \"$ref\": \"#/components/schemas/IPage.IPagination\"\n          },\n          \"data\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/bbsComments\"\n            },\n            \"description\": \"Array of comments for the result page.\"\n          }\n        },\n        \"required\": [\n          \"pagination\",\n          \"data\"\n        ],\n        \"description\": \"Paginated response wrapper for comments list/search APIs.\\n\\nHolds the page of comment records and pagination info, conforming to platform standards for large thread handling.\"\n      },\n      \"bbsComments\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"Unique identifier for the comment, `id` primary key from the comments table.\\n\\nUsed system-wide to reference comments in API operations and thread navigation.\"\n          },\n          \"user_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"UUID of the user who wrote this comment, matching `user_id` in comments table.\\n\\nUsed for author audits, reply tracking, and profile linking.\"\n          },\n          \"post_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"UUID of the post this comment is attached to, from `post_id` in the comments table.\\n\\nCritical for threading, structure, and navigation of discussion posts.\"\n          },\n          \"parent_id\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"format\": \"uuid\",\n                \"description\": \"If present, this is the UUID of the parent comment, enabling threading/nesting of replies. Nullable for top-level comments.\\n\\nImplements self-referential comment hierarchy as explained in requirements and Prisma schema.\"\n              },\n              {\n                \"type\": \"null\"\n              }\n            ],\n            \"description\": \"If present, this is the UUID of the parent comment, enabling threading/nesting of replies. Nullable for top-level comments.\\n\\nImplements self-referential comment hierarchy as explained in requirements and Prisma schema.\"\n          },\n          \"content\": {\n            \"type\": \"string\",\n            \"description\": \"Body/content of the comment, from the `content` field in comments table.\\n\\nCarries user opinion, replies, and substantive discussion.\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"description\": \"Timestamp for comment creation, from `created_at` column.\\n\\nUsed in chronological sorting, audit, and moderation.\"\n          },\n          \"updated_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"description\": \"Timestamp for last update of the comment, as per `updated_at` field.\\n\\nReflects edit history and moderation actions.\"\n          },\n          \"deleted_at\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"format\": \"date-time\",\n                \"description\": \"Soft deletion flag (if present) indicating when this comment was 'deleted' for moderation, but not physically removed from the database.\\n\\nNull if currently active.\"\n              },\n              {\n                \"type\": \"null\"\n              }\n            ],\n            \"description\": \"Soft deletion flag (if present) indicating when this comment was 'deleted' for moderation, but not physically removed from the database.\\n\\nNull if currently active.\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"user_id\",\n          \"post_id\",\n          \"content\",\n          \"created_at\",\n          \"updated_at\"\n        ],\n        \"description\": \"Represents a comment entity in the discussion board. Used for both top-level and nested/threaded replies.\\n\\nFully aligns with the comments entity as specified in the requirements and comments table in the Prisma schema, including parent-child threading, audit, and moderation soft-delete support.\"\n      },\n      \"bbsComments.ICreate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"content\": {\n            \"type\": \"string\",\n            \"description\": \"Comment body text.\\n\\nThis property contains the text that will be displayed as the content of the comment. It implements the rule that each comment consists of user-written content. For example: 'I agree and here’s why...'. Referenced from the 'content' column in the Prisma comments model and per requirements in 03_data_structure_and_business_rules.md.\"\n          },\n          \"parent_id\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"format\": \"uuid\",\n                \"description\": \"The ID of the parent comment for nested/threaded replies. Nullable for top-level comments (direct replies to posts).\\n\\nReferenced from 'parent_id' in the comments Prisma schema. Implements thread/nesting support and conversation branching per requirements.\"\n              },\n              {\n                \"type\": \"null\",\n                \"format\": \"uuid\",\n                \"description\": \"The ID of the parent comment for nested/threaded replies. Nullable for top-level comments (direct replies to posts).\\n\\nReferenced from 'parent_id' in the comments Prisma schema. Implements thread/nesting support and conversation branching per requirements.\"\n              }\n            ],\n            \"description\": \"The ID of the parent comment for nested/threaded replies. Nullable for top-level comments (direct replies to posts).\\n\\nReferenced from 'parent_id' in the comments Prisma schema. Implements thread/nesting support and conversation branching per requirements.\"\n          }\n        },\n        \"required\": [\n          \"content\"\n        ],\n        \"description\": \"Model for creating a new comment on a post or as a reply to another comment.\\n\\nBased on the requirements document and comments schema, this interface allows users to create either a top-level comment or a nested reply. Only registered users may comment. Thread assignment is supported via optional parent_id.\"\n      },\n      \"bbsComments.IUpdate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"content\": {\n            \"type\": \"string\",\n            \"description\": \"Updated comment body text.\\n\\nChanged content for this comment. Enforces non-empty value and transparent audit trails, per the 'content' column in comments Prisma model.\"\n          }\n        },\n        \"required\": [\n          \"content\"\n        ],\n        \"description\": \"Model for updating an existing comment. Allows comment text to be edited subject to audit and ownership rules (see Prisma comment model and requirements analysis).\"\n      },\n      \"IBbsCommentReply.IRequest\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"page\": {\n            \"oneOf\": [\n              {\n                \"type\": \"integer\",\n                \"format\": \"uint32\",\n                \"description\": \"Page number for pagination (optional). Allows navigating through multiple pages of replies. See standard 'IPage' interface definition.\"\n              },\n              {\n                \"type\": \"null\",\n                \"format\": \"uint32\",\n                \"description\": \"Page number for pagination (optional). Allows navigating through multiple pages of replies. See standard 'IPage' interface definition.\"\n              }\n            ],\n            \"description\": \"Page number for pagination (optional). Allows navigating through multiple pages of replies. See standard 'IPage' interface definition.\"\n          },\n          \"limit\": {\n            \"oneOf\": [\n              {\n                \"type\": \"integer\",\n                \"format\": \"uint32\",\n                \"description\": \"Number of replies per page (optional). Defaults to 100 if not specified. See IPage.IRequest standard type.\"\n              },\n              {\n                \"type\": \"null\",\n                \"format\": \"uint32\",\n                \"description\": \"Number of replies per page (optional). Defaults to 100 if not specified. See IPage.IRequest standard type.\"\n              }\n            ],\n            \"description\": \"Number of replies per page (optional). Defaults to 100 if not specified. See IPage.IRequest standard type.\"\n          }\n        },\n        \"description\": \"Parameters for listing or searching child replies to a specific comment. Implements filtering/pagination for nested replies based on standard IPage IRequest schema.\",\n        \"required\": []\n      },\n      \"IPageIBbsCommentReply\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"pagination\": {\n            \"$ref\": \"#/components/schemas/IPage.IPagination\"\n          },\n          \"data\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IBbsCommentReply\"\n            },\n            \"description\": \"List of reply comments matching the search/pagination criteria. Each item is an IBbsCommentReply instance.\"\n          }\n        },\n        \"required\": [\n          \"pagination\",\n          \"data\"\n        ],\n        \"description\": \"Paginated container for replies to a specific comment.\\n\\nImplements the IPage structure for consistent pagination information and reply lists. Used in threaded/nested comment UIs and admin moderation tools.\"\n      },\n      \"IBbsCommentReply\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"Unique identifier for the comment reply.\\n\\nPrimary key from the comments Prisma model. Used for programmatic operations and API lookups.\"\n          },\n          \"user_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"Identifier for the authoring user of this reply comment.\\n\\nReferences users.id. Used for attribution, audit, and profile summary features.\"\n          },\n          \"post_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"Identifier for the parent post to which this reply (comment) belongs.\\n\\nReferences posts.id. Required for evidence/auditing, threading context, and navigation (see ERD and comments model).\"\n          },\n          \"parent_id\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"format\": \"uuid\",\n                \"description\": \"Identifier for the parent comment if this is a reply (threading hierarchy). Null for top-level (post) replies, set for nested replies.\\n\\nMapped from comments.parent_id in the Prisma schema.\"\n              },\n              {\n                \"type\": \"null\",\n                \"format\": \"uuid\",\n                \"description\": \"Identifier for the parent comment if this is a reply (threading hierarchy). Null for top-level (post) replies, set for nested replies.\\n\\nMapped from comments.parent_id in the Prisma schema.\"\n              }\n            ],\n            \"description\": \"Identifier for the parent comment if this is a reply (threading hierarchy). Null for top-level (post) replies, set for nested replies.\\n\\nMapped from comments.parent_id in the Prisma schema.\"\n          },\n          \"content\": {\n            \"type\": \"string\",\n            \"description\": \"Reply body text for this comment. Business meaning: user-supplied message or opinion as per 'content' in Prisma model.\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"description\": \"Timestamp for when the reply comment was created (ISO 8601 format).\\n\\nTaken from comments.created_at. Important for audit/history, proper ordering, and moderation evidence.\"\n          },\n          \"updated_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"description\": \"Timestamp for last edit. Reflects edit history and transparency for users/moderators. Maps to comments.updated_at field.\"\n          },\n          \"deleted_at\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"format\": \"date-time\",\n                \"description\": \"If set, indicates the reply was deleted (soft delete logic). Used for moderation/audit preservation. Matches comments.deleted_at.\"\n              },\n              {\n                \"type\": \"null\",\n                \"format\": \"date-time\",\n                \"description\": \"If set, indicates the reply was deleted (soft delete logic). Used for moderation/audit preservation. Matches comments.deleted_at.\"\n              }\n            ],\n            \"description\": \"If set, indicates the reply was deleted (soft delete logic). Used for moderation/audit preservation. Matches comments.deleted_at.\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"user_id\",\n          \"post_id\",\n          \"content\",\n          \"created_at\",\n          \"updated_at\"\n        ],\n        \"description\": \"A single reply comment/nested reply object.\\n\\nRepresents a direct response to a parent comment (or a top-level post reply).\\nIncludes all evidence required for auditing, threading, and moderation. Referenced from threaded/nested replies in comments Prisma model.\"\n      },\n      \"IBbsCommentReply.ICreate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"content\": {\n            \"type\": \"string\",\n            \"description\": \"Reply content (body text). User-supplied message or opinion contributed as a nested reply. From comments.content Prisma field.\"\n          }\n        },\n        \"required\": [\n          \"content\"\n        ],\n        \"description\": \"Payload for creating a new reply (nested comment) to a parent comment. Enforces required comment body, referenced from comments Prisma model and requirements analysis.\"\n      },\n      \"IBbsCommentReply.IUpdate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"content\": {\n            \"type\": \"string\",\n            \"description\": \"Updated reply content (body text). Used when editing reply within allowed window, per requirements.\"\n          }\n        },\n        \"required\": [\n          \"content\"\n        ],\n        \"description\": \"Edit/update payload for a reply comment (nested thread). Allows the reply content to be changed. Ownership and audit rules apply.\"\n      },\n      \"IBbsVote.IRequest\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"page\": {\n            \"oneOf\": [\n              {\n                \"type\": \"integer\",\n                \"format\": \"uint32\",\n                \"description\": \"Page number for result pagination. Used for navigating through vote records. See IPage.IRequest guidelines.\"\n              },\n              {\n                \"type\": \"null\",\n                \"format\": \"uint32\",\n                \"description\": \"Page number for result pagination. Used for navigating through vote records. See IPage.IRequest guidelines.\"\n              }\n            ],\n            \"description\": \"Page number for result pagination. Used for navigating through vote records. See IPage.IRequest guidelines.\"\n          },\n          \"limit\": {\n            \"oneOf\": [\n              {\n                \"type\": \"integer\",\n                \"format\": \"uint32\",\n                \"description\": \"Number of vote records per page. Default is 100. Controls batch size returned. See IPage.IRequest.\"\n              },\n              {\n                \"type\": \"null\",\n                \"format\": \"uint32\",\n                \"description\": \"Number of vote records per page. Default is 100. Controls batch size returned. See IPage.IRequest.\"\n              }\n            ],\n            \"description\": \"Number of vote records per page. Default is 100. Controls batch size returned. See IPage.IRequest.\"\n          },\n          \"user_id\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"format\": \"uuid\",\n                \"description\": \"Filter by the voter's (user's) UUID. Useful for auditing or personal history views. From votes.user_id.\"\n              },\n              {\n                \"type\": \"null\",\n                \"format\": \"uuid\",\n                \"description\": \"Filter by the voter's (user's) UUID. Useful for auditing or personal history views. From votes.user_id.\"\n              }\n            ],\n            \"description\": \"Filter by the voter's (user's) UUID. Useful for auditing or personal history views. From votes.user_id.\"\n          },\n          \"post_id\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"format\": \"uuid\",\n                \"description\": \"Filter by a specific post (UUID) - returns votes associated with the given post ID. From votes.post_id.\"\n              },\n              {\n                \"type\": \"null\",\n                \"format\": \"uuid\",\n                \"description\": \"Filter by a specific post (UUID) - returns votes associated with the given post ID. From votes.post_id.\"\n              }\n            ],\n            \"description\": \"Filter by a specific post (UUID) - returns votes associated with the given post ID. From votes.post_id.\"\n          },\n          \"comment_id\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"format\": \"uuid\",\n                \"description\": \"Filter votes associated with a particular comment (UUID). Enables lookup of votes for a comment thread/reply (votes.comment_id).\"\n              },\n              {\n                \"type\": \"null\",\n                \"format\": \"uuid\",\n                \"description\": \"Filter votes associated with a particular comment (UUID). Enables lookup of votes for a comment thread/reply (votes.comment_id).\"\n              }\n            ],\n            \"description\": \"Filter votes associated with a particular comment (UUID). Enables lookup of votes for a comment thread/reply (votes.comment_id).\"\n          },\n          \"value\": {\n            \"oneOf\": [\n              {\n                \"const\": -1,\n                \"description\": \"Filter by vote value: +1 (upvote) or -1 (downvote). Optional. From votes.value.\"\n              },\n              {\n                \"const\": 1,\n                \"description\": \"Filter by vote value: +1 (upvote) or -1 (downvote). Optional. From votes.value.\"\n              },\n              {\n                \"type\": \"null\",\n                \"enum\": [\n                  -1,\n                  1\n                ],\n                \"description\": \"Filter by vote value: +1 (upvote) or -1 (downvote). Optional. From votes.value.\"\n              }\n            ],\n            \"description\": \"Filter by vote value: +1 (upvote) or -1 (downvote). Optional. From votes.value.\"\n          },\n          \"created_after\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"format\": \"date-time\",\n                \"description\": \"Include votes created after this date/time (ISO-8601). Audit/analytics tool.\"\n              },\n              {\n                \"type\": \"null\",\n                \"format\": \"date-time\",\n                \"description\": \"Include votes created after this date/time (ISO-8601). Audit/analytics tool.\"\n              }\n            ],\n            \"description\": \"Include votes created after this date/time (ISO-8601). Audit/analytics tool.\"\n          },\n          \"created_before\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"format\": \"date-time\",\n                \"description\": \"Include votes created before this date/time (ISO-8601). Audit/analytics/periodic analysis.\"\n              },\n              {\n                \"type\": \"null\",\n                \"format\": \"date-time\",\n                \"description\": \"Include votes created before this date/time (ISO-8601). Audit/analytics/periodic analysis.\"\n              }\n            ],\n            \"description\": \"Include votes created before this date/time (ISO-8601). Audit/analytics/periodic analysis.\"\n          }\n        },\n        \"description\": \"Request/query object for searching votes table. Implements voting auditability, moderation, and analytics as detailed in Prisma model and requirements analysis.\",\n        \"required\": []\n      },\n      \"IPageIBbsVote\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"pagination\": {\n            \"$ref\": \"#/components/schemas/IPage.IPagination\"\n          },\n          \"data\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IBbsVote\"\n            },\n            \"description\": \"Vote records for the query window, each as an IBbsVote object.\"\n          }\n        },\n        \"required\": [\n          \"pagination\",\n          \"data\"\n        ],\n        \"description\": \"Paginated result structure for queries on the votes table.\\n\\nStandardized as IPage<T>, with pagination and vote data array. Used in moderation, analytics, and voting integrity checks.\"\n      },\n      \"IBbsVote\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"Unique identifier for the vote record. Maps to votes.id in Prisma schema.\"\n          },\n          \"user_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"User (voter) UUID that cast this vote. From votes.user_id. Used for auditing and per-user history.\"\n          },\n          \"post_id\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"format\": \"uuid\",\n                \"description\": \"UUID of the post being voted on, if applicable. From votes.post_id. Mutually exclusive with comment_id per schema.\"\n              },\n              {\n                \"type\": \"null\",\n                \"format\": \"uuid\",\n                \"description\": \"UUID of the post being voted on, if applicable. From votes.post_id. Mutually exclusive with comment_id per schema.\"\n              }\n            ],\n            \"description\": \"UUID of the post being voted on, if applicable. From votes.post_id. Mutually exclusive with comment_id per schema.\"\n          },\n          \"comment_id\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"format\": \"uuid\",\n                \"description\": \"UUID of the comment being voted on, if applicable. From votes.comment_id. Mutually exclusive with post_id.\"\n              },\n              {\n                \"type\": \"null\",\n                \"format\": \"uuid\",\n                \"description\": \"UUID of the comment being voted on, if applicable. From votes.comment_id. Mutually exclusive with post_id.\"\n              }\n            ],\n            \"description\": \"UUID of the comment being voted on, if applicable. From votes.comment_id. Mutually exclusive with post_id.\"\n          },\n          \"value\": {\n            \"oneOf\": [\n              {\n                \"const\": -1,\n                \"description\": \"Vote value: +1 for upvote, -1 for downvote. Enforced by DB check and business rules. From votes.value.\"\n              },\n              {\n                \"const\": 1,\n                \"description\": \"Vote value: +1 for upvote, -1 for downvote. Enforced by DB check and business rules. From votes.value.\"\n              }\n            ],\n            \"description\": \"Vote value: +1 for upvote, -1 for downvote. Enforced by DB check and business rules. From votes.value.\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"description\": \"Timestamp when the vote was made. From votes.created_at. Used for auditing, reporting, and analytics.\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"user_id\",\n          \"value\",\n          \"created_at\"\n        ],\n        \"description\": \"A single vote record (post or comment vote).\\n\\nDefines the core information about a user-provided upvote/downvote for either a post or comment. Per schema, only one of post_id or comment_id is populated for each record. Business rules for voting integrity apply.\"\n      },\n      \"IBbsVote.ICreate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"post_id\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"format\": \"uuid\",\n                \"description\": \"ID of the post to be voted on. Set this or comment_id, but not both. Enforced by business logic and unique constraint (see votes.post_id).\"\n              },\n              {\n                \"type\": \"null\",\n                \"format\": \"uuid\",\n                \"description\": \"ID of the post to be voted on. Set this or comment_id, but not both. Enforced by business logic and unique constraint (see votes.post_id).\"\n              }\n            ],\n            \"description\": \"ID of the post to be voted on. Set this or comment_id, but not both. Enforced by business logic and unique constraint (see votes.post_id).\"\n          },\n          \"comment_id\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"format\": \"uuid\",\n                \"description\": \"ID of the comment to be voted on. Set this or post_id, but not both. Only one target can be set. From votes.comment_id.\"\n              },\n              {\n                \"type\": \"null\",\n                \"format\": \"uuid\",\n                \"description\": \"ID of the comment to be voted on. Set this or post_id, but not both. Only one target can be set. From votes.comment_id.\"\n              }\n            ],\n            \"description\": \"ID of the comment to be voted on. Set this or post_id, but not both. Only one target can be set. From votes.comment_id.\"\n          },\n          \"value\": {\n            \"oneOf\": [\n              {\n                \"const\": -1,\n                \"description\": \"Required. Vote value: +1 (upvote) or -1 (downvote). Enforced by schema and business rules.\"\n              },\n              {\n                \"const\": 1,\n                \"description\": \"Required. Vote value: +1 (upvote) or -1 (downvote). Enforced by schema and business rules.\"\n              }\n            ],\n            \"description\": \"Required. Vote value: +1 (upvote) or -1 (downvote). Enforced by schema and business rules.\"\n          }\n        },\n        \"required\": [\n          \"value\"\n        ],\n        \"description\": \"Object for creating a vote on a post or comment.\\n\\nSpecifies the target entity (post_id or comment_id) and the value (+1/-1). Enforces one-vote-per-target-per-user as described in requirements and Prisma schema.\"\n      },\n      \"IBbsVote.IUpdate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"value\": {\n            \"oneOf\": [\n              {\n                \"const\": -1,\n                \"description\": \"New vote value: +1 or -1. Only allowed update. Alters the score on the target entity.\"\n              },\n              {\n                \"const\": 1,\n                \"description\": \"New vote value: +1 or -1. Only allowed update. Alters the score on the target entity.\"\n              }\n            ],\n            \"description\": \"New vote value: +1 or -1. Only allowed update. Alters the score on the target entity.\"\n          }\n        },\n        \"required\": [\n          \"value\"\n        ],\n        \"description\": \"Edit/update payload for an existing vote record.\\n\\nAllows switching between upvote/downvote. Subject to audit and moderator/admin permission checks.\"\n      }\n    }\n  },\n  \"x-samchon-emended-v4\": true\n}"
    },
    "reason": "Step to the interface designing after DB schema generation",
    "step": 0,
    "created_at": "2025-07-08T06:12:57.232Z",
    "completed_at": "2025-07-08T06:16:27.505Z"
  }
]