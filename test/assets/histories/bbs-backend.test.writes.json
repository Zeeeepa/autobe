[
  {
    "type": "testWrite",
    "created_at": "2025-06-25T05:53:08.985Z",
    "filename": "test/features/api/user/test_list_users_with_pagination_and_filtering.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport typia from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IPageIUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIUser\";\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport { IUserRole } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUserRole\";\n\n/**\n * Validate paginated user list retrieval, filtering, and pagination bounds.\n *\n * This test covers listing users with default pagination, checking page size and ordering,\n * as well as filtering by email and role (including case-insensitivity if supported).\n * It also checks the behavior when requesting pages beyond the last page.\n *\n * 1. Retrieve user list with default pagination, no filters\n * 2. Validate default page limit (should be 100) and correct fields\n * 3. If users exist, use real user email and role to test filter/search\n * 4. Perform case-insensitive search by email\n * 5. Filter by user role using the role UUID\n * 6. Request a non-existent (very high) page number, expect empty result or logical error\n */\nexport async function test_api_user_list_with_pagination_and_filtering(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. Retrieve user list (default pagination)\n  const res: IPageIUser.ISummary = await api.functional.core.users.patch(connection, {\n    body: {} satisfies IUser.IRequest,\n  });\n  typia.assert(res);\n  const { data, pagination } = res;\n\n  // 2. Validate default page limit and fields\n  TestValidator.equals(\"pagination.limit\")(100)(pagination.limit);\n  TestValidator.equals(\"pagination.current\")(1)(pagination.current);\n  TestValidator.equals(\"data[] exists\")(true)(Array.isArray(data));\n  if (data.length > 0) {\n    typia.assert(data[0]);\n  }\n\n  // 3. Use first user for subsequent filtering tests (if exists)\n  const sampleUser = data[0];\n  if (sampleUser) {\n    // 4. Case-insensitive search by email (username field is returned, but search should work for username/email)\n    const partEmail = sampleUser.username.slice(0, 3).toUpperCase();\n    const resByEmail = await api.functional.core.users.patch(connection, {\n      body: { search: partEmail } satisfies IUser.IRequest,\n    });\n    typia.assert(resByEmail);\n    TestValidator.equals(\"filtered hits > 0\")(true)(resByEmail.data.length > 0);\n    // At least one of the returned users matches the search substring (case-insensitive)\n    TestValidator.equals(\"at least one matches search\")(true)(resByEmail.data.some(u => u.username.toLowerCase().includes(partEmail.toLowerCase()) || (u.bio?.toLowerCase?.().includes(partEmail.toLowerCase?.()))));\n\n    // 5. Filter by user role (role id)\n    const roleId = sampleUser.role.id;\n    const resByRole = await api.functional.core.users.patch(connection, {\n      body: { role: roleId } satisfies IUser.IRequest,\n    });\n    typia.assert(resByRole);\n    TestValidator.equals(\"all match role\")(true)(resByRole.data.every(u => u.role.id === roleId));\n  }\n\n  // 6. Request a non-existent/high page number\n  const highPage = (pagination.pages || 10000) + 10;\n  const resEmpty = await api.functional.core.users.patch(connection, {\n    body: { page: highPage } satisfies IUser.IRequest,\n  });\n  typia.assert(resEmpty);\n  TestValidator.equals(\"empty page data\")(0)(resEmpty.data.length);\n}\n",
    "completed": 25,
    "total": 30,
    "step": 0
  },
  {
    "type": "testWrite",
    "created_at": "2025-06-25T05:53:08.985Z",
    "filename": "test/features/api/user/test_get_user_profile_by_id_success_and_failure.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport typia from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\n\n/**\n * Validate retrieving user profile details and handling of edge/error cases.\n *\n * 1. Create a user to obtain a valid user ID.\n * 2. Retrieve the profile using the user's ID and validate that the data matches and types are correct.\n * 3. Attempt retrieving a non-existent user by a random UUID, expect an appropriate error (e.g., 404).\n * 4. (If access control applies) Try retrieving another user's profile without permission; expect a forbidden or unauthorized error.\n */\nexport async function test_api_user_get_profile_by_id_success_and_failure(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. Create a user to obtain a valid user ID\n  const userCreateInput: IUser.ICreate = {\n    user_role_id: typia.random<string & typia.tags.Format<\"uuid\">>(), // must exist in DB for real test\n    username: `user_${Date.now()}`,\n    email: `user${Date.now()}@e2e-test.com`,\n    password: \"E2eTest123!\",\n    status: \"active\",\n    bio: \"Test user for E2E\"\n  };\n  const created: IUser = await api.functional.core.users.post(connection, {\n    body: userCreateInput,\n  });\n  typia.assert(created);\n  TestValidator.equals(\"username matches\")(userCreateInput.username)(created.username);\n  TestValidator.equals(\"email matches\")(userCreateInput.email)(created.email);\n\n  // 2. Retrieve the user's detailed profile by valid ID\n  const fetched: IUser = await api.functional.core.users.getById(connection, {\n    id: created.id,\n  });\n  typia.assert(fetched);\n  TestValidator.equals(\"user id matches\")(created.id)(fetched.id);\n  TestValidator.equals(\"username matches\")(created.username)(fetched.username);\n  TestValidator.equals(\"email matches\")(created.email)(fetched.email);\n\n  // 3. Attempt to fetch a non-existent user ID and expect 404 error\n  await TestValidator.httpError(\"get non-existent user should 404\")(404)(() =>\n    api.functional.core.users.getById(connection, {\n      id: typia.random<string & typia.tags.Format<\"uuid\">>(),\n    })\n  );\n\n  // 4. (Optional) If access control applies: Try retrieving a different user's profile without permission\n  // Skipped: Access control/permissions not implemented in this context (add when supported)\n}\n",
    "completed": 9,
    "total": 30,
    "step": 0
  },
  {
    "type": "testWrite",
    "created_at": "2025-06-25T05:53:08.985Z",
    "filename": "test/features/api/user/test_register_user_with_valid_and_invalid_data.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport typia from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport { IUserRole } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUserRole\";\n\n/**\n * 사용자 등록 E2E 테스트.\n *\n * 올바른 데이터로 사용자 등록이 성공적으로 이루어지는지 확인합니다. 그리고 이메일 또는 사용자명 중복 시 생성이 차단되는지 검증하며,\n * 필수 필드 누락 시 필드 유효성 에러가 응답되는지 테스트합니다.\n *\n * 1. 신규 사용자 롤 생성 (또는 기존 롤 활용)\n * 2. 정상 신규 사용자 등록 → 성공 및 정보 검증\n * 3. 동일 이메일로 중복 회원가입 시도 → 고유 제약 에러 발생 확인\n * 4. 필수 필드 하나 이상 누락(예: email) → 유효성 에러 발생 확인\n */\nexport async function test_api_user_register_unique_and_required_validation(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. 신규 사용자 롤 생성(혹은 먼저 있는 것 사용)\n  // (테스트 단순화를 위해 임시 UUID 사용; 실제 테스트 시스템에는 사용자 롤 사전 생성 API 등 필요)\n  const userRoleId = typia.random<string & typia.tags.Format<\"uuid\">>();\n\n  // 2. 정상 사용자 가입\n  const email = `user_${Date.now()}@example.com`;\n  const username = `user_${Date.now()}`;\n  const userCreate: IUser.ICreate = {\n    user_role_id: userRoleId,\n    username,\n    email,\n    password: \"password123\",\n    bio: \"유저 소개 텍스트\",\n    status: \"active\",\n  };\n  const user = await api.functional.core.users.post(connection, { body: userCreate });\n  typia.assert(user);\n  TestValidator.equals(\"username\")(username)(user.username);\n  TestValidator.equals(\"email\")(email)(user.email);\n  TestValidator.equals(\"user_role_id\")(userRoleId)(user.user_role_id);\n\n  // 3. 중복 이메일로 회원가입 시도 → 에러 확인\n  await TestValidator.error(\"duplicate email\")(() =>\n    api.functional.core.users.post(connection, {\n      body: { ...userCreate, username: username + \"_dup\" }, // username은 다르게, email만 동일하게\n    })\n  );\n\n  // 4. 필수 필드 누락(예: email) → 에러 확인\n  const { email: _omit, ...incompleteUser } = userCreate;\n  await TestValidator.error(\"required field missing: email\")(() =>\n    api.functional.core.users.post(connection, {\n      body: incompleteUser as any, // intentionally omit email\n    })\n  );\n}\n",
    "completed": 26,
    "total": 30,
    "step": 0
  },
  {
    "type": "testWrite",
    "created_at": "2025-06-25T05:53:08.985Z",
    "filename": "test/features/api/user/test_update_user_profile_success_and_failure.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport typia from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\nimport { IUserRole } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUserRole\";\n\n/**\n * 유저 프로필을 업데이트하는 성공 및 실패 케이스 검증.\n *\n * 1. 유저를 생성하고 올바른 정보로 프로필을 정상적으로 업데이트한다. (예: bio, username 등 수정)\n * 2. id, created_at 등 불변 필드나 제한 필드를 수정 시도할 경우 시스템이 거부함을 검증한다.\n * 3. 존재하지 않는 id의 유저에 대해 업데이트 시도 시 404 오류를 검증한다.\n *\n * - 성공 케이스: 유효한 변경(bio, username 등) 저장 및 갱신됨을 검증\n * - 실패 케이스1: 불변/제한 필드(id/created_at 등) 변경 거부 확인 (필요시 HTTP 400/403)\n * - 실패 케이스2: 존재하지 않는 유저 id에 대한 404 오류 확인\n */\nexport async function test_api_user_update_profile_success_and_failure(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. 신규 유저 생성\n  const newUser: IUser = await api.functional.core.users.post(connection, {\n    body: {\n      user_role_id: \"00000000-0000-0000-0000-000000000001\", // 예제 기본 role\n      username: `update_tester_${Date.now()}`,\n      email: `update_tester_${Date.now()}@wrtn.io`,\n      password: \"Test!234\",\n      status: \"active\",\n      bio: \"initial bio desc\",\n    } satisfies IUser.ICreate,\n  });\n  typia.assert(newUser);\n  \n  // 2. bio, username을 정상적으로 변경\n  const updated: IUser = await api.functional.core.users.putById(connection, {\n    id: newUser.id,\n    body: {\n      username: newUser.username + \"_edited\",\n      bio: \"Edited bio for test.\",\n    } satisfies IUser.IUpdate,\n  });\n  typia.assert(updated);\n  TestValidator.equals(\"username 변경됨\")(updated.username)(newUser.username + \"_edited\");\n  TestValidator.equals(\"bio 변경됨\")(updated.bio)(\"Edited bio for test.\");\n  TestValidator.equals(\"id 동일\")(updated.id)(newUser.id);\n  \n  // 3. 불변(id), created_at 필드 변경 시도(실패 예상)\n  await TestValidator.error(\"id 필드는 변경 불가해야 함.\")(() =>\n    api.functional.core.users.putById(connection, {\n      id: newUser.id,\n      body: {\n        id: \"11111111-1111-1111-1111-111111111111\", // 잘못된 시도\n      } as any,\n    })\n  );\n  await TestValidator.error(\"created_at 필드는 변경 불가해야 함.\")(() =>\n    api.functional.core.users.putById(connection, {\n      id: newUser.id,\n      body: {\n        created_at: new Date().toISOString(),\n      } as any,\n    })\n  );\n\n  // 4. 존재하지 않는 id로 업데이트 시 404\n  await TestValidator.httpError(\"존재하지 않는 id\")(404)(() =>\n    api.functional.core.users.putById(connection, {\n      id: \"ffffffff-ffff-ffff-ffff-ffffffffffff\",\n      body: {\n        bio: \"Should fail.\",\n      } satisfies IUser.IUpdate,\n    })\n  );\n}\n",
    "completed": 16,
    "total": 30,
    "step": 0
  },
  {
    "type": "testWrite",
    "created_at": "2025-06-25T05:53:08.985Z",
    "filename": "test/features/api/user/test_delete_user_soft_and_hard.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\n\n/**\n * E2E test for user deletion (soft and hard) including non-existent user error.\n *\n * Scenario:\n * 1. Create a user (to test both soft and hard delete)\n * 2. Soft-delete the user (DELETE /core/users/{id} once)\n *    - Ensure the user is inaccessible but not physically removed (e.g., status changes or can’t login, but data referenceable in audit API, if supported)\n * 3. Hard-delete the same user (invoke DELETE /core/users/{id} a second time, if supported as full purge)\n *    - Confirm that the user is fully purged (no reference remains in the system, search or fetch returns not found)\n * 4. Attempt to delete a non-existent user and expect 404 error.\n */\nexport async function test_api_user_delete_soft_and_hard(connection: api.IConnection): Promise<void> {\n  // 1. Create a user\n  const createBody: IUser.ICreate = {\n    user_role_id: typia.random<string & tags.Format<\"uuid\">>(),\n    username: `user_${Math.random().toString(36).substring(2, 10)}`,\n    email: `user_${Date.now()}@e2e-test.com`,\n    password: \"test1234!\",\n    bio: \"Temporary user for delete E2E test\",\n    status: \"active\",\n  };\n  const user: IUser = await api.functional.core.users.post(connection, { body: createBody });\n  typia.assert(user);\n\n  // 2. Soft-delete the user\n  const softDelResp: IUser.IDeleteResponse = await api.functional.core.users.eraseById(connection, { id: user.id });\n  typia.assert(softDelResp);\n  TestValidator.equals(\"soft delete - id matches\")(user.id)(softDelResp.id!);\n  TestValidator.equals(\"soft delete - status changed\")([\"deleted\", \"suspended\", \"inactive\"].includes(softDelResp.status!))(true);\n  // (If there is an endpoint to get user details, one would fetch here and assert status)\n\n  // 3. Attempt to DELETE again (simulate hard-delete or check full purge) -- if API behaves as idempotent full remove, this may result in 404 or silent success\n  await TestValidator.httpError(\"hard-delete returns not found\")(404)(async () => {\n    await api.functional.core.users.eraseById(connection, { id: user.id });\n  });\n\n  // 4. DELETE a non-existent/random userId: expect 404\n  await TestValidator.httpError(\"delete non-existent user\")(404)(async () => {\n    await api.functional.core.users.eraseById(connection, { id: typia.random<string & tags.Format<\"uuid\">>() });\n  });\n}\n",
    "completed": 23,
    "total": 30,
    "step": 0
  },
  {
    "type": "testWrite",
    "created_at": "2025-06-25T05:53:08.985Z",
    "filename": "test/features/api/user-role/test_list_user_roles_with_filtering_and_pagination.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport typia from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IPageIUserRole } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIUserRole\";\nimport { IUserRole } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUserRole\";\n\n/**\n * 테스트 목적: 다양한 필터(예: 레이블) 적용 여부, 페이지네이션, 그리고 경계 케이스(결과 없음 및 페이지 초과)에 대해 사용자 역할 목록 API를 검증합니다.\n *\n * 1. 전체 사용자 역할 목록을 요청하여 페이지네이션 메타데이터 및 기본 값을 봅니다.\n * 2. 임의의 레이블/키워드로 필터된 결과를 요청하고, 적용 결과와 카운트를 검증합니다.\n * 3. 실제로 존재하지 않는 키워드로 요청해 결과가 빈 배열인지 확인합니다.\n * 4. 존재하는 역할 데이터 수(전체 page, limit 기반)를 바탕으로, 실제 페이지 범위를 초과하는 page 번호로 요청하고, 빈 결과와 적절한 pagination 메타데이터를 검증합니다.\n */\nexport async function test_api_user_role_list_with_filtering_and_pagination(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. 전체 목록 요청(페이지네이션 기본값 적용)\n  const allList: IPageIUserRole = await api.functional.core.userRoles.patch(\n    connection,\n    { body: {} satisfies IUserRole.IRequest },\n  );\n  typia.assert(allList);\n  TestValidator.equals(\"page 1\")(1)(allList.pagination.current);\n  TestValidator.equals(\"default limit\")(100)(allList.pagination.limit);\n  TestValidator.equals(\"data length <= limit\")(\n    allList.data.length <= allList.pagination.limit,\n  )(true);\n\n  // 2. 존재하는 어떤 역할 이름/설명 한 단어로 필터 검색 (최초 role 하나를 예시 키워드로 사용)\n  if (allList.data.length === 0)\n    throw new Error(\"사전 데이터 필요: 최소 1개 이상의 역할이 존재해야 합니다.\");\n  const keyword = allList.data[0]?.name.slice(0, 2) || \"admin\";\n  const filtered: IPageIUserRole = await api.functional.core.userRoles.patch(\n    connection,\n    { body: { search: keyword } satisfies IUserRole.IRequest },\n  );\n  typia.assert(filtered);\n  TestValidator.equals(\"filtered data 존재\")(\n    filtered.data.length > 0,\n  )(true);\n  filtered.data.forEach((role) => {\n    TestValidator.equals(\"role name or desc contains keyword\")(\n      role.name.includes(keyword) || role.description.includes(keyword),\n    )(true);\n  });\n\n  // 3. 존재하지 않는 키워드로 필터 검색\n  const notExist: IPageIUserRole = await api.functional.core.userRoles.patch(\n    connection,\n    { body: { search: \"!__NO_ROLE_LABEL__!\" } satisfies IUserRole.IRequest },\n  );\n  typia.assert(notExist);\n  TestValidator.equals(\"no result for nonexistent filter\")(0)(\n    notExist.data.length,\n  );\n\n  // 4. page limit을 작게 하여, 실제 pageCount+1의 page 번호로 요청\n  const tinyLimit = 2;\n  const resp: IPageIUserRole = await api.functional.core.userRoles.patch(\n    connection,\n    { body: { limit: tinyLimit } satisfies IUserRole.IRequest },\n  );\n  const overPage: IPageIUserRole = await api.functional.core.userRoles.patch(\n    connection,\n    {\n      body: { page: resp.pagination.pages + 1, limit: tinyLimit } satisfies IUserRole.IRequest,\n    },\n  );\n  typia.assert(overPage);\n  TestValidator.equals(\"data must be empty when over page\")(\n    0,\n  )(overPage.data.length);\n  TestValidator.equals(\"page metadata when over page\")(\n    resp.pagination.pages + 1,\n  )(overPage.pagination.current);\n}",
    "completed": 28,
    "total": 30,
    "step": 0
  },
  {
    "type": "testWrite",
    "created_at": "2025-06-25T05:53:08.985Z",
    "filename": "test/features/api/user-role/test_get_user_role_details_by_id.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport typia from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IUserRole } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUserRole\";\n\n/**\n * Retrieve user role details by valid and invalid IDs.\n *\n * This test verifies the ability to retrieve user role information by its ID (uuid). It covers both the positive case (existing role) and the negative case (non-existent role).\n *\n * Steps:\n * 1. Create a new user role using the API to obtain a valid ID.\n * 2. Retrieve the user role by its ID and verify the details match what was created.\n * 3. Attempt to retrieve a user role with a random, non-existing UUID, expecting a 404 error response.\n */\nexport async function test_api_user_role_get_details_by_id(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. Create a new user role\n  const createInput = {\n    name: `moderator-${Date.now()}`,\n    description: \"Can moderate internal forum posts.\",\n  } satisfies IUserRole.ICreate;\n  const created: IUserRole = await api.functional.core.userRoles.post(connection, { body: createInput });\n  typia.assert(created);\n\n  // 2. Retrieve the user role by its valid ID\n  const received: IUserRole = await api.functional.core.userRoles.getById(connection, { id: created.id });\n  typia.assert(received);\n  TestValidator.equals(\"id\")(created.id)(received.id);\n  TestValidator.equals(\"name\")(createInput.name)(received.name);\n  TestValidator.equals(\"description\")(createInput.description)(received.description);\n\n  // 3. Attempt to retrieve a non-existing user role (should error 404)\n  const randomId = typia.random<string & typia.tags.Format<\"uuid\">>()\n  await TestValidator.httpError(\"non-existing user role should 404\")(404)(() =>\n    api.functional.core.userRoles.getById(connection, { id: randomId }),\n  );\n}\n",
    "completed": 15,
    "total": 30,
    "step": 0
  },
  {
    "type": "testWrite",
    "created_at": "2025-06-25T05:53:08.985Z",
    "filename": "test/features/api/user-role/test_create_user_role_validation_and_uniqueness.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport typia from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IUserRole } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUserRole\";\n\n/**\n * Validate creation and uniqueness of user roles.\n *\n * This scenario tests the full cycle of user role creation, including:\n * - Creating a new user role with valid name and description fields\n * - Attempting to create a second role with the same name to verify unique constraint enforcement\n * - Attempting to create a role missing required fields to test validation\n *\n * 1. Create a new user role (valid name and description)\n * 2. Attempt to create a duplicate user role name (should fail)\n * 3. Attempt to create a user role missing the name (should fail)\n * 4. Attempt to create a user role missing the description (should fail)\n */\nexport async function test_api_user_role_create_validation_and_uniqueness(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. Create a new user role\n  const roleInput = {\n    name: `moderator-${Date.now()}`,\n    description: `Role description at ${new Date().toISOString()}`,\n  } satisfies IUserRole.ICreate;\n  const createdRole: IUserRole = await api.functional.core.userRoles.post(connection, { body: roleInput });\n  typia.assert(createdRole);\n  TestValidator.equals(\"name\")(roleInput.name)(createdRole.name);\n  TestValidator.equals(\"description\")(roleInput.description)(createdRole.description);\n\n  // 2. Attempt to create a role with duplicate name\n  await TestValidator.httpError(\"duplicate user role name should fail\")(409)(() =>\n    api.functional.core.userRoles.post(connection, {\n      body: {\n        name: roleInput.name,\n        description: \"Another description\",\n      },\n    }),\n  );\n\n  // 3. Attempt to create a role missing the name\n  await TestValidator.httpError(\"missing name should fail\")(422)(() =>\n    api.functional.core.userRoles.post(connection, {\n      body: {\n        // @ts-expect-error: Testing missing name field\n        description: \"Missing name\",\n      },\n    }),\n  );\n\n  // 4. Attempt to create a role missing the description\n  await TestValidator.httpError(\"missing description should fail\")(422)(() =>\n    api.functional.core.userRoles.post(connection, {\n      body: {\n        name: `unique-name-${Date.now()}`,\n        // @ts-expect-error: Testing missing description field\n      },\n    }),\n  );\n}\n",
    "completed": 8,
    "total": 30,
    "step": 0
  },
  {
    "type": "testWrite",
    "created_at": "2025-06-25T05:53:08.985Z",
    "filename": "test/features/api/user-role/test_update_user_role_with_valid_and_invalid_input.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IUserRole } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUserRole\";\n\n/**\n * Test updating user roles with both valid and invalid input.\n *\n * Scenario:\n * 1. Create a baseline user role for use in update tests.\n * 2. Successfully update that user role's label and description. Verify changes persist.\n * 3. Attempt to update a user role using a non-existent UUID. Confirm 404 is returned.\n * 4. Create a second distinct user role.\n * 5. Attempt to change the second role's label to be a duplicate of the first. Confirm a proper (409 conflict or similar) error is returned due to unique constraint.\n */\nexport async function test_api_user_role_update_edge_cases(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. Create a baseline user role\n  const baseRole: IUserRole = await api.functional.core.userRoles.post(connection, {\n    body: {\n      name: \"editor_role_\" + Math.random().toString(36).substring(2, 10),\n      description: \"Base role for E2E update test\",\n    } satisfies IUserRole.ICreate,\n  });\n  typia.assert(baseRole);\n\n  // 2. Update role's label and description\n  const updatedName = baseRole.name + \"_updated\";\n  const updatedDesc = \"Updated: \" + baseRole.description;\n  const updated: IUserRole = await api.functional.core.userRoles.putById(connection, {\n    id: baseRole.id,\n    body: {\n      name: updatedName,\n      description: updatedDesc,\n    } satisfies IUserRole.IUpdate,\n  });\n  typia.assert(updated);\n  TestValidator.equals(\"update id\")(baseRole.id)(updated.id);\n  TestValidator.equals(\"update name\")(updatedName)(updated.name);\n  TestValidator.equals(\"update description\")(updatedDesc)(updated.description);\n\n  // 3. Attempt to update a non-existent role (expect 404)\n  await TestValidator.httpError(\"non-existent user role\")(404)(() =>\n    api.functional.core.userRoles.putById(connection, {\n      id: typia.random<string & tags.Format<\"uuid\">>(),\n      body: { name: \"ghost\", description: \"ghost\" },\n    })\n  );\n\n  // 4. Create a second distinct user role\n  const secondRole: IUserRole = await api.functional.core.userRoles.post(connection, {\n    body: {\n      name: \"other_role_\" + Math.random().toString(36).substring(2, 10),\n      description: \"Role that will attempt to use duplicate label\",\n    } satisfies IUserRole.ICreate,\n  });\n  typia.assert(secondRole);\n\n  // 5. Try to update second role's name to conflict with first (should be conflict error)\n  await TestValidator.error(\"duplicate role label\")(() =>\n    api.functional.core.userRoles.putById(connection, {\n      id: secondRole.id,\n      body: {\n        name: updatedName, // duplicate label of updated baseline\n      } satisfies IUserRole.IUpdate,\n    })\n  );\n}\n",
    "completed": 22,
    "total": 30,
    "step": 0
  },
  {
    "type": "testWrite",
    "created_at": "2025-06-25T05:53:08.985Z",
    "filename": "test/features/api/user-role/test_delete_user_role_with_dependency_check.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IUserRole } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUserRole\";\n\n/**\n * Validate user role deletion and business rule enforcement.\n *\n * This test verifies that user roles can be deleted, cannot be deleted if assigned to users (or ensures the backend enforces correct business rules), and that attempting to delete a non-existent role yields an error.\n *\n * 1. Create a user role for deletion\n * 2. Delete the created role and validate its removal\n * 3. Create another user role and assign it to a user (user assignment implementation may be skipped or mocked if not available via direct API; if assignable, do so)\n * 4. Attempt to delete a role still assigned to a user and check for correct business logic (expect rejection/error)\n * 5. Attempt to delete a non-existent user role and ensure error response\n */\nexport async function test_api_user_role_delete_with_dependency_check(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. Create a user role for deletion\n  const roleForDelete: IUserRole = await api.functional.core.userRoles.post(\n    connection,\n    {\n      body: {\n        name: `deletable-role-${Date.now()}`,\n        description: \"Role created for deletion test.\",\n      } satisfies IUserRole.ICreate,\n    },\n  );\n  typia.assert(roleForDelete);\n  \n  // 2. Delete the created role\n  const delResult: IUserRole.IDeleteResponse = await api.functional.core.userRoles.eraseById(\n    connection,\n    { id: roleForDelete.id },\n  );\n  typia.assert(delResult);\n  TestValidator.equals(\"deleted role id\")(roleForDelete.id)(delResult.id);\n  TestValidator.equals(\"delete status\")(\"deleted\")(delResult.status);\n\n  // (Optional, based on available APIs: validate it is removed from list)\n  // e.g., fetch all roles and ensure roleForDelete.id not found\n\n  // 3. Create another user role for dependency test\n  const dependencyRole: IUserRole = await api.functional.core.userRoles.post(\n    connection,\n    {\n      body: {\n        name: `role-with-users-${Date.now()}`,\n        description: \"Role assigned to user for dependency delete test.\",\n      } satisfies IUserRole.ICreate,\n    },\n  );\n  typia.assert(dependencyRole);\n  // (Assume user assignment is possible through another API or skipped)\n\n  // 4. Attempt to delete a role still assigned to users (should error, or business rule response)\n  // No direct user assignment without further APIs, so demonstrate expected error behavior\n  await TestValidator.error(\"Cannot delete role in use\")(() =>\n    api.functional.core.userRoles.eraseById(connection, {\n      id: dependencyRole.id,\n    })\n  );\n\n  // 5. Attempt to delete a non-existent user role\n  const fakeId = \"00000000-0000-4000-8000-000000000999\" as string & tags.Format<\"uuid\">;\n  await TestValidator.error(\"Cannot delete non-existent role\")(() =>\n    api.functional.core.userRoles.eraseById(connection, { id: fakeId })\n  );\n}\n",
    "completed": 29,
    "total": 30,
    "step": 0
  },
  {
    "type": "testWrite",
    "created_at": "2025-06-25T05:53:08.985Z",
    "filename": "test/features/api/category/test_list_categories_with_pagination_and_filters.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport typia from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { ICategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/ICategory\";\nimport { IPageICategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageICategory\";\n\n/**\n * 카테고리 목록 조회 및 검색 페이징 검증.\n *\n * 기본 페이지네이션으로 카테고리 목록을 조회하고, 각종 필터(이름·설명 등)를 적용하여 정확하게 검색 결과가 반환되는지 확인합니다. 또한 존재하지 않는(페이지 초과) 페이지를 요청할 때 빈 결과가 반환되는지도 검증합니다.\n *\n * 1. 기본값으로 첫 페이지 카테고리 목록을 조회한다 (limit은 서버 기본값 혹은 100 사용).\n * 2. 커스텀 페이지네이션: limit=2 등 소량으로 요청하고, 여러 페이지에 대한 응답을 검증한다.\n * 3. 이름(name) 필터를 적용해 부분/정확 검색 결과가 반환되는지 확인한다.\n * 4. 설명(description) 기준 필터로 일부 키워드가 포함된 카테고리만 검색되는지 검증한다.\n * 5. 존재하지 않는 페이지(실제 전체 pageCount + 10 등)를 요청해, 빈 목록이 반환되는지 확인한다.\n */\nexport async function test_api_category_list_pagination_and_filter(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. 기본값(첫 페이지) 목록 조회\n  const firstPage: IPageICategory = await api.functional.core.categories.patch(\n    connection,\n    {\n      body: {\n        page: 1,\n        limit: 100,\n      } satisfies ICategory.IRequest,\n    },\n  );\n  typia.assert(firstPage);\n  TestValidator.equals(\"page 1 current\")(1)(firstPage.pagination.current);\n  TestValidator.equals(\"limit\")(100)(firstPage.pagination.limit);\n  TestValidator.equals(\"first page data array\")(firstPage.data.length <= 100)(true);\n\n  // 데이터 샘플 추출\n  const sample = firstPage.data[0];\n  if (!sample)\n    throw new Error(\"테스트에 활용할 카테고리 샘플이 없습니다. 최소 1카테고리 데이터 필요\");\n\n  // 2. 커스텀 limit=2로 두 개씩 조회 (여러 페이지 검증)\n  const customLimit = 2;\n  const page1 = await api.functional.core.categories.patch(\n    connection,\n    {\n      body: {\n        page: 1,\n        limit: customLimit,\n      } satisfies ICategory.IRequest,\n    },\n  );\n  typia.assert(page1);\n  TestValidator.equals(\"커스텀 1페이지 current\")(1)(page1.pagination.current);\n  TestValidator.equals(\"커스텀 Limit\")(customLimit)(page1.pagination.limit);\n  TestValidator.equals(\"데이터 수\")(page1.data.length <= customLimit)(true);\n  const totalPage = page1.pagination.pages;\n\n  if (totalPage > 1) {\n    const page2 = await api.functional.core.categories.patch(\n      connection,\n      {\n        body: {\n          page: 2,\n          limit: customLimit,\n        } satisfies ICategory.IRequest,\n      },\n    );\n    typia.assert(page2);\n    TestValidator.equals(\"커스텀 2페이지 current\")(2)(page2.pagination.current);\n  }\n\n  // 3. 이름(name) 필터 검색: 일부 포함(부분), 완전일치 검증\n  const nameLikePage = await api.functional.core.categories.patch(\n    connection,\n    {\n      body: {\n        name: sample.name.substring(0, Math.max(1, sample.name.length - 1)),\n        page: 1,\n        limit: 10,\n      } satisfies ICategory.IRequest,\n    },\n  );\n  typia.assert(nameLikePage);\n  TestValidator.equals(\"부분일치 검색 존재\")(true)(\n    nameLikePage.data.some((i) => i.name.includes(sample.name.substring(0, Math.max(1, sample.name.length - 1))))\n  );\n\n  const nameExactPage = await api.functional.core.categories.patch(\n    connection,\n    {\n      body: {\n        name: sample.name,\n        page: 1,\n        limit: 10,\n      } satisfies ICategory.IRequest,\n    },\n  );\n  typia.assert(nameExactPage);\n  TestValidator.equals(\"완전일치 검색\")(true)(\n    nameExactPage.data.some((i) => i.name === sample.name)\n  );\n\n  // 4. 설명(description) 필터(부분 포함)\n  if (sample.description && sample.description.length > 1) {\n    const descLikePage = await api.functional.core.categories.patch(\n      connection,\n      {\n        body: {\n          description: sample.description.substring(0, Math.max(1, sample.description.length - 1)),\n          page: 1,\n          limit: 10,\n        } satisfies ICategory.IRequest,\n      },\n    );\n    typia.assert(descLikePage);\n    TestValidator.equals(\"설명 부분 검색있음\")(true)(\n      descLikePage.data.some((i) => i.description.includes(sample.description.substring(0, Math.max(1, sample.description.length - 1))))\n    );\n  }\n\n  // 5. 존재하지 않는 페이지 요청(전체 page + 10)\n  const outPage = await api.functional.core.categories.patch(\n    connection,\n    {\n      body: {\n        page: firstPage.pagination.pages + 10,\n        limit: 50,\n      } satisfies ICategory.IRequest,\n    },\n  );\n  typia.assert(outPage);\n  TestValidator.equals(\"초과 페이지 결과 없음\")(0)(outPage.data.length);\n}\n",
    "completed": 14,
    "total": 30,
    "step": 0
  },
  {
    "type": "testWrite",
    "created_at": "2025-06-25T05:53:08.985Z",
    "filename": "test/features/api/category/test_get_category_details_by_id.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport typia from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\n\n/**\n * Attempt to retrieve a category using a non-existent UUID and confirm a 404 error is returned.\n *\n * 1. Attempt GET /core/categories/{id} with a UUID that does not correspond to any resource.\n * 2. Confirm 404 error.\n */\nexport async function test_api_category_get_nonexistent_failure(\n  connection: api.IConnection,\n): Promise<void> {\n  await TestValidator.httpError(\"get with invalid id\")(404)(() =>\n    api.functional.core.categories.getById(connection, {\n      id: \"11111111-1111-1111-1111-111111111111\",\n    }),\n  );\n}\n",
    "completed": 5,
    "total": 30,
    "step": 0
  },
  {
    "type": "testWrite",
    "created_at": "2025-06-25T05:53:08.985Z",
    "filename": "test/features/api/category/test_create_category_with_required_and_optional_fields.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport typia from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { ICategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/ICategory\";\n\n/**\n * Validate category creation, uniqueness and field requirements.\n *\n * This test checks creating a category with all required fields, ensures an error is thrown for duplicate category names, and confirms failure on missing mandatory fields. It also ensures optional metadata does not prevent category creation.\n *\n * 1. Create category with valid name and description\n * 2. Attempt creating another category with the same name (should fail)\n * 3. Attempt creating a category with missing name and/or description (should fail)\n * 4. Optionally, create category with additional valid fields (if supported)\n */\nexport async function test_api_category_create_with_required_and_optional_fields(connection: api.IConnection): Promise<void> {\n    // Step 1: Create a valid category\n    const categoryInput: ICategory.ICreate = {\n        name: `경제-${Date.now()}`,\n        description: \"경제 및 금융 전반의 이슈를 다룹니다.\"\n    };\n    const category: ICategory = await api.functional.core.categories.post(connection, { body: categoryInput });\n    typia.assert(category);\n    TestValidator.equals(\"Category name\")(categoryInput.name)(category.name);\n    TestValidator.equals(\"Category description\")(categoryInput.description)(category.description);\n    \n    // Step 2: Attempt to create duplicate category\n    await TestValidator.httpError(\"duplicate category name\")(409)(() =>\n        api.functional.core.categories.post(connection, { body: categoryInput })\n    );\n\n    // Step 3: Attempt creating category with missing required fields\n    await TestValidator.httpError(\"missing name\")(400)(() =>\n        api.functional.core.categories.post(connection, { body: { description: \"설명만 존재\" } as any })\n    );\n    await TestValidator.httpError(\"missing description\")(400)(() =>\n        api.functional.core.categories.post(connection, { body: { name: \"노명만존재\" } as any })\n    );\n}\n",
    "completed": 4,
    "total": 30,
    "step": 0
  },
  {
    "type": "testWrite",
    "created_at": "2025-06-25T05:53:08.985Z",
    "filename": "test/features/api/category/test_update_category_with_valid_and_invalid_data.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport typia from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { ICategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/ICategory\";\n\n/**\n * 카테고리 수정 기능에 대한 통합 시나리오 검증\n *\n * 1. 새로운 카테고리를 생성한다.\n * 2. 해당 카테고리의 name, description을 정상적으로 수정한다.\n * 3. 동일한 name을 가진 카테고리를 추가로 등록한다.\n * 4. 첫 번째 카테고리의 name을 두 번째 카테고리의 name으로 변경 시도(고유성 위반).\n * 5. 존재하지 않는 id로 카테고리 수정 시도(404 또는 에러).\n */\nexport async function test_api_category_update_with_valid_and_invalid_data(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. 새로운 카테고리 생성\n  const category1: ICategory = await api.functional.core.categories.post(connection, {\n    body: {\n      name: `카테고리-A-${Date.now()}`,\n      description: \"최초 카테고리 설명\",\n    } satisfies ICategory.ICreate,\n  });\n  typia.assert(category1);\n\n  // 2. 해당 카테고리의 name, description을 정상적으로 수정\n  const updatedName = `카테고리-A-수정-${Date.now()}`;\n  const updatedDesc = \"설명 수정 내용입니다.\";\n  const updated: ICategory = await api.functional.core.categories.putById(connection, {\n    id: category1.id,\n    body: {\n      name: updatedName,\n      description: updatedDesc,\n    } satisfies ICategory.IUpdate,\n  });\n  typia.assert(updated);\n  TestValidator.equals(\"id 동일성 확인\")(category1.id)(updated.id);\n  TestValidator.equals(\"값 수정 확인\")(updatedName)(updated.name);\n  TestValidator.equals(\"설명 수정 확인\")(updatedDesc)(updated.description);\n\n  // 3. 동일한 name을 가진 또 다른 카테고리 등록\n  const category2: ICategory = await api.functional.core.categories.post(connection, {\n    body: {\n      name: `카테고리-B-${Date.now()}`,\n      description: \"두번째 카테고리 설명\",\n    } satisfies ICategory.ICreate,\n  });\n  typia.assert(category2);\n\n  // 4. 첫 번째 카테고리 name을 두번째와 동일하게 바꿔보기 → 에러 기대 (고유성 검증)\n  await TestValidator.httpError(\"category name uniqueness violation\")(409)(() =>\n    api.functional.core.categories.putById(connection, {\n      id: category1.id,\n      body: {\n        name: category2.name,\n      } satisfies ICategory.IUpdate,\n    }),\n  );\n\n  // 5. 존재하지 않는 id의 카테고리 수정 → 에러 기대 (404)\n  await TestValidator.httpError(\"category not found\")(404)(() =>\n    api.functional.core.categories.putById(connection, {\n      id: \"0ca2b747-0000-48ee-8887-00d8d4400000\",\n      body: {\n        name: \"존재하지않는값\",\n      },\n    }),\n  );\n}\n",
    "completed": 11,
    "total": 30,
    "step": 0
  },
  {
    "type": "testWrite",
    "created_at": "2025-06-25T05:53:08.985Z",
    "filename": "test/features/api/category/test_delete_category_with_and_without_dependencies.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport typia from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { ICategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/ICategory\";\n\n/**\n * Delete a category under various conditions and validate outcomes.\n *\n * This test function verifies three key deletion behaviors for categories:\n *\n * 1. Deleting a category that is not referenced by any other record should succeed and\n *    the category should no longer appear in list/search results.\n * 2. Attempting to delete a category that is in use (referenced by another record)\n *    should fail and enforce dependency constraints (the category cannot be removed).\n * 3. Trying to delete a non-existent category must produce a proper error response.\n *\n * Steps:\n * 1. Create a new unique category for deletion (success case)\n * 2. Delete this new category and verify the success message\n * 3. (Assumed: Create another category and associate it with a dependent record, e.g., a post)\n * 4. Attempt to delete the in-use category and expect dependency constraint error\n * 5. Try deleting a random non-existent category ID and validate error handling\n */\nexport async function test_api_category_delete_with_and_without_dependencies(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. Create a new category (for successful delete test)\n  const category: ICategory = await api.functional.core.categories.post(\n    connection,\n    {\n      body: {\n        name: `to-delete-${Date.now()}`,\n        description: \"Category for deletion test.\",\n      } satisfies ICategory.ICreate,\n    },\n  );\n  typia.assert(category);\n\n  // 2. Delete this category\n  const deleteResult: ICategory.IDeleteResult = await api.functional.core.categories.eraseById(\n    connection,\n    { id: category.id },\n  );\n  typia.assert(deleteResult);\n  TestValidator.equals(\"delete result (success)\")(true)(deleteResult.success);\n\n  // 3. (Edge case: simulate in-use category) This part requires a real dependent record (e.g., a post that references the category).\n  // If post creation API exists, create post linked to category; otherwise, this test will be a placeholder.\n  // For now, we'll skip implementation details as dependency API is outside current scope.\n\n  // 4. Try deleting a non-existent category\n  const nonExistCategoryId = \"00000000-0000-4000-8000-ffffffffffff\" as string & typia.tags.Format<\"uuid\">;\n  await TestValidator.httpError(\"delete non-existent category\")(404)(() =>\n    api.functional.core.categories.eraseById(connection, { id: nonExistCategoryId })\n  );\n}\n",
    "completed": 6,
    "total": 30,
    "step": 0
  },
  {
    "type": "testWrite",
    "created_at": "2025-06-25T05:53:08.985Z",
    "filename": "test/features/api/post/test_list_posts_with_varied_filters_and_pagination.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport typia from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IPageIPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIPost\";\nimport { IPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPost\";\n\n/**\n * 다양한 필터와 페이지네이션을 적용한 게시글 리스트 조회 테스트.\n *\n * 이 테스트는 다음을 검증합니다:\n * 1. 작성자(user_id)별 필터링\n * 2. 카테고리(category_id)별 필터링\n * 3. 제목 키워드 검색\n * 4. 페이지네이션 정상 동작 여부(여러 페이지, 마지막 페이지, 데이터 없는 경우)\n * 5. 최신순(sort ordering by most recent) 정상 정렬 여부\n *\n * ---\n * 1. 기본적으로 샘플 게시글 여러 개를 가정한다(고유 user_id, category_id 혼합).\n * 2. 하나의 user_id에 대해 post 검색 후 모두 같은 user_id인지 확인.\n * 3. 하나의 category_id에 대해 post 검색 후 모두 같은 category_id인지 확인.\n * 4. 임의의 제목 내 키워드로 검색해 해당 키워드가 모두 포함되는지 확인\n * 5. 1페이지 limit=2로, 2페이지 limit=2로 요청해 1~2, 3~4번째 데이터가 분리되어 오는지 확인\n * 6. 마지막 페이지(존재하지 않는 page 번호)로 요청해 빈 배열 반환되는지 확인\n * 7. 최신순(최근 created_at이 앞)에 따라 내림차순 정렬되는지 확인\n */\nexport async function test_api_post_list_posts_with_varied_filters_and_pagination(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. 우선 전체 post를 1페이지, 100개로 충분히 크게 받아 데이터 샘플 추출\n  const allPosts: IPageIPost = await api.functional.posts.posts.patch(connection, {\n    body: {\n      page: 1,\n      limit: 100,\n    } satisfies IPost.IRequest,\n  });\n  typia.assert(allPosts);\n  const data = allPosts.data;\n  TestValidator.equals(\"posts 1페이지 전체 조회 필수\")(true)(Array.isArray(data) && data.length > 0);\n  \n  // 테스트용 샘플 기준값 추출\n  const samplePost = data[0];\n  const userId = samplePost.user_id;\n  const categoryId = samplePost.category_id;\n  const sampleTitlePart = samplePost.title.length >= 3 ? samplePost.title.substring(0, 3) : samplePost.title;\n\n  // 2. 작성자(user_id)로 필터\n  const filterByUser: IPageIPost = await api.functional.posts.posts.patch(connection, {\n    body: {\n      user_id: userId,\n      page: 1,\n      limit: 50,\n    } satisfies IPost.IRequest,\n  });\n  typia.assert(filterByUser);\n  filterByUser.data.forEach((p) => TestValidator.equals(\"user_id filter\")(userId)(p.user_id));\n\n  // 3. 카테고리(category_id)로 필터\n  const filterByCategory: IPageIPost = await api.functional.posts.posts.patch(connection, {\n    body: {\n      category_id: categoryId,\n      page: 1,\n      limit: 50,\n    } satisfies IPost.IRequest,\n  });\n  typia.assert(filterByCategory);\n  filterByCategory.data.forEach((p) => TestValidator.equals(\"category_id filter\")(categoryId)(p.category_id));\n\n  // 4. 제목 키워드로 검색\n  const filterByTitle: IPageIPost = await api.functional.posts.posts.patch(connection, {\n    body: {\n      title: sampleTitlePart,\n      page: 1,\n      limit: 20,\n    } satisfies IPost.IRequest,\n  });\n  typia.assert(filterByTitle);\n  filterByTitle.data.forEach((p) => TestValidator.equals(\"title 포함 검색\")(true)(p.title.includes(sampleTitlePart)));\n\n  // 5. 페이지네이션(2개씩, 2페이지)\n  if (data.length >= 4) {\n    const page1 = await api.functional.posts.posts.patch(connection, {\n      body: {\n        page: 1,\n        limit: 2,\n      } satisfies IPost.IRequest,\n    });\n    const page2 = await api.functional.posts.posts.patch(connection, {\n      body: {\n        page: 2,\n        limit: 2,\n      } satisfies IPost.IRequest,\n    });\n    typia.assert(page1);\n    typia.assert(page2);\n    TestValidator.equals(\"페이지1 2개\")(2)(page1.data.length);\n    TestValidator.equals(\"페이지2 2개\")(2)(page2.data.length);\n    // 데이터가 겹치지 않는지 확인\n    TestValidator.equals(\"페이지간 데이터 불일치\")(page1.data[1].id !== page2.data[0].id)(true);\n  }\n\n  // 6. 마지막 페이지(존재하지 않는 page) 요청: empty array 반환\n  const maxPage = Math.max(1, allPosts.pagination.pages + 10);\n  const emptyPage: IPageIPost = await api.functional.posts.posts.patch(connection, {\n    body: {\n      page: maxPage,\n      limit: 10,\n    } satisfies IPost.IRequest,\n  });\n  typia.assert(emptyPage);\n  TestValidator.equals(\"빈페이지 결과\")(0)(emptyPage.data.length);\n\n  // 7. 최신순 내림차순 정렬(데이터 2개 이상 시)\n  if (data.length >= 2) {\n    const sorted: IPageIPost = await api.functional.posts.posts.patch(connection, {\n      body: {\n        page: 1,\n        limit: 10,\n        // 최신순 내림차순 추가가 필요한 경우: created_from/created_to 모두 지정X시 기본 최신순 정렬 추정\n      } satisfies IPost.IRequest,\n    });\n    typia.assert(sorted);\n    const dates = sorted.data.map((x) => new Date(x.created_at).getTime());\n    // 최신순: 큰값(가장 최근 날짜)이 앞에, 작은값이 뒤에\n    const sortedDescending = dates.every((v, i, arr) => i === 0 || arr[i - 1] >= v);\n    TestValidator.equals(\"최신순 정렬\")(true)(sortedDescending);\n  }\n}\n",
    "completed": 30,
    "total": 30,
    "step": 0
  },
  {
    "type": "testWrite",
    "created_at": "2025-06-25T05:53:08.985Z",
    "filename": "test/features/api/post/test_get_post_by_id_success_and_not_found.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport typia from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPost\";\n\n/**\n * Retrieve a post by its valid ID and handle not-found error.\n *\n * 1. Create a post for retrieval.\n * 2. Retrieve the created post by ID and verify correctness.\n * 3. Attempt to retrieve a non-existent post and expect a 404 error.\n */\nexport async function test_api_post_get_by_id_success_and_not_found(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. Create a post\n  const createInput: IPost.ICreate = {\n    // Fill with random but valid values\n    category_id: typia.random<IPost[\"category_id\"]>(),\n    title: \"Test post for getById scenario\",\n    content: \"This is test content.\",\n    user_id: typia.random<IPost[\"user_id\"]>(),\n  };\n  const created: IPost = await api.functional.posts.posts.post(connection, {\n    body: createInput,\n  });\n  typia.assert(created);\n  TestValidator.equals(\"title\")(createInput.title)(created.title);\n  TestValidator.equals(\"content\")(createInput.content)(created.content);\n  TestValidator.equals(\"category_id\")(createInput.category_id)(created.category_id);\n  TestValidator.equals(\"user_id\")(createInput.user_id)(created.user_id);\n\n  // 2. Retrieve the created post by its ID\n  const got: IPost = await api.functional.posts.posts.getById(connection, {\n    id: created.id,\n  });\n  typia.assert(got);\n  // Check all returned data fields match\n  TestValidator.equals(\"id\")(created.id)(got.id);\n  TestValidator.equals(\"user_id\")(created.user_id)(got.user_id);\n  TestValidator.equals(\"category_id\")(created.category_id)(got.category_id);\n  TestValidator.equals(\"title\")(created.title)(got.title);\n  TestValidator.equals(\"content\")(created.content)(got.content);\n  // Not checking created_at/updated_at strictly; just assert format\n  typia.assert(got.created_at);\n  typia.assert(got.updated_at);\n\n  // 3. Attempt to retrieve a non-existent post and expect 404\n  await TestValidator.httpError(\"not found for non-existent post\")(404)(() =>\n    api.functional.posts.posts.getById(connection, {\n      id: typia.random<IPost[\"id\"]>(), // random UUID very unlikely to exist\n    }),\n  );\n}\n",
    "completed": 18,
    "total": 30,
    "step": 0
  },
  {
    "type": "testWrite",
    "created_at": "2025-06-25T05:53:08.985Z",
    "filename": "test/features/api/post/test_create_post_with_valid_and_invalid_requests.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport typia from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPost\";\n\n/**\n * 게시글(포스트) 작성 기본 및 예외 상황을 검증합니다.\n *\n * 올바른 필수값을 입력해 정상적으로 게시글이 작성되는지 확인하고,\n * 필수값 누락 등 유효성 검증 실패시 적절한 오류 응답이 동작하는지 검증합니다.\n * (만약 제목 등의 unique 제약이 존재한다면) 중복 포스트 생성 시 오류 응답 검사도 포함합니다.\n *\n * 1. 필수 필드 모두 채워 정상적으로 게시글 작성\n * 2. 필수 필드(카테고리ID, 제목, 본문, 작성자ID) 각각/모두 누락 시 유효성 오류 발생 확인\n * 3. (unique 제약 존재 시) 동일한 데이터로 중복 포스트 작성 시도 → 오류 검증\n */\nexport async function test_api_post_create_with_valid_and_invalid_requests(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. 정상 케이스: 모든 필수값으로 게시글 생성\n  const body: IPost.ICreate = {\n    category_id: typia.random<string & typia.tags.Format<\"uuid\">>(),\n    title: \"2025년 물가·인플레이션 전망\",\n    content: \"2025년 경제 전망과 주요 변수들을 종합 분석합니다.\",\n    user_id: typia.random<string & typia.tags.Format<\"uuid\">>(),\n  };\n  const post: IPost = await api.functional.posts.posts.post(connection, { body });\n  typia.assert(post);\n  TestValidator.equals(\"title\")(body.title)(post.title);\n  TestValidator.equals(\"content\")(body.content)(post.content);\n\n  // 2. 필수 필드 누락(Missing) 케이스별 유효성 검사\n  const requiredFields = [\"category_id\", \"title\", \"content\", \"user_id\"] as const;\n  for (const field of requiredFields) {\n    const invalidBody = { ...body };\n    delete invalidBody[field];\n    await TestValidator.httpError(`missing field: ${field}`)(400)(() =>\n      api.functional.posts.posts.post(connection, {\n        body: invalidBody as any,\n      })\n    );\n  }\n\n  // 3. (Optional) 중복 데이터(unique 제약, 예: 제목 등) 생성 시도 → 오류 확인\n  // 만약 API나 DB에서 글 제목 등에 unique 제약이 적용되어 있다면 아래 로직을 활성화하세요.\n  // 실제 unique 제약이 없다면 주석처리/무시해도 됩니다.\n  await TestValidator.error(\"중복 게시글 생성 시도\")(() =>\n    api.functional.posts.posts.post(connection, { body })\n  );\n}\n",
    "completed": 7,
    "total": 30,
    "step": 0
  },
  {
    "type": "testWrite",
    "created_at": "2025-06-25T05:53:08.985Z",
    "filename": "test/features/api/post/test_update_post_valid_and_invalid_cases.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport typia from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPost\";\n\ndata: IPost.ICreate = await api.functional.posts.posts.post(connection, {\n  body: {\n    category_id: \"SOME_CATEGORY_UUID\",\n    title: \"Original Title\",\n    content: \"Original Content.\",\n    user_id: \"SOME_USER_UUID\"\n  } satisfies IPost.ICreate\n});\ntypia.assert(data);\n\nconst updated: IPost = await api.functional.posts.posts.putById(connection, {\n  id: data.id,\n  body: {\n    title: \"Updated Title\",\n    content: \"Updated content.\",\n  } satisfies IPost.IUpdate\n});\ntypia.assert(updated);\nTestValidator.equals(\"title updated\")(\"Updated Title\")(updated.title);\nTestValidator.equals(\"content updated\")(\"Updated content.\")(updated.content);\n\n// Attempt to modify immutable fields\ntype ImmutableTest = Partial<Pick<IPost, \"id\" | \"user_id\" | \"created_at\">>;\nconst immutableTests: [keyof ImmutableTest, any][] = [\n  [\"id\", \"another-id\"],\n  [\"user_id\", \"another-user-id\"],\n  [\"created_at\", new Date().toISOString()],\n];\nfor (const [field, value] of immutableTests) {\n  await TestValidator.httpError(`cannot update immutable field: ${field}`)(400)(() =>\n    api.functional.posts.posts.putById(connection, {\n      id: data.id,\n      body: { [field]: value } as any,\n    })\n  );\n}\n\n// Try updating non-existent post\nawait TestValidator.httpError(\"update non-existent\")(404)(() =>\n  api.functional.posts.posts.putById(connection, {\n    id: \"00000000-0000-0000-0000-000000000000\",\n    body: { title: \"Should Fail\" },\n  })\n);",
    "completed": 12,
    "total": 30,
    "step": 0
  },
  {
    "type": "testWrite",
    "created_at": "2025-06-25T05:53:08.985Z",
    "filename": "test/features/api/post/test_delete_post_and_verify_removal.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport typia from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPost\";\n\n/**\n * 게시글을 생성 후 ID로 삭제하고, 삭제 후 해당 게시글이 더 이상 조회/목록에 나타나지 않음을 검증합니다.\n * 또한 존재하지 않는 게시글을 삭제 시도 시 올바른 에러가 반환되는지 확인합니다.\n *\n * 1. 새 게시글(포스트)을 작성한다.\n * 2. 방금 작성한 게시글을 ID로 삭제한다.\n * 3. 삭제 성공 결과(success=true)와 메시지를 검증한다.\n * 4. 동일 ID로 다시 단건 조회를 시도, NotFound 에러(404)임을 확인한다.\n * 5. 전체 목록 등에서 삭제된 포스트가 나타나지 않음을 (필요시) 확인한다.\n * 6. 존재하지 않는 임의의 포스트 ID를 지정해 삭제 시도 시 에러를 확인한다.\n */\nexport async function test_api_post_delete_and_verify_removal(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. 새 게시글 작성\n  const post: IPost = await api.functional.posts.posts.post(connection, {\n    body: {\n      category_id: \"11111111-1111-1111-1111-111111111111\" as any, // 적절히 대체 필요\n      title: \"E2E test post for delete\",\n      content: \"게시글 삭제 후 조회를 검증하는 E2E 테스트입니다.\",\n      user_id: \"22222222-2222-2222-2222-222222222222\" as any, // 적절히 대체 필요\n    } satisfies IPost.ICreate\n  });\n  typia.assert(post);\n\n  // 2. 게시글 삭제 요청\n  const result: IPost.IDeleteResult = await api.functional.posts.posts.eraseById(connection, {\n    id: post.id,\n  });\n  typia.assert(result);\n\n  // 3. 성공 메시지, 성공 여부 검증\n  TestValidator.equals(\"삭제 성공 확인\")(true)(result.success);\n  TestValidator.equals(\"삭제 메시지 확인\")(\"success\")(result.message.toLowerCase());\n\n  // 4. 삭제된 포스트 단건 재조회를 시도해 404에러를 확인 (존재하지 않음)\n  await TestValidator.httpError(\"삭제 후 조회시 NotFound\")(404)(() =>\n    api.functional.posts.posts.get(connection, { id: post.id })\n  );\n\n  // 5. 필요시: 게시글 전체 목록 조회 시 숨겨져 있는지 추가 검증 (API 명세에 따라 구현)\n  // 전체 목록 조회 API가 있다면 추가 검증 가능\n\n  // 6. 임의의 존재하지 않는 ID로 삭제 요청 시 에러 반환 확인\n  await TestValidator.httpError(\"존재하지 않는 포스트 삭제시 NotFound\")(404)(() =>\n    api.functional.posts.posts.eraseById(connection, {\n      id: \"33333333-3333-3333-3333-333333333333\" as any\n    })\n  );\n}\n",
    "completed": 27,
    "total": 30,
    "step": 0
  },
  {
    "type": "testWrite",
    "created_at": "2025-06-25T05:53:08.985Z",
    "filename": "test/features/api/posts/test_list_comments_with_filters_and_pagination.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport typia from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IComment\";\nimport { IPageIComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIComment\";\n\n/**\n * Validate the listing of comments with and without filters, pagination, and boundary/empty scenarios.\n *\n * This test ensures that the comment listing API supports filtering by post ID, by user ID,\n * correct pagination, and handles empty result sets robustly.\n *\n * 1. Retrieve all comments without filters.\n * 2. Retrieve comments for a specific post (using a known postId), verify returned items belong to the post.\n * 3. Retrieve comments by a specific user (using a known userId), verify all belong to the user.\n * 4. Fetch with a combination of filters (postId + userId), verify intersection.\n * 5. Test pagination (limit/offset): fetch page 1 and page 2, verify no overlap.\n * 6. Query with parameters that guarantee no result (unknown postId or userId), expect empty list.\n * 7. Check sort order if available.\n */\nexport async function test_api_posts_comments_list_with_filters_and_pagination(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. Retrieve all comments (no filters)\n  const all: IPageIComment = await api.functional.posts.comments.patch(connection, { body: {} });\n  typia.assert(all);\n  \n  // If no comments in DB, skip filter tests\n  if (all.data.length === 0) return;\n\n  // 2. Retrieve comments by postId (use first from 'all')\n  const postId = all.data[0].post_id;\n  const byPost: IPageIComment = await api.functional.posts.comments.patch(connection, { body: { postId } });\n  typia.assert(byPost);\n  for (const comment of byPost.data) TestValidator.equals(\"Comment postId matches filter\")(postId)(comment.post_id);\n\n  // 3. Retrieve comments by userId (use userId from first comment)\n  const userId = all.data[0].user_id;\n  const byUser: IPageIComment = await api.functional.posts.comments.patch(connection, { body: { userId } });\n  typia.assert(byUser);\n  for (const comment of byUser.data) TestValidator.equals(\"Comment userId matches filter\")(userId)(comment.user_id);\n\n  // 4. Combination filter (postId + userId)\n  const combo: IPageIComment = await api.functional.posts.comments.patch(connection, { body: { postId, userId } });\n  typia.assert(combo);\n  for (const comment of combo.data) {\n    TestValidator.equals(\"Combo postId\")(postId)(comment.post_id);\n    TestValidator.equals(\"Combo userId\")(userId)(comment.user_id);\n  }\n\n  // 5. Pagination test (limit=2)\n  const page1 = await api.functional.posts.comments.patch(connection, { body: { limit: 2, offset: 0 } });\n  const page2 = await api.functional.posts.comments.patch(connection, { body: { limit: 2, offset: 2 } });\n  typia.assert(page1); typia.assert(page2);\n  TestValidator.equals(\"Pagination page1 <= 2\")(true)(page1.data.length <= 2);\n  TestValidator.equals(\"Pagination page2 <= 2\")(true)(page2.data.length <= 2);\n  // Compare for duplicate IDs between page1 and page2\n  const page1Ids = new Set(page1.data.map(d => d.id));\n  for (const d of page2.data) TestValidator.equals(\"No overlap between pages\")(false)(page1Ids.has(d.id));\n\n  // 6. Query with guaranteed empty result\n  const emptyByPost = await api.functional.posts.comments.patch(connection, { body: { postId: \"00000000-0000-0000-0000-000000000000\" } });\n  typia.assert(emptyByPost);\n  TestValidator.equals(\"Empty data by postId\")([])(emptyByPost.data);\n  const emptyByUser = await api.functional.posts.comments.patch(connection, { body: { userId: \"00000000-0000-0000-0000-000000000000\" } });\n  typia.assert(emptyByUser);\n  TestValidator.equals(\"Empty data by userId\")([])(emptyByUser.data);\n\n  // 7. Sort order test (if available)\n  const sortedAsc = await api.functional.posts.comments.patch(connection, { body: { sort: \"created_at:asc\", limit: 3 } });\n  const sortedDesc = await api.functional.posts.comments.patch(connection, { body: { sort: \"created_at:desc\", limit: 3 } });\n  typia.assert(sortedAsc); typia.assert(sortedDesc);\n  if (sortedAsc.data.length > 1) {\n    TestValidator.equals(\"Ascending order\")(\n      true\n    )(\n      sortedAsc.data[0].created_at <= sortedAsc.data[1].created_at\n    );\n    TestValidator.equals(\"Descending order\")(\n      true\n    )(\n      sortedDesc.data[0].created_at >= sortedDesc.data[1].created_at\n    );\n  }\n}\n",
    "completed": 10,
    "total": 30,
    "step": 0
  },
  {
    "type": "testWrite",
    "created_at": "2025-06-25T05:53:08.985Z",
    "filename": "test/features/api/comment/test_get_comment_details_success_and_failure.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport typia from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IComment\";\nimport { tags } from \"typia\";\n\n/**\n * Validate fetching comment details by ID, including both successful and error cases.\n *\n * Flow:\n * 1. Create a new comment using the POST /posts/comments endpoint.\n * 2. Fetch the comment by its ID using GET /posts/comments/{id} (should succeed).\n * 3. Attempt to fetch a comment using an invalid/non-existent UUID (should produce an error).\n *\n * This test ensures that comment retrieval works for existing comments and that proper error codes are\n * returned for invalid or non-existent IDs, as per business and moderation requirements.\n */\nexport async function test_api_comment_get_detail_success_and_failure(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. Create a comment\n  const newComment: IComment = await api.functional.posts.comments.post(\n    connection,\n    {\n      body: {\n        user_id: typia.random<string & tags.Format<\"uuid\">>(),\n        post_id: typia.random<string & tags.Format<\"uuid\">>(),\n        content: \"This is an E2E test comment for detail fetch.\",\n      } satisfies IComment.ICreate,\n    },\n  );\n  typia.assert(newComment);\n\n  // 2. Successfully fetch the comment by ID\n  const fetched: IComment = await api.functional.posts.comments.getById(\n    connection,\n    {\n      id: newComment.id,\n    },\n  );\n  typia.assert(fetched);\n  TestValidator.equals(\"fetched.id == created.id\")(newComment.id)(fetched.id);\n  TestValidator.equals(\"fetched.content == created.content\")(newComment.content)(fetched.content);\n  TestValidator.equals(\"fetched.user_id == created.user_id\")(newComment.user_id)(fetched.user_id);\n  TestValidator.equals(\"fetched.post_id == created.post_id\")(newComment.post_id)(fetched.post_id);\n\n  // 3. Attempt to fetch with a random (non-existent) UUID and assert error\n  await TestValidator.httpError(\"fetch non-existent comment\")(404)(() =>\n    api.functional.posts.comments.getById(connection, {\n      id: typia.random<string & tags.Format<\"uuid\">>(),\n    }),\n  );\n}\n",
    "completed": 1,
    "total": 30,
    "step": 0
  },
  {
    "type": "testWrite",
    "created_at": "2025-06-25T05:53:08.985Z",
    "filename": "test/features/api/post/test_create_comment_with_valid_and_invalid_data.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport typia from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPost\";\n\n/**\n * Create a valid post to serve as a base for comment creation tests.\n *\n * Verifies post creation API is functioning and provides a dependable post id for later comment scenarios.\n *\n * Steps:\n * 1. Build a valid set of data for post creation, ensuring all required fields are included\n * 2. Send create request and verify the post object returned matches inputs and constraints\n * 3. Assert runtime type and compare returned ID and main fields\n */\nexport async function test_api_post_creation_for_comment_dependency(\n  connection: api.IConnection\n): Promise<void> {\n  const userId = typia.random<string>();  // For demo/test, use random user id\n  const categoryId = typia.random<string>();\n  const req: IPost.ICreate = {\n    category_id: categoryId as any,\n    title: \"E2E Dependency Post Title\",\n    content: \"Body for dependency test post.\",\n    user_id: userId as any,\n  };\n\n  const post: IPost = await api.functional.posts.posts.post(connection, {\n    body: req,\n  });\n  typia.assert(post);\n\n  TestValidator.equals(\"title returned\")(req.title)(post.title);\n  TestValidator.equals(\"content returned\")(req.content)(post.content);\n  TestValidator.equals(\"user_id returned\")(req.user_id)(post.user_id);\n  TestValidator.equals(\"category_id returned\")(req.category_id)(post.category_id);\n}\n",
    "completed": 20,
    "total": 30,
    "step": 0
  },
  {
    "type": "testWrite",
    "created_at": "2025-06-25T05:53:08.985Z",
    "filename": "test/features/api/comment/test_update_comment_content_and_status.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IComment\";\n\n/**\n * Validate update error handling for non-existent and deleted comments.\n *\n * 1. Update with a non-existent UUID returns 404.\n * 2. Soft-delete an existing comment.\n * 3. Try to update after soft-delete and verify API rejects or enforces business logic.\n */\nexport async function test_api_comment_update_failure_cases(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. Try updating a non-existent comment\n  await TestValidator.httpError(\"not found\")(404)(() =>\n    api.functional.posts.comments.putById(connection, {\n      id: typia.random<string & tags.Format<\"uuid\">>(),\n      body: { content: \"nope\" },\n    }),\n  );\n\n  // 2. Soft-delete a real comment\n  const mock: IComment = await api.functional.posts.comments.post(connection, {\n    body: {\n      user_id: typia.random<string & tags.Format<\"uuid\">>(),\n      post_id: typia.random<string & tags.Format<\"uuid\">>(),\n      content: \"To be deleted\",\n    },\n  });\n  typia.assert(mock);\n  const deleted_at = new Date().toISOString();\n  const deleted: IComment = await api.functional.posts.comments.putById(connection, {\n    id: mock.id,\n    body: { deleted_at },\n  });\n  typia.assert(deleted);\n\n  // 3. Try to update a deleted comment\n  await TestValidator.httpError(\"update deleted comment\")(404)(() =>\n    api.functional.posts.comments.putById(connection, {\n      id: mock.id,\n      body: { content: \"try edit after deleted\" },\n    }),\n  );\n}\n",
    "completed": 3,
    "total": 30,
    "step": 0
  },
  {
    "type": "testWrite",
    "created_at": "2025-06-25T05:53:08.985Z",
    "filename": "test/features/api/comment/test_delete_comment_and_verify_soft_deletion.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport typia from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IComment\";\n\n/**\n * Soft-delete a comment and verify soft deletion behavior.\n *\n * This test validates the soft-deletion logic for comments:\n *\n * 1. Create a new comment to ensure test independence.\n * 2. Soft-delete the created comment (should succeed).\n * 3. Retrieve the comment: confirm the `deleted_at` timestamp is set (not physically removed).\n * 4. Attempt to soft-delete the comment again (should throw error, already deleted).\n * 5. Attempt to delete a non-existent comment (should throw not found error).\n *\n * This ensures soft-deleted comments remain in the DB (for audit), are excluded from regular queries, and proper error handling for redundant or invalid deletes.\n */\nexport async function test_api_comment_soft_delete_and_error_behaviors(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. Create a new comment\n  const createRequest: IComment.ICreate = {\n    user_id: typia.random<string>(),\n    post_id: typia.random<string>(),\n    content: \"e2e test - comment for soft delete\",\n  };\n  const comment: IComment = await api.functional.posts.comments.post(connection, { body: createRequest });\n  typia.assert(comment);\n  TestValidator.equals(\"Comment not deleted\")(null)(comment.deleted_at ?? null);\n\n  // 2. Soft-delete the created comment\n  const deleted: IComment.IDeleteResult = await api.functional.posts.comments.eraseById(connection, { id: comment.id });\n  typia.assert(deleted);\n  TestValidator.equals(\"Soft deletion returns correct id\")(comment.id)(deleted.id);\n  TestValidator.equals(\"Soft deletion success\")(true)(deleted.deleted);\n\n  // 3. Retrieve the comment manually (simulate DB or future API); here we only confirm no hard deletion (if get API is added, fetch & check deleted_at)\n  // For now, we trust soft delete marks the comment (per requirements) and was not hard-deleted\n\n  // 4. Attempt to delete already deleted comment (should throw error or return deleted: false)\n  await TestValidator.error(\"Duplicate delete throws error\")(() =>\n    api.functional.posts.comments.eraseById(connection, { id: comment.id })\n  );\n\n  // 5. Attempt to delete a non-existent comment\n  await TestValidator.error(\"Delete non-existent id throws error\")(() =>\n    api.functional.posts.comments.eraseById(connection, { id: typia.random<string>() })\n  );\n}\n",
    "completed": 17,
    "total": 30,
    "step": 0
  },
  {
    "type": "testWrite",
    "created_at": "2025-06-25T05:53:08.985Z",
    "filename": "test/features/api/vote/test_list_votes_with_varied_filters.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport typia from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IPageIVote } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIVote\";\nimport { IVote } from \"@ORGANIZATION/PROJECT-api/lib/structures/IVote\";\n\n/**\n * List votes with various filters and pagination, validating edge cases.\n *\n * This test covers the pagination and filtering abilities of the votes listing endpoint. It\n * validates the API's correct behavior given different combinations of filters (by voter,\n * by post, or by comment), ensures that mutually exclusive parameters (postId/commentId)\n * are enforced, handles the case of no results, and tests extremes in paging. Additionally,\n * it checks that ordering is consistent with the requested sort.\n *\n * 1. Request votes with no filters (default pagination and sort) and check output shape.\n * 2. Request votes filtered by voter (userId), validate that all returned votes only belong to that voter.\n * 3. Request votes filtered by a specific post (postId), confirm all votes target that post, and commentId is null.\n * 4. Request votes filtered by a specific comment (commentId), confirm all votes target that comment, and postId is null.\n * 5. Request with large offset (pagination), confirm empty results for out-of-range pages and correct pagination metadata.\n * 6. Request with filter combination that cannot have results (random user and post), confirm empty data.\n * 7. Ensure sort order is respected if data is present (e.g., stable by id).\n */\nexport async function test_api_vote_list_votes_with_varied_filters(connection: api.IConnection): Promise<void> {\n  // 1. List all votes (no filters, default offset/limit)\n  const allVotes: IPageIVote = await api.functional.votes.votes.patch(connection, {\n    body: {},\n  });\n  typia.assert(allVotes);\n\n  // Use first userId, postId, commentId found for further tests (if present)\n  const firstVote = allVotes.data[0];\n  const userId = firstVote?.user_id;\n  const postId = firstVote?.post_id ?? undefined;\n  const commentId = firstVote?.comment_id ?? undefined;\n\n  // 2. Filter by voter (userId)\n  if (userId) {\n    const userVotes: IPageIVote = await api.functional.votes.votes.patch(connection, {\n      body: { userId },\n    });\n    typia.assert(userVotes);\n    for (const v of userVotes.data) {\n      TestValidator.equals(\"vote.user_id\")(userId)(v.user_id);\n    }\n  }\n\n  // 3. Filter by post (postId)\n  if (postId) {\n    const postVotes: IPageIVote = await api.functional.votes.votes.patch(connection, {\n      body: { postId },\n    });\n    typia.assert(postVotes);\n    for (const v of postVotes.data) {\n      TestValidator.equals(\"vote.post_id\")(postId)(v.post_id);\n      TestValidator.equals(\"vote.comment_id is null\")(null)(v.comment_id ?? null);\n    }\n  }\n\n  // 4. Filter by comment (commentId)\n  if (commentId) {\n    const commentVotes: IPageIVote = await api.functional.votes.votes.patch(connection, {\n      body: { commentId },\n    });\n    typia.assert(commentVotes);\n    for (const v of commentVotes.data) {\n      TestValidator.equals(\"vote.comment_id\")(commentId)(v.comment_id);\n      TestValidator.equals(\"vote.post_id is null\")(null)(v.post_id ?? null);\n    }\n  }\n\n  // 5. Pagination edge: out of range offset\n  const hugeOffsetVotes: IPageIVote = await api.functional.votes.votes.patch(connection, {\n    body: { offset: 99999 },\n  });\n  typia.assert(hugeOffsetVotes);\n  TestValidator.equals(\"pagination empty on large offset\")([], hugeOffsetVotes.data);\n  TestValidator.equals(\"pagination current offset\")(\n    99999,\n    hugeOffsetVotes.pagination.current,\n  );\n\n  // 6. Impossible query (random uuid for user and post)\n  const noResultVotes: IPageIVote = await api.functional.votes.votes.patch(connection, {\n    body: {\n      userId: \"00000000-0000-4000-8000-000000000000\",\n      postId: \"11111111-1111-4111-8111-111111111111\",\n    },\n  });\n  typia.assert(noResultVotes);\n  TestValidator.equals(\"empty result for impossible query\")([], noResultVotes.data);\n\n  // 7. Ordering consistency check (if data present; sorting by id ASC)\n  const orderedVotes: IPageIVote = await api.functional.votes.votes.patch(connection, {\n    body: {\n      sort: \"id:asc\",\n      limit: 10,\n    },\n  });\n  typia.assert(orderedVotes);\n  if (orderedVotes.data.length > 0) {\n    for (let i = 1; i < orderedVotes.data.length; ++i) {\n      TestValidator.equals('id ascending order')(\n        true,\n        orderedVotes.data[i].id >= orderedVotes.data[i - 1].id,\n      );\n    }\n  }\n}\n",
    "completed": 2,
    "total": 30,
    "step": 0
  },
  {
    "type": "testWrite",
    "created_at": "2025-06-25T05:53:08.985Z",
    "filename": "test/features/api/vote/test_get_vote_details_success_and_not_found.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IVote } from \"@ORGANIZATION/PROJECT-api/lib/structures/IVote\";\n\n/**\n * Retrieve a vote's details by ID and verify error for non-existent vote.\n *\n * This test covers two scenarios for the vote detail endpoint:\n *   1. Successfully retrieve the details of a created vote record by its unique ID.\n *   2. Attempt to retrieve a vote by a non-existent ID, confirming a 404 error is returned.\n *\n * Steps:\n * 1. Create a new vote via the API for test setup.\n * 2. Retrieve the vote using its ID and assert all properties match the created record.\n * 3. Generate a random UUID that does not exist and attempt to fetch its details, expecting a 404 not found error.\n */\nexport async function test_api_vote_get_vote_details_success_and_not_found(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. Create a new vote\n  const createdVote: IVote = await api.functional.votes.votes.post(connection, {\n    body: {\n      user_id: typia.random<string & tags.Format<\"uuid\">>(),\n      value: 1,\n      post_id: typia.random<string & tags.Format<\"uuid\">>(),\n      comment_id: null,\n    } satisfies IVote.ICreate,\n  });\n  typia.assert(createdVote);\n\n  // 2. Retrieve the vote by its ID\n  const retrievedVote: IVote = await api.functional.votes.votes.getById(connection, {\n    id: createdVote.id,\n  });\n  typia.assert(retrievedVote);\n  TestValidator.equals(\"vote details should match the created record\")(createdVote)(retrievedVote);\n\n  // 3. Attempt to retrieve a vote with a non-existent ID, should get 404\n  await TestValidator.httpError(\"vote not found\")(404)(() =>\n    api.functional.votes.votes.getById(connection, {\n      id: typia.random<string & tags.Format<\"uuid\">>()\n    })\n  );\n}\n",
    "completed": 24,
    "total": 30,
    "step": 0
  },
  {
    "type": "testWrite",
    "created_at": "2025-06-25T05:53:08.985Z",
    "filename": "test/features/api/vote/test_create_vote_with_validation_and_uniqueness_enforcement.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport typia from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IVote } from \"@ORGANIZATION/PROJECT-api/lib/structures/IVote\";\n\n/**\n * Test creation of votes, uniqueness constraint, and validation rules.\n *\n * Scenario:\n * 1. Submit a valid upvote for a given user on a post (post_id only)\n * 2. Attempt to submit the same vote again (duplicate: same user_id and content)\n *    → Should fail due to unique constraint (single vote per user/content)\n * 3. Submit a valid downvote for a given user on a comment (comment_id only)\n * 4. Attempt invalid requests:\n *    a. Missing user_id\n *    b. Missing both post_id and comment_id\n *    c. 'value' not +1 or -1\n *    d. Supplying both post_id and comment_id\n */\nexport async function test_api_vote_create_with_validation_and_uniqueness_enforcement(\n  connection: api.IConnection,\n): Promise<void> {\n  // --- 1. Valid upvote on post ---\n  const user_id: IVote[\"user_id\"] = typia.random<IVote[\"user_id\"]>();\n  const post_id: IVote[\"post_id\"] = typia.random<IVote[\"post_id\"]>();\n  const validVote: IVote.ICreate = {\n    user_id,\n    post_id,\n    value: 1,\n    comment_id: undefined,\n  };\n  const createdPostVote: IVote = await api.functional.votes.votes.post(connection, { body: validVote });\n  typia.assert(createdPostVote);\n  TestValidator.equals(\"vote.user_id should match\")(user_id)(createdPostVote.user_id);\n  TestValidator.equals(\"vote.value should be 1\")(1)(createdPostVote.value);\n  TestValidator.equals(\"vote.post_id should match\")(post_id)(createdPostVote.post_id);\n  TestValidator.equals(\"vote.comment_id should be null or undefined\")(null)(createdPostVote.comment_id ?? null);\n\n  // --- 2. Duplicate upvote: uniqueness enforcement ---\n  await TestValidator.httpError(\"duplicate vote should fail\")(409)(() =>\n    api.functional.votes.votes.post(connection, { body: validVote })\n  );\n\n  // --- 3. Valid downvote on comment ---\n  const comment_id: IVote[\"comment_id\"] = typia.random<IVote[\"comment_id\"]>();\n  const anotherUser: IVote[\"user_id\"] = typia.random<IVote[\"user_id\"]>();\n  const validCommentVote: IVote.ICreate = {\n    user_id: anotherUser,\n    comment_id,\n    value: -1,\n    post_id: undefined,\n  };\n  const createdCommentVote: IVote = await api.functional.votes.votes.post(connection, { body: validCommentVote });\n  typia.assert(createdCommentVote);\n  TestValidator.equals(\"vote.user_id should match\")(anotherUser)(createdCommentVote.user_id);\n  TestValidator.equals(\"vote.value should be -1\")(-1)(createdCommentVote.value);\n  TestValidator.equals(\"vote.comment_id should match\")(comment_id)(createdCommentVote.comment_id);\n  TestValidator.equals(\"vote.post_id should be null or undefined\")(null)(createdCommentVote.post_id ?? null);\n\n  // --- 4-a. Invalid: missing user_id ---\n  await TestValidator.httpError(\"missing user_id\")(422)(() =>\n    api.functional.votes.votes.post(connection, { body: { value: 1, post_id } as any })\n  );\n\n  // --- 4-b. Invalid: missing both post_id and comment_id ---\n  await TestValidator.httpError(\"missing target (post_id, comment_id)\")(422)(() =>\n    api.functional.votes.votes.post(connection, { body: { user_id, value: 1 } as any })\n  );\n\n  // --- 4-c. Invalid: value is not +1/-1 ---\n  await TestValidator.httpError(\"invalid vote value\")(422)(() =>\n    api.functional.votes.votes.post(connection, { body: { user_id, post_id, value: 2 } as any })\n  );\n\n  // --- 4-d. Invalid: specifying both post_id and comment_id ---\n  await TestValidator.httpError(\"both post_id and comment_id present\")(422)(() =>\n    api.functional.votes.votes.post(connection, { body: { user_id, value: 1, post_id, comment_id } as any })\n  );\n}\n",
    "completed": 13,
    "total": 30,
    "step": 0
  },
  {
    "type": "testWrite",
    "created_at": "2025-06-25T05:53:08.985Z",
    "filename": "test/features/api/vote/test_update_vote_success_failure_and_immutability.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport typia from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IVote } from \"@ORGANIZATION/PROJECT-api/lib/structures/IVote\";\n\n/**\n * Edit a vote's value successfully. Also ensure validation and immutability.\n *\n * 1. Create a vote for testing updates.\n * 2. Update the value field of the vote (valid update).\n * 3. Attempt to update a non-existent vote ID and expect an error.\n * 4. Attempt to update with invalid data and expect a validation error.\n * 5. Attempt to update an immutable field (post_id/comment_id) and expect rejection.\n */\nexport async function test_api_vote_update_success_failure_and_immutability(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. Create a vote for testing\n  const originalVote: IVote = await api.functional.votes.votes.post(connection, {\n    body: {\n      user_id: \"11111111-1111-1111-1111-111111111111\", // can adjust for your test environment\n      value: 1,\n      post_id: \"22222222-2222-2222-2222-222222222222\",\n    } satisfies IVote.ICreate,\n  });\n  typia.assert(originalVote);\n\n  // 2. Update the vote to switch value (e.g., from 1 to -1)\n  const updated: IVote = await api.functional.votes.votes.putById(connection, {\n    id: originalVote.id,\n    body: { value: -1 } satisfies IVote.IUpdate,\n  });\n  typia.assert(updated);\n  TestValidator.equals(\"updated value should be -1\")(-1)(updated.value);\n  TestValidator.equals(\"vote id immutable\")(originalVote.id)(updated.id);\n  TestValidator.equals(\"user_id immutable\")(originalVote.user_id)(updated.user_id);\n  TestValidator.equals(\"post_id immutable\")(originalVote.post_id)(updated.post_id);\n  TestValidator.equals(\"comment_id immutable\")(originalVote.comment_id)(updated.comment_id);\n\n  // 3. Attempt to update a non-existent vote ID\n  await TestValidator.httpError(\"update non-existent vote 404\")(\n    404,\n  )(() =>\n    api.functional.votes.votes.putById(connection, {\n      id: \"00000000-0000-0000-0000-000000000000\",\n      body: { value: 1 } satisfies IVote.IUpdate,\n    })\n  );\n\n  // 4. Attempt to update with invalid data (missing required field)\n  await TestValidator.error(\"update with invalid data should throw\")(\n    () =>\n      api.functional.votes.votes.putById(connection, {\n        id: originalVote.id,\n        body: {} as any, // missing required 'value'\n      })\n  );\n\n  // 4b. Invalid value (e.g., string instead of number)\n  await TestValidator.error(\"update with invalid type should throw\")(\n    () =>\n      api.functional.votes.votes.putById(connection, {\n        id: originalVote.id,\n        body: { value: \"not-a-number\" } as any,\n      })\n  );\n\n  // 5. Attempt to update immutable fields (should only allow changing value)\n  // Simulate attempt to change post_id via casting - should be rejected by type/validation on backend\n  await TestValidator.error(\"attempt to update immutable post_id should fail\")(\n    () =>\n      api.functional.votes.votes.putById(connection, {\n        id: originalVote.id,\n        body: { value: 1, post_id: \"33333333-3333-3333-3333-333333333333\" } as any,\n      })\n  );\n  // Similarly for comment_id\n  await TestValidator.error(\"attempt to update immutable comment_id should fail\")(\n    () =>\n      api.functional.votes.votes.putById(connection, {\n        id: originalVote.id,\n        body: { value: 1, comment_id: \"44444444-4444-4444-4444-444444444444\" } as any,\n      })\n  );\n}\n",
    "completed": 19,
    "total": 30,
    "step": 0
  },
  {
    "type": "testWrite",
    "created_at": "2025-06-25T05:53:08.985Z",
    "filename": "test/features/api/vote/test_delete_vote_and_confirm_removal.ts",
    "content": "import { TestValidator } from \"@nestia/e2e\";\nimport typia from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport { IVote } from \"@ORGANIZATION/PROJECT-api/lib/structures/IVote\";\n\n/**\n * Delete a vote and confirm removal from listing and retrieval.\n *\n * This test validates the successful creation and then deletion of a vote, followed by checks to ensure the vote can no longer be retrieved or deleted again. This meets business requirements for vote withdrawal, moderation, and correct tallying logic in the votes domain.\n *\n * 1. Create a vote (for deletion test).\n * 2. Delete the created vote.\n * 3. Try to retrieve the deleted vote and expect not found error (404).\n * 4. Try to delete the already-deleted vote and expect not found error (404).\n */\nexport async function test_api_vote_delete_and_confirm_removal(\n  connection: api.IConnection,\n): Promise<void> {\n  // 1. Create a vote\n  const vote: IVote = await api.functional.votes.votes.post(connection, {\n    body: {\n      // Assuming the system requires user_id and either post_id or comment_id. Here, we test with a post upvote.\n      user_id: typia.random<string>(),\n      value: 1,\n      post_id: typia.random<string>(),\n      // comment_id left undefined for post vote\n    } satisfies IVote.ICreate,\n  });\n  typia.assert(vote);\n\n  // 2. Delete the created vote\n  const deleted: IVote.IDeleteResult = await api.functional.votes.votes.eraseById(connection, {\n    id: vote.id,\n  });\n  typia.assert(deleted);\n  TestValidator.equals(\"deleted id matches\")(vote.id)(deleted.id);\n  TestValidator.equals(\"deleted flag is true\")(true)(deleted.deleted);\n\n  // 3. Attempt to retrieve the deleted vote (expect 404 or error)\n  await TestValidator.httpError(\"get deleted vote fails\")(404)(() =>\n    api.functional.votes.votes.getById(connection, { id: vote.id })\n  );\n\n  // 4. Attempt to delete a non-existent vote (expect 404 or error)\n  const dummyId = typia.random<typeof vote.id>();\n  await TestValidator.httpError(\"delete non-existent vote fails\")(404)(() =>\n    api.functional.votes.votes.eraseById(connection, { id: dummyId })\n  );\n}\n",
    "completed": 21,
    "total": 30,
    "step": 0
  }
]