[
  {
    "specification": "Search and list users in the system, with support for advanced search, filtering, and pagination. This operation is based on the 'users' table in the Prisma schema. It enables clients to retrieve user records according to various criteria. The endpoint should be able to handle filtering by email, username, status, and date ranges, as well as provide paginated results to support large datasets. This aligns with requirements for privacy-preserving user search, regulatory compliance auditing, and AI feedback loop extraction. The search parameters and return values must match the schema column comments and allow future extensibility for additional filters (e.g., organization, role).",
    "description": "This endpoint provides a comprehensive user listing function, supporting both simple and advanced search needs. All search parameters correspond to atomic, indexed columns in the users table: username, email, status (is_active), organization_id, role_id, and created_at/updated_at date ranges. Pagination parameters such as 'page' and 'pageSize' enable scalable queries across large user bases. Filtering is designed to be stateless and RESTful.\n\nSecurity and permissions are critical, as the operation returns potentially sensitive user information. RBAC and audit logging are required; only authorized admin or privacy-compliant clients may access full lists. Implementation must ensure no exposure of secure fields like password_hash.\n\nThe endpoint implements full auditability: all access and query events are logged in access_log and audit_log tables. Data returned are non-sensitive fields only, in line with privacy and API best practices. Error handling should clearly distinguish between access-denied, invalid query, and backend errors. This operation is extensible for future search enhancements and bulk actions (e.g., CSV export) per compliance or operational needs.\n\nTypical use cases include admin user management, onboarding analytics, user churn monitoring, regulatory investigations, and AI feedback data collection for personalization or fraud prevention models.",
    "summary": "Retrieve a paginated, searchable list of users (users table).",
    "parameters": [],
    "requestBody": {
      "description": "Search, filter, and pagination parameters for users list retrieval.",
      "typeName": "IShoppingUser.IRequest"
    },
    "responseBody": {
      "description": "Paginated, filtered list of user summaries.",
      "typeName": "IPageIShoppingUser.ISummary"
    },
    "path": "/shopping/users",
    "method": "patch"
  },
  {
    "specification": "Retrieve a specific user by unique identifier. Based on the 'users' table, this endpoint returns all non-sensitive details for a given user ID. Fulfills requirements for managing, viewing, or auditing user state. Essential for direct user profile access and management by administrators, as well as supporting AI/ML data pipelines that require a single user detail for explainability or personalized models. The operation must not expose fields marked as restricted (e.g., password_hash).",
    "description": "Fetches full, non-sensitive profile details for a single user as identified by their UUID. The ID parameter is validated for format and existence. Permissions must be enforced; only users with appropriate privileges (such as admins or the user themselves) may access the record. All access is logged in audit_log and access_logs for regulatory compliance.\n\nRelated entities such as roles or organization information may be included or linked by reference. The result includes all primary user fields (username, email, phone, status, timestamps), excluding sensitive cryptographic or authentication material. If the user does not exist or permission is denied, the API returns a compliant error structure with relevant audit evidence. This endpoint supports downstream workflows such as account reviews, incident investigations, and model explainability when a targeted user's data is required.",
    "summary": "Retrieve detailed information for a specific user (users table).",
    "parameters": [
      {
        "name": "id",
        "description": "Unique user identifier (UUID).",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Detailed user object with all permitted fields (no sensitive credentials).",
      "typeName": "IShoppingUser"
    },
    "path": "/shopping/users/{id}",
    "method": "get"
  },
  {
    "specification": "Create a new user account in the system, following the schema and evidence/audit requirements described in 'users'. Inputs must match allowed registration fields and trigger all downstream user creation flows including profile, session initialization, and audit trail creation. Supports both user-facing registration and admin onboarding.",
    "description": "Allows the creation of a new user account with all required attributes—username, email, password (hashed server-side), organization, and role assignment. The endpoint enforces uniqueness checks for username and email as well as role/organization consistency. All events are logged in audit_log and access_log for evidence preservation.\n\nPassword is submitted in a non-plain form or is hashed in transit and is not exposed in any response. After successful creation, related flows such as default user_profile creation and consent initializations are triggered (compliant with onboarding and privacy policies). Error handling guards against duplicate account creation, permission issues, and invalid input. This operation is extensible for SSO/federated ID onboarding in the future.\n\nDownstream integrations can include user onboarding analytics, AI-driven fraud detection, and instant profile personalization. Only authorized actors (self-registration, admin accounts) are permitted by backend business logic.",
    "summary": "Create a new user (users table).",
    "parameters": [],
    "requestBody": {
      "description": "User registration details for a new account.",
      "typeName": "IShoppingUser.ICreate"
    },
    "responseBody": {
      "description": "Full user entity as created, minus sensitive data.",
      "typeName": "IShoppingUser"
    },
    "path": "/shopping/users",
    "method": "post"
  },
  {
    "specification": "Update an existing user’s profile and account data, including role, status, and preferences. Tied to the 'users' table and must enforce both attribute- and structure-level validation. Updates trigger audit, compliance, and evidence logging per requirements. Sensitive fields may only be altered by authorized clients/admins. Supports partial or full update patterns.",
    "description": "Updates the specified user account identified by UUID, changing any permitted field such as username, email, role, status, or organization. Strict validation is enforced for uniqueness (username, email), role and organization ID consistency, and attribute format. The endpoint does not accept updates to restricted fields (e.g., password hash, unless provided via specialized password-change API), and all changes are journaled in audit_log and access_log for evidence preservation.\n\nPermission checks ensure only allowed clients can update accounts; conditional business logic handles cases such as organization transfer (triggers resource inheritance review) or role escalation (requires audit-level review). Any failed update attempt or invalid operation is returned with a compliance-ready error. The workflow may result in downstream integration triggers such as profile sync or AI profile re-evaluation.",
    "summary": "Update user details for a specific user (users table).",
    "parameters": [
      {
        "name": "id",
        "description": "Unique user identifier (UUID).",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": {
      "description": "New profile/account attributes to update an existing user.",
      "typeName": "IShoppingUser.IUpdate"
    },
    "responseBody": {
      "description": "The updated user object with latest permissible attributes.",
      "typeName": "IShoppingUser"
    },
    "path": "/shopping/users/{id}",
    "method": "put"
  },
  {
    "specification": "Remove (soft delete) or deactivate a user in the system by unique identifier. This operation targets the 'users' table and adheres to evidence preservation, audit, and compliance requirements. Deletion is typically implemented as a soft-delete (setting deleted_at) rather than hard removal, to meet regulatory and forensic tracking needs. Only authorized actors may invoke this operation.",
    "description": "Deactivates or soft-deletes a user account by UUID, typically by setting the deleted_at timestamp, updating is_active flag, and recording the event for audit/compliance. The endpoint checks user permissions, includes all relevant data in audit_log and access_log, and ensures user-related objects (profile, sessions, etc.) are handled per business regulations. Hard delete is only allowed under explicit legal clearance (handled by separate API/path).\n\nAttempts to remove users who do not exist, are already deleted, or where permissions are insufficient result in an error with regulatory logging attached. This operation is used for regulatory compliance, user churn handling, and account lifecycle management scenarios.",
    "summary": "Soft-delete (deactivate) a user by ID (users table).",
    "parameters": [
      {
        "name": "id",
        "description": "Unique user identifier (UUID) to be deleted.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Confirmation of user soft-delete with updated user object/status.",
      "typeName": "IShoppingUser"
    },
    "path": "/shopping/users/{id}",
    "method": "delete"
  },
  {
    "specification": "List/search user profiles in the system, supporting advanced metadata filtering, preference search, and pagination. Tied to the 'user_profiles' table. Enables administrators and authorized clients to query user profile data for personalization, accessibility compliance review, and AI feedback analytics. Search parameters align with the schema fields and must preserve privacy and compliance evidence.",
    "description": "This endpoint provides advanced, paginated user profile search. Accepts search filters on fields such as user_id, locale_id, full_name, timezone, a11y_prefs, and creation/updated timestamps. Pagination and sorting options are provided as required for compliance and operational reporting. Search is implemented against indexed fields per the schema.\n\nOnly authorized clients (e.g., admin, compliance, analytics modules) may access profile lists. Personally identifiable information (PII) is only returned when aligned with the organization’s privacy policy, and no authentication or credential data are exposed. All accesses and queries are logged for compliance using audit_log tables. The output is extensible to include additional filtering or join-ready summary objects as future needs arise (such as locale or accessibility stats for accessibility audits).\n\nFailure to meet permission standards or attempt to retrieve restricted data is appropriately blocked and logged.",
    "summary": "Search and retrieve a paginated list of user profiles (user_profiles table).",
    "parameters": [],
    "requestBody": {
      "description": "Filters, search, and pagination parameters for userProfile list retrieval.",
      "typeName": "IShoppingUserProfile.IRequest"
    },
    "responseBody": {
      "description": "Paginated, filtered list of user profile summaries.",
      "typeName": "IPageIShoppingUserProfile.ISummary"
    },
    "path": "/shopping/userProfiles",
    "method": "patch"
  },
  {
    "specification": "Retrieve a specific user profile record by its unique identifier. Operates on the 'user_profiles' table and is used by admin, compliance, and analytics services to view, review, or update individual profile detail. Ensures privacy protection by masking or excluding any sensitive data as dictated by business logic and regulatory standards.",
    "description": "Fetches complete details for a user profile given its UUID, linking back to the related user and locale where needed. Access is restricted by permission (e.g., only profile owners or administrators may view), and every access event is recorded in compliance logs. The result set includes all user profile atomic fields—user_id, locale_id, names, avatar_url, timezone, bio, and accessibility prefs—along with created_at and updated_at timestamps.\n\nNo authentication or credential material is ever exported. Attempts to retrieve non-existent records or without suitable permissions will be clearly logged and a compliant error status returned. Supports downstream integrations such as user onboarding, accessibility testing, and analytics/journey mapping workflows.",
    "summary": "Retrieve a specific user profile record (user_profiles table).",
    "parameters": [
      {
        "name": "id",
        "description": "Unique identifier for the user profile (UUID).",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Full user profile object for the specified record.",
      "typeName": "IShoppingUserProfile"
    },
    "path": "/shopping/userProfiles/{id}",
    "method": "get"
  },
  {
    "specification": "Create a new user profile attached to a user account. This operation is based on 'user_profiles' and accepts all required and optional profile attributes, enforcing 3NF separation from credentials and supporting accessibility/compliance configurations. Ensures audit and evidence requirements are met, with all events logged.",
    "description": "Allows for creation of a user profile by providing all necessary and optional details—user_id, locale, full_name, avatar_url, timezone, and accessibility preferences. Profile creation is only permitted by authorized entities (such as a completed user registration flow or admin onboarding). All operations are traceable for compliance and evidence retention purposes through audit logging.\n\nAny errors due to permission, uniqueness, or missing required fields are reported in accordance with operational and regulatory needs. On success, the API returns the full user profile object, ready for downstream integrations such as user personalization, analytics, or accessibility configuration.",
    "summary": "Create a new user profile (user_profiles table).",
    "parameters": [],
    "requestBody": {
      "description": "User profile details for registration or admin onboarding.",
      "typeName": "IShoppingUserProfile.ICreate"
    },
    "responseBody": {
      "description": "The created user profile record with all allowed attributes.",
      "typeName": "IShoppingUserProfile"
    },
    "path": "/shopping/userProfiles",
    "method": "post"
  },
  {
    "specification": "Update an existing user profile, referenced by its unique identifier. This endpoint alters attributes like full name, avatar, locale, bio, timezone, or accessibility settings, based on the 'user_profiles' table. All updates must be fully audit-logged and check RBAC and privacy policies for allowed modifications.",
    "description": "Updates a specified user profile by UUID, accepting new/modified attributes (all allowed per schema), enforcing validation for uniqueness and format where required (e.g., locale_id, avatar_url URI pattern, a11y_prefs schema). Only owning user or privileged admin clients may update. Any changes are strictly tracked by updates in audit_log/access_log for compliance.\n\nProfile changes trigger further workflows, e.g., update to personalization pipelines, localization settings, or accessibility-focused business logic. Errors are handled and returned in alignment with compliance and operational reporting policies.",
    "summary": "Update the details of a specific user profile (user_profiles table).",
    "parameters": [
      {
        "name": "id",
        "description": "Unique identifier of the user profile (UUID).",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": {
      "description": "Attributes to update on the existing user profile.",
      "typeName": "IShoppingUserProfile.IUpdate"
    },
    "responseBody": {
      "description": "The updated user profile record with all allowable changes applied.",
      "typeName": "IShoppingUserProfile"
    },
    "path": "/shopping/userProfiles/{id}",
    "method": "put"
  },
  {
    "specification": "Delete (soft-delete/deactivate) a user profile by unique identifier. Implements evidence preservation, audit, and regulatory compliance required by the 'user_profiles' entity comments in the Prisma schema. Deletion is typically a soft-remove (recording a deleted_at timestamp). Only RBAC-authorized clients may invoke this operation.",
    "description": "Soft-deletes or deactivates a user profile by UUID—implemented as setting a deleted_at or equivalent marker in the profile record (hard delete only allowed by separate audit strategy). Attempts to remove or deactivate profiles are fully audit-logged and validated against RBAC and privacy boundaries.\n\nThis operation is used for compliance with right-to-erasure, profile churn reporting, regulatory export, and legal holds. Attempts to delete non-existent or unauthorized records return a compliant error structure. The operation may cascade to disable accessibility preferences or user engagement features at the business logic level.",
    "summary": "Soft-delete (deactivate) a user profile by ID (user_profiles table).",
    "parameters": [
      {
        "name": "id",
        "description": "UUID of the user profile to be soft-deleted/deactivated.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Confirmation of user profile soft-delete with updated profile object/status.",
      "typeName": "IShoppingUserProfile"
    },
    "path": "/shopping/userProfiles/{id}",
    "method": "delete"
  },
  {
    "specification": "List/search organizations with advanced filtering (name, code, created dates) and pagination. Operates on the 'organizations' table in the Prisma schema. Supports admin and compliance flows to review, audit, and manage organizations including B2B contexts.",
    "description": "This API endpoint lists organizations, supporting search and filtering by name, code, or creation date, as well as pagination options for large result sets. Returns non-sensitive attributes only (name, code, timestamps) for each organization. Only authorized users (admins, compliance officers) can access this endpoint, and all query events are audit-logged for regulatory purposes.\n\nSupports direct integration into organization onboarding automation, compliance review workflows, and partner management dashboards. The API is ready for future extension to support advanced filters (e.g., by associated users, active campaigns) and API batch operations. Any unauthorized, invalid, or unprocessable requests yield standardized audit/error responses.",
    "summary": "Retrieve a paginated list of organizations with search and filtering (organizations table).",
    "parameters": [],
    "requestBody": {
      "description": "Search and pagination parameters for organization list retrieval.",
      "typeName": "IShoppingOrganization.IRequest"
    },
    "responseBody": {
      "description": "Paginated organization summary list.",
      "typeName": "IPageIShoppingOrganization.ISummary"
    },
    "path": "/shopping/organizations",
    "method": "patch"
  },
  {
    "specification": "Retrieve details of a specific organization by its unique identifier. This is a direct retrieval operation on the 'organizations' table, used for viewing, auditing, or managing details for a given business entity. All system audits and compliance rules are enforced, with access control to limit details to authorized parties only.",
    "description": "Fetches full detail for one organization, corresponding to its UUID, including all non-sensitive/allowed attributes per the Prisma schema (name, code, created_at, updated_at). No confidential, compliance-bound, or contractual info is exposed via this endpoint.\n\nThis operation is used by internal dashboards, compliance reviewers, and possibly by B2B integration partners (subject to RBAC). All accesses to this endpoint are fully logged for audit and non-repudiation, with error responses returned for permission or entity existence violations. The data structure is extensible for future business fields and compliance notes/attachments.",
    "summary": "Retrieve details for a specific organization (organizations table).",
    "parameters": [
      {
        "name": "id",
        "description": "Unique identifier for an organization (UUID).",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Detailed organization object with all allowed fields (non-sensitive only).",
      "typeName": "IShoppingOrganization"
    },
    "path": "/shopping/organizations/{id}",
    "method": "get"
  },
  {
    "specification": "Create a new organization entity in the Core module. This operation registers a new business or retailer organization, as required for multi-tenancy and B2B scenarios. It ensures that the organization name and code are unique system-wide, and supports future extensibility for B2B, partner, and omnichannel integrations. The organization's metadata, such as display/legal name and code, must be validated for uniqueness to prevent duplicate entries and support 3NF normalization. The request must contain the necessary details to create a new organization. This operation is associated with the 'organizations' table in the Prisma schema.",
    "description": "This API endpoint is used to create a new organization within the shopping platform. The creation process includes validation of the organization name and code for uniqueness to comply with multi-tenancy and B2B requirements, as described in the database schema. The organization entity is crucial for providing logical boundaries for retailers, partners, or business users, and enables proper data segregation for scalability and compliance.\n\nSecurity measures ensure that only authorized administrators can create organizations. This operation enforces data integrity by requiring essential organization details and returning a conflict error if the organization name or code is already in use. On successful creation, the complete organization record is returned for immediate downstream use (such as assigning roles or users). Audit logging must capture the creation event for compliance and evidence preservation.\n\nThis operation is foundational for entities that reference organizations, such as users and roles, and must be available before onboarding new users or managing associated entities. Errors are handled gracefully, providing meaningful messages for data validation or permission issues.",
    "summary": "Create a new organization (Core/organizations table).",
    "parameters": [],
    "requestBody": {
      "description": "Information required to create a new organization.",
      "typeName": "IShoppingOrganization.ICreate"
    },
    "responseBody": {
      "description": "Newly created organization entity.",
      "typeName": "IShoppingOrganization"
    },
    "path": "/shopping/organizations",
    "method": "post"
  },
  {
    "specification": "Update an existing organization entity in the Core module. This operation allows modification of organization metadata such as name and code, while maintaining uniqueness and data integrity. It is directly associated with the 'organizations' table in the Prisma schema. The organization may be updated to reflect business changes, such as a name change or code update, and must enforce uniqueness and audit logging.",
    "description": "This API endpoint is designed for updating an existing organization's details by its unique identifier. The operation validates that the given organization exists and that the new name or code do not conflict with other entries (uniqueness enforcement). Only authorized administrators are permitted to perform this action, in line with compliance and audit requirements of the platform.\n\nAll changes are logged for traceability and evidence preservation, ensuring that the system can reconstruct the organization's state history for regulatory or forensic purposes. The operation supports partial or full updates as specified in the request, applying normalization rules and 3NF compliance by only allowing direct fields to be updated.\n\nThis endpoint should be used for scenarios such as legal/business renaming or restructuring. Related entities (users, roles, etc.) remain unaffected except where enforcement of organization-level uniqueness is vital. Error handling includes not found, conflict, and permission errors.",
    "summary": "Update an existing organization by ID (Core/organizations table).",
    "parameters": [
      {
        "name": "id",
        "description": "Target organization's unique identifier (UUID).",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": {
      "description": "Information to update the organization.",
      "typeName": "IShoppingOrganization.IUpdate"
    },
    "responseBody": {
      "description": "Updated organization entity.",
      "typeName": "IShoppingOrganization"
    },
    "path": "/shopping/organizations/{id}",
    "method": "put"
  },
  {
    "specification": "Delete (soft-delete) an organization entity in the Core module. The organization is identified by its unique ID. Associated users and roles are handled through cascading rules. Deletion is implemented as a soft delete for evidence preservation and compliance. This operation is associated with the 'organizations' table in the Prisma schema.",
    "description": "This API endpoint allows for the (soft) deletion of an organization entity using its unique identifier. Soft deletion is required by compliance rules and preserves the record for audit or forensic purposes (updates the deletion timestamp rather than removing the row).\n\nBefore proceeding, the system validates that the organization exists and that the requesting user has the appropriate privileges for this action. After marking the organization as deleted, the system initiates cascading effects, such as disabling users/roles linked to the deleted organization, according to the platform's rules.\n\nAll deletion actions are logged for regulatory compliance and evidence preservation. The deletion operation does not physically remove the record from the database; instead, it marks the record, and downstream consumers are expected to filter based on the deletion timestamp. Errors include not found, permission denied, and dependency violation.",
    "summary": "Soft-delete an organization by ID (Core/organizations table).",
    "parameters": [
      {
        "name": "id",
        "description": "Unique identifier (UUID) of the organization to be deleted.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Deleted (soft-deleted) organization entity.",
      "typeName": "IShoppingOrganization"
    },
    "path": "/shopping/organizations/{id}",
    "method": "delete"
  },
  {
    "specification": "Fetch a paginated, searchable list of roles in the Core module. Supports search, sort, and advanced filtering as required for RBAC management. Associated with the 'roles' table in the Prisma schema. List retrieval supports multi-tenant extension and permission-based filtering.",
    "description": "This API endpoint provides a paginated list of roles present in the shopping system, along with search, sort, and advanced filter capabilities. It supports requirements for dynamic RBAC/ABAC, enabling administrators or authorized users to manage and analyze role assignments across organizations.\n\nSupports filtering by organization, role name, or code, and implements permission checks to ensure only eligible users retrieve sensitive RBAC data. The implementation uses efficient pagination and query optimization to support large-scale systems and multi-tenant environments. Results can be sorted and filtered according to business rules.\n\nAudit logging is used to record query activity for compliance and monitoring. This operation can be chained with user, policy, or organization APIs for advanced access management workflows. Error management includes validation, permission, and query format errors.",
    "summary": "Retrieve a paginated/searchable list of roles (Core/roles table).",
    "parameters": [],
    "requestBody": {
      "description": "Query, pagination, or filtering parameters for listing roles.",
      "typeName": "IShoppingRole.IRequest"
    },
    "responseBody": {
      "description": "Paginated result set of roles.",
      "typeName": "IPageIShoppingRole"
    },
    "path": "/shopping/roles",
    "method": "patch"
  },
  {
    "specification": "Retrieve a single role entity from the Core module by unique ID. Associated with the 'roles' table in the Prisma schema. Returns complete role metadata and is used for detailed RBAC/ABAC management.",
    "description": "This API endpoint fetches the details of a single role using its unique identifier. Used for managing advanced access, permission setting, or querying role properties. Only authorized users (administrators or RBAC-delegates) have access to this operation.\n\nAudit logging captures invocation for compliance and security monitoring, as access to role definitions is considered sensitive. The returned data includes all directly maintained properties of the role entity, enabling downstream use in UI, configuration, or further processing.\n\nError responses include not found, permission denied, or query format errors. Related APIs (such as update/delete) can be chained using the role ID. The operation does not reveal sensitive internal platform information beyond the target role entity data.",
    "summary": "Get single role details by ID (Core/roles table).",
    "parameters": [
      {
        "name": "id",
        "description": "Unique identifier (UUID) of the role.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Role entity details.",
      "typeName": "IShoppingRole"
    },
    "path": "/shopping/roles/{id}",
    "method": "get"
  },
  {
    "specification": "Create a new role entity within the Core module. Used for defining permission sets per organization. This operation directly impacts the 'roles' table in the Prisma schema. It implements the requirement for modular RBAC/ABAC and organizational role scoping. Name and code must be unique per organization.",
    "description": "This API endpoint enables system administrators to create new roles in the platform, associating each role with an organization as required for multi-tenancy and RBAC/ABAC. It validates the uniqueness of the role name and code within the organization context and enforces data normalization.\n\nThe new role's properties, such as name, code, description, and associated organization, are provided in the request body. Only privileged users can invoke this operation, in line with platform security and compliance standards. Upon successful creation, the API returns the newly registered role metadata.\n\nThis operation is a precursor to advanced user/permission assignment workflows and must be fully auditable. Error handling includes duplication (conflict), permission denied, or invalid data errors.",
    "summary": "Create a new role (Core/roles table).",
    "parameters": [],
    "requestBody": {
      "description": "Role information for creation.",
      "typeName": "IShoppingRole.ICreate"
    },
    "responseBody": {
      "description": "Newly created role entity.",
      "typeName": "IShoppingRole"
    },
    "path": "/shopping/roles",
    "method": "post"
  },
  {
    "specification": "Update an existing role entity in the Core module, identified by unique ID. Directly linked to the 'roles' Prisma table. Implements changing role metadata, such as name, code, or description, with per-organization uniqueness enforcement and auditable changes.",
    "description": "This API endpoint allows for updating the properties of a role entity using its unique identifier. Supported fields are name, code, description, and organization association. Updates are validated for uniqueness within the organization to avoid conflicts and maintain compliance.\n\nOnly users with appropriate administrative permissions are allowed to perform updates, as this affects RBAC/ABAC definitions and platform integrity. All modifications are audited and logged for evidence preservation. The operation must not allow changes to immutable fields, such as the primary key. Updates are atomic, and the resulting entity is returned.\n\nUse cases include role renaming, reclassification, or scope modification for evolving security or business needs. Errors returned include not found, conflict, or permission denial.",
    "summary": "Update a role by ID (Core/roles table).",
    "parameters": [
      {
        "name": "id",
        "description": "Unique identifier (UUID) of the role to be updated.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": {
      "description": "Role properties to update.",
      "typeName": "IShoppingRole.IUpdate"
    },
    "responseBody": {
      "description": "Updated role entity.",
      "typeName": "IShoppingRole"
    },
    "path": "/shopping/roles/{id}",
    "method": "put"
  },
  {
    "specification": "Soft-delete a role entity in the Core module by unique ID. The associated Prisma schema is 'roles'. This action disables the role for assignment and preserves the entity for audit and compliance purposes. Cascading impacts on user/permission assignments must be handled according to organizational business logic.",
    "description": "This API endpoint marks a role entity as deleted (soft deletion) based on its unique identifier. The soft delete updates the relevant field (e.g., deletion timestamp or status) rather than physically removing the entity, as required by evidence preservation and regulatory compliance.\n\nThe system enforces appropriate authorization prior to deleting a role, especially because role deletion may impact access and RBAC/ABAC logic for users in the organization. All operations are audited, and cascaded changes (such as revoking from users or permissions) are managed according to platform policies.\n\nThe request logs the event for compliance, preserves the deleted record for future audit, and filters deleted roles from normal queries. Errors managed include entity not found, permission denied, or dependency/assignment conflicts.",
    "summary": "Soft-delete a role by ID (Core/roles table).",
    "parameters": [
      {
        "name": "id",
        "description": "Unique identifier (UUID) of the role to delete.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Soft-deleted role entity.",
      "typeName": "IShoppingRole"
    },
    "path": "/shopping/roles/{id}",
    "method": "delete"
  },
  {
    "specification": "Fetch a paginated, filterable list of sessions from the Core module (user authentication/session management). The request supports complex queries (filtering by user, session status, expiration) for compliance and forensic purposes. Linked to the 'sessions' table in the Prisma schema.",
    "description": "This API endpoint is used to retrieve a filtered, paginated list of session entities within the platform. Sessions represent authentication events and carry critical compliance, security, and access data. The endpoint supports filter criteria such as user ID, status (active, expired, revoked), or device fingerprint, satisfying requirements for session management and compliance investigations.\n\nAccess is restricted to privileged administrators or compliance officers, and requests are fully audited for evidence preservation. Supports advanced scenarios such as forensic analysis, suspicious activity review, or user access debugging. The listing supports efficient pagination and can be sorted as required by operational needs.\n\nThis list operation may be paired with session detail or revocation APIs for advanced access flows. Errors include query parameter validation and permission issues.",
    "summary": "Retrieve a paginated/filterable list of sessions (Core/sessions table).",
    "parameters": [],
    "requestBody": {
      "description": "Request body for pagination and session filtering criteria.",
      "typeName": "IShoppingSession.IRequest"
    },
    "responseBody": {
      "description": "Paginated result set of session entities.",
      "typeName": "IPageIShoppingSession"
    },
    "path": "/shopping/sessions",
    "method": "patch"
  },
  {
    "specification": "Retrieve detailed information about a specific session in the Core module, identified by session ID. Returns all session attributes and metadata for audit, compliance, and operational needs. Uses the 'sessions' table in the Prisma schema.",
    "description": "This API endpoint returns the details of a specific session using its unique identifier. The returned session entity contains all metadata fields, such as token, expiration, user, device fingerprint, and timestamps. Used primarily by administrators or compliance staff during access management, forensic investigations, or user support operations.\n\nSensitive information is only returned to authorized users, in line with security and privacy best practices. Each access is logged for audit/evidence; repeated access may trigger operational alerts.\n\nErrors handled include session not found, permission denied, or invalid identifier format. This operation enables downstream session revocation, extension, or activity logging as part of compliance operations.",
    "summary": "Get session details by ID (Core/sessions table).",
    "parameters": [
      {
        "name": "id",
        "description": "Unique identifier (UUID) of session.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Detailed session entity information.",
      "typeName": "IShoppingSession"
    },
    "path": "/shopping/sessions/{id}",
    "method": "get"
  },
  {
    "specification": "Create a new session entity in the Core module, tracking logins/authentication events. The session is associated with a user and contains metadata such as token, expiration, and device info. Associated with the 'sessions' table in the Prisma schema. Returns the newly created session attributes and metadata.",
    "description": "This API endpoint is responsible for creating a new session for an authenticated user, supporting the system's authentication and access management flows. The session includes data such as the user ID, session token, expiration, device fingerprint, and IP address, as required for audit, compliance, and advanced security/fraud workflows.\n\nThe session creation process may involve additional security checks (MFA, adaptive authentication, device fingerprint analysis), in accordance with RBAC/ABAC rules. Only authenticated users or token authentication services are authorized to invoke this endpoint. Upon successful creation, the session entity (minus sensitive credential data) is returned.\n\nAudit logging, evidence preservation, and compliance policies are enforced. Error cases include duplication, invalid user/token, or denied creation due to security policy.",
    "summary": "Create a new session (Core/sessions table).",
    "parameters": [],
    "requestBody": {
      "description": "New session information (user, device, expiration token, etc.).",
      "typeName": "IShoppingSession.ICreate"
    },
    "responseBody": {
      "description": "Newly created session entity.",
      "typeName": "IShoppingSession"
    },
    "path": "/shopping/sessions",
    "method": "post"
  },
  {
    "specification": "Update an existing session in the Core module by unique ID. Used for session extension, attribute update, or security information refresh. The session is located via its unique identifier in the 'sessions' schema table.",
    "description": "This API endpoint enables administrators, compliance tools, or security systems to update an existing session by its unique identifier. Updates may include extension of expiration, change of device fingerprint, revocation, or other metadata necessary for ongoing security management. All modifications are subject to strict permission checks.\n\nOperations are audit-logged, and updates must not compromise session token security, e.g., session tokens themselves should not be alterable post-creation. Appropriate validation is required to prevent conflict and maintain integrity.\n\nUse cases include extending session duration, changing device association, or forcibly revoking sessions in case of suspicious activity. Error handling includes not found, validation, or permission issues.",
    "summary": "Update a session by ID (Core/sessions table).",
    "parameters": [
      {
        "name": "id",
        "description": "Unique identifier (UUID) of the session to be updated.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": {
      "description": "Update information for the session entity.",
      "typeName": "IShoppingSession.IUpdate"
    },
    "responseBody": {
      "description": "Updated session entity.",
      "typeName": "IShoppingSession"
    },
    "path": "/shopping/sessions/{id}",
    "method": "put"
  },
  {
    "specification": "Delete a user session by its unique ID. This operation is used to forcibly revoke or invalidate an active session for compliance, user-requested logout, or security reasons. The operation ensures evidence preservation by soft-deleting the session record, updating the 'revoked_at' timestamp instead of permanent deletion, and capturing an access log entry if needed. It is critical for enforcing security policies, responding to account compromise, or processing GDPR 'right to log out' requests. This API is closely related to session management and access logging, and should be audit logged by default. Only privileged users or the session owner can call this endpoint. The underlying Prisma table is 'sessions'.",
    "description": "This endpoint allows an authorized actor (admin or the session owner) to forcibly terminate a specific session identified by its unique UUID. Terminating the session sets the 'revoked_at' timestamp, rendering the session token invalid for future authentication attempts. This aligns with both regulatory and practical requirements for session invalidation, supporting use cases such as security breaches, user-requested global logouts, and compliance-driven session control (GDPR/CCPA). \n\nOperation is non-destructive (soft-delete); the session data is retained for evidence, audit, and potential dispute resolution. Every session deletion should generate a corresponding access log entry, documenting the action and actor. \n\nRelevant validation includes checking for session ownership (matching user or admin privileges) and verifying that the session is active before attempting revocation. If the operation is performed by an admin, additional audit information should be recorded. If the session is already revoked, the endpoint should respond with idempotent success.\n\nRelated endpoints include POST for login/session creation, GET for session retrieval, and PATCH for session searches/audits.\n\nError responses include 404 (session not found), 403 (not allowed), and 409 (already revoked).\n",
    "summary": "Delete (revoke) a session in the sessions Prisma table by ID.",
    "parameters": [
      {
        "name": "id",
        "description": "UUID of the session to revoke (soft-delete).",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Operation result (success indication only).",
      "typeName": "IOperationResult"
    },
    "path": "/shopping/sessions/{id}",
    "method": "delete"
  },
  {
    "specification": "Search, filter, and retrieve a list of all supported locales in the system, with support for complex searching and sorting. This is designed for admin or UI clients needing structured locale choice or bulk management. The underlying Prisma table is 'locales'.",
    "description": "This endpoint returns a paginated, filterable, and sortable list of all available locales (language-region codes) supported by the platform. It is predominantly used by admin interfaces, onboarding and preference screens, or systems needing to present users with a set of language and region options.\n\nThe 'locales' table contains normalized records for every language and region code that the system supports (e.g., 'en-US', 'ko-KR'). API consumers may request searching by name, code, or partial string, and may sort by code, name, or registration order. This endpoint supports pagination for scalability and should resist timing attacks or information leakage by limiting excessive or pattern-based search access.\n\nThis operation is essential for compliance with multicultural and accessibility requirements (e.g., I18N/L10N), and for configuration of user profiles. Only admin or privileged users can perform bulk operations.\n\nRelated endpoints include GET/PUT/POST/DELETE for individual locales.\n",
    "summary": "List/search all locales from locales Prisma table (paginated/filterable).",
    "parameters": [],
    "requestBody": {
      "description": "Search, filter, pagination, and sort options for querying locales.",
      "typeName": "ILocale.IRequest"
    },
    "responseBody": {
      "description": "Page of locale entities, including pagination data and locale details.",
      "typeName": "IPageILocale"
    },
    "path": "/shopping/locales",
    "method": "patch"
  },
  {
    "specification": "Retrieve a specific locale record (language/region code entry) from the system by its unique ID. Used when displaying or managing a single locale setting in admin, onboarding, or user profile flows. The underlying Prisma table is 'locales'.",
    "description": "This endpoint returns the details for a specific locale record (e.g., 'en-US') by its unique UUID. It is typically used in administrative, onboarding, or locale management flows, where the client needs to view a full record, including code, display name, and other descriptors for a particular locale.\n\nThe operation enforces RBAC and may redact sensitive metadata depending on the caller's privileges. This endpoint is fundamental to supporting multilingual, multicultural user experiences and guarantees that every locale code is presented in a normalized, canonical fashion for UI purposes.\n\nIf locale is not found, returns 404. If unauthorized, returns 403.\n\nRelated endpoints: PATCH for search/list, PUT/POST/DELETE for management.\n",
    "summary": "Retrieve a locale entity by ID from the locales Prisma table.",
    "parameters": [
      {
        "name": "id",
        "description": "UUID of the locale to retrieve.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Full locale entity details for the given ID.",
      "typeName": "ILocale"
    },
    "path": "/shopping/locales/{id}",
    "method": "get"
  },
  {
    "specification": "Create and register a new locale in the system (admin operation). This allows addition of new supported languages/regions for multicultural and accessibility coverage. The underlying Prisma table is 'locales'.",
    "description": "This endpoint allows admin users to add a new locale (combination of language and region) to the system's supported list. It is fundamental for maintaining a multilingual/multicultural-ready application, enabling plug-in of additional locales as business expands or regulatory/compliance standards change.\n\nAll locale records should be unique by code (e.g., 'en-GB', 'es-MX') with human-friendly display names and optional metadata. The endpoint enforces uniqueness and may trigger downstream flows (e.g., propagation to UI clients, cache updates, compliance workflows).\n\nValidations include syntactic and uniqueness checks for the BCP 47 locale code, appropriateness of the display name, and privilege validation for the caller. Only administrators or system-level actors should be permitted to create new locales.\n\nIf a locale with the given code already exists, returns 409. Returns 400 on invalid code format.\n\nRelated endpoints: PATCH (list/search), GET/PUT/DELETE (single locale management).\n",
    "summary": "Register a new locale in the locales Prisma table.",
    "parameters": [],
    "requestBody": {
      "description": "New locale information (code, name, etc).",
      "typeName": "ILocale.ICreate"
    },
    "responseBody": {
      "description": "The created locale entity.",
      "typeName": "ILocale"
    },
    "path": "/shopping/locales",
    "method": "post"
  },
  {
    "specification": "Update an existing locale entry in the system by unique ID. Used by admins to correct or maintain supported locale options. This updates the 'locales' table.",
    "description": "This endpoint allows an administrator to update a locale record (by ID), modifying its display name, code, or associated metadata. It is required for maintenance of language-region support, legal compliance corrections, or renaming for clarity in user preference displays.\n\nThe operation should enforce BCP 47 code uniqueness, RBAC for admin privileges, and update audit trails for compliance.\n\nConflicts (e.g., duplicate code) return 409. Nonexistent ID returns 404. Unauthorized access returns 403. This endpoint is related to PATCH (list/search), POST (creation), and DELETE (removal), with special attention to update audit/evidence preservation.\n",
    "summary": "Update an existing locale by ID in the locales Prisma table.",
    "parameters": [
      {
        "name": "id",
        "description": "UUID of the locale to update.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": {
      "description": "Fields to update for the locale (name, code, etc).",
      "typeName": "ILocale.IUpdate"
    },
    "responseBody": {
      "description": "The updated locale entity.",
      "typeName": "ILocale"
    },
    "path": "/shopping/locales/{id}",
    "method": "put"
  },
  {
    "specification": "Delete a locale entry (by unique ID) from the system (admin operation). Deletes the supported locale (language/region) from system's available options. Underlying table is 'locales'.",
    "description": "This endpoint allows an administrator to remove a locale record by its UUID, typically as part of reducing supported language-region options or in compliance with regional legal changes. The deletion is logical (soft-delete for evidence preservation where required) or hard (actual row deletion) according to business logic and data retention policy tied to compliance and evidence mandates.\n\nThe operation may require privilege escalation checks (admin only) and must maintain uniqueness constraints, returning 403 if unauthorized, 404 if not found, or 409 if the locale is referenced elsewhere in a protected relationship. Deletions should always be audit logged for regulatory traceability.\n\nThis endpoint is closely related to locale creation (POST), update (PUT), and listing (PATCH).\n",
    "summary": "Delete (remove) a locale by ID from the locales Prisma table.",
    "parameters": [
      {
        "name": "id",
        "description": "UUID of the locale to delete.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Operation result/success confirmation.",
      "typeName": "IOperationResult"
    },
    "path": "/shopping/locales/{id}",
    "method": "delete"
  },
  {
    "specification": "Search, filter, and retrieve a list of all user consent records in the system. Used by administrators, compliance tools, or users to view audit trails of explicit consent granted/revoked. Supports search/filter/paginate. Table: 'consents'.",
    "description": "This endpoint returns a paginated, filterable, and optionally sorted list of user consent records relevant to privacy, data use, AI/ML training, marketing, etc. It is designed for admin audit, user review/management interfaces, or regulatory export features requiring access to a user's full consent history.\n\nThe consents table tracks every explicit user permission as unique records, retained for evidence and compliance (GDPR/CCPA, etc). This endpoint enables searching/filtering by user, type, status, or date/time and supports pagination and export. Proper RBAC is required; users can only access their own consents, admins can access all.\n\nRelated endpoints: GET/PUT/POST/DELETE for single consent operations. Error scenarios: excessive access (rate limit), not found (empty result), forbidden (RBAC violation).\n",
    "summary": "List/search all user consents (paginated/filterable) from consents Prisma table.",
    "parameters": [],
    "requestBody": {
      "description": "Search, filter, pagination, and sort options for user consents.",
      "typeName": "IConsent.IRequest"
    },
    "responseBody": {
      "description": "Paginated list of user consent records and metadata.",
      "typeName": "IPageIConsent"
    },
    "path": "/shopping/consents",
    "method": "patch"
  },
  {
    "specification": "Retrieve a specific user consent record by its unique ID. Used by compliance tools, audit flows, or user self-service to view detailed consent information. Prisma table: 'consents'.",
    "description": "This endpoint gets full details of a single consent record (e.g., AI data usage, marketing, etc) by its UUID. It is essential for audit reporting, privacy dashboard tools, or for users to view and manage their own consent settings. Returns the full consent record: what the consent covers, grant/revoke status, and relevant timestamps for regulatory exports.\n\nRBAC is enforced: users can only access their own consent records; admins can access all. This endpoint is tightly linked to PATCH (list), POST (creation), PUT (update), DELETE (revoke). 404: not found, 403: RBAC violation.\n",
    "summary": "Get a user consent record by ID from the consents Prisma table.",
    "parameters": [
      {
        "name": "id",
        "description": "UUID of the consent record to retrieve.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Full details of the consent record requested.",
      "typeName": "IConsent"
    },
    "path": "/shopping/consents/{id}",
    "method": "get"
  },
  {
    "specification": "Create a new user consent record in the system. Used for explicit user or admin-granted permissions for data use, AI/ML, marketing, etc. Underlying table: 'consents'.",
    "description": "This endpoint enables explicit creation of a consent record, typically as part of privacy onboarding, profile updates, or explicit user permission for AI/ML data use, marketing, or personalized offers. The operation creates a new record in the consents table representing user approval or grant, with enforced uniqueness by user/type for compliance.\n\nValidates that the consent type is recognized, that the specific (user, type) combination does not already exist as active, and that the actor is authorized (the user themselves or an admin). Creation is always audit-logged.\n\n401/403 if not authorized, 409 if duplicate, 400 for invalid.\n\nRelated endpoints: PATCH (list), GET (fetch single), PUT (update), DELETE (revoke).\n",
    "summary": "Create a new user consent record in the consents Prisma table.",
    "parameters": [],
    "requestBody": {
      "description": "Consent record information (user, type, grant state, etc).",
      "typeName": "IConsent.ICreate"
    },
    "responseBody": {
      "description": "The newly created consent record.",
      "typeName": "IConsent"
    },
    "path": "/shopping/consents",
    "method": "post"
  },
  {
    "specification": "Update an existing user consent record by its unique ID. Used to grant, revoke, or modify permission for a specific data type or activity. Prisma table: 'consents'.",
    "description": "This endpoint updates a specific consent record by UUID. It is used for updating the current status of an existing user consent (e.g., marking as revoked, re-granted, or modifying the category for privacy or regulatory compliance). Only the user or privileged admin can update the record.\n\nEnforces uniqueness (no duplicate user/type active records), value validation for grant/revoke, and audit-evidence preservation (record all changes). The operation is idempotent when setting an already-matching value. Privilege checks (RBAC) apply; 404 if not found, 403 if forbidden, 409 for duplicate user/type or invalid transitions.\n\nRelated endpoints: POST (create), PATCH (search/list), GET (single), DELETE (remove/revoke).\n",
    "summary": "Update a user consent record by ID in the consents Prisma table.",
    "parameters": [
      {
        "name": "id",
        "description": "UUID of the consent record to update.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": {
      "description": "Update information (grant/revoke, type, timestamps, etc).",
      "typeName": "IConsent.IUpdate"
    },
    "responseBody": {
      "description": "The updated consent record.",
      "typeName": "IConsent"
    },
    "path": "/shopping/consents/{id}",
    "method": "put"
  },
  {
    "specification": "Delete (revoke) a user consent record by ID. Used for removing permission flags (e.g., opt-out, right-to-erasure) by user/admin. Maintains evidence for compliance. Table: 'consents'.",
    "description": "This endpoint logically deletes (revokes) a user consent record by UUID. It is core to compliance with right-to-withdraw, right-to-erasure, or user-requested consent changes. The operation should not irretrievably delete the record unless required by retention policy; typically, it is a soft delete (revocation timestamp is set), preserving evidence of the original grant for audit/regulatory purposes.\n\nOnly the user or system admin may perform the revocation. RBAC, audit/evidence requirements, and non-duplication semantics all apply. 404 if not found, 403 if not authorized or not owner, 409 if already revoked. Related to PATCH/POST/PUT for listing, creation, and update of consent records.",
    "summary": "Delete (logically revoke) a user consent record by ID in the consents Prisma table.",
    "parameters": [
      {
        "name": "id",
        "description": "UUID of the consent record to revoke/delete.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Confirmation/result of revocation.",
      "typeName": "IOperationResult"
    },
    "path": "/shopping/consents/{id}",
    "method": "delete"
  },
  {
    "specification": "Search/filter/paginate user access log records (auth/events) for security and auditing. Used by admins or users for security review and regulatory reporting. Table: 'access_logs'.",
    "description": "This endpoint fetches a paginated, filtered, and optionally sorted list of access log records, which detail every authenticated or attempted session for a user or system. Used for security audits, incident response, account reviews, and regulatory compliance reporting (evidence of actions).\n\nThe 'access_logs' table preserves all evidence-grade event records, tracking user, session, IP, event type, and success/failure. The endpoint supports filtering by user, session, event type, or time, and can sort results and paginate for large data volumes.\n\nAccess control applies: users may only see their own logs; admins can query any. Results include pagination details and the list of access log records, supporting downstream compliance exports, breach investigations, or anomaly detection. Related endpoints: PATCH/GET/POST/DELETE for sessions/users.\n\nEdge/error cases: excessive queries (rate-limit), empty results (404), forbidden access (403), malformed queries (400).",
    "summary": "List/search access log records from the access_logs Prisma table (paginated/filterable).",
    "parameters": [],
    "requestBody": {
      "description": "Search/filter/paginate/sort options for querying access log records.",
      "typeName": "IAccessLog.IRequest"
    },
    "responseBody": {
      "description": "Page of access log entities and pagination metadata.",
      "typeName": "IPageIAccessLog"
    },
    "path": "/shopping/accessLogs",
    "method": "patch"
  },
  {
    "specification": "Retrieve a single access log by its ID. This operation enables audit, compliance, and security modules to query detailed information of a specific access event, including user, session, event type, IP, and success flag. The data is sourced from the 'access_logs' table. Fulfills traceability, evidence preservation, and security analytics as described in requirements. Only authorized users with auditing or security permissions may access this endpoint. It is critical for regulatory exports, forensic investigations, and operational anomaly detection. If the log does not exist, return a clear error. Edge cases (e.g., deleted user/session) must be handled gracefully.",
    "description": "This endpoint is used to retrieve a detailed access log record from the 'access_logs' Prisma DB table. The log contains audit-grade information related to a single access event, such as the user, session, IP address, browser/user agent, and the result of the event (success/failure). Access logs are immutable and provide foundational evidence for compliance, anomaly detection, and forensic audits in the shopping mall backend system.\n\nSecurity context is enforced, only users or services with explicit permission may retrieve logs due to privacy and compliance reasons. If the requested log is not found, the API must return an appropriate error message. The endpoint is referenced by security, compliance, and analytics modules for advanced incident analysis and regulatory inspection.\n\nThe 'id' parameter references the primary key of the access_logs table, which is a UUID string. All retrievals are logged themselves via the audit logging system to maintain end-to-end traceability.",
    "summary": "Get a specific shopping access log from the access_logs table by ID.",
    "parameters": [
      {
        "name": "id",
        "description": "The unique identifier (UUID) of the access log to retrieve.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Detailed information about the requested access log event.",
      "typeName": "IShoppingAccessLog"
    },
    "path": "/shopping/accessLogs/{id}",
    "method": "get"
  },
  {
    "specification": "Create a new access log record in the system. This endpoint is used for logging completed access events (login, logout, API access, etc.) in compliance with traceability, auditing, and evidence preservation standards. It targets the 'access_logs' table. The operation is typically invoked by backend subsystems, not directly by frontend clients. The request body must adhere to the IShoppingAccessLog.ICreate schema, and every submission is validated for required audit fields and referential integrity to users and sessions. Duplicate/incomplete records are rejected.",
    "description": "This endpoint allows the creation of a new access log record in the 'access_logs' table to satisfy evidence, regulatory, and security requirements. Each log includes the user and session linkage, event type, IP address, agent, success status, and precise timestamp. Log records are append-only and are never updated or deleted except as part of data retention policies. All submissions must be validated for correctness, with immediate error response if user/session relationships are invalid (e.g., non-existent user/session IDs).\n\nThis API is typically utilized internally by backend infrastructure modules, but can also support audit testing. All creations are themselves captured in the audit log, and proper API authentication is mandatory to avoid tampering of critical evidence or logs.",
    "summary": "Create a new shopping access log record in the access_logs table.",
    "parameters": [],
    "requestBody": {
      "description": "Access log information to record (user/session/event/audit data).",
      "typeName": "IShoppingAccessLog.ICreate"
    },
    "responseBody": {
      "description": "Information about the newly created access log record.",
      "typeName": "IShoppingAccessLog"
    },
    "path": "/shopping/accessLogs",
    "method": "post"
  },
  {
    "specification": "Update an existing access log record. This operation allows correction (where allowed), annotation, or evidence augmentation for a specific log entry identified by its unique ID. The target is the 'access_logs' table. Any update action must be evidential and append audit trails, following strict compliance controls. Typically, logs are immutable and only exceptional fields (such as annotations for legal review) can be updated. Reject updates that attempt to alter core evidence (user/session/event/time/IP).",
    "description": "This endpoint permits update actions on access log records within the 'access_logs' Prisma DB table to append case management annotations/evidence (e.g., legal notations, dispute markers) in compliance with regulatory requirements. Direct modification of audit/evidence fields such as user/session/event type, IP address, or timestamp is strictly prohibited to safeguard evidence preservation. Only users with administrative or legal roles may invoke this operation, and all mutations are themselves appended to the audit chain for traceability.\n\nAttempting to alter the core evidence content (non-annotation fields) must result in a clear error. The 'id' parameter refers to the primary UUID key, and the operation uses the IShoppingAccessLog.IUpdate schema for allowed updates.",
    "summary": "Update an existing shopping access log in the access_logs table by ID (audit/annotation only).",
    "parameters": [
      {
        "name": "id",
        "description": "The unique identifier (UUID) of the access log to update.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": {
      "description": "Data for allowed annotation or legal mark update on the access log.",
      "typeName": "IShoppingAccessLog.IUpdate"
    },
    "responseBody": {
      "description": "The updated access log record (possibly with appended annotation/evidence info).",
      "typeName": "IShoppingAccessLog"
    },
    "path": "/shopping/accessLogs/{id}",
    "method": "put"
  },
  {
    "specification": "Delete (soft-delete) an access log record by ID. Intended only for explicit regulatory requirements (e.g., GDPR erasure, legal hold expiration) or routine data retention policy enforcement. Target: 'access_logs' table. Deletion is logical (sets deleted_at), not physical, ensuring evidence preservation and trace. Only privileged roles may perform this action. All deletions are logged in audit chain.",
    "description": "This endpoint handles logical removal (soft delete) of an access log entry from the 'access_logs' table by the log's unique UUID. It enforces full evidence preservation and compliance requirements: the log is marked as deleted via a 'deleted_at' timestamp but retained for audit/recovery. Only users with explicit legal, compliance, or security clearance may invoke this operation, and all actions are captured in the global audit trail.\n\nPhysical deletion is prohibited except in compliance with retention policies. Attempting deletion of a non-existent log, or one already deleted, must return an appropriate error.",
    "summary": "Delete (soft delete) a shopping access log from the access_logs table by ID for regulatory/evidence compliance.",
    "parameters": [
      {
        "name": "id",
        "description": "The unique identifier (UUID) of the access log to delete.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Result of the soft-delete operation on the specified access log record.",
      "typeName": "IShoppingAccessLog"
    },
    "path": "/shopping/accessLogs/{id}",
    "method": "delete"
  },
  {
    "specification": "List and search shopping products with advanced filtering, pagination, and sorting. This aligns with product discovery, management, and analytics modules, powered by AI-driven recommendation and indexing strategies. Query parameters include category, status, tags, price range, AI metadata, and search text. Results are paginated, and support internationalization (multi-locale). The response is a paginated list of product summaries from the 'products' table.",
    "description": "This PATCH endpoint provides advanced retrieval of product records from the 'products' Prisma DB table using filtering, full-text search, sort, and pagination. The request body (IShoppingProduct.IRequest) allows clients to specify search criteria, filters for product attributes (such as categories, status, price, tags), and sorting orders (name, created_at, relevance, etc). Supports AI-powered product recommendation or personalization ranking. The response returns a paginated and de-duplicated array of product summaries for UI, search, and analytics. Appropriate permission checks are required for access.\n\nClients can leverage this endpoint for catalog search, admin management, or personalized user feeds. It supports multi-language and multi-market queries for a global shopping mall experience, and all queries themselves are subject to audit logging when invoked under privileged or bulk read contexts.",
    "summary": "List (with search, filter, pagination/sort) shopping products from the products table.",
    "parameters": [],
    "requestBody": {
      "description": "Search and filter parameters for listing shopping products.",
      "typeName": "IShoppingProduct.IRequest"
    },
    "responseBody": {
      "description": "Paginated summary information for the list of matching products.",
      "typeName": "IPageIShoppingProductSummary"
    },
    "path": "/shopping/products",
    "method": "patch"
  },
  {
    "specification": "Get a specific shopping product by its unique ID. This supports detailed view, editing, or analytics for product catalog management and AI training sources. Target: 'products' table. Returns a single full detail record or error if not found. Restricted to authorized roles/business rules for sensitive information (e.g., unpublished, draft products). All access is audit-traced for compliance.",
    "description": "This endpoint retrieves all detailed product information from the 'products' Prisma DB table for a given product UUID. It is used for product management, catalog display, analytics, and serves as a foundation for downstream AI and personalization modules. Sensitive attributes (cost, unpublished status) are restricted based on role. If no product is found, an error must be thrown. All accesses are logged for compliance and analytics, particularly when accessed by admin, AI, or integration users.",
    "summary": "Get detailed information for a given shopping product from the products table by ID.",
    "parameters": [
      {
        "name": "id",
        "description": "The unique identifier (UUID) of the product to retrieve.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Detailed product information for the requested ID.",
      "typeName": "IShoppingProduct"
    },
    "path": "/shopping/products/{id}",
    "method": "get"
  },
  {
    "specification": "Create a new shopping product record in the catalog. Target: 'products' table. Invoked by product onboarding/admin/API flows. The request body must conform to the IShoppingProduct.ICreate schema, enforce referential integrity (e.g., user, category), and must validate all product integrity rules. Upon creation, related catalog events and audit logs are triggered automatically.",
    "description": "This POST endpoint adds a product to the shopping catalog ('products' table). It enforces strong business validation and referential integrity, including creator/updater fields, tying the product to category/tags, and logging the creation event in both the catalog and audit event stream. Fails if business or referential constraints are violated (e.g., duplicate internal code, missing mandatory data). Access is controlled by product management privileges. Full detail is returned on success, enabling subsequent actions such as variant creation or media upload.",
    "summary": "Create a new shopping product in the products table (catalog).",
    "parameters": [],
    "requestBody": {
      "description": "Product registration info (all required and optional fields) to create a new shopping product.",
      "typeName": "IShoppingProduct.ICreate"
    },
    "responseBody": {
      "description": "All fields of the newly created shopping product record.",
      "typeName": "IShoppingProduct"
    },
    "path": "/shopping/products",
    "method": "post"
  },
  {
    "specification": "Update an existing shopping product by ID. Applies to 'products' table. The body schema follows IShoppingProduct.IUpdate and supports updating fields such as description, status, tags, AI metadata, and more. All updates are subject to audit logging, compliance checks, and integrity enforcement. Core identity data (product ID, creator) cannot be changed. Related catalog event logs and AI triggers fire on update.",
    "description": "This endpoint applies business or editorial updates to existing product records in the 'products' DB table. Only modifiable fields are accepted via IShoppingProduct.IUpdate body; ID and fundamental integrity fields (creator) are immutable. Each update generates a catalog event for audit/evidence, and the operation is restricted to users with relevant catalog/product management privileges. Any integrity violation causes an error with reason. All updates are themselves logged to the audit system, and may trigger downstream AI/model retraining or catalog sync events.",
    "summary": "Update (business info/metadata) for an existing shopping product in the products table by ID.",
    "parameters": [
      {
        "name": "id",
        "description": "The unique identifier (UUID) of the product to update.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": {
      "description": "The updatable new data for the product, defined in IShoppingProduct.IUpdate.",
      "typeName": "IShoppingProduct.IUpdate"
    },
    "responseBody": {
      "description": "The updated record for the product, with current metadata.",
      "typeName": "IShoppingProduct"
    },
    "path": "/shopping/products/{id}",
    "method": "put"
  },
  {
    "specification": "Delete (soft delete) a shopping product by its ID. Applies to 'products' table. Deletion is logical (sets deleted_at or status=archived), never hard delete, to preserve evidence for analytics, audit, and compliance. Deletion is restricted to high-privilege roles. All deletions trigger catalog and audit event logs, with downstream AI/model updates fired as needed.",
    "description": "This endpoint performs a soft delete of a product in the shopping catalog by product UUID via the 'products' DB table. The product is archived (status change or deleted_at set), and all evidence required for compliance and business continuity is preserved. The actual record remains for analytics, AI/model retraining, and legal traceability. This operation is allowed only to authorized users and all mutations are audit-logged. Attempting to delete an already-deleted or non-existent product returns a suitable error.",
    "summary": "Soft delete a shopping product in the products table by ID, preserving analytics and evidence.",
    "parameters": [
      {
        "name": "id",
        "description": "The unique identifier (UUID) of the product to delete.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "The result and details of the deleted (archived) product record.",
      "typeName": "IShoppingProduct"
    },
    "path": "/shopping/products/{id}",
    "method": "delete"
  },
  {
    "specification": "List and search shopping product variants with filtering, pagination, and sort. Applies to 'product_variants' table. Query by product, price, SKU, stock status, or AI metadata. Used by catalog, admin, and recommendation modules to power browsing, analytics, fulfillment, or AI flows. Returns a paginated list using the IPageIShoppingProductVariantSummary schema.",
    "description": "This PATCH endpoint provides advanced querying over the 'product_variants' database table, allowing clients to filter by product association, availability, price, SKU, and other attributes. The request body (IShoppingProductVariant.IRequest) encodes pagination, sorting, and filters. The result is a paginated summary of variants, supporting use cases like catalog exploration, fulfillment analytics, or downstream inventory/AI modules.\n\nAll operations are subject to permission auditing, and queries with high data volume or privileged contexts must be audit-logged. Search logic supports multi-market and multilingual filtering, aligning with global shopping and omnichannel requirements.",
    "summary": "List (with filters, paging, sort) shopping product variants from product_variants table.",
    "parameters": [],
    "requestBody": {
      "description": "Search/filter/pagination input for shopping product variant query.",
      "typeName": "IShoppingProductVariant.IRequest"
    },
    "responseBody": {
      "description": "Paginated summaries of matching shopping product variants.",
      "typeName": "IPageIShoppingProductVariantSummary"
    },
    "path": "/shopping/productVariants",
    "method": "patch"
  },
  {
    "specification": "Get full details for a specific shopping product variant by ID out of the 'product_variants' table. Returns all variant attributes for management, analytics, or recommendation engine input. Only available to users/services with catalog or inventory privileges. Non-existence yields an error. Access is audit-logged.",
    "description": "This endpoint retrieves the complete record for a shopping product variant by unique UUID via the 'product_variants' table. Used for catalog display, admin modification, AI training, or inventory-fulfillment inspection. Only available to authorized principals with catalog/inventory access, and all lookups are themselves audit-traced for compliance. If not found, the endpoint returns a suitable error code. Data delivered includes all atomic and relational attributes for the variant.",
    "summary": "Get detailed shopping product variant info by ID from product_variants table.",
    "parameters": [
      {
        "name": "id",
        "description": "The unique identifier (UUID) of the product variant to retrieve.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Full field details for the specified shopping product variant.",
      "typeName": "IShoppingProductVariant"
    },
    "path": "/shopping/productVariants/{id}",
    "method": "get"
  },
  {
    "specification": "Create a new product variant under an existing shopping product in the catalog. Target: 'product_variants' table. Body must conform to IShoppingProductVariant.ICreate. Enforces referential integrity (matching product_id), SKU/price validation, and triggers catalog/audit logs and possible AI/model events. Duplicates or invalid attribute combos are rejected with error. Only catalog-updating roles may call this API.",
    "description": "This endpoint creates and persists a new product variant record in the 'product_variants' DB table, strictly validating references to existing products and the uniqueness of SKU/barcode. Typical use cases include onboarding new catalog variants, inventory splits, or enabling new sales/configurable options. The provided request body must pass all integrity and business rule validation (IShoppingProductVariant.ICreate). On success, returns the complete variant record and triggers catalog update/log events as well as any downstream AI retraining or analytics as needed. Access is restricted to product/catalog managers or automated processes with suitable privileges.",
    "summary": "Create a new shopping product variant record in product_variants table (add to catalog).",
    "parameters": [],
    "requestBody": {
      "description": "Information required to create a new product variant (SKU, price, config, etc).",
      "typeName": "IShoppingProductVariant.ICreate"
    },
    "responseBody": {
      "description": "Created shopping product variant record with all normalized database fields.",
      "typeName": "IShoppingProductVariant"
    },
    "path": "/shopping/productVariants",
    "method": "post"
  },
  {
    "specification": "Update an existing product variant in the shopping mall system. This endpoint is linked to the ProductCatalog.product_variants Prisma DB table. It allows modification of a product variant's attributes, such as SKU, price, barcode, availability, and links to inventory or import feeds. Intended for system admins or catalog managers to maintain product data integrity and compliance. Only allowed for active products or with appropriate permissions. All updates are recorded for auditability and regulatory compliance. Related models: products, import_feeds, inventory. Error on invalid SKU, non-existent or deleted records, or insufficient permissions.",
    "description": "This endpoint allows an authorized admin or catalog manager to update a product variant with precise details in the 'product_variants' table. Product variants represent distinct SKUs of master products—e.g., different sizes or colors of a shoe. All fields, such as SKU, price, barcode, and availability, may be updated, but business logic ensures only atomic, non-derived updates.\n\nSecurity is enforced via role-based access/permissions. The input is validated for uniqueness of SKU, existing referenced product, and valid import feed. Invalid updates (such as to archived/deleted variants or without sufficient privileges) return errors. Full audit logs are created for each update event, meeting evidence and compliance requirements from the catalog management module.\n\nThe request body must match ShoppingProductVariant.IUpdate, with a strict contract for updated atomic fields. The response returns the full updated variant info, or descriptive error in case of failure. Relates to '/shopping/productVariants/{id}' PUT endpoint in the OpenAPI. Updates also trigger catalog events for downstream systems.",
    "summary": "Update an existing product variant in ProductCatalog.product_variants.",
    "parameters": [
      {
        "name": "id",
        "description": "Target product variant's ID",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": {
      "description": "Updated detail for the product variant record.",
      "typeName": "ShoppingProductVariant.IUpdate"
    },
    "responseBody": {
      "description": "Detailed info of the updated product variant.",
      "typeName": "ShoppingProductVariant"
    },
    "path": "/shopping/productVariants/{id}",
    "method": "put"
  },
  {
    "specification": "Delete a product variant by ID from the shopping mall system. This operation is linked to the ProductCatalog.product_variants Prisma DB table. Deletion is soft (mark as inactive) for evidence preservation. Only permissible for authorized admins when no dependencies (e.g., inventory, active cart items) exist. Related to audit, inventory, compliance, and reporting modules. Error on non-existent record, insufficient permissions, or logical integrity violation.",
    "description": "This endpoint deletes a product variant, identified by its unique UUID, from the 'product_variants' table. Physical deletion is typically not performed; instead, the variant is marked inactive for audit/compliance. All deletions are logged for evidence, in line with regulatory and catalog audit requirements.\n\nExecution is subject to checks: variant must not be part of active inventory, cart, or current order. The operation is only allowed for authorized catalog managers or system admins. Attempts to delete non-existent, already-deleted, or protected variants return an error.\n\nThe endpoint interacts with inventory, audit, catalog events, and compliance records for downstream tracking. Responses provide confirmation of deletion and updated resource status, leveraging the product variant's ID from the path parameter.",
    "summary": "Soft-delete a product variant in ProductCatalog.product_variants by ID.",
    "parameters": [
      {
        "name": "id",
        "description": "Target product variant's ID",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Deleted (inactive) product variant info.",
      "typeName": "ShoppingProductVariant"
    },
    "path": "/shopping/productVariants/{id}",
    "method": "delete"
  },
  {
    "specification": "Search and retrieve a list of product categories with advanced filtering in the shopping domain. Tightly coupled with ProductCatalog.product_categories Prisma DB table. Supports pagination, search by name, hierarchical navigation, and custom sorting for omnichannel, admin, and catalog UI. Enforces RBAC for category visibility. Result contains metadata for UI trees and audit logs for evidence. Error on invalid filters or unauthorized access.",
    "description": "This endpoint returns a paginated and/or filtered list of product categories from 'product_categories'. Categories represent taxonomy nodes used for product faces, navigation, search, and analytics. Filters include name, parent_id, and other tree-walking parameters. Category hierarchy is respected and returned where relevant.\n\nSecurity controls (role, permission) limit visibility to authorized users. Pagination and sorting parameters enable efficient UI rendering and omnichannel pipelines. All queries are efficient and produce evidence metadata for compliance/audit requirements.\n\nRelates to catalog management modules and feeds downstream operations (product onboarding, personalized UIs, analytics). Errors are raised for malformed filters, unauthorized queries, or permission issues. Response data shape is ShoppingPageShoppingProductCategory, including pagination, data, and metadata.",
    "summary": "Paged search for product categories (ProductCatalog.product_categories).",
    "parameters": [],
    "requestBody": {
      "description": "Filter/search/sort info for listing product categories.",
      "typeName": "ShoppingProductCategory.IRequest"
    },
    "responseBody": {
      "description": "Paginated list of product categories.",
      "typeName": "ShoppingPageShoppingProductCategory"
    },
    "path": "/shopping/productCategories",
    "method": "patch"
  },
  {
    "specification": "Get a single product category by ID for shopping mall taxonomy management. Direct mapping to ProductCatalog.product_categories Prisma table. Used for editing, UI display, detail modal, or evidence. Category returned with all metadata but no related tree or products. Permissions/RBAC enforced. Error on missing/deleted categories.",
    "description": "This endpoint retrieves a single product category specified by its UUID from 'product_categories'. Used for admin or catalog UI when editing categories or showing details. Only authorized roles can access. No linked categories/products are returned—see tree endpoints for hierarchy.\n\nQueries are evidence-logged per catalog/audit compliance. Details like name, parent, and timestamps are provided. Attempts to access non-existent or soft-deleted categories will yield a not found error. Related to category management functions in catalog module. Path parameter 'id' is required as a UUID. Used in conjunction with category search and edit endpoints.",
    "summary": "Get a product category by ID (ProductCatalog.product_categories).",
    "parameters": [
      {
        "name": "id",
        "description": "Target product category's ID",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Details for requested product category.",
      "typeName": "ShoppingProductCategory"
    },
    "path": "/shopping/productCategories/{id}",
    "method": "get"
  },
  {
    "specification": "Create a new product category in the catalog. Associated with ProductCatalog.product_categories Prisma DB table. Used for adding new taxonomy nodes for product classification and navigation. Requires unique name, optionally parent_id for hierarchy. Permissions enforced for taxonomy management. Full audit/evidence upon creation. Related to catalog, UI, evidence, and search modules. Error on duplicate names or invalid parent.",
    "description": "This endpoint lets an authorized admin add a new product category (node) for catalog taxonomy. Inserted category must have a unique name; optionally, a parent_id links it hierarchically. Parent is checked for existence and not deleted/archived. Operation is logged for audit/compliance. All input validated strictly against ShoppingProductCategory.ICreate.\n\nInteracts with catalog, navigation, search, and analytics modules. Category creation triggers evidence records for future compliance. Duplicate, malformed, or unauthorized requests are rejected with clear errors.\n\nOn success, returns the created category details, including system-generated ID and metadata.",
    "summary": "Create new product category (ProductCatalog.product_categories).",
    "parameters": [],
    "requestBody": {
      "description": "Information for new product category record.",
      "typeName": "ShoppingProductCategory.ICreate"
    },
    "responseBody": {
      "description": "Details for the newly created product category.",
      "typeName": "ShoppingProductCategory"
    },
    "path": "/shopping/productCategories",
    "method": "post"
  },
  {
    "specification": "Update a product category by ID. Directly synchronizes to ProductCatalog.product_categories Prisma DB table. Only allowed for authorized taxonomy/catalog managers. Fields (name, parent) may be changed if constraints are met. All updates are logged for audit, evidence, and compliance. Error on duplicate/invalid names, invalid parent, or unauthorized attempt.",
    "description": "This endpoint updates a product category identified by its UUID in the 'product_categories' table. Allows changing name, parent, or other properties, subject to business rules—e.g., name must be unique, parent must exist and not loop/hide chains.\n\nFull RBAC and permission enforcement for admins. All update attempts are logged and trigger evidence snapshotting for compliance/audit/digital signatures. Attempts to update deleted, non-existent, or locked categories result in error. Data input validated against ShoppingProductCategory.IUpdate.\n\nResponse includes the updated category with all data and status fields. Related to catalog management, taxonomy UI, and compliance modules.",
    "summary": "Update a product category by ID (ProductCatalog.product_categories).",
    "parameters": [
      {
        "name": "id",
        "description": "Target product category's ID",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": {
      "description": "Updated fields for product category record.",
      "typeName": "ShoppingProductCategory.IUpdate"
    },
    "responseBody": {
      "description": "Details for updated product category.",
      "typeName": "ShoppingProductCategory"
    },
    "path": "/shopping/productCategories/{id}",
    "method": "put"
  },
  {
    "specification": "Delete a product category by ID. Performs a soft-delete for evidence/audit preservation and referential integrity. ProductCatalog.product_categories as source. Can only be performed by authorized admins. Deletion must not break product/category relationships or hide connected products. All deletions recorded for compliance. Error on attempting to delete protected, non-existent, or linked categories.",
    "description": "This endpoint performs a soft-deletion on a product category specified by UUID in 'product_categories'. Physical deletion is not performed to ensure evidence, audit, and compliance (see catalog/audit/evidence requirements). RBAC, referential integrity, and business rules enforced.\n\nAdmins/catalog managers may only delete categories unlinked from products or protected trees. All attempts are logged in audit and evidence modules. Tries to delete non-existent, protected, or already-deleted categories return errors.\n\nResponse provides status and the (now inactive/archived) category. Related to taxonomy, catalog, compliance, and audit modules.",
    "summary": "Soft-delete a product category by ID (ProductCatalog.product_categories).",
    "parameters": [
      {
        "name": "id",
        "description": "Target product category's ID",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Deleted (soft) product category info.",
      "typeName": "ShoppingProductCategory"
    },
    "path": "/shopping/productCategories/{id}",
    "method": "delete"
  },
  {
    "specification": "List and search product options for catalog setup, editing, or integration. Maps to ProductCatalog.product_options table. Supports search, pagination, and sorting by type or value. Permissions enforced for edit, catalog, and data sync. Used by admin/catalog UIs and product onboarding. Error on invalid params or unauthorized access.",
    "description": "This endpoint searches and retrieves a paginated list of product options, which are atomic attributes assignable to product variants (such as size, color). Data is returned from the 'product_options' table, with filters for option_type and value. Used for admin or onboarding UI for specifying available choices during variant configuration.\n\nSecurity enforced per RBAC/policy. All accesses and filters are logged for evidence/audit. Paging and sorting parameters available. Inputs/outputs validated for search/sort contract (ShoppingPageShoppingProductOption/ShoppingProductOption.IRequest).\n\nErrors for unauthorized, malformed, or failed search attempts are included in the response. Integrates with catalog, onboarding, and analytics modules.",
    "summary": "Paged listing and search for product options (ProductCatalog.product_options).",
    "parameters": [],
    "requestBody": {
      "description": "Filter/search/sort info for product option list.",
      "typeName": "ShoppingProductOption.IRequest"
    },
    "responseBody": {
      "description": "Paginated list of product options.",
      "typeName": "ShoppingPageShoppingProductOption"
    },
    "path": "/shopping/productOptions",
    "method": "patch"
  },
  {
    "specification": "Get the detail for a specific product option by its ID. Syncs with ProductCatalog.product_options table. Used for UI editing, onboarding, and completeness checks. Only available to catalog managers/admins. Permission and referential checks enforced. Error on non-existent/removed option.",
    "description": "This endpoint fetches the detail for a product option, which is a specific attribute assignable to product variants (e.g., 'Color: Red'). The option is accessed from the 'product_options' table by its UUID. Option metadata (type, value, linked product) are returned for admin/catalog UI or onboarding.\n\nFull RBAC and referential validation. Not found/non-existent/deleted options yield error. All queries logged for evidence and audit as per regulatory/compliance requirements. Returned data is compatible with ShoppingProductOption model/schema. Used with product onboarding and catalog management endpoints. Related to product_variants, onboarding, catalog UIs.",
    "summary": "Get product option detail by ID (ProductCatalog.product_options).",
    "parameters": [
      {
        "name": "id",
        "description": "Target product option's ID",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Detail for requested product option.",
      "typeName": "ShoppingProductOption"
    },
    "path": "/shopping/productOptions/{id}",
    "method": "get"
  },
  {
    "specification": "Create a new product option in the catalog domain (e.g., size, color, material). Source: ProductCatalog.product_options table. Used by admin/onboarding UI and for variant configuration flows. Requires required fields (product, type, value). Permissions and referential check to source product. All creations logged for evidence, audit, and compliance. Error on duplicates, invalid product, or unauthorized use.",
    "description": "This endpoint allows an authorized admin to create a new product option for a specified product in the 'product_options' table. Used to define atomic choices (like 'color: blue'). Input must specify parent product, type, value and be unique per product/option pair. Validation enforces product existence.\n\nAll creation events are logged for audit/compliance/evidentiary tracing. Attempts with invalid product, duplicate options, or missing fields are rejected and registered in audit logs. Response data includes full created option record.\n\nIntegrates with catalog and onboarding UIs, variant/option config flows, analytics, and evidence modules.",
    "summary": "Create new product option (ProductCatalog.product_options).",
    "parameters": [],
    "requestBody": {
      "description": "Detail of new product option to create.",
      "typeName": "ShoppingProductOption.ICreate"
    },
    "responseBody": {
      "description": "Detailed info of the created product option.",
      "typeName": "ShoppingProductOption"
    },
    "path": "/shopping/productOptions",
    "method": "post"
  },
  {
    "specification": "Update a product option by ID in the catalog. Mapped to ProductCatalog.product_options. Alterations to type/value/parent product possible under strict validation. Used for onboarding/admin UIs to maintain atomic, consistent variant configs. Permission and referential validation required. Audit/evidence for every change. Error on invalid option, permission, or business rule violation.",
    "description": "This endpoint modifies an existing product option record in the 'product_options' table using its UUID as a path parameter. Allows editing attributes such as type, value, and parent product, under strict business rules (uniqueness, referential integrity). Role-based access controls apply, restricting change attempts to catalog admins/onboarders.\n\nAll successful/failed edits are logged for audit/evidence compliance. Errors for not-found, permission, or constraint issues are descriptive. Contracts are defined by ShoppingProductOption.IUpdate/ShoppingProductOption models. Used for onboarding and catalog management UIs and workflows. Interacts with product_variants and analytics modules for evidence and impact analysis.",
    "summary": "Update product option by ID (ProductCatalog.product_options).",
    "parameters": [
      {
        "name": "id",
        "description": "Target product option's ID",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": {
      "description": "Updated detail for product option record.",
      "typeName": "ShoppingProductOption.IUpdate"
    },
    "responseBody": {
      "description": "Detail of the updated product option.",
      "typeName": "ShoppingProductOption"
    },
    "path": "/shopping/productOptions/{id}",
    "method": "put"
  },
  {
    "specification": "Delete a product option by ID from catalog. Maps to ProductCatalog.product_options table. Only catalog admins/onboarders may perform, with checks for options in use in variants/orders. Deletion is soft for evidence preservation. Logs all operations to compliance/audit. Error on not-found, in-use, or permission issues.",
    "description": "This endpoint permits deletion (soft-deletion) of a product option, identified by its UUID, in the 'product_options' table. Used by catalog admins to remove outdated/redundant options, only if not referenced by product_variants. Checks ensure option is not used by any active records.\n\nAll deletions are logged for evidence/compliance (not physically removed). Forbidden for options in use, non-existent, or without permission. Used in catalog onboarding, variant config, analytics, and evidence modules. Response is the (now inactive) option record.",
    "summary": "Delete (soft-delete) product option by ID (ProductCatalog.product_options).",
    "parameters": [
      {
        "name": "id",
        "description": "Target product option's ID",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Deleted (inactive) product option info.",
      "typeName": "ShoppingProductOption"
    },
    "path": "/shopping/productOptions/{id}",
    "method": "delete"
  },
  {
    "specification": "Implements the list operation for product tags, enabling filtered, paginated retrieval with support for search and sorting. This operation corresponds to the product_tags table and ensures efficient access for large or dynamic tag sets, supporting AI tagging workflows and compliance needs. The response carries a paginated list of tags as defined in the schema documentation.",
    "description": "This API provides a paginated, searchable, and sortable list of product tags for the shopping mall backend. It implements advanced filtering options and efficiently supports both manual and AI-generated tags, which are crucial for product discovery and analytics as outlined in the requirements. \n\nAll product tag records are stored in the product_tags table with atomic fields for value, ID, and timestamps, as defined by the Prisma DB schema. This list operation is secured according to permission scopes relevant to catalog management and tagging. Results are paginated and returned with metadata for evidence preservation, as required for AI-driven analytics and regulatory audit trails.\n\nQuery validation ensures only authorized users with catalog/search permissions can request tag lists. Audit logging is required for all list and search requests for traceability. Related to POST, PUT, DELETE, and single GET operations for tag management.",
    "summary": "List and search product tags (product_tags table).",
    "parameters": [],
    "requestBody": {
      "description": "Search, pagination, and filtering parameters for product tags.",
      "typeName": "IProductTag.IRequest"
    },
    "responseBody": {
      "description": "Paginated list of product tags with metadata.",
      "typeName": "IPageIProductTag"
    },
    "path": "/shopping/productTags",
    "method": "patch"
  },
  {
    "specification": "Implements the retrieval of a single product tag by its unique identifier from the product_tags table, as used for search, filtering, and AI-driven analytics. Allows catalog admins or automated systems to query a tag’s details, with audit compliance and evidence logging.",
    "description": "This API operation fetches a specific product tag by its ID and is critical for tag management, AI explainability, and search indexing. The product_tags table in Prisma maintains atomic fields of tag value and timestamp for each entry.\n\nSecurity checks enforce that only users with appropriate catalog management permissions can read tag details. This is necessary for curation, moderation, or evidence review as required by business logic. All access events are logged for compliance, and the response includes the tag metadata defined in the schema.",
    "summary": "Get product tag detail by ID (product_tags table).",
    "parameters": [
      {
        "name": "id",
        "description": "Unique identifier of the product tag.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Full product tag record with metadata.",
      "typeName": "IProductTag"
    },
    "path": "/shopping/productTags/{id}",
    "method": "get"
  },
  {
    "specification": "Creates a new product tag in the product_tags table, supporting manual or AI-driven taxonomy enrichment. Used for product discoverability, AI labeling, or admin tag creation. Fully auditable and permission-controlled for catalog roles.",
    "description": "This operation allows authorized users or automated AI pipelines to create a new product tag. The request body must comply with the atomic structure defined in the product_tags table in Prisma, requiring a unique tag value and optionally additional metadata.\n\nOn success, the operation creates a tag record, logs the event for evidence preservation, and returns the created tag entry. Permission checks restrict tag addition to roles with catalog or AI tag management scope. Errors with duplicates, validation failures, or insufficient permission are returned with appropriate messages.",
    "summary": "Create a product tag (product_tags table).",
    "parameters": [],
    "requestBody": {
      "description": "Required product tag information for creation.",
      "typeName": "IProductTag.ICreate"
    },
    "responseBody": {
      "description": "Created product tag record.",
      "typeName": "IProductTag"
    },
    "path": "/shopping/productTags",
    "method": "post"
  },
  {
    "specification": "Update an existing product tag in the product_tags table by its unique identifier. Used to correct, rename, or enrich tags in accordance with catalog or AI management workflows. Audit-compliant, supporting full traceability on changes.",
    "description": "Enables updating a tag value or its metadata by ID. Updates to product_tags are critical for correcting taxonomy errors or enabling dynamic, AI-driven reclassification of products for search/discovery. Implements audit-logging of before/after for compliance and evidence preservation as described in requirements.\n\nAuthorizations restrict usage to catalog admins or AI operations with update rights. The request body follows the update contract defined in the schema. Failures for non-existent tags, loss of uniqueness, or missing permissions are reported with detailed error information.",
    "summary": "Update a product tag by ID (product_tags table).",
    "parameters": [
      {
        "name": "id",
        "description": "Unique identifier of the product tag to update.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": {
      "description": "Update information for the product tag.",
      "typeName": "IProductTag.IUpdate"
    },
    "responseBody": {
      "description": "Updated product tag record.",
      "typeName": "IProductTag"
    },
    "path": "/shopping/productTags/{id}",
    "method": "put"
  },
  {
    "specification": "Delete a product tag by its identifier from the product_tags table. Supports lifecycle management, AI/automated cleanup, and evidence preservation. Physically restricts deletion if tag is referenced, as per schema rules.",
    "description": "This operation removes a product tag record by ID. It verifies cascade constraints, ensures tags are not referenced in active product relationships, and logs the deletion event for evidence and audit compliance as specified in the schema’s description.\n\nAuthorization is checked for catalog management scope or AI admin roles; all deletions are soft for evidence preservation, recording timestamp and actor. Errors for reference constraint violations or permission failures are provided with explanatory messages.\n\nThis complements create, update, and detail endpoints for full tag lifecycle control via API.",
    "summary": "Delete a product tag by ID (product_tags table).",
    "parameters": [
      {
        "name": "id",
        "description": "Unique identifier of the product tag to delete.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Result of delete operation (success, details).",
      "typeName": "ICommonDeleteResult"
    },
    "path": "/shopping/productTags/{id}",
    "method": "delete"
  },
  {
    "specification": "Implements a paginated, filterable, and searchable list operation for product media as stored in the product_media table. Enables catalog managers and automated systems to efficiently browse and manage all media assets in the shopping backend.",
    "description": "Retrieves a list of product media entries, supporting filtering by type, locale, associated product/variant, and other criteria as needed for multilingual and accessibility support. Respects catalog management permissions and logs search events for compliance. Returned records provide asset metadata and URIs as defined in the Prisma schema, supporting WCAG compliance and legal traceability.\n\nImplements pagination and optional sorting for large datasets. Extensible for future enhancements such as evidence status or media provenance. Integrates with create, update, delete, and detail operations.",
    "summary": "List/search product media (product_media table).",
    "parameters": [],
    "requestBody": {
      "description": "Search/pagination information for product media.",
      "typeName": "IProductMedia.IRequest"
    },
    "responseBody": {
      "description": "Paginated list of product media with metadata.",
      "typeName": "IPageIProductMedia"
    },
    "path": "/shopping/productMedia",
    "method": "patch"
  },
  {
    "specification": "Retrieves a single product media record by its unique identifier from the product_media table. Supports multilingual, accessibility, and evidence compliance requirements, with audit logging of all access for traceability.",
    "description": "This endpoint fetches the metadata and URI of a specific product media entry. Handles access validation, evidence preservation, and ensures returned metadata follows the schema’s accessibility and compliance requirements (alt text, type, locale).\n\nAccess logs are created for each request, with details available for legal or regulatory audits. Implements required integration with AI and catalog management systems for downstream use.",
    "summary": "Get product media detail by ID (product_media table).",
    "parameters": [
      {
        "name": "id",
        "description": "Unique identifier of the product media entry.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Product media record with all metadata.",
      "typeName": "IProductMedia"
    },
    "path": "/shopping/productMedia/{id}",
    "method": "get"
  },
  {
    "specification": "Creates a new product media entry in the product_media table, supporting upload of images, videos, or document URIs. Compliance with a11y metadata and multilingual tracking is enforced for evidence preservation.",
    "description": "This API allows catalog administrators or automated AI systems to register new product media assets (image, video, etc). The request body contains URI and metadata (type, locale, alt text) as strictly defined in the schema. On success, returns the created record and audit log entry.\n\nSecurity controls restrict creation to catalog/media managers or trusted AI enrichment agents. All actions are logged and reviewed as per compliance policies. Errors for duplicate or malformed URIs, missing fields, or lack of permission are clearly relayed. Complements list, detail, update, and delete media APIs.",
    "summary": "Create a product media asset (product_media table).",
    "parameters": [],
    "requestBody": {
      "description": "Required record information for new media.",
      "typeName": "IProductMedia.ICreate"
    },
    "responseBody": {
      "description": "Created product media metadata.",
      "typeName": "IProductMedia"
    },
    "path": "/shopping/productMedia",
    "method": "post"
  },
  {
    "specification": "Updates product media metadata in the product_media table by ID, allowing catalog admins to enrich, correct, or localize digital asset information. Ensures WCAG evidence and audit compliance for all changes.",
    "description": "Enables authorized users to update details of an existing product media entry, such as alt text, locale, or asset type, in compliance with accessibility and legal traceability requirements. Each update is atomically logged for evidence, and full audit trail is preserved as per the schema.\n\nThe input must match the schema's update structure, and security controls limit usage to catalog/media managers. Errors for invalid IDs, failed validation, or insufficient permissions are clear and actionable. Implements contract with list, detail, create, and delete endpoints for lifecycle management.",
    "summary": "Update a product media entry by ID (product_media table).",
    "parameters": [
      {
        "name": "id",
        "description": "Unique identifier of the product media entry to update.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": {
      "description": "Update information for product media entry.",
      "typeName": "IProductMedia.IUpdate"
    },
    "responseBody": {
      "description": "Updated product media record.",
      "typeName": "IProductMedia"
    },
    "path": "/shopping/productMedia/{id}",
    "method": "put"
  },
  {
    "specification": "Deletes a product media entry from the product_media table by its unique identifier, supporting catalog management evidence and regulatory lifecycle requirements. Soft delete to keep full audit evidence as required.",
    "description": "Removes a product media record by ID, ensuring that deletion retains non-repudiation evidence (via soft delete/timestamp approach). This is needed for compliance with accessibility and legal standards as explained in the schema.\n\nOnly catalog/media managers or authorized personnel may remove media. All events are logged for audit. Errors for invalid IDs, reference constraints, or denied access are detailed. This operation complements the other CRUD endpoints for product media lifecycle management.",
    "summary": "Delete a product media entry by ID (product_media table).",
    "parameters": [
      {
        "name": "id",
        "description": "Unique identifier of the product media entry to delete.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Result of delete operation (success, details).",
      "typeName": "ICommonDeleteResult"
    },
    "path": "/shopping/productMedia/{id}",
    "method": "delete"
  },
  {
    "specification": "Lists available inventory entries as stored in the inventory table for all variants, allowing paginated, filterable, and sortable results. Used for real-time availability tracking, evidence preservation, and integration with predictive stocking/AI modules.",
    "description": "Provides a paginated, searchable list of inventory entries, supporting filtering by variant, stock level, and other contextual criteria. Implements access control for catalog, operations, and AI users; all read actions are logged for regulatory and analytics evidence.\n\nResults provide current stock level, variant linkage, and modification time as normalized in the schema. Designed to support future extensions for supply chain integration or predictive alerts. Works together with inventory detail and materialized views for comprehensive AI-enabled stock management.",
    "summary": "List and search inventory entries (inventory table).",
    "parameters": [],
    "requestBody": {
      "description": "Search and pagination parameters for inventory entries.",
      "typeName": "IInventory.IRequest"
    },
    "responseBody": {
      "description": "Paginated list of inventory records.",
      "typeName": "IPageIInventory"
    },
    "path": "/shopping/inventory",
    "method": "patch"
  },
  {
    "specification": "Retrieves a single inventory record by unique identifier from the inventory table. Used in catalog, warehouse, and audit/integrity flows for real-time and AI-enabled supply management.",
    "description": "Fetches details of a specific inventory entry by its ID, enabling stock validation, audit review, and evidence preservation as required by the schema. Ensures only catalog, inventory, or analytics users with the proper scope may view individual records, with all events logged.\n\nReturns atomic record fields: variant, stock, last modified date as described in the inventory schema. Complements the inventory list endpoint.",
    "summary": "Get inventory entry detail by ID (inventory table).",
    "parameters": [
      {
        "name": "id",
        "description": "Unique identifier for the inventory record.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Atomic inventory record.",
      "typeName": "IInventory"
    },
    "path": "/shopping/inventory/{id}",
    "method": "get"
  },
  {
    "specification": "Create a new inventory record in the shopping mall backend. This operation belongs to the 'inventory' table in the Prisma schema and is responsible for inserting a new, atomic inventory record associated with a unique product variant. It enforces strict data integrity and ensures that each created inventory record tracks the current in-stock amount and its assignment to a specific product variant. The creation is evidence-preserved, with audit capability. Authorization is required; only allowed business roles may call this endpoint.",
    "description": "This API endpoint registers a new inventory entry in the 'inventory' table. It is used when a product variant requires a new stock tracking entry, such as when introducing a new SKU or restocking a previously untracked item. The endpoint ensures only one inventory record exists for each variant, and enforces referential integrity by checking the referenced product variant ID.\n\nSecurity and compliance are crucial, as creating inventory can influence order fulfillment, supply chain analytics, and fraud detection workflows. The creation action is recorded in the audit trail for non-repudiation and forensic evidence. Failure to create a properly linked record will roll back the transaction, with detailed error messages provided when business rules are violated (e.g., duplicate variant).\n\nThis creation endpoint is typically used in combination with update (PUT) and deletion (DELETE) inventory endpoints, and may be referenced during bulk import or synchronization routines.",
    "summary": "Create a new inventory record in the 'inventory' table (shopping/inventory).",
    "parameters": [],
    "requestBody": {
      "description": "Inventory creation parameters (variant, stock count, last modified date)",
      "typeName": "IShoppingInventory.ICreate"
    },
    "responseBody": {
      "description": "Created inventory record details, reflecting current stock and variant assignment.",
      "typeName": "IShoppingInventory"
    },
    "path": "/shopping/inventory",
    "method": "post"
  },
  {
    "specification": "Update an existing inventory record for a given ID. This operation modifies the row in the 'inventory' table matching the given ID, adjusting stock count or timestamps to reflect current warehouse state. It ensures audit evidence by recording the update and is only callable by authorized users.",
    "description": "This API updates a particular inventory record in the 'inventory' table, identified by its unique ID. It is used for stock adjustments (e.g., after sales, restock, or reconciliation), updating the stock quantity and 'last_modified_at' timestamp.\n\nThe operation includes stringent validation: the ID must exist, and only users with permission (such as warehouse staff, system integrations) can execute the update. All modifications are logged in the audit trail for compliance and operational investigation purposes. Business logic ensures that updates never create duplicate records and maintain referential integrity with the linked product variant.\n\nThis endpoint should be used whenever state changes occur that affect stock. Any failure, such as not finding the record, results in a clear error with no partial updates.",
    "summary": "Update an existing inventory record by ID in the 'inventory' table (shopping/inventory/{id}).",
    "parameters": [
      {
        "name": "id",
        "description": "Inventory record's unique identifier",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": {
      "description": "Inventory update parameters (updated stock count, modified date, etc.)",
      "typeName": "IShoppingInventory.IUpdate"
    },
    "responseBody": {
      "description": "Updated inventory record reflecting latest stock state.",
      "typeName": "IShoppingInventory"
    },
    "path": "/shopping/inventory/{id}",
    "method": "put"
  },
  {
    "specification": "Delete the inventory record specified by ID. This removes the record from the 'inventory' table while preserving audit evidence for compliance. Only authorized users (such as warehouse managers or admins) may perform this action.",
    "description": "This API removes an inventory record by its unique ID, marking it as deleted or physically erasing it depending on compliance policy. The operation is used for permanently decommissioning a stock record that has been retired (e.g., discontinued SKUs, error corrections). Upon deletion, a record of the action and metadata (who deleted, when, rationale if provided) is stored in the audit log for non-repudiation.\n\nThe operation will fail if the ID does not exist, or if there are dependent records that would compromise referential integrity, e.g., active orders referencing the inventory. It may leverage soft-delete or hard-delete depending on configured policy but always guarantees evidence preservation.",
    "summary": "Delete an inventory record by ID in the 'inventory' table (shopping/inventory/{id}).",
    "parameters": [
      {
        "name": "id",
        "description": "Inventory record's unique identifier to delete",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Success message or deleted inventory record reference.",
      "typeName": "IShoppingInventory.IDeleteResult"
    },
    "path": "/shopping/inventory/{id}",
    "method": "delete"
  },
  {
    "specification": "Retrieve a paginated and filterable list of import feeds. This operation provides advanced search, filtering, and sorting of import feed records from the 'import_feeds' table, supporting bulk management and analytics. It is used to monitor external catalog sources and synchronize product data.",
    "description": "This endpoint queries the 'import_feeds' table and returns a list of import feeds according to pagination, sorting, and search criteria. It is commonly used in catalog management workflows to review data integrations, monitor import statuses, and audit external catalog synchronizations.\n\nThe list can be filtered by source, status, date ranges, etc. Only authorized users (catalog managers, admins) may access this endpoint, and all access is logged. It supports large-scale operations such as bulk review, error resolution, or investigation of catalog evidence trails. Results include relevant metadata to support compliance and operational needs.",
    "summary": "List import feeds with search, pagination, and sorting from 'import_feeds' table (shopping/importFeeds).",
    "parameters": [],
    "requestBody": {
      "description": "Import feeds search, filter, pagination, and sorting parameters.",
      "typeName": "IShoppingImportFeeds.IRequest"
    },
    "responseBody": {
      "description": "Paginated result of import feed records matching the query.",
      "typeName": "IPageIShoppingImportFeeds"
    },
    "path": "/shopping/importFeeds",
    "method": "patch"
  },
  {
    "specification": "Retrieve detailed information of a single import feed by its unique ID. This reads a single row from the 'import_feeds' table and returns all its fields, including provenance information, timestamps, and source metadata.",
    "description": "This endpoint retrieves and returns a single import feed identified by its ID from the 'import_feeds' table. It is typically invoked to view or analyze the metadata and evidence of a specific external catalog import.\n\nAccess is restricted to users with catalog management or admin roles, and evidential access is logged for compliance. The returned information includes full provenance—source name, URI, import timestamp, and any linked catalog event data. Query failures are clearly reported, and referential integrity is enforced.",
    "summary": "Get details of a specific import feed (shopping/importFeeds/{id}).",
    "parameters": [
      {
        "name": "id",
        "description": "The unique identifier of the import feed to retrieve.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Import feed record with full metadata and provenance information.",
      "typeName": "IShoppingImportFeeds"
    },
    "path": "/shopping/importFeeds/{id}",
    "method": "get"
  },
  {
    "specification": "Create a new import feed record for external catalog synchronization in the 'import_feeds' table. This operation is used to register new sources for batch or real-time import of product data and evidence.",
    "description": "This endpoint registers a new row in the 'import_feeds' table. It is used to set up new data sources for product import (e.g., partner feeds, ERP connections, bulk uploads). Business rules enforce unique source URIs and provenance compliance (e.g., documenting the external source's origin).\n\nAll actions are logged for compliance, and failures due to duplication, invalid URIs, or missing required fields are reported. The creation is restricted to privileged catalog or platform managers. Use of this endpoint is typically paired with corresponding update and delete operations, and supports end-to-end auditability of import pipelines.",
    "summary": "Create a new import feed record (shopping/importFeeds).",
    "parameters": [],
    "requestBody": {
      "description": "Import feed creation parameters, including source name and URI.",
      "typeName": "IShoppingImportFeeds.ICreate"
    },
    "responseBody": {
      "description": "Created import feed record reflecting entered metadata and evidence.",
      "typeName": "IShoppingImportFeeds"
    },
    "path": "/shopping/importFeeds",
    "method": "post"
  },
  {
    "specification": "Update an existing import feed record by its unique ID in the 'import_feeds' table. Adjusts metadata or provenance details, e.g., when endpoints or credential details change, ensuring that evidence and compliance are preserved for the import pipeline.",
    "description": "This endpoint updates an existing import feed record matching the given ID. It can update metadata such as the source name, URI, or other provenance details. All changes are logged for audit and evidence, and business logic enforces unique URIs and referential integrity.\n\nThe endpoint is restricted to privileged users. Any errors, such as trying to set a duplicate URI or updating non-existent records, result in detailed errors. All updates maintain compliance with business logic and evidence preservation requirements.",
    "summary": "Update an import feed record by ID (shopping/importFeeds/{id}).",
    "parameters": [
      {
        "name": "id",
        "description": "Unique identifier of the import feed to update.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": {
      "description": "Fields to update in the import feed (name, URI, etc).",
      "typeName": "IShoppingImportFeeds.IUpdate"
    },
    "responseBody": {
      "description": "Updated import feed record reflecting new metadata or provenance.",
      "typeName": "IShoppingImportFeeds"
    },
    "path": "/shopping/importFeeds/{id}",
    "method": "put"
  },
  {
    "specification": "Delete an import feed record by unique ID from the 'import_feeds' table. This operation permanently or logically removes the record for compliance, error correction, or data hygiene. Evidence preservation is maintained by audit logging all removals.",
    "description": "This endpoint deletes an import feed record by its unique ID. It is used to decommission obsolete or erroneous import sources, maintaining a complete evidence trail by logging the removal. The operation may perform soft or hard deletes as per policy, and will fail if the record does not exist or dependencies prevent deletion (e.g., referenced by active products).\n\nOnly qualified catalog managers or admins may invoke this endpoint. All delete actions are audited, and incomplete/failed deletions are clearly reported to support regulatory compliance and operational recovery.",
    "summary": "Delete an import feed record by ID (shopping/importFeeds/{id}).",
    "parameters": [
      {
        "name": "id",
        "description": "Unique identifier of the import feed to delete.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Success confirmation or deleted record reference for audit.",
      "typeName": "IShoppingImportFeeds.IDeleteResult"
    },
    "path": "/shopping/importFeeds/{id}",
    "method": "delete"
  },
  {
    "specification": "Retrieve a paginated and filterable list of catalog events as evidence for product, variant, or import operations. Reads from the 'catalog_events' table and supports detailed audit, compliance, and analytics use cases.",
    "description": "This endpoint fetches a paginated list of catalog event records from the 'catalog_events' table. It is typically used to investigate audit trails, evidence records, and business analyst workflows concerning product, variant, or import changes.\n\nThe API allows for advanced searching, filtering (e.g., by event type, actor, time window), and sorting. Access is restricted for confidentiality, and all accesses are logged for compliance. Failure to retrieve results (e.g., invalid filters or permissions) triggers explicit error reporting, preventing accidental data leaks or audit bypass.\n\nTypically used alongside product or variant administration and evidence retrieval endpoints.",
    "summary": "List catalog events with filtering, pagination, and sorting (shopping/catalogEvents).",
    "parameters": [],
    "requestBody": {
      "description": "Search and filter options for catalog event retrieval.",
      "typeName": "IShoppingCatalogEvents.IRequest"
    },
    "responseBody": {
      "description": "Paginated catalog event entries matching filter and query.",
      "typeName": "IPageIShoppingCatalogEvents"
    },
    "path": "/shopping/catalogEvents",
    "method": "patch"
  },
  {
    "specification": "Get the details of a specific catalog event by its unique ID from the 'catalog_events' table. Returns the referenced event, including metadata (actor, type, target, description, timestamp, etc.) used for evidence and compliance reporting.",
    "description": "This endpoint reads a catalog event by its unique ID, returning all metadata for the event. It is commonly used for compliance audit, evidence validation, and operational forensics, allowing a detailed view of what changed, when, by whom, and what entities were involved.\n\nThe operation enforces access control and logs use for evidence. It provides all fields required for complete forensic or compliance reporting, matching the normalized catalog_events schema. Any failures (missing ID, lack of permissions) are returned as clear errors. This endpoint is typically paired with the catalog event listing, and may be referenced by product/variant or evidence endpoints.",
    "summary": "Get catalog event details by ID (shopping/catalogEvents/{id}).",
    "parameters": [
      {
        "name": "id",
        "description": "Catalog event's unique identifier to fetch.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Full catalog event details for evidence and compliance reporting.",
      "typeName": "IShoppingCatalogEvents"
    },
    "path": "/shopping/catalogEvents/{id}",
    "method": "get"
  },
  {
    "specification": "Create a new catalog event record, used for registering evidence/log events about product, variant, or import source changes. This records provenance, audit, and operational history in the 'catalog_events' table.",
    "description": "This endpoint creates a new row in the 'catalog_events' table, representing a singular catalog operation (creation, update, import, status change, etc.). Event attributes include event type, actor, target product/variant, description, and timestamp. Detailed audit fields support compliance with regulatory mandates and operational transparency.\n\nBusiness logic enforces atomic creation (no batch writes), referential integrity to all linked resources (product, variant, user), and logs each action for future evidence review. Authorization is mandatory; all operations are evidence-preserved and auditable.\n\nAny creation failures due to invalid references, missing fields, or unauthorized attempts produce explicit errors. This endpoint typically works alongside data mutation endpoints (product, variant, import feed) to form a complete evidence trail.",
    "summary": "Create a new catalog event record (shopping/catalogEvents).",
    "parameters": [],
    "requestBody": {
      "description": "Event creation parameters: type, actor, target entity, description, timestamp, etc.",
      "typeName": "IShoppingCatalogEvents.ICreate"
    },
    "responseBody": {
      "description": "Created catalog event record with all evidence and actor metadata.",
      "typeName": "IShoppingCatalogEvents"
    },
    "path": "/shopping/catalogEvents",
    "method": "post"
  },
  {
    "specification": "Update details of an existing catalog event by its unique ID in the 'catalog_events' table. This adjusts event metadata, description, or corrections while maintaining evidence and full audit trail compliance.",
    "description": "This endpoint updates a catalog event referenced by its unique ID, allowing for correction of metadata, clarifications in description, or evidence supplementation. The changes are logged (old and new values), and access requires compliance qualification.\n\nIf the event ID is not found or update would break referential integrity, a clear error is returned. The endpoint never allows changes to primary relationships to target entities, respecting evidence/log immutability; only description or classification may be altered. This is a specialized endpoint primarily used for compliance remediation or supplemental audit detail provision.",
    "summary": "Update catalog event details by ID (shopping/catalogEvents/{id}).",
    "parameters": [
      {
        "name": "id",
        "description": "Catalog event's unique identifier to update.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": {
      "description": "Fields to update (description, evidence, event classification etc.)",
      "typeName": "IShoppingCatalogEvents.IUpdate"
    },
    "responseBody": {
      "description": "Updated catalog event record with revised evidence or descriptive metadata.",
      "typeName": "IShoppingCatalogEvents"
    },
    "path": "/shopping/catalogEvents/{id}",
    "method": "put"
  },
  {
    "specification": "Implements the delete operation for catalog_events table, removing a specific catalog event by its unique ID. This is necessary for compliance and evidence management related to product catalog changes. Deletion is soft by business rules for audit.",
    "description": "Deletes a single catalog event identified by its unique ID. It is typically invoked by compliance or administrative users to remove erroneous or obsolete entries from the catalog_events entity. Security checks verify sufficient permissions before processing the request. Deletion is soft, meaning events are flagged as removed but retained for audit and evidence purposes. The operation logs all changes for regulatory compliance, preserving an immutable event trail. Associated catalog evidence is retained but unlinked for historic tracking. Errors such as permission denied or event not found are handled gracefully, with appropriate status codes.",
    "summary": "Delete a catalog_event identified by its ID. This relates to the ProductCatalog.catalog_events table.",
    "parameters": [
      {
        "name": "id",
        "description": "Target catalog event's unique identifier.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": null,
    "path": "/shopping/catalogEvents/{id}",
    "method": "delete"
  },
  {
    "specification": "Implements the advanced query/filter operation for catalog_evidence entities. Supports searching, filtering, and pagination of catalog evidence records for compliance and audit reporting. Related to the ProductCatalog.catalog_evidence table.",
    "description": "Retrieves a filtered and paginated list of catalog_evidence records, supporting queries such as evidence creation date, reference_uri, description, and possibly linked catalog_event. Access is restricted to administration and compliance roles. Response includes essential evidence metadata and pagination cursor/total count for UI rendering. Supports elastic search patterns for text fields and supports evidence retrieval for regulatory export. Errors include invalid query parameters or insufficient permissions, handled with proper status codes.",
    "summary": "Query and list catalog_evidence records with advanced filtering. This relates to the ProductCatalog.catalog_evidence entity.",
    "parameters": [],
    "requestBody": {
      "description": "Filter/query payload for listing catalog_evidence records.",
      "typeName": "ICatalogEvidence.IRequest"
    },
    "responseBody": {
      "description": "Paginated response with catalog_evidence records matching query.",
      "typeName": "IPageICatalogEvidence"
    },
    "path": "/shopping/catalogEvidence",
    "method": "patch"
  },
  {
    "specification": "Implements fetching a single catalog_evidence record by its primary key, for evidence review and export. Associated with auditing and regulatory evidence preservation for catalog operations.",
    "description": "Retrieves detailed information of a catalog_evidence entry identified by its unique ID. Used in compliance audits, regulatory evidence checks, and operations needing fine-grained review of event-linked evidence. Permission checks ensure only authorized users (e.g., compliance officers, auditors) can access. The returned resource includes all core metadata: reference_uri, description, created_at, catalog_event linkage. Returns 404 if the record does not exist or if access is denied. All accesses are logged for compliance purposes.",
    "summary": "Get a single catalog_evidence record by ID. This relates to the ProductCatalog.catalog_evidence entity.",
    "parameters": [
      {
        "name": "id",
        "description": "ID of the catalog_evidence record to fetch.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Detailed information of the requested catalog_evidence record.",
      "typeName": "ICatalogEvidence"
    },
    "path": "/shopping/catalogEvidence/{id}",
    "method": "get"
  },
  {
    "specification": "Implements creation of a new catalog_evidence record in the ProductCatalog.catalog_evidence table. Supports evidence addition for catalog event audit and compliance.",
    "description": "Creates a new catalog_evidence entry, storing essential references (reference_uri, description, associated catalog_event_id) for legal, audit, or operational evidence preservation. Input validation assures all required fields are present and valid, especially URIs and event linkage. On success, stores immutable record, attaches to the referenced catalog_event if supplied, and returns the created evidence entity. Permission checks restrict this operation to authorized roles (catalog admins, compliance). Errors include validation failures, permission denial, or referenced event not found.",
    "summary": "Create a new catalog_evidence record. This is for ProductCatalog.catalog_evidence entity.",
    "parameters": [],
    "requestBody": {
      "description": "Information for creating new catalog_evidence record.",
      "typeName": "ICatalogEvidence.ICreate"
    },
    "responseBody": {
      "description": "The newly created catalog_evidence entity.",
      "typeName": "ICatalogEvidence"
    },
    "path": "/shopping/catalogEvidence",
    "method": "post"
  },
  {
    "specification": "Implements updating an existing catalog_evidence entry by primary key. Attached to ProductCatalog.catalog_evidence for compliance, audit, and evidence correction flows.",
    "description": "Updates the fields (except immutable references) of a catalog_evidence record identified by its unique ID. Used for annotation, descriptive changes, or correction of auxiliary info. All changes must be logged and previous state retained for evidence preservation, ensuring compliance. Permission checks guarantee only authorized personnel (catalog admins, compliance staff) may update records. Linked event references, creation timestamps, and immutable URIs cannot be altered. Attempting to update non-existent or immutable fields, or lacking permission, is properly handled with error reporting.",
    "summary": "Update an existing catalog_evidence record by ID. This relates to ProductCatalog.catalog_evidence.",
    "parameters": [
      {
        "name": "id",
        "description": "ID of the catalog_evidence to update.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": {
      "description": "Editable fields and metadata for the catalog_evidence update.",
      "typeName": "ICatalogEvidence.IUpdate"
    },
    "responseBody": {
      "description": "The updated catalog_evidence record.",
      "typeName": "ICatalogEvidence"
    },
    "path": "/shopping/catalogEvidence/{id}",
    "method": "put"
  },
  {
    "specification": "Implements deletion (soft) of a catalog_evidence record by ID, as mandated for audit and compliance regulation. Related to ProductCatalog.catalog_evidence entity.",
    "description": "Removes a catalog_evidence record, typically by flagging as deleted for evidence preservation. Cannot physically delete for compliance; only marks as deleted and logs action for audit. Only permitted for authorized users after careful checks. Associated catalog_event relation is unlinked, and evidence is retained for historic purposes. Returns no payload; success is indicated via HTTP status. Errors include insufficient permission, record not found, or attempts to hard delete (handled by business logic).",
    "summary": "Delete a single catalog_evidence record by ID (soft delete, audit-compliant).",
    "parameters": [
      {
        "name": "id",
        "description": "ID of the catalog_evidence to be deleted.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": null,
    "path": "/shopping/catalogEvidence/{id}",
    "method": "delete"
  },
  {
    "specification": "Retrieves a filtered and paginated list of cart records for intelligent cart management and compliance audit needs. Based on CartOrder.cart entity, supports query for user/session, date ranges, etc.",
    "description": "Returns a list of cart entities with filter/search/pagination support, typically for administrative review, machine learning analysis, or active cart management. Security and permission checks restrict access to authorized staff, or return results for currently authenticated user. Core use cases include monitoring abandoned carts for recovery campaigns, analytics, and audit. Response is paginated, with essential metadata. Supplies underlying data for AI-driven recommendations.",
    "summary": "List and query cart records. This relates to CartOrder.cart entity.",
    "parameters": [],
    "requestBody": {
      "description": "Query and filter information to search/list carts.",
      "typeName": "ICart.IRequest"
    },
    "responseBody": {
      "description": "Paginated cart list response.",
      "typeName": "IPageICart"
    },
    "path": "/shopping/cart",
    "method": "patch"
  },
  {
    "specification": "Fetch a single cart record by its unique ID for retrieval, audit, or recovery. Based on CartOrder.cart entity.",
    "description": "Returns detailed information for a single cart record, including ownership, creation, update times, and associated items. Typically used for cart recovery, compliance review, or support assistance. Permission checks enforce that only the cart's owner or authorized staff may access the cart. Returns 404 if not found or unauthorized. Audit logging is performed for all access to support regulatory trace, with immutable evidence chain.",
    "summary": "Get a cart record by ID. CartOrder.cart entity.",
    "parameters": [
      {
        "name": "id",
        "description": "ID of the cart to get.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Cart entity details for the requested cart ID.",
      "typeName": "ICart"
    },
    "path": "/shopping/cart/{id}",
    "method": "get"
  },
  {
    "specification": "Implements creation of a new cart record in CartOrder.cart entity. Supports cart initialization, session-local or user-persistent cart creation flows.",
    "description": "Creates a persistent cart for a user or session, ready for item addition. Processing cross-checks that no active (undeleted) cart exists for the same user/session context. Input validation checks session and user references, timestamps, and required metadata. Permission checks prevent unauthorized creation of carts. On success, returns the newly created cart entity with all core metadata. For evidence, operation is logged, and linkage to user/session established. Errors include duplicate cart, user/session not found, or permission denied.",
    "summary": "Create and initialize a new cart. CartOrder.cart entity.",
    "parameters": [],
    "requestBody": {
      "description": "Initial information for cart creation.",
      "typeName": "ICart.ICreate"
    },
    "responseBody": {
      "description": "The newly created cart entity.",
      "typeName": "ICart"
    },
    "path": "/shopping/cart",
    "method": "post"
  },
  {
    "specification": "Updates an existing cart by its unique ID for CartOrder.cart entity. Allows updating modifiable properties, e.g., timestamps, session reassignment, deletion mark, but not owner/user. Used for recovery, compliance, or correction of cart state.",
    "description": "Updates an existing cart (by ID) with supported mutable properties: timestamps, session association, or compliance soft-delete. Change of cart owner is not permitted for security. All changes are audit-logged, with previous state tracked for evidence and compliance. Only authorized users can update their cart, and all permission checks are enforced. Errors include not found, modification forbidden, or permission denied, all with appropriate status and audit log.",
    "summary": "Update cart record by ID. CartOrder.cart entity.",
    "parameters": [
      {
        "name": "id",
        "description": "Cart ID to update.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": {
      "description": "Editable fields to modify in the cart.",
      "typeName": "ICart.IUpdate"
    },
    "responseBody": {
      "description": "Updated cart entity.",
      "typeName": "ICart"
    },
    "path": "/shopping/cart/{id}",
    "method": "put"
  },
  {
    "specification": "Implements the deletion (soft) of a cart entity by its unique ID based on CartOrder.cart. Operation is audit-logged as per compliance.",
    "description": "Deletes (flags as deleted) the cart entity specified by ID. Cannot be physically removed for evidence preservation, only soft-deleted. Permission and security checks ensure only owner or authorized staff may delete a cart. Any active items are unlinked or transitioned accordingly. Action is logged for non-repudiation (audit). Returns no payload on success, only status. Errors include not found or access denied.",
    "summary": "Delete a cart record by ID. CartOrder.cart entity.",
    "parameters": [
      {
        "name": "id",
        "description": "ID of the cart to be deleted.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": null,
    "path": "/shopping/cart/{id}",
    "method": "delete"
  },
  {
    "specification": "Provides paginated listing and advanced querying of cart_item details, related to CartOrder.cart_item entity. Used for compliance reporting, abandoned cart recovery, or machine learning analytics.",
    "description": "Returns a filtered list of cart_item records, supporting queries by product_variant_id, cart_id, date ranges, and more. Core use cases include compliance audits, analytics, and personalized marketing (AI input). Pagination and sorting metadata are included in responses. Only accessible to authorized administrative users, support staff, or the cart's owner. Permission checks are enforced. Errors include invalid query/filter, forbidden access, or no results.",
    "summary": "Query and list cart_item records. CartOrder.cart_item entity.",
    "parameters": [],
    "requestBody": {
      "description": "Query/filter details for cart_item listing.",
      "typeName": "ICartItem.IRequest"
    },
    "responseBody": {
      "description": "Page of cart_item records matching search filters.",
      "typeName": "IPageICartItem"
    },
    "path": "/shopping/cartItem",
    "method": "patch"
  },
  {
    "specification": "Retrieve a specific cart item by its unique identifier. Associated with the 'cart_item' table in the CartOrder module. This operation fetches all normalized details for a selected cart item, including quantity, variant, associated cart, and audit timestamps. Essential for displaying cart status, supporting audit, AI analysis, and business integrity.\n\nSecurity: Only accessible by authenticated user owning the cart or with proper admin permissions. Enforces row-level RBAC. Includes evidence and audit trail for compliance.\n\nThis API is typically called after listing the cart contents or as part of a detailed view for cart verification. Returns error if item doesn't exist or user context does not match.\n\nValidation: ID must exist and belong to user/session context. Handles soft-deleted logic and returns 404 if item not found or deleted.\n\nRelated operations: add, update, or remove cart item, cart status/history tracking.",
    "description": "This API fetches a single cart_item record from the normalized cart_item table, providing full detail, forensic audit timestamps, and evidence of cart state. The implementation supports strict authentication, locking to the user's own cart or privileged administrative context. All queries are audited and evidence-preserved for compliance, including rollback and dispute handling. If the cart item has been soft-deleted, a 404 is returned. Access to the endpoint is governed by strict RBAC, requiring either ownership of the cart or explicit admin rights. Related endpoints include add, update, and delete item; cart state queries; and audit/event review for the cart table.",
    "summary": "Get details for a single cart_item (CartOrder DB) by ID.",
    "parameters": [
      {
        "name": "id",
        "description": "Unique identifier for the target cart_item record.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Detailed information for a single cart_item record, including all normalized references and audit metadata.",
      "typeName": "IShoppingCartItem"
    },
    "path": "/shopping/cartItem/{id}",
    "method": "get"
  },
  {
    "specification": "Create a new cart_item record, mapping to the CartOrder 'cart_item' table. Allows authenticated users to add a specific product variant to the cart with a quantity, fully normalized for integrity, supporting multi-device and multi-session workflows. Enforces schema checks for inputs.\n\nSecurity: Accessible by authenticated users only (owns the cart/session). RBAC applies; business logic validates ownership.\n\nValidation: Checks for valid product_variant, valid quantity, and correct user/session assignment. Duplicates for the same variant in the same cart are not permitted (composite uniqueness constraint).\n\nRelated: This is the entry point for adding items to the user's shopping cart, typically triggered by UI/product catalog workflows. Also feeds into recommendation/analytics and evidence systems.",
    "description": "Creates a new cart_item instance for the current user's session or persisted cart. This endpoint enforces atomic quantity updates and unique cart/variant mapping (no duplicates per variant per cart). The data is validated against cart existence, variant validity, and session alignment. All creation events are logged for evidence/audit purposes. The record supports later updates, deletion (soft-deletion for evidence), and ties into further workflows including recommendation, checkout, and dynamic pricing analysis. The endpoint triggers related AI learning pipelines by logging usage context.",
    "summary": "Add a new cart_item (CartOrder DB) to user cart for a product variant.",
    "parameters": [],
    "requestBody": {
      "description": "Cart item creation information (cart reference, product_variant, quantity).",
      "typeName": "IShoppingCartItem.ICreate"
    },
    "responseBody": {
      "description": "The newly created cart_item record in full, with all reference and evidence attributes.",
      "typeName": "IShoppingCartItem"
    },
    "path": "/shopping/cartItem",
    "method": "post"
  },
  {
    "specification": "Update details about a specific cart_item referenced by its unique ID. Implements CartOrder.cart_item table logic for changing quantity, variant, or evidence tags. Supports AI analysis (intended for ML flow logging), as well as transactional cart integrity.\n\nSecurity: Access is authenticated and limited to the item's owner (or delegated admin). Full audit trail for changes.\n\nValidation: ID must exist, must be assigned to user/session context. Duplicates per variant/cart are forbidden. Can only update fields: quantity, or evidence metadata. Attempts to update deleted, or non-owned, item yield error.",
    "description": "Updates a cart_item record with a new quantity, metadata, or status, by ID. This operation triggers event/audit logs and is subject to RBAC (ownership or admin rights required). Sensitive to multi-device/session state; robustly prevents race conditions and enforces accuracy. If a change is rejected, a structured error details the constraint. Related end-points: get by ID, create, delete.",
    "summary": "Update specific cart_item (CartOrder DB) in user cart by ID.",
    "parameters": [
      {
        "name": "id",
        "description": "Unique identifier for the cart_item to update.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": {
      "description": "Fields to update for the cart_item, e.g. quantity, evidence.",
      "typeName": "IShoppingCartItem.IUpdate"
    },
    "responseBody": {
      "description": "The updated cart_item record after mutation, with all details and audit metadata.",
      "typeName": "IShoppingCartItem"
    },
    "path": "/shopping/cartItem/{id}",
    "method": "put"
  },
  {
    "specification": "Delete (soft-delete for audit) a cart_item entry by unique ID (CartOrder.cart_item table). Main pathway to removing a product variant from a user's persistent cart, with evidence preservation for rollback or compliance checks. Supports multi-session and race condition scenarios.\n\nSecurity: Only the resource owner (or privileged user) can perform this operation. All deletions are evidence-logged for audit and forensics.\n\nValidation: ID must exist and belong to current user. If already deleted, returns successful no-op or explicit not-found, per business policy. Prevents deleting others' items via RBAC.\n\nRelated: Used along with add/update/retrieve for full cart lifecycle. Triggers downstream update notifications and AI-recommendation signals for model retraining.",
    "description": "Marks a cart_item as deleted (soft-delete) using its unique identifier, yielding compliance and audit evidence for user action. The operation is tracked in evidence logs and triggers any downstream notifications, such as cart recalculation and personalized recommendations update. Prerequisite: item exists, belongs to current session/user, not already deleted. Related: create, update, retrieve, and view all cart items for cart/session.",
    "summary": "Soft-delete a cart_item (CartOrder DB) in user cart by ID (for audit).",
    "parameters": [
      {
        "name": "id",
        "description": "Unique identifier for the target cart_item record to delete.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Deleted (or soft-deleted) confirmation for the cart_item, including audit metadata.",
      "typeName": "IShoppingCartItem"
    },
    "path": "/shopping/cartItem/{id}",
    "method": "delete"
  },
  {
    "specification": "Retrieve a filtered, possibly paginated list of order records for the current user or admin context, from the CartOrder.order table. Implements list/search requirements using advanced query logic (pagination, sort, status filter, date range, etc.), supporting business intelligence, audit, and AI analytics. This is the main batch query for order histories.\n\nSecurity: Authenticated access only, RBAC to ensure only self/user orders visible unless admin rights granted. Evidence and audit controls for each query.\n\nValidation: Accepts advanced filter parameters (status, date, value), pagination controls (limit/offset/page), sorting directives. Errors for unauthorized, malformed, or out-of-bounds queries.\n\nRelated: Single order view, order item listing, cart/order transition state queries.",
    "description": "Fetch a paginated and filterable list of order records relevant to the requesting user, including all top-level metadata, references, and audit fields. Supports strict evidence preservation for audit and model training. Behaves as the root query for order dashboards, BI, and user account/portal order listings. Handles advanced searching, filtering, and sorting. Full query is evidence-logged and supports compliant data export. Prerequisite: authentication and RBAC for user context. Related endpoints: get order by ID, list order items, order log retrieval.",
    "summary": "List/search orders (CartOrder DB) with advanced/filtering query.",
    "parameters": [],
    "requestBody": {
      "description": "Query options (filters, pagination, sort) for order list/search.",
      "typeName": "IShoppingOrder.IRequest"
    },
    "responseBody": {
      "description": "A paginated, filtered array of order records and pagination metadata.",
      "typeName": "IPageIShoppingOrder"
    },
    "path": "/shopping/order",
    "method": "patch"
  },
  {
    "specification": "Retrieve a single order record in detail for a given order ID (CartOrder.order table). Includes all order, cart, reference, audit, and evidence fields for compliance, analytics, and user-facing detail. Implements business, legal, and AI-tracking objectives.\n\nSecurity: Only the user or privileged admin may access their order. RBAC/ownership enforced; full access logging for evidence.\n\nValidation: ID must exist and belong to user/context; errors on not-found or unauthorized. Includes evidence, event history, and all normalized fields.\n\nRelated: List orders API, order item listing, audit/event log retrieval, compliance downloads.",
    "description": "Fetch full detail for a single order record, identified by its unique ID, supporting evidence, audit, and advanced user/business logic. All result data is normalized and includes cart, references, and forensic event data where required. Strict RBAC, authentication, and query logging is enforced, ensuring regulatory and audit compliance. Soft-deleted (voided) orders return 404 or equivalent error. Used with order list/search, item list, and audit/event review endpoints.",
    "summary": "Get details for a single order (CartOrder DB) by ID.",
    "parameters": [
      {
        "name": "id",
        "description": "Unique identifier for the target order record.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Detailed normalized order record including cart, item, ref, and evidence information.",
      "typeName": "IShoppingOrder"
    },
    "path": "/shopping/order/{id}",
    "method": "get"
  },
  {
    "specification": "Create a new order in the CartOrder.order table, corresponding to a unified, transactional conversion of a user's cart. Implements strict evidence and audit controls, supports order lifecycle, and records compliance at every step.\n\nSecurity: Authenticated user, order creator only. Triggers all order validation, inventory lock, and evidence workflows. RBAC enforced.\n\nValidation: Requires cart reference, user identity, valid cart status and items (valid-product, quantity, price at point-of-sale). Handles errors for stock/unavailability, or fraud block. Audits all state transitions including AI/risk evaluation outcomes.\n\nRelated: Cart checkout, payment initiation, order item and status auditing, compliance dataflows.",
    "description": "Creates a new order record for the current user's session/cart. Handles rich validation (stock locks, payment/preauth, user checks), triggers atomic evidence and event logging for compliance, and forwards the transition to order processing. Returns full order record including status, reference, and evidence compliance field. The endpoint expects all regulatory, audit, and BI reporting hooks to be triggered. Related: single-order view, list/search, cart item and checkout integration, payment and discount flows.",
    "summary": "Create a new order (CartOrder DB) from user cart.",
    "parameters": [],
    "requestBody": {
      "description": "Order creation information (cart, user, item, payment info).",
      "typeName": "IShoppingOrder.ICreate"
    },
    "responseBody": {
      "description": "The newly created order record, including all references, state, and audit evidence.",
      "typeName": "IShoppingOrder"
    },
    "path": "/shopping/order",
    "method": "post"
  },
  {
    "specification": "Update an order record by its unique ID, supporting transactional status changes (e.g., paid, shipped, cancelled), edits to reference data (shipping address, audit tags), and regulatory evidence update in CartOrder.order table.\n\nSecurity: Only owner or privileged user allowed. All changes strictly evidence-logged and audited; RBAC enforced; triggers compliance hooks.\n\nValidation: ID must exist, user must own or be authorized for order, only allowed fields updatable. Errors surfaced for invalid transitions, unauthorized status changes, or integrity failures.\n\nRelated: Used for order management by users/admins, audit log query, compliance actions. Order log and evidence flows triggered by all mutations.",
    "description": "Updates fields of an order record including transactional state and reference data, identified by unique order ID. Ensures atomic evidence trail and compliance for business and regulatory purposes. Strict enforcement of transition validity, traceability, audit logging, and RBAC. Only mutable fields updatable (e.g., shipping address, status/mark, audit data). If operation fails, explicit error with compliance trace is returned. Related endpoints: get by ID, list/search, audit/event log, order evidence download.",
    "summary": "Update order (CartOrder DB) detail or status by ID.",
    "parameters": [
      {
        "name": "id",
        "description": "Unique identifier for the order to update.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": {
      "description": "Fields to update for the order, e.g. status, address, audit info.",
      "typeName": "IShoppingOrder.IUpdate"
    },
    "responseBody": {
      "description": "The updated order record, compliance/evidence state attached.",
      "typeName": "IShoppingOrder"
    },
    "path": "/shopping/order/{id}",
    "method": "put"
  },
  {
    "specification": "Delete (soft-delete for audit) an order record by its unique ID, with compliance, evidence preservation, and forensics. Implements CartOrder.order table requirement for voiding order, rollback, and regulatory audit.\n\nSecurity: Only the creator/owner (or admin) can void an order. All deletions are evidence-logged, with audit trail ensuring non-repudiation. RBAC enforced.\n\nValidation: Order ID must exist and be accessible to user/session context. Soft-deleted orders remain available for audit/download. Error for already deleted orders triggers no-op or regular not-found response per business rule.\n\nRelated: Used alongside creation, update, audit log/event review endpoints, compliance/forensics tools.",
    "description": "Marks an order as deleted (soft-delete) in the CartOrder.order table, for evidence, compliance, and rollback audit. Operation triggers audit logs, downstream notifications, and risk/compliance hooks. Only order owner (or privileged admin) can execute. If order not found or deleted, returns not found or explicit error. Related: create, update, get by ID, list/search, retrieve audit or evidence logs.",
    "summary": "Soft-delete a single order (CartOrder DB) by ID (evidence/audit).",
    "parameters": [
      {
        "name": "id",
        "description": "Unique identifier for the target order record for deletion.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Deleted (soft) order record with compliance and evidence attributes.",
      "typeName": "IShoppingOrder"
    },
    "path": "/shopping/order/{id}",
    "method": "delete"
  },
  {
    "specification": "Provide a filterable, paginated list of order_item records for the current user or admin, mapped to CartOrder.order_item table. Implements advanced query support for itemized analyses, order breakdown, and BI across order lines. Essential for AI learning pipelines and compliance reporting.\n\nSecurity: Access scoped to authenticated user; RBAC governs row-level access and advanced search. Evidence/audit logged per business policy.\n\nValidation: Accepts filter/query params (order, variant, status/date ranges), pagination, and sort options for large data. Ensures parent order ownership. Errors if unauthorized.\n\nRelated: Item detail, parent order query, compliance download endpoints.",
    "description": "This API provides advanced querying for order_item records, supporting analytics dashboards, itemized user order histories, and BI order breakdown reports. Implements robust evidence/audit controls per regulatory mandates, tracks query context for AI/ML workflows, and provides paginated, filtered, and sorted result sets. Related endpoints: get by ID, parent order/detail, audit logs, export/report APIs. RBAC/ownership applies strictly.",
    "summary": "List/search order_item (CartOrder DB) with filtering, pagination, and BI support.",
    "parameters": [],
    "requestBody": {
      "description": "Filter, pagination, and sort options for order_item listing.",
      "typeName": "IShoppingOrderItem.IRequest"
    },
    "responseBody": {
      "description": "A paginated, filtered array of order_item records plus pagination metadata.",
      "typeName": "IPageIShoppingOrderItem"
    },
    "path": "/shopping/orderItem",
    "method": "patch"
  },
  {
    "specification": "Retrieve detail for a single order_item record by unique ID, as stored in CartOrder.order_item table. Returns all normalized references, audit, and compliance fields for BI, user review, and legal evidence.\n\nSecurity: Only owner or privileged user can view. Implements full evidence and RBAC logic; audit-traces all queries for compliance and explainability.\n\nValidation: ID must exist and be authorized under RBAC policies. Publishes error if out of scope or non-existent.\n\nRelated: List/search order_items, parent order fetch, compliance and evidence pipelines.",
    "description": "Fetches a single order_item detail record by unique identifier, including all normalized line-item references, item/product, audit information, and supporting legal evidence for compliance (per advanced audit requirements). RBAC, evidence, and access logging enforced for each call. Used for order/reporting breakdown, ML feedback loops, and dispute management. Related: order_item list/search, audit log, parent order funnel.",
    "summary": "Get details for a single order_item (CartOrder DB) by ID.",
    "parameters": [
      {
        "name": "id",
        "description": "Unique identifier for the target order_item record.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Detailed normalized order_item record for audit/evidence/reports.",
      "typeName": "IShoppingOrderItem"
    },
    "path": "/shopping/orderItem/{id}",
    "method": "get"
  },
  {
    "specification": "Create a new order_item record, mapped to CartOrder.order_item, formally attaching a product variant to an order (normally used only in admin, repair, or advanced flows unless atomic checkout mutation allowed). Strictly normalized, triggers evidence and compliance hooks at creation.\n\nSecurity: Only privileged user or admin allowed. Must be tied to an existing order (not a user-facing endpoint in typical checkout; business managed only). Evidence/audit recorded for regulatory/legal queries.\n\nValidation: Requires valid order reference, valid product_variant, and quantity. RBAC/ownership applies; validates atomic consistency for line-items.\n\nRelated: Used for advanced order management, BI, or compliance repair; not used in normal checkout (order and items created atomically).",
    "description": "Creates a new order_item record for a specific order, tying product variants directly to an order record (not just the cart). For compliance, repair, and specialized administration or data fix-up. All inputs validated for order/ref/product linkage, atomicity, and audit compliance. RBAC applies, usually not available to end users unless business logic requires. Triggers event log/evidence flows as for all critical operations. Related endpoints: get by ID, list/search, update/delete (when supported).",
    "summary": "Create new order_item (CartOrder DB) in an order (admin/special-use).",
    "parameters": [],
    "requestBody": {
      "description": "Order item creation fields (order ref, product variant, quantity).",
      "typeName": "IShoppingOrderItem.ICreate"
    },
    "responseBody": {
      "description": "New order_item record with full reference and evidence fields.",
      "typeName": "IShoppingOrderItem"
    },
    "path": "/shopping/orderItem",
    "method": "post"
  },
  {
    "specification": "Update an existing order item record in the shopping mall system. This operation targets the 'order_item' table, allowing an authorized user or service to update the details of a specific order line item identified by its unique ID. The update may include changes to quantity or other atomic, auditable fields. Implements traceability, evidence logging, and full compliance with order item modification requirements as outlined in the Cart & Order Processing module. All changes must be recorded with timestamped audit and evidence preservation.",
    "description": "This API operation enables the secure update of an existing order item, in compliance with the audit and evidence requirements from the Cart & Order Processing module. The endpoint accepts a structured payload referencing the updated atomic fields (such as quantity or last modified timestamp) and ensures ACID compliance, transactional integrity, and evidence logging through immutable event registration in order_log. Users must possess the necessary permissions to modify order items, with all actions tracked for audit and regulatory compliance.\n\nAssociated relationships include strong referential integrity with the order, product variant, and audit trail. Error conditions handled include invalid ID, permission denied, and concurrent modification conflicts. This operation is typically used in workflows involving order edits, corrections, or split shipments.\n\nRelated APIs: GET/DELETE on single order item, patch to list order items, and order history query for audit review.",
    "summary": "Update a specific order_item record by ID in the shopping mall order system, implementing audit and compliance requirements.",
    "parameters": [
      {
        "name": "id",
        "description": "Target order item's ID",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": {
      "description": "Updated order_item data for modification",
      "typeName": "IShoppingOrderItem.IUpdate"
    },
    "responseBody": {
      "description": "Updated order_item detail",
      "typeName": "IShoppingOrderItem"
    },
    "path": "/shopping/orderItem/{id}",
    "method": "put"
  },
  {
    "specification": "Delete (soft delete) a specific order item record in the shopping mall order system. This operation targets the 'order_item' table, marking the record as deleted for evidence-preserving compliance, rather than physical removal. Fully logs the deletion event for audit, dispute resolution, and regulatory requirements. Access controlled by order ownership and permission policies.",
    "description": "This API operation provides evidence-preserving soft deletion of a single order_item entity identified by its ID. Complies with the strict audit and regulatory requirements from the Cart & Order Processing and Security, Permission & Compliance modules. The operation sets the appropriate deleted_at or archived flag, appends a corresponding order_log record, and ensures no orphaned relationships remain. All deletion actions are non-repudiable, logged with timestamps and user context, and prevent physical data loss in line with compliance standards.\n\nDeletion requests are rejected if the ID is invalid, the user lacks permission, or the item is in a non-deletable workflow state. The API's integrity supports downstream audit, reporting, and event-driven reconciliation processes.",
    "summary": "Soft delete a specific order_item record by ID, preserving audit/evidence while restricting further updates.",
    "parameters": [
      {
        "name": "id",
        "description": "Target order item's ID",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Confirmation of soft deletion (status/message)",
      "typeName": "ICommonDeleteResult"
    },
    "path": "/shopping/orderItem/{id}",
    "method": "delete"
  },
  {
    "specification": "List, search, and filter order status change events in the shopping mall system. Query the 'order_status' table with flexible searching capabilities including order ID, status code, timestamp ranges, user, and pagination. Used for monitoring and analytics of order state transitions, and for evidence exports required by audit/compliance workflows.",
    "description": "This API operation provides a flexible, paginated, and filterable interface for querying the full history of order status change records. Implements the evidence-preservation, analytics, and compliance monitoring requirements from the Cart & Order Processing specification. Supports advanced filtering (by order, status_code, actor, and timestamp), full text search, and robust pagination to enable downstream auditing, reporting, or analytics workflows.\n\nReturns only atomic order status events, never aggregates or pre-computed rollups. Handles permission checks for sensitive order history, with all queries tracked in the system audit log for regulatory oversight. Error handling includes invalid query parameters, permission denial, and pagination limits.\n\nRelated APIs include creation (POST), detail (GET), update (PUT), and deletion (DELETE) of individual order status records.",
    "summary": "List/filter order_status records, supporting audit, analytics, and compliance flows with full search and pagination support.",
    "parameters": [],
    "requestBody": {
      "description": "Order_status query/filter/search input, including pagination, search, and sorting fields",
      "typeName": "IShoppingOrderStatus.IRequest"
    },
    "responseBody": {
      "description": "Paginated and filtered list of order_status records",
      "typeName": "IPageIShoppingOrderStatus"
    },
    "path": "/shopping/orderStatus",
    "method": "patch"
  },
  {
    "specification": "Get the detailed status change record for a specific order, by order status record ID. Accesses the 'order_status' table to return full atomic details of the status change event, supporting evidence audits, compliance traceability, and order workflow analytics. Used in audit reviews, individual event drilldown, and troubleshooting state machine errors.",
    "description": "This API endpoint retrieves the complete, unaggregated detail of a single order_status record, by its unique identifier. Returns all atomic fields and fully resolves referenced relationships (e.g., actor, time, status_code) for the event. This fulfills the audit, compliance, and evidence traceability requirements specified in the Cart & Order Processing and Security, Permission & Compliance modules.\n\nStrict access control imposed—record only returned if user has permission for the parent order. All queries are logged in the audit log for regulatory compliance. Errors include record not found, permission denied, and transient backend failures.",
    "summary": "Get detail of a specific order_status change event by ID for deep audit, evidence, or analytics use.",
    "parameters": [
      {
        "name": "id",
        "description": "Target order_status record ID",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Full order_status record detail",
      "typeName": "IShoppingOrderStatus"
    },
    "path": "/shopping/orderStatus/{id}",
    "method": "get"
  },
  {
    "specification": "Create a new order_status change event (e.g., pending, paid, shipped) for an order. Writes a new record in 'order_status' table, triggering downstream workflows such as audit logging, compliance evidence recording, and event-driven state transitions. Permission-guarded to authorized order operators (system/admin/vendor) per compliance and traceability requirements.",
    "description": "This endpoint creates a new order_status change record in the shopping mall backend, fulfilling strict compliance and evidence-preserving requirements as described in the Cart & Order Processing and Security, Permission & Compliance specifications. The API accepts a payload containing all required atomic fields (order ID, new status_code, actor, timestamp) and logs the creation event in audit and order_log for later analytics or dispute resolution.\n\nPrecondition checks include correct workflow state transitions, sufficient permissions, and data validation. Postcondition: downstream eventing/notification systems may be triggered based on new status. Errors handled include permission denied, invalid workflow, missing data, and backend failures. Used in order management, automation, and compliance review flows.",
    "summary": "Create a new order_status record for an order, marking state transitions as evidence for audit/compliance.",
    "parameters": [],
    "requestBody": {
      "description": "Order_status creation payload (order, status, actor, timestamp, ...), atomic and audit-compliant",
      "typeName": "IShoppingOrderStatus.ICreate"
    },
    "responseBody": {
      "description": "Created order_status record",
      "typeName": "IShoppingOrderStatus"
    },
    "path": "/shopping/orderStatus",
    "method": "post"
  },
  {
    "specification": "Update an existing order_status change record. Enables correction or evidence-supplementation for prior state transitions, as permitted by business/workflow logic. Updates the 'order_status' table, implements full audit trace and compliance evidence requirements, and records all changes in immutable logs for forensic review.",
    "description": "This operation updates the atomic details of a specific order_status entry, such as correction of actor, status_code, or timestamp fields, in accordance with compliance and audit policies. All updates require strict permission enforcement and generate new order_log/audit_log entries for every change, supporting evidence chains for dispute resolution or regulatory review. Used in correction workflows, migration scripts, or exceptional workflows as permitted by system business rules.\n\nValidation includes only allowing updates that don't introduce illegal state transitions, maintaining referential and audit integrity. All updates are transactional and ACID-compliant. Errors are returned for permission denial, workflow rule violations, and data integrity conflicts.",
    "summary": "Update an existing order_status record, maintaining audit/evidence compliance through immutable event registration.",
    "parameters": [
      {
        "name": "id",
        "description": "Target order_status record ID",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": {
      "description": "Updated order_status data (actor, status, changed_at, ...), atomic and audit-tracked",
      "typeName": "IShoppingOrderStatus.IUpdate"
    },
    "responseBody": {
      "description": "Updated order_status record detail",
      "typeName": "IShoppingOrderStatus"
    },
    "path": "/shopping/orderStatus/{id}",
    "method": "put"
  },
  {
    "specification": "Delete (audit-preserved, soft delete) a specific order_status record. Implements evidence retention and compliance audit requirements by only flagging as deleted/archived, not removing from storage. Records all actions in immutable event/audit logs for forensic and regulatory review. Enforces workflow/protection logic to prevent illegal deletions.",
    "description": "This endpoint implements strict, evidence-preserving soft deletion of an order_status record by ID. The operation supports audit, compliance, and regulatory logging as mandated in Cart & Order Processing and Security, Permission & Compliance modules. On deletion, sets deleted/archived flag (not physical removal), logs action in order_log/audit_log, and triggers event notification for dependent workflows if applicable.\n\nOperation is only permitted with appropriate permission and if workflow rules permit deletion. All actions are non-repudiable and traceable for downstream compliance audits. Returns a confirmation object.",
    "summary": "Soft delete an order_status record, maintaining audit/evidence; never physically removed.",
    "parameters": [
      {
        "name": "id",
        "description": "Target order_status record ID",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Result/confirmation of audit-preserving soft delete",
      "typeName": "ICommonDeleteResult"
    },
    "path": "/shopping/orderStatus/{id}",
    "method": "delete"
  },
  {
    "specification": "List, search, and filter order event logs in the shopping mall order management system. Query the 'order_log' table with filtering on event_type, order ID, actor, timestamp range, and support for robust pagination and sorting, used for compliance reporting, audit/investigation, and evidence chain reconstruction.",
    "description": "This API operation implements flexible, paginated search and filtering for all order_log event records, supporting audit, compliance, and dispute evidence requirements. All log entries are atomic, detailing individual actions (event_type, description, actor, timestamps) for robust downstream analytics and audit workflows. Filtering options support event types, related order, actor, or time range, with strict permission enforcement for evidence visibility (e.g. privileged users/admins/auditors only).\n\nEach query is logged for audit evidence. Used by reporting, legal, and compliance tools to reconstruct business events for a given order/account. Errors: permission denied, invalid filter values, pagination limits exceeded.",
    "summary": "List/filter order_log event records for compliance/audit evidence, supporting search, filtering, and pagination.",
    "parameters": [],
    "requestBody": {
      "description": "Order_log query/filter/search input including pagination, range, or sorting.",
      "typeName": "IShoppingOrderLog.IRequest"
    },
    "responseBody": {
      "description": "Paginated, filtered list of order_log records, atomic event detail output.",
      "typeName": "IPageIShoppingOrderLog"
    },
    "path": "/shopping/orderLog",
    "method": "patch"
  },
  {
    "specification": "Get the detail for a single order_log event record by ID. Queries the 'order_log' table to return full atomic details of the log event. Used in audit workflows, evidence drilldown, or event tracing for order management and compliance traceability. Access is strictly controlled for sensitive evidence data.",
    "description": "This endpoint retrieves the complete atomic details of a single order_log event record, referenced by its unique ID. Returns all fields, including event_type, description, actor references, timestamps, and linked evidence (if any). Implements evidence preservation, audit, and compliance requirements as described in governance and dispute-handling specifications.\n\nStrict access controls restrict visibility based on role/ownership. Queries themselves are logged for evidence preservation. Errors include record not found, not authorized, or backend failures.",
    "summary": "Get detail of a specific order_log event for order audit, compliance, and evidence review.",
    "parameters": [
      {
        "name": "id",
        "description": "Target order_log record ID",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Full order_log record detail, atomic event audit fields.",
      "typeName": "IShoppingOrderLog"
    },
    "path": "/shopping/orderLog/{id}",
    "method": "get"
  },
  {
    "specification": "Create a new order_log event entry for either a business operation (e.g., state change, evidence addition, note) or for compliance trace of order actions. Appends an atomic event to 'order_log', recording actor, type, timestamp, linked evidence reference. Downstream systems may be notified post-write (e.g., analytics, compliance reporting).",
    "description": "This endpoint records a new atomic order_log event record, satisfying the requirements for immutable event tracing, compliance evidence, and robust business logic audit. The API accepts fields for order linkage, event_type, event_description, timestamp, actor ID, and optional evidence reference. All insertions result in appended order_log record and may trigger notifications to dependent modules.\n\nPre-condition checks include permission validation, event data completeness, and referential integrity. All actions are non-repudiable and written with timestamp for forensic/regulatory review. Used by order workflows, dispute handling, and compliance reporting tools.\n\nErrors: missing/incomplete data, permission denied, invalid references, transactional conflict. Related Operations: PATCH filter, GET/PUT/DELETE by id.",
    "summary": "Create an atomic order_log event for an order, implementing evidence and compliance requirements.",
    "parameters": [],
    "requestBody": {
      "description": "Order_log event creation details (order, event_type, description, actor, ...), atomic and audit-oriented.",
      "typeName": "IShoppingOrderLog.ICreate"
    },
    "responseBody": {
      "description": "Created order_log record, event detail",
      "typeName": "IShoppingOrderLog"
    },
    "path": "/shopping/orderLog",
    "method": "post"
  },
  {
    "specification": "Update an existing order_log event record. Corrects or supplements event details with evidence, maintaining immutability in logs by appending a new event for all changes. Original records never deleted for compliance; update operation references the original log and denotes correction. Changes tracked for full regulatory and forensic evidence. Used for evidence correction, annotation, or compliance-driven updates.",
    "description": "Updates details for a specific order_log entry, referencing its unique ID and replacing only permitted atomic fields (event_description, evidence reference, etc.), fully in line with audit, compliance, and evidence-preservation best practices. All updates are permission-gated and append a corrective log entry for immutability—auditors and compliance reviewers can trace all changes via the audit trail.\n\nValidations: cannot alter protected/immutable fields (event_time, actor, etc.), no physical record replacement. Errors: lack of permission, illegal update, or data conflict. Used in exceptional evidence correction or compliance-mandated annotation workflows.",
    "summary": "Update an order_log event by ID, appending correction with audit/evidence preservation and full traceability.",
    "parameters": [
      {
        "name": "id",
        "description": "Target order_log record ID",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": {
      "description": "Corrected order_log event details; appended for evidence and compliance.",
      "typeName": "IShoppingOrderLog.IUpdate"
    },
    "responseBody": {
      "description": "Updated (corrected/annotated) order_log record detail, atomic event output.",
      "typeName": "IShoppingOrderLog"
    },
    "path": "/shopping/orderLog/{id}",
    "method": "put"
  },
  {
    "specification": "Delete (soft delete, evidence-preserving) a specific order_log event by ID. Sets appropriate flag (archived/deleted_at) but never physically removes the record, fulfilling audit, compliance, and legal hold requirements. Logs all actions for full traceability, including user, timestamp, and justification. Used for regulatory takedown, data minimization, or correction of error entries; never erases original event for chain of custody.",
    "description": "Implements soft (evidence-preserved) deletion for a given order_log record, marked by its ID. The API only sets deleted/archived flags, never removing or overwriting physical event logs. Fulfills requirements for audit, compliance, privacy (GDPR/CCPA), and chain-of-custody preservation. All deletion actions are logged as new immutable events for downstream legal or regulatory review. Strict permission enforcement prevents unauthorized erasure.\n\nReturns confirmation object (deleted: boolean or status/message). Used for controlled evidence and log lifecycle management in regulated environments.",
    "summary": "Soft delete (archive) order_log event record, complying with audit/evidence policies for immutable system record keeping.",
    "parameters": [
      {
        "name": "id",
        "description": "Target order_log record ID",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Result/confirmation of evidence-preserved (archived) soft delete operation.",
      "typeName": "ICommonDeleteResult"
    },
    "path": "/shopping/orderLog/{id}",
    "method": "delete"
  },
  {
    "specification": "Retrieve a paginated list of order evidence records. This endpoint enables searching, filtering, and sorting of order_evidence table entries. Each record represents an evidence artifact (such as a document, receipt, or digital asset) associated with an order in support of compliance, audit, or dispute resolution. The operation references the order_evidence table, which stores atomic per-evidence data, relationship to order, evidence type, URI, timestamp, and provider reference. Supports search by evidence type, order ID, provider, and date interval. Implements evidence chain retrieval, allowing downstream modules (compliance, analytics, legal exports) and AI analysis workflows to programmatically access supporting artifacts efficiently.",
    "description": "This PATCH endpoint retrieves a paginated, searchable list of order evidence entities, as required for the evidence preservation and audit-trail requirements in the CartOrder module. Each entry from the order_evidence Prisma schema table represents a single, immutable, atomic record of order-associated evidence—such as receipts, digital signatures, or regulatory documents. The endpoint supports advanced filtering by order, evidence type, date range, and provider. Security is enforced via authentication and fine-grained permissions, only presenting evidence for authorized user contexts. Every API invocation triggers append-only logging (see SecurityCompliance module) to preserve audit trace.\n\nReturned records correspond directly to the order_evidence table, with full compliance to non-repudiation and integrity mandates. Interaction with this endpoint may be used alongside /order and /order/{id} APIs for full transaction context, or with data export endpoints for legal reporting. Error responses are standardized; access is controlled by user role and organizational policies.\n\nList retrievals through this endpoint feed downstream legal, compliance, and AI/analytics systems that require robust evidence chains for investigation, reconciliation, or model training. Pagination is mandatory, and sensitive URI data may be masked or redacted if not permitted by current user's context.",
    "summary": "Retrieve paginated/searchable list of order evidence (order_evidence table).",
    "parameters": [],
    "requestBody": {
      "description": "Search and filter input for order evidence records, including pagination, query, and sorting fields.",
      "typeName": "IOrderEvidence.IRequest"
    },
    "responseBody": {
      "description": "Paginated result set of order evidence records matching search and filter inputs.",
      "typeName": "IPageIOrderEvidence"
    },
    "path": "/shopping/orderEvidence",
    "method": "patch"
  },
  {
    "specification": "Retrieve the detailed information for a specific order evidence item. This endpoint returns the full atomic record from the order_evidence table by primary key (id). Use this endpoint to fetch the metadata, file reference/URI, evidence type, associated order, provider, time of provision, and provider context for a given evidence asset recorded in the commerce system. Direct mapping to the order_evidence Prisma schema entity. Required for granular audit, compliance review, and evidence inspection.",
    "description": "This GET endpoint retrieves a single order evidence entity, identified by its primary key id, in alignment with the order_evidence Prisma schema. It reveals all atomic information about the selected evidence asset, including evidence type, URI, timestamp, related order ID, and the user/provider reference. API consumers must have appropriate access rights; sensitive evidence links may be further restricted depending on role, order ownership, or regulatory overlays.\n\nTypical use is legal/audit teams, admin panels, or programmatic compliance exports, fetching details of a specific supporting artifact for transaction evidence. Accesses are immutably logged for evidence preservation and audit, as described in the SecurityCompliance module. Errors are returned for unauthorized access or missing records. This operation is often paired with /shopping/orderEvidence (PATCH) for collections, or /shopping/orders/{id} for transaction context. Evidence is not editable via this API—immutable by design.",
    "summary": "Fetch a specific order evidence asset by ID (order_evidence table).",
    "parameters": [
      {
        "name": "id",
        "description": "Primary key of the order evidence to retrieve.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Complete order evidence record as per order_evidence table.",
      "typeName": "IOrderEvidence"
    },
    "path": "/shopping/orderEvidence/{id}",
    "method": "get"
  },
  {
    "specification": "Create a new order evidence record for a transaction. The request accepts structured metadata and optionally a reference URI to the evidence artifact (such as a file, digital receipt, or regulatory document). The record is stored as a new entity in the order_evidence table, capturing evidence type, order association, timestamp, and provider context, thereby supporting audit, compliance, or dispute flows.",
    "description": "This POST endpoint allows creation of a new order evidence record, as defined by the order_evidence table in the CartOrder module. The request includes the order to which the evidence applies, the evidence type, a reference URI or hash, and supplementary metadata. Only users with appropriate permissions (including compliance, legal, or authorized transaction actors) may create evidence—role-based access control is strictly enforced. The entry is immutable post-creation (for audit chain integrity).\n\nUpon creation, the system logs the action with a compliance record. Order evidence may be required by payment, AI/analytics, audit, or user dispute resolution modules downstream. Validation ensures referenced orders and URIs exist and conform to compliance protocols. Error handling covers invalid orders, URI collisions, or permission violations. Creation is typically combined with order fulfillment, complaint, or refund flows requiring non-repudiable audit evidence.",
    "summary": "Create a new order evidence record (order_evidence table).",
    "parameters": [],
    "requestBody": {
      "description": "Specification of order evidence attributes, linked order, evidence type, URI, and provider info.",
      "typeName": "IOrderEvidence.ICreate"
    },
    "responseBody": {
      "description": "The newly created atomic order evidence record.",
      "typeName": "IOrderEvidence"
    },
    "path": "/shopping/orderEvidence",
    "method": "post"
  },
  {
    "specification": "Update (replace) an existing order evidence record by ID. This operation enables updating all mutable fields for a specific order evidence asset, allowing administrative corrections or compliance updates. The order_evidence table is referenced by primary key, and submitted values replace existing ones. Order evidence is typically append-only and immutable; use of this endpoint must be heavily audited, typically reserved for compliance officers.",
    "description": "This PUT endpoint updates an existing order evidence entity, referenced by its unique id, according to the order_evidence schema. All fields except immutable identifiers may be replaced, for scenarios such as correcting misclassified evidence type, replacing a broken URI, or re-tagging provider attribution. Use of this API is extremely privileged; access is restricted to compliance, legal, or trusted administrative actors and every invocation is permanently logged for audit purposes, per SecurityCompliance protocols.\n\nCommon use cases include compliance-directed evidence remediation, regulatory correction, or migration/upgrade of digital evidence formats. API request validation ensures consistency, referential integrity (ordinal and provider signatures), and legal compliance. Unauthorized or improper usage raises alerts. Success returns the fully replaced order evidence record; errors for missing, conflicting, or read-only attributes are detailed in the response.",
    "summary": "Update/replace order evidence record by ID (order_evidence table).",
    "parameters": [
      {
        "name": "id",
        "description": "Primary key of the order evidence to update.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": {
      "description": "Replacement payload for the order evidence record, all required updatable fields.",
      "typeName": "IOrderEvidence.IUpdate"
    },
    "responseBody": {
      "description": "The fully updated order evidence record.",
      "typeName": "IOrderEvidence"
    },
    "path": "/shopping/orderEvidence/{id}",
    "method": "put"
  },
  {
    "specification": "Delete an order evidence record by ID. This endpoint performs a logical (soft) delete in the order_evidence table, setting a deleted_at timestamp for compliance/evidence chain retention. Physical deletion is never performed, ensuring that evidence for transactions remains auditable and tamper-evident. Deletion access is tightly restricted to high-trust compliance or legal ops.",
    "description": "This DELETE endpoint marks an existing order evidence entity as deleted, setting a deleted_at timestamp according to the order_evidence table's compliance requirements. The operation is restricted to compliance, legal, or privileged administrative actors, as order evidence must remain retrievable for audit, legal discovery, or regulatory review. All deletions are append-only for the audit trail, and the record persists for transparency in historical queries.\n\nTypical usages are regulatory/GDPR request handling, resolving duplicate/malformed records, or policy-driven cleanup. Attempting to delete non-existent or already deleted records results in idempotent, standards-compliant error responses. All actions through this endpoint are automatically and immutably logged, consistent with requirements for tamper-evident chain of custody.",
    "summary": "Soft delete order evidence record by ID (order_evidence table).",
    "parameters": [
      {
        "name": "id",
        "description": "Primary key of the order evidence to delete.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Order evidence record marked as deleted (deleted_at set).",
      "typeName": "IOrderEvidence"
    },
    "path": "/shopping/orderEvidence/{id}",
    "method": "delete"
  },
  {
    "specification": "Retrieve a paginated, searchable list of payment records. This operation queries the payments table, supporting filtering by transaction, user, status, currency, date range, and payment method. Payment records are foundational for transaction audits, reconciliation, AI risk scoring, fraud analysis, and compliance exports.",
    "description": "This PATCH endpoint returns a list of payment entities from the payments table, adhering to criteria set in PaymentsDiscounts module. Query parameters enable fine-grained filtering—by transaction ID, payment status, currency, payment method, timestamp, and optionally by user (for admin/operator use). Pagination and sorting are required for scalability and evidentiary flows. All results comprise atomic, immutable payment records, with audit and integrity protocols enforced throughout access.\n\nAPI consumers include financial controllers, compliance/legal officers, and operational dashboards, as well as downstream modules that require payment lineage for analytics, AI/ML workflows, fraud models, or evidence reporting. Access to records is permission-restricted and fully logged; sensitive information is masked per the caller's rights. Error handling covers unauthorized access, malformed queries, missing permissions, or non-existent transactions.",
    "summary": "Retrieve paginated/searchable payment records (payments table).",
    "parameters": [],
    "requestBody": {
      "description": "Search parameters, including filter, pagination, and sorting for payments.",
      "typeName": "IPayment.IRequest"
    },
    "responseBody": {
      "description": "Paginated response containing payment records matching search criteria.",
      "typeName": "IPageIPayment"
    },
    "path": "/shopping/payments",
    "method": "patch"
  },
  {
    "specification": "Fetch a single payment record from the payments table by ID. The endpoint delivers all atomic metadata for the requested payment, including payment method, status, currency, amount, timestamps, and audit context. Used by finance, compliance, and evidence reporting modules.",
    "description": "This GET endpoint returns the full atomic details for a payment entity, as stored in the payments table, accessible by primary key id. All fields, including status, amount, currency, payment method, date, and associated transaction reference, are included. Sensitive data (masked details, notes) are visible only to authorized users—access is strictly controlled by role-based permissions, and all API invocations are permanently logged for compliance.\n\nThis operation is frequently used in admin dashboards, compliance/finance review systems, and downstream analytics/AI fraud detection. Error handling covers missing records, access violations, and attempts to access unreconciled/archived data. The endpoint often augments returns from payment summary searches or is used in evidence chains/document exports.",
    "summary": "Retrieve payment details by ID (payments table).",
    "parameters": [
      {
        "name": "id",
        "description": "Primary key of the payment to retrieve.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Complete payment record and related metadata from payments table.",
      "typeName": "IPayment"
    },
    "path": "/shopping/payments/{id}",
    "method": "get"
  },
  {
    "specification": "Create a new payment record in the payments table. This endpoint accepts structured payment input, creating an atomic record of a payment event, including transaction linkage, payment method, status, currency, amount, and audit fields. Used as part of transaction, checkout, or refund workflows.",
    "description": "This POST endpoint creates a new payment entry in the payments table, as per requirements for traceability and compliance in the PaymentsDiscounts module. Input includes transaction association, payment method, status, currency, amount, and optionally, business notes. All new payments are subject to validation (e.g., valid transaction, unique constraints, PCI/DSS logic). Editing is not permitted post-creation (immutability for audit).\n\nAccess is role-restricted (operator, system, or admin), with every invocation producing an immutable audit log. Typical scenarios are transaction completion, top-ups, refunds, or wallet operations. API consumers include checkout modules, payment gateways, finance ops, and AI/ML fraud/risk scoring. Error handling covers validation inconsistencies, permission failures, or payment processing errors. Downstream impacts include updates to transaction, ledger, and report modules.",
    "summary": "Create a new payment record (payments table).",
    "parameters": [],
    "requestBody": {
      "description": "Specification for the new payment: transaction reference, method, status, currency, amount, and notes.",
      "typeName": "IPayment.ICreate"
    },
    "responseBody": {
      "description": "Atomic record of the newly created payment event.",
      "typeName": "IPayment"
    },
    "path": "/shopping/payments",
    "method": "post"
  },
  {
    "specification": "Replace (update) a payment record by its ID. This allows updating of allowed mutable fields, primarily for administrative, compliance, or reconciliation scenarios. The operation references the payments table by primary key; updated values replace existing fields, with immutable audit logging enforced.",
    "description": "This PUT endpoint allows privileged actors to update an existing payment entry (by id), as represented in the payments table. Typical use cases include updating status (e.g., marking refunded, failed), correcting payment method references, or updating business notes. All changes are logged as required by compliance and audit mandates; only authorized operators may call this endpoint.\n\nKey business logic involves enforcing immutability on historical/statute fields (transaction reference, amount may be restricted), so only business notes, providers, or status are typically updatable. Inputs are validated for referential, business, and regulatory integrity. Error returns for permission issues, attempts to mutate locked fields, or non-existent payment records.",
    "summary": "Update/replace a payment record by ID (payments table).",
    "parameters": [
      {
        "name": "id",
        "description": "Primary key of the payment to update.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": {
      "description": "Replacement payload specifying updatable attributes of payment record.",
      "typeName": "IPayment.IUpdate"
    },
    "responseBody": {
      "description": "Updated payment record (atomic from payments table).",
      "typeName": "IPayment"
    },
    "path": "/shopping/payments/{id}",
    "method": "put"
  },
  {
    "specification": "Soft delete an individual payment record from the payments table by ID. Implements evidence chain preservation by marking the payment as deleted without physical removal. Used for compliance, fraud management, or dispute resolution, all deletions are immutably logged.",
    "description": "This DELETE endpoint marks an individual payment record (from payments table) as deleted—by setting a deleted_at timestamp or equivalent—without physically removing the record. Deletion is restricted to privileged/executive operator roles, given payment records must remain accessible for audit, compliance, and fraud investigation. All actions are permanently, append-only logged per regulatory evidence requirements.\n\nTypical scenarios include redress for fraud, regulatory policy, account closure, or post-mortem/archival. The endpoint returns the softly deleted payment entity; errors are raised for invalid or duplicate deletion attempts. All deletions are transparent and auditable, matching requirements for compliance chain preservation in PaymentsDiscounts module.",
    "summary": "Soft delete a payment record by ID (payments table).",
    "parameters": [
      {
        "name": "id",
        "description": "Primary key of the payment to delete.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Record of the payment now marked as deleted (deleted_at set).",
      "typeName": "IPayment"
    },
    "path": "/shopping/payments/{id}",
    "method": "delete"
  },
  {
    "specification": "Retrieve a paginated, filtered list of payment method entries from the payment_methods table. Supports filtering by user, type, provider, status, date, and other operator-facing attributes. Used for payment method administration, user wallet/client/card management, finance analysis, and compliance reporting.",
    "description": "This PATCH endpoint allows fine-grained retrieval of payment method records from the payment_methods table, supporting full administrative, user, and operator flows. Query filtering includes method type (credit, wallet, crypto), provider, activation status, user, and creation/issuance time frames. Pagination and sorting support large user or operator volumes. Access to user-specific payment method data is strictly controlled by RBAC and security policies; sensitive attributes such as masked details and provider are redacted except for owners and privileged operators.\n\nIntended audience includes platform admins, finance operations, compliance/legal/PCI review, and user self-management. Downstream systems include checkout, wallet UI, and audits/exports. Every access triggers audit logging, consistent with the platform's evidence chain mandates in PaymentsDiscounts and SecurityCompliance modules.",
    "summary": "Paginated, filtered retrieval of payment methods (payment_methods table).",
    "parameters": [],
    "requestBody": {
      "description": "Search and pagination parameters for querying payment methods.",
      "typeName": "IPaymentMethod.IRequest"
    },
    "responseBody": {
      "description": "Paginated set of filtered payment method records, as per search criteria.",
      "typeName": "IPageIPaymentMethod"
    },
    "path": "/shopping/paymentMethods",
    "method": "patch"
  },
  {
    "specification": "Fetch an individual payment method record by ID from the payment_methods table. This operation retrieves all atomic payment method data, including masked detail, type, status, provider, timestamps, and user association. Used for payment method management and compliance review flows.",
    "description": "This GET endpoint returns the full atomic record of a payment method entry, identified by unique id, mapped from the payment_methods table. Returned fields include type, masked detail, provider, status, owner user, and full metadata. RBAC enforcement ensures that only authorized users (owner, admins, finance officers) can access sensitive data. API usage is fully audit logged for compliance as outlined in SecurityCompliance.\n\nThis operation is essential for user wallet/card management, compliance review/audit, operational UI, and can support automated finance processes or AI/ML enrichment. Error returns for unauthorized access, non-existent records, or RBAC failures. This endpoint is often used in conjunction with list-filter endpoints and payment event flows.",
    "summary": "Fetch a payment method record by ID (payment_methods table).",
    "parameters": [
      {
        "name": "id",
        "description": "Primary key of payment method to fetch.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Full details of payment method, from payment_methods table.",
      "typeName": "IPaymentMethod"
    },
    "path": "/shopping/paymentMethods/{id}",
    "method": "get"
  },
  {
    "specification": "API for creating a new payment method as defined in the payment_methods table of the Prisma schema. This is part of the PaymentsDiscounts domain, enforcing strong normalization, unique constraints, and evidence preservation for financial integrations. This operation provides onboarding for user payment instruments (credit card, wallet, etc.), triggers audit trails, and is tightly secured per regulatory requirement. User must be authenticated; request must pass validations for active/uniqueness. Linked to the payment_methods table used for storing atomic payment instrument data, referenced by users, payments, vouchers, etc.",
    "description": "This API enables creation of a new payment method (e.g., credit card, wallet, or crypto account) for a user in the shopping mall backend system. The endpoint enforces PCI compliance, ensuring masking of critical data, and validates uniqueness per user (cannot register same method twice). It logs creation time for audit and compliance, associates method with a user, and ensures the active flag is correctly set. The API only accepts minimal identifying/payment info (type, masked_detail, provider, active) with all sensitive info stored encrypted at rest. Failure conditions include duplicate, invalid input, or user not authenticated. Successful creation returns the created payment method details, including unique ID, type, masked detail, and creation time. All creation actions are immutably logged in payment audit trail as per compliance. Related endpoints include update, delete, and list operations on payment methods for advanced account management.",
    "summary": "Create a new payment method (payment_methods table, PaymentsDiscounts domain).",
    "parameters": [],
    "requestBody": {
      "description": "Payment method creation details. Required fields: type, masked_detail, provider, active flag. Must reference user context. Sensitive details excluded, use masking.",
      "typeName": "IPaymentMethod.ICreate"
    },
    "responseBody": {
      "description": "Created payment method details, including ID, type, masked_detail, provider, status, and creation time as per the payment_methods schema.",
      "typeName": "IPaymentMethod"
    },
    "path": "/shopping/paymentMethods",
    "method": "post"
  },
  {
    "specification": "API for updating an existing payment method belonging to a user. Operations reflect modifications permitted in the payment_methods table (masked_detail, provider, activation status), only for active and non-deleted records. Part of domain PaymentsDiscounts, update triggers audit trail. Strict validation required to enforce PCI compliance and integrity of original fields; updating sensitive details is out of scope (re-registration or tokenization flow required for true credential changes). Linked to payment_methods table per Prisma schema.",
    "description": "This API updates existing payment method metadata (provider, active status, masked_detail—if permitted) for a user’s payment method. Only the owner can update, and all sensitive data must remain masked/encrypted; actual credentials are not directly updatable in this operation. Attempts to update non-existing, deleted, or unauthorized records will yield error. Each update triggers a payment_audits record for full traceability, and current/previous state is evidenced for compliance. Use this API for metadata changes (e.g., provider name update, activation/inactivation, label change). For changing sensitive account information, the method should be deleted and a new one created. Related endpoints are payment methods create/delete and payment operations that reference these methods.",
    "summary": "Update a user’s payment method information (payment_methods table, PaymentsDiscounts domain).",
    "parameters": [
      {
        "name": "id",
        "description": "Target payment method's ID.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": {
      "description": "Fields to update for payment method: may include provider, masked_detail (if allowed), and active flag. Must match payment_methods schema, with sensitive details handled separately.",
      "typeName": "IPaymentMethod.IUpdate"
    },
    "responseBody": {
      "description": "Updated payment method object, confirming changes and state after successful update.",
      "typeName": "IPaymentMethod"
    },
    "path": "/shopping/paymentMethods/{id}",
    "method": "put"
  },
  {
    "specification": "API for deleting (soft-delete/inactivation) a user's payment method, as reflected by the active and deleted_at fields of the payment_methods table (PaymentsDiscounts domain). Provides evidence preservation as required by financial operations, triggers audit chains, and ensures integrity. Deletion disables payment method for future use but preserves it for audit.",
    "description": "This API disables (soft-deletes) a user’s payment method, marking it as inactive and updating deleted_at for evidence. Target payment instrument must be owned by user and not already deleted. PCI compliance prohibits deleting sensitive credential data; instead, this disables further use while retaining evidence for audit, fraud, and regulatory requirements. Action is recorded in payment_audits for evidence. Related APIs: payment method create/update/list; making payments with alternative/inactive methods is blocked.",
    "summary": "Soft-delete or deactivate a user’s payment method, preserving evidence and audit (payment_methods, PaymentsDiscounts).",
    "parameters": [
      {
        "name": "id",
        "description": "Target payment method ID to deactivate.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Confirmation of soft-delete: usually the updated payment method record showing active: false, deleted_at set.",
      "typeName": "IPaymentMethod"
    },
    "path": "/shopping/paymentMethods/{id}",
    "method": "delete"
  },
  {
    "specification": "Retrieve a filtered and paginated list of discounts. Primarily operates on the discounts table (PaymentsDiscounts domain) as the source of record, joined with discount_rules and orders as needed. Supports complex search by user, order, campaign, status, type, and date range, with advanced sorting and evidence reference. Triggers analytics and audit logging for compliance. Used for reporting, analytics, and continuous AI model improvements.",
    "description": "This API lists/searches all applicable discount records, supporting filtering by order, user, campaign, rule type, status, and time frame. Provides paginated data per compliance and performance requirements. Results include core discount fields (ID, amount, order, rule/method, notes, timestamps) and referenced rule information. Used by business analytics, support dashboards, and auto-reconciliation tasks. Supports AI/ML model monitoring if discount rule is ML-based. Each search action may be logged for audit/compliance. Related endpoints: discount detail, create, update, delete, and discount rule endpoints.",
    "summary": "List and search discounts (discounts table, PaymentsDiscounts domain) with filtering/pagination.",
    "parameters": [],
    "requestBody": {
      "description": "Discounts search, filter, and pagination criteria (by order, user, rule, campaign, status, time, etc.).",
      "typeName": "IDiscount.IRequest"
    },
    "responseBody": {
      "description": "Paginated, filtered list of discount records with associated rule/order information as per the discounts schema.",
      "typeName": "IPageDiscount"
    },
    "path": "/shopping/discounts",
    "method": "patch"
  },
  {
    "specification": "Retrieve detailed info for a single discount record as stored in the discounts table (PaymentsDiscounts domain). Lookup is by primary key (ID). Returns all discount fields plus referenced discount_rule, order, and evidence as appropriate. Triggers evidence access and logs access for compliance/audit.",
    "description": "This API retrieves detailed information about a specific discount record by its unique ID. Returns all normalized discount properties (amount, order, rule, notes, application timestamp) and related info for discount rule, order, and any applicable evidence or audit trail. Used for investigating discount application, business integrity checks, and compliance investigation. Related endpoints: discounts list, create, update, and delete.",
    "summary": "Get a discount’s detailed info by ID (discounts table, PaymentsDiscounts domain).",
    "parameters": [
      {
        "name": "id",
        "description": "Target discount’s ID.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Complete discount record with all fields and linked rule/order context.",
      "typeName": "IDiscount"
    },
    "path": "/shopping/discounts/{id}",
    "method": "get"
  },
  {
    "specification": "Create a new discount (discounts table, PaymentsDiscounts domain). Handles both rule-based and AI-driven (ML-model) discounts, validating inputs per business logic, and stores compliant atomic discount record. Also creates evidence audit via payment_audits. The associated order and rule must exist/validate. Used by business/developer/dashboard or automated campaigns.",
    "description": "This API creates a new discount, linking an existing discount_rule to a specific order and applying the benefit (amount, notes, application time). The request ensures referenced rule/order exist and are valid for discount type. Handles rollbacks on failure. Triggers audit log and compliance events, especially if AI/ML-driven rule is used. Only administrators or system contexts can create discounts; normal users typically receive discounts via automation, not this API. Related endpoints include discounts list/detail, update, delete, and discount rule create/update.",
    "summary": "Create a new discount application for an order (discounts table, PaymentsDiscounts domain).",
    "parameters": [],
    "requestBody": {
      "description": "Information required to create a discount: discount_rule_id, order_id, amount, notes. See Prisma schema for details.",
      "typeName": "IDiscount.ICreate"
    },
    "responseBody": {
      "description": "Created discount record, with IDs, rule/order references, audit/evidence assurance per discounts schema.",
      "typeName": "IDiscount"
    },
    "path": "/shopping/discounts",
    "method": "post"
  },
  {
    "specification": "Update an existing discount record by ID (discounts table, PaymentsDiscounts domain). Only permitted fields per business logic (notes, potentially amount if in draft). Update is recorded for audit, and recalculate triggered if needed. Order/rule associations cannot be changed after application for compliance. Modification triggers evidence/audit/rollback per regulatory requirement.",
    "description": "This API updates an existing discount’s details, primarily limited to notes and, if business logic allows, amount (but not references to order or rule after applying). Input must match current record, and existing evidence land in payment_audits. If record is finalized, only supplementary metadata (notes) may be changed. Each update triggers full audit evidence for compliance/regulatory trace. Related endpoints: discount list/get/create/delete and discount rule CRUD.",
    "summary": "Update a discount’s metadata/fields (discounts table, PaymentsDiscounts domain).",
    "parameters": [
      {
        "name": "id",
        "description": "Target discount’s ID for update.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": {
      "description": "Permitted updates to the discount (notes, maybe amount if status allows). No changes to order/rule links.",
      "typeName": "IDiscount.IUpdate"
    },
    "responseBody": {
      "description": "Updated discount record with all permitted fields and compliance evidence per discounts schema.",
      "typeName": "IDiscount"
    },
    "path": "/shopping/discounts/{id}",
    "method": "put"
  },
  {
    "specification": "Delete (soft-delete) an existing discount record by ID (discounts table, PaymentsDiscounts domain). Discount must be eligible (not committed, depending on business logic) and referenced evidence is preserved, not destroyed. Triggers payment_audits and possibly compliance alerts.",
    "description": "This API disables or marks a discount as deleted or inactive, retaining evidence for auditing and dispute resolution. Target discount must be owned by current business context and eligible for deletion under business rules. Soft-deletion (archival, not hard removal) preserves all information for compliance with audit, fraud prevention, and regulatory obligations. Records all actions in payment_audits. Related endpoints: discount list/get/create/update and discount rule management.",
    "summary": "Delete (soft-delete/disable) an existing discount (discounts, PaymentsDiscounts).",
    "parameters": [
      {
        "name": "id",
        "description": "Target discount ID to delete/disable.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Deleted/archived discount record showing evidence of non-deletion (soft-delete, flags set).",
      "typeName": "IDiscount"
    },
    "path": "/shopping/discounts/{id}",
    "method": "delete"
  },
  {
    "specification": "Retrieve filtered and paginated list of discount rules (discount_rules table, PaymentsDiscounts domain) for admin/system purposes. Supports advanced search by type, campaign, status, activation, date, and ML model version. Used for campaign analysis, manual review, future campaign creation, and compliance.",
    "description": "This API returns a filtered, paginated list of discount rules in the system. Supports searching by rule type, campaign, activation status, creation date, and model version. Covers both rule-based and AI/ML-generated discounts. Used for marketing/campaign analysis, admin dashboards, compliance, and for rule selection by automation flows. Traceability and compliance are managed through pagination, filters, and evidence records for searched rules. Related endpoints include individual rule detail, creation, update, and delete.",
    "summary": "List/search discount rules with filters/pagination (discount_rules table, PaymentsDiscounts).",
    "parameters": [],
    "requestBody": {
      "description": "Discount rule search criteria: rule type, activation, campaign, ML model version, etc.; plus pagination/sorting.",
      "typeName": "IDiscountRule.IRequest"
    },
    "responseBody": {
      "description": "Paginated result of discount rule objects, with filtering, campaign reference, ML model version reference as per Prisma schema.",
      "typeName": "IPageDiscountRule"
    },
    "path": "/shopping/discountRules",
    "method": "patch"
  },
  {
    "specification": "Get details on a single discount rule by its unique ID (discount_rules table, PaymentsDiscounts domain). Endpoint returns main attributes of the rule, links to campaign and AI model version as appropriate. Access is traced for audit/compliance. Used for business logic, preview, and compliance.",
    "description": "This API retrieves a specific discount rule’s detailed data, including type, value, activation status, campaign reference, and ML model version if present. Used for business logic, campaign operations, and compliance dashboards. Related endpoints: discount rule list, create, update, delete.",
    "summary": "Get discount rule details by ID (discount_rules, PaymentsDiscounts).",
    "parameters": [
      {
        "name": "id",
        "description": "Target discount rule’s ID for detail.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Full discount rule details, including campaign and ML/AI model reference if present.",
      "typeName": "IDiscountRule"
    },
    "path": "/shopping/discountRules/{id}",
    "method": "get"
  },
  {
    "specification": "Create a new discount rule (discount_rules table, PaymentsDiscounts domain). Used to define a new campaign, rule, or AI/ML-based discounting strategy. Input includes type, value, activation flag, and optional campaign/AI model version. Operation is logged for compliance and triggers update in related processes. Validates input and enforces uniqueness/context integrity. Only admins/system may create rules. Immediate effect on campaign automation. Evidence recorded in audit trail.",
    "description": "This API allows privileged users to create a new discount rule, specifying type, value, activation flag, campaign reference, and optionally ML model version reference. It’s used for launching new discount strategies (percentage, fixed, buy-one-get-one, ML-powered dynamic). Enforces all business validations, logs the operation for regulatory and auditing requirements. Any automatic effect on campaigns/orders updates related records. Related endpoints: rule list/get/update/delete, discount CRUD.",
    "summary": "Create a new discount rule (discount_rules, PaymentsDiscounts).",
    "parameters": [],
    "requestBody": {
      "description": "Discount rule creation data, including rule type, value, activation, campaign, optional ML model info as defined in Prisma schema.",
      "typeName": "IDiscountRule.ICreate"
    },
    "responseBody": {
      "description": "Created discount rule object, showing type/value, campaign/ML references, activation. Used for further campaign automation.",
      "typeName": "IDiscountRule"
    },
    "path": "/shopping/discountRules",
    "method": "post"
  },
  {
    "specification": "Update an existing discount rule by ID (discount_rules table, PaymentsDiscounts domain). Acceptable changes: type, value, status (activation), campaign association, ML model version (where permitted). Each update is logged for evidence. Only privileged users can update. Rule changes can immediately impact future discounts. Compliance and traceability enforced via audit trail.",
    "description": "This API updates an existing discount rule, accepting changes to type, value, activation status, campaign reference, or AI/ML version association (as allowed by state/permissions). The update triggers compliance evidence/audit. All changes are versioned and stored for regulatory review. Related endpoints: rule list/get/create/delete, discount CRUD. Unauthorized or invalid updates are rejected.",
    "summary": "Update discount rule configuration by ID (discount_rules, PaymentsDiscounts).",
    "parameters": [
      {
        "name": "id",
        "description": "Target discount rule ID to update.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": {
      "description": "Discount rule update info; allowed fields are type, value, status, campaign, ML version, as permitted in schema/business logic.",
      "typeName": "IDiscountRule.IUpdate"
    },
    "responseBody": {
      "description": "Updated discount rule object, reflecting new configuration, audit record generated.",
      "typeName": "IDiscountRule"
    },
    "path": "/shopping/discountRules/{id}",
    "method": "put"
  },
  {
    "specification": "Delete an existing discount rule by its unique identifier. This operation is tied to the PaymentsDiscounts.discount_rules table in the Prisma schema, which manages rules used for discount applications within the system. The endpoint enables deletion (archival, as per audit/evidence compliance) of a rule, with full traceability and compliance recorded in an audit log. Standard permissions and evidence preservation constraints apply. Deleting a discount rule ensures that it cannot be used for future discounts while preserving its record for regulatory and compliance needs. Related discounts remain intact for historical transactions, but the rule is no longer active or available for use. Only authorized users (e.g., admins) can perform this action, and each delete operation triggers an audit entry. Attempting to delete a rule in active use may require additional validation or trigger an error.",
    "description": "This endpoint deletes the specified discount rule from the system, in accordance with compliance and evidence preservation requirements drawn from PaymentsDiscounts.discount_rules. Upon invocation, the system verifies the requestor’s permission, checks the rule’s linkage to past discounts, and ensures that the rule can be safely archived/deactivated. All delete operations are logged with full traceability for audit and regulatory reporting. Business logic prohibits deletion of rules actively applied to ongoing or future discounts. Attempts to delete non-existent or non-removable rules result in clear, evidence-traced errors. This function supports maintaining a clean, regulatory-compliant set of discount strategies and a tamper-evident history for all critical changes. It interacts directly with audit logging and may be referenced by compliance/reporting tools.",
    "summary": "Delete a discount rule by ID (PaymentsDiscounts.discount_rules).",
    "parameters": [
      {
        "name": "id",
        "description": "Unique identifier of the discount rule to delete.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": null,
    "path": "/shopping/discountRules/{id}",
    "method": "delete"
  },
  {
    "specification": "Retrieve a list of discount campaigns with search, pagination, and sorting capabilities, as required by the PaymentsDiscounts.discount_campaigns table in the Prisma schema. This API provides advanced lookups, status-based filtering, and supports evidence, compliance, and traceability as needed in enterprise campaign management. Accessible to authorized parties for operational analytics and regulatory reporting.",
    "description": "This endpoint fetches a paginated, filterable list of discount campaigns as recorded in PaymentsDiscounts.discount_campaigns. Utilizing request body parameters, clients may search, filter (e.g., by status, time ranges), and sort campaigns for business operations, analytics, or campaign review. All search queries and responses are logged for regulatory and audit purposes, ensuring compliance and retrospective inquiry. The design is aligned with modular, API-first practices and respects permissioning, privacy, and audit boundaries as outlined in the requirements. Common usage includes viewing campaigns for review, analysis, or planning new marketing activities, with returned structures supporting evidence and traceability for each campaign’s business state.",
    "summary": "Retrieve a list of discount campaigns with search and filter (PaymentsDiscounts.discount_campaigns).",
    "parameters": [],
    "requestBody": {
      "description": "Filter/search request for discount campaigns (pagination, status, time, etc).",
      "typeName": "IDiscountCampaign.IRequest"
    },
    "responseBody": {
      "description": "Paginated list of discount campaigns.",
      "typeName": "IPageIDiscountCampaign"
    },
    "path": "/shopping/discountCampaigns",
    "method": "patch"
  },
  {
    "specification": "Get the details of a specific discount campaign by its unique identifier. This endpoint accesses PaymentsDiscounts.discount_campaigns for a given campaign, providing full campaign metadata, active status, timestamps, and associated audit/compliance information. Suitable for business, regulatory, or analytics review and inspection.",
    "description": "Fetches the full details for an individual discount campaign based on the provided UUID. The returned object includes campaign name, timeframe, activation status, description, and all atomic attributes conformant to the PaymentsDiscounts.discount_campaigns schema. Each fetch request is logged for audit/compliance reporting. Used frequently by admins, auditors, or integration systems for contextual display, modification review, or evidence supporting discount activity across the commerce platform. Error responses are generated for non-existent or inaccessible (e.g., permission-restricted) campaigns with traceable reference for compliance.",
    "summary": "Get a specific discount campaign by ID (PaymentsDiscounts.discount_campaigns).",
    "parameters": [
      {
        "name": "id",
        "description": "Unique identifier of the discount campaign to retrieve.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Full discount campaign detail record.",
      "typeName": "IDiscountCampaign"
    },
    "path": "/shopping/discountCampaigns/{id}",
    "method": "get"
  },
  {
    "specification": "Create a new discount campaign, recording all related compliance, evidence, and campaign metadata. This endpoint writes to the PaymentsDiscounts.discount_campaigns table, initializing a new campaign for active or future use subject to audit, traceability, and business lifecycle rules. Data validation, permission checks, and uniqueness of name/start time enforced as per schema and requirements. Standard campaign attributes (name, timeframe, activation status, description) must be provided.",
    "description": "This endpoint enables authorized parties to create a new discount campaign in accordance with PaymentsDiscounts.discount_campaigns requirements and business evidence needs. On submission, the system validates inputs, ensures uniqueness where enforced, and creates the campaign record. The creation event is logged as per audit/compliance standards, linking any subsequent rules, discounts, or loyalty assets to this campaign. Common usage includes launching new promotions, managing seasonal/partner activities, or preparing audit/traceability for regulatory reporting. The integration supports multi-tenant business boundaries, privacy/compliance, and ensures that all data inputs are atomic and evidence-traceable.",
    "summary": "Create a new discount campaign (PaymentsDiscounts.discount_campaigns).",
    "parameters": [],
    "requestBody": {
      "description": "Details of the discount campaign to create (name, active, timeframe, ...).",
      "typeName": "IDiscountCampaign.ICreate"
    },
    "responseBody": {
      "description": "Created discount campaign record.",
      "typeName": "IDiscountCampaign"
    },
    "path": "/shopping/discountCampaigns",
    "method": "post"
  },
  {
    "specification": "Update an existing discount campaign by its unique identifier, modifying core attributes while ensuring evidence, compliance, audit history, and business traceability. This updates the PaymentsDiscounts.discount_campaigns table. Attributes such as campaign name, description, activation, timeframe, and audit proofs may be updated in accordance with permission and regulatory requirements. The modification event is evidence-tracked and triggers trace logging for audit/compliance tools.",
    "description": "This endpoint updates an existing discount campaign in the PaymentsDiscounts.discount_campaigns schema, enforcing permission, audit, and evidence preservation constraints. The request body provides new values for updatable atomic attributes (e.g., name, active flag, dates, description). Upon execution, a modification audit log entry is created, with previous values preserved for evidence and compliance review. The update supports business needs such as activating/deactivating campaigns, correcting descriptive details, or adjusting timeframes as required. If the campaign does not exist or is restricted, error states are returned with full traceability. All modifications comply with privacy, traceability, and regulatory mandates.",
    "summary": "Update an existing discount campaign by ID (PaymentsDiscounts.discount_campaigns).",
    "parameters": [
      {
        "name": "id",
        "description": "Unique identifier of the discount campaign to update.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": {
      "description": "Updated discount campaign attributes (name, status, timeframe, ...).",
      "typeName": "IDiscountCampaign.IUpdate"
    },
    "responseBody": {
      "description": "Updated discount campaign detail record.",
      "typeName": "IDiscountCampaign"
    },
    "path": "/shopping/discountCampaigns/{id}",
    "method": "put"
  },
  {
    "specification": "Delete a discount campaign by its unique identifier. This operation concerns the PaymentsDiscounts.discount_campaigns table and implements a logical (archival) delete, maintaining full evidence and regulatory traceability requirements. Deletion is restricted to authorized personnel and triggers a compliance/audit trail entry. The campaign is preserved for historical and regulatory purposes but marked inactive or archived within the system.",
    "description": "This endpoint deletes (archives) the specified discount campaign as per PaymentsDiscounts.discount_campaigns and sectioned compliance requirements. The operation deactivates the campaign, preserving a non-repudiable evidence trail and updating audit logs accordingly. The campaign becomes unavailable for new discount logic but remains referenceable for traceability, analytics, or regulatory review. Deletion may be blocked if the campaign is in active use or required for business evidence export. Business logic ensures that all changes are permissioned and auditable, and errors are clear and evidence-traced. Only properly permissioned users (e.g., administrators, auditors) may invoke this operation.",
    "summary": "Delete a discount campaign by ID (PaymentsDiscounts.discount_campaigns).",
    "parameters": [
      {
        "name": "id",
        "description": "Unique identifier of the discount campaign to delete.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": null,
    "path": "/shopping/discountCampaigns/{id}",
    "method": "delete"
  },
  {
    "specification": "Retrieve a list of transactions with search, pagination, and filtering, based on the PaymentsDiscounts.transactions table. Enables operational, analytical, and audit queries supporting evidence and compliance requirements. Standard query/body includes support for transaction type, status, user, or timeframe filtering. All operations logged for compliance, privacy, and modular audit needs.",
    "description": "This endpoint fetches a filterable, paginated list of transactions per PaymentsDiscounts.transactions, enabling complex search operations for business, analytics, or regulatory review. Clients provide criteria for transaction type (e.g., purchase, refund), timeframe, user, and other attributes. Each request is logged for audit, evidence, and compliance. This operation is central for financial reconciliation, business intelligence, and regulatory exports. Permission checks and privacy controls are applied per user/entity context. Data returned supports subsequent detail/investigation or export as evidence for compliance queries.",
    "summary": "List transactions with search and pagination (PaymentsDiscounts.transactions).",
    "parameters": [],
    "requestBody": {
      "description": "Filter/search criteria for transaction listing (type, user, status, time, ...).",
      "typeName": "ITransaction.IRequest"
    },
    "responseBody": {
      "description": "Paginated list of transactions.",
      "typeName": "IPageITransaction"
    },
    "path": "/shopping/transactions",
    "method": "patch"
  },
  {
    "specification": "Retrieve detailed information for a specific transaction by its unique identifier from PaymentsDiscounts.transactions. Suited for business review, audit, evidence preservation, or compliance monitoring. Returns full transaction history, linkage, and atomic detail fields.",
    "description": "Fetches a single transaction in detail based on its UUID identifier from PaymentsDiscounts.transactions. Output includes all atomic fields (user, order context, event time, notes) as required for audit, business, and regulatory needs. Every fetch operation is logged for evidence and compliance. This function is used by financial admins, auditors, integration/reporting clients, or operational tools that need to review individual transaction events, trace payment flows, or respond to regulatory inquiries. Missing or unauthorized queries trigger clear, evidence-traceable error responses.",
    "summary": "Get a transaction by ID (PaymentsDiscounts.transactions).",
    "parameters": [
      {
        "name": "id",
        "description": "Unique identifier of the transaction to retrieve.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Full transaction detail record.",
      "typeName": "ITransaction"
    },
    "path": "/shopping/transactions/{id}",
    "method": "get"
  },
  {
    "specification": "Create a new transaction record in PaymentsDiscounts.transactions, recording all required evidence and compliance data. Used for logging business events that create financial/payments flows, such as order checkout, wallet top-up, or manual adjustment. All creates are logged for compliance/evidence and subject to audit review. New transaction is linked to payment, order, and loyalty/rewards as required. Validations for atomicity, permissions, and privacy are enforced as per schema/business rules.",
    "description": "This endpoint creates a new transaction following PaymentsDiscounts.transactions and business logic compliance requirements. On invocation, permission and input validation are enforced, ensuring proper user context, transaction type, event notes, and compliance with regulatory traceability protocols. Creation events are logged and auditable, supporting operational analytics, downstream evidence analysis, risk/fraud monitoring, and compliant business record-keeping. On success, the transaction is available for linkage to payment, loyalty, refund, or reporting workflows. Common use cases include checkout flows, wallet management, loyalty programs, and event logging for compliance trails.",
    "summary": "Create a transaction (PaymentsDiscounts.transactions).",
    "parameters": [],
    "requestBody": {
      "description": "Details for the new transaction (user, type, event time, description, ...).",
      "typeName": "ITransaction.ICreate"
    },
    "responseBody": {
      "description": "Created transaction record.",
      "typeName": "ITransaction"
    },
    "path": "/shopping/transactions",
    "method": "post"
  },
  {
    "specification": "Update a transaction by its identifier in PaymentsDiscounts.transactions, allowing business correction, annotation, or compliance remediation. This updates only atomic, permissible fields (e.g., description, notes—not calculated summary values or identity fields). All modifications are evidence-logged and subject to permission/audit review. Previous values preserved for trace/audit compliance.",
    "description": "This endpoint updates a specific transaction within PaymentsDiscounts.transactions, modifying authorized, atomic attributes (such as description). On execution, the previous state of the record is preserved, and a complete audit trail is recorded. Strict permission and compliance checks are enforced—identity and crucial event markers cannot be changed post-creation. If the transaction doesn’t exist, a not found error is returned with evidence for audit. Used typically for admin-initiated corrections, operator annotation, or compliance review, supporting business transparency, regulatory requirements, and cross-module data integrity.",
    "summary": "Update an existing transaction by ID (PaymentsDiscounts.transactions).",
    "parameters": [
      {
        "name": "id",
        "description": "Unique identifier of the transaction to update.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": {
      "description": "Updates to atomic, non-identity transaction fields (e.g., description).",
      "typeName": "ITransaction.IUpdate"
    },
    "responseBody": {
      "description": "Updated transaction record.",
      "typeName": "ITransaction"
    },
    "path": "/shopping/transactions/{id}",
    "method": "put"
  },
  {
    "specification": "Delete a transaction record by ID from PaymentsDiscounts.transactions. This operation implements a logical (non-destructive, archival) deletion, maintaining evidence and audit chains per business and compliance requirements. Triggers a compliance/audit entry and preserves record for retrospective review, while removing it from active/operational flows. Active payment or business entity linkage may restrict deletion; errors are evidence-traced and clear. Only authorized actors (admins, auditors) may invoke this endpoint. Business traceability and error transparency enforced by design.",
    "description": "Deletes a particular transaction by its identifier from PaymentsDiscounts.transactions, archiving but not physically deleting the record for full evidence and compliance. All delete operations are permission-checked and generate audit trail entries for legal, regulatory, and operational review. Attempting to delete non-existent, protected, or required transactions will result in clear error responses with full audit context. Inactive transactions are unavailable for further business logic but remain queryable for retrospective audit. Business rules prohibit deletion of transactions critical to active payment flows or compliance/investigation context.",
    "summary": "Delete a transaction by ID (PaymentsDiscounts.transactions).",
    "parameters": [
      {
        "name": "id",
        "description": "Unique identifier of the transaction to delete.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": null,
    "path": "/shopping/transactions/{id}",
    "method": "delete"
  },
  {
    "specification": "Retrieve a paginated, filterable list of all vouchers managed by the commerce system, aligned with PaymentsDiscounts.vouchers. Provides search, filter, and audit capabilities necessary for financial control, operational analytics, and compliance. Supports customizable queries (by user, campaign, payment method, balance, or expiration) in accordance with regulatory, evidence, and business traceability needs. Only authorized parties may invoke the operation, and all requests are audit-logged.",
    "description": "This endpoint lists vouchers applying search, pagination, and filtering criteria as structured in the PaymentsDiscounts.vouchers schema, with full support for analytics, evidence preservation, and audit trails. Common filters include voucher owner, campaign context, redemption state, and validity periods. Business and regulatory use cases include reporting, campaign analysis, finance exports, or support operations. Every search operation is logged for compliance. Returned data allows subsequent drilldown, audit of voucher lifecycles, and cross-reference to payment, loyalty, and campaign modules. Permissions and privacy logic is enforced to restrict access by entity or role, as required by business or regulatory rules.",
    "summary": "Retrieve/search vouchers with filter and pagination (PaymentsDiscounts.vouchers).",
    "parameters": [],
    "requestBody": {
      "description": "Search and filter criteria for voucher listing (user, campaign, status, …).",
      "typeName": "IVoucher.IRequest"
    },
    "responseBody": {
      "description": "Paginated list of vouchers matching filter/search criteria.",
      "typeName": "IPageIVoucher"
    },
    "path": "/shopping/vouchers",
    "method": "patch"
  },
  {
    "specification": "Get detailed information for a single voucher resource using its unique identifier (UUID). This operation relates to the PaymentsDiscounts.vouchers table, providing all details of a specific voucher including ownership (user), associated campaign/payment method, code, balance, currency, timestamps, and lifecycle fields (e.g., expiration, redeemed state). The operation ensures only active, non-deleted vouchers are retrievable, supporting audit, compliance, and regulatory export requirements.",
    "description": "Retrieves full details about a single voucher resource by its ID (UUID) from the PaymentsDiscounts.vouchers database table. This includes all metadata such as owning user, campaign, payment method linkage, code, current and creation balance, currency, expiration date, timestamp audit fields, and redemption state.\n\nThis API endpoint requires permissions to access sensitive monetary and asset information and will validate the API caller’s RBAC permissions before returning data. Only non-deleted (active or redeemed) voucher entries are queried, in accordance with evidence and compliance standards.\n\nIf a voucher does not exist or the user lacks appropriate access, an error with a standardized message is returned. This endpoint enables external campaign systems, compliance tools, or user-facing mailbox/account operations to retrieve voucher asset data for an individual voucher.\n\nRelated operations are POST (create), PUT (update), DELETE (remove), and PATCH (search/list/vouchers).",
    "summary": "Retrieve the details for a single voucher (vouchers table) by ID.",
    "parameters": [
      {
        "name": "id",
        "description": "The unique identifier (UUID) for the target voucher.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "A full voucher record, including all asset tracking and compliance fields.",
      "typeName": "shoppingVouchers"
    },
    "path": "/shopping/vouchers/{id}",
    "method": "get"
  },
  {
    "specification": "Create a new voucher record (e.g., gift card, loyalty asset, promotional code) within the system. This operation targets the PaymentsDiscounts.vouchers table. It allows an authenticated and permissioned actor (via RBAC) to issue a new voucher with assignment (user, campaign, payment method), starting balance, currency, and time-bounded attributes (expiration/issue times).\n\nAll critical asset issuance operations are fully audited and evidence-preserved, supporting compliance with regulatory asset tracking, audit, customer notification, and business analytics.",
    "description": "Creates a new voucher entry in the PaymentsDiscounts.vouchers table, requiring all mandatory fields: user association (owner), optional campaign/payment method, unique code (not re-usable), initial balance, currency, and expiration.\n\nVouchers can be created for various asset types including loyalty, gift, refund, promotional, etc., with each creation event subject to audit and compliance checks. All inputs are strictly validated (unique code, valid balance/currency/compliance with organizational asset management policies). On success, a fully detailed voucher object is returned reflecting the new persisted asset.\n\nRelated endpoints include GET (retrieve), PUT (update), DELETE (mark as deleted/cancelled), and PATCH (list/search vouchers). All operations are subject to permission checks and audit event creation for evidence chains.",
    "summary": "Create a new voucher (vouchers table).",
    "parameters": [],
    "requestBody": {
      "description": "Required fields for voucher creation, including user, code, balance, and related asset metadata.",
      "typeName": "shoppingVouchers.ICreate"
    },
    "responseBody": {
      "description": "Details of the newly created voucher asset.",
      "typeName": "shoppingVouchers"
    },
    "path": "/shopping/vouchers",
    "method": "post"
  },
  {
    "specification": "Update a specific voucher record using its unique identifier (UUID). This operation updates the PaymentsDiscounts.vouchers table. It supports modifying allowed mutable fields (such as expiration, notes, or associated campaign/payment method) but never code, creation time, or original balance. Designed for admin or system-corrective action, all changes are evidence-preserved and fully audited for compliance.\n\nHandles asset modification events such as extending expiry, tagging to a different campaign, or adjusting user notes. Does not allow reactivating deleted or fully redeemed vouchers per evidence integrity requirements.",
    "description": "Updates mutable fields for an existing voucher, identified by its unique ID (UUID), in the vouchers table. Immutable attributes (original user, code, and balance on issue) cannot be changed.\n\nAll updates are permission checked and audited against organizational change management and asset compliance policies. Typical usages include extending expiry, correcting payment method, or adding/removing links to campaigns. Any update attempt on a deleted or redeemed voucher (logical removal state) is rejected with a clear, standardized error.\n\nRelated endpoints are GET (single asset), POST (new asset), DELETE (mark as deleted), PATCH (search/list). All actions create auditable evidence in accordance with compliance/tracking requirements.",
    "summary": "Update an existing voucher by ID (vouchers table).",
    "parameters": [
      {
        "name": "id",
        "description": "The unique identifier (UUID) of the voucher record to update.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": {
      "description": "Fields permitted for voucher update, such as new expiration, campaign, or optional metadata.",
      "typeName": "shoppingVouchers.IUpdate"
    },
    "responseBody": {
      "description": "Updated voucher record as persisted.",
      "typeName": "shoppingVouchers"
    },
    "path": "/shopping/vouchers/{id}",
    "method": "put"
  },
  {
    "specification": "Delete (soft-remove) a voucher asset by its unique identifier (UUID), as recorded in PaymentsDiscounts.vouchers. Inactivates the voucher by setting the deleted_at timestamp (never hard deletes), preserving evidence trails for compliance, audit, and regulatory export. This endpoint is used to retire/cancel vouchers that are unused, compromised, or expired according to business processes.",
    "description": "Marks a specific voucher as deleted (soft-delete) using its unique ID (UUID), by updating the deleted_at timestamp. This operation disables any further redemption or update to the voucher; all subsequent retrievals or operations will indicate the voucher is deleted or unavailable.\n\nAccess to this operation is gated with fine RBAC controls; only actors with appropriate privileges may revoke/cancel voucher assets. All delete actions are fully auditable, creating evidence records in compliance with regulatory and business requirements.\n\nPossibly related: POST (new asset), PUT (update), GET (retrieve), PATCH (search/list vouchers).",
    "summary": "Delete (soft-remove/mark as deleted) a voucher asset by ID.",
    "parameters": [
      {
        "name": "id",
        "description": "Unique identifier (UUID) for the voucher record to mark as deleted.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "The full voucher resource as of deletion, including audit metadata.",
      "typeName": "shoppingVouchers"
    },
    "path": "/shopping/vouchers/{id}",
    "method": "delete"
  },
  {
    "specification": "Search, filter, and paginate through all loyalty points ledger entries (loyalty_points table). This PATCH operation enables retrieval of points transactions for usage history, balance computation, regulatory export, and analytics, supporting an omnichannel and AI-personalization context.",
    "description": "Returns a list of loyalty points transactions from the PaymentsDiscounts.loyalty_points table. Supports advanced filtering (date ranges, type, campaign, user, transaction), multi-field text search, sort (by date, points, type), and paginated response structures.\n\nPermissions are required to view loyalty assets and data are filtered according to caller’s access context (admin/user/self/partner). Each entry includes transaction details (type, value, timestamp, campaign, transaction/event linkage) as required for audit, account balance reconciliation, and compliance evidence preservation.\n\nRelated endpoints: GET (single entry), POST (record accrual), PUT (update correction), DELETE (soft-remove for audit). Returns both the paginated page info and points data array. Serves analytics, compliance, loyalty, and customer support use cases.",
    "summary": "List, search, and paginate loyalty points ledger entries (loyalty_points table).",
    "parameters": [],
    "requestBody": {
      "description": "Filter/search/sort/pagination parameters for loyalty points listing.",
      "typeName": "shoppingLoyaltyPoints.IRequest"
    },
    "responseBody": {
      "description": "Paginated results of loyalty points events, as specified by query and filters.",
      "typeName": "IPageShoppingLoyaltyPoints"
    },
    "path": "/shopping/loyaltyPoints",
    "method": "patch"
  },
  {
    "specification": "Retrieve details for a single loyalty points ledger entry using its unique identifier (UUID). Accesses PaymentsDiscounts.loyalty_points, showing all record fields including point value, linked user, origin transaction, campaign, event type, and evidence timestamps.",
    "description": "Fetches a specific loyalty point entry from the loyalty_points table by its unique ID. Returns all record fields including user, transaction, campaign, event type, points value, timestamp, supporting account & regulatory reconciliation, analytics, and evidence-preserved history.\n\nConsiders permissions to ensure only authorized actors may retrieve specific records; errors are standardized for not found or forbidden access cases. Related endpoints: PATCH (search/list), POST (accrue new), PUT (correction), DELETE (mark deleted).",
    "summary": "Retrieve a single loyalty point entry (loyalty_points table) by ID.",
    "parameters": [
      {
        "name": "id",
        "description": "Unique identifier (UUID) for the loyalty points ledger entry.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "The full details of the specified loyalty point event.",
      "typeName": "shoppingLoyaltyPoints"
    },
    "path": "/shopping/loyaltyPoints/{id}",
    "method": "get"
  },
  {
    "specification": "Create a new loyalty point ledger entry (accrual, redemption, admin adjustment) in PaymentsDiscounts.loyalty_points. Supports all earning, redemption, or bonus point events per requirements. All entries are audited, evidence-preserved, with compliance to loyalty program, user, and campaign context.",
    "description": "Creates a new loyalty points event—accrual, redemption, bonus or adjustment—in the loyalty_points table. Requires structured request specifying user, points, type (e.g., 'earn', 'redeem'), timestamp, and relevant campaign/transaction.\n\nStrict validation occurs for loyalty policy compliance (no negative/illegal accruals), campaign/rule linkage, and evidence trail preservation for each transaction. Upon success, returns the full point event object as stored in the ledger (with audit metadata).\n\nRelated endpoints: PATCH (list/search), GET (single entry), PUT (correction), DELETE (cancel). Used by loyalty, account management, compliance, and analytics modules.",
    "summary": "Create a new loyalty point ledger entry (loyalty_points table).",
    "parameters": [],
    "requestBody": {
      "description": "Fields required for new loyalty points event—user, value, type, associated campaign/event context.",
      "typeName": "shoppingLoyaltyPoints.ICreate"
    },
    "responseBody": {
      "description": "Details of the created loyalty points entry.",
      "typeName": "shoppingLoyaltyPoints"
    },
    "path": "/shopping/loyaltyPoints",
    "method": "post"
  },
  {
    "specification": "Update an existing loyalty points ledger entry by ID, as stored in PaymentsDiscounts.loyalty_points, supporting legitimate corrections of evidence/audit errors (e.g., admin fix, points adjustment for post-fact correction). All updates are audit-logged and subject to RBAC and compliance rules.",
    "description": "Updates mutable fields for a single loyalty points ledger entry (identified by its unique ID/UUID), such as event type or campaign association, as permitted by business workflow, audit, and compliance requirements. All changes are logged for evidence chains.\n\nImmutable or business-critical audit fields (initial value, user) cannot be changed post-entry. Reverts or over-adjustment attempts are rejected with standardized error messaging, following data preservation and audit chain logic.\n\nReturns the updated loyalty points record as evidence and for subsequent analytics/use. Related: PATCH (list), GET (retrieve), POST (create), DELETE (logical removal).",
    "summary": "Update a loyalty points event by ID (loyalty_points table).",
    "parameters": [
      {
        "name": "id",
        "description": "Unique identifier (UUID) for the loyalty point event entry to update.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": {
      "description": "Fields for permitted updates (may be business-limited), e.g., campaign or event type correction.",
      "typeName": "shoppingLoyaltyPoints.IUpdate"
    },
    "responseBody": {
      "description": "Updated loyalty points event, as persisted.",
      "typeName": "shoppingLoyaltyPoints"
    },
    "path": "/shopping/loyaltyPoints/{id}",
    "method": "put"
  },
  {
    "specification": "Delete a loyalty points ledger entry (soft-delete for audit/evidence preservation) by its unique identifier (UUID) in PaymentsDiscounts.loyalty_points. This disables/cancels the effect of the record but preserves historical evidence for regulatory/Audit compliance.",
    "description": "Marks a single loyalty points event as deleted (by setting deleted_at or equivalent logical flag) in the loyalty_points table, using its unique ID (UUID). No physical data removal is permitted; all changes are evidence-preserving and audited in compliance with regulatory requirements.\n\nA deleted/cancelled event becomes ineligible for balance calculation or further operations. Only RBAC-permitted administrators may invoke this endpoint. Attempting to re-delete, or delete non-existent/locked events is rejected with a compliance-aligned error.\n\nReturns the state of the event as of deletion for audit/reporting purposes. Related endpoints: PATCH (list), GET (fetch), POST (new), PUT (update).",
    "summary": "Delete (soft-remove/cancel) a loyalty points event by ID (loyalty_points table).",
    "parameters": [
      {
        "name": "id",
        "description": "Unique identifier (UUID) for the loyalty point entry to logically delete/cancel.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Deleted/cancelled loyalty point record (audit preserved).",
      "typeName": "shoppingLoyaltyPoints"
    },
    "path": "/shopping/loyaltyPoints/{id}",
    "method": "delete"
  },
  {
    "specification": "List, search, filter, and paginate refund records from the PaymentsDiscounts.refunds entity. This PATCH operation supports rich query (by transaction, order, payment, date, status, etc.), multi-field search/sort, pagination. Returns immutable evidence records in accordance with audit, compliance, and reconciliation requirements for refunds.",
    "description": "Retrieves a paginated, filtered list of refunds from the refunds table, allowing clients to specify search, date, order, transaction, and type filters. Each refund includes payment, transaction, order (if applicable), amounts, status, notes, and evidence timestamps.\n\nOnly permitted actors (per RBAC) can query refund events, and all results are returned with the necessary evidence fields for compliance, reconciliation, and legal queries. Results structure includes both page info and refund data.\n\nRelated endpoints: GET (single), POST (new refund), PATCH (search/filter), DELETE (if allowed). Used for finance, customer support, audit, and compliance reporting.",
    "summary": "Search, filter, and paginate refund records (refunds table).",
    "parameters": [],
    "requestBody": {
      "description": "Filter/search/pagination parameters for refund event listing.",
      "typeName": "shoppingRefunds.IRequest"
    },
    "responseBody": {
      "description": "Paginated results of refund events, per filters.",
      "typeName": "IPageShoppingRefunds"
    },
    "path": "/shopping/refunds",
    "method": "patch"
  },
  {
    "specification": "Retrieve a single refund event by its unique identifier (UUID) from the PaymentsDiscounts.refunds table. Provides full atomic details including amounts, payment, status, linkage to transactions, orders, timestamps, and regulatory-compliance evidence fields for audit and forensic analysis. Errors for not found/inaccessible events are standardized.",
    "description": "Returns a detailed refund information record given its unique ID (UUID). Shows all fields as stored in refunds, including linkage to payment, order, transaction, user, amount, status/state, notes, timestamps for request and processing, and all audit-relevant evidence as required for compliance.\n\nPermissions and access context are checked for each request. Provisioning is made for customer/accounting, legal, or compliance queries.\n\nRelated: PATCH (list/search), POST (initiate), DELETE (if permitted).",
    "summary": "Retrieve a single refund event (refunds table) by ID.",
    "parameters": [
      {
        "name": "id",
        "description": "Unique identifier (UUID) for the refund record to fetch.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "The full refund event details as stored, including all evidence fields.",
      "typeName": "shoppingRefunds"
    },
    "path": "/shopping/refunds/{id}",
    "method": "get"
  },
  {
    "specification": "Initiate a new refund event, recording refund of payment/transaction/order in the PaymentsDiscounts.refunds table. This operation audits all critical refund event details (who, what payment/order, amounts, reason, timestamps), marks status, and ensures compliance with financial legal/audit standards. Automatic evidence chain entry created for each refund record.",
    "description": "Creates a new refund record corresponding with a payment, transaction, and optionally an order, with details including refund amount, currency, linked objects, notes, and request timestamp.\n\nValidation checks for refund eligibility, payment/transaction state, permission controls, and evidence preservation are performed. Result is the persisted refund record with full audit trail information for compliance, legal, and business processes. Redundant or duplicate refund attempts are rejected with a clear error, supporting idempotency as required.\n\nRelated endpoints include PATCH (list/search), GET (fetch one), DELETE (if allowed), PUT (update for possible status correction).",
    "summary": "Create a new refund event (refunds table).",
    "parameters": [],
    "requestBody": {
      "description": "All required fields for refund creation—payment, order, transaction, amount, currency, status/type, notes.",
      "typeName": "shoppingRefunds.ICreate"
    },
    "responseBody": {
      "description": "Persisted refund record with audit evidence fields.",
      "typeName": "shoppingRefunds"
    },
    "path": "/shopping/refunds",
    "method": "post"
  },
  {
    "specification": "Update an existing refund record in the system. Associated with the 'refunds' table of the PaymentsDiscounts module. Allows modification of refund data for compliance (such as status transitions, reason updates, or modification of linked audit data), ensuring evidence preservation, auditability, and regulatory requirements. Only fields that are allowed to be updated per business and compliance rules can be modified; original creation and financial integrity fields remain immutable. This operation must be logged for audit purposes, and any update must retain the full trace of previous values (soft update model).\n\nSecurity: Only authorized payment operations or compliance staff can invoke this.\n\nValidation: ID must exist; business logic ensures refund state transition is legal. Error if refund cannot be found or is immutable.\n\nOther APIs: For a list of refunds, see PATCH /shopping/refunds. To create, use POST /shopping/refunds.",
    "description": "Updates an existing refund record in the refunds table. Applicable for changing status, reason, or compliance flags. Immutable financial values cannot be modified. The operation is logged for non-repudiation and evidence preservation. Calls must be authorized and all changes must comply with audit requirements. Returns an updated refund object on success, or an error if the refund does not exist or cannot be updated due to business or regulatory rules.",
    "summary": "Update a refund record in the refunds table (PaymentsDiscounts).",
    "parameters": [
      {
        "name": "id",
        "description": "Target refund's ID.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": {
      "description": "Refund data to update (status, reason, or compliance fields).",
      "typeName": "shoppingRefunds.IUpdate"
    },
    "responseBody": {
      "description": "Updated refund data after modification.",
      "typeName": "shoppingRefunds"
    },
    "path": "/shopping/refunds/{id}",
    "method": "put"
  },
  {
    "specification": "Delete (soft-delete) a refund record from the 'refunds' table in the PaymentsDiscounts module. This operation implements compliance requirements for evidence preservation: physical deletion is not allowed—deletion only sets a deleted_at timestamp or equivalent soft-delete field. Regulatory traces, audit logs, and financial integrity must be maintained for post-deletion inquiry, forensics, and compliance reporting.\n\nSecurity: Only users with the correct privileges (e.g., payments admin, compliance auditor) may perform this action.\n\nDependencies: Operation must be non-destructive and revertible; deleted refunds must be retrievable from audit logs. Will fail if refund does not exist or is already marked deleted.\n\nRelated APIs: Use PATCH /shopping/refunds for listing/restore operations, POST /shopping/refunds to create, PUT /shopping/refunds/{id} to update.",
    "description": "Soft-deletes a refund record by marking it deleted (not physical deletion). Maintains evidence and audit trail for financial and compliance purposes. Attempts to delete refunds which do not exist or are already deleted will return an error. Only authorized users may perform this action. Returns the deleted refund data including soft-delete timestamp.",
    "summary": "Soft-delete a refund record in the refunds table (PaymentsDiscounts).",
    "parameters": [
      {
        "name": "id",
        "description": "Target refund's ID.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Deleted refund record (soft deleted with timestamp).",
      "typeName": "shoppingRefunds"
    },
    "path": "/shopping/refunds/{id}",
    "method": "delete"
  },
  {
    "specification": "List or search payment audit records in the payment_audits table for evidence tracking, compliance, and analysis. Allows for advanced filtering, sorting, and pagination based on audit fields such as entity_type, entity_id, action, timestamp, or the user who performed the action. Implements evidence chain, compliance audit, and forensics requirements. The operation must ensure that no sensitive financial or identity information is exposed unless user is authorized.\n\nSecurity: Accessible to auditing, compliance, or finance roles only. Input must be validated for filtering/sorting fields.\n\nDependencies: Used alongside GET, POST, PUT, and DELETE /shopping/paymentAudits endpoints for individual record operations.",
    "description": "Fetches a filtered, paginated list of payment audit records, supporting advanced search on action type, entity, result, or user. Ensures evidence preservation and supports compliance audit requirements. Pagination and sorting available. Only authorized users may access, and all queries are logged for audit. Returns a paged result set of paymentAudit summary data.",
    "summary": "Search/list payment_audit records (evidence tracking for PaymentsDiscounts).",
    "parameters": [],
    "requestBody": {
      "description": "Query and filtering parameters for payment audits (pagination, filters, sorting).",
      "typeName": "shoppingPaymentAudits.IRequest"
    },
    "responseBody": {
      "description": "Paginated result of payment audit summary records.",
      "typeName": "IPageShoppingPaymentAudits"
    },
    "path": "/shopping/paymentAudits",
    "method": "patch"
  },
  {
    "specification": "Get detailed information for a single payment audit record, as stored in the payment_audits table in the PaymentsDiscounts module. Supports compliance, forensics, and financial event tracking. Returns all audit details, including references to users, target entity, previous and new values, and the full evidence chain of changes.\n\nSecurity: Only authorized auditing, compliance, or finance staff may invoke this endpoint. If the audit ID does not exist, an error is returned.\n\nRelated endpoints: PATCH /shopping/paymentAudits for list/search, POST /shopping/paymentAudits for creating new audit records, PUT /shopping/paymentAudits/{id} for updates.",
    "description": "Retrieves all details of a payment audit record from the payment_audits table. Includes user, target entity, action, before/after values, evidence of action, and timestamp. Only authorized staff may access. Returns the complete audit record or error if not found.",
    "summary": "Get a payment audit record (PaymentsDiscounts evidence tracking).",
    "parameters": [
      {
        "name": "id",
        "description": "Target payment audit record's ID.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Payment audit record with all details.",
      "typeName": "shoppingPaymentAudits"
    },
    "path": "/shopping/paymentAudits/{id}",
    "method": "get"
  },
  {
    "specification": "Create a new payment audit record in the payment_audits table for the PaymentsDiscounts module. This operation logs critical changes, state transitions, or actions in the payment, discount, refund, or voucher flows. Ensures evidence preservation and compliance by logging details such as old/new value, user, timestamp, and action type. All records must be immutable, with any downstream changes recorded as new audit events, not edits.\n\nSecurity: Only system processes or privileged finance/audit users may invoke this API. Input data must be validated.\n\nDependencies: Used alongside PATCH, GET, PUT, DELETE /shopping/paymentAudits endpoints for full audit flow coverage.",
    "description": "Creates a new payment audit record, logging a critical change or event in payment/discount/refund/voucher flows. Once created, record is immutable. Supports evidence preservation and forensics. Returns the created audit record with all relevant details.",
    "summary": "Create a payment audit record (PaymentsDiscounts evidence/audit system).",
    "parameters": [],
    "requestBody": {
      "description": "Details of the audit record to create (action, entity reference, user, before/after values, etc).",
      "typeName": "shoppingPaymentAudits.ICreate"
    },
    "responseBody": {
      "description": "Newly created payment audit record.",
      "typeName": "shoppingPaymentAudits"
    },
    "path": "/shopping/paymentAudits",
    "method": "post"
  },
  {
    "specification": "Update a single payment audit record in the payment_audits table for the PaymentsDiscounts module. Used rarely; in most systems, audit records are immutable, but certain metadata or soft-correctable fields may be updated by compliance staff (such as notes, correction flags). Any state or evidence-altering changes must result in a new audit record rather than update. Only specific updates are allowed per compliance policy; input validated accordingly.\n\nSecurity: Only compliance/audit staff may update. Action is logged as a separate audit event.\n\nDependencies: Used for correcting or annotating audit records, not altering original evidence/content. PATCH /shopping/paymentAudits for searching/listing.",
    "description": "Updates a payment audit record. Only correction, metadata, or compliance fields can be edited. All original evidence is preserved; changes are tracked as new audit chain. Attempts to modify immutable fields result in error. Returns updated payment audit record if successful.",
    "summary": "Update a payment audit record (metadata/compliance, PaymentsDiscounts).",
    "parameters": [
      {
        "name": "id",
        "description": "Target payment audit record ID.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": {
      "description": "Editable fields for payment audit record (correction, compliance annotation, etc).",
      "typeName": "shoppingPaymentAudits.IUpdate"
    },
    "responseBody": {
      "description": "Payment audit record after allowable update.",
      "typeName": "shoppingPaymentAudits"
    },
    "path": "/shopping/paymentAudits/{id}",
    "method": "put"
  },
  {
    "specification": "Delete (soft-delete) a payment audit record in the payment_audits table. Actual physical deletion is not allowed due to evidence retention, compliance, and regulatory audit requirements. Operation only sets a deletion flag or timestamp, maintaining all audit data for review and forensics.\n\nSecurity: Only authorized compliance or system admin staff can perform this. Operation is itself logged as an audit event.\n\nRelated endpoints: PATCH /shopping/paymentAudits for list/search, POST /shopping/paymentAudits for create, PUT /shopping/paymentAudits/{id} for updates.",
    "description": "Soft-deletes a payment audit record, preserving all data but marking as deleted for future evidence review. No physical deletion. Attempts to delete non-existing or already deleted records return error. Action is logged for audit compliance. Returns deleted record including deletion timestamp.",
    "summary": "Soft-delete a payment audit record (PaymentsDiscounts evidence retention).",
    "parameters": [
      {
        "name": "id",
        "description": "Target payment audit record's ID.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Soft-deleted payment audit record with deletion metadata.",
      "typeName": "shoppingPaymentAudits"
    },
    "path": "/shopping/paymentAudits/{id}",
    "method": "delete"
  },
  {
    "specification": "List/search all message threads in the message_threads table for the CommunicationReview module. Implements advanced search, filtering, and paging for messaging systems (customer support, order comms, general user chat). Returns brief thread summary and relevant metadata: subject, creator, archive status, created/updated timestamps, and participant references. Only authorized users (participant or admin/support roles) can search threads using this endpoint.\n\nSecurity: Query parameters validated; result set filtered to match user's permitted message threads.\n\nDependencies: Used alongside POST (create), GET (detail), PUT (update), DELETE (archive) endpoints for full thread lifecycle.",
    "description": "Fetches a filtered list of message threads. Supports search by subject, participant, creation/update time, and archive status. Pagination and sorting implemented. Result set only returns threads user is permitted to view. Returns a paginated collection of thread summaries.",
    "summary": "List/search message threads (CommunicationReview module).",
    "parameters": [],
    "requestBody": {
      "description": "Filtering, paging, and sort options for threads search.",
      "typeName": "shoppingMessageThreads.IRequest"
    },
    "responseBody": {
      "description": "Paginated result of message thread summaries.",
      "typeName": "IPageShoppingMessageThreads"
    },
    "path": "/shopping/messageThreads",
    "method": "patch"
  },
  {
    "specification": "Get detailed information for a specific message thread from the message_threads table in the CommunicationReview module. Provides full thread details: subject, creator, participants, archive flag, creation/update, and relationship to contained messages. Used for direct user inbox, support center, messaging features. Security: Access restricted to thread participants or system admin/support staff. Returns all thread data and summary of contained messages (without all full message bodies—see separate messages API for full content).\n\nValidation: Returns error if thread does not exist or user lacks access privileges.\n\nDependencies: Used with PATCH /shopping/messageThreads for list, POST for creating, PUT for updating thread info.",
    "description": "Fetches complete details of a single message thread, including metadata, participants, and summary data. Only thread participants or authorized staff may access. Does not return all messages; use messages API for in-thread details. Returns error if not found or unauthorized.",
    "summary": "Get message thread details (CommunicationReview module).",
    "parameters": [
      {
        "name": "id",
        "description": "Target message thread's ID.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Message thread with all details and metadata.",
      "typeName": "shoppingMessageThreads"
    },
    "path": "/shopping/messageThreads/{id}",
    "method": "get"
  },
  {
    "specification": "Create a new message thread in the message_threads table within the CommunicationReview module. Implements compliance, evidence, and communication structure requirements: every thread groups related messages and tracks creation, subject, participants, and archival status. Used by customer support, user-to-user messaging, or system automation. All new thread creation events must be logged for audit. Thread is created with subject, optional participants, and initial metadata.\n\nSecurity: Only authenticated users or support agents may create threads.\n\nValidation: Input data verified for required fields (subject, participant(s)).\n\nRelated: Use PATCH for search, GET for details, PUT for updating, and DELETE for archiving.",
    "description": "Creates a new message thread. Requires subject and creator; may specify initial participants. Outcome is logged in the evidence/audit log. Returns the created thread record with all metadata and unique thread ID.",
    "summary": "Create a new message thread (CommunicationReview module).",
    "parameters": [],
    "requestBody": {
      "description": "Message thread creation info (subject, participants, optional metadata).",
      "typeName": "shoppingMessageThreads.ICreate"
    },
    "responseBody": {
      "description": "The created message thread with all details.",
      "typeName": "shoppingMessageThreads"
    },
    "path": "/shopping/messageThreads",
    "method": "post"
  },
  {
    "specification": "Update an existing message thread record in the message_threads table (CommunicationReview module). Used for changing subject, archive status, or participant info (where permitted). All edit operations must preserve previous version for audit/evidence (soft update; audit chain maintained). Most edits limited to the thread creator, participant, or admin/support staff. Only thread metadata can be edited—messages themselves are not updated via this API.\n\nSecurity: Only the creator, participants, or staff with permission may update. All changes must be logged for evidence/compliance.\n\nRelated: Use PATCH for list, GET for details, POST for thread creation, DELETE for archiving.",
    "description": "Updates a message thread's metadata (subject, archive status, participants where allowed). Original creation and evidence fields cannot be changed. All edits are audit-logged for evidence preservation and compliance. Returns the updated message thread record, or error if not permitted or not found.",
    "summary": "Update message thread metadata (CommunicationReview module).",
    "parameters": [
      {
        "name": "id",
        "description": "Target message thread's ID.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": {
      "description": "Fields and values to update in the message thread (subject, archive status, participant info).",
      "typeName": "shoppingMessageThreads.IUpdate"
    },
    "responseBody": {
      "description": "Updated thread record after compliant metadata change.",
      "typeName": "shoppingMessageThreads"
    },
    "path": "/shopping/messageThreads/{id}",
    "method": "put"
  },
  {
    "specification": "Delete or archive a message thread record in the message_threads table for the CommunicationReview module. This operation does not physically delete the thread; instead, it marks the thread as archived/preserved for evidence retention, supporting audit, compliance, and legal hold requirements. All actions are logged. Only participants or compliance/support staff with sufficient privilege may archive threads. Physically deleted records are never allowed; archived threads must always be retrievable for evidence compliance.\n\nValidation: Fails if thread is not found or user lacks privilege. Archive timestamp or flag is set.\n\nRelated: PATCH for search, GET for details, POST for create, PUT for update of thread info.",
    "description": "Deletes or archives a message thread by setting archived status/flag. Physical deletion is not performed; the thread remains retrievable for audit/evidence. Only authorized users may perform this action. Attempts to delete non-existent or already archived records return error. Returns the updated thread record (with archive status/metadata).",
    "summary": "Archive or soft-delete a message thread (CommunicationReview module).",
    "parameters": [
      {
        "name": "id",
        "description": "Target message thread's ID.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Archived/deleted thread record (with archive flag/timestamp).",
      "typeName": "shoppingMessageThreads"
    },
    "path": "/shopping/messageThreads/{id}",
    "method": "delete"
  },
  {
    "specification": "Retrieve a paginated list of message records. This operation covers advanced filtering, sorting, and searching of messages for the shopping mall system, using the messages table in the CommunicationReview domain. The operation allows AI-driven and user-defined filtering, multi-channel support, evidence preservation fields, and supports future extensibility for multilingual and accessibility metadata. Supports querying by sender, recipient, message type (user, system, notification), archived state, sent/read timestamp ranges, and content-based full-text search. Pagination, ordering by sent_at or thread association, and inclusion of additional flags for AI moderation status are supported. AI-native backends may include explainable sorting strategies derived from sentiment analysis or recommendation preferences. Data returned is always subject to privacy controls and only includes records current user is authorized to view. 3NF integrity—never leaks deleted content, only postponed or archived markers remain for audit/analytics.",
    "description": "This API retrieves a list of messages, with extensive support for search and filtering based on CommunicationReview.messages schema: id (PK), thread_id, sender_user_id, parent_message_id, content, message_type, sent_at, read_at, archived. Each record contains atomic details suitable for AI-driven analytics, evidence preservation, and compliance. Advanced parameters allow clients to search by sender, message type, thread, sent/read/archived status, sent_at/read_at ranges, and full-text content (using trigram or vector search). Sorting is flexible: by sent_at, read status, relevance, or by ML model-inferred importance. Security: Only messages where user has access (thread participant or admin) are included; sensitive fields protected automatically. AI native usage: search/sort may return explainable metadata for ranking rationale when available. Error handling includes forbidden, invalid parameters, db timeouts, and data privacy exceptions. Typically used to power chat UIs, support inboxes, or admin consoles; may be consumed by AI/ML services for personalized recommendations or workflow automation.",
    "summary": "Retrieve a paginated and filterable list of messages from the messages table (CommunicationReview domain).",
    "parameters": [],
    "requestBody": {
      "description": "Message search, filter, pagination and sorting parameters.",
      "typeName": "shoppingMessage.IRequest"
    },
    "responseBody": {
      "description": "Paginated and filterable list of messages with full evidence fields, sorted as requested.",
      "typeName": "shoppingPageMessage"
    },
    "path": "/shopping/messages",
    "method": "patch"
  },
  {
    "specification": "Retrieve the detail of a specific message by its unique identifier from the messages table in the CommunicationReview domain. This operation is key for displaying a single message record, including all atomic fields necessary for evidence, compliance, and AI-native analytics. Supports authorization logic to prevent leaks of sensitive or private communication; access is only allowed if the requester is a message participant, admin/mod, or system. The returned content includes thread context, full message, archiving state, and references to parent/thread for hierarchical conversations. AI-driven explainable metadata (such as sentiment score, toxicity flag, or model rationale) may be included if available. Designed for full compliance and audit readiness: does not return deleted messages, and always includes evidence of archival or moderation events affecting the specified message.",
    "description": "Fetch the detailed record for a single message, based on the messages (CommunicationReview domain) schema: id (PK), thread_id, sender_user_id, parent_message_id, content, message_type, sent_at, read_at, archived. The API includes full original message payload, context about the thread if relevant, references to parent/child messages, and audit flags for archival or moderation. AI-native platforms may augment response with sentiment analysis and moderation data when available. Authorization is enforced at backend; only allowed users may retrieve. Error handling returns not found or forbidden if message does not exist or access is not permitted. This endpoint ensures all required evidence fields for compliance and includes extensible fields for future analytics or explanation.",
    "summary": "Fetch the details of a single message by ID from the messages table (CommunicationReview domain).",
    "parameters": [
      {
        "name": "id",
        "description": "The message's unique identifier to retrieve.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "A single message with all evidence and compliance fields.",
      "typeName": "shoppingMessage"
    },
    "path": "/shopping/messages/{id}",
    "method": "get"
  },
  {
    "specification": "Create a new message record in the messages table, CommunicationReview domain. Supports user-generated, system, or notification messages with all atomic fields needed for strict audit and evidence preservation, including optional hierarchical threading. Accepts all required fields: thread_id, sender_user_id, content, message_type, sent_at; and optionally, parent_message_id and read_at. AI-native backends enable submission of AI-moderation reasoning or origin flags, in cases of system auto-messages. The operation enforces validations: required fields, participant permissions, thread access, and compliance checks. All created messages are strictly audited and archived for non-repudiation and privacy. Audit/data lineage is attached on creation for regulatory and evidence needs.",
    "description": "Creates a new message in the messages table (CommunicationReview domain): id (generated), thread_id, sender_user_id, parent_message_id (optional), content, message_type, sent_at, read_at (optional). Message type enforces business rules: 'user', 'system', or 'notification'. Backend validations ensure sender has permission to post into thread, thread is not archived or closed, and input content passes anti-abuse and privacy standards. AI-native logic may trigger explainable moderation or evidence capture at creation. All atomic fields and audit metadata are included in the response. Errors include forbidden, bad request, moderation reject, or backend validation failure.",
    "summary": "Create a new message in the messages table (CommunicationReview domain).",
    "parameters": [],
    "requestBody": {
      "description": "New message creation details (content, thread, sender, message type, etc).",
      "typeName": "shoppingMessage.ICreate"
    },
    "responseBody": {
      "description": "Created message record with evidence fields and audit metadata.",
      "typeName": "shoppingMessage"
    },
    "path": "/shopping/messages",
    "method": "post"
  },
  {
    "specification": "Update (replace) a message record by its unique ID, supporting full-field replacement according to CommunicationReview.messages table. This operation is used for admin/moderator, system, or privileged user correction of message content, or for rectifying errors flagged by audit/compliance. Includes all atomic fields of the standard message record, enforces permissions (only author/admin allowed), and ensures evidence preservation of the original content via immutable audit log. Validates updates for thread membership, parent hierarchy, and content moderation rules. Strictly compliant: cannot be used to resurrect archived or deleted messages; instead, a separate recovery/audit workflow would apply. AI-native backends may require model explainability on update if message is auto-moderated or corrected.",
    "description": "Replaces a message by ID, referencing the CommunicationReview.messages schema: id (PK), thread_id, sender_user_id, parent_message_id (optional), content, message_type, sent_at, read_at (optional), archived (auto-managed). Validations enforce that only the original author or an admin may perform updates, and that changes are auditable with evidence preservation protocols. Updated messages trigger archival of previous data and generate an audit event, including parent/child context if relevant. AI/ML explainability metadata can be attached. Errors returned include not found, permission denied, validation errors, or attempted update of archived/deleted message.",
    "summary": "Update a message by its ID in the messages table (CommunicationReview domain), preserving audit flow and evidence.",
    "parameters": [
      {
        "name": "id",
        "description": "The target message record's unique UUID.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": {
      "description": "Complete message data to replace the record; all required fields must be included.",
      "typeName": "shoppingMessage.IUpdate"
    },
    "responseBody": {
      "description": "Updated message record with new audit and evidence fields.",
      "typeName": "shoppingMessage"
    },
    "path": "/shopping/messages/{id}",
    "method": "put"
  },
  {
    "specification": "Delete (archive) a message by its unique ID, supporting soft-delete archival for audit and evidence preservation. This operation reflects the compliance-first requirement that messages are never fully deleted from the system storage, but are only flagged as archived—enabling immutable audit trails. Only sender or moderator/admin may perform this operation. On invocation, marks record as archived, sets archived flag and optionally archives related content (replies, attachments) subject to retention logic. Compliance mandates audit log is generated for every deletion, with context around actor, reason, and preservation chain. Not permitted for messages already deleted/archived.",
    "description": "Logically deletes (archives) a message by setting the archived flag in the messages table (CommunicationReview domain). Enforces authorization checks: only sender, moderator, or admin can perform. Attempts to delete already-archived or non-existent records cause error. Related atomic fields: id, thread_id, sender_user_id, parent_message_id, content, message_type, sent_at, read_at, archived. Audit and evidence flow triggered for every archival. AI-native backends may return compliance/explainability fields. All archival operations are appended to audit log. Errors include forbidden, already archived, or not found.",
    "summary": "Archive (soft-delete) a message in the messages table (CommunicationReview domain), preserving compliance.",
    "parameters": [
      {
        "name": "id",
        "description": "The message record's unique UUID to be archived.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Archived message record, complete with audit and evidence fields.",
      "typeName": "shoppingMessage"
    },
    "path": "/shopping/messages/{id}",
    "method": "delete"
  },
  {
    "specification": "Retrieve a paginated and filterable list of notifications in the CommunicationReview.notifications table. Enables AI-native, evidence-traceable filtering by type (system, message, promotion), user, thread, sent/read/archived status, and content keyword. Supports robust pagination, sorting by sent_at/read_at, ML-driven ordering where available, and full audit compliance. Content always filtered for privacy and role-based access—only the recipient or system/admin may see. AI explainability and evidence fields can be included when requested, e.g., why a notification is urgent or prioritized. Returned fields include all atomic notification details and extensible fields for audit and analytic capabilities. Fully compliant with audit log and privacy controls.",
    "description": "Lists notifications for the authenticated user or admin, based on the CommunicationReview.notifications schema: id (PK), user_id, thread_id, notification_type, content, sent_at, read_at, archived. Supports full-text and trigram content search, filtering by notification_type, date ranges, read/archive state, and thread context. Pagination and sorting options include sent_at, priority, and ML/AI-driven ranking. Enforces strict privacy: only notifications for/owned by requestor are shown, unless admin override is present. AI-model or compliance fields may be included for evidence/traceability. Errors: access denied, invalid filters, system/db errors. Fully auditable results, with immutable query evidence for compliance logs.",
    "summary": "Retrieve a paginated and filterable list of notifications from the notifications table (CommunicationReview domain).",
    "parameters": [],
    "requestBody": {
      "description": "Notification search, pagination, and filter parameters.",
      "typeName": "shoppingNotification.IRequest"
    },
    "responseBody": {
      "description": "Paginated list of notification records, with compliance and audit evidence fields.",
      "typeName": "shoppingPageNotification"
    },
    "path": "/shopping/notifications",
    "method": "patch"
  },
  {
    "specification": "Retrieve the detail of a specific notification by its unique identifier. Operates on the notifications table in the CommunicationReview domain, supporting access validation, evidence preservation, and compliance controls. Used to display the content and status of a user/system notification, with full auditability and extension metadata for AI-native explainability. Only the notification's owner, the system, or approved admin roles can access; sensitive content never exposed to unauthorized users. Returned payload includes all atomic notification fields and extensible evidence fields, such as audit and compliance metadata, rationale for AI-driven status, and hypermedia links for navigation.",
    "description": "Fetches the detail of a given notification, from the CommunicationReview.notifications schema: id (PK), user_id, thread_id, notification_type, content, sent_at, read_at, archived. Provides full original content, read state, thread context if any, and all atomic fields needed for compliance and analytic workflows. AI-native platforms may enrich with explainability and evidentiary attributes if requested. Authorization is strictly enforced; non-owners or unauthorized roles are denied access. Typical errors: not found or forbidden. Always includes evidence for audit, and supports future compliance metadata extensions.",
    "summary": "Retrieve the details of a specific notification by ID from the notifications table (CommunicationReview domain).",
    "parameters": [
      {
        "name": "id",
        "description": "Unique identifier (UUID) of the notification to retrieve.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Single notification record, with compliance and audit evidence fields.",
      "typeName": "shoppingNotification"
    },
    "path": "/shopping/notifications/{id}",
    "method": "get"
  },
  {
    "specification": "Create a new notification record in the notifications table (CommunicationReview domain). This API supports both user- and system-generated notification creation, supporting all evidence, audit, and compliance needs. All atomic fields are accepted: user_id, thread_id (optional), notification_type, content, sent_at, (optional) read_at, and archived. The API enforces validations: required content and user/recipient, only authorized systems/users may create, and compliance checks on type and content. AI-native backends can pass model rationale for ML-driven notifications. Audit log is appended on creation, with evidence fields in response. Duplicate or spammy creation requests are subject to business logic/throttling. Errors: forbidden, bad request, validation failure, or duplicate creation.",
    "description": "Creates a notification in the notifications table (CommunicationReview domain): id (generated), user_id, thread_id (optional), notification_type, content, sent_at, read_at (optional), archived (default false). Validates required fields, recipient ownership, compliance for notification_type/content. AI-native explanation logic may be attached. An immutable audit log entry is always created with compliance details. On success returns full notification record; on error, returns standard API error. Fully compliant for evidence preservation.",
    "summary": "Create a new notification in the notifications table (CommunicationReview domain), with all audit evidence fields.",
    "parameters": [],
    "requestBody": {
      "description": "Notification creation details, including user, content, type, timestamps.",
      "typeName": "shoppingNotification.ICreate"
    },
    "responseBody": {
      "description": "Created notification record with all evidence/audit fields.",
      "typeName": "shoppingNotification"
    },
    "path": "/shopping/notifications",
    "method": "post"
  },
  {
    "specification": "Update (replace) a notification by its unique ID, according to the notifications table in the CommunicationReview domain. Supports full field replacement (PUT), preserving evidence and audit log chains. Only admin, system actors, or notification recipients can update; attempts by unauthorized users are denied. All atomic fields must be included in the request. Archival or deletion flags are managed according to business logic, but any update triggers audit log event for traceability. AI-native platforms may submit explainability fields with the update. This endpoint is strictly compliant—cannot be used to restore archived/deleted notifications; such actions require explicit recovery workflow.",
    "description": "Replaces a notification by its ID, referencing the CommunicationReview.notifications schema: id (PK), user_id, thread_id (optional), notification_type, content, sent_at, read_at (optional), archived. Backend validates ownership, recipient, and notification privilege; unauthorized or deleted/archived records cause error. Audit log event is generated for every update, preserving historical record for compliance. AI/ML explanation or contextual evidence can be attached in update request. Errors: not found, forbidden, validation failures, or tries to update archived notifications. Transaction is fully atomic; previous data archived for evidence.",
    "summary": "Update a notification by its ID in the notifications table (CommunicationReview domain), including audit trail.",
    "parameters": [
      {
        "name": "id",
        "description": "Target notification record's unique UUID to update.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": {
      "description": "Full notification replacement data (all fields).",
      "typeName": "shoppingNotification.IUpdate"
    },
    "responseBody": {
      "description": "Updated notification record with full compliance and audit evidence fields.",
      "typeName": "shoppingNotification"
    },
    "path": "/shopping/notifications/{id}",
    "method": "put"
  },
  {
    "specification": "Delete (archive) a notification by its unique ID, implementing soft-delete and evidence archiving in the notifications table (CommunicationReview domain). No notification is hard-deleted; instead, sets archived=true and optionally records rationale in audit log. Only owner (recipient), admin or system may archive a notification; attempts by others are denied. Archived notifications still available to compliance/audit APIs but hidden from standard user retrievals. Any deletion triggers audit log and evidence preservation. Cannot be used to archive already-deleted records, error if so. Compliance and audit rationale is included in response for evidentiary needs.",
    "description": "Logically deletes (archives) a notification, setting archived=true in the notifications table (CommunicationReview domain). Only admins, system actors, or owner user may perform. Forbids operation if already archived; otherwise, triggers audit log preservation. Returns full notification record for evidence/audit. AI-native backends may return explainability data for compliance or resilience. Errors: forbidden, not found, already archived. Audit trail is always updated and preserved.",
    "summary": "Archive (soft-delete) a notification by ID in the notifications table (CommunicationReview domain), for compliance/audit.",
    "parameters": [
      {
        "name": "id",
        "description": "Unique notification record identifier (UUID) to be archived.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Archived notification record, including audit/evidence fields for compliance.",
      "typeName": "shoppingNotification"
    },
    "path": "/shopping/notifications/{id}",
    "method": "delete"
  },
  {
    "specification": "Retrieve a paginated and filterable list of reviews from the reviews table in the CommunicationReview domain. Supports robust AI/ML-powered search and analytics filtering: by product, author, language_code, parent_review, verified_purchase status, creation/update time, and archival state. Enables full audit, evidence, and explainability (sentiment and moderation fields available for AI-native backends). Pagination, sorted by created_at/updated_at or AI-driven ranking when supported. Information always privacy/compliance restricted—only visible to owner, product admin, or authorized reviewer. Evidence fields, AI explainability, and sentiment analytics included where possible. Review content returned is filtered for privacy and moderation but maintains all audit evidence features.",
    "description": "Lists reviews with advanced filtering and search, based on CommunicationReview.reviews schema: id (PK), user_id, product_id, parent_review_id, content, language_code, created_at, updated_at, verified_purchase, archived. Filterable by author, product, language, parent review, creation/update/archival dates, verified purchase, and by text content (trigram/fulltext/AI-extract fields). Sorting by creation/update time, AI/ML-based ordering by sentiment/importance available. Only accessible to reviewer, product admin, or compliance. Results are paginated, fully evidence- and compliance-ready, extensible for AI-native sentiment and moderation enrichment in response. Errors: permission denied, invalid params, db/system errors. Returns full atomic fields needed for compliance and analytics.",
    "summary": "Retrieve a paginated, filterable list of reviews from the reviews table (CommunicationReview domain), AI-ready.",
    "parameters": [],
    "requestBody": {
      "description": "Review search, filter, pagination and sorting parameters.",
      "typeName": "shoppingReview.IRequest"
    },
    "responseBody": {
      "description": "Paginated list of reviews with full compliance/audit evidence and explainability fields.",
      "typeName": "shoppingPageReview"
    },
    "path": "/shopping/reviews",
    "method": "patch"
  },
  {
    "specification": "Fetch the details of a single review record by its unique identifier. Operates on the reviews table in the CommunicationReview domain. This operation retrieves all atomic review fields as well as evidence and compliance tracking fields, AI-generated sentiment, moderation, and explainability data when available. Ownership or privileged admin/compliance role is required—ensures privacy and access control of potentially sensitive user-generated content. Returns all required review, evidence, and extension fields for compliance or downstream AI/ML analytic workflows. Audit/evidence log entries may be referenced in the response for immutable tracing of review state changes, moderation, or forensic/explainability purposes.",
    "description": "Retrieves a single review in detail per CommunicationReview.reviews schema: id (PK), user_id, product_id, parent_review_id, content, language_code, created_at, updated_at, verified_purchase, archived. Attached metadata (media, sentiment, moderation) returned if available and if compliance policy permits. Authorization enforced: only author, product admin, or compliance actor can view. AI fields (sentiment score, classification, moderation rationale, explainable model results) included in response where relevant. Not found or forbidden if review does not exist or user unauthorized. Response is compliance and evidence-ready, capturing all immutable audit information.",
    "summary": "Fetch a single review's details from the reviews table (CommunicationReview domain), AI- and evidence-ready.",
    "parameters": [
      {
        "name": "id",
        "description": "Unique identifier of the review to retrieve (UUID).",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Detailed review record, including all compliance, sentiment, and moderation fields.",
      "typeName": "shoppingReview"
    },
    "path": "/shopping/reviews/{id}",
    "method": "get"
  },
  {
    "specification": "Create a new review resource in the shopping mall system. This operation corresponds to the creation of a product/service review entity in the 'reviews' table of the Prisma schema. The review entity supports multilingual, evidence-preserving, and versioned user feedback as described in the requirements, including fields for user, product, content, language, and verification of purchase, with full audit capabilities. The POST operation ensures that a new review is submitted by an authenticated user, links it to a product, records content, verifies purchase status if applicable, and initializes the evidence chain for compliance. Access control is enforced so only authenticated users can review, and all input data is validated for allowed lengths, supported languages, and business rules like one review per product per purchase. Errors are returned for unauthenticated access, invalid references, or business logic violations. Related review operations are PATCH for complex listing and GET/PUT/DELETE for management.",
    "description": "This endpoint allows customers to create a new review for purchased products or services. When invoked, it records all atomic details (user, product, content, language, parent review if applicable) in strict 3NF, initializes evidence fields, and sets the verified_purchase flag if possible. If the review is a reply, parent_review_id is linked. Input is validated via business logic: user must have purchased the product, the product must exist, and duplicate reviews for the same product by the same user are not allowed. Timestamps are recorded for created_at and updated_at fields as required for compliance and audit trails. The endpoint enforces permissions, stores data for multicultural accessibility, and logs the author for evidence preservation. Related API operations are PUT/DELETE (for updating and archiving reviews), PATCH for list retrieval, and child/parent relationship management for reply chains.",
    "summary": "Create a new product/service review (reviews table) in the shopping domain.",
    "parameters": [],
    "requestBody": {
      "description": "Creation payload for a new review, including user and product references, content, language, and optional parent review for replies.",
      "typeName": "IShoppingReview.ICreate"
    },
    "responseBody": {
      "description": "Details of the created review, including ID, product, user, content, language, and timestamps.",
      "typeName": "IShoppingReview"
    },
    "path": "/shopping/reviews",
    "method": "post"
  },
  {
    "specification": "Update an existing review resource. This operation corresponds to the update/edit action for a product/service review in the 'reviews' table of the Prisma schema. The operation supports updating the review content, language, archived status, and may record updates to evidence or audit logs as required for compliance and traceability. Only the original author or authorized moderators can modify a review. All business validation is enforced to prevent editing of reviews in a locked/archived state and to maintain change histories. PUT is used for full replacement, matching the requirements for strong evidence and retaining prior versions if edits occur.",
    "description": "Allows the original review author, or an authorized moderator, to fully update the content and attributes of a specific review identified by its ID. Input data is strictly validated: only modifiable fields (content, language_code, archived) can be changed; product and user references are immutable. Before updating, the endpoint checks permissions and whether the review is locked. On success, timestamps and update histories are amended, supporting complete evidence trails for compliance. If the review has been edited previously, versioning or audit records are updated accordingly. Error responses are provided for unauthenticated calls, unauthorized modification, invalid review IDs, or attempting to edit reviews that are archived or verified by certain business rules. Related endpoints are POST (for creation), PATCH (for listing/search), and DELETE (for logical deletion/archival).",
    "summary": "Update a product/service review by ID (reviews table, shopping domain).",
    "parameters": [
      {
        "name": "id",
        "description": "Review identifier (UUID) to update.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": {
      "description": "Replacement data for the review, including updated content, language, or archived status. Product and user references are immutable.",
      "typeName": "IShoppingReview.IUpdate"
    },
    "responseBody": {
      "description": "Updated review details after modification, including evidence of changes and timestamps.",
      "typeName": "IShoppingReview"
    },
    "path": "/shopping/reviews/{id}",
    "method": "put"
  },
  {
    "specification": "Soft-delete or archive a review entry by ID. This operation models the logical deletion or archival of a review in the 'reviews' table of the Prisma schema, necessary for evidence preservation and compliance. It does not physically remove records, preserving the audit trail, but sets the 'archived' or 'deleted_at' field as required. Only authorized users (review authors or moderators) may perform this operation. Related reviews may be retained for legal reporting or regulatory audit. Related operations are POST (for creation/restore), PUT (for editing), and PATCH (for lookup).",
    "description": "Enables a user or moderator to archive or soft-delete a review by setting the appropriate field (e.g., 'archived' or 'deleted_at') in the reviews table, rather than deleting the record entirely. Preserves all other data for compliance and audit purposes. Checks permissions and state before archiving; if a review is already archived, acts idempotently. Input requires only the review ID; after operation, the endpoint returns the updated record with its new state. Related history and evidence logs are retained. Errors are returned for unauthorized attempts, missing IDs, or if the review does not exist or is already subject to regulatory hold. Use with PATCH to query reviews and PUT/POST to modify or create them.",
    "summary": "Archive (soft-delete) a review by ID (reviews table, shopping domain).",
    "parameters": [
      {
        "name": "id",
        "description": "Review identifier (UUID) to archive.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Archived review object with changed status/timestamps for compliance evidence.",
      "typeName": "IShoppingReview"
    },
    "path": "/shopping/reviews/{id}",
    "method": "delete"
  },
  {
    "specification": "Retrieve a list of review media records matching search/filter parameters. This corresponds to the 'review_media' table in the Prisma schema, which stores metadata about media attached to reviews. The operation supports paging, searching, and filtering (by review, media type, sequence, etc.) according to advanced evidence and compliance requirements. All returned records preserve 3NF normalization, and access is limited to the review authors, product owners, or admins. Results are paginated and may include filter/sort metadata as per standard listing practices.",
    "description": "Provides a filtered and paginated list of review media entries matching complex or multi-parameter search criteria. This endpoint supports searching by review ID, media type, sequence, or alt text. Typically used by frontend interfaces to display attached images or videos for reviews, by admins for moderation, or by users for managing their media. Pagination parameters (page, pageSize), search keywords (for alt text), and sorting options are accepted in the request body. All output supports evidence preservation: media URIs are returned in a secure, reference-only format. Access rules may restrict viewing sensitive or user-only media.",
    "summary": "List review media entries (review_media table, shopping domain) with advanced querying.",
    "parameters": [],
    "requestBody": {
      "description": "Filtering, search, paging, and sorting parameters for review media listing.",
      "typeName": "IShoppingReviewMedia.IRequest"
    },
    "responseBody": {
      "description": "Page of review media entries with pagination metadata and sensitive data redacted as required by policy.",
      "typeName": "IPageIShoppingReviewMedia"
    },
    "path": "/shopping/reviewMedia",
    "method": "patch"
  },
  {
    "specification": "Retrieve a single review media entry by its ID. This corresponds to the 'review_media' table in the Prisma schema, structuring access to metadata and evidence for images/videos attached to reviews. The GET operation supports read-only, evidence-preserving retrieval, and is subject to access controls for users, admins, and moderators. Detailed metadata (type, sequence, alt text, URI) is returned, subject to security and privacy policies.",
    "description": "Fetches details for a single review media record identified by its unique ID. Returned data includes all atomic and audit fields: media type, URI, alt text, sequence, and attachment context (review link). This endpoint is typically used for in-context media display or compliance/audit examination. Access is validated: only authorized reviewers, product owners, or admin users can access associated media. Returns error for invalid IDs or unauthorized requests. Related endpoints include PATCH (listing with filters), POST (media creation), PUT (update), and DELETE (logical removal).",
    "summary": "Get a review media entry by ID (review_media table, shopping domain).",
    "parameters": [
      {
        "name": "id",
        "description": "Review media identifier (UUID) to retrieve.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Single review media resource, including all metadata fields and evidence-compliance attributes.",
      "typeName": "IShoppingReviewMedia"
    },
    "path": "/shopping/reviewMedia/{id}",
    "method": "get"
  },
  {
    "specification": "Create a new review media record. This operation models attaching a new image/video resource to a review, structured in the 'review_media' table of the Prisma schema. The operation supports creation with media_type, uri, alt_text, and sequence fields, along with references to the parent review. Access control requires the requesting user to be the owner of the review or an admin. Evidence and metadata (creation timestamp, author) are recorded for compliance requirements.",
    "description": "Allows a user (typically the review author) to attach new media to a review. All required fields (media_type, uri, alt_text, sequence, review_id) are validated, and the system checks that the review exists and is modifiable. On creation, the endpoint records the upload timestamp and enforces business rules like maximum upload size or allowed media types, and ensures evidence-preserving soft creation. The media is linked to the review, and other modules (like moderation) may be notified. Access control restricts to review authors or admins; all new media are audit-logged. Returns the newly created resource on success or proper error messages if input/permission fails. Related endpoints are PATCH (listing), GET/PUT/DELETE for further management.",
    "summary": "Attach new media to a review (review_media table, shopping domain).",
    "parameters": [],
    "requestBody": {
      "description": "Media upload payload, including review reference, media_type, URI, sequence, and alt_text.",
      "typeName": "IShoppingReviewMedia.ICreate"
    },
    "responseBody": {
      "description": "Details of newly created review media resource, including ID and audit metadata.",
      "typeName": "IShoppingReviewMedia"
    },
    "path": "/shopping/reviewMedia",
    "method": "post"
  },
  {
    "specification": "Update an existing review media record by ID. This operation updates fields such as media_type, uri, alt_text, or sequence for a media resource linked to a review, corresponding to the 'review_media' table. Access control ensures only review owners or admins can modify media. Evidence preservation is maintained by keeping audit logs of changes, and all update validations are enforced, e.g., URI length, allowed types, sequence order.",
    "description": "Allows a review author or admin to update attributes of a specific review media entry. Only certain fields (media_type, uri, alt_text, sequence) may be modified; the review_id is immutable once created. The system verifies that the target media exists and is associated with a review that the caller may modify. All changes are timestamped and logged for audit/compliance. Errors are returned for unauthorized attempts, invalid input, or if the media is not found. Related endpoints are PATCH (listing/search), GET (single media retrieval), POST (new media creation), and DELETE (logical removal).",
    "summary": "Update a review media entry by ID (review_media table, shopping domain).",
    "parameters": [
      {
        "name": "id",
        "description": "Review media identifier (UUID) to update.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": {
      "description": "Update payload for review media, supporting fields such as media_type, uri, alt_text, and sequence.",
      "typeName": "IShoppingReviewMedia.IUpdate"
    },
    "responseBody": {
      "description": "Updated review media object, including change evidence and timestamps.",
      "typeName": "IShoppingReviewMedia"
    },
    "path": "/shopping/reviewMedia/{id}",
    "method": "put"
  },
  {
    "specification": "Soft-delete or archive a review media entry by ID. Corresponds to logical removal (not physical deletion) for review_media in the Prisma schema, preserving evidence and compliance records. Access control allows only authorized users (review owners or admins). The operation sets a deleted/archived flag and keeps all audit history.",
    "description": "Marks a review media record as archived/soft-deleted by ID, ensuring evidence preservation and compliance. The item is no longer available to normal listing queries. Audit fields are updated to reflect change. Only the review author or an admin may perform this action. Attempts to re-archive already archived entries are idempotent. Upon result, the operation returns the resource with updated archival status and timestamps. Related endpoints are PATCH (list/search), GET (single), POST (new), and PUT (update).",
    "summary": "Archive (soft-delete) a review media entry by ID (review_media table, shopping domain).",
    "parameters": [
      {
        "name": "id",
        "description": "Review media identifier (UUID) to archive.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Review media object with archival/compliance status set.",
      "typeName": "IShoppingReviewMedia"
    },
    "path": "/shopping/reviewMedia/{id}",
    "method": "delete"
  },
  {
    "specification": "Retrieve a list of review moderation actions matching search or filter parameters. This operation corresponds to the 'review_moderations' table in the Prisma schema, storing evidence of moderation (flag, remove, restore, rationale, moderator, timestamps). PATCH allows advanced queries including pagination, sorting, and searching by any moderation attribute (review, moderator, action type, etc.). Only authorized users (moderators/admins) can view these logs. Result format supports evidence reporting and is paginated for scalability.",
    "description": "Returns a paginated list of review moderation entries with extensible filtering on review ID, moderator user, action type, rationale, or date range. Used primarily by admins or moderation tools/auditors for compliance evidence. Each record includes immutable fields (id, review, moderator, action, rationale, timestamp). Request body can include advanced filter, sort, and paging query parameters. Related endpoints are POST (moderation action creation), GET/PUT/DELETE for item-level management. Access is restricted to moderation roles; enforcement is strict per compliance requirements. Error responses for invalid filters, unauthorized access, or data not found. All returned data complies with regulatory evidence rules.",
    "summary": "List review moderation actions (review_moderations table, shopping domain) with advanced filtering.",
    "parameters": [],
    "requestBody": {
      "description": "Filtering, pagination, and search parameters for moderation action list.",
      "typeName": "IShoppingReviewModeration.IRequest"
    },
    "responseBody": {
      "description": "Paginated result containing review moderation audit entries, with compliance metadata.",
      "typeName": "IPageIShoppingReviewModeration"
    },
    "path": "/shopping/reviewModerations",
    "method": "patch"
  },
  {
    "specification": "Retrieve a single review moderation entry by its ID. Corresponds to the 'review_moderations' table of the Prisma schema for evidence, compliance, and audit. Allows introspection of details for one moderation action (remove, restore, flag, rationale, actor, timestamp) after authorization. Output is the immutable moderation record. Used by admin, compliance, and audit interfaces.",
    "description": "Returns the details of a review moderation action identified by its unique ID. Includes evidence and compliance fields: review reference, moderator, action_type, rationale, and created_at timestamp. The endpoint is read-only and restricted to authorized moderators/admins. Errors are returned for invalid or missing IDs or unauthorized access. Related endpoints are PATCH (listing/search), POST (creation), PUT (update). All returned data is strict for compliance and cannot be edited except by evidence-adding actions. Use with POST/PUT (for creating/updating moderation actions) or PATCH for searches.",
    "summary": "Get a review moderation action by ID (review_moderations table, shopping domain).",
    "parameters": [
      {
        "name": "id",
        "description": "Review moderation identifier (UUID) to retrieve.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Review moderation entry, with all evidence and compliance fields returned.",
      "typeName": "IShoppingReviewModeration"
    },
    "path": "/shopping/reviewModerations/{id}",
    "method": "get"
  },
  {
    "specification": "Create a new review moderation action. This operation adds an immutable entry in the 'review_moderations' table for actions such as flagging, removing, restoring, or providing a rationale by a moderator. Only authorized moderators or admin users may create these entries, and every entry is immutable for regulatory compliance. The moderation action records all required fields (review, moderator, action, rationale, timestamp). Related endpoints are PATCH (listing), GET (retrieve), and PUT (update for corrections).",
    "description": "Allows a moderator to add an audit/evidence-preserved entry for a moderation action on a review. This creates a new record with moderator user, action_type (remove, restore, flag), rationale, linked review, and creation timestamp. Only moderators/admins may call this endpoint; full input validation is enforced. The moderation action cannot be changed or removed after creation, except via evidence-adding updates (PUT). Related endpoints allow searching (PATCH), observation (GET), and correction or rationale updates (PUT). Errors returned for unauthorized use, invalid input, or non-existent review IDs.",
    "summary": "Create a review moderation action (review_moderations table, shopping domain).",
    "parameters": [],
    "requestBody": {
      "description": "Moderation action creation payload, including review reference, moderator user, action_type, rationale, and timestamp.",
      "typeName": "IShoppingReviewModeration.ICreate"
    },
    "responseBody": {
      "description": "Review moderation entry as created, including all immutable fields and audit evidence.",
      "typeName": "IShoppingReviewModeration"
    },
    "path": "/shopping/reviewModerations",
    "method": "post"
  },
  {
    "specification": "Update an existing review moderation entry by ID. This operation is suitable for appending additional evidence/rationale fields, or correcting the non-critical attributes of a moderation event (never for deleting or changing the action). All changes are audited. Only admins/moderators may perform this operation. Related table is 'review_moderations' in the Prisma schema. PUT enforces evidence compliance: fields like rationale or timestamps can be appended, never replaced. Output includes new evidence records as required by regulatory standards.",
    "description": "Allows an authorized moderator or admin to update certain fields of a review moderation audit entry, such as appending rationale or evidence notes. Primary core fields (review, moderator, action_type) are immutable post-creation. All changes are logged and become part of the evidence chain for compliance. Input is strictly validated for policy enforcement. Errors are returned for unauthorized attempts, invalid IDs, or attempts to change locked fields. Associated endpoints are POST (for initial creation), PATCH (listing/search), and GET (detail viewing). PUT does not delete or fundamentally alter moderation actions, only appends/annotates evidence. Output contains the updated moderation entry and appended evidence data.",
    "summary": "Update a review moderation action by ID (review_moderations table, shopping domain).",
    "parameters": [
      {
        "name": "id",
        "description": "Review moderation identifier (UUID) to update.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": {
      "description": "Moderation action update payload; only non-critical, evidence-related fields may be appended.",
      "typeName": "IShoppingReviewModeration.IUpdate"
    },
    "responseBody": {
      "description": "Review moderation entry after update, with amended rationale/evidence and full audit details.",
      "typeName": "IShoppingReviewModeration"
    },
    "path": "/shopping/reviewModerations/{id}",
    "method": "put"
  },
  {
    "specification": "Implements the deletion of a review moderation entry from the CommunicationReview.review_moderations table. This endpoint is responsible for permanently removing a specific moderation log for a product or service review. Deletion must consider audit trail and evidence retention as required by compliance—actual removal may trigger an archival or soft-delete logic, depending on business rules. Only authorized operators or automated compliance systems should have permission to perform this action. Required for compliance, undo logic in moderation interfaces, and forensic/audit requests. Related entities (e.g., the review itself, moderator reference) must remain unaffected; only the moderation record is deleted.",
    "description": "This operation permanently deletes a review moderation record from the database, which is used to log actions such as removing, restoring, or flagging a review for compliance and evidence. The moderation action, moderator identity, and rationale are documented in the record. Security and compliance logic ensures that this deletion only affects the moderation record itself, and any relation to the reviewed entity or user remains intact for purposes of traceability and audit. Performing this action may create a new system-level audit entry or trigger compliance workflows, such as notifying audit loggers or administrators. Error handling covers cases where the moderation record does not exist, has already been deleted, or the user lacks sufficient privilege. Access is typically restricted to compliance officers, system administrators, or automated compliance/breach detection jobs.\n\nRelated APIs include the GET/PUT/POST/PATCH operations for reviewModerations. This API is often paired with review status management and audit evidence tracking endpoints. Business logic mandates that deletion of moderation actions may be required for regulatory evidence export or after compliance-hold periods have expired.",
    "summary": "Delete a single review moderation record from CommunicationReview.review_moderations.",
    "parameters": [
      {
        "name": "id",
        "description": "Target moderation record ID to delete.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": null,
    "path": "/shopping/reviewModerations/{id}",
    "method": "delete"
  },
  {
    "specification": "Enables advanced querying, pagination, and searching for review sentiments in the CommunicationReview.review_sentiments table. This endpoint is designed to support AI/ML model integration and analytics workflows by allowing clients to filter, aggregate, and view batches of sentiment analysis results linked to reviews. Typical search parameters include review ID, sentiment category, AI model version, or scoring thresholds. Pagination and sorting facilitate scalable result presentation for dashboards, monitoring tools, or analyst review. Implements compliance with evidence preservation by allowing only query, not mutation. May expose summary statistics on search results if required for analytics.",
    "description": "This operation searches or lists review sentiment analysis records based on arbitrary query parameters (such as review ID, sentiment category, score, or model version) against the review_sentiments entity. The endpoint supports pagination, sorting, and advanced filters to support monitoring of AI-driven moderation effectiveness, trend detection, and regulatory reporting. Returned records include all evidence necessary for regulatory compliance, such as analysis timestamps, model version details, and score values. The API supports integration with sentiment analysis dashboards and legal/analytics reporting pipelines. If error occurs (e.g., invalid query parameter or unsupported filter), an error response is returned.\n\nRelated API operations include: post (single record creation), get/put/delete (individual record), and analytics/reporting endpoints for AI-based compliance and explainability. Security measures limit data returned to authorized analysts or managers with appropriate read permissions.",
    "summary": "List or search reviewSentiments (CommunicationReview.review_sentiments) with filtering, pagination, and analytics.",
    "parameters": [],
    "requestBody": {
      "description": "Search/filter conditions for listing reviewSentiments. Includes pagination, filter fields (e.g., reviewId, sentiment, modelVersion, score range), and sort options.",
      "typeName": "IReviewSentiments.IRequest"
    },
    "responseBody": {
      "description": "Paginated response with list of review sentiment records matching the query, plus pagination metadata.",
      "typeName": "IPageIReviewSentiments"
    },
    "path": "/shopping/reviewSentiments",
    "method": "patch"
  },
  {
    "specification": "Retrieves a single reviewSentiments record by its unique identifier from the CommunicationReview.review_sentiments table. Provides all available sentiment analysis evidence for the linked review, including result, score, AI model version reference, and timestamp. Essential for compliance with explainability, evidence chaining, and review-level transparency.",
    "description": "This operation fetches a specific sentiment analysis result linked to a user review, as identified by the reviewSentiments ID. The returned data includes all atomic fields for the sentiment analysis event (sentiment class, score, analysis timestamp, AI/ML model version ID, etc.). Specifically used for review dashboards, audit tools needing evidence, or analyst review of automated moderation. Security and privacy concerns are managed by limiting access to authorized personnel. Error cases include non-existent IDs or insufficient permission.\n\nThis API is usually paired with PATCH (search/query), POST (add new sentiment), PUT (replace record), and DELETE (remove record) endpoints for the reviewSentiments resource.",
    "summary": "Get detail for one reviewSentiments record (CommunicationReview.review_sentiments) by ID.",
    "parameters": [
      {
        "name": "id",
        "description": "ReviewSentiments record ID to retrieve.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Details for the specified reviewSentiments record including analysis evidence.",
      "typeName": "IReviewSentiments"
    },
    "path": "/shopping/reviewSentiments/{id}",
    "method": "get"
  },
  {
    "specification": "Creates a new reviewSentiments record in CommunicationReview.review_sentiments. This endpoint is invoked when an AI or automated moderation service completes a sentiment analysis for a review, and the evidence needs to be stored for explainability, compliance, and audit trails. The body contains all necessary data for the sentiment analysis event: review ID, model version, sentiment value, score, and timestamp. The operation is subject to validation (existence of referenced review, model version, data correctness).",
    "description": "This operation creates a new sentiment analysis record for a review, capturing all evidence related to the model inference: the review being analyzed, sentiment result, score/confidence, AI model version, and timestamp. This API must validate all foreign key references (to review and model version) and ensure data consistency. On successful creation, all fields are returned, including generated metadata. Error conditions include conflicting IDs, missing references, schema validation errors, or insufficient privilege. Access control applies, typically limited to AI moderation pipelines or administrative roles.\n\nThis endpoint supports compliance efforts by creating immutable audit evidence of sentiment analysis, supporting right-to-explain and legal/regulatory requirements.",
    "summary": "Create a new reviewSentiments record (CommunicationReview.review_sentiments) with all evidence fields.",
    "parameters": [],
    "requestBody": {
      "description": "All required data for creating a new reviewSentiments record (review, model version, sentiment result, score, timestamp).",
      "typeName": "IReviewSentiments.ICreate"
    },
    "responseBody": {
      "description": "Created reviewSentiments record with all fields (IDs, evidence, metadata).",
      "typeName": "IReviewSentiments"
    },
    "path": "/shopping/reviewSentiments",
    "method": "post"
  },
  {
    "specification": "Updates or replaces a reviewSentiments record in CommunicationReview.review_sentiments identified by ID. This endpoint is used for corrections, legal compliance, or AI re-analysis if a prior sentiment assignment was in error or needs regulatory update. All fields are replaced, so requests must contain the complete new state. All changes must be logged for audit evidence. Permission checks and foreign key validation (to review and model version) are enforced. Triggers requisite audit updates and may synchronize evidence logs for compliance.",
    "description": "This operation fully replaces the specified reviewSentiments record with the new data provided in the request. All evidence, metadata, and analysis results are updated atomically. Audit trail logic ensures that previous values, actor information, and update timestamp are properly archived, enabling forensics and compliance evidence review. Validation covers references to reviews and model versions, sentiment schema constraints, and required fields. On success, the entire new resource state is returned. Errors include non-existent records, failed validations, permission errors, or attempts to overwrite immutable evidence fields. Security restricts operation to privileged analysts, AI pipeline controllers, or compliance actors.",
    "summary": "Replace an existing reviewSentiments record in CommunicationReview.review_sentiments by ID (full update).",
    "parameters": [
      {
        "name": "id",
        "description": "Target reviewSentiments record ID to update.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": {
      "description": "Full replacement for the reviewSentiments record; all evidence and metadata required.",
      "typeName": "IReviewSentiments.IUpdate"
    },
    "responseBody": {
      "description": "Updated reviewSentiments record (all fields, latest state).",
      "typeName": "IReviewSentiments"
    },
    "path": "/shopping/reviewSentiments/{id}",
    "method": "put"
  },
  {
    "specification": "Removes an existing reviewSentiments record from CommunicationReview.review_sentiments by ID. Required for evidence retention control, legal deletion requests, or compliance workflows. Actual deletion may be logically soft (archival) or physically destructive based on system policy. Triggers audit/evidence log update and may require privilege elevation.",
    "description": "This operation deletes a sentiment analysis record for a review, either by soft-deleting the evidence for legal compliance or by hard deletion if allowed by current policy. The specific record is identified by its ID. Access control logic restricts the operation to those with regulatory or administrative rights. The operation cross-references audit trails and may trigger evidence archival jobs. Deleting this record does not affect the original review, only its sentiment evidence. Errors are returned for missing IDs, permission failures, or attempts to delete protected evidence.",
    "summary": "Delete a reviewSentiments record from CommunicationReview.review_sentiments by ID.",
    "parameters": [
      {
        "name": "id",
        "description": "Target reviewSentiments record ID to delete.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": null,
    "path": "/shopping/reviewSentiments/{id}",
    "method": "delete"
  },
  {
    "specification": "Lists or searches sentimentAnalysisLogs entries from the CommunicationReview.sentiment_analysis_logs table with advanced filtering, analytics, and dashboard support. The endpoint serves analysts, auditors, and AI operations teams for purposes of tracking all past AI/ML-driven sentiment analysis runs on reviews. Query options enable filtering by review, AI model version, timestamp range, or result class. All returned records include full evidence logging, raw model input, output, and version references. Designed for use in compliance, explainability, and continuous improvement pipelines.",
    "description": "This operation allows for complex queries (filters, ranges, aggregates) and paginated listing of sentimentAnalysisLogs records. Returned rows include atomic evidence-links (model input, output, model version, and timestamp) for each log entry. The endpoint supports AI monitoring dashboards, forensics/audits, and compliance reporting. Includes support for large-scale data ingestion and external regulatory access (data residency, right-to-explain, etc.). On error (e.g., invalid filter), a structured error response is returned. Only authorized users and systems may access this endpoint, with results limited by role-based data access policies.",
    "summary": "Search or list sentimentAnalysisLogs records in CommunicationReview.sentiment_analysis_logs with advanced query and analytics support.",
    "parameters": [],
    "requestBody": {
      "description": "Query, filter, and pagination conditions for listing sentimentAnalysisLogs entries. Includes reviewId, modelVersion, analysis period, input/output class, etc.",
      "typeName": "ISentimentAnalysisLogs.IRequest"
    },
    "responseBody": {
      "description": "Paginated result set with all sentimentAnalysisLogs records and query metadata.",
      "typeName": "IPageISentimentAnalysisLogs"
    },
    "path": "/shopping/sentimentAnalysisLogs",
    "method": "patch"
  },
  {
    "specification": "Retrieves a single sentimentAnalysisLogs record from CommunicationReview.sentiment_analysis_logs by ID. Used for compliance, forensic review, model debugging, and right-to-explain logic. Returns all fields and evidence snapshots, including model input/output, version reference, and timestamps.",
    "description": "This operation fetches the detailed evidence and metadata for a single sentimentAnalysisLogs record, as identified by its unique ID. The output includes the full input/raw payload sent for analysis, actual model output, version, and related audit details. Designed for dashboards, compliance evidence, legal requests, or AI performance debugging. Error handling includes absent records, unauthorized access, and validation errors. Security measures restrict access to privileged or audit/analyst users only.\n\nPaired endpoints are PATCH (list/search), POST (create new analysis log), PUT/DELETE (update/remove log) for the sentimentAnalysisLogs resource.",
    "summary": "Get full details for one sentimentAnalysisLogs record by ID (CommunicationReview.sentiment_analysis_logs).",
    "parameters": [
      {
        "name": "id",
        "description": "Target sentimentAnalysisLogs record ID to retrieve.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Complete record for sentimentAnalysisLogs entry, with evidence/log fields.",
      "typeName": "ISentimentAnalysisLogs"
    },
    "path": "/shopping/sentimentAnalysisLogs/{id}",
    "method": "get"
  },
  {
    "specification": "Creates a new sentimentAnalysisLogs entry in CommunicationReview.sentiment_analysis_logs. The endpoint records full details (raw input, output, version, analysis time, evidence) each time an AI/ML model runs on a review for sentiment analysis. Data from this endpoint supports audit trails, model debugging, explainability, and automated compliance monitoring. Subject to full validation (existence of referenced review/model version).",
    "description": "This operation creates a new sentiment analysis log record, tying together the review input, AI model version, raw input/output, analysis timestamp, and all supporting evidence. Designed for integration into AI pipelines, compliance evidence generation, and dashboard analytics. All referenced foreign keys to reviews and AI model versions are validated. Completion returns the entire log entry, including generated fields (ID, timestamps). Error handling includes missing records, referential failures, permission errors, and schema/gateway validation issues. Access control gates use to administrator or AI-ops service accounts.",
    "summary": "Create a new sentimentAnalysisLogs record with all evidence fields (CommunicationReview.sentiment_analysis_logs).",
    "parameters": [],
    "requestBody": {
      "description": "Full required data for sentiment analysis log. Includes input payload, output, model version, review ref, evidence links.",
      "typeName": "ISentimentAnalysisLogs.ICreate"
    },
    "responseBody": {
      "description": "Created sentimentAnalysisLogs entry with full evidence and all metadata.",
      "typeName": "ISentimentAnalysisLogs"
    },
    "path": "/shopping/sentimentAnalysisLogs",
    "method": "post"
  },
  {
    "specification": "Updates (fully replaces) a single sentimentAnalysisLogs record by ID in CommunicationReview.sentiment_analysis_logs. Used for evidence correction, audit replay, or legal data changes. Requires full replacement of all evidence/data fields; partial updates are not supported. Triggers audit logging and may create a new compliance report if needed. Reference validation (review, model version) is mandatory.",
    "description": "This operation replaces all data for a specified sentimentAnalysisLogs record, including its evidence fields (raw input, raw output, model version, analysis time, etc.). Used in circumstances where a prior AI analysis is disputed, requires legal update, or operator/administrator rectification. All audit, evidence, and actor data are synchronized with change. Old and new values may be stored in secondary audit logs for traceability. Security and compliance logic restricts this operation to approved analysts, AI ops staff, or compliance administrators. Validation requires all references to exist and all data be present. Errors include not found, validation failure, or permission denied.\n\nCompanion operations are GET, POST, DELETE, and PATCH endpoints for this resource group.",
    "summary": "Replace a complete sentimentAnalysisLogs record in CommunicationReview.sentiment_analysis_logs by ID.",
    "parameters": [
      {
        "name": "id",
        "description": "SentimentAnalysisLogs record ID to update.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": {
      "description": "Full replacement record for sentimentAnalysisLogs. All evidence, metadata, and log fields required.",
      "typeName": "ISentimentAnalysisLogs.IUpdate"
    },
    "responseBody": {
      "description": "Updated sentimentAnalysisLogs record (all fields/evidence).",
      "typeName": "ISentimentAnalysisLogs"
    },
    "path": "/shopping/sentimentAnalysisLogs/{id}",
    "method": "put"
  },
  {
    "specification": "Deletes a sentimentAnalysisLogs record in CommunicationReview.sentiment_analysis_logs by ID. This endpoint is used for legal right-to-erasure, compliance evidence removal, or regulatory requests. Deletion may be logical (soft) or physical depending on policy. Full audit/evidence tracing is performed. Access limitation for administrators and legal teams only.",
    "description": "This operation deletes a sentiment analysis log record, leaving audit and evidence trails as required by compliance policy. The actual record may be soft- or hard-deleted but must maintain traceability; audit entries are updated or appended for accountability. Only those with explicit privileges (compliance officers or system admins) may invoke. Error handling occurs for records not found, referential constraints, conflicting system state, or privilege violations. Related entities are not directly affected by this operation.\n\nCommonly used as part of legal or compliance-driven lifecycle operations (e.g., end-user or regulator deletion requests).",
    "summary": "Delete sentimentAnalysisLogs record from CommunicationReview.sentiment_analysis_logs by ID.",
    "parameters": [
      {
        "name": "id",
        "description": "SentimentAnalysisLogs record ID to delete.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": null,
    "path": "/shopping/sentimentAnalysisLogs/{id}",
    "method": "delete"
  },
  {
    "specification": "Provides advanced listing, search, and filter for user favorites across the system via FavoritesPersonalization.favorites. Used to power analytics dashboards, user preference engines, compliance/legal evidence retrieval, and model training/feedback flows. This endpoint returns paginated results with optional filtering on user, product, or creation timestamps. No mutation allowed; read-only evidence for audit and compliance.",
    "description": "This operation returns a paginated list of favorite records, filtered by provided criteria (such as user ID, product ID, favorite timestamp, or deleted status). Query parameters are included in the request body; the response includes results and pagination metadata. Designed for use in user dashboards, compliance exports, or data analytics/model training. Only authorized users (themselves or administrative reviewers) can query their own or system-wide favorites according to data access policy. Errors are returned for invalid queries or permission problems.\n\nAssociated endpoints include POST (add favorite), DELETE (remove), and PATCH (list) for bookmarks or personalization events.",
    "summary": "List, search, or filter favorites in FavoritesPersonalization.favorites, with paginated response.",
    "parameters": [],
    "requestBody": {
      "description": "Search/filter and pagination parameters for querying favorites. Includes userId, productId, date range, deleted status, etc.",
      "typeName": "IFavorites.IRequest"
    },
    "responseBody": {
      "description": "Paginated list of favorites records with evidence and metadata.",
      "typeName": "IPageIFavorites"
    },
    "path": "/shopping/favorites",
    "method": "patch"
  },
  {
    "specification": "Retrieve a specific favorite record by its unique ID. This operation relates to the 'favorites' entity in the Prisma schema, which tracks user's favorite (bookmarked) products and is central to the Favorites & Personalization module. The API allows evidence-preserved, audit-grade fetching of a user's individual favorite with full compliance and regulatory traceability for analytics, security, or preference history. Ensures user-level RBAC compliance and only returns non-soft-deleted (active) favorites.",
    "description": "This endpoint fetches a single favorite bookmark for a user, supporting the compliance and personalization module. The favorites table stores the relationship between a user and their favorited product (products.id) with full audit evidence (timestamps, deleted timestamp for soft-deletes). On GET, the API consults user permissions (from users and RBAC logic) and returns atomic favorite data (id, user_id, product_id, created_at, deleted_at). Data returned is guaranteed not to expose deleted or tampered rows, as soft-deleted records are excluded by logic. This endpoint supports monitoring for auditors, AI-raised context (such as for recommendations), and targeted analytics. Error handling includes: 404 for non-existent or deleted favorites, and 403 for unauthorized users. This API is frequently linked from personalization detail flows, advanced AI explainability, and audit drill-down tools. If the requested ID is not present or access is denied, a clear error will be returned without leaking internal details.",
    "summary": "Get a specific favorite (favorites table, FavoritesPersonalization module) by ID.",
    "parameters": [
      {
        "name": "id",
        "description": "Favorite record's unique identifier (UUID).",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Details of the favorites entity with full property set for evidence and compliance.",
      "typeName": "IFavorites"
    },
    "path": "/shopping/favorites/{id}",
    "method": "get"
  },
  {
    "specification": "Create a new favorite record, marking a product as a favorite (bookmark) for the current user. Writes to the 'favorites' table, part of the FavoritesPersonalization domain. This endpoint is used for preference management, AI/ML personalization feedback, and user engagement tracking with full evidence/audit trail preservation. Guarantees that only one favorite per (user, product) pair exists.",
    "description": "Posts a new favorite relationship for a user, enabling product bookmarking, personalized recommendation context, and loyalty evidence. Input validation ensures both product_id and user session match constraints from the favorites Prisma schema (composite uniqueness on user_id/product_id, user auth via session or token). The record is created in an audit-preserved way (created_at set by server, deleted_at null), available for explainable AI and compliance logs. This operation is RBAC protected: users must be authenticated and not blocked. The API emits a personalization audit log per creation for compliance. Possible errors: 409 on duplicate favorite, 400 on bad input, 401/403 if not authorized. This endpoint underpins real-time personalization, AI feedback, and analytics/loyalty integration. Linked to corresponding 'undo' (delete) and 'list' functionalities for user experience continuity.",
    "summary": "Create a favorite (favorites table, FavoritesPersonalization module) for the authenticated user.",
    "parameters": [],
    "requestBody": {
      "description": "Favorite creation payload including at least product_id.",
      "typeName": "IFavorites.ICreate"
    },
    "responseBody": {
      "description": "Newly created favorites record in detail.",
      "typeName": "IFavorites"
    },
    "path": "/shopping/favorites",
    "method": "post"
  },
  {
    "specification": "Update an existing favorite record by its ID (e.g., soft-delete/restore, metadata change). Central operation for the FavoritesPersonalization module (favorites table). Preserves audit/evidence chain; typically used for recovery, analytics, or administrative override. Changes are tracked via audit logging.",
    "description": "This endpoint allows modifying a favorite relationship—primarily for compliance-driven soft-deletion/restoration. Though 'favorites' is inherently simple (mapping user/product), the endpoint enforces atomicity and only supports mutable fields such as deleted_at (for soft delete purposes). Attempts to update immutable fields (user_id, product_id, created_at) are rejected. An audit log is generated for every mutation (to support forensics, compliance, user rights management). RBAC protections enforced, and attempts at unauthorized access are blocked and logged. Fails with 404 if ID does not exist; 403 for unauthorized action; 400 if immutable fields are included in update. If updated, the response includes full favorite details reflecting the new state.",
    "summary": "Update a favorite record, typically soft-delete/restore (favorites table, FavoritesPersonalization module).",
    "parameters": [
      {
        "name": "id",
        "description": "Favorite record's unique identifier (UUID).",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": {
      "description": "Payload for updating mutable fields of a favorites entity (e.g., deleted_at for soft delete).",
      "typeName": "IFavorites.IUpdate"
    },
    "responseBody": {
      "description": "Updated favorite entity reflecting requested changes.",
      "typeName": "IFavorites"
    },
    "path": "/shopping/favorites/{id}",
    "method": "put"
  },
  {
    "specification": "Delete (soft-delete) a favorite record by ID for the authenticated user; key for regulatory/evidence purposes in the FavoritesPersonalization module (favorites entity). This operation preserves evidence (via deleted_at and audit logging) instead of physical deletion, conforming to compliance rules (e.g., GDPR 'right-to-be-forgotten').",
    "description": "This endpoint performs a soft-delete of a favorite record, making it inaccessible in list/lookup queries but retaining evidence for audit. It supports user-initiated removal of favorites, regulatory compliance flows, and cross-device preference retraction. The favorite (by id) must exist and belong to the requesting user (or be allowed by.admin override). Only permitted users may perform this action (enforced by RBAC/auth logic). After soft-delete, the deleted_at timestamp is set and audit logs are updated (personalization audit table, evidence_hash generated). On success, the now-deleted favorite is returned (for immediate UI feedback or compliance download). Errors: 404 if not found or already deleted, 403 if unauthorized. This operation supports undo (restore) via update.",
    "summary": "Soft-delete a favorite record (favorites table, FavoritesPersonalization module, evidence-preserving).",
    "parameters": [
      {
        "name": "id",
        "description": "Favorite record's unique identifier (UUID).",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "The favorite record post-deletion, reflecting the new deleted_at timestamp.",
      "typeName": "IFavorites"
    },
    "path": "/shopping/favorites/{id}",
    "method": "delete"
  },
  {
    "specification": "List or search user's bookmarks with flexible query/pagination. This endpoint pulls from the bookmarks table (FavoritesPersonalization module) and supports search, filtering, and evidence-compliant listing. Supports all advanced requirements for personalization AI feedback, audit trails, and omnichannel extensibility, returning only bookmarks accessible for the calling user/session.",
    "description": "Patch operation for listing (potentially filtered/searched) bookmarks, which link users and products with optional organization/tag/note fields. Accepts search, filter, and pagination input (e.g., by user_id, product_id, folder, tag, created_at), validating parameters against Prisma schema (all atomic and indexed fields). Results are paged for performance, including total count and items. This endpoint enables analytics, auditing (evidence timestamp), and monitoring for compliance, favoriting metrics, and AI feature workflows. Accessibility and multicultural support through I18N of tags/notes and localizable list fields. Only bookmarks not soft-deleted are returned; audit/evidence for each result. RBAC protection for ownership and admin listing. Linked to favorite and personalization event list APIs. Errors include: 400 (malformed query), 403 (unauthorized), 500 (unexpected error).",
    "summary": "List/search bookmarks (bookmarks table, FavoritesPersonalization module) with filtering/paging.",
    "parameters": [],
    "requestBody": {
      "description": "Query/filter/pagination parameters for bookmarks list operation.",
      "typeName": "IBookmarks.IListRequest"
    },
    "responseBody": {
      "description": "Paginated list of bookmarks, including evidence/audit attributes.",
      "typeName": "IPageIBookmarks"
    },
    "path": "/shopping/bookmarks",
    "method": "patch"
  },
  {
    "specification": "Get explicit bookmark detail by its unique ID. Supports audit, personalization, and evidence-compliance flows. Reads the bookmarks table from the FavoritesPersonalization module (favoriting/personalization system).",
    "description": "This endpoint fetches all atomic bookmark attributes (id, user_id, product_id, custom_folder, tag, note, created_at, deleted_at) for a single bookmark. Enforces RBAC—restricts visibility to the owner or permitted admin. All lookup operations include compliance checks for soft-deletion, audit trail, and access logs. Bookmarks in a deleted state are NOT returned unless specifically requested and authorized. Commonly used for UI bookmark drilldowns, API-driven personalization flows, and compliance audits. Returns 404 if not found or not accessible, 403 for authorization errors. Error payloads include trace IDs for audit.",
    "summary": "Fetch detail of a single bookmark by ID (bookmarks table, FavoritesPersonalization module).",
    "parameters": [
      {
        "name": "id",
        "description": "Bookmark record's unique identifier (UUID).",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Full bookmark entity including evidence attributes (audit pass-through).",
      "typeName": "IBookmarks"
    },
    "path": "/shopping/bookmarks/{id}",
    "method": "get"
  },
  {
    "specification": "Create a new bookmark (user-product relation with optional metadata) in bookmarks table, FavoritesPersonalization module. Enforces evidence and compliance requirements (audit log, ownership checks, uniqueness per product/user, soft-delete support).",
    "description": "Posts a bookmark associating a user with a product and optional folder/tag/note organizational metadata. Request payload enforces product_id and at least one identifier (custom_folder/tag/note can be null). Uniqueness and ownership enforced per (user, product_id). Auth required; rejects duplicate or unauthorized attempts. On success, creates the bookmark with server-generated created_at and null deleted_at. Fires audit log for personalization evidence. Response returns full created bookmark record for compliance and personalization tracking. Linked to listing, update, and delete endpoints. RBAC-protected, errors: 409 (duplicate), 400 (bad input), 401/403 (auth), 500 (unexpected).",
    "summary": "Create a bookmark linking a user/product, optional metadata (bookmarks table, FavoritesPersonalization module).",
    "parameters": [],
    "requestBody": {
      "description": "Bookmark creation payload—includes product_id, optional folder/tag/note.",
      "typeName": "IBookmarks.ICreate"
    },
    "responseBody": {
      "description": "The newly created bookmark and all relevant audit/evidence fields.",
      "typeName": "IBookmarks"
    },
    "path": "/shopping/bookmarks",
    "method": "post"
  },
  {
    "specification": "Update an existing bookmark by ID—modifies organizational metadata (folder/tag/note), supporting evidence/compliance requirements. Only updateable by owner (user_id) or privileged admin. Full audit logging required. This endpoint affects one record in the bookmarks table (FavoritesPersonalization module).",
    "description": "Allows modification of mutable fields on a single bookmark: folder, tag, note, or soft-deletion (deleted_at). Input is validated for presence and content rules (e.g., folder/tag max length, note no prohibited content) and checked against Prisma field definitions. RBAC enforced: only the owner or authorized admin can update. Each update triggers audit logging for personalization compliance. Immutable fields (user_id, product_id, created_at) are rejected if present. Returns 404 if the bookmark does not exist or not accessible; 403 if unauthorized; 400 if validation fails; 409 if unique constraint violated. Updated record returned on success.",
    "summary": "Update bookmark organizational metadata or soft-delete (bookmarks table, FavoritesPersonalization module).",
    "parameters": [
      {
        "name": "id",
        "description": "Bookmark record's unique identifier (UUID).",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": {
      "description": "Fields to update: custom_folder, tag, note, or soft-delete (deleted_at).",
      "typeName": "IBookmarks.IUpdate"
    },
    "responseBody": {
      "description": "Updated bookmark including new metadata and compliance evidence.",
      "typeName": "IBookmarks"
    },
    "path": "/shopping/bookmarks/{id}",
    "method": "put"
  },
  {
    "specification": "Delete (soft-delete) a bookmark by ID in bookmarks table (FavoritesPersonalization). Preserves audit evidence by setting deleted_at and logging the operation in personalization_audits. Enforces compliance and user privacy (GDPR/right to erasure).",
    "description": "Soft-deletes a bookmark by ID, marking it as deleted (deleted_at set) while preserving audit trail per compliance requirements. Only the owner (user_id) or admin can execute this. Provides an atomic removal for UI and user experience, analytics, and preference learning feedback. The record remains in system for audit/introspection, not shown in lists unless authorized. Fires audit log entry. RBAC enforced; 404 if not found/not owned, 403 if unauthorized. Success returns new deleted record for immediate client feedback and compliance export. Linked to restore (update) and evidence/audit flows.",
    "summary": "Soft-delete a bookmark (bookmarks table, FavoritesPersonalization, with compliance audit).",
    "parameters": [
      {
        "name": "id",
        "description": "Bookmark record's unique identifier (UUID).",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Bookmark as soft-deleted (deleted_at set); evidence included for compliance.",
      "typeName": "IBookmarks"
    },
    "path": "/shopping/bookmarks/{id}",
    "method": "delete"
  },
  {
    "specification": "List/search personalization events (e.g., recommendation served/clicked) for a user/session, supporting analytics, feedback loop, and audit evidence/compliance. Reads the personalization_events table (FavoritesPersonalization module). Fully supports filtering by user_id, event_type, model_version, context, and timestamp. Results are paged and support evidence-based tracking for explainable AI and compliance reporting.",
    "description": "Patch request retrieves a filtered, paginated list of personalization_events (e.g., recommendation view/click, favorite added, feedback given). Search parameters include user_id, recommendation_id, product_id, event_type, model_version, timestamp (with range). Each result includes audit/evidence fields (timestamp, model version, context). Only events permitted by RBAC are returned. Supports compliance logs (personalization_audits) and AI feedback reporting. Errors: 400 (bad input), 401/403 (auth), 500 (server error). Linked to feedback, personalization, analytics and audit dashboards. Supports I18N compliance for context and metadata.",
    "summary": "List/search personalization events (personalization_events table, FavoritesPersonalization module, analytics/evidence).",
    "parameters": [],
    "requestBody": {
      "description": "Filtering, sorting, pagination parameters for personalization event search.",
      "typeName": "IPersonalizationEvents.IListRequest"
    },
    "responseBody": {
      "description": "Paginated list of personalization event records and compliance evidence.",
      "typeName": "IPageIPersonalizationEvents"
    },
    "path": "/shopping/personalizationEvents",
    "method": "patch"
  },
  {
    "specification": "Retrieve detail for a single personalization_event by its unique ID, from personalization_events table (FavoritesPersonalization module). Used for compliance, evidence chain, and AI explainability/personalization feedback reporting. Returns all atomic event data and evidence/audit fields.",
    "description": "GET endpoint fetches the complete record for a personalization_event—showing user_id, recommendation_id, product_id, event_type, model_version, context, timestamp. Supports compliance, feedback audit, and evidence chains as required by explainable AI and personalization loops. RBAC and user-level access checks enforced: only authorized/owner or admin can fetch. Errors: 404 if not found, 403 if unauthorized, 400 if invalid ID. Payload includes evidence for audit and analytics (e.g., context, model version, event details). Linked to list and audit APIs, used in model improvement workflows.",
    "summary": "Retrieve a single personalization event detail (personalization_events table, FavoritesPersonalization module, evidence support).",
    "parameters": [
      {
        "name": "id",
        "description": "Personalization event's unique identifier (UUID).",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Personalization event entity including all evidence/audit-supporting fields.",
      "typeName": "IPersonalizationEvents"
    },
    "path": "/shopping/personalizationEvents/{id}",
    "method": "get"
  },
  {
    "specification": "Create a new personalization_event record in personalization_events table (FavoritesPersonalization module). Accepts event_type, associated recommendation_id, product_id, model_version, context. This action provides mandatory evidence for explainable AI, analytics, and personalization feedback loop integration. All entries are traced for compliance/evidence reporting.",
    "description": "This endpoint records a personalization event—such as recommendation viewed/clicked, preference learned, or AI-based personalization delivered. Payload includes relevant atomic fields: user_id, recommendation_id, product_id, event_type, model_version, context, timestamp. Input is validated (e.g., existing recommendation_id/product_id, valid model_version context). Audit log is triggered for every entry, supporting compliance and model improvement. RBAC required. Errors: 400 for bad input, 409 for duplicate event, 401/403 for authentication issue. On success, returns complete created record with compliance evidence. Linked to reporting, analytics, and model retraining workflows.",
    "summary": "Create a new personalization event (personalization_events table, FavoritesPersonalization module, AI/analytics evidence).",
    "parameters": [],
    "requestBody": {
      "description": "Payload representing a personalization event, including user, recommendation, product, event_type, model_version, etc.",
      "typeName": "IPersonalizationEvents.ICreate"
    },
    "responseBody": {
      "description": "Newly created personalization event record with compliance/audit fields.",
      "typeName": "IPersonalizationEvents"
    },
    "path": "/shopping/personalizationEvents",
    "method": "post"
  },
  {
    "specification": "Update an existing personalization event in the database. The operation targets the 'personalization_events' table, which tracks all user interactions and feedback with AI-driven personalized recommendations. Updates must ensure strict evidence preservation, auditability, and compliance with non-repudiation requirements. Modification is allowed only on non-key atomic fields; references to user, product, and recommendation must remain consistent. All changes are logged for regulatory and ML feedback loop purposes. Business logic enforces access controls so only authorized entities may update events. Events updated here affect personalization analytics and continuous AI improvement. Related APIs include get, create, and delete for personalization events.",
    "description": "This API updates an existing personalization event record, as defined in the 'personalization_events' database table. Personalization events capture interactions such as when a user views, clicks, dismisses, or otherwise reacts to an AI-driven recommendation. Each record logs the user, product, recommendation, event type, model version, and context metadata, along with a timestamp. \n\nUpdates permitted via this endpoint include changes to event_type, context, or timestamp fields. Changes to relationships (user, product, recommendation) are not allowed, as these establish referential integrity and auditability for the event log. All modifications must be fully tracked to support audit trails, AI/ML retraining, and compliance mandates such as GDPR/CCPA evidence retention. Access is restricted to authorized system roles or service accounts. Attempts to violate referential integrity or modify critical references will result in errors. \n\nThis operation is closely linked to create (POST), fetch (GET), and delete (DELETE) operations for personalization events. It is fundamental for maintaining the ongoing integrity of AI service analytics, continuous personalization improvement, and regulatory documentation.",
    "summary": "Update an existing personalization_event record (personalization_events table) by ID.",
    "parameters": [
      {
        "name": "id",
        "description": "Target personalization_event's unique identifier.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": {
      "description": "Update information for the personalization_event. Only non-relational fields may be modified.",
      "typeName": "IShoppingPersonalizationEvent.IUpdate"
    },
    "responseBody": {
      "description": "The updated personalization_event resource.",
      "typeName": "IShoppingPersonalizationEvent"
    },
    "path": "/shopping/personalizationEvents/{id}",
    "method": "put"
  },
  {
    "specification": "Delete an existing personalization event from the 'personalization_events' table. The table is designed for immutable event tracking but supports logical deletion (soft delete), marking records as deleted while preserving audit evidence as per GDPR/CCPA and internal audit requirements. This endpoint ensures only authorized deletions are performed, maintaining evidence and referential integrity. Useful for handling user/principal requests to retract evidence or correct erroneous data. Any delete attempts on non-existent or already-deleted records will return a not-found error. All deletions are tracked for compliance and AI analytics integrity, as deleted events may affect retraining datasets.",
    "description": "This API deletes (soft deletes) a personalization event, identified by its ID, from the 'personalization_events' table. Instead of hard deletion, the system marks the deleted_at timestamp to preserve audit trail and evidence for compliance purposes. This supports GDPR/CCPA and internal regulatory requirements around evidence preservation, right-to-be-forgotten, and audit reconstruction while maintaining non-repudiation guarantees. \n\nSoft-deleted entries remain in the data store but are excluded from standard analytics and retrieval queries. Attempts to delete records that do not exist or are already deleted return an error. This operation interacts with AI/ML pipelines by ensuring that deleted records are not fed into continuous learning or retraining datasets unless flagged for compliance-replay. All delete actions are themselves logged as personalization audits.",
    "summary": "Delete (soft delete) a personalization_event record (personalization_events table) by ID.",
    "parameters": [
      {
        "name": "id",
        "description": "Target personalization_event's unique identifier.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Confirmation of deletion (soft delete).",
      "typeName": "IDeleteResult"
    },
    "path": "/shopping/personalizationEvents/{id}",
    "method": "delete"
  },
  {
    "specification": "Retrieve a paginated, searchable, and sortable list of recommendation records from the 'recommendations' table. Supports AI-driven recommendation analytics, feedback loop, and personalization monitoring. The operation must allow for filtering by user, product, model version, and time, corresponding to ML analytics and explainability workflows. Designed to supply a robust and regulatory-compliant view of recommendations, including support for continuous learning and audit/explainability use cases. Key for AI-native recommendation management in the shopping domain.",
    "description": "This API fetches a list of recommendation records from the 'recommendations' database table. It supports advanced retrieval with search, filtering, pagination, and sorting based on criteria such as user, product, model_version, and time window. This is required for AI analytics/evaluation, feedback loop processing, personalization dashboarding, and regulatory/ML audit reviews. \n\nSupports granular searching for recommendations delivered by a specific model or version, those targeting a particular user or item, or within a specified time range. The endpoint is optimized for retrieval of both core recommendation data and audit-relevant metadata such as rationale and delivery timestamp. It returns a paginated response structure suitable for handling large-scale recommendation systems.\n\nErrors (e.g., invalid query, out-of-range pages) are reported with actionable details. This endpoint is related to CRUD endpoints on recommendations and serves as a backend to model analytics, explainability dashboards, and AI/ML pipeline tools.",
    "summary": "List/search recommendations in the recommendations table.",
    "parameters": [],
    "requestBody": {
      "description": "Parameters for filtering, searching, paginating, and sorting recommendations.",
      "typeName": "IShoppingRecommendation.IRequest"
    },
    "responseBody": {
      "description": "Paginated list of recommendations matching search criteria.",
      "typeName": "IPageIShoppingRecommendation"
    },
    "path": "/shopping/recommendations",
    "method": "patch"
  },
  {
    "specification": "Retrieve a single recommendation record from the 'recommendations' table by its unique identifier. This API supplies all details of an AI/ML-driven recommendation delivered to a user/product, including explainability information and model audit trace data. Designed to support dashboard UIs, analytics, and regulatory requirements around AI recommendation transparency, explainability, and auditing (models, rationale, timestamps, targets).",
    "description": "Fetches a single recommendation from the 'recommendations' table, providing full traceability, audit, and explainability data for the delivered AI/ML recommendation. The entity includes references to user, product, model ID and version, rationale for recommendation, and timestamp, supporting business, ML, and regulatory/audit dashboards.\n\nAccess controls ensure only authorized users or services can view full recommendation detail, including rationale and model version. This operation is critical for continuous learning, model trust and transparency, and audit-legal obligations. All fetches are tracked for evidence in the audit subsystem.",
    "summary": "Get a specific recommendation by ID from the recommendations table.",
    "parameters": [
      {
        "name": "id",
        "description": "Unique identifier of the recommendation.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "The detailed recommendation resource.",
      "typeName": "IShoppingRecommendation"
    },
    "path": "/shopping/recommendations/{id}",
    "method": "get"
  },
  {
    "specification": "Create a new recommendation record in the 'recommendations' table. This endpoint feeds personalized AI/ML-driven recommendation delivery tracking, supporting model trust, regulatory evidence, user explainability, and ongoing feedback loop requirements. Creation supports complete referential integrity and audit logging for all core properties including user, product, model_id, model_version, rationale, and delivery timestamp. All creations trigger audit and continuous learning workflows for model improvement and explainability.",
    "description": "Creates a new recommendation entry, recording all attributes of the delivered AI/ML-based recommendation to a user/product. The request validates referential integrity (user, product, model), captures explainability metadata (rationale, model version), and logs delivery timestamp for regulatory and analytics workflows.\n\nOn successful creation, the endpoint returns the saved recommendation. This creation is logged for ML training and compliance evidence. Invocation of this operation can trigger downstream analytics, dashboards, and data ingestion for continuous recommendation improvement.",
    "summary": "Create a new recommendation record (recommendations table).",
    "parameters": [],
    "requestBody": {
      "description": "Recommendation creation payload, including user/product, model details, rationale, and timestamp.",
      "typeName": "IShoppingRecommendation.ICreate"
    },
    "responseBody": {
      "description": "The created recommendation entity.",
      "typeName": "IShoppingRecommendation"
    },
    "path": "/shopping/recommendations",
    "method": "post"
  },
  {
    "specification": "Update an existing recommendation in the 'recommendations' table by ID. The recommendation record tracks AI/ML-driven interventions, including who/what/when of the recommendation, rationale, model version, and all fields required for audit and explainability. Update restricts changes to non-key atomic fields; referential IDs (user, product, model) are immutable to preserve audit evidence. All changes are logged for audit, AI model retraining, and evidence tracking.",
    "description": "Updates a recommendation record in the 'recommendations' table, allowing modification of mutable fields such as rationale, timestamp, or explainability attributes. The request enforces referential and audit integrity: referential IDs (user, product, model) are immutable. All updates trigger audit logging required for regulatory and AI/ML feedback purposes. \n\nAccess control restricts updates to authorized business users, system accounts, or AI/ML maintenance services. Attempts to update non-mutable fields or break referential constraints are rejected with explicit error reporting. This endpoint supports explainability and trust workflows for AI-driven recommendations in ecommerce.",
    "summary": "Update a recommendation record by ID (recommendations table).",
    "parameters": [
      {
        "name": "id",
        "description": "Unique identifier of the recommendation to update.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": {
      "description": "Recommendation changes; only atomic, non-relational fields may be changed.",
      "typeName": "IShoppingRecommendation.IUpdate"
    },
    "responseBody": {
      "description": "The updated recommendation entity.",
      "typeName": "IShoppingRecommendation"
    },
    "path": "/shopping/recommendations/{id}",
    "method": "put"
  },
  {
    "specification": "Delete (soft-delete) a recommendation from the 'recommendations' table by its unique identifier. The system preserves audit evidence and referential integrity by never physically removing records; instead, the deleted_at field is set. Only authorized users or trusted backend services may perform this action, and all deletions are fully tracked for compliance and AI/ML training data management. Related APIs include create, fetch, update recommendation.",
    "description": "Logically deletes a recommendation entity from the 'recommendations' table, setting a deleted_at timestamp instead of hard removal to preserve evidence for audit/compliance (GDPR/CCPA) and enable reconstruction of model training data. All soft deletes are tracked in the audit system and retraining/analytics logic should exclude entries with deleted_at values.\n\nAttempts to delete non-existent or already deleted records return an error. This API is critical in maintaining trust and evidence around AI/ML-driven interventions in ecommerce. It also enables compliance with user data management, auditability, and continuous learning feedback workflows.",
    "summary": "Delete (soft-delete) a recommendation by ID (recommendations table).",
    "parameters": [
      {
        "name": "id",
        "description": "Unique identifier of the recommendation.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Confirmation of soft delete for the recommendation.",
      "typeName": "IDeleteResult"
    },
    "path": "/shopping/recommendations/{id}",
    "method": "delete"
  },
  {
    "specification": "Retrieve a paginated, filtered, and sortable list of personalization_audit records from the 'personalization_audits' audit table. This table tracks all evidence-preserving logs of user actions and AI-driven personalization events (bookmarks, favorites, recommendations, personalizations interactions). The endpoint underpins compliance reporting, explainability, and continuous AI improvement, requiring efficient and secure search on action types, timestamps, user IDs, and related entities. Supports review and export for legal/regulatory processes and AI/ML retraining audits.",
    "description": "Fetch a list of personalization_audit records, supporting advanced searching, filtering, pagination, and sorting by user, action_type, timestamp, or linkage to related favorites/bookmarks/recommendations/personalization_events. The audit log supports evidence preservation for regulatory audits, GDPR/CCPA compliance, and ML explainability. \n\nAPIs built on this list endpoint drive compliance dashboards, audit exports, and legal queries, while also enabling ML teams to review feedback and evidence for continuous improvement. All parameters are designed to align with regulatory/legal export protocols; only authorized and privacy-compliant access is allowed.",
    "summary": "List/search personalization_audits for user activity and evidence (personalization_audits table).",
    "parameters": [],
    "requestBody": {
      "description": "Filtering, searching, pagination and sorting criteria for personalization_audit records.",
      "typeName": "IShoppingPersonalizationAudit.IRequest"
    },
    "responseBody": {
      "description": "Paginated list of filtered personalization_audit records.",
      "typeName": "IPageIShoppingPersonalizationAudit"
    },
    "path": "/shopping/personalizationAudits",
    "method": "patch"
  },
  {
    "specification": "Retrieve a single personalization_audit record by its unique identifier from the 'personalization_audits' evidence table. Each record supplies a timestamped, cryptographically signed audit trail of user-AI interactions (favorites, bookmarks, recommendations, or personalization events). The endpoint supports explainability workflows, regulatory/legal export, and ML evidence chains.",
    "description": "Fetches a single personalization_audit record by ID, providing all detail on the evidence-preserving log of a user or system action related to personalization/favorite/recommendation, as described in GDPR-compliance and AI explainability modules. The operation surfaces all available metadata, linked entities, and evidence hashes for legal inquiry, dashboards, or ML model debugging.\n\nAccess is permitted only to authorized, compliance-privileged users or system roles, and every fetch is itself logged for evidence. This endpoint forms the backbone of compliance reporting and continuous learning explainability chains around AI-driven features.",
    "summary": "Get personalization_audit record by ID (personalization_audits table).",
    "parameters": [
      {
        "name": "id",
        "description": "Unique ID of the personalization_audit record.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "The detailed personalization_audit resource.",
      "typeName": "IShoppingPersonalizationAudit"
    },
    "path": "/shopping/personalizationAudits/{id}",
    "method": "get"
  },
  {
    "specification": "Create a new personalization_audit record in the 'personalization_audits' table. This enforces non-repudiation, evidence preservation, and regulatory compliance for all user/system interactions tracked as part of AI-driven personalization workflows (favorites, bookmarks, recommendations, etc). Every creation captures details such as user, linked entity IDs (favorites/bookmarks/recommendations/events), action_type (add, delete, update, serve, override), cryptographic evidence hash, and timestamp. All creations participate in audit and legal inquiry chains and influence explainability of AI model decisions.",
    "description": "Creates a new entry in the personalization_audits evidence table, recording all relevant attributes for compliance, audit, and explainability. The submitter must supply all required links to user, action_type, evidence_hash, and related entities. Creation is logged as an immutable audit record and may immediately be consumed by regulatory export, compliance dashboards, and continuous learning/ML explanation tools.\n\nCreation failures (invalid references, missing data, attempt to duplicate evidence) are explicitly reported for regulatory verifiability. The endpoint is central to ongoing AI/ML and compliance explainability workflows, as well as system trust and model improvement processes.",
    "summary": "Create new personalization_audit evidence record (personalization_audits table).",
    "parameters": [],
    "requestBody": {
      "description": "Personalization_audit creation payload, capturing all compliance- and ML-relevant attributes.",
      "typeName": "IShoppingPersonalizationAudit.ICreate"
    },
    "responseBody": {
      "description": "The created personalization_audit resource.",
      "typeName": "IShoppingPersonalizationAudit"
    },
    "path": "/shopping/personalizationAudits",
    "method": "post"
  },
  {
    "specification": "Update an existing personalization_audit evidence record in the 'personalization_audits' table by ID. This operation is tightly controlled due to evidence preservation requirements: only non-relational, non-critical fields (e.g., action_type, evidence_hash, timestamp) may be updated. All updates are themselves tracked as audit chain events to maintain legal and regulatory integrity, as well as AI/ML explainability. AI, ML and regulatory workflows depend on preserving original relationships and data lineage.",
    "description": "Updates a personalization_audit record, identified by its unique ID, within the evidence table. Update is restricted to mutable, non-relational fields; links to user and related entities (favorites, bookmarks, recommendations, events) and timestamps must remain valid and unchanged for evidence and compliance. Each update is logged as its own audit trail link, enabling legal tracebacks and regulatory forensics.\n\nFailed updates (e.g., attempts to mutate immutable fields, break referential constraints) return explicit error codes for auditing. Only system-privileged accounts or authorized compliance officers may use this endpoint, in conformity with legal requirements around evidence management.",
    "summary": "Update a personalization_audit record by ID (personalization_audits table).",
    "parameters": [
      {
        "name": "id",
        "description": "Target personalization_audit record's ID.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": {
      "description": "Permitted update info for personalization_audit (only non-relational fields).",
      "typeName": "IShoppingPersonalizationAudit.IUpdate"
    },
    "responseBody": {
      "description": "The updated personalization_audit resource.",
      "typeName": "IShoppingPersonalizationAudit"
    },
    "path": "/shopping/personalizationAudits/{id}",
    "method": "put"
  },
  {
    "specification": "Delete (soft-delete) a personalization_audit evidence record from the 'personalization_audits' audit table. Supports GDPR/CCPA right-to-be-forgotten and retention requirements. All deletions are logical (preserve audit data, mark as deleted), and are fully tracked to maintain evidence chain and regulatory compliance. Deletion may only be performed by authorized regulatory or system roles, and all attempts are themselves audited. Deleted records are excluded from audit exports and ML training sets unless specifically flagged for compliance review.",
    "description": "Performs a soft-delete of a personalization_audit evidence record, marking it as deleted for compliance and right-to-erasure, but never physically removing the record from the audit evidence chain. The deleted_at flag is set, and the deletion is logged for end-to-end traceability and legal/regulatory audit, in accordance with GDPR/CCPA and internal policies.\n\nUnauthorized or invalid delete attempts (e.g., deleting already deleted or non-existent records) result in explicit errors. ML/analytics pipelines are to be notified so the deleted record is excluded from non-compliance-sensitive workflows.",
    "summary": "Delete personalization_audit record by ID (soft-delete, evidence chain preserved).",
    "parameters": [
      {
        "name": "id",
        "description": "Unique ID of the personalization_audit record to delete.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Confirmation of soft delete for personalization_audit record.",
      "typeName": "IDeleteResult"
    },
    "path": "/shopping/personalizationAudits/{id}",
    "method": "delete"
  },
  {
    "specification": "Retrieve a paginated and filterable list of AI models managed by the advanced AI module. This endpoint supports searching by model name, type, or organization and returns summary information for each model. Prisma table: ai_models. Request body supports advanced filters, search criteria, and pagination/sorting.",
    "description": "This API operation provides a paginated, searchable, and filterable list of all AI/ML models registered in the platform, referencing the ai_models table from the Prisma schema. Each AI model record contains business metadata such as name, organization, model type, and description.\n\nSecurity enforcement applies, only users with appropriate permissions can access model listings—organizational scope may apply for multi-tenant situations. Search criteria in the request body allow clients to filter by name, type, owner organization, creation date, and status, in line with compliance and auditability requirements.\n\nThe endpoint is designed for extensibility, accepting complex search objects to support future additional attributes or model classifications. Pagination and sorting minimize load and support frontend or integration use. Expected errors include permission violations or malformed filters. Used in conjunction with detail endpoints and model version/query APIs.",
    "summary": "Retrieve a paginated and filtered list of AI models (ai_models table) with search support.",
    "parameters": [],
    "requestBody": {
      "description": "Filter, paging, and search criteria for AI models.",
      "typeName": "IShoppingAiModel.IRequest"
    },
    "responseBody": {
      "description": "Paginated result of AI model summaries.",
      "typeName": "IPageIShoppingAiModel.ISummary"
    },
    "path": "/shopping/aiModels",
    "method": "patch"
  },
  {
    "specification": "Retrieve full detail for a specific AI model by its unique ID. This corresponds to the ai_models table. Returns all business metadata, governance state, linkages to owner organization and versions, and compliance audit fields.",
    "description": "This API operation fetches all available information for a single AI model, referencing the ai_models table in Prisma. The result includes all key fields: unique identifier, model name, model type, description, organizational owner, timestamps, and relational fields such as linkages to users and model versions.\n\nAccess is governed by permissions and organization boundaries as required by the requirements analysis. Access attempts for nonexistent or unauthorized resources are rejected. This endpoint supports model governance, audit, compliance, and is a prerequisite for model updates or version management workflows. All returned data is fully auditable in line with advanced AI operations and evidence tracking.",
    "summary": "Retrieve detailed business and governance metadata for a specific AI model (ai_models table).",
    "parameters": [
      {
        "name": "id",
        "description": "Unique identifier of the AI model to retrieve.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Detailed AI model metadata and links.",
      "typeName": "IShoppingAiModel"
    },
    "path": "/shopping/aiModels/{id}",
    "method": "get"
  },
  {
    "specification": "Create a new AI model registry entry in ai_models. Allows administrators to register a new model with business metadata and initial governance settings. Requires full detail in body.",
    "description": "This API registers a new AI/ML model in the system, persisting all required metadata in the ai_models table according to the Prisma schema. The request body must include all required attributes such as model name, type, owner organization, description, organizational and user ownership, and other metadata for governance and regulatory purposes.\n\nCaller must have elevated permissions (admin/AI ops personnel). All input is validated according to compliance rules. Entry creation is logged for auditability, and data integrity is enforced. On success, returns the created AI model full record.",
    "summary": "Register a new AI model entry (ai_models table) with metadata for governance and audit.",
    "parameters": [],
    "requestBody": {
      "description": "Full registration details for the AI model (required fields and optional metadata).",
      "typeName": "IShoppingAiModel.ICreate"
    },
    "responseBody": {
      "description": "Created AI model metadata record.",
      "typeName": "IShoppingAiModel"
    },
    "path": "/shopping/aiModels",
    "method": "post"
  },
  {
    "specification": "Update metadata or business information for an existing AI model in ai_models by ID. Only certain fields may be mutable and audit logging is enforced. Organization and access rules apply.",
    "description": "This endpoint allows an authorized user (admin/AI operator) to modify specific attributes of an existing AI model entry in the ai_models table. Changes such as updating the model description, type, organization, or ownership can be made, respecting compliance and audit requirements from both Prisma schema and requirements.\n\nOnly permitted fields are updatable; model ID and immutable audit fields cannot be changed. All changes are audited and evidence-preserved. Validation enforces system and domain constraints. Used in conjunction with detail retrieval and model operations. Rejected if unauthorized, not found, or if integrity constraints are violated.",
    "summary": "Update mutable business and governance info for an AI model (ai_models table) by ID.",
    "parameters": [
      {
        "name": "id",
        "description": "ID of the AI model to update.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": {
      "description": "Fields to update for the model (only allowed fields).",
      "typeName": "IShoppingAiModel.IUpdate"
    },
    "responseBody": {
      "description": "Updated AI model details.",
      "typeName": "IShoppingAiModel"
    },
    "path": "/shopping/aiModels/{id}",
    "method": "put"
  },
  {
    "specification": "Soft-delete (archive) an AI model entry from ai_models by ID. This operation marks the entry as deleted for audit/tracing but does not physically remove the record.",
    "description": "This API endpoint marks an AI model registry entry (ai_models table) as deleted by setting the deleted flag, in accordance with compliance, audit, and evidence preservation requirements. The model is not physically removed but excluded from normal listings. The operation is only allowed for users with appropriate permissions and is audited for evidence.\n\nUsed for decommissioning retired, superseded, or invalid models, while maintaining a full historical and audit record for regulatory or forensic purposes. Attempts to delete non-existent or already deleted records result in appropriate errors.",
    "summary": "Soft-delete (archive) an AI model record (ai_models table) by its ID, preserving audit trail.",
    "parameters": [
      {
        "name": "id",
        "description": "ID of the AI model to delete (archive).",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Result confirmation and updated AI model record.",
      "typeName": "IShoppingAiModel"
    },
    "path": "/shopping/aiModels/{id}",
    "method": "delete"
  },
  {
    "specification": "Retrieve a paginated and filterable list of AI model versions registered in the system. Backs continuous deployment/version tracking. Supports advanced searching, pagination, and sorting. Prisma table: ai_model_versions.",
    "description": "This API gives a searchable, paginated listing of all AI model versions referenced in the ai_model_versions table. Each summary record contains version string, associated model, hashes for artifact/validation, status, and timestamps for deployment or creation.\n\nThe request body enables advanced search, filter by model, deployment state, version, or date. Used for CI/CD and model governance dashboards. Results respect security, organization, and audit criteria. Pagination and sorting enable large-scale management of model registry entries, while supporting compliance for evidence and continuous learning loops.",
    "summary": "List AI model versions (ai_model_versions table) with search and pagination.",
    "parameters": [],
    "requestBody": {
      "description": "Search and filter criteria for model versions (model, status, timeframe, etc).",
      "typeName": "IShoppingAiModelVersion.IRequest"
    },
    "responseBody": {
      "description": "Paginated result set of model version summaries.",
      "typeName": "IPageIShoppingAiModelVersion.ISummary"
    },
    "path": "/shopping/aiModelVersions",
    "method": "patch"
  },
  {
    "specification": "Fetch complete metadata for a given version of an AI/ML model by version entry ID. Returns artifact and deployment fields, traces governance requirements.",
    "description": "This endpoint retrieves all information for a single version instance of an AI model, as recorded in ai_model_versions. Returns fields covering version string, hash, artifact URL, framework, deployment timestamps, metadata, and model linkage. This operation ensures traceability, version governance, and compliance with explainability and auditability requirements from the requirements report and Prisma schema.\n\nAccess is security controlled, version may be gated by model organizational scope. Used in conjunction with model registry and model deployment APIs. Returns 404 for not found or restricted models. Error handlings aligned with compliance and evidence requirements.",
    "summary": "Retrieve full metadata for a specific AI model version (ai_model_versions table) by ID.",
    "parameters": [
      {
        "name": "id",
        "description": "Unique ID for the AI model version.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Detailed AI model version entry.",
      "typeName": "IShoppingAiModelVersion"
    },
    "path": "/shopping/aiModelVersions/{id}",
    "method": "get"
  },
  {
    "specification": "Register a new AI model version in ai_model_versions. Used for uploading new model artifacts, version upgrades, and deployment history in the AI/ML governance framework.",
    "description": "This endpoint registers a newly trained/packaged AI/ML model version, persisting all version metadata in ai_model_versions. The body must include all key details: version string, hash for validation, artifact URI, framework, origin AI model linkage, and optional deployment metadata. Enforces compliance and audit logging rules for versioned models, supporting regulatory traceability and CI/CD model management.\n\nOnly authorized AI governance/admin users are allowed to create new model versions. The operation is fully audited for decision rationale, operational evidence, and model lineage responsibilities. Returns the created record on success.",
    "summary": "Register (upload) a new version of an AI model (ai_model_versions table) with artifacts, hashes, and metadata.",
    "parameters": [],
    "requestBody": {
      "description": "Full metadata and linkage for registering an AI model version.",
      "typeName": "IShoppingAiModelVersion.ICreate"
    },
    "responseBody": {
      "description": "The newly registered AI model version record.",
      "typeName": "IShoppingAiModelVersion"
    },
    "path": "/shopping/aiModelVersions",
    "method": "post"
  },
  {
    "specification": "Update mutable metadata fields for an existing AI model version in ai_model_versions. Used for lifecycle management, deployment marking, or metadata enrichment. Audit and compliance enforced per-update.",
    "description": "Allows compliant modification of an AI model version record in ai_model_versions. Permitted changes might include updating the deployment timestamp, changing the framework, or updating metadata for a specific version. All changes are strictly validated and logged for audit evidence. Some core fields (version hash, artifact) are immutable; constraints enforced based on business and compliance requirements.\n\nSecurity applies for admin/AI ops only; audit evidence created for every update. Used in conjunction with detail endpoint, registry listings, and model deployment workflows. Errors result from missing/immutable fields, permission, or model version not found.",
    "summary": "Update allowed metadata for a specific AI model version (ai_model_versions table) by ID.",
    "parameters": [
      {
        "name": "id",
        "description": "ID of the AI model version to update.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": {
      "description": "Allowed updatable fields for an AI model version.",
      "typeName": "IShoppingAiModelVersion.IUpdate"
    },
    "responseBody": {
      "description": "AI model version with updated metadata.",
      "typeName": "IShoppingAiModelVersion"
    },
    "path": "/shopping/aiModelVersions/{id}",
    "method": "put"
  },
  {
    "specification": "Delete (archive) an AI model version entry in ai_model_versions by ID. Enforces soft-delete or archival, never physical deletion, for traceability as required by AI governance.",
    "description": "This endpoint soft-deletes (archives) an AI model version entry, marking it as deleted in ai_model_versions, never physically removing the record for auditability and traceability. All actions are logged for evidence and audit in compliance with continuous AI lifecycle management. Only admin/AI governance roles can perform this operation, and the operation is blocked for protected or already removed versions.\n\nUsed for retiring superseded or deprecated AI models, while supporting full audit trails for regulatory/forensic examination. Access is denied for unauthorized users and not found for invalid IDs.",
    "summary": "Soft-delete/archive a version entry from the AI model version registry (ai_model_versions table) by ID.",
    "parameters": [
      {
        "name": "id",
        "description": "ID of the AI model version to delete (archive).",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Archived model version confirmation and record.",
      "typeName": "IShoppingAiModelVersion"
    },
    "path": "/shopping/aiModelVersions/{id}",
    "method": "delete"
  },
  {
    "specification": "Retrieve a paginated, filtered list of AI/ML training datasets present in the registry. Supports search criteria for name, version, source, linked model, and more. Used for model/data governance and audit operations. Table: ai_training_data.",
    "description": "This endpoint delivers a paginated listing with filter capability of all registered AI training datasets as defined in ai_training_data. The request body accepts advanced filter criteria such as dataset name, training data version, source URI, schema hash, record count, creation dates, or linked model. The result enables governance, audit, and explainability over all datasets used in AI/ML model training as per requirements and Prisma schema.\n\nPagination, sorting, and advanced search minimize response size for large registries. Access and usage are strictly audited; only permitted users (AI ops) may access sensitive data provenance. Used in conjunction with dataset and model registry detail endpoints. Errors for invalid filters, permission violations, or missing resources are consistent with system policy.",
    "summary": "List and search registered AI training datasets (ai_training_data table) with flexible filters and pagination.",
    "parameters": [],
    "requestBody": {
      "description": "Advanced search, filter, and paging for AI training dataset listing.",
      "typeName": "IShoppingAiTrainingData.IRequest"
    },
    "responseBody": {
      "description": "Paginated dataset summaries from the AI training registry.",
      "typeName": "IPageIShoppingAiTrainingData.ISummary"
    },
    "path": "/shopping/aiTrainingData",
    "method": "patch"
  },
  {
    "specification": "Retrieve full metadata and governance information for a specific AI/ML training dataset by its registry entry ID. Returns all atomic fields for audit, explainability, and compliance. Table: ai_training_data.",
    "description": "Fetches the detailed information for a single registered AI/ML training dataset, leveraging the ai_training_data table from Prisma. The return payload includes all atomic and relational attributes—dataset name, linked model, version, schema hash, source URI, record count, and ownership/provenance information. This endpoint is required for governance, audit, evidence preservation, and ongoing compliance. Security and access is enforced for authorized users only; errors for missing or unauthorized resources are handled per requirements documentation.",
    "summary": "Retrieve all metadata and linkage info for a specific training dataset (ai_training_data table) by ID.",
    "parameters": [
      {
        "name": "id",
        "description": "ID of the training dataset to retrieve.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Full detail of the requested AI/ML training dataset record.",
      "typeName": "IShoppingAiTrainingData"
    },
    "path": "/shopping/aiTrainingData/{id}",
    "method": "get"
  },
  {
    "specification": "Create a new AI training data resource. This operation is mapped to the ai_training_data table and enables registration of a new dataset for model training, accountability, and evidence logging. According to the requirements and schema, the user must supply all fields necessary to describe the dataset (name, version, source_uri, schema_hash, optional model association, and record count). Consent, compliance, and data governance are enforced.",
    "description": "This API operation allows the registration of a new training dataset into the AI/ML registry. It supports metadata such as dataset name (unique per version), version, storage URI, schema hash for evidence, optional AI model ID (if linked to a particular model), and record count. The endpoint is designed for strict auditability and regulatory compliance, supporting traceability of training data origin and usage in model governance.\n\nOnly authorized users—typically ML engineers, platform administrators, or designated data custodians—may access this endpoint. The operation requires validation of field integrity and uniqueness (name, version, source_uri), and logs a provenance record for compliance. Mutations are fully logged in audit/evidence tables.\n\nRejection reasons include duplicate entries, missing consent, or non-compliance with traceability policy. Related endpoints: update, delete, and fetch AI training data.",
    "summary": "Create a new AI training dataset entity (ai_training_data table).",
    "parameters": [],
    "requestBody": {
      "description": "Payload with training data details: name, version, source_uri, schema_hash, (optional model ID), record count, etc.",
      "typeName": "IShoppingAiTrainingData.ICreate"
    },
    "responseBody": {
      "description": "The newly created AI training data resource entity.",
      "typeName": "IShoppingAiTrainingData"
    },
    "path": "/shopping/aiTrainingData",
    "method": "post"
  },
  {
    "specification": "Update an existing AI training dataset. This operation is directly mapped to the ai_training_data table, allowing modification of permissible fields, such as the dataset's name, version, source_uri, schema_hash, associated AI model, and record count. It supports evidence and regulatory logging—invalid operations (e.g., attempt to overwrite audit fields) are rejected, and all updates generate an audit record.",
    "description": "This endpoint updates the metadata of a specific registered AI training data entity, referenced by its unique ID. Only updatable fields such as the name, version, source_uri, schema_hash, optional ai_model_id, and record_count can be changed—critical audit/evidence fields (e.g., created_at) are immutable.\n\nAccess is RBAC-controlled to system admins, data scientists, or auditors. All changes are validated for integrity, and a detailed update log is kept for evidence and compliance. If the ID does not exist, a not found error is returned; if update is not allowed (e.g., non-updatable field), a policy error is thrown. Companion endpoints: POST to create, DELETE to remove, GET to fetch details.",
    "summary": "Update an existing AI training dataset (ai_training_data table).",
    "parameters": [
      {
        "name": "id",
        "description": "Target AI training data resource ID (UUID) to update.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": {
      "description": "Fields to update on the training data resource: name, version, source_uri, schema_hash, (optional model ID), record count.",
      "typeName": "IShoppingAiTrainingData.IUpdate"
    },
    "responseBody": {
      "description": "The updated AI training data resource entity.",
      "typeName": "IShoppingAiTrainingData"
    },
    "path": "/shopping/aiTrainingData/{id}",
    "method": "put"
  },
  {
    "specification": "Delete an existing AI training dataset. Removes the resource and preserves audit evidence per data governance requirements. Mapped to the ai_training_data table, soft deletion or audit-logged hard deletion is supported. Only authorized roles (admins, ML/data custodians) may invoke this operation.",
    "description": "This endpoint deletes an AI training data resource identified by its unique ID. While physical deletion may be replaced by soft deletion (or archiving), the operation is always logged in the evidence/audit records, capturing actor, time, and rationale for compliance.\n\nSecurity controls and role checks are enforced. The operation may be rejected if the resource is attached to immutable compliance logs, is under investigation, or already deleted. Idempotency is supported: deleting an already-deleted or non-existent entry returns success. Related endpoints allow creation, update, and retrieval.",
    "summary": "Delete an existing AI training dataset (ai_training_data table).",
    "parameters": [
      {
        "name": "id",
        "description": "Target AI training data resource ID (UUID) to delete.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Confirmation or metadata/status of the deleted AI training data entity.",
      "typeName": "IShoppingAiTrainingData"
    },
    "path": "/shopping/aiTrainingData/{id}",
    "method": "delete"
  },
  {
    "specification": "Search and paginate through AI feature store records. Mapped to the ai_feature_store table, this endpoint supports flexible querying and filtering over feature sets registered for AI models, including search by feature name, model version, training dataset, creation timestamps, and other relevant dimensions. Pagination, sorting, and advanced search are built-in per best practices.",
    "description": "Allows authorized users to query the feature store registry. The endpoint accepts complex search parameters (name match, model version, training dataset, created_at range, etc.) and supports pagination (page/limit), sorting (fields, order), and optional full-text search on description or schema fields. Only users with access rights to the relevant model or dataset can access this endpoint.\n\nSecurity, evidence preservation, and compliance auditing are enforced. Unusual search patterns, failed authentications, or excessive request volume are logged for monitoring. Rejection reasons include query validation errors, insufficient permissions, or compliance policy blocks.",
    "summary": "List/search AI feature store sets with paging and filtering (ai_feature_store table).",
    "parameters": [],
    "requestBody": {
      "description": "Search and filtering criteria for AI feature store records, plus pagination and sorting info.",
      "typeName": "IShoppingAiFeatureStore.IRequest"
    },
    "responseBody": {
      "description": "Paginated list of AI feature store records matching criteria.",
      "typeName": "IPageIShoppingAiFeatureStore"
    },
    "path": "/shopping/aiFeatureStore",
    "method": "patch"
  },
  {
    "specification": "Fetch the details of a specific AI feature store record by its unique ID. The operation targets the ai_feature_store table and retrieves all fields, including associations with the AI model version, training dataset, schema, and other metadata.",
    "description": "Retrieves the full information for an AI feature store entity marked by given ID. Output includes the feature set name, schema, description, associated model version, training dataset, and creation timestamp. Evidence and access audit logs are generated for traceability. Permissions: only users with authorized model/dataset access can use this endpoint.\n\nReturns 'not found' for non-existent IDs or unauthorized access (RBAC error). Audit logs preserve the details of each access for compliance. Companion endpoints: PATCH for search, POST for creation, PUT/DELETE for mutation.",
    "summary": "Get a single AI feature store record by ID (ai_feature_store table).",
    "parameters": [
      {
        "name": "id",
        "description": "Target AI feature store record ID (UUID).",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Detailed AI feature store record.",
      "typeName": "IShoppingAiFeatureStore"
    },
    "path": "/shopping/aiFeatureStore/{id}",
    "method": "get"
  },
  {
    "specification": "Create a new AI feature store record. Adds a new feature set entry—used for AI model training or inference—mapped to the ai_feature_store table. Accepts all required descriptive fields: name, description (optional), schema (JSON), associated model version, optional training dataset, and timestamps.",
    "description": "Enables authorized data scientists or ML engineers to register a new feature set in the platform's feature store. Accepts all relevant fields for the ai_feature_store entity, including the model version it serves (required) and optionally the training dataset ID, plus a human-facing label, description, and a machine-readable schema. Input validation and permissions checks are enforced. The action is fully logged; duplicate entries are blocked by uniqueness constraints.\n\nAudit logs track the creation for future compliance and explainability. Related endpoints: PATCH for search, GET by ID, PUT for updates, DELETE for removal.",
    "summary": "Create a new AI feature store record (ai_feature_store table).",
    "parameters": [],
    "requestBody": {
      "description": "Information for new AI feature store entry: name, model version ID, (optional) training data ID, description, feature schema.",
      "typeName": "IShoppingAiFeatureStore.ICreate"
    },
    "responseBody": {
      "description": "Created AI feature store record.",
      "typeName": "IShoppingAiFeatureStore"
    },
    "path": "/shopping/aiFeatureStore",
    "method": "post"
  },
  {
    "specification": "Update an existing feature store record by ID. This operation is mapped to the ai_feature_store table and allows modification of fields such as the name, description, schema, associated model version, and optional training dataset. Audit fields and entity identity are immutable. The operation is evidence logged for compliance.",
    "description": "Updates the provided fields of an existing AI feature store record identified by its unique ID. Only editable properties (name, description, schema, model version, training dataset) may be changed; all modifications are evidence/audit logged and permissions enforced. Non-editable fields or invalid modification attempts result in errors. Access limited to authorized roles (data scientists, admins).\n\nIf the specified record does not exist, returns 'not found'. Update logs attached to entity for full traceability. Companion endpoints: POST to create, PATCH for search, GET for inspect, DELETE for remove.",
    "summary": "Update an existing AI feature store record (ai_feature_store table).",
    "parameters": [
      {
        "name": "id",
        "description": "Target AI feature store record ID (UUID) to update.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": {
      "description": "Fields to update for the AI feature store (name, description, schema, etc).",
      "typeName": "IShoppingAiFeatureStore.IUpdate"
    },
    "responseBody": {
      "description": "Updated AI feature store record.",
      "typeName": "IShoppingAiFeatureStore"
    },
    "path": "/shopping/aiFeatureStore/{id}",
    "method": "put"
  },
  {
    "specification": "Delete an existing AI feature store record. Mapped to the ai_feature_store table, the endpoint disables or removes a feature set entry by its unique ID. Audit/evidence logging is mandatory. Only authorized users may perform this operation.",
    "description": "Deletes an AI feature store entity identified by its unique ID. The entity is either soft-deleted (recommended, evidence preserved) or hard-deleted according to platform policy, but all deletions are logged in the evidence/audit tables specifying actor, rationale, and affected fields. Deletion rejects entities in active regulatory, compliance, or model production use.\n\nNot found or already deleted cases are treated idempotently. Only allowed for authorized users (admin/data scientist/ML engineer roles). Related endpoints: create, update, detail and search operations.",
    "summary": "Delete an existing AI feature store record (ai_feature_store table).",
    "parameters": [
      {
        "name": "id",
        "description": "Target AI feature store record ID (UUID) to delete.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Status/metadata of the deleted AI feature store record.",
      "typeName": "IShoppingAiFeatureStore"
    },
    "path": "/shopping/aiFeatureStore/{id}",
    "method": "delete"
  },
  {
    "specification": "List and search AI decision logs. This endpoint queries the ai_decision_logs table, enabling advanced search, filtering, sorting, and pagination over AI-driven decision events and their corresponding metadata, including model version, user, entity type, rationale, and creation timestamp. Designed for audit, compliance, and explainability workflows.",
    "description": "Allows data scientists, auditors, and authorized managers to perform advanced searches over all AI model inference records, filtering by model version, user, entity type, time window, and explainability rationale. Pagination (page/limit), flexible sorting (by created_at, rationale, etc.), and optional free-text search are included. Query activity is itself audit-logged.\n\nProper permissions are enforced according to security and governance policy; excessive or abusive querying is monitored. Related endpoints: detail GET, POST create (rare/manual insertion), PUT update, DELETE remove.",
    "summary": "Search and paginate AI decision logs (ai_decision_logs table).",
    "parameters": [],
    "requestBody": {
      "description": "Filtering/search criteria for AI decision logs with pagination/sorting options.",
      "typeName": "IShoppingAiDecisionLogs.IRequest"
    },
    "responseBody": {
      "description": "Paginated result set of AI decision log records.",
      "typeName": "IPageIShoppingAiDecisionLogs"
    },
    "path": "/shopping/aiDecisionLogs",
    "method": "patch"
  },
  {
    "specification": "Get details of a specific AI decision log by its ID. Reads ai_decision_logs table, returning all atomic fields and evidence for the indicated event, including model version, entity/user, decision outcome, input snapshot, and audit metadata. Supports explainability and evidence flows.",
    "description": "Retrieves a single AI decision log record by its unique ID, including all audit and decision data (entity, user, model version, input context, rationale, and event timestamp). Access control and compliance logging are strictly enforced. If unauthorized, returns permission error; if not found, returns not found error. Audit logs include accessor, time, and data involved.\n\nCompanion endpoints: PATCH for search, POST for create, PUT for update.",
    "summary": "Get a specific AI decision log by ID (ai_decision_logs table).",
    "parameters": [
      {
        "name": "id",
        "description": "Target AI decision log record ID (UUID).",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Details of the specified AI decision log entry.",
      "typeName": "IShoppingAiDecisionLogs"
    },
    "path": "/shopping/aiDecisionLogs/{id}",
    "method": "get"
  },
  {
    "specification": "Create a new AI decision log entry. Mapped to the ai_decision_logs table, this endpoint is used (primarily by automated ML systems) to write a record of an AI model's inference/decision at runtime. Registers atomic event data: model version, user/entity, inference input, outcome, rationale, and timestamp. All creation is regulatory/audit logged.",
    "description": "Enables insertion of a new AI decision log event—typically via ML workflow hooks or for compliance testing—documenting model involved, input snapshot, decision output, affected entity/user, and rationale for action. Restricted to internal, system, or authorized operators only. Input is validated, integrity-checked, and uniqueness/policy rules are enforced. All creation is logged for compliance.\n\nAudit logs track actor, time, and all data submitted for subsequent evidence review. Related endpoints: PATCH for search, GET by ID, PUT/DELETE for mutation.",
    "summary": "Create a new AI decision log entry (ai_decision_logs table).",
    "parameters": [],
    "requestBody": {
      "description": "Information required for logging AI model decision event (model version, input, decision, etc).",
      "typeName": "IShoppingAiDecisionLogs.ICreate"
    },
    "responseBody": {
      "description": "Created AI decision log entity.",
      "typeName": "IShoppingAiDecisionLogs"
    },
    "path": "/shopping/aiDecisionLogs",
    "method": "post"
  },
  {
    "specification": "Update an existing AI decision log entry by ID. Allows correction/reason augmentation of decision log metadata. Mapped to the ai_decision_logs table, only authorized users/systems may perform updates (auditor, admin). Audit/evidence fields and entity identity are immutable. Change is strictly audit/evidence logged. Rejects if record not found, update not allowed, or RBAC fails.",
    "description": "Modify permissible metadata fields of an existing decision log identified by its ID—e.g., rationale, input snapshot, or (if allowed) correction of associated model version. Regulatory and evidence controls require full traceability and immutability of audit evidence; thus, only select non-core fields may be amended. All operations are secured, hence RBAC errors or not found responses are returned where appropriate.\n\nEach update writes a full evidence log. Companion endpoints: POST create, PATCH for search, GET for details, DELETE for removal.",
    "summary": "Update an existing AI decision log entry (ai_decision_logs table).",
    "parameters": [
      {
        "name": "id",
        "description": "Target AI decision log record ID (UUID) to update.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": {
      "description": "Fields to update for decision log metadata (rationale, input snapshot, etc).",
      "typeName": "IShoppingAiDecisionLogs.IUpdate"
    },
    "responseBody": {
      "description": "Updated AI decision log entity.",
      "typeName": "IShoppingAiDecisionLogs"
    },
    "path": "/shopping/aiDecisionLogs/{id}",
    "method": "put"
  },
  {
    "specification": "Removes a single AI Decision Log entity from the registry, handling reference cleanup and compliance audit. Related to AI-native functionality in continuous learning, explainability, and audit log preservation. Entity is 'ai_decision_logs' from the AdvancedAI namespace. Deletion includes cryptographic audit trace and regulatory evidence chaining.",
    "description": "This operation enables the permanent removal of an AI Decision Log entry recorded by the AI-native backend. The API ensures the correct deletion sequence—removing the decision log entity from the underlying data store, cleaning up related audit chains, and preserving non-repudiable evidence in compliance snapshot systems.\n\nCareful attention is paid to regulatory/logging requirements as outlined in the advanced AI and compliance modules. This includes triggering an archival audit entry, and supporting evidence trace from compliance/evidence preservation modules. If the entity has associated feedback records or evidence, those links must be analyzed to avoid dangling references.\n\nThe endpoint enforces permission checks (RBAC), logs deletion for full audit recovery, and rejects deletions if linked evidences are still legally required. In cases of failure (foreign key constraints, evidence hold, etc), a detailed error with failure reason is returned.",
    "summary": "Delete an AI Decision Log entity (AdvancedAI.ai_decision_logs).",
    "parameters": [
      {
        "name": "id",
        "description": "Unique identifier of the AI Decision Log to delete.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Result of deletion, with compliance and audit info.",
      "typeName": "IAdvancedAI.AiDecisionLogDeleteResult"
    },
    "path": "/shopping/aiDecisionLogs/{id}",
    "method": "delete"
  },
  {
    "specification": "Retrieves a filtered and/or paginated list of AI Feedback events, allowing for search, filtering, and advanced analytics. Core to the AdvancedAI.ai_feedback entity, supporting compliance, ongoing learning, and explainability. PATCH method allows for complex queries, search, and sorting.",
    "description": "This operation enables advanced searching, filtering, and list retrieval for AI Feedback records. It supports rich queries including filters on user, feedback type, model decisions, and time range. Pagination options and sorting are also supported by the request body.\n\nThe operation is used for analytics, model retraining prep, and compliance reporting. It references detailed requirements for AI feedback loops, compliance traceability, and evidence preservation. Returned data includes full feedback detail, with summary counts if requested.\n\nPermissions checks are enforced according to RBAC/ABAC, and all reads are logged for compliance, especially under auditing regimes tracking AI explainability and continuous learning KPIs. Failure conditions (invalid filters, access denied) return structured errors.",
    "summary": "List, search, and filter AI Feedback events (AdvancedAI.ai_feedback).",
    "parameters": [],
    "requestBody": {
      "description": "Query/filter/sort options for paginated AI Feedback retrieval.",
      "typeName": "IAdvancedAI.AiFeedbackQuery"
    },
    "responseBody": {
      "description": "Paginated, filtered AI Feedback list with full feedback details and summary data as needed.",
      "typeName": "IPageIAdvancedAI.AiFeedback"
    },
    "path": "/shopping/aiFeedback",
    "method": "patch"
  },
  {
    "specification": "Retrieves a single AI Feedback record, including all details for compliance, explainability, and evidence preservation. Tied to the AdvancedAI.ai_feedback entity.",
    "description": "Used to fetch all information about a specific AI Feedback instance by its primary key. Returns all details including user, decision log, feedback type/value, and extra metadata, ensuring regulatory and compliance requirements for explainability and evidence traceability are satisfied.\n\nIncludes all required cross-entity lookups for audit and model retraining workflows. Access checks and evidence permission handling enforced per compliance and RBAC/ABAC modules.\n\nFailure to find the feedback entity (invalid id or soft-deleted) returns a not-found error with fully localized message for global, accessible UX.",
    "summary": "Get detail for a single AI Feedback record (AdvancedAI.ai_feedback).",
    "parameters": [
      {
        "name": "id",
        "description": "Unique identifier of the AI Feedback record.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Detailed AI Feedback entity matching provided id, with all compliance and evidence fields.",
      "typeName": "IAdvancedAI.AiFeedback"
    },
    "path": "/shopping/aiFeedback/{id}",
    "method": "get"
  },
  {
    "specification": "Creates a new AI Feedback record for continuous learning, explainability feedback, and compliance reporting. Core to AdvancedAI.ai_feedback, supporting user-driven and system-driven feedback logging.",
    "description": "This operation inserts a new AI Feedback entity, representing either explicit user/model feedback or system-inferred events. All attributes required by the 3NF schema are captured, including decision log reference, feedback type, value, associated user, and timing/metadata.\n\nThe insert process records compliance evidence, hashes, and ensures evidence preservation in line with the AI-native requirements. Validation of referenced decision log and user entities is performed before creation. Upon success, the new feedback record is persisted with audit/compliance trigger.\n\nErrors arise from invalid references, business rule violations, or permission denials, all handled as structured responses with full compliance context.",
    "summary": "Create a new AI Feedback entity (AdvancedAI.ai_feedback).",
    "parameters": [],
    "requestBody": {
      "description": "New AI Feedback information to be created.",
      "typeName": "IAdvancedAI.AiFeedback.ICreate"
    },
    "responseBody": {
      "description": "Created AI Feedback entity with full evidence/audit chain.",
      "typeName": "IAdvancedAI.AiFeedback"
    },
    "path": "/shopping/aiFeedback",
    "method": "post"
  },
  {
    "specification": "Updates an existing AI Feedback record, reflecting new compliance or evidence details, feedback changes, or corrections. Tied to AdvancedAI.ai_feedback; PUT is for idempotent, full replacement/updates.",
    "description": "This operation allows the modification of an existing AI Feedback record by id. The provided payload must contain all fields to replace, according to the update/replace paradigm. Compliance with auditability and evidence preservation is mandatory—changes are recorded in audit chains and cross-entity validation enforced.\n\nThe operation checks for the entity's existence, validates reference consistency (decision log, user id), and ensures only authorized entities can update (permission checks/RBAC). All field changes are evidence-tracked and logged for regulatory and explainability purposes in AI-native flows. If business or referential rules are violated, a failure is returned with specific error reasons.\n\nSuccess returns the fully updated feedback entity with all compliance/audit metadata.",
    "summary": "Update (replace) an existing AI Feedback record (AdvancedAI.ai_feedback).",
    "parameters": [
      {
        "name": "id",
        "description": "Unique identifier of the AI Feedback record to update.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": {
      "description": "Full replacement/update for the AI Feedback record.",
      "typeName": "IAdvancedAI.AiFeedback.IUpdate"
    },
    "responseBody": {
      "description": "The updated AI Feedback entity with compliance/audit trace.",
      "typeName": "IAdvancedAI.AiFeedback"
    },
    "path": "/shopping/aiFeedback/{id}",
    "method": "put"
  },
  {
    "specification": "Deletes a single AI Feedback record from the evidence registry, supporting compliance, model retraining traceability, and evidence preservation. Part of AdvancedAI.ai_feedback.",
    "description": "This operation handles the deletion of an AI Feedback entity, including removal from the feedback registry, compliance support for audit events, and evidence preservation. Cascade rules apply: related audit or evidence links are checked for safe deletion.\n\nRBAC permission rules are followed, with all removals triggering audit trails. Compliance/evidence modules are referenced, and in cases where deletion is prevented due to regulatory or legal hold, the operation will return a structured, descriptive error.\n\nThe operation ensures data integrity for ongoing or future model training and explainability reporting.",
    "summary": "Delete an AI Feedback record (AdvancedAI.ai_feedback).",
    "parameters": [
      {
        "name": "id",
        "description": "Unique identifier of the AI Feedback record to delete.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Result of deletion, with audit trail and compliance status.",
      "typeName": "IAdvancedAI.AiFeedbackDeleteResult"
    },
    "path": "/shopping/aiFeedback/{id}",
    "method": "delete"
  },
  {
    "specification": "Retrieves a paginated, filtered list of security event logs for compliance, incident analysis, and security audit. Entity is 'security_event' from SecurityCompliance namespace. PATCH method enables advanced search, filtering, and sorting.",
    "description": "This operation allows security, compliance, and admin personnel to list and search security_event records with advanced filters (event type, user, session, date range). Pagination and sorting are also handled in the request body.\n\nRead access is permission/role-guarded, and every access is logged for compliance and audit, enabling full traceability of event usage. All responses include supporting evidence or audit context text for regulatory compliance.\n\nFailure scenarios (invalid filters, permission denial, etc.) are returned as structured errors with clear diagnostic info.",
    "summary": "List, search, and filter security events (SecurityCompliance.security_event).",
    "parameters": [],
    "requestBody": {
      "description": "Filter, search, sort, and pagination options for security event logs.",
      "typeName": "ISecurityCompliance.SecurityEventQuery"
    },
    "responseBody": {
      "description": "Paginated, filtered list of security events with evidence and audit info.",
      "typeName": "IPageISecurityCompliance.SecurityEvent"
    },
    "path": "/shopping/securityEvent",
    "method": "patch"
  },
  {
    "specification": "Retrieves the detail of a single security event by id. Supports compliance audit, incident investigation, and event traceability. Entity is SecurityCompliance.security_event.",
    "description": "Fetches complete detail on a single security event, including user, session, API client, event type, context, and timestamps. Returns all fields necessary for full compliance, audit, and incident analysis.\n\nDetailed permission and access checks apply, with RBAC enforced and access logged for regulatory trace. Not-found results (id not found or archived) return error object suitable for compliance export and accessible UI needs.",
    "summary": "Get detail for a security event log record (SecurityCompliance.security_event).",
    "parameters": [
      {
        "name": "id",
        "description": "Unique identifier of security event to retrieve.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Single security event log detail with all compliance/evidence fields.",
      "typeName": "ISecurityCompliance.SecurityEvent"
    },
    "path": "/shopping/securityEvent/{id}",
    "method": "get"
  },
  {
    "specification": "Creates a new security event log, registering an incident for audit, compliance, or automated security response requirements. Entity is SecurityCompliance.security_event.",
    "description": "This endpoint registers a new security event—such as a login attempt, token rotation, misuse detection, etc.—providing atomic evidence for incident analysis and compliance audits. All event attributes are captured, and evidence preservation (e.g., cryptographic chaining or file reference) is triggered.\n\nThe event record is immediately available for audit or investigation, and triggers relevant compliance and monitoring checks. Business rule validation, required fields, and actor reference checks are performed before accepting any insertion. Rejected events (validation error, forbidden actor, illegal timestamp, etc.) return structured error objects, ensuring transparency and regulatory trace.",
    "summary": "Create a new security event log (SecurityCompliance.security_event).",
    "parameters": [],
    "requestBody": {
      "description": "New security event information to insert.",
      "typeName": "ISecurityCompliance.SecurityEvent.ICreate"
    },
    "responseBody": {
      "description": "Created security event record including compliance evidence and audit chain metadata.",
      "typeName": "ISecurityCompliance.SecurityEvent"
    },
    "path": "/shopping/securityEvent",
    "method": "post"
  },
  {
    "specification": "Updates an existing security event log, e.g., for correcting event details, adding audit context, linking to incident management or evidence. Entity is SecurityCompliance.security_event. PUT is for full replacement/update by id.",
    "description": "Allows modification of a security event entity, such as correction of detail, appending evidence links, or compliance adjustments (e.g., marking as investigated). The payload must contain a complete replacement set for all required and updatable fields, and operation is fully permission-guarded.\n\nAll changes are recorded in audit chain, supporting both regulatory compliance and forensics. Validation includes referential integrity for linked users/sessions/API clients, time consistency, and event status logic.\n\nSuccess returns fully updated event entity and compliance/audit reporting context. Failure returns structured error indicating constraint violation or permission failure.",
    "summary": "Update (replace) an existing security event (SecurityCompliance.security_event).",
    "parameters": [
      {
        "name": "id",
        "description": "Unique identifier of the security event to update.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": {
      "description": "Full replacement/update of security event log fields.",
      "typeName": "ISecurityCompliance.SecurityEvent.IUpdate"
    },
    "responseBody": {
      "description": "Updated security event log record, evidence, and audit chain info.",
      "typeName": "ISecurityCompliance.SecurityEvent"
    },
    "path": "/shopping/securityEvent/{id}",
    "method": "put"
  },
  {
    "specification": "Deletes a single security event entity for compliance, audit correction, or administrative privilege. Entity: SecurityCompliance.security_event.",
    "description": "Handles the safe deletion of a security event record, including all compliance and evidence preservation logic. Business rules restrict deletion for events under investigation or with legal hold. Audit record is always appended on removals, describing action and actor. Deleted events and their associated evidence are not physically erased, but soft-deleted for chain-of-custody trace.\n\nOperation logs all attempts, successes, and denials for transparency. Failure (e.g., foreign key constraint, compliance hold) produces structured errors with detailed audit commentary for use in regulatory exports.",
    "summary": "Delete a security event record (SecurityCompliance.security_event).",
    "parameters": [
      {
        "name": "id",
        "description": "Unique identifier of the security event to delete.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Result of deletion, evidence and audit compliance info.",
      "typeName": "ISecurityCompliance.SecurityEventDeleteResult"
    },
    "path": "/shopping/securityEvent/{id}",
    "method": "delete"
  },
  {
    "specification": "Retrieves a filtered, paginated list of fine-grained permission definitions for all platform entities, as required for evidence/audit, RBAC enforcement, policy management, and extensibility. Entity is SecurityCompliance.permission. PATCH is used for advanced query/sorting/search.",
    "description": "This endpoint enables searching, filtering, and paginated listing of permission definitions. Filters may include permission code, description, policy assignment, and date range. Supports fulltext, RBAC-enforced access, and compliance log trails.\n\nResponses adhere to strict regulatory logging and audit standards. The operation logs query access for compliance, and all responses include the required context for regulatory export. Failures (permission denied, invalid queries) return structured errors with detailed explanation for compliance/UI needs.",
    "summary": "List/search permission registry (SecurityCompliance.permission).",
    "parameters": [],
    "requestBody": {
      "description": "Query/filter/sort options for permission list retrieval.",
      "typeName": "ISecurityCompliance.PermissionQuery"
    },
    "responseBody": {
      "description": "Paginated/filtered Permission registry entries with audit/evidence metadata.",
      "typeName": "IPageISecurityCompliance.Permission"
    },
    "path": "/shopping/permission",
    "method": "patch"
  },
  {
    "specification": "GET /shopping/permission/{id}: Retrieve detailed information of a specific permission record in the shopping mall backend. This operation is strictly related to the 'permission' table in the Prisma schema (model: permission), which catalogs fine-grained permissions used throughout the platform. It's essential for auditing, managing access, and enforcement of role-based or policy-driven security. The response must provide all column details including code, description, policy linkage, and creation timestamp, referencing relational context (such as associated policy if applicable). Ensure appropriate error handling for non-existent IDs or access denial. The permissions system underlies modular business operations and compliance boundaries. Only users with admin or compliance-related privileges can access sensitive permission data via this endpoint.",
    "description": "This API operation fetches a specific permission by its ID from the permission table. The permission entity is described in the schema as a unique atomic right or capability, with properties like code (e.g., 'order.edit'), description (what this right entails), and an optional foreign key to its associated policy. Permissions are essential for implementing strict RBAC or ABAC controls. This endpoint provides a full explainer: code, business meaning, policy association, and detailed description. Access is controlled to administrators or services with explicit audit privileges. The implementation ensures evidence-grade logging of parameter access and permissions checks, maintaining auditability as per compliance requirements. Error handling returns 404 for missing ID and 403/401 for unauthorized access. To enumerate or filter permissions lists see the PATCH /shopping/permission endpoint (not included here).",
    "summary": "Fetch a specific permission entity from the permission table by ID.",
    "parameters": [
      {
        "name": "id",
        "description": "Unique identifier for the permission record to retrieve.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Detailed information about the requested permission.",
      "typeName": "shoppingPermission"
    },
    "path": "/shopping/permission/{id}",
    "method": "get"
  },
  {
    "specification": "POST /shopping/permission: Create a new permission entity in the permissions registry. This operates directly on the Prisma 'permission' table, forming the foundation for role and policy-based security models across the platform. The API enforces uniqueness on the code property and associates the permission with a policy if specified. On success, the new permission record—including code, description, and policy linkage if any—is returned, alongside audit logs for compliance. This endpoint is restricted to administrators and compliance operators with explicit creation rights. Attempts to create duplicates, blanks, or unauthorized access are error-logged per regulatory requirements. All inputs and mutation history are stored for traceability.",
    "description": "This endpoint enables creation of a new permission in the permission table (see Prisma model: permission). The input must include: code (unique across the system, e.g., 'user.read'), a business-context description, and optionally policy_id if this permission is governed by a specific policy. The implementation validates uniqueness and required fields, logs all creation attempts (success or error), and ties mutations to the initiating admin user for evidence and regulatory exports. Failure cases include 409 for code conflicts and 400 for missing/invalid parameters. Use this endpoint to expand or refactor the permission taxonomy as the business logic and regulatory landscape evolve.",
    "summary": "Create a new permission entity in the permission registry.",
    "parameters": [],
    "requestBody": {
      "description": "Required data for creating a new permission entry.",
      "typeName": "shoppingPermission.ICreate"
    },
    "responseBody": {
      "description": "The newly created permission record.",
      "typeName": "shoppingPermission"
    },
    "path": "/shopping/permission",
    "method": "post"
  },
  {
    "specification": "PUT /shopping/permission/{id}: Update attributes of a specific permission entity. Directly manages the Prisma 'permission' table, supporting updates to code, description, and policy associations as business logic or regulatory requirements change. Enforces uniqueness of permission code (unless unchanged), and updates all relevant audit logs. All modifications are evidence-preserved for compliance and traceability. Access is locked to privileged admins or compliance auditors only. Provides full updated permission object on success, or 404 for not found, 409 for code conflict, and 403/401 for permission denials. This endpoint is critical for adapting access models to new business and compliance needs.",
    "description": "Updates an existing permission by ID. Supported updates include permission code (e.g., 'discount.manage'), description, and associated policy (policy_id). The endpoint references the permission table in the Prisma schema, which underlies granular access controls for all platform modules. Uniqueness constraint on code is enforced. All changes (successful or denied) are logged for evidentiary and compliance reasons, suitable for export in audit logs. The implementation supports rollback and high-verifiability of change history, meeting requirements for non-repudiation in high-compliance sectors. Error responses for missing or conflicting states, as well as unauthorized modifications, follow platform-wide standards.",
    "summary": "Update details of an existing permission entity in the permission table.",
    "parameters": [
      {
        "name": "id",
        "description": "Unique identifier for the permission record to update.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": {
      "description": "Fields to update for the permission entity.",
      "typeName": "shoppingPermission.IUpdate"
    },
    "responseBody": {
      "description": "The updated permission record with all properties.",
      "typeName": "shoppingPermission"
    },
    "path": "/shopping/permission/{id}",
    "method": "put"
  },
  {
    "specification": "DELETE /shopping/permission/{id}: Remove a specific permission record permanently from the permission registry (Prisma table: permission). Permanent deletion is only available under extraordinary circumstances and is subject to strict audit and permission checks, as irreversibly removing a permission can impact regulatory/compliance obligations. This is typically limited to super-admins or compliance officers. The operation logs all relevant evidence of deletion, including who performed it, justification, and affected roles or policies. Attempts to remove permissions linked to active users/policies should be prevented at the business logic level and produce an appropriate error. Returns confirmation of deletion or a detailed error object.",
    "description": "Deletes a permission entity by its unique ID from the permission table. Business logic must ensure the permission is not actively referenced in critical policy/role assignments. This endpoint is used extremely sparingly, mainly for regulatory or incident-driven workflows. Deletion triggers an immutable audit log documenting the deletion actor, timestamp, and business rationale. The operation is restricted to core compliance personnel and top-level system administrators. Proper care is needed to avoid accidental cascading privilege loss. On error, returns a 404 if the permission doesn't exist, or 409 if deletion is blocked by dependent objects. Success responses confirm deletion and provide traceable evidence hash.",
    "summary": "Permanent deletion of a specific permission entity from the registry.",
    "parameters": [
      {
        "name": "id",
        "description": "Unique identifier for the permission record to delete.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Result of the deletion operation with evidentiary tracking.",
      "typeName": "shoppingPermission.IDeleteResult"
    },
    "path": "/shopping/permission/{id}",
    "method": "delete"
  },
  {
    "specification": "PATCH /shopping/policy: Retrieve a filtered or searched list of permission policies in the shopping mall backend. Relates directly to the Prisma 'policy' table, which stores access control and restriction policies linked to permissions and roles. The endpoint supports advanced filtering (by name, content, condition), pagination, and sorting, aligned with requirements for regulatory audit, extensibility, or role management. Results should include all policy columns and optionally counts or summaries for usage contexts. High-volume use cases include policy review, access audits, and permission assignment workflows. Only users with the correct audit or admin rights can enumerate all or filtered policy records.",
    "description": "This API operation queries the policy table for a paginated, optionally filtered list of policies. Supports advanced queries: name/condition substring matching, sort order, and limit/offset, using a structured request body. This satisfies the requirement for reviewing all active and historical policies—critical for system audits, evidence preservation, and proactive compliance work. Returned objects must contain all core policy properties, including description, name, and serialized condition logic. The operation logs all access for forensic and regulatory traceability. Error responses cover invalid filters or access violations. For direct reads by ID, use GET /shopping/policy/{id}.",
    "summary": "List/filter access control policies for permissions and roles.",
    "parameters": [],
    "requestBody": {
      "description": "Query parameters for filtering, searching, and paginating policies.",
      "typeName": "shoppingPolicy.IRequest"
    },
    "responseBody": {
      "description": "Paged or filtered list of policy records matching the request.",
      "typeName": "IPageShoppingPolicy"
    },
    "path": "/shopping/policy",
    "method": "patch"
  },
  {
    "specification": "GET /shopping/policy/{id}: Retrieve full detail for a specific policy entity by ID. This endpoint targets the 'policy' table in Prisma, which catalogs named access control policies—aggregating, describing, and configuring fine-grained business and regulatory controls across the platform. The endpoint returns the complete policy entity, including name, serialized logic/conditions, related permissions, and creation timestamp. This is essential for compliance and role assignment workflows, and for administrative audit/reporting. Access is restricted to privileged administrators and regulatory/audit actors. Provides comprehensive error handling for not found (404) and permission denied.",
    "description": "Fetches the details of a specific policy by its unique ID. The policy model, as described in the Prisma schema, manages logical groupings and constraints for system permissions, such as regional restrictions, time-based access, or dynamic business logic. This operation enables compliance staff and admins to review detailed policy configuration—a requirement for platform audit-readiness and troubleshooting. The API response includes all atomic properties: name, description/conditions, timestamp, and relations as permitted. Full audit-trail is maintained for query access. If the policy does not exist, a 404 error is returned. Use PATCH /shopping/policy for list/search functionality.",
    "summary": "Retrieve a specific policy entity and its details by ID.",
    "parameters": [
      {
        "name": "id",
        "description": "Unique identifier for policy entity to retrieve.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "The policy entity with all properties and relations.",
      "typeName": "shoppingPolicy"
    },
    "path": "/shopping/policy/{id}",
    "method": "get"
  },
  {
    "specification": "POST /shopping/policy: Create a new access control policy within the security module. Targets the Prisma 'policy' table, which defines grouped sets of permissions and rules. New policies should include a name, serialized condition expression (e.g., constraint logic), and, optionally, a human-level description. Creation operations are logged for evidence and compliance, including the initiator's identity and timestamp. Only privileged system administrators or compliance managers may invoke this endpoint. Errors are returned for duplicates (by name), missing parameters, or permission violations. The new policy entity is returned on success, with all properties and unique identifier.",
    "description": "Creates a new entry in the policy table. The request body must include name (unique display name for policy), conditions (serialized expression describing access logic), and optionally, a business-context description string. The policy entity, as per schema, is central to RBAC/ABAC enforcement and compliance audits. All creation operations are attributed to the initiating admin, with full audit trail. Business logic checks for duplicate names and validates the structural correctness of the policy logic (conditions field). All attempts are logged for forensic traceability. Error handling for name conflicts (409), malformed requests (400), or forbidden access (403/401) as standard.",
    "summary": "Create a new policy entity in the access control system.",
    "parameters": [],
    "requestBody": {
      "description": "Required fields for creating a new policy.",
      "typeName": "shoppingPolicy.ICreate"
    },
    "responseBody": {
      "description": "The newly created policy record.",
      "typeName": "shoppingPolicy"
    },
    "path": "/shopping/policy",
    "method": "post"
  },
  {
    "specification": "PUT /shopping/policy/{id}: Update the fields of an existing policy entity by its ID. This endpoint enables modification of critical security controls at the policy level—directly updating the Prisma 'policy' table, which stores logical groupings and condition expressions for access rules. Allowed modifications: name (if unique), serialized condition logic, and optional business context. All changes are logged for audit/compliance. Permission is exclusive to system/global security admins and compliance officers. Returns updated policy entity on success, or appropriate error object if update cannot be performed (not found, name conflict, or access denied).",
    "description": "Updates an existing policy record in the policy table by ID. Fields that may be altered include name (must remain unique), conditions (logic/expressions), and optionally, business-context description. Full audit/trace is required for evidence, ensuring that every modification is attributable. The operation underpins dynamic and regulatory security requirements. Schema-level constraints mean changes to a policy’s name are checked for collision, and edits to logic must pass structural validation. Error codes as standard: 404 for not found, 409 for conflicts, 403/401 for denied. Successful response returns the modified policy entity object.",
    "summary": "Update an existing policy entity and its core data.",
    "parameters": [
      {
        "name": "id",
        "description": "ID of policy entity to update.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": {
      "description": "Fields for updating the policy entity.",
      "typeName": "shoppingPolicy.IUpdate"
    },
    "responseBody": {
      "description": "The updated policy entity.",
      "typeName": "shoppingPolicy"
    },
    "path": "/shopping/policy/{id}",
    "method": "put"
  },
  {
    "specification": "DELETE /shopping/policy/{id}: Permanently remove a specific policy record from the access control layer. Interacts with the Prisma 'policy' table. Deletion is restricted to super-admins and compliance staff only, and must be logged for evidence and compliance. Policy deletions may only proceed if there are no dependent permission or role references—otherwise, the operation must fail gracefully with a clear error. Upon success, returns confirmation and audit evidence details of the operation. This endpoint is leveraged for regulatory cleanup, incident response, and periodic security reviews. All actions are stored as evidence for compliance inquiries.",
    "description": "Deletes a policy entity from the policy table by its ID. Policy records represent grouped permissions and rules for restricting and granting access in line with business and regulatory requirements. Business logic must check for dependent entities (permissions still assigned), and block deletion if present. If dependencies allow, deletion is performed with full audit-trail (who/when/why) and evidence hash returned in response. Access is locked to system or compliance-level actors. Nonexistent records return 404, conflict cases 409, and audit failures are escalated. The endpoint is a keystone for compliance–oriented systems with strict evidence trails.",
    "summary": "Permanently delete a specific policy entity after checks/auditing.",
    "parameters": [
      {
        "name": "id",
        "description": "Unique ID of policy entity to delete.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Deletion result with evidentiary evidence and confirmation.",
      "typeName": "shoppingPolicy.IDeleteResult"
    },
    "path": "/shopping/policy/{id}",
    "method": "delete"
  },
  {
    "specification": "PATCH /shopping/auditLog: Retrieve a paginated or filtered list of system audit logs from the shopping mall platform. Interacts with the Prisma 'audit_log' table, storing immutable evidence of all system and user actions for regulatory and forensic purposes. This endpoint is used for compliance, incident response, and business auditing—enabling filters on action type, entity, actor, or date range. Appropriate permission checks are mandatory, as audit logs may involve highly sensitive information. Results include all audit columns and may be filtered, sorted, or paged with the proper request parameters.",
    "description": "Enables filtered or paginated query of audit logs from the audit_log table of the schema. The audit_log entity records all significant user and system actions, with properties such as action (operation performed), entity_type (affected table/type), entity_id (target record), initiating user, context (JSON metadata of the event), and timestamp. This endpoint allows compliance auditors and admins to retrieve a time-sliced or entity-specific history—critical for legal holds, forensic review, and incident resolution. Returned records must include all original evidence fields. The operation logs all queries for further evidence, and restricts access to privileged audiences. For single-record reads, use GET /shopping/auditLog/{id}.",
    "summary": "List and filter audit logs for regulatory or forensic review.",
    "parameters": [],
    "requestBody": {
      "description": "Parameters for querying audit logs, support for filters and pagination.",
      "typeName": "shoppingAuditLog.IRequest"
    },
    "responseBody": {
      "description": "Page or filtered list of matching audit log entries.",
      "typeName": "IPageShoppingAuditLog"
    },
    "path": "/shopping/auditLog",
    "method": "patch"
  },
  {
    "specification": "GET /shopping/auditLog/{id}: Retrieve details of a specific audit log entry by its ID. This accesses the 'audit_log' table, which stores immutable and comprehensive event records for the shopping mall backend—critical for regulatory compliance, evidence traceability, and forensics. Returns the full fields of the specified audit log row, including action, entity context, actor, evidence linkage, and the event's context for reconstruction of histories. Restricted to compliance, administrative, or incident-response actors. Returns 404 if the log id does not exist, and logs all access for non-repudiable evidence.",
    "description": "Fetches a specific audit_log entity detail from the audit_log table. Each audit_log represents atomic evidence for an event—a user or system-triggered operation with all context and cryptographic evidence. Fields include action type, entity metadata, context blob, references to user and evidence archive, and the precise timestamp. This endpoint is used in compliance reviews, legal audits, and incident investigations. Access is tightly controlled; the request is evidence-logged, and failures (not found or unauthorized) return 404/401/403. For batch or filtered queries, use PATCH /shopping/auditLog.",
    "summary": "Retrieve a single audit log entry and its full event evidence.",
    "parameters": [
      {
        "name": "id",
        "description": "Unique identifier for the audit log entry.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Detailed result for the selected audit log row.",
      "typeName": "shoppingAuditLog"
    },
    "path": "/shopping/auditLog/{id}",
    "method": "get"
  },
  {
    "specification": "POST /shopping/auditLog: Create an audit log entry. Directly inserts into the 'audit_log' table to record a user or system event, ensuring non-repudiation and compliance with system-wide evidence-preservation mandates. The operation should receive all required atomic fields (action, entity_type, etc) and assign additional metadata (such as evidence_archive linkage) as appropriate. Only privileged system components may invoke this endpoint; all writes are themselves evidence-logged and attributed to the actor. Validates entity id or context fields, and assigns timestamps. Returns the full record on success or a structured error on failure. No duplicate detection is required, as every action is unique.",
    "description": "Creates a new entry in the audit_log table to record an event or action—by user, system, or integration. The required body fields are action (event), entity_type (targeted entity), (optionally) entity_id, context (JSON), and, if available, user and evidence_archive linkage. Audit log creation is a keystone of evidence/compliance for regulated sectors (GDPR, CCPA, legal, etc). Every write is immutable, never deleted. Used by both backend modules and security systems for full traceability. The operation is strictly permissioned for security and compliance oversight. Successful creation returns the new audit_log record; failures return 400/403/500 as appropriate. For reading, see PATCH/GET auditLog endpoints.",
    "summary": "Create an audit log entry for a user/system event.",
    "parameters": [],
    "requestBody": {
      "description": "New audit log details for event evidence record.",
      "typeName": "shoppingAuditLog.ICreate"
    },
    "responseBody": {
      "description": "The log entry as written, with all atomic properties.",
      "typeName": "shoppingAuditLog"
    },
    "path": "/shopping/auditLog",
    "method": "post"
  },
  {
    "specification": "Updates an existing audit log entry in the audit_log table. Each audit log records a system or user action, with references to the involved user, entity, evidence, and context. Updating an entry allows for correcting metadata, appending additional context, or modifying the audit action as allowed by business logic and regulatory requirements. Certain fields such as the created_at timestamp and evidence references may be immutable depending on compliance. All updates must ensure evidence preservation and full traceability, with auditability in the history of changes. This operation typically requires elevated permissions and is logged for further scrutiny. Related APIs include audit log creation and retrieval endpoints.",
    "description": "This API operation updates an existing audit log record identified by its unique ID. The audit_log table records critical user or system actions, and updates might be needed to correct the context, change the action description, or associate new evidence. Update operations must maintain full evidence integrity—immutable fields like action timestamps and entity references are controlled according to compliance standards. Updates should be logged to guarantee traceability, and prior states may need to be preserved for forensic or compliance reviews. Permission checks are required due to the sensitive nature of audit trails. This API is generally used in administrative dashboards or automated compliance tools. If updates would break the non-repudiation requirement (such as changing critical evidence pointers), the operation should be rejected with a clear error message. All attempts to update audit logs should themselves be recorded in a separate audit trail for regulatory review.",
    "summary": "Update an audit_log entry in the shopping system (audit_log table).",
    "parameters": [
      {
        "name": "id",
        "description": "The unique identifier of the audit_log entry to update.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": {
      "description": "Information for updating the audit_log entry.",
      "typeName": "shoppingAuditLog.IUpdate"
    },
    "responseBody": {
      "description": "The updated audit_log entry.",
      "typeName": "shoppingAuditLog"
    },
    "path": "/shopping/auditLog/{id}",
    "method": "put"
  },
  {
    "specification": "Deletes an existing audit log entry by its unique ID in the audit_log table. The audit_log table stores evidence-preserving records of system or user actions, referenced for compliance, forensics, and regulatory reporting. Deleting an audit_log entry is highly restricted—soft deletion or archival is preferred to maintain non-repudiation and evidence preservation. This endpoint typically marks the record as deleted, without physically removing it, ensuring all original evidence remains intact. Such operations require strict permission validation, with all deletion attempts, successful or failed, themselves logged for compliance. Relates to audit log retrieval and update operations.",
    "description": "This endpoint deletes a specific audit_log entry, identified by its unique ID, from the audit_log table. The deletion process usually involves marking the record as deleted (soft delete) rather than true removal, to preserve evidence and legal compliance. Attempts to remove entries with unresolved legal holds or active compliance requirements must result in errors and log detailed reasons. Deletion is generally restricted to users with high-level or regulatory permissions, and all such actions are themselves subject to audit. This operation should be paired with review or retrieval endpoints to confirm deletion state for regulatory and support workflows.",
    "summary": "Delete an audit_log entry by ID in the shopping system (audit_log table).",
    "parameters": [
      {
        "name": "id",
        "description": "The unique identifier of the audit_log entry to delete.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Result of the deletion operation (typically the soft-deleted audit_log entry or status).",
      "typeName": "shoppingAuditLog"
    },
    "path": "/shopping/auditLog/{id}",
    "method": "delete"
  },
  {
    "specification": "Retrieve a list of compliance reports from the compliance_report table, with support for advanced search, filtering, and pagination. Each compliance_report entry documents regulatory, privacy, or audit findings, linked to users or organizations. This endpoint allows admins and compliance officers to locate reports based on date, status, report type, and entity associations. It must conform to evidence preservation and security standards, applying access controls and logging all query operations for regulatory review. Pagination is required for large datasets. Related endpoints: individual retrieval, creation, update, or deletion of reports.",
    "description": "This endpoint allows authorized users to query the compliance_report table for a list of generated compliance or regulatory reports. The endpoint supports extensive filtering, search, and pagination parameters, including report type, status, date range, and ownership (user or organization). Returned results contain summary information and pointers to detailed report data. Access to this operation is typically limited to compliance officers, admins, or designated reviewers, and all data access is logged for audit/compliance. Security constraints ensure that users receive only allowed reports, and queries against confidential or legal hold data are controlled by policy. Pagination is enforced to manage large result sets. This operation is often used in compliance dashboards and automated auditing workflows.",
    "summary": "Search, paginate, and list compliance_report entries (compliance_report table).",
    "parameters": [],
    "requestBody": {
      "description": "Query parameters for searching and paginating compliance_report entries.",
      "typeName": "shoppingComplianceReport.IRequest"
    },
    "responseBody": {
      "description": "Paginated summary of compliance_report entries matching the query.",
      "typeName": "IPageShoppingComplianceReport"
    },
    "path": "/shopping/complianceReport",
    "method": "patch"
  },
  {
    "specification": "Retrieves the full details of a compliance_report entry by its unique ID from the compliance_report table. Each compliance_report provides a record of regulatory findings, user data exports, or internal audits, and is referenced for legal, operational, and accountability purposes. This operation supports full evidence tracking, access control (who can read each report), and logs all access for regulatory compliance. Associated endpoints: search/list, create, update, delete.",
    "description": "This endpoint allows an authorized user to read a specific compliance_report by its unique ID. The retrieved data includes all report attributes and linked metadata, such as user or organization references, report type and status, generated and published dates, and pointers to associated evidence or export files. Reading compliance reports is restricted to users with compliance, legal, or audit permission, with all access logged as required by regulatory rules. Attempts to access reports under legal hold or protected classification may trigger errors or redacted responses. This operation is core to compliance dashboards and export reviews.",
    "summary": "Get a compliance_report entry by ID (compliance_report table).",
    "parameters": [
      {
        "name": "id",
        "description": "The unique identifier of the compliance_report to retrieve.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Detailed compliance_report entry.",
      "typeName": "shoppingComplianceReport"
    },
    "path": "/shopping/complianceReport/{id}",
    "method": "get"
  },
  {
    "specification": "Creates a new compliance_report entry in the compliance_report table. Each report records a compliance export, audit finding, or regulatory outcome for a user or organization. This operation requires strict input validation, ensuring all mandatory report attributes (owner, report_type, status, generated timestamp) are provided. Evidence preservation, non-repudiation, and immediate audit logging are mandatory; upon creation, a snapshot of creation context must be taken. Only privileged users or automated audit triggers should access this endpoint. Associated endpoints: list, get, update, delete compliance_report.",
    "description": "This endpoint enables privileged users or automated audit systems to add a new compliance_report to the system. It validates supplied request data for completeness and compliance (user/org association, report type, status, generation date, and publication plan), and creates the new compliance record in the database. All activity is audit-logged for traceability and regulatory review. Data is protected according to the report's classification and legal rules. This API is generally used in compliance dashboards, periodic audit scripts, or during regulatory data exports. On success, returns the full created compliance_report entry.",
    "summary": "Create a new compliance_report in the shopping system (compliance_report table).",
    "parameters": [],
    "requestBody": {
      "description": "Data for the new compliance_report entry.",
      "typeName": "shoppingComplianceReport.ICreate"
    },
    "responseBody": {
      "description": "The created compliance_report entry.",
      "typeName": "shoppingComplianceReport"
    },
    "path": "/shopping/complianceReport",
    "method": "post"
  },
  {
    "specification": "Updates an existing compliance_report by ID in the compliance_report table. Each report details a compliance audit, export, or regulatory review for a user or organization, and tracks status, content, and evidence. This operation allows for status changes (e.g. 'pending' to 'published'), error corrections, or attaching new evidence/publish metadata. All updates are evidence-preserving and logged for non-repudiation; critical fields may be immutable under regulatory policy. Permission checks and update audit trails are enforced. Associated endpoints: retrieval, listing, creation, or deletion of compliance_report entries.",
    "description": "This endpoint allows privileged users or audit systems to update an existing compliance_report identified by its ID. Permitted updates include changing report status, adding publication date, updating classification, or correcting descriptive info. Every update must preserve original evidence—immutable fields are protected as required for compliance, and attempts to alter critical audit data result in errors. All changes are themselves audit-logged for regulatory traceability. This API is used in compliance export processes, legal reviews, and dashboard workflows.",
    "summary": "Update a compliance_report entry in the shopping system (compliance_report table).",
    "parameters": [
      {
        "name": "id",
        "description": "The unique identifier of the compliance_report entry to update.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": {
      "description": "Information for updating the compliance_report entry.",
      "typeName": "shoppingComplianceReport.IUpdate"
    },
    "responseBody": {
      "description": "The updated compliance_report entry.",
      "typeName": "shoppingComplianceReport"
    },
    "path": "/shopping/complianceReport/{id}",
    "method": "put"
  },
  {
    "specification": "Deletes a compliance_report entry by ID from the compliance_report table, implementing evidence-preserving soft deletion in most cases. Compliance reports document exports, audits, or regulatory reviews and must remain discoverable for audit and legal review, even after deletion. This operation should only mark the entry as deleted, leaving evidence for audit, and requires strict permission checks and audit logging. Associated with creation, update, or retrieval of compliance_report.",
    "description": "This endpoint deletes a specific compliance_report entry by its unique ID, typically via soft delete which preserves the record's audit evidence and context. Actual data is not removed, but marked as deleted to ensure compliance, non-repudiation, and legal chain-of-custody. Attempts to delete reports with unresolved legal holds or in-use classifications are rejected, with errors logged. Restricted to compliance officers and subject to additional audit review. Used in regulatory management dashboards or automated cleanup scripts.",
    "summary": "Delete a compliance_report entry by ID (compliance_report table).",
    "parameters": [
      {
        "name": "id",
        "description": "The unique identifier of the compliance_report entry to delete.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Result of the deletion operation (typically the soft-deleted compliance_report entry or status).",
      "typeName": "shoppingComplianceReport"
    },
    "path": "/shopping/complianceReport/{id}",
    "method": "delete"
  },
  {
    "specification": "Advanced list endpoint for data_retention table, allowing searching, filtering, and paginating data retention policy records. Each data_retention entry configures policy for a data entity, with assignment to an organization. This endpoint supports searching by entity_type, organization_id, legal hold status, and retention period. Security and evidence preservation is enforced; access, queries, and all operations against this endpoint are themselves audit-logged. Pagination is enforced for large data sets. Related endpoints: data retention creation, update, retrieval, deletion.",
    "description": "This API allows authorized users to list and search data_retention policy records, filtered by criteria such as entity_type, organization, legal hold state, and retention period. The data_retention table tracks policy for every schema entity and is referenced for legal compliance, deletion, and evidence review. All queries and their parameters are logged for audit/compliance. Pagination and security constraints are strictly enforced. This operation is often used in administrative and compliance dashboards and as a backend for scheduled data retention reviews or policies.",
    "summary": "Search, filter, and paginate shopping data_retention records (data_retention table).",
    "parameters": [],
    "requestBody": {
      "description": "Search and pagination criteria for data_retention entries.",
      "typeName": "shoppingDataRetention.IRequest"
    },
    "responseBody": {
      "description": "Paginated results of matching data_retention entries.",
      "typeName": "IPageShoppingDataRetention"
    },
    "path": "/shopping/dataRetention",
    "method": "patch"
  },
  {
    "specification": "Retrieves full detail of a data_retention entry by unique ID from data_retention table. A data_retention entry configures a legal or compliance data retention policy for a schema/entity within an organization. Reading retention policy details supports compliance review, policy editing, legal audits, and automated data lifecycle enforcement. Every access is logged for non-repudiation and evidence. Access controls govern which users can see specific policies, especially for sensitive entities such as user or payment data. Associated operations: list/search entries, create/update, delete.",
    "description": "This endpoint retrieves all metadata and policy fields for a specific data_retention entry, identified by its unique ID. Details include organization association, entity_type, retention period in days, legal hold status, and policy creation time. Access is governed by compliance/audit permissions. Attempts to view inapplicable or protected policies are rejected or redacted as required by compliance. Every endpoint access is logged for audit. This API is typically used in compliance tools, admin dashboards, and automated data lifecycle enforcement processes.",
    "summary": "Get a data_retention entry by ID (data_retention table).",
    "parameters": [
      {
        "name": "id",
        "description": "The unique identifier of the data_retention entry to retrieve.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Full data_retention policy detail.",
      "typeName": "shoppingDataRetention"
    },
    "path": "/shopping/dataRetention/{id}",
    "method": "get"
  },
  {
    "specification": "Creates a new data_retention entry in the data_retention table. Each record establishes a policy for retention, deletion, or legal hold for a specific entity type within an organization, enforcing regulatory or business data lifecycle requirements. Strict input validation is required for organization association, entity_type, retention period, and legal hold state. All creation requests and results are audit-logged for compliance and non-repudiation. Endpoint requires appropriate compliance permissions. Related APIs: list, get, update, delete data_retention entries.",
    "description": "This endpoint creates a new data_retention policy record after validating all mandatory policy attributes (organization/context, entity_type, retention_period_days, and legal hold flag). All creation attempts and created records are audit-logged for compliance, with appropriate permission checks enforced. On successful creation, returns the new data_retention policy entry with all metadata. Used in compliance dashboards or scheduled compliance configuration workflows.",
    "summary": "Create a new data_retention entry in shopping system (data_retention table).",
    "parameters": [],
    "requestBody": {
      "description": "Data for the new data_retention entry.",
      "typeName": "shoppingDataRetention.ICreate"
    },
    "responseBody": {
      "description": "The created data_retention entry.",
      "typeName": "shoppingDataRetention"
    },
    "path": "/shopping/dataRetention",
    "method": "post"
  },
  {
    "specification": "Updates an existing data_retention entry by ID in the data_retention table. Each record governs a compliance data retention policy for a schema/entity and organization. Permitted updates include period adjustments, legal hold toggling, or contextual changes; all such changes are evidence-preserving and immutably logged. Organization association or entity_type changes may be restricted. All update requests are audit-logged. Permissions and compliance checks are strictly enforced. Related endpoints: retrieval, search/list, creation, and deletion.",
    "description": "This endpoint enables modifications to a data_retention policy by its unique ID. Allowed updates include changing the retention period in days, toggling is_legal_hold, or updating the entity_type or organization association (where permitted by policy). All updates are audit-logged and protected by compliance constraints. Certain changes may be disallowed if there is an active legal hold or regulatory requirement. The original creation time and prior versions remain immutable and recoverable. Designed for use in admin and compliance dashboards and for compliance workflow automation.",
    "summary": "Update a data_retention entry in shopping system (data_retention table).",
    "parameters": [
      {
        "name": "id",
        "description": "The unique identifier of the data_retention entry to update.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": {
      "description": "Information for updating the data_retention entry.",
      "typeName": "shoppingDataRetention.IUpdate"
    },
    "responseBody": {
      "description": "The updated data_retention entry.",
      "typeName": "shoppingDataRetention"
    },
    "path": "/shopping/dataRetention/{id}",
    "method": "put"
  },
  {
    "specification": "Deletes a data_retention entry by ID from data_retention table, implementing evidence-preserving (soft) deletion in most cases. data_retention entries control entity-level data lifecycle requirements for compliance and legal hold tracking. This operation marks the entry as deleted, leaving evidence for audit, with hard deletion only allowed under special conditions. Attempting to delete policies under legal hold is forbidden. Action is deeply audited and requires strict permissions. Related APIs: create, get, update, search data_retention.",
    "description": "This endpoint deletes a specific data_retention entry identified by its unique ID, typically performing a soft (evidence-preserving) deletion rather than true removal. Legal holds or compliance rules may prohibit or delay deletion; such attempts must return error with rationale. All deletion operations are recorded in immutable audit logs, and regular access controls are enforced. Used in compliance dashboards, policy cleanup processes, or regulatory workflows.",
    "summary": "Delete a data_retention entry by ID (data_retention table).",
    "parameters": [
      {
        "name": "id",
        "description": "The unique identifier of the data_retention entry to delete.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Result of the deletion operation (typically the soft-deleted data_retention entry or status).",
      "typeName": "shoppingDataRetention"
    },
    "path": "/shopping/dataRetention/{id}",
    "method": "delete"
  },
  {
    "specification": "Provides a paginated, searchable list of evidence archive records for the shopping mall system. Enables regulatory, forensics, and legal query support for evidence_archive, as per Prisma schema. Incorporates evidence type, checksum, and date filters for compliance and audit queries. Pagination and sorting are required for navigating large amounts of evidence data. Matches strict evidence preservation boundaries. Follows best practices for access control and data security on audit-grade archives.",
    "description": "This operation returns a paginated list of evidence archive entries, supporting filtering by evidence type, creation date, or checksum. Users with appropriate permissions can query archived evidence, supporting compliance with regulatory, legal, and internal audit requirements. Access should be tightly controlled due to the sensitivity of the data. Pagination, sorting, and search parameters are processed in the request body as per system conventions.",
    "summary": "List evidenceArchive records for audit and compliance evidence tracking (evidence_archive table).",
    "parameters": [],
    "requestBody": {
      "description": "Filtering, pagination, and search options for evidence archive records.",
      "typeName": "IEvidenceArchive.IRequest"
    },
    "responseBody": {
      "description": "Paginated list of evidence archive records matching query criteria.",
      "typeName": "IPageIEvidenceArchive"
    },
    "path": "/shopping/evidenceArchive",
    "method": "patch"
  },
  {
    "specification": "Retrieves a single evidence archive record from the shopping mall system. Based on the evidence_archive table from Prisma, this operation fetches metadata and references for immutable, securely archived evidence objects, such as blobs for legal holds, GDPR exports, or compliance snapshots. Designed for detailed audit, legal, and operational review use cases. All access and visibility are tightly regulated due to the sensitive nature of evidence data.",
    "description": "This operation returns detailed information about a particular evidence archive, identified by its unique ID. The result includes metadata such as evidence type, creation timestamp, cryptographic checksum, blob URL, and size. It supports regulators, forensic examiners, and administrators who require access to immutable evidence records. Error handling covers invalid IDs, unauthorized access, and non-existent records.",
    "summary": "Fetch a single evidenceArchive record for forensic or compliance review (evidence_archive table).",
    "parameters": [
      {
        "name": "id",
        "description": "Unique identifier for the evidence archive record to retrieve.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Detailed metadata of the specific evidence archive entry.",
      "typeName": "IEvidenceArchive"
    },
    "path": "/shopping/evidenceArchive/{id}",
    "method": "get"
  },
  {
    "specification": "Creates a new evidence archive record in the shopping mall system. As specified in the evidence_archive Prisma table, this endpoint enables registering compressed, signed, or reference-only evidence blobs required for audit trails, legal compliance, and investigative retention. Only users with high-level permissions should invoke this operation. Evidence registration is atomic and cryptographically sealed for non-repudiation and legal defense.",
    "description": "This operation creates and registers a new evidence archive entry. Incoming data includes evidence type, blob URI, checksum, and size. On success, a secure immutable record is created for long-term retention, and a unique ID is returned. All registration actions are logged for compliance. Strict validation is enforced, and failure or duplicate attempts return an error. Supports enforcement of organizational or legal policies for evidence management.",
    "summary": "Register a new evidenceArchive for legal/forensic compliance (evidence_archive table).",
    "parameters": [],
    "requestBody": {
      "description": "Details necessary to create an evidence archive record, including type, blob URL, size, and checksum.",
      "typeName": "IEvidenceArchive.ICreate"
    },
    "responseBody": {
      "description": "The created evidence archive record, with its unique ID and metadata.",
      "typeName": "IEvidenceArchive"
    },
    "path": "/shopping/evidenceArchive",
    "method": "post"
  },
  {
    "specification": "Updates an existing evidence archive record in the shopping mall system. This endpoint, as specified in evidence_archive Prisma schema, supports modifications like metadata update, typically for annotation or administrative correction (e.g., updating evidence description, not the cryptographic or binary content). Actual evidence blobs remain immutable, reflecting compliance and non-repudiation policy. Only system administrators and privileged auditors should perform updates. Strict logging and transparency are required for all changes.",
    "description": "This operation updates allowed metadata fields for an evidence archive record, such as description or context. The evidence content, type, and checksum fields cannot be modified to preserve evidence integrity. Success returns the updated record; failure returns error details. All updates are comprehensively logged to satisfy regulatory and forensic requirements. Unauthorized or invalid modifications are blocked.",
    "summary": "Update evidenceArchive metadata for extended compliance or annotation (evidence_archive table).",
    "parameters": [
      {
        "name": "id",
        "description": "Unique identifier of the evidence archive record to update.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": {
      "description": "Metadata updates for the evidence archive record (excluding blob or checksum changes).",
      "typeName": "IEvidenceArchive.IUpdate"
    },
    "responseBody": {
      "description": "The updated evidence archive record.",
      "typeName": "IEvidenceArchive"
    },
    "path": "/shopping/evidenceArchive/{id}",
    "method": "put"
  },
  {
    "specification": "Deletes (softly archives) an evidence archive record in the shopping mall system. In line with evidence_archive design, does not remove the physical blob, but marks the record as deleted for compliance, retention, or legal hold purposes. Deletion is heavily logged for audit trails. Only privileged users (e.g., compliance officers) can invoke this. No actual evidence content is lost or modified.",
    "description": "This operation flags an evidence archive record as deleted (soft delete), preserving immutable audit trails in compliance with evidence retention regulations. When deleted, the evidence is no longer retrievable for ordinary queries but is held for legal, forensic, or regulatory review. Regulatory export and rollback are supported. Actual blob is untouched, and all deletions are logged for accountability. Deleted records may still be visible via privileged endpoints or reports.",
    "summary": "Soft delete an evidenceArchive record for evidence retention/audit (evidence_archive table).",
    "parameters": [
      {
        "name": "id",
        "description": "Unique identifier of the evidence archive record to delete.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Metadata of the evidence archive record after deletion (soft deletion).",
      "typeName": "IEvidenceArchive"
    },
    "path": "/shopping/evidenceArchive/{id}",
    "method": "delete"
  },
  {
    "specification": "Provides a paginated, searchable list of API client records for the shopping mall system. Designed per api_clients table in Prisma schema for API/omnichannel extensibility. Allows auditing, registration review, and key access management for third-party, partner, or internal API clients. Includes filters for active/inactive, client name, creation date, and more. Only system administrators or technical operators may access.",
    "description": "This operation provides a paginated API to list and filter registered API clients, supporting audit, onboarding, and integrator management flows. Filtering parameters include active status, time range, and partial client naming. All endpoint access must be role-protected due to the privilege of the data. Pagination and result limits apply to support large-scale integrations.",
    "summary": "List apiClients for integrator and partner API management (api_clients table).",
    "parameters": [],
    "requestBody": {
      "description": "Filtering and pagination parameters for API client records.",
      "typeName": "IApiClient.IRequest"
    },
    "responseBody": {
      "description": "Paginated API client records matching search criteria.",
      "typeName": "IPageIApiClient"
    },
    "path": "/shopping/apiClients",
    "method": "patch"
  },
  {
    "specification": "Retrieves a single API client record from the shopping mall system. This endpoint fetches metadata and credentials (excluding secret tokens) for a registered API integration, as per api_clients Prisma schema. Used for integration onboarding, credential validation, and audit. Sensitive information is secured; only privileged users access detailed integration metadata. All access and retrieval are logged for compliance and incident response.",
    "description": "This operation retrieves detailed metadata about a specific API client integration, identified by its unique ID. Returns details such as name, contact, activation status, and public key/certificate information for partnered or internal API integrators. Handles errors for not found, permissions, or invalid input. Results aid technical onboarding, security review, and operational audits. Response never exposes secret credentials or revoked data.",
    "summary": "Fetch a single apiClient for security and integration management (api_clients table).",
    "parameters": [
      {
        "name": "id",
        "description": "Unique identifier of the API client record to retrieve.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Metadata and descriptive record for the specified API client.",
      "typeName": "IApiClient"
    },
    "path": "/shopping/apiClients/{id}",
    "method": "get"
  },
  {
    "specification": "Registers a new API client integration in the shopping mall system. This endpoint creates a record as per api_clients Prisma schema, supporting onboarding of partner, B2B, or internal API consumers. Includes client name, description, contact, public key/certificate, and activation status. Operation is tightly permissioned, access-logged, and triggers auditing and credential provisioning flows. All sensitive credential data is processed and stored securely, never returned in the response.",
    "description": "This operation creates a new API client integration for programmatic access to shopping mall APIs. Sets metadata such as client name, contact email, public key, etc. Successful creation returns a unique client ID and displayable details, excluding generated secrets or tokens. Appropriate role and audit logging are enforced, and failure returns error with diagnostics. Registration may trigger further onboarding automation.",
    "summary": "Register a new apiClient for partner or internal integration (api_clients table).",
    "parameters": [],
    "requestBody": {
      "description": "Metadata to register a new API client, including name, contact, and public key information.",
      "typeName": "IApiClient.ICreate"
    },
    "responseBody": {
      "description": "The registered API client record, with unique ID and readable attributes.",
      "typeName": "IApiClient"
    },
    "path": "/shopping/apiClients",
    "method": "post"
  },
  {
    "specification": "Updates properties of an existing API client record in the shopping mall system. This endpoint, as per api_clients Prisma schema, allows modification of display information, activation/deactivation, or public key updates. Credentials/secrets are never returned or stored insecurely. Operation is tightly logged for audit, onboarding support, and incident management. Only privileged roles may perform updates.",
    "description": "This operation allows permitted administrators to update details about an API client integration, such as description, contact email, activation status, or public key. Secrets or API tokens cannot be directly changed here. All updates are access-logged and reflected in audit trails for regulatory and security compliance. Invalid or unauthorized updates return standardized errors. Only system-level roles can use this endpoint.",
    "summary": "Update apiClient metadata or authorizations for integration management (api_clients table).",
    "parameters": [
      {
        "name": "id",
        "description": "Unique identifier of the API client record to update.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": {
      "description": "Update payload for API client integration (excluding credentials/secrets).",
      "typeName": "IApiClient.IUpdate"
    },
    "responseBody": {
      "description": "Updated record of the API client integration.",
      "typeName": "IApiClient"
    },
    "path": "/shopping/apiClients/{id}",
    "method": "put"
  },
  {
    "specification": "Deletes (softly archives) an API client integration in the shopping mall system. This endpoint, specified in api_clients Prisma schema, sets a soft delete flag for an API client record, preventing future API access or onboarding. Actual client data and audit trails are preserved for incident forensic and regulatory requirements. Only platform administrators or compliance officers can use this operation. Client deletion is logged and supports operational analytics and compliance reporting.",
    "description": "This operation disables (soft deletes) an API client integration, preventing any future API calls or token issuance. The client record is marked as deleted for evidence and audit; no data is permanently erased. Soft deletion supports GDPR, breach response, and incident analysis, and may trigger downstream deactivation in channel or token management. All actions are logged for compliance.",
    "summary": "Soft delete or disable an apiClient integration (api_clients table).",
    "parameters": [
      {
        "name": "id",
        "description": "Unique identifier of the API client integration to delete.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "API client metadata after soft deletion or disablement.",
      "typeName": "IApiClient"
    },
    "path": "/shopping/apiClients/{id}",
    "method": "delete"
  },
  {
    "specification": "Provides a paginated, searchable list of API access tokens for the shopping mall system. Based on api_tokens in Prisma schema, this supports audit, security review, and operational token lifecycle management. Filters can be applied on client, status, expiry, or issued-at metadata. Intended for privileged users to review issued/active/revoked tokens. Token values are never returned, only metadata. Strict data retention and auditing applies.",
    "description": "This operation provides a paginated API for listing metadata about API access tokens, such as issued tokens, expiration, revoked status, and associated API clients. Token credentials themselves are never exposed. Filtering supports client ID, active status, expiration range. Designed for operational security, compliance, and large-scale integration management. Result set follows secure pagination, no sensitive exposures due to token sensitivity.",
    "summary": "List apiTokens for integration token lifecycle management (api_tokens table).",
    "parameters": [],
    "requestBody": {
      "description": "Filtering, pagination, and search parameters for API token metadata.",
      "typeName": "IApiToken.IRequest"
    },
    "responseBody": {
      "description": "Paginated tokens with descriptive metadata for security/compliance review.",
      "typeName": "IPageIApiToken"
    },
    "path": "/shopping/apiTokens",
    "method": "patch"
  },
  {
    "specification": "Retrieves metadata and information for a single API access token, as tracked by the api_tokens table. Supports audit, security review, and incident investigation. Token credential is never returned, only metadata such as issued_at, expires_at, revoked_at, client association, and scope. Accessible only by administrators and security personnel, all access is logged for regulatory compliance.",
    "description": "This operation fetches metadata for a single API token, given its unique ID. Fields may include client, scope, issuance, expiry, and status, but never the raw token value. Error handling for unauthorized/invalid/not found cases is strict. Audit trail is preserved for all accesses. Used for incident response, root cause analysis, and operational monitoring.",
    "summary": "Fetch single apiToken metadata for security/operations (api_tokens table).",
    "parameters": [
      {
        "name": "id",
        "description": "Unique identifier of the API access token to retrieve.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Metadata only (not credentials) for specified API token.",
      "typeName": "IApiToken"
    },
    "path": "/shopping/apiTokens/{id}",
    "method": "get"
  },
  {
    "specification": "This operation creates a new API Token in the shopping API_Omnichannel module. It is associated with the api_tokens table in Prisma and implements token creation, including managing API client relations, scopes, issuance, expiry, and optional revocation metadata. It ensures PCI and security compliance with audit logging for all secret generation and assignment actions. Only privileged admins or integration onboarding flows should access this API for API key provisioning. Upon creation, all fields must be validated according to business and compliance rules, including reference integrity to API clients. Token values must be hashed before storage; raw values are returned only once upon creation. Evidence of the token's creation with issued_at and initial scope is preserved for audit, and actions are logged for non-repudiation.",
    "description": "This endpoint allows for the secure creation of an API access token, which is an essential credential for authenticating API and omnichannel client integrations. The created token is linked to a specific API client, stores scope and expiration policies, and is never stored in plaintext after issuance due to PCI-level security requirements. Authorization is mandatory and restricted to users with sufficient privilege, such as system administrators or application onboarding automation. Compliance evidence (issued_at, audit log entry) is generated for each operation. The request body requires comprehensive validation—specifically, correct API client linkage (api_client_id), policy-compliant scope definition, and institutional consistency in expiry policy. Raw tokens are returned ONLY in creation response and are not retrievable afterward for security. Creation is always append-only; rotation and revocation must use dedicated APIs. Auditable failures (e.g., scope violation, missing client) generate documented error states. Related operations include GET/PATCH for retrieval, and DELETE for revocation. This operation does not update or remove tokens.",
    "summary": "Create a new shopping API Token (api_tokens table, API_Omnichannel module).",
    "parameters": [],
    "requestBody": {
      "description": "Information required to create an API token for a registered client.",
      "typeName": "IShoppingApiToken.ICreate"
    },
    "responseBody": {
      "description": "Detailed information of the newly created API token (raw token value as applicable, else hash/metadata).",
      "typeName": "IShoppingApiToken"
    },
    "path": "/shopping/apiTokens",
    "method": "post"
  },
  {
    "specification": "This operation updates a specific API Token's mutable properties within the shopping API_Omnichannel module, associated with the api_tokens Prisma table. It allows for rotating, expiring, or revoking a token (e.g., adjusting expiry, adding scope/permissions, or soft-revoking via revoked_at). All updates are tracked for audit and compliance by writing to audit logs and updating corresponding timestamps. Only certain fields are permitted to be modified after creation, maintaining compliance with evidence preservation requirements (revocation/expiration cannot fully erase records). Only authorized clients or privileged administrators may perform this action. All changes must pass strict validation (e.g., no extension of expired/revoked tokens except for documented rotation procedures).",
    "description": "This endpoint enables partial or full update of a specific API Token's properties, including expiry adjustments (expires_at), scope refinement, and revocation via revoked_at timestamp. Each update operation is logged for regulatory evidence, preserving previous values in the audit trail for full traceability. Raw token values can never be reset or overwritten via this endpoint (use rotate for fresh secrets); only scope and lifetime or revocation status may be changed. Authorization is required, restricted to privileged admins or owners of the API client. All changes must conform to compliance requirements (PCI-DSS, non-repudiable audit logs). Linked operations include POST (creation), DELETE (revoking tokens), and PATCH/GET for searching or retrieval. Errors in expired, already revoked, or permissionless modifications are handled with detailed compliance error messages.",
    "summary": "Update mutable properties (scope, expiry, revocation) of a specific shopping API Token (api_tokens table).",
    "parameters": [
      {
        "name": "id",
        "description": "UUID of the target API Token record to update in the api_tokens table.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": {
      "description": "Update information for a specific API Token, such as new expiry or scope.",
      "typeName": "IShoppingApiToken.IUpdate"
    },
    "responseBody": {
      "description": "Updated API Token information, reflecting changes (scope, expiry, revocation status).",
      "typeName": "IShoppingApiToken"
    },
    "path": "/shopping/apiTokens/{id}",
    "method": "put"
  },
  {
    "specification": "This operation soft-revokes (marks as revoked) a specific API Token in the shopping API_Omnichannel module (api_tokens table in Prisma). This is a compliance-critical flow for immediately invalidating credentials in case of breach, rotation, or integration retirement. Records are preserved for evidentiary and regulatory reasons; tokens are not physically deleted. Related audit entries must record the actor, revoked_at timestamp, and outcome. Authorization is tightly enforced, and operation is irreversible. Linked to compliance with PCI-DSS, integration partner offboarding, and incident response policies.",
    "description": "This endpoint allows for the secure and regulatory-compliant revocation of a specific API Token (per its UUID). It does not physically delete the token record, as required for audit and forensic traceability, but instead sets the revoked_at timestamp. This ensures non-repudiation and preserves the full token event trace for future compliance checks. Only privileged administrators or users with explicit authorization for API client integration management may trigger this action. Any attempt to access or use a revoked token will result in access denial at runtime. Compliance errors, such as attempting to revoke an already revoked token, are handled with clear audit logs.",
    "summary": "Revoke (soft-delete) a specific shopping API Token (api_tokens table) for compliance.",
    "parameters": [
      {
        "name": "id",
        "description": "UUID of the API Token to revoke (soft-delete/compliance).",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Details of the revoked API Token, including revoked_at timestamp and audit evidence.",
      "typeName": "IShoppingApiToken"
    },
    "path": "/shopping/apiTokens/{id}",
    "method": "delete"
  },
  {
    "specification": "This operation searches/shows a paginated list of API Audit records (api_audits table in shopping API_Omnichannel module). It implements a list retrieval allowing for filtering by API client, token, endpoint, dates, and actor, supporting compliance, review, forensic, and analytics needs. It requires sufficient privilege for audit data visibility as audit logs may contain sensitive or regulated information. Pagination, sorting, and search queries are supported as required for evidentiary, operational, or compliance review.",
    "description": "This endpoint allows privileged users or auditors to search, filter, and page through a list of API Audit records, including details of all API-level interactions, actors, endpoints, and outcomes. Filters may include time window, client, token, endpoint pattern, actor, and success/failure state, as per business logic. All returned records are evidence-grade and non-modifiable, supporting reconstruction of incident or access logs for compliance or forensics. Paginated results support operational scaling and compliance retention policies. Errors on unauthorized access or overbroad search requests are returned as compliance errors. Linked operations include API Audit detail (GET), creation (POST), and full/partial update (PUT/PATCH, typically only in exceptional correction scenarios as audit logs should be immutable).",
    "summary": "Paginated search/list operation for shopping API Audits (api_audits table).",
    "parameters": [],
    "requestBody": {
      "description": "Search and filter criteria for API Audits, such as client, token, endpoint, actor, or time window.",
      "typeName": "IShoppingApiAudit.IRequest"
    },
    "responseBody": {
      "description": "Paginated list of matching API Audit records with full evidence traceability.",
      "typeName": "IPageIShoppingApiAudit"
    },
    "path": "/shopping/apiAudits",
    "method": "patch"
  },
  {
    "specification": "This operation retrieves the full detail of a specific API Audit record by its UUID, associated with the api_audits table in the shopping API_Omnichannel module. It supports compliance, forensics, risk review, and traceability requirements for every API event. Linked to all event-level evidence logs and API operation decision points. Sufficient privilege is required for access due to sensitive nature of logs. Immutable and evidence-grade.",
    "description": "This endpoint fetches the evidence-grade detail of a single API Audit record. Typical consumers are auditors, incident responders, risk managers, or privileged administrators. Information includes request/response hashes, actors, decision logs (if associated with AI/ML flow), and metadata as recorded atomically at time of operation. Authorization is required, and unauthorized or out-of-scope users/clients receive permission errors. Related flows: PATCH for list/search, and (exceptionally) PUT for correction/amendment when permitted (audit logs are generally immutable). Errors when retrieving deleted/expired records are explicitly declared and logged. Directly supports incident response and regulatory requests for trace-level evidence.",
    "summary": "Get detail of a single shopping API Audit record (api_audits table).",
    "parameters": [
      {
        "name": "id",
        "description": "UUID of the API Audit record to retrieve in api_audits table.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Detailed API Audit record, with full field and evidence information.",
      "typeName": "IShoppingApiAudit"
    },
    "path": "/shopping/apiAudits/{id}",
    "method": "get"
  },
  {
    "specification": "This operation creates a new API Audit record in the shopping API_Omnichannel module (api_audits table in Prisma). It is used by internal and system actors to atomically document each API call, including client, token, actor, endpoint, AI/ML decision log reference, hashes, outcomes, and initial compliance context. Privileged authorization is required for direct manual insertion (normally system-generated). Full evidence preservation is required: all fields populated atomically, with request and response hashes computed per regulation. Newly created records are immutable (except for rare admin corrections—see PUT).",
    "description": "This endpoint enables the creation of a new API Audit record, representing the evidence-grade log of one API event (request/response) for a specific API client and token. Intended for use by backend logic, security subsystems, and privileged admin/debug scenarios. All request, actor, token, and endpoint metadata must be provided and validated upon entry; no record is ever deleted. Manual insertion (via API) is only for compliance remediation or for advanced audit logging integrations. Linked operations: PATCH (list/search), GET (retrieve), PUT (amend), DELETE (remove with compliance evidence, rarely). Failures to supply minimum required metadata or attempts to insert duplicate records are returned as explicit errors with audit evidence.",
    "summary": "Create a new shopping API Audit record (api_audits table, API_Omnichannel module).",
    "parameters": [],
    "requestBody": {
      "description": "Information required to create an API Audit record (complete, atomic evidence-grade log entry).",
      "typeName": "IShoppingApiAudit.ICreate"
    },
    "responseBody": {
      "description": "Newly created API Audit record with atomic, evidence-compliant data.",
      "typeName": "IShoppingApiAudit"
    },
    "path": "/shopping/apiAudits",
    "method": "post"
  },
  {
    "specification": "This operation updates or amends a specific API Audit record by its UUID, as part of the api_audits table in the shopping API_Omnichannel module. Audit logs are designed to be immutable, so usage is exceptional—e.g., evidence correction, redaction for legal/privacy compliance, or system remediation. Fully versioned and audit-trailed: new/old field values are preserved. Only system administrators or compliance officers may perform this operation, after explicit review. Evidence of adjustments must be clearly logged with rationale, user, and timestamps for regulatory compliance.",
    "description": "This endpoint commits a correction, redaction, or update to a specific API Audit record, allowing for repair of evidence logs in rare, regulated contexts (e.g., remediation after incident, privacy-ordered redaction). It is not for general modification—normal API logs are append-only and immutable. All operations are versioned, fully documented in meta-audit logs, and subject to review and approval. Privileged authorization is required. Typical changes may include redacting a mis-logged field, correcting misattributed actors, or supplying missing AI decision linkage. Linked operations: PATCH for list/search, GET for single record. Attempts to modify immutable or out-of-scope records are rejected with compliance errors. All successful changes include before/after details and audit traces.",
    "summary": "Amend or redact a single, immutable shopping API Audit record (api_audits table) for compliance or legal reasons.",
    "parameters": [
      {
        "name": "id",
        "description": "UUID of the API Audit record to amend/redact.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": {
      "description": "Details for the corrective amendment or redaction for an API Audit record.",
      "typeName": "IShoppingApiAudit.IUpdate"
    },
    "responseBody": {
      "description": "Updated API Audit record, reflecting the legal or compliance-mandated change.",
      "typeName": "IShoppingApiAudit"
    },
    "path": "/shopping/apiAudits/{id}",
    "method": "put"
  },
  {
    "specification": "This operation exceptionally deletes or expunges a specific API Audit record from the shopping API_Omnichannel module (api_audits table), as permitted only under strict compliance (e.g., legal order under GDPR right to erasure or regulatory mandate). All such deletions are themselves audited in a meta-log, and should preserve non-repudiation via evidence archive linkage or legal basis reference. Operation is absolutely restricted, always reviewed by compliance or legal. Links to evidence_archive and system audit_log for trace preservation. No routine user/admin can perform this operation.",
    "description": "This compliance-only endpoint permanently deletes a specific API Audit record, such as under a GDPR erasure request or regulatory purge order. All removals must be strictly authorized and a full evidence trail must be linked to the deletion operation, including legal order reference or evidence_archive. The endpoint must return the deleted record's metadata for audit trace, and alert system monitoring. Upon invocation, the record is physically expunged (with all downstream evidence updated), but the deletion itself becomes a new immutable audit entry with legal justification. Errors for unauthorized or improper invocation return compliance error results. Linked operations: PATCH (search), GET (retrieve), PUT (amend).",
    "summary": "Compliance-only deletion/expungement of single shopping API Audit record (api_audits table).",
    "parameters": [
      {
        "name": "id",
        "description": "UUID of the API Audit record to comply-erase.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Deleted API Audit metadata, and new compliance audit log entry.",
      "typeName": "IShoppingApiAudit"
    },
    "path": "/shopping/apiAudits/{id}",
    "method": "delete"
  },
  {
    "specification": "This operation retrieves a paginated and filterable list of Integration Channels from the shopping API_Omnichannel module, corresponding to the integration_channels table in Prisma. This supports compliance with omnichannel evidence tracking and enables system/admin/partner users to discover and manage registered channels. List endpoint supports search (by code, name, active status), sorting, and pagination. Visibility may be role-restricted, especially for privileged or partner-only channels. Evidence-grade logs are returned for compliance and monitoring. Use in conjunction with POST (create) and PUT (update) endpoints.",
    "description": "This endpoint lists Integration Channels with advanced filtering, sorting, and paging options. Typical usage is by administrators or integration management platforms to review which omnichannel sources are registered and manage their operational status (active/archived/deleted). Returned data includes channel codes, names, activation/deletion status, timestamps, and full metadata for compliance and discovery. Access is role-gated. Related operations: POST (creation), GET (single channel), PUT (update), DELETE (exceptional; not included by default as archive is preferred). Errors for overbroad or unauthorized requests are explicitly flagged for system monitoring.",
    "summary": "Paginated/filterable list operation for shopping Integration Channels (integration_channels table).",
    "parameters": [],
    "requestBody": {
      "description": "Search and filter information for querying Integration Channels.",
      "typeName": "IShoppingIntegrationChannel.IRequest"
    },
    "responseBody": {
      "description": "Paginated list of matching Integration Channel records.",
      "typeName": "IPageIShoppingIntegrationChannel"
    },
    "path": "/shopping/integrationChannels",
    "method": "patch"
  },
  {
    "specification": "This operation retrieves detail of a specific Integration Channel by its UUID, as an evidence-grade record in the shopping API_Omnichannel module (integration_channels table). Fully itemizes the channel's metadata, activation status, timestamps, and relations to omnichannel event streams. This operation enables monitoring, troubleshooting, and compliance exports. Only privileged users (e.g., administrators, integrators) are authorized for access to full channel details. Access to archived/soft-deleted records should be possible if needed for audit, but not to physically deleted entries.",
    "description": "This endpoint returns full record/timeline details of a single Integration Channel, including code/name, status (active/archived), creation/modification/deletion timestamps, and related metadata. Typically used by administrators, integration managers, or compliance staff to trace omnichannel channel provenance, review status, or assemble system audit exports. All access should be traced in internal system monitoring logs for compliance. Linked operations: PATCH (list/search), PUT (update), POST (create), DELETE (exceptional; physical deletion is not generally permitted, but archive is possible via status). Compliance errors include access outside permission or attempting to retrieve a non-existent/expunged record.",
    "summary": "Get detail for a single shopping Integration Channel (integration_channels table).",
    "parameters": [
      {
        "name": "id",
        "description": "UUID of the Integration Channel to retrieve in integration_channels table.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Full record and metadata for specified Integration Channel.",
      "typeName": "IShoppingIntegrationChannel"
    },
    "path": "/shopping/integrationChannels/{id}",
    "method": "get"
  },
  {
    "specification": "This operation creates a new Integration Channel within the shopping API_Omnichannel module (integration_channels table, Prisma). Enables registration of a new omnichannel or API source with unique channel codes and identity. All channels must be uniquely identified, and activation status, credentials/certificates, and provisioning info must be validated as per business logic. Channels can later be updated/deactivated via PUT endpoint. Evidence trail for each creation is preserved for compliance, and all writes are append-only. Authorization is required (integrator/admin-level users only).",
    "description": "This endpoint allows for privileged creation/registering of a new Integration Channel, enabling the backend to recognize a new API, omnichannel, or partner integration endpoint. Required fields include channel code, name, activation status, and initial metadata. Post-creation, the channel will be discoverable/searchable via PATCH endpoint, and updatable by PUT. Returned record includes all submitted data and system fields. Authorization is required; only integrators or system administrators permitted. All channel registrations are append-only and fully audited (evidence preserved).",
    "summary": "Register a new shopping Integration Channel (integration_channels table, API_Omnichannel module).",
    "parameters": [],
    "requestBody": {
      "description": "Information for registering a new Integration Channel.",
      "typeName": "IShoppingIntegrationChannel.ICreate"
    },
    "responseBody": {
      "description": "Newly created Integration Channel record with metadata and system fields.",
      "typeName": "IShoppingIntegrationChannel"
    },
    "path": "/shopping/integrationChannels",
    "method": "post"
  },
  {
    "specification": "This operation updates an existing Integration Channel's mutable fields (such as activation status, channel name, or credentials/certificates) in the shopping API_Omnichannel module (integration_channels table, Prisma). Used by privileged integrators or system administrators to adjust channel configuration, e.g., for reactivation, archiving, credential/certificate rotation, or correcting channel metadata. All changes are append-only and strictly audited for compliance. Physical deletion is not permitted; all status changes must be archival only.",
    "description": "This endpoint enables privileged updates/amendments to an existing Integration Channel record. Typical updates involve changing the activation flag, rotating channel credentials/certificates, editing descriptive metadata, or archiving the channel (deactivation). All requests must validate channel existence, ensure integrity of status transitions, and record evidence-grade audit entries for every change. Only integrators and privileged system administrators may update channel configuration. Linked operations: PATCH (list/search), GET (detail), POST (creation). Deletion is not supported—archival (inactive/deleted_at) is enforced instead. Unauthorized or non-compliant edits are rejected with detailed compliance error reporting.",
    "summary": "Update an existing shopping Integration Channel (integration_channels table) with new configuration or status.",
    "parameters": [
      {
        "name": "id",
        "description": "UUID of the Integration Channel record to update.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": {
      "description": "Updated details for the Integration Channel (activation, metadata, certificates, etc.).",
      "typeName": "IShoppingIntegrationChannel.IUpdate"
    },
    "responseBody": {
      "description": "Updated Integration Channel record with current configuration and evidence log.",
      "typeName": "IShoppingIntegrationChannel"
    },
    "path": "/shopping/integrationChannels/{id}",
    "method": "put"
  },
  {
    "specification": "Delete an Integration Channel by its ID. This operation removes the specified channel from the shopping mall integration registry, fulfilling the requirement for secure deactivation and audit-trail compliant deletion of omnichannel integration sources. It is based on the 'integration_channels' table and ensures that only channels which are not actively referenced can be deleted, preserving compliance with evidence and audit requirements. The operation is strictly controlled to retain a soft-delete (archival) timestamp for compliance and regulatory search. If referenced by related sessions, audits, or webhook events, deletion fails with a well-specified error. Only users with sufficient permissions may invoke this endpoint.",
    "description": "This API endpoint deletes a single integration channel identified by its unique ID. The primary purpose is to support the system's requirements for managing omnichannel integration, including deactivation of business partners or obsolete technical integrations. All operations are strictly logged for audit and compliance.\n\nThe endpoint enforces soft-deletion: the channel is not physically removed, but instead a deletion timestamp is recorded. This preserves evidence for regulatory, forensic, and historical review. Attempts to delete an integration channel that is actively referenced by channel sessions, API audits, or webhook events are rejected to ensure business continuity and data integrity.\n\nDeletion actions are restricted to users with proper administrative privileges. Every invocation is fully logged in the system audit trail. Errors such as 'not found', 'referenced by active records', and 'insufficient permissions' are clearly returned for robust API client experience.",
    "summary": "Delete an Integration Channel (integration_channels table) by ID, with compliance-preserving soft-delete.",
    "parameters": [
      {
        "name": "id",
        "description": "Unique identifier of the integration channel to delete.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Confirmation that the integration channel was soft-deleted, including its archival timestamp and status.",
      "typeName": "IShoppingIntegrationChannel"
    },
    "path": "/shopping/integrationChannels/{id}",
    "method": "delete"
  },
  {
    "specification": "Search and retrieve a paginated, filterable list of channel session records corresponding to the channel_sessions table. This supports the requirement for system-wide monitoring, omnichannel analytics, and evidence of cross-channel user activity. The endpoint allows clients to filter by channel, token, user, session activity state, and supports advanced querying for compliance and integration reports. It is essential for tracking session concurrency, user behavior, and system usage trends.",
    "description": "This endpoint lists channel session records from the shopping mall's channel_sessions resource. Operations include filtering by channel, user, token, active status, and time window. Results are paginated for performance and may be sorted by various criteria, such as most recent activity or started_at timestamp.\n\nAll session data is evidence-preserving and immutable, with soft deletions reflected via ended_at timestamps. The API supports compliance requirements for session auditing, incident response (e.g., tracing omnichannel fraud), and cross-device behavior analytics. Advanced filtering and sorting ensure extensibility for integration with monitoring dashboards and reports.\n\nAccess is restricted to users or service accounts authorized for system monitoring. Error responses are provided for invalid queries, pagination boundaries, or permission issues.",
    "summary": "Retrieve/search channel session records from the channel_sessions table, supporting omnichannel analytics and compliance.",
    "parameters": [],
    "requestBody": {
      "description": "Search and pagination criteria for listing channel sessions.",
      "typeName": "IShoppingChannelSession.IRequest"
    },
    "responseBody": {
      "description": "Paginated result of channel sessions matching the query, including evidence metadata for each session.",
      "typeName": "IPageIShoppingChannelSession"
    },
    "path": "/shopping/channelSessions",
    "method": "patch"
  },
  {
    "specification": "Get details of a specific channel session. This operation fulfills requirements for actionable, auditable queries over channel_sessions (from omnichannel integration), supporting session monitoring, compliance auditing, and diagnostics. Returns full session metadata and contextual evidence, including associated channel, token, session user, status (open/ended), and key timestamps. Designed to enable forensic reconstruction and user/channel troubleshooting for admins or monitoring systems.",
    "description": "Returns a single channel session by its ID, containing all metadata, links to associated integration channel and API token, and session state (ongoing or ended). This endpoint is vital for operations such as incident response, evidentiary record-keeping, and real-time monitoring.\n\nThe returned data includes immutable evidence for compliance (started_at, ended_at, session_key, channel info). Access is privileged, complying with data minimization and access control policies. Not found and permission errors are robustly reported.",
    "summary": "Get a specific channel session's evidence-rich detail from the channel_sessions table, referenced by ID.",
    "parameters": [
      {
        "name": "id",
        "description": "The unique ID of the channel session to retrieve.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "The detailed channel session record, including all compliance metadata.",
      "typeName": "IShoppingChannelSession"
    },
    "path": "/shopping/channelSessions/{id}",
    "method": "get"
  },
  {
    "specification": "Create a new channel session in the shopping mall backend, mapped to the channel_sessions table. Supports omnichannel integration and audit trail for cross-device, cross-channel session evidence, as specified in the scalability and API extensibility requirements. Input includes references to integration channel, access token, user (if authenticated), session key, and timing. Validates uniqueness of session key and enforces referential integrity.",
    "description": "This endpoint allows creation of a new channel session record, logging evidence for client or user activity originating from different channels (web, mobile, partner, etc.). Payload must include integration_channel_id, api_token_id, (optional) user_id, session_key, and timestamps. Ensures normalization, forward-compatibility for evolving channels, and triggers audit logging for compliance.\n\nOn success, returns the new session with all populated fields. Errors returned for constraint violations, permission errors, or invalid relationships (e.g., channel or token not found). Only authorized system or integration clients may invoke this endpoint.",
    "summary": "Create new channel session (channel_sessions table) for omnichannel user/activity tracking.",
    "parameters": [],
    "requestBody": {
      "description": "Payload for channel session creation: channel, token, user, and session context.",
      "typeName": "IShoppingChannelSession.ICreate"
    },
    "responseBody": {
      "description": "The channel session record as created, including all evidence-compliance fields.",
      "typeName": "IShoppingChannelSession"
    },
    "path": "/shopping/channelSessions",
    "method": "post"
  },
  {
    "specification": "Update a channel session's record in the channel_sessions table. Used for extending, annotating, or correcting session state—such as marking exit time (ended_at), correcting associations, or adding compliance context. Fulfills the requirement for mutable but evidence-preserving session state in omnichannel analytics and security modules. Soft deletion/ending is accomplished by setting ended_at, preserving evidence for forensics and compliance reports.",
    "description": "This endpoint updates a channel session identified by ID, handling record corrections such as closing an open session (setting ended_at), associating to a user post-authentication, or annotating the session for compliance evidence. All updates are evidence-preserving, with new/before states logged in audit trail per policy.\n\nOperation validates integrity (session_key uniqueness, relationship constraints). Only authorized channel owners, system admins, or compliance/monitoring subsystems may invoke. Errors for not found, concurrent modification, or permission denied are robustly returned. Updates are versioned for evidence preservation.",
    "summary": "Update an existing channel session by ID, with evidence-preserving record changes (channel_sessions table).",
    "parameters": [
      {
        "name": "id",
        "description": "The unique ID of the session to update.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": {
      "description": "Fields to update in the channel session record, such as user association or session state.",
      "typeName": "IShoppingChannelSession.IUpdate"
    },
    "responseBody": {
      "description": "Updated channel session record post-modification, including compliance metadata.",
      "typeName": "IShoppingChannelSession"
    },
    "path": "/shopping/channelSessions/{id}",
    "method": "put"
  },
  {
    "specification": "Delete a channel session (channel_sessions table) by ID, supporting compliance and evidence preservation via soft deletion or ending the session (setting ended_at). This endpoint ensures audit trail integrity for omnichannel user interaction records, and is designed to enforce permission boundaries—only authorized deletion allowed. If session is already ended, the operation is idempotent, returning the unchanged evidence.",
    "description": "This operation deletes (soft or logical) a channel session specified by ID, marking the session as completed (setting ended_at). The action is non-destructive to preserve compliance integrity, and supports incident response—e.g., terminating a compromised session, enforcing session expiry, or cleaning up orphaned records.\n\nEvery deletion is logged in audit trails, and errors are robustly handled: session not found, already ended, concurrent update, or insufficient privilege. Only system administrators or authorized channel owners may invoke. API returns the post-operation session record and compliance metadata.",
    "summary": "Delete (logically/end) a channel session by ID in the channel_sessions table, enforcing compliance and evidence trails.",
    "parameters": [
      {
        "name": "id",
        "description": "Unique identifier for the session to delete/end.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Channel session record with evidence of session ending or soft deletion.",
      "typeName": "IShoppingChannelSession"
    },
    "path": "/shopping/channelSessions/{id}",
    "method": "delete"
  },
  {
    "specification": "List/search webhook event records from the webhook_events table, supporting evidence-compliant tracking of system/webhook notifications in omnichannel integration. The endpoint is essential for API monitoring, troubleshooting event delivery, partner integration analytics, and regulatory audit. Supports advanced filter by delivery status, event type, integration channel, time range, and pagination (IRequest).",
    "description": "This endpoint returns a paginated, filterable list of webhook event records. It supports searching by delivery status (pending, failed, success, etc.), event type, integration channel, attempt count, and time of delivery. All output includes compliance metadata (attempt times, delivery status, hash).\n\nThis API is central to monitor event bus and webhook delivery, supporting troubleshooting for API partners and forensics for incident response. Only users/services with appropriate evidence privilege may use this endpoint. Results can be integrated with dashboards or compliance audit workflows.\n\nErrors (query, permission, pagination) are robustly returned.",
    "summary": "Search and retrieve webhook events (webhook_events table) for audit, monitoring, and partner troubleshooting.",
    "parameters": [],
    "requestBody": {
      "description": "Filter, paging, and search criteria for webhook event records.",
      "typeName": "IShoppingWebhookEvent.IRequest"
    },
    "responseBody": {
      "description": "Paginated search result of webhook events, including evidence fields, delivery metadata, and compliance logs.",
      "typeName": "IPageIShoppingWebhookEvent"
    },
    "path": "/shopping/webhookEvents",
    "method": "patch"
  },
  {
    "specification": "Get detailed information about a single webhook event from the webhook_events table by its unique ID. Supports the requirement for partner integration monitoring, compliance, and technical forensics of event delivery. Provides all relevant meta and audit fields for reproduction of event lifecycle. Returns immutable, atomic event record and compliance evidence.",
    "description": "Returns a single webhook event record matching the provided ID. Output includes all event metadata: event_type, channel, delivery status, time(s), delivery destination, hashes, and evidence fields. This is critical for forensics (e.g., partner dispute) and regulatory audits. Only users/services with sufficient permissions may access the endpoint; robust error handling for not found/permission issues.\n\nCompliance mandates (immutability, evidence retention) are strictly enforced. The endpoint fulfills the monitoring, compatibility audit, and technical investigation use cases for all partner channels and event logs.",
    "summary": "Retrieve a single webhook event's full data and evidence, by ID (webhook_events table).",
    "parameters": [
      {
        "name": "id",
        "description": "The unique webhook event ID to retrieve.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Full webhook event record, with all evidence and compliance metadata fields.",
      "typeName": "IShoppingWebhookEvent"
    },
    "path": "/shopping/webhookEvents/{id}",
    "method": "get"
  },
  {
    "specification": "Create a new webhook event in the webhook_events table, supporting external integration event delivery, compliance with evidence tracking, and technical notification. The endpoint allows registering new events for asynchronous processing and traceability. Payload includes event type, channel reference, delivery destination, evidence hash, and timestamps. Only service accounts/integration clients with event privilege may invoke.",
    "description": "This endpoint creates a new webhook event record, which may be triggered by system, admin, or approved integration. The request payload must include required event metadata (integration_channel_id, event_type, destination_url, delivery details, attempt count, etc.). Implements evidence chain and audit log requirements, ensuring every event can be reconstructed for compliance, investigation, or dispute.\n\nAfter validation, new records are returned with their system-generated IDs and evidence metadata. Errors provided for constraint violations, missing data, or insufficient permissions. Invoking client is always logged for accountability.",
    "summary": "Create and record a new webhook event (webhook_events table) for partner/system notification and evidence.",
    "parameters": [],
    "requestBody": {
      "description": "Metadata and delivery context for the new webhook event.",
      "typeName": "IShoppingWebhookEvent.ICreate"
    },
    "responseBody": {
      "description": "The newly created webhook event record, including all compliance and evidence metadata.",
      "typeName": "IShoppingWebhookEvent"
    },
    "path": "/shopping/webhookEvents",
    "method": "post"
  },
  {
    "specification": "Update an existing webhook event record by its ID in the webhook_events table. Used for correcting or annotating delivery metadata, error reconciliation, or compliance note-taking. All updates are evidence-preserving and immutably logged; no physical deletion or redaction. The endpoint fulfills requirements for partner troubleshooting, compliance annotation, and technical forensics of webhook delivery status.",
    "description": "This endpoint updates fields of a webhook event (e.g., last_attempted_at, delivery_status), corresponding to handling of retries, error reconciliation, or compliance notations. Invocations are subject to full audit trail and write-once evidence policies for sensitive changes. Only system accounts or integration clients with control privilege may update, and each change is versioned for regulatory review.\n\nReturns the updated record post-modification. Integrity and constraint errors, permission checks, or idempotency concerns are handled explicitly. The endpoint is extensible for future metadata expansion and supports compliance requirements for immutable record trails.",
    "summary": "Annotate/update an existing webhook event (webhook_events table) by ID for compliance, troubleshooting, or delivery updates.",
    "parameters": [
      {
        "name": "id",
        "description": "Unique identifier of the webhook event record to update.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": {
      "description": "Delivery metadata or annotation fields to update in the webhook event record.",
      "typeName": "IShoppingWebhookEvent.IUpdate"
    },
    "responseBody": {
      "description": "The updated event record with all evidence and metadata fields.",
      "typeName": "IShoppingWebhookEvent"
    },
    "path": "/shopping/webhookEvents/{id}",
    "method": "put"
  },
  {
    "specification": "Delete a webhook event record in the webhook_events table by its unique ID. Used to mark webhook as decommissioned, failed, or for compliance purposes, enforcing evidence retention and audit policy. All deletions are soft; physical removal is not permitted. Only privileged accounts may delete; result includes archival state and compliance fields. Referential integrity checks enforced to prevent loss of evidence for referenced audits/incidents.",
    "description": "Deletes (soft deletes) a webhook event record by ID, marking it as archived or decommissioned (without physical data destruction). This is critical for maintaining evidence trails, compliance with audit/regulation, and enabling incident postmortem. Operations are strictly audited and only possible for users/services with sufficient privilege. If webhook event is still referenced by active audit records, delete fails with clear error. Success returns the event in its new (archived) state with compliance metadata.\n\nNot found, already archived, and permission errors are robustly surfaced. All soft-deletion events are retained indefinitely for legal evidence unless a retention policy threshold is met or legal hold released.",
    "summary": "Delete (soft, evidence-compliant) a webhook event by ID from webhook_events table.",
    "parameters": [
      {
        "name": "id",
        "description": "Unique identifier for the webhook event to delete/archive.",
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      }
    ],
    "requestBody": null,
    "responseBody": {
      "description": "Webhook event record with evidence of archival/soft deletion.",
      "typeName": "IShoppingWebhookEvent"
    },
    "path": "/shopping/webhookEvents/{id}",
    "method": "delete"
  }
]