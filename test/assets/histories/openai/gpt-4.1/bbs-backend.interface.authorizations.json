[{"specification":"Implements admin account registration. This operation creates a new admin account in the `discussion_board_admins` table, requiring atomic fields for identity and authentication—`username` (unique), `password_hash`, and `email` (unique). All values map directly to required table columns, enforcing uniqueness constraints on both username and email. The account is immediately marked as active or not via `is_active`. Upon successful insertion, the system issues a JWT for the new admin and records the registration event in the audit log. No pre-execution of other APIs required. Business logic includes proper hashing of passwords before persistence. Errors for duplicate usernames/emails are handled at DB constraint level. Related: sign-in, token issuance, and access log entry on signup.","description":"This endpoint allows a user to register a new administrator account for the discussion board system.\n\nIt inserts a new row into the `discussion_board_admins` table, setting the `username`, `password_hash`, `email`, and `is_active` fields. The system ensures `username` and `email` are unique as enforced by the Prisma schema's unique constraints. On success, a JWT is generated for initial authentication and an access log is written for security compliance.\n\nPassword hashing is enforced at this step, and the request will fail with concise errors if the supplied username/email already exists. No email verification, reset, or MFA flows are triggered at registration, as those fields are not present in the schema.\n\nThis operation is mandatory for the admin authentication flow, as all further admin actions require registration. Auditing and role-based enforcement workflows rely on valid admin registration sources.\n\nError conditions are handled strictly per unique constraint and authentication requirements.","summary":"Register a new admin account in the `discussion_board_admins` table.","parameters":[],"requestBody":{"description":"Information required for registering a new admin account.","typeName":"IDiscussionBoardAdmin.ICreate"},"responseBody":{"description":"Information about the newly registered admin and issued JWT tokens.","typeName":"IDiscussionBoardAdmin.IAuthResponse"},"authorizationRole":null,"name":"signUp","path":"/auth/admin/register","method":"post"},{"specification":"Provides admin login/authentication. This endpoint accepts admin credentials and verifies them against the `discussion_board_admins` table. Authenticity is determined by matching `username` and checking if the provided password, when hashed, matches the stored `password_hash`. The `is_active` field is checked to deny access to deactivated admins. If authentication is successful, a new JWT is generated and stored in `discussion_board_auth_tokens` with actor_type `admin`. Failed logins are not differentiated for increased security. Successful logins update the admin's access log. This operation is one-way and does not require registration. Related: sign-up (registration), sign-out (logout), password change.","description":"This endpoint enables an administrator to log in to the discussion board system.\n\nIt validates the request using the supplied `username` and password, matching them to the corresponding row in the `discussion_board_admins` table. The request fails if `is_active` is false or if the password does not match the stored `password_hash`. If successful, a new JWT is signed and persisted to `discussion_board_auth_tokens` for the admin's session, and an access log entry is recorded for compliance.\n\nThe admin's role and permissions are enforced by role name on this authentication event. Immediately after successful authentication, session tokens are available for subsequent API calls. No reset, verification, or refresh flows apply as they are unsupported in the schema.\n\nError handling is strict, returning generic error messages on authentication failure. Multiple failed logins may be logged for future rate/lockout features.","summary":"Authenticate an admin and issue JWT tokens using `discussion_board_admins`.","parameters":[],"requestBody":{"description":"Credentials required for admin login.","typeName":"IDiscussionBoardAdmin.ILogin"},"responseBody":{"description":"JWT tokens and admin information for the session.","typeName":"IDiscussionBoardAdmin.IAuthResponse"},"authorizationRole":null,"name":"signIn","path":"/auth/admin/login","method":"post"},{"specification":"Allows an authenticated admin to end their session, invalidating current login JWT. The operation marks the current JWT as `revoked` in the `discussion_board_auth_tokens` table by token identity and associated admin. This ensures the token can no longer be used for API access. The revoked status is checked in later request authorizations. A new audit log entry is made on sign-out. This operation does not remove the admin row in the users table or affect other sessions. Related flows: sign-in, token validation. Pre-requisite: valid authentication via JWT.","description":"This endpoint handles admin session logout by marking the current JWT as revoked in the `discussion_board_auth_tokens` table for the acting admin user.\n\nThe flow: After an authenticated API call, this endpoint is called to invalidate the token, ensuring it is no longer usable for subsequent requests. The system uses the current token for lookup and sets its `revoked` field to true. Audit and access logs are updated accordingly for traceability and security policy.\n\nThis operation is central to secure admin logout, ensuring the end of current session only (not account deletion or multi-session removal). Token status and session management rely on this endpoint for correct compliance.\n\nAny unauthorized or invalid token attempt triggers a standard access denial. All sign-outs are logged, enabling admin compliance/audit checks.","summary":"Logout admin by revoking the current JWT in `discussion_board_auth_tokens`.","parameters":[],"requestBody":null,"responseBody":{"description":"Confirmation of successful logout and token revocation.","typeName":"IDiscussionBoardAdmin.ILogoutResponse"},"authorizationRole":"admin","name":"signOut","path":"/auth/admin/logout","method":"post"},{"specification":"Validates an admin's JWT token. This endpoint checks whether a supplied JWT is present and unexpired in `discussion_board_auth_tokens` for actor_type `admin` and is not revoked. Upon success, it returns authentication status and associated admin information. Expired or revoked tokens are rejected, aligning with access policy and compliance requirements. This is a stateless operation and does not depend on user authentication context but on token validity.","description":"This endpoint validates a provided admin JWT. It locates the token in `discussion_board_auth_tokens` by its value, actor_type, and `revoked=false`, and checks the expiry date.\n\nIf the token is valid, it returns authorization status and associated admin data. For invalid, revoked, or expired tokens, it returns a failure status and does not reveal sensitive user details. Every validation attempt (success or failure) may be logged to `discussion_board_access_logs` for analytics/compliance.\n\nThis mechanism enables stateless auth flows, API gatekeeping, and token life-cycle management and ensures that only bona fide admin tokens can be used for privileged endpoints.\n\nRelated operations: sign-in (to issue JWT), sign-out (to revoke JWT).","summary":"Validate a JWT for admin in `discussion_board_auth_tokens`.","parameters":[],"requestBody":{"description":"The JWT token to validate for the admin.","typeName":"IDiscussionBoardAdmin.ITokenValidation"},"responseBody":{"description":"Validation result and corresponding admin information, if valid.","typeName":"IDiscussionBoardAdmin.IValidationResponse"},"authorizationRole":null,"name":"validateToken","path":"/auth/admin/validate","method":"post"},{"specification":"Allows an authenticated admin to change their password in the `discussion_board_admins` table. The operation checks that the provided current password matches the `password_hash` field for the admin. If it matches, the new password is hash-persisted in the same field. No password reset tokens are used—password changes require current password verification for security. The action is logged and triggers session invalidation if implemented. Pre-requisite: JWT-authenticated admin session. This is essential for routine admin password maintenance. Related flows: signUp, signIn, signOut. Security measures: Enforces strong password policies if implemented upstream.","description":"This endpoint facilitates changing the password for an authenticated admin. It compares the supplied current password (after hashing) with the `password_hash` stored in the admin's row in `discussion_board_admins`. On a successful match, the `password_hash` is overwritten with the new (hashed) password. If the passwords do not match, an error response is returned, and the attempt is logged for security compliance.\n\nThis flow ensures that only a properly authenticated admin can perform password updates, per industry security best practices. After password change, some implementations may require all tokens to be revoked, but this is not strictly dictated by the current schema (would require explicit additional fields).\n\nNo password reset, verification, or email OTP features are available because schema fields such as reset_token are absent. The change event is logged for audit and compliance.\n\nCritical for admin security lifecycle management; supports regulatory audit flows and password maintenance requirements.","summary":"Change admin password in `discussion_board_admins` with current password check.","parameters":[],"requestBody":{"description":"Current and new password for the admin password change operation.","typeName":"IDiscussionBoardAdmin.IChangePassword"},"responseBody":{"description":"Confirmation and status of password change.","typeName":"IDiscussionBoardAdmin.IPasswordChangeResponse"},"authorizationRole":"admin","name":"changePassword","path":"/auth/admin/password","method":"put"},{"specification":"This operation creates a new guest session in the system and issues an initial JWT token so the guest can browse public sections while tracking their session ID and IP address. The schema for discussion_board_guests defines the required information: session_token (used internally for session identification), guest_ip, and entered_at. The operation is public as no previous authentication is required. On creation, a corresponding entry in discussion_board_guests must be created, and an authentication token is issued and stored in discussion_board_auth_tokens with guest_id and actor_type 'guest'. It ensures the audit trail via access logs using the guest's IP and session token.","description":"The purpose of this operation is to allow an unauthenticated user (guest) to begin a browsing session on the discussion board platform. Upon registration, the system records the guest's session using the guest_ip and session_token fields in the discussion_board_guests table, and sets the entered_at timestamp to the current time. A JWT token is immediately generated and stored in discussion_board_auth_tokens (token, guest_id, actor_type = 'guest', issued_at, revoked=false), allowing the guest to make public API calls while providing an auditable identity for this session.\n\nJWT implementation relies on issuance and tracking in discussion_board_auth_tokens, keyed by token and guest_id. The token is returned to the guest for subsequent 'public' requests.\n\nThis endpoint is intended as the entry-point for guest access, as described in the user role and API authentication requirements. It supports all typical guest interactions that require maintaining a session but not authentication.\n\nSecurity mechanisms focus on restricting access to public features only, recording all actions associated with a guest session in both the auth and access logs for compliance.\n\nOperations related include guest logout (session/authorization revocation) and token validation. This is always the first step when converting an anonymous client to a session-tracked guest.","summary":"Register a new guest browsing session and issue an initial JWT token (discussion_board_guests, discussion_board_auth_tokens).","parameters":[],"requestBody":{"description":"Information required to create a guest session: guest_ip, session_token (browser fingerprint or random), entered_at (auto).","typeName":"IGuestSignUpRequest"},"responseBody":{"description":"Details of the newly created guest session, including the JWT token and session metadata.","typeName":"IGuestSignUpResponse"},"authorizationRole":null,"name":"signUp","path":"/auth/guest/register","method":"post"},{"specification":"This operation authenticates an existing guest session and issues a new JWT token. The 'login' for a guest means presenting a valid session_token (and optionally guest_ip) that matches an entry in discussion_board_guests. On successful match, a new authentication token (discussion_board_auth_tokens) is created with guest_id, token, and actor_type 'guest'. Expired or revoked tokens are handled according to the schema in discussion_board_auth_tokens. Authentication for a guest session does not elevate permissions but reissues a valid JWT for continued public browsing with session tracking.","description":"This endpoint allows a guest user to re-authenticate an existing guest session. When provided with a session_token (and optionally guest_ip), the system verifies the existence of a matching entry in the discussion_board_guests table. If valid, it issues a new JWT and stores it in discussion_board_auth_tokens (token, guest_id, actor_type = 'guest', issued_at, revoked=false). Invalid or expired sessions result in an error.\n\nJWT handling uses the token field for issuance and linking to guest_id. Session continuity depends on having a valid session_token. This operation complements guest registration to enable persistent public browsing without requiring member or higher roles.\n\nSecurity is minimal: tokens grant access only to public endpoints associated with the guest session.\n\nRelated operations are guest sign-out (session revocation) and validation. It is used by clients wishing to persist or resume a guest browsing session.","summary":"Authenticate an existing guest session and re-issue a JWT token (discussion_board_guests, discussion_board_auth_tokens).","parameters":[],"requestBody":{"description":"Credentials to authenticate an existing guest session: session_token (required), guest_ip (optional for validation).","typeName":"IGuestSignInRequest"},"responseBody":{"description":"Details for the authenticated guest session plus a (re-)issued JWT token.","typeName":"IGuestSignInResponse"},"authorizationRole":null,"name":"signIn","path":"/auth/guest/login","method":"post"},{"specification":"This operation logs a guest out by revoking their current JWT authentication token. It requires the guest's authenticated identity (JWT) and the active token (stored in discussion_board_auth_tokens). The matching record for the guest and token is marked revoked=true, and future usage is denied. This operation enables guests to explicitly end their session and prevent the token from being used again.","description":"Upon invocation, this endpoint takes the guest's JWT or token reference and marks the associated record in discussion_board_auth_tokens as revoked (revoked=true). This ensures no public or accidental session activity continues under the old token. No changes are made to discussion_board_guests beyond this session closure event.\n\nJWT enforcement is managed with the revoked flag, and token invalidation is immediate. This operation is critical for audit/compliance and supports explicit user-initiated logouts, even for unauthenticated (guest) roles.\n\nThe primary security consideration is thorough invalidation of the token, confirmed in the response. It provides an audit trail in access and auth logs.\n\nTypically paired with guest sign-in and token validation operations as part of the minimal authentication lifecycle for guests.","summary":"Revoke a guest's authentication token and log the guest out (discussion_board_auth_tokens).","parameters":[],"requestBody":null,"responseBody":{"description":"Confirmation of logout and token revocation status.","typeName":"IGuestSignOutResponse"},"authorizationRole":"guest","name":"signOut","path":"/auth/guest/logout","method":"post"},{"specification":"This operation validates a JWT token presented by a guest user. The JWT, supplied in the Authorization header or as a parameter, is checked against discussion_board_auth_tokens for existence, validity, non-revocation, and expiry. The guest_id and session are confirmed, and the current status of the session is returned. This is essential for public session management, ensuring that only valid sessions are recognized for subsequent API usage.","description":"This endpoint accepts a JWT token and looks for a matching, non-revoked and non-expired entry in discussion_board_auth_tokens with actor_type 'guest'. It validates public session identity and returns the status (valid, invalid, revoked, or expired). It does not elevate permissions or authenticate for non-public endpoints.\n\nJWT verification parses and checks token structure, expiry, signature, and database status. The guest session (discussion_board_guests) is referenced by guest_id for additional session context.\n\nThis operation is critical in the guest API security model and allows stateless clients to check their authorization without user records.\n\nSecurity relies on the token's correctness; responses never reveal sensitive data.\n\nRelated operations are guest sign-in, sign-out, and registration as part of the guest access workflow.","summary":"Validate a JWT belonging to a guest session (discussion_board_auth_tokens, discussion_board_guests).","parameters":[],"requestBody":{"description":"JWT token to validate, typically supplied in the Authorization header or as a payload property.","typeName":"IGuestValidateTokenRequest"},"responseBody":{"description":"Validation status and guest session context.","typeName":"IGuestValidateTokenResponse"},"authorizationRole":null,"name":"validateToken","path":"/auth/guest/validate","method":"post"},{"specification":"This operation allows a guest to forcibly change (reset) their anonymous browsing session token, effectively ending the current session and creating a new session and token. For a guest, 'changePassword' means regenerating session_token and invalidating the old authentication record. The schema for discussion_board_guests supports session_token updates for deduplication/security. The old token in discussion_board_auth_tokens is revoked, and a new one issued, continuing public browsing under a new session identity. This operation is authenticated with the current guest's valid JWT.","description":"When called by an authenticated guest session, this operation revokes the current token in discussion_board_auth_tokens (by setting revoked=true), generates a new session_token (guest), and creates a new record in discussion_board_guests and auth_tokens. This allows a guest to explicitly reset their session for privacy, deduplication, or before sharing a device. Audit trails are preserved in both tokens and guest logs.\n\nJWT handling ensures session continuity only for the new session. Re-authentication is required after this change. This provides a minimal privacy and session management feature even for unauthenticated users.\n\nAllows users of shared computers to quickly reset guest state. Related to guest sign-in/sign-out.","summary":"Replace the guest's session token and revoke the prior session (discussion_board_guests, discussion_board_auth_tokens).","parameters":[],"requestBody":{"description":"Optional justification or context for changing (resetting) the guest session, otherwise blank.","typeName":"IGuestChangePasswordRequest"},"responseBody":{"description":"Confirmation of guest session reset and the new session/token details.","typeName":"IGuestChangePasswordResponse"},"authorizationRole":"guest","name":"changePassword","path":"/auth/guest/password","method":"put"},{"specification":"This operation registers a new member account for the discussion platform. It is based on the 'discussion_board_members' table, referencing 'display_name' for user identity, 'email' for correspondence and unique identification, and 'password_hash' for authentication.\n\nThe operation creates a new member entry by requiring the user to provide a display name, unique email, and password (which will be hashed before storage). Default values such as 'is_verified' (email verification status), 'status' (initially active or pending), 'registered_at' (current timestamp), and 'last_login_at' (nullable, null at registration) are managed internally. Only the fields present in the schema are referenced; there are no additional fields for verification tokens or phone numbers.\n\nJWT tokens for session authentication are issued on registration success, leveraging the newly created member id and recorded in the appropriate tokens table. The operation is public (no authentication required) and forms the foundation for all member access capabilities. Security is handled by securely hashing the password before inserting, not storing plaintext. 'is_verified' is always 'false' until a separate verification process occurs (not present in schema). The operation strictly checks for email uniqueness, and all errors on constraint violation are surfaced clearly.\n\nThis registration is a prerequisite for all member-only board operations and precedes authentication steps like signIn. Related operations include signIn, signOut, and changePassword.","description":"This API operation enables user sign-up for the discussion board by inserting a new row into the 'discussion_board_members' table. The registration process requires users to provide a display name, email, and password. The password is securely hashed and stored in the 'password_hash' field, adhering to Prisma schema column comments on secure authentication. The email is enforced to be unique, fulfilling the identity requirement for member-level access as described.\n\nJWT-based session logic is triggered post-registration for direct onboarding. 'is_verified' is set to 'false' on initial registration, in alignment with schema intent for future email verification extensions (none are present in this schema). The 'registered_at' timestamp is auto-generated, and initial 'status' is set to activate member access (typically 'active' or 'pending', as inferred by downstream application logic). No external validation, token, or two-factor logic is present due to absence of such schema fields.\n\nRole-specific integration means only members are enrolled via this route. Security risks (such as email uniqueness or password complexity) are mitigated at the database and application layer. All unsuccessful attempts return clear errors, including unique constraint violations on the 'email' field. This operation is required before a user can sign in, change password, or access member-only resources. It forms the first step in the member authentication workflow and is related to signIn, signOut, validateToken, and changePassword processes.","summary":"Register new member (discussion_board_members table)","parameters":[],"requestBody":{"description":"Sign-up info for a new discussion board member","typeName":"IMemberSignUpRequest"},"responseBody":{"description":"Result: JWT token + member info","typeName":"IMemberAuthResponse"},"authorizationRole":null,"name":"signUp","path":"/auth/member/register","method":"post"},{"specification":"This operation authenticates a member by verifying credentials against 'discussion_board_members'. It expects an email and password from the user, referenced in the schema as 'email' (unique identifier) and 'password_hash'.\n\nWhen a login request is received, the API verifies the email exists and then compares the submitted password, after hashing, to the stored 'password_hash'. If successful, a new JWT is issued, and the 'last_login_at' field is updated. JWT session token issuance is managed through the 'discussion_board_auth_tokens' table, linking the generated token to the authenticated member and actor_type 'member', providing session tracking and auditability.\n\nSecurity is paramount: only hashed password comparisons occur, and the operation exposes no member credential information. All failures (email not found, bad password) return generic authentication errors for security. No multi-factor or refresh tokens are present in the schema. This endpoint is open to the public (not authenticated) and is necessary before accessing any authenticated board operations. Related operations include signUp, signOut, validateToken, and changePassword.","description":"This endpoint allows members to authenticate by providing their email and password. The system references the 'discussion_board_members' table, using the email as a unique identity and securely comparing the provided password (after hashing) to the stored 'password_hash'.\n\nUpon success, a new JWT is generated, and an entry is added to the 'discussion_board_auth_tokens' table, associating the token with the member (actor_type 'member'). Audit trail and access logging occur via standard mechanisms. 'last_login_at' for the member is updated to the current time upon successful authentication.\n\nThis operation only supports standard email/password authentication since no refresh tokens or multi-factor columns are in schema. It blocks all failed attempts with generic errors. It is the core credential gate for all subsequent member actions (posting, voting, reporting) and is necessary before executing signOut, changePassword, or any other secured workflow.","summary":"Authenticate (sign in) member (discussion_board_members table)","parameters":[],"requestBody":{"description":"Member login (email + password)","typeName":"IMemberSignInRequest"},"responseBody":{"description":"Result: JWT + member info","typeName":"IMemberAuthResponse"},"authorizationRole":null,"name":"signIn","path":"/auth/member/login","method":"post"},{"specification":"This endpoint logs out an authenticated member by invalidating the current JWT in the 'discussion_board_auth_tokens' table. The operation requires authentication: caller must be a member with a valid session token.\n\nIt finds the 'discussion_board_auth_tokens' record matching the member and the token presented in the request (by 'token' field, actor_type 'member', member_id). The operation then sets the 'revoked' field to 'true', invalidating the session for all further authenticated calls.\n\nNo other fields are referenced. This prevents the token from being reused for further API calls. This operation does not destroy the member record or revoke other tokens unless a broader session management operation is implemented. Logouts are audit-logged in the access logs. It is member-specific and cannot be called by other roles. Related operations: signUp, signIn, validateToken, changePassword.","description":"This API allows an authenticated member to log out by marking the current JWT as revoked in the 'discussion_board_auth_tokens' table. The operation requires a valid member session token in the request header. It finds the corresponding token record (actor_type 'member', by token and member_id) and updates 'revoked' to 'true', immediately blocking further use.\n\nFor security, only the session's own token is invalidated; other active tokens for the same member remain unaffected. This mechanism is essential for proper JWT session hygiene and complies with audit/access regulation by recording the event in access logs. It does not support session-wide or refresh-token invalidation due to schema limitations. This is the sole logout mechanism available to members and must precede client-side token destruction or UI logoff. Related operations: signIn, signUp, validateToken, and changePassword.","summary":"Logout member (revoke JWT, discussion_board_auth_tokens table)","parameters":[],"requestBody":{"description":"Empty payload (logout only requires the Authorization header token)","typeName":"IEmptyRequest"},"responseBody":{"description":"Result: success or failure of token revocation","typeName":"ISimpleStatusResponse"},"authorizationRole":"member","name":"signOut","path":"/auth/member/logout","method":"post"},{"specification":"This operation validates a JWT for a member, checking existence, expiry, and not revoked in the 'discussion_board_auth_tokens' table with 'actor_type' = 'member'. No authentication required; token is supplied as part of the request (header or body, as per implementation). It finds the corresponding token, confirms it is not expired (if 'expires_at' used) and not revoked. If valid, the member's session is considered active. If not, returns invalid/unauthorized.\n\nNo refresh or advanced token columns exist in the schema, so only direct JWT validation by lookup is supported. If valid, may return basic member info (from 'discussion_board_members' via the 'member_id' in the token row) to confirm active session.\n\nSecurity rules require that expired or revoked tokens yield a clear unauthorized result; no partial access is granted. This is needed by clients to re-confirm session status (e.g., on app startup or tab refresh). Operation is public; any supplied token will be checked directly. Related: signUp, signIn, signOut, changePassword.","description":"This API verifies if the JWT supplied for a member session is valid and current. It queries the 'discussion_board_auth_tokens' table (actor_type 'member') for a match, ensuring the token is neither expired ('expires_at') nor marked revoked (the 'revoked' boolean).\n\nIf valid, minimal member info may be returned to support UX/session refresh. If the token does not match or fails checks, a clear unauthorized/invalid response is returned. This endpoint does not update last_login_at or modify the token record, and does not issue new tokens. No advanced validations (refresh tokens, MFA) are supported in schema, so only direct-acquisition JWTs are checked. Operation is public—no prior authentication is done for the check; security is in token verification itself.\n\nIt is typically used on client bootstrap or token status refresh, and precedes member-only actions. Related operations: signUp, signIn, signOut, changePassword.","summary":"Validate member JWT (discussion_board_auth_tokens table)","parameters":[],"requestBody":{"description":"Token payload (JWT supplied for verification)","typeName":"IJwtValidationRequest"},"responseBody":{"description":"Result: valid/invalid + optional member info","typeName":"IMemberAuthValidationResponse"},"authorizationRole":null,"name":"validateToken","path":"/auth/member/validate","method":"post"},{"specification":"This operation allows an authenticated member to change their password. It references the 'discussion_board_members' table, requiring the member to supply their current password and the new password. The current password is compared (hashed) to 'password_hash', and if valid, the 'password_hash' field is updated to the new value (hashed in storage).\n\nNo other schema fields are referenced—this is strictly a one-step password change, without any reset or email-verification flow. After change, all JWT tokens can be managed as desired by the application logic (though the schema does not specify a 'force sign out' or token refresh mechanism for changed passwords).\n\nSecurity: Only authenticated members may call this operation. No external password reset, verification, or MFA processes exist in the schema. Related operations: signIn, signOut, signUp, validateToken.","description":"This endpoint allows authenticated members to change their account password. 'discussion_board_members' provides the necessary authentication context, matching the supplied current password (after hashing) to the stored 'password_hash'. The new password is then securely hashed and written to 'password_hash'.\n\nNo token invalidation or extra side-effects occur; the session remains active unless additional logic is implemented above the schema. This operation is limited to members, and is not available for guests, moderators, or admins. It is invoked typically by users who are logged in and want to update their credential information. Errors are returned for incorrect current password or missing new password fields.\n\nRequired before member credential update or post-breach precautions. Related: signIn, signUp, signOut, validateToken.","summary":"Member change password (discussion_board_members table)","parameters":[],"requestBody":{"description":"Current and new password (member)","typeName":"IMemberChangePasswordRequest"},"responseBody":{"description":"Result: success/failure, optional token refresh info","typeName":"ISimpleStatusResponse"},"authorizationRole":"member","name":"changePassword","path":"/auth/member/password","method":"put"},{"specification":"Implements moderator registration (sign-up) for the discussion_board_moderators table. Uses the 'username', 'password_hash', and 'email' fields for identity and authentication, following explicit role-based separation documented in the schema. Audit, is_active status, and created_at/updated_at handled internally, not exposed.\n\nPurpose: Registers a new moderator with unique username and email, storing a secure password hash. Business logic requires both username and email to be unique per moderator as enforced by @@unique constraints in the schema. The method creates an active moderator account only if all constraints are satisfied.\n\nJWT/Token implementation is not applicable during registration (token is only provisioned after successful sign-in). This API exposes only sign-up logic, with activation or approval handled by admin policies externally if needed. No advanced verification fields are present in the schema.\n\nAccess: Public endpoint (no prior authentication required).\n\nSecurity: Enforces unique username/email. Passwords are never stored/transmitted in plaintext (see Prisma schema's 'password_hash' and description). CSRF protection, input sanitation, and audit logging must be enforced at the controller/service layer. Account is_active is true by default. Rate-limiting is recommended.\n\nWorkflow: Upon success, triggers email confirmation flow externally if implemented, then user must sign in via /auth/moderator/login.\n\nRelated operations: signIn (login), signOut (logout), changePassword. Workflow: signUp → signIn → set session/token.","description":"This endpoint enables registration of new moderators by collecting 'username', 'email', and 'password' which are stored, respectively, in the 'username', 'email', and 'password_hash' columns in the discussion_board_moderators table. This operation is mapped precisely to the moderator registration flow required for role-based access control on the discussion platform.\n\nJWT tokens are not issued by this endpoint; registration alone does not authenticate a session, as per the schema design. Moderator status (is_active) and audit timestamps (created_at, updated_at) are set automatically during the registration event.\n\nThis operation is distinct from admin/member creation; it only affects the moderator role. It does not allow for assigning the admin role or affecting member/guest tables. The endpoint is always public; administrative approval and additional verification are handled in external processes, not part of this API.\n\nSecurity policy is aligned with account uniqueness constraints (unique email/username enforced by schema), auditability requirements, and prepared for CSRF/rate-limiting measures. Input validation is crucial, and error handling must differentiate unique constraint violations.\n\nUse together with signIn and signOut endpoints for full session lifecycle management.","summary":"Moderator registration (discussion_board_moderators table): Registers new moderator with unique username/email and password hash.","parameters":[],"requestBody":{"description":"Moderator registration data (username, email, password) mapped to the discussion_board_moderators schema fields.","typeName":"IModerator.SignUpRequest"},"responseBody":{"description":"Moderator authentication information and basic details after successful registration. Reflects initial information from discussion_board_moderators.","typeName":"IModerator.AuthResponse"},"authorizationRole":null,"name":"signUp","path":"/auth/moderator/register","method":"post"},{"specification":"Implements moderator login (sign-in) against the discussion_board_moderators table. Uses the 'username' or 'email' with 'password_hash' to authenticate moderator identity and, on success, issues a JWT token recorded in discussion_board_auth_tokens (actor_type='moderator').\n\nPurpose: Authenticates a moderator and grants a JWT session token for subsequent authorization. Looks up and verifies credentials using the schema's 'username', 'email', and 'password_hash'. Account must be is_active=true for login to succeed (per schema and requirements doc).\n\nToken: After verifying credentials, generates and records a JWT in discussion_board_auth_tokens (with proper actor_type, expires_at, revoked=false). The token is subsequently used for all protected moderator endpoints. Token revocation is handled via signOut or manual backend interventions.\n\nSecurity: Enforces secure password verification and checks is_active flag. Implements rate limiting and brute-force protection. All responses must avoid leaking credential existence. Input must be sanitized. Records access in discussion_board_access_logs.\n\nAccess: Public (authentication endpoint).\n\nWorkflow: On success, returns token and minimal moderator info in response. Audit logging for access and metrics via separate access log table (discussion_board_access_logs).\n\nRelated: signUp (registration), signOut (logout), validateToken (token validation).","description":"This endpoint enables a moderator to log into the platform, authenticating using credentials mapped to the 'username', 'email', and 'password_hash' columns in the discussion_board_moderators table. On successful authentication, the system issues a JWT and creates an entry in discussion_board_auth_tokens with actor_type='moderator', as per DB schema and RBAC requirements.\n\nJWT session management is implemented by linking each issued token to the moderator's ID and actor_type, with expiry and revocation status tracked in the auth token table. Login is only allowed if is_active is true, and responses must not indicate whether the username or email exists to preserve user privacy.\n\nModerator sessions are fully separated from admins and members by DB structure and business logic. This login operation does not grant admin privileges or affect member/guest tables. Input validation is strict and all credential verification is timing-safe as required by security policy.\n\nAudit logging is mandatory for every login attempt, regardless of outcome, to enable forensic analysis and compliance. Session lifecycle: signUp → signIn → API usage → signOut.","summary":"Moderator login (discussion_board_moderators): Authenticates moderator; issues JWT and creates discussion_board_auth_tokens entry.","parameters":[],"requestBody":{"description":"Moderator login data (username/email and password) mapped to discussion_board_moderators schema fields.","typeName":"IModerator.SignInRequest"},"responseBody":{"description":"Moderator authentication and JWT token issued on successful login. Includes basic moderator identity fields from discussion_board_moderators.","typeName":"IModerator.AuthResponse"},"authorizationRole":null,"name":"signIn","path":"/auth/moderator/login","method":"post"},{"specification":"Implements JWT sign-out/invalidation for moderators. Uses discussion_board_auth_tokens to revoke the corresponding active token for the current session (actor_type='moderator'). Moderator must be authenticated for this action.\n\nPurpose: Terminates an active moderator JWT session, enforcing RBAC logout and session end-point required by policy and token hygiene. Uses the token from the request header to locate the entry in discussion_board_auth_tokens and marks it revoked=true.\n\nBusiness logic: Only the current active token is revoked; other sessions remain unaffected. The endpoint is accessible to any authenticated moderator session, as indicated by actor_type and access control checks in the controller/middleware.\n\nSecurity: The endpoint is idempotent—multiple signOut requests for the same token will not cause errors. All activity is logged to discussion_board_access_logs for forensics.\n\nWorkflow: On success, JWT is invalidated (set revoked=true in DB), logging out the moderator and requiring new authentication for API access.\n\nRelated: signIn (login), validateToken (token validation), signUp (registration).","description":"This endpoint logs out a currently authenticated moderator by revoking the JWT token associated with their session. The operation looks up the token in discussion_board_auth_tokens (filter: actor_type='moderator') and marks revoked=true for the token value matching the current session, as per schema and requirements for RBAC hygiene.\n\nThe endpoint is available to authenticated moderators only and is protected by role-based middleware. Token revocation does not impact tokens/sessions for other moderators or for other actor types.\n\nAll logout attempts, whether the token was active or already revoked, are audit-logged in discussion_board_access_logs for regulatory/compliance traceability, supporting full forensic workflows. This operation cannot be used to affect admin/member/guest sessions.\n\nError handling is standardized: if the token does not exist or is already revoked, the response is always success (idempotency, never reveals session state). For workflow: signIn → signOut is typical, with multi-session scenarios managed externally.","summary":"Moderator JWT logout: Invalidates the current session token for the moderator in discussion_board_auth_tokens.","parameters":[],"requestBody":null,"responseBody":{"description":"Confirmation that the moderator JWT session/token has been revoked (or was already invalid).","typeName":"IModerator.SignOutResponse"},"authorizationRole":"moderator","name":"signOut","path":"/auth/moderator/logout","method":"post"},{"specification":"Implements JWT token validation for the moderator role. Uses the incoming JWT (from client header) and validates it by verifying signature, expiry, and that it exists and is not revoked in discussion_board_auth_tokens with actor_type='moderator'.\n\nPurpose: Checks token status for session verification, access control, and role enforcement for secure API use as required by authentication specs. Does not perform authentication, only validates the given JWT.\n\nBusiness logic: The incoming token is checked for signature validity, expiry, correct role (actor_type='moderator'), and that revoked=false. If any check fails, access is denied and error logged.\n\nSecurity: Used by frontend and middleware for session status checks. All failed/invalid token validations must be logged for forensics. Supports supporting stateless JWT validation combined with persistent audit scenario (hybrid pattern documented in schema/access logs).\n\nWorkflow: Called by client before accessing protected endpoints, ensures session is valid and moderator actor is confirmed. Does not verify permissions beyond role. Used for session keep-alive pings.\n\nRelated: signIn (login), signOut (logout).","description":"This endpoint validates whether a submitted JWT token (supplied in request auth header) is currently valid for the moderator role. Validation includes checking JWT signature, matching the token against discussion_board_auth_tokens with actor_type='moderator', ensuring not revoked, and confirming expiry if set (as described in schema fields). Token validation is role-specific: only moderator tokens are checked.\n\nInput: JWT token is provided (typically via Authorization header or request field by convention); no body fields required. If validation passes, moderator's identity and session status are returned; if invalid/expired/revoked, an error is returned and recorded in access logs.\n\nThis operation is used for secure role access and can be called by client apps or API middleware before every moderator-protected endpoint call (as enforced by RBAC). Results NEVER expose sensitive details about what failed in the validation (for security). Audit logs record all validation attempts (success/failure).\n\nUse as a session-status operation. Related: signIn, signOut, changePassword.","summary":"Moderator JWT session/token validation: checks validity, expiry, and revocation status in discussion_board_auth_tokens.","parameters":[],"requestBody":null,"responseBody":{"description":"Result of moderator JWT validation (session and identity status for UI or middleware enforcement).","typeName":"IModerator.ValidateTokenResponse"},"authorizationRole":null,"name":"validateToken","path":"/auth/moderator/validate","method":"post"},{"specification":"Enables moderators to change their password. Verifies the current password using 'password_hash' field of discussion_board_moderators, then updates with a new hash if the old one is correct. Does not allow for arbitrary password resets (only self-service change).\n\nPurpose: Provides secure password change for authenticated moderators, in compliance with requirements for account control and security. Implements business rule: must know existing password to change to a new one.\n\nBusiness logic: User supplies current password and new password; API verifies current credential, then updates password_hash atomically. All password handling is secure, never exposes current or new values. is_active must be true. Database update occurs in the discussion_board_moderators table.\n\nSecurity: API endpoint is protected (only authenticated moderators). Supports full RBAC, input validation, strict error handling (never reveals which part of the authentication failed). All password updates are audit-logged, with old password hashes never provided to user or logged.\n\nAudit and compliance: Updated_at and password_hash updated atomically; event recorded in discussion_board_access_logs. Rate limiting is recommended.\n\nWorkflow: Client must prompt user for current password before allowing change. Error responses are generic for security purposes.\n\nRelated: signIn (login), signUp (registration), signOut (logout).","description":"This endpoint allows an authenticated moderator to securely change their password by supplying their current (old) password and a new password. The current password is verified against the existing 'password_hash' in discussion_board_moderators before updating to the new hash. The API does not support unauthenticated password resets or arbitrary password changes (self-service only).\n\nThe operation updates discussion_board_moderators, ensuring only the authenticated account is affected. The endpoint is protected by authorization middleware and requires valid JWT (actor_type='moderator').\n\nAll password changes are atomic, secure, and fully auditable: the updated_at and password_hash are modified together, and an entry is logged in discussion_board_access_logs for security auditing. Error responses never indicate if the old password was incorrect for security policy compliance.\n\nUse for: password change flows, RBAC session hygiene, and recovery from credential leakage. Related endpoints: signIn, signOut, validateToken.","summary":"Moderator password change: Verifies and updates password_hash in discussion_board_moderators.","parameters":[],"requestBody":{"description":"Current and new password information to update moderator's password in discussion_board_moderators.","typeName":"IModerator.ChangePassword"},"responseBody":{"description":"Moderator basic identity and confirmation of successful password change.","typeName":"IModerator.PasswordChangeResponse"},"authorizationRole":"moderator","name":"changePassword","path":"/auth/moderator/password","method":"put"}]