{
  "schemas": {
    "IPage.IRequest": {
      "type": "object",
      "properties": {
        "current": {
          "type": "integer",
          "description": "Current page number to request (1-based, required for all paged endpoints). Usually defaults to 1."
        },
        "limit": {
          "type": "integer",
          "description": "Desired number of records per page/result block. Strict max limit enforced by server (default 20/50/100, as per endpoint)."
        },
        "sorts": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "field": {
                "type": "string",
                "description": "Field name to sort results by. Must be valid column key (e.g., 'created_at', 'nickname'), as specified by the endpoint."
              },
              "direction": {
                "oneOf": [
                  {
                    "const": "asc",
                    "description": "Ascending order for the specified field."
                  },
                  {
                    "const": "desc",
                    "description": "Descending order for the specified field."
                  }
                ],
                "description": "Direction for sorting: 'asc' for ascending, 'desc' for descending."
              }
            },
            "required": [
              "field",
              "direction"
            ]
          },
          "description": "Array of objects specifying complex/multi-field sort order for paged endpoints. E.g. [{ field: 'created_at', direction: 'desc' }]. Optional; use for advanced paging/sorting UIs."
        }
      },
      "required": [
        "current",
        "limit"
      ],
      "description": "Standard pagination request object for all OpenAPI endpoints returning paged results. Used to specify page number, page size, and optional complex sorting. All paged endpoints' PATCH request bodies may extend from or include this as a base struct."
    },
    "ai_ecommerce_customers.IRequest": {
      "type": "object",
      "properties": {
        "search": {
          "type": "string",
          "description": "A free-text search string for filtering customers by nickname, email, or other indexed properties. Enables advanced searching/filtering of ai_ecommerce_customers list by query term.\n\nMatches records by partial or full email, display nickname, etc. as supported by system."
        },
        "status": {
          "type": "string",
          "description": "Status filter for customer account (e.g., 'active', 'deleted', or system-defined statuses). Used to filter by account lifecycle state.\n\nTypically supports 'active', 'deleted', 'locked', etc. Implemented at business logic/application level. Not a DB enum; value space enforced by backend."
        },
        "created_from": {
          "type": "string",
          "format": "date-time",
          "description": "Start date for filtering customers by account creation time. Supports ISO 8601 format.\n\nReturns only customers created after this timestamp (inclusive)."
        },
        "created_to": {
          "type": "string",
          "format": "date-time",
          "description": "End date for filtering customers by account creation time. Supports ISO 8601 format.\n\nReturns only customers created before this timestamp (inclusive)."
        },
        "page": {
          "type": "integer",
          "minimum": 1,
          "description": "Page number for paginated results. Defaults to 1 if omitted."
        },
        "limit": {
          "type": "integer",
          "minimum": 1,
          "maximum": 100,
          "description": "Maximum number of results per page (pagination limit). Defaults to 20 if omitted. Use for server-side paging."
        },
        "sort_key": {
          "type": "string",
          "description": "Key/field to sort by. Examples: 'created_at', 'nickname', etc.\n\nRequired for sortable paginated browsing and consistent result ordering."
        },
        "sort_order": {
          "oneOf": [
            {
              "const": "asc",
              "description": "Sort direction/order for results. 'asc' for ascending, 'desc' for descending. Default 'asc'.\n\nResults returned by field defined in sort_key."
            },
            {
              "const": "desc",
              "description": "Sort direction/order for results. 'asc' for ascending, 'desc' for descending. Default 'asc'.\n\nResults returned by field defined in sort_key."
            }
          ],
          "description": "Sort direction/order for results. 'asc' for ascending, 'desc' for descending. Default 'asc'.\n\nResults returned by field defined in sort_key."
        }
      },
      "description": "Request schema for paginated, filterable, and searchable retrieval of ai_ecommerce_customers. Used as PATCH request body for /ai_ecommerce/customers.\n\nEnables advanced query patterns on the customer entity list and supports pagination, search, and sorting.",
      "required": []
    },
    "IPageai_ecommerce_customers": {
      "type": "object",
      "properties": {
        "pagination": {
          "$ref": "#/components/schemas/IPage.IPagination"
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/ai_ecommerce_customers"
          }
        }
      },
      "required": [
        "pagination",
        "data"
      ],
      "description": "Paginated container for ai_ecommerce_customers result list.\n\nStandardized response structure for paging, includes data array of customers and a pagination info block. Used as response for PATCH /ai_ecommerce/customers."
    },
    "ai_ecommerce_customers": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "Unique customer identifier (UUID, primary key). Immutable. Referenced in all customer business flows and join relations. Mirrors id field in ai_ecommerce_customers table.\n\nUsed as foreign key in most customer-related records (cart, order, etc.)."
        },
        "profile_id": {
          "type": "string",
          "format": "uuid",
          "description": "Foreign key to 1:1 ai_ecommerce_user_profiles. Strictly required and unique per customer. Used for normalized profile linkage.\n\nNever directly modifiable after creation; enforced at database and service layer."
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp of account creation. ISO 8601, UTC. Used for audit, traceability and time-bounded queries."
        },
        "updated_at": {
          "type": "string",
          "format": "date-time",
          "description": "Datetime of last update. Used for audit, compliance, optimistic concurrency."
        },
        "deleted_at": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "Soft-deletion marker. If set (not null), the customer is logically deleted; else record is active.\n\nEnables GDPR/compliance workflows without physical deletion."
            },
            {
              "type": "null"
            }
          ],
          "description": "Soft-deletion marker. If set (not null), the customer is logically deleted; else record is active.\n\nEnables GDPR/compliance workflows without physical deletion."
        }
      },
      "required": [
        "id",
        "profile_id",
        "created_at",
        "updated_at"
      ],
      "description": "Normalized customer entity representing a registered account in ai_ecommerce_customers table.\n\nReferences the unique profile, audit data, and soft-deletion marker as described in core system schema. Used for customer management, admin/support, and backend logic."
    },
    "ai_ecommerce_customers.IRegister": {
      "type": "object",
      "properties": {
        "profile_id": {
          "type": "string",
          "format": "uuid",
          "description": "Foreign key linking this customer to ai_ecommerce_user_profiles. Strictly one-to-one; required for account creation.\n\nThis value must reference an existing user profile row."
        }
      },
      "required": [
        "profile_id"
      ],
      "description": "Payload schema for registration/creation of a new ai_ecommerce_customers entity (POST /ai_ecommerce/customers).\n\nRequires linking to a user profile; all other fields are system-generated or managed afterwards."
    },
    "ai_ecommerce_customers.IUpdate": {
      "type": "object",
      "properties": {
        "status": {
          "type": "string",
          "description": "Status to update the customer record with. Supported values depend on system business logic; may include 'active', 'deleted', etc."
        },
        "deleted_at": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "Update to set soft-deletion timestamp. If set (not null), marks as deleted; for restoring, may be set to null. Mutation follows business rules for logical deletion/restoration."
            },
            {
              "type": "null"
            }
          ],
          "description": "Update to set soft-deletion timestamp. If set (not null), marks as deleted; for restoring, may be set to null. Mutation follows business rules for logical deletion/restoration."
        }
      },
      "description": "Payload for patching/updating an ai_ecommerce_customers entity. Used for updating status or lifecycle dates, not profile_id.",
      "required": []
    },
    "ai_ecommerce_sellers.IRequest": {
      "type": "object",
      "properties": {
        "search": {
          "type": "string",
          "description": "Free-text search term to filter sellers, by business name, profile info, or other indexed fields."
        },
        "status": {
          "type": "string",
          "description": "Filter sellers by account status ('active', 'deleted', etc). Interpreted at business logic layer; not a DB enum."
        },
        "created_from": {
          "type": "string",
          "format": "date-time",
          "description": "Start date for filtering sellers by account creation time (ISO 8601)."
        },
        "created_to": {
          "type": "string",
          "format": "date-time",
          "description": "End date for filtering sellers by account creation time (ISO 8601)."
        },
        "page": {
          "type": "integer",
          "minimum": 1,
          "description": "Current page number for paginated results. Default 1."
        },
        "limit": {
          "type": "integer",
          "minimum": 1,
          "maximum": 100,
          "description": "Maximum page size (defaults to 20)."
        },
        "sort_key": {
          "type": "string",
          "description": "Field name to sort by ('created_at', etc)."
        },
        "sort_order": {
          "oneOf": [
            {
              "const": "asc",
              "description": "Sorting order: ascending ('asc') or descending ('desc')."
            },
            {
              "const": "desc",
              "description": "Sorting order: ascending ('asc') or descending ('desc')."
            }
          ],
          "description": "Sorting order: ascending ('asc') or descending ('desc')."
        }
      },
      "description": "Request schema for paged/searchable seller list retrieval (PATCH /ai_ecommerce/sellers). Supports free-text search, status filter, created timestamp range, pagination, and custom sorting.",
      "required": []
    },
    "IPageai_ecommerce_sellers": {
      "type": "object",
      "properties": {
        "pagination": {
          "$ref": "#/components/schemas/IPage.IPagination"
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/ai_ecommerce_sellers"
          }
        }
      },
      "required": [
        "pagination",
        "data"
      ],
      "description": "Paginated response container for ai_ecommerce_sellers search/listing. Used to wrap list of sellers with page info on PATCH /ai_ecommerce/sellers."
    },
    "ai_ecommerce_sellers": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "Unique seller identifier (UUID primary key). Used as seller identity on the platform."
        },
        "profile_id": {
          "type": "string",
          "format": "uuid",
          "description": "Unique user profile linkage (FK to ai_ecommerce_user_profiles). Enforcement of 1:1 business/identity separation."
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "Datetime when account (seller) was created."
        },
        "updated_at": {
          "type": "string",
          "format": "date-time",
          "description": "Datetime of last update for seller record."
        },
        "deleted_at": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "Soft-delete field: null if active, timestamp if deleted for audit/compliance."
            },
            {
              "type": "null"
            }
          ],
          "description": "Soft-delete field: null if active, timestamp if deleted for audit/compliance."
        }
      },
      "required": [
        "id",
        "profile_id",
        "created_at",
        "updated_at"
      ],
      "description": "Seller entity for ai_ecommerce_sellers, as defined in core schema.\n\nRepresents legal business user. Links 1:1 to a user profile."
    },
    "ai_ecommerce_sellers.IRegister": {
      "type": "object",
      "properties": {
        "profile_id": {
          "type": "string",
          "format": "uuid",
          "description": "Foreign key (UUID) to ai_ecommerce_user_profiles - identity for this seller. Enforces 1:1 business link."
        }
      },
      "required": [
        "profile_id"
      ],
      "description": "Payload for creating a new seller record (POST /ai_ecommerce/sellers). Requires linking to a user profile row. Other fields handled by system."
    },
    "ai_ecommerce_sellers.IUpdate": {
      "type": "object",
      "properties": {
        "status": {
          "type": "string",
          "description": "Status to set for seller. Not a database enum; enforced by application layer. Examples include: 'active', 'deleted', etc."
        },
        "deleted_at": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "Update for soft-deletion of seller; follow business compliance rules. Null for restore/reactivation; timestamp for deletion."
            },
            {
              "type": "null"
            }
          ],
          "description": "Update for soft-deletion of seller; follow business compliance rules. Null for restore/reactivation; timestamp for deletion."
        }
      },
      "description": "Payload for updating/patching a seller entity. Used for status/lifecycle field updates only.",
      "required": []
    },
    "ai_ecommerce_administrators.IRequest": {
      "type": "object",
      "properties": {
        "search": {
          "type": "string",
          "description": "Free-text search string for admin listing (email/nickname/etc. from linked profile or indexed fields)."
        },
        "status": {
          "type": "string",
          "description": "Status filter (e.g., 'active', 'deleted'). Not a true enum; business logic enforced."
        },
        "created_from": {
          "type": "string",
          "format": "date-time",
          "description": "Filter for admin accounts created after this datetime (ISO-8601)."
        },
        "created_to": {
          "type": "string",
          "format": "date-time",
          "description": "Filter for admin accounts created before this datetime (ISO-8601)."
        },
        "page": {
          "type": "integer",
          "minimum": 1,
          "description": "Pagination page number (min: 1, default: 1)."
        },
        "limit": {
          "type": "integer",
          "minimum": 1,
          "maximum": 100,
          "description": "Pagination limit (max: 100, default: 20)."
        },
        "sort_key": {
          "type": "string",
          "description": "Field name to sort by (e.g., 'created_at')."
        },
        "sort_order": {
          "oneOf": [
            {
              "const": "asc",
              "description": "Sort direction for results; 'asc' for ascending, 'desc' for descending."
            },
            {
              "const": "desc",
              "description": "Sort direction for results; 'asc' for ascending, 'desc' for descending."
            }
          ],
          "description": "Sort direction for results; 'asc' for ascending, 'desc' for descending."
        }
      },
      "description": "Request schema for paginated, searchable administrator account listing. Used on PATCH /ai_ecommerce/administrators.",
      "required": []
    },
    "IPageai_ecommerce_administrators": {
      "type": "object",
      "properties": {
        "pagination": {
          "$ref": "#/components/schemas/IPage.IPagination"
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/ai_ecommerce_administrators"
          }
        }
      },
      "required": [
        "pagination",
        "data"
      ],
      "description": "Paging wrapper for ai_ecommerce_administrators entities. Used in list results for PATCH /ai_ecommerce/administrators."
    },
    "ai_ecommerce_administrators": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "[Primary Key] - Unique admin identity; referenced in admin/audit flows. Immutable for all administrator records in the system.\n\nRequired by business and security rules for administrative account operations and traceability."
        },
        "profile_id": {
          "type": "string",
          "format": "uuid",
          "description": "[User Profile Relation] - 1:1 relation to ai_ecommerce_user_profiles; unique per admin. Required for identification and normalization.\n\nThis ensures each administrator record references a specific user profile, and that profile_id is unique for admins."
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "[Created Timestamp] - Created for traceability. System-generated timestamp for audit logs of administrator account creation.\n\nEnables full lifecycle and compliance audit or rollback."
        },
        "updated_at": {
          "type": "string",
          "format": "date-time",
          "description": "[Last Updated Timestamp] - Compliance/audit edits. Reflects changes or edits by sysadmin or process automation.\n\nTracks last modification, supporting change tracking and data stewardship for regulatory requirements."
        },
        "deleted_at": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "[Soft Delete] - Admin deactivation timestamp; null if active. When set, the administrator is deactivated (not removed) for compliance audit and system integrity.\n\nUsed to support regulatory mandates that require preservation of administrative change history even when a record is deactivated."
            },
            {
              "type": "null"
            }
          ],
          "description": "[Soft Delete] - Admin deactivation timestamp; null if active. When set, the administrator is deactivated (not removed) for compliance audit and system integrity.\n\nUsed to support regulatory mandates that require preservation of administrative change history even when a record is deactivated."
        }
      },
      "required": [
        "id",
        "profile_id",
        "created_at",
        "updated_at"
      ],
      "description": "Administrator entity representing privileged platform/system admins, as defined in the ai_ecommerce_administrators table (Prisma schema and ERD). Each administrator is uniquely linked to a user profile, supports traceability, soft deletion, and full audit compliance.\n\nReferenced in system audit, onboarding, and role management flows. Fulfills business requirements regarding admin separability, account lifecycle, and access control.\n\nAll properties, relations, and deletion behaviors described here mirror those in the original database schema and business logic."
    },
    "IPage.IPagination": {
      "type": "object",
      "description": "Paging metadata structure returned with all IPage<T> responses. Contains key info about the current page for list results, including position, strict limit, total record count, and calculated total pages. Used by dashboards, UIs, and reporting interfaces to build paginated/batch UX components.",
      "properties": {
        "current": {
          "type": "integer",
          "description": "Current page number (uint32). Required for all paginated responses."
        },
        "limit": {
          "type": "integer",
          "description": "Page size (per-page record limit, default 100/strict system-dependent max) for paginated result."
        },
        "records": {
          "type": "integer",
          "description": "Total number of records matching query in the DB (used to drive total page calculation, UX.)"
        },
        "pages": {
          "type": "integer",
          "description": "Total number of pages as analytic pagination ceil(records/limit)."
        }
      },
      "required": [
        "current",
        "limit",
        "records",
        "pages"
      ]
    },
    "IAiEcommerceAdministrator.ICreate": {
      "type": "object",
      "properties": {
        "profile_id": {
          "type": "string",
          "format": "uuid",
          "description": "[User Profile Relation] - 1:1 relation to ai_ecommerce_user_profiles table. Must be an existing, unique user profile ID representing the admin.\n\nEnforces normalization and uniqueness of administrators in the system."
        }
      },
      "required": [
        "profile_id"
      ],
      "description": "Request body schema for creating a new administrator record (ai_ecommerce_administrators table). Requires mandatory linkage to an existing user profile.\n\nProfile_id must refer to an available, unique user profile not already associated with an admin entity. All default fields, such as created_at and updated_at, are populated automatically by the system."
    },
    "IAiEcommerceAdministrator": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "[Primary Key] - Unique admin identity; referenced in admin/audit flows. Immutable for all administrator records in the system.\n\nRequired by business and security rules for administrative account operations and traceability."
        },
        "profile_id": {
          "type": "string",
          "format": "uuid",
          "description": "[User Profile Relation] - 1:1 relation to ai_ecommerce_user_profiles; unique per admin. Required for identification and normalization.\n\nThis ensures each administrator record references a specific user profile, and that profile_id is unique for admins."
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "[Created Timestamp] - Created for traceability. System-generated timestamp for audit logs of administrator account creation.\n\nEnables full lifecycle and compliance audit or rollback."
        },
        "updated_at": {
          "type": "string",
          "format": "date-time",
          "description": "[Last Updated Timestamp] - Compliance/audit edits. Reflects changes or edits by sysadmin or process automation.\n\nTracks last modification, supporting change tracking and data stewardship for regulatory requirements."
        },
        "deleted_at": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "[Soft Delete] - Admin deactivation timestamp; null if active. When set, the administrator is deactivated (not removed) for compliance audit and system integrity.\n\nUsed to support regulatory mandates that require preservation of administrative change history even when a record is deactivated."
            },
            {
              "type": "null"
            }
          ],
          "description": "[Soft Delete] - Admin deactivation timestamp; null if active. When set, the administrator is deactivated (not removed) for compliance audit and system integrity.\n\nUsed to support regulatory mandates that require preservation of administrative change history even when a record is deactivated."
        }
      },
      "required": [
        "id",
        "profile_id",
        "created_at",
        "updated_at"
      ],
      "description": "Administrator entity representing privileged platform/system admins, as defined in the ai_ecommerce_administrators table (Prisma schema and ERD). Each administrator is uniquely linked to a user profile, supports traceability, soft deletion, and full audit compliance.\n\nReferenced in system audit, onboarding, and role management flows. Fulfills business requirements regarding admin separability, account lifecycle, and access control.\n\nAll properties, relations, and deletion behaviors described here mirror those in the original database schema and business logic."
    },
    "IAiEcommerceAdministrator.IUpdate": {
      "type": "object",
      "properties": {
        "updated_at": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp for the moment the admin record is updated. Should be set to the current time when making the update.\n\nMandatory for all admin record change tracking."
        }
      },
      "required": [
        "updated_at"
      ],
      "description": "Request body for updating an administrator record in the ai_ecommerce_administrators table. Update able fields are restricted to timestamp (updated_at), as all other identifiers (profile_id, id) are immutable after creation.\n\nMust always set updated_at to current time for proper audit trail, in line with database and regulatory expectations."
    },
    "IAiEcommerceUserProfile.IRequest": {
      "type": "object",
      "properties": {
        "search": {
          "type": "string",
          "description": "Full-text search query for nickname or email. Enables flexible querying for admin dashboards, CMS interfaces, or customer management. Optional; if omitted, no filtering occurs."
        },
        "page": {
          "type": "integer",
          "format": "uint32",
          "description": "Page number for pagination (1-based). Used for batched result retrieval in UI or batch download. Optional; default is 1."
        },
        "limit": {
          "type": "integer",
          "format": "uint32",
          "description": "Records per page. Used to throttle or paginate results. Optional; default is 100."
        },
        "sortBy": {
          "type": "string",
          "description": "Field to sort results by (e.g. 'created_at', 'nickname'). Optional; omitted for natural order."
        },
        "sortDir": {
          "oneOf": [
            {
              "const": "asc",
              "description": "Direction of sorting for sortBy field ('asc' or 'desc'). Optional."
            },
            {
              "const": "desc",
              "description": "Direction of sorting for sortBy field ('asc' or 'desc'). Optional."
            }
          ],
          "description": "Direction of sorting for sortBy field ('asc' or 'desc'). Optional."
        }
      },
      "description": "Request parameters for searching/paginating user profiles (ai_ecommerce_user_profiles). Each field matches a probable query parameter, supporting typical admin UI or self-service search requirements. See Prisma schema for full field index and business rules.",
      "required": []
    },
    "IPageIAiEcommerceUserProfile": {
      "type": "object",
      "properties": {
        "pagination": {
          "type": "object",
          "properties": {
            "current": {
              "type": "integer",
              "format": "uint32",
              "description": "Current page number being returned."
            },
            "limit": {
              "type": "integer",
              "format": "uint32",
              "description": "Maximum number of records returned per page (default 100)."
            },
            "records": {
              "type": "integer",
              "format": "uint32",
              "description": "Total number of records in the database for this query."
            },
            "pages": {
              "type": "integer",
              "format": "uint32",
              "description": "Total page count for this query."
            }
          },
          "required": [
            "current",
            "limit",
            "records",
            "pages"
          ],
          "description": "Pagination definition for paged result containers. All paginated endpoints return this object alongside actual data."
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/IAiEcommerceUserProfile"
          },
          "description": "List of user profiles for the current page."
        }
      },
      "required": [
        "pagination",
        "data"
      ],
      "description": "Standard paginated result for ai_ecommerce_user_profiles entity search/list operation. All paginated collection endpoints follow this container, including the mandatory data array and pagination metadata."
    },
    "IAiEcommerceUserProfile": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "[Primary Key] - One-to-one with every user/seller/admin identity. Global unique identifier for user profiles."
        },
        "nickname": {
          "type": "string",
          "description": "[Display Nickname] - Used as user-facing name; not globally unique. Allows for system-search and UI display."
        },
        "avatar_uri": {
          "oneOf": [
            {
              "type": "string",
              "maxLength": 80000,
              "description": "[Profile Image URI] - Optional. Stores avatar/profile photo as URI string. May be null if not set."
            },
            {
              "type": "null"
            }
          ],
          "description": "[Profile Image URI] - Optional. Stores avatar/profile photo as URI string. May be null if not set."
        },
        "email": {
          "type": "string",
          "description": "[Email Address] - Main point of communication & login. Must be unique system-wide; enforced at DB and business logic."
        },
        "phone_number": {
          "oneOf": [
            {
              "type": "string",
              "description": "[Phone Number] - Optional for secondary comms/MFA. May be null if not supplied."
            },
            {
              "type": "null"
            }
          ],
          "description": "[Phone Number] - Optional for secondary comms/MFA. May be null if not supplied."
        },
        "communication_consent": {
          "type": "boolean",
          "description": "[Communication Consent] - True if user has opted in for platform communication. Regulatory/business compliance setting."
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "[Created Timestamp] - Timestamp of profile creation. Used for audit, lifecycle, and compliance."
        },
        "updated_at": {
          "type": "string",
          "format": "date-time",
          "description": "[Updated Timestamp] - Timestamp of last change to profile. Essential for profile updates, rollback, and change tracking."
        }
      },
      "required": [
        "id",
        "nickname",
        "email",
        "communication_consent",
        "created_at",
        "updated_at"
      ],
      "description": "ai_ecommerce_user_profiles entity representing fundamental user/account profile for customers, sellers, and admins. Contains all basic display/communication fields, normalization logic, and audit fields.\n\nBusiness rule: At most one profile per email; all RBAC and account linkage is by this entity. Conforms to DB schema and UX design for consistent access, creation, and updating."
    },
    "IAiEcommerceUserProfile.ICreate": {
      "type": "object",
      "properties": {
        "nickname": {
          "type": "string",
          "description": "[Display Nickname] - Required name string for display in community/UI/comm preferences. Non-unique."
        },
        "avatar_uri": {
          "oneOf": [
            {
              "type": "string",
              "maxLength": 80000,
              "description": "[Profile Image URI] - Optional; avatar file URI, may be set to null to omit."
            },
            {
              "type": "null"
            }
          ],
          "description": "[Profile Image URI] - Optional; avatar file URI, may be set to null to omit."
        },
        "email": {
          "type": "string",
          "description": "[Email Address] - Required field for system comms and login. Must be unique at time of creation."
        },
        "phone_number": {
          "oneOf": [
            {
              "type": "string",
              "description": "[Phone Number] - Optional field for comms/MFA. Omit or set null if unused."
            },
            {
              "type": "null"
            }
          ],
          "description": "[Phone Number] - Optional field for comms/MFA. Omit or set null if unused."
        },
        "communication_consent": {
          "type": "boolean",
          "description": "[Communication Consent] - Explicit consent to contact. True/false only."
        }
      },
      "required": [
        "nickname",
        "email",
        "communication_consent"
      ],
      "description": "Request body for creating new ai_ecommerce_user_profiles entity. All fields must be supplied per business/rule constraints except optional avatar/phone number. Omitted/invalid email or nickname triggers record rejection."
    },
    "IAiEcommerceUserProfile.IUpdate": {
      "type": "object",
      "properties": {
        "nickname": {
          "type": "string",
          "description": "Updated nickname for the user profile, if changed. May be omitted if not changing. Requires non-empty string if set."
        },
        "avatar_uri": {
          "oneOf": [
            {
              "type": "string",
              "maxLength": 80000,
              "description": "Profile image URI to update. Optional. Can set to null to remove avatar."
            },
            {
              "type": "null"
            }
          ],
          "description": "Profile image URI to update. Optional. Can set to null to remove avatar."
        },
        "email": {
          "type": "string",
          "description": "Updated email address; must remain unique if changed. Validation applies. Optional."
        },
        "phone_number": {
          "oneOf": [
            {
              "type": "string",
              "description": "Updated phone number for comms/MFA. Optional. Can set null to clear."
            },
            {
              "type": "null"
            }
          ],
          "description": "Updated phone number for comms/MFA. Optional. Can set null to clear."
        },
        "communication_consent": {
          "type": "boolean",
          "description": "Updated communication consent flag. Optional; set to true/false."
        }
      },
      "description": "Payload for updating ai_ecommerce_user_profiles. Supports partial or full update. All fields optional, but at least one should be supplied for effective update. Omitting a property leaves it unchanged.\n\nBusiness and schema rules enforce constraints (e.g., unique email, non-null constraints, 80000 char max for avatar).",
      "required": []
    },
    "IAiEcommerceUserAddress.IRequest": {
      "type": "object",
      "properties": {
        "profile_id": {
          "type": "string",
          "format": "uuid",
          "description": "Filter by user profile (foreign key). Only addresses belonging to this user profile will be returned. Optional."
        },
        "address_type": {
          "type": "string",
          "description": "Filter by address type (e.g., 'default', 'delivery', 'billing'). Optional."
        },
        "search": {
          "type": "string",
          "description": "Full-text search across name, address, custom_label, etc. Optional."
        },
        "region_code": {
          "type": "string",
          "description": "Filter addresses by region code (ISO/Country). Optional."
        },
        "is_default": {
          "type": "boolean",
          "description": "Filter only default addresses (true/false). Optional."
        },
        "page": {
          "type": "integer",
          "format": "uint32",
          "description": "Pagination: page number (1-based). Optional."
        },
        "limit": {
          "type": "integer",
          "format": "uint32",
          "description": "Pagination: number of records per page. Optional."
        }
      },
      "description": "Request payload for searching, filtering, and paginating user address book entries (ai_ecommerce_user_addresses/\nai_ecommerce_user_address). All parameters are optional for flexible queries.",
      "required": []
    },
    "IPageIAiEcommerceUserAddress": {
      "type": "object",
      "properties": {
        "pagination": {
          "type": "object",
          "properties": {
            "current": {
              "type": "integer",
              "format": "uint32",
              "description": "Current page number being returned."
            },
            "limit": {
              "type": "integer",
              "format": "uint32",
              "description": "Maximum number of records returned per page (default 100)."
            },
            "records": {
              "type": "integer",
              "format": "uint32",
              "description": "Total number of records in the database for this query."
            },
            "pages": {
              "type": "integer",
              "format": "uint32",
              "description": "Total page count for this query."
            }
          },
          "required": [
            "current",
            "limit",
            "records",
            "pages"
          ],
          "description": "Pagination definition for paged result containers. All paginated endpoints return this object alongside actual data."
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/IAiEcommerceUserAddress"
          },
          "description": "List of user addresses for the current page."
        }
      },
      "required": [
        "pagination",
        "data"
      ],
      "description": "Paginated data structure for user address list results. Includes result set of addresses and pagination metadata for UI display/consumption."
    },
    "IAiEcommerceUserAddress": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "[Primary Key] - Unique address ID for referencing/fulfillment and audit."
        },
        "profile_id": {
          "type": "string",
          "format": "uuid",
          "description": "[Profile FK] - Indicates which user/owner the address belongs to. Foreign key to user_profiles."
        },
        "address_type": {
          "type": "string",
          "description": "Address classification; business logic expects values like 'default', 'billing', or 'delivery'."
        },
        "name": {
          "type": "string",
          "description": "Recipient name for this address; used for delivery or billing records."
        },
        "phone_number": {
          "type": "string",
          "description": "Recipient contact phone number; used for fulfillment and customer contact."
        },
        "postal_code": {
          "type": "string",
          "description": "Address postal/ZIP code for shipping validation. FMS/international addresses supported."
        },
        "address_line1": {
          "type": "string",
          "description": "First address line (required); typically street, building number, etc."
        },
        "address_line2": {
          "oneOf": [
            {
              "type": "string",
              "description": "Additional bottom/auxiliary address info (optional); apt/unit/floor."
            },
            {
              "type": "null"
            }
          ],
          "description": "Additional bottom/auxiliary address info (optional); apt/unit/floor."
        },
        "custom_label": {
          "oneOf": [
            {
              "type": "string",
              "description": "User-supplied friendly label, e.g. 'Home', 'Work', 'For gifts'. Optional; may be null."
            },
            {
              "type": "null"
            }
          ],
          "description": "User-supplied friendly label, e.g. 'Home', 'Work', 'For gifts'. Optional; may be null."
        },
        "region_code": {
          "type": "string",
          "description": "Region or country code; ISO/locale identifier. Required for shipping compliance."
        },
        "is_default": {
          "type": "boolean",
          "description": "True if this address is the user's active default. Used by services/UI to pre-select address for checkout."
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "Record creation timestamp. System-generated for compliance/audit auditing."
        },
        "updated_at": {
          "type": "string",
          "format": "date-time",
          "description": "Last modification timestamp. Used for audit and version history."
        },
        "deleted_at": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "Soft delete timestamp; null if active. Set for logically removed/compliant retrievals."
            },
            {
              "type": "null"
            }
          ],
          "description": "Soft delete timestamp; null if active. Set for logically removed/compliant retrievals."
        }
      },
      "required": [
        "id",
        "profile_id",
        "address_type",
        "name",
        "phone_number",
        "postal_code",
        "address_line1",
        "region_code",
        "is_default",
        "created_at",
        "updated_at"
      ],
      "description": "Atomic user address record as defined in ai_ecommerce_user_addresses/ai_ecommerce_user_address. Used for fulfillment, billing, address book UIs, and compliance queries. All major fields are separated per DB normalization; read/write business rules enforced as per schema descriptions."
    },
    "IAiEcommerceUserAddress.ICreate": {
      "type": "object",
      "properties": {
        "profile_id": {
          "type": "string",
          "format": "uuid",
          "description": "Foreign key referring to the user's profile. This field links the address to a user via ai_ecommerce_user_profiles.id. Required for associating the address with its owner profile in a normalized fashion. See Prisma schema for ai_ecommerce_user_addresses.profile_id."
        },
        "address_type": {
          "type": "string",
          "description": "Classifies the address as 'default', 'delivery', or 'billing'. Serves logical separation of addresses in user profile context. Enforced by application logic and referenced at checkout, profile book, and for business flows. See Prisma: ai_ecommerce_user_addresses.address_type."
        },
        "name": {
          "type": "string",
          "description": "Name of the person who will receive at this address. Required for labeling deliveries, billing, etc. Directly maps to ai_ecommerce_user_addresses.name."
        },
        "phone_number": {
          "type": "string",
          "description": "Contact phone for delivery, notifications, or order/fulfillment. Atomic per 3NF. Column: ai_ecommerce_user_addresses.phone_number."
        },
        "postal_code": {
          "type": "string",
          "description": "Postal ZIP code for address validation/shipping. Handles domestic/international. See Prisma: ai_ecommerce_user_addresses.postal_code."
        },
        "address_line1": {
          "type": "string",
          "description": "Main address field: street/road/building, atomic per normalization. See ai_ecommerce_user_addresses.address_line1."
        },
        "address_line2": {
          "oneOf": [
            {
              "type": "string",
              "description": "Optional additional address detail: apartment/floor/etc. Null if unused. Column: ai_ecommerce_user_addresses.address_line2."
            },
            {
              "type": "null",
              "description": "Optional additional address detail: apartment/floor/etc. Null if unused. Column: ai_ecommerce_user_addresses.address_line2."
            }
          ],
          "description": "Optional additional address detail: apartment/floor/etc. Null if unused. Column: ai_ecommerce_user_addresses.address_line2."
        },
        "custom_label": {
          "oneOf": [
            {
              "type": "string",
              "description": "Optional user-supplied display name for address. Enables easier address selection (e.g., 'Work', 'Mom's House'). Null if not labeled. See ai_ecommerce_user_addresses.custom_label."
            },
            {
              "type": "null",
              "description": "Optional user-supplied display name for address. Enables easier address selection (e.g., 'Work', 'Mom's House'). Null if not labeled. See ai_ecommerce_user_addresses.custom_label."
            }
          ],
          "description": "Optional user-supplied display name for address. Enables easier address selection (e.g., 'Work', 'Mom's House'). Null if not labeled. See ai_ecommerce_user_addresses.custom_label."
        },
        "region_code": {
          "type": "string",
          "description": "Code denoting region/country for shipping and legal region enforcement. ISO/local codes supported. Prisma: ai_ecommerce_user_addresses.region_code."
        },
        "is_default": {
          "type": "boolean",
          "description": "Whether this address is considered the default for the profile. Enforced at the service level; not multiple default per user. See ai_ecommerce_user_addresses.is_default."
        }
      },
      "required": [
        "profile_id",
        "address_type",
        "name",
        "phone_number",
        "postal_code",
        "address_line1",
        "region_code",
        "is_default"
      ],
      "description": "Request body for creating a user address, as per ai_ecommerce_user_addresses in Prisma schema. Contains all required fields, links to profile, and optionally labels/customizes the address for user UX. Required for user address onboarding, checkout, and delivery flows. All business and normalization rules referenced from the schema documentation."
    },
    "IAiEcommerceUserAddress.IUpdate": {
      "type": "object",
      "properties": {
        "address_type": {
          "type": "string",
          "description": "See IAiEcommerceUserAddress.ICreate; updates the type for this address (default/delivery/billing)."
        },
        "name": {
          "type": "string",
          "description": "Recipient name for this address."
        },
        "phone_number": {
          "type": "string",
          "description": "Contact phone for delivery/fulfillment."
        },
        "postal_code": {
          "type": "string",
          "description": "Postal ZIP code for delivery address."
        },
        "address_line1": {
          "type": "string",
          "description": "Main address line."
        },
        "address_line2": {
          "oneOf": [
            {
              "type": "string",
              "description": "Optional detail (apartment/unit/floor)."
            },
            {
              "type": "null",
              "description": "Optional detail (apartment/unit/floor)."
            }
          ],
          "description": "Optional detail (apartment/unit/floor)."
        },
        "custom_label": {
          "oneOf": [
            {
              "type": "string",
              "description": "Optional label for easier user recognition."
            },
            {
              "type": "null",
              "description": "Optional label for easier user recognition."
            }
          ],
          "description": "Optional label for easier user recognition."
        },
        "region_code": {
          "type": "string",
          "description": "Region or country code."
        },
        "is_default": {
          "type": "boolean",
          "description": "Mark or remove this address as default."
        }
      },
      "required": [],
      "description": "Update body for ai_ecommerce_user_addresses. All fields optional; only properties present will be updated. Used for address edits, relabeling, or updating delivery data in customer or admin flows. See schema for validation, normalization, and compliance requirements."
    },
    "ai_ecommerce_user_oauth.IRequest": {
      "type": "object",
      "properties": {
        "profile_id": {
          "type": "string",
          "format": "uuid",
          "description": "Foreign key to user profile (ai_ecommerce_user_profiles.id)."
        },
        "provider": {
          "type": "string",
          "description": "OAuth provider. E.g., 'google', 'apple', etc."
        },
        "provider_user_id": {
          "type": "string",
          "description": "Unique identifier provided by OAuth provider for federation."
        },
        "created_from": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "Earliest date for filtering linked OAuth accounts."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "Earliest date for filtering linked OAuth accounts."
            }
          ],
          "description": "Earliest date for filtering linked OAuth accounts."
        },
        "created_to": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "Latest date for filtering linked OAuth accounts."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "Latest date for filtering linked OAuth accounts."
            }
          ],
          "description": "Latest date for filtering linked OAuth accounts."
        },
        "page": {
          "type": "integer",
          "description": "Pagination: page number, starts from 1."
        },
        "limit": {
          "type": "integer",
          "description": "Pagination: maximum records per page."
        }
      },
      "required": [],
      "description": "Search, filter and pagination structure for listing OAuth account bindings. Applies query filters as defined for ai_ecommerce_user_oauth PATCH endpoint. Each parameter references the normalized properties from the Prisma schema. For listing OAuth linkages by user or admin, see schema documentation for property semantics."
    },
    "IPageai_ecommerce_user_oauth": {
      "type": "object",
      "properties": {
        "pagination": {
          "$ref": "#/components/schemas/IPage.IPagination"
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/ai_ecommerce_user_oauth"
          },
          "description": "Array of OAuth user account records."
        }
      },
      "required": [
        "pagination",
        "data"
      ],
      "description": "Paginated response for ai_ecommerce_user_oauth list API. Contains pagination metadata and an array of ai_ecommerce_user_oauth records. See IPage<T> standard in API."
    },
    "ai_ecommerce_user_oauth": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "Primary key for the ai_ecommerce_user_oauth table. Unique OAuth binding row identifier. See schema documentation."
        },
        "profile_id": {
          "type": "string",
          "format": "uuid",
          "description": "Foreign key linking this OAuth record to the user profile. See ai_ecommerce_user_profiles.id."
        },
        "provider": {
          "type": "string",
          "description": "OAuth provider (e.g., 'google','apple','kakao')."
        },
        "provider_user_id": {
          "type": "string",
          "description": "User ID as provided by the OAuth provider. Must be globally unique within the provider namespace."
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp for account linkage; audit field. See ai_ecommerce_user_oauth.created_at."
        }
      },
      "required": [
        "id",
        "profile_id",
        "provider",
        "provider_user_id",
        "created_at"
      ],
      "description": "Represents a single OAuth provider linkage for a user profile, per ai_ecommerce_user_oauth table in Prisma schema. Used for federated login, SSO, or external authentication. All fields map directly to Prisma columns and 3NF requirements. Comprehensively documents the normalized OAuth linkage."
    },
    "ai_ecommerce_user_oauth.ICreate": {
      "type": "object",
      "properties": {
        "profile_id": {
          "type": "string",
          "format": "uuid",
          "description": "User profile foreign key; owner of the OAuth linkage."
        },
        "provider": {
          "type": "string",
          "description": "Provider key: 'google', 'apple', 'kakao', etc."
        },
        "provider_user_id": {
          "type": "string",
          "description": "OAuth provider-side unique user id reference."
        }
      },
      "required": [
        "profile_id",
        "provider",
        "provider_user_id"
      ],
      "description": "Request payload for creating a new OAuth provider binding for a user. Requires the profile (FK), provider key, and external provider_user_id. Input parallels the columns in ai_ecommerce_user_oauth table per schema."
    },
    "ai_ecommerce_user_oauth.IUpdate": {
      "type": "object",
      "properties": {
        "provider": {
          "type": "string",
          "description": "Update the OAuth provider, if allowed."
        },
        "provider_user_id": {
          "type": "string",
          "description": "Update the provider user id."
        }
      },
      "required": [],
      "description": "Update structure for ai_ecommerce_user_oauth. Supports patching provider/provider_user_id."
    },
    "ai_ecommerce_user_audit_logs.IRequest": {
      "type": "object",
      "properties": {
        "profile_id": {
          "type": "string",
          "format": "uuid",
          "description": "Filter logs by user profile owning the audit log."
        },
        "event_type": {
          "type": "string",
          "description": "Type of audit event ('registration','login','profile_update', etc.)."
        },
        "created_from": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "Earliest log creation date for filter."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "Earliest log creation date for filter."
            }
          ],
          "description": "Earliest log creation date for filter."
        },
        "created_to": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "Latest log creation date for filter."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "Latest log creation date for filter."
            }
          ],
          "description": "Latest log creation date for filter."
        },
        "page": {
          "type": "integer",
          "description": "Page number, for pagination."
        },
        "limit": {
          "type": "integer",
          "description": "Page size (number of records per page)."
        }
      },
      "required": [],
      "description": "Search/pagination/filtering parameters for PATCH listing of ai_ecommerce_user_audit_logs. Parameter definitions match Prisma schema properties for user audit logging/filtering/analytics."
    },
    "IPageai_ecommerce_user_audit_logs": {
      "type": "object",
      "properties": {
        "pagination": {
          "$ref": "#/components/schemas/IPage.IPagination"
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/ai_ecommerce_user_audit_logs"
          },
          "description": "Array of audit log records matching the search."
        }
      },
      "required": [
        "pagination",
        "data"
      ],
      "description": "Paginated result for ai_ecommerce_user_audit_logs list/search. Array contains audit log records, pagination describes current/total state."
    },
    "ai_ecommerce_user_audit_logs": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "Primary key for each audit event. Immutable/unique. Prisma ai_ecommerce_user_audit_logs.id."
        },
        "profile_id": {
          "type": "string",
          "format": "uuid",
          "description": "FK to actor user profile who performed action. 1:N relationship. Prisma: profile_id."
        },
        "event_type": {
          "type": "string",
          "description": "Enumeration of audit event type: 'registration','login','profile_update', etc."
        },
        "event_payload": {
          "oneOf": [
            {
              "type": "string",
              "description": "JSON or free text describing event context (e.g. device/IP location). Prisma: event_payload."
            },
            {
              "type": "null",
              "description": "JSON or free text describing event context (e.g. device/IP location). Prisma: event_payload."
            }
          ],
          "description": "JSON or free text describing event context (e.g. device/IP location). Prisma: event_payload."
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "Audit event creation timestamp. Prisma: created_at."
        }
      },
      "required": [
        "id",
        "profile_id",
        "event_type",
        "created_at"
      ],
      "description": "Single user audit log event as recorded by ai_ecommerce_user_audit_logs table. Represents key user events (registration, login, changes). All properties derived from schema, not duplicated elsewhere."
    },
    "ai_ecommerce_user_audit_logs.ICreate": {
      "type": "object",
      "properties": {
        "profile_id": {
          "type": "string",
          "format": "uuid",
          "description": "Actor's user profile FK. Belongs to ai_ecommerce_user_profiles.id."
        },
        "event_type": {
          "type": "string",
          "description": "Audit event code/type. See Prisma column."
        },
        "event_payload": {
          "oneOf": [
            {
              "type": "string",
              "description": "Optional additional event details/metadata (JSON/text, etc)."
            },
            {
              "type": "null",
              "description": "Optional additional event details/metadata (JSON/text, etc)."
            }
          ],
          "description": "Optional additional event details/metadata (JSON/text, etc)."
        }
      },
      "required": [
        "profile_id",
        "event_type"
      ],
      "description": "Request payload for creating an audit log entry (user action). Properties mirror ai_ecommerce_user_audit_logs for normalized event logging. Event payload may be omitted/null as per schema definition."
    },
    "ai_ecommerce_user_audit_logs.IUpdate": {
      "type": "object",
      "properties": {
        "event_type": {
          "type": "string",
          "description": "Updated event type code, if correcting event log."
        },
        "event_payload": {
          "oneOf": [
            {
              "type": "string",
              "description": "Edit/append/correct event context for audit trail."
            },
            {
              "type": "null",
              "description": "Edit/append/correct event context for audit trail."
            }
          ],
          "description": "Edit/append/correct event context for audit trail."
        }
      },
      "required": [],
      "description": "Update structure for amending user audit log records. Supports correcting event type or payload. Intended for administration or legal correction only, as logs are otherwise append-only."
    },
    "ai_ecommerce_seller_business_profiles.IRequest": {
      "type": "object",
      "properties": {
        "seller_id": {
          "type": "string",
          "format": "uuid",
          "description": "Unique identifier of the seller whose business profiles are being requested. This must be a UUID as per the ai_ecommerce_seller_business_profiles schema. This filter allows administrative queries over all associated business profiles of a seller.\n\nReference: FK in Prisma ai_ecommerce_seller_business_profiles."
        },
        "business_name": {
          "type": "string",
          "description": "Business name (company name) filter for advanced search. Allows partial/full search for company registration/onboarding scenarios. This value should match normalized business profile schemas, supporting UI querying of sellers by business name.\n\nReference: business_name in ai_ecommerce_seller_business_profiles."
        },
        "business_registration_number": {
          "type": "string",
          "description": "Filter by unique business registration number. Used in seller onboarding compliance and duplicate prevention. This value determines if a business is already registered, aiding in anti-fraud and regulatory lookup.\n\nReference: business_registration_number in ai_ecommerce_seller_business_profiles."
        },
        "tax_id": {
          "oneOf": [
            {
              "type": "string",
              "description": "Optional filter for business tax ID (usually from tax certificates or compliance onboarding). Null if the business does not provide one. Essential for regulatory filter and onboarding validation.\n\nReference: tax_id in ai_ecommerce_seller_business_profiles."
            },
            {
              "type": "null",
              "description": "Optional filter for business tax ID (usually from tax certificates or compliance onboarding). Null if the business does not provide one. Essential for regulatory filter and onboarding validation.\n\nReference: tax_id in ai_ecommerce_seller_business_profiles."
            }
          ],
          "description": "Optional filter for business tax ID (usually from tax certificates or compliance onboarding). Null if the business does not provide one. Essential for regulatory filter and onboarding validation.\n\nReference: tax_id in ai_ecommerce_seller_business_profiles."
        },
        "is_deleted": {
          "type": "boolean",
          "description": "When true, only soft-deleted (deleted_at set) business profiles are returned. Used for compliance reviews. Linked to deleted_at property in schema.\n\nReference: deleted_at in ai_ecommerce_seller_business_profiles."
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "Lower bound ISO8601 timestamp for filtering business profiles created after this point. Useful for onboarding review, time-based batch queries, and reporting.\n\nReference: created_at in ai_ecommerce_seller_business_profiles."
        },
        "updated_at": {
          "type": "string",
          "format": "date-time",
          "description": "Lower bound ISO8601 timestamp for last updated time. Used for querying business profiles based on recency of change.\n\nReference: updated_at in ai_ecommerce_seller_business_profiles."
        },
        "page": {
          "type": "integer",
          "description": "Pagination: which result page to retrieve (1-based).",
          "minimum": 1
        },
        "limit": {
          "type": "integer",
          "description": "Pagination: number of results per page. System defaults should apply if not supplied.",
          "minimum": 1
        }
      },
      "required": [],
      "description": "Request DTO for searching/filtering/paging seller business profiles. Every property aligns with a column or business logic in ai_ecommerce_seller_business_profiles Prisma schema. All fields are optional and can be used in any combination for flexible query construction.\n\nCan be used in admin onboarding dashboard, compliance review pipelines, and seller search interfaces.\n\nSupports multi-field search, pagination, and compliance-filtered querying."
    },
    "IPageai_ecommerce_seller_business_profiles": {
      "type": "object",
      "properties": {
        "pagination": {
          "$ref": "#/components/schemas/IPage.IPagination"
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/IAiEcommerceSellerBusinessProfile"
          },
          "description": "Paginated array of seller business profile summary/detail records. Each item is compliant with IAiEcommerceSellerBusinessProfile."
        }
      },
      "required": [
        "pagination",
        "data"
      ],
      "description": "Paginated container for ai_ecommerce_seller_business_profiles query results. Conforms to IPage<T> as used throughout the platform. Contains page metadata and result data array."
    },
    "IAiEcommerceSellerBusinessProfile": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "Primary key UUID uniquely identifying the seller business profile. Required for linking, updating, deleting, or compliance tracking.\n\nReference: id in ai_ecommerce_seller_business_profiles."
        },
        "seller_id": {
          "type": "string",
          "format": "uuid",
          "description": "UUID linking this business profile to its owner seller. Strong FK enforce 1:1 mapping. Immutable after creation.\n\nReference: seller_id in ai_ecommerce_seller_business_profiles."
        },
        "business_name": {
          "type": "string",
          "description": "The legally registered company name for this business profile. Onboarding/compliance purposes. Must be unique per seller.\n\nReference: business_name in ai_ecommerce_seller_business_profiles."
        },
        "business_registration_number": {
          "type": "string",
          "description": "Employer/business registration number used for legal and regulatory trace. Must be unique in table.\n\nReference: business_registration_number in ai_ecommerce_seller_business_profiles."
        },
        "tax_id": {
          "oneOf": [
            {
              "type": "string",
              "description": "Government-issued business tax ID. Used in compliance, onboarding, and cross-border processing. Nullable if not provided.\n\nReference: tax_id in ai_ecommerce_seller_business_profiles."
            },
            {
              "type": "null",
              "description": "Government-issued business tax ID. Used in compliance, onboarding, and cross-border processing. Nullable if not provided.\n\nReference: tax_id in ai_ecommerce_seller_business_profiles."
            }
          ],
          "description": "Government-issued business tax ID. Used in compliance, onboarding, and cross-border processing. Nullable if not provided.\n\nReference: tax_id in ai_ecommerce_seller_business_profiles."
        },
        "contact_name": {
          "type": "string",
          "description": "The business point-of-contact's name. Used for escalation/logistics. Must match onboarding/contact documentation.\n\nReference: contact_name in ai_ecommerce_seller_business_profiles."
        },
        "contact_phone": {
          "type": "string",
          "description": "Contact telephone number for the business. Requires normalization/validation. Used for onboarding/audit communication.\n\nReference: contact_phone in ai_ecommerce_seller_business_profiles."
        },
        "contact_email": {
          "type": "string",
          "description": "Contact email for all business communication, onboarding, support, or compliance notifications. Not user/seller's private email: must be a business domain address.\n\nReference: contact_email in ai_ecommerce_seller_business_profiles."
        },
        "address_line1": {
          "type": "string",
          "description": "Business headquarters/physical location, first address line. Used for onboarding/shipping/compliance correspondence.\n\nReference: address_line1 in ai_ecommerce_seller_business_profiles."
        },
        "address_line2": {
          "oneOf": [
            {
              "type": "string",
              "description": "Second address line for more detailed addresses (unit/floor/etc). Optionally filled during onboarding.\n\nReference: address_line2 in ai_ecommerce_seller_business_profiles."
            },
            {
              "type": "null",
              "description": "Second address line for more detailed addresses (unit/floor/etc). Optionally filled during onboarding.\n\nReference: address_line2 in ai_ecommerce_seller_business_profiles."
            }
          ],
          "description": "Second address line for more detailed addresses (unit/floor/etc). Optionally filled during onboarding.\n\nReference: address_line2 in ai_ecommerce_seller_business_profiles."
        },
        "city": {
          "type": "string",
          "description": "Business city/municipality. Required for logistics, regulatory analysis.\n\nReference: city in ai_ecommerce_seller_business_profiles."
        },
        "state": {
          "type": "string",
          "description": "State or province or region for business registration. Critical for internationalization, regulatory sorting.\n\nReference: state in ai_ecommerce_seller_business_profiles."
        },
        "postal_code": {
          "type": "string",
          "description": "Postal or ZIP code of the business address. Used for plugin delivery/logistics, address validation.\n\nReference: postal_code in ai_ecommerce_seller_business_profiles."
        },
        "country": {
          "type": "string",
          "description": "Country in ISO country name/code (e.g., 'KR', 'KOR', 'South Korea'). Required for compliance.\n\nReference: country in ai_ecommerce_seller_business_profiles."
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "ISO8601 timestamp for when the business profile was created. System-generated.\n\nReference: created_at in ai_ecommerce_seller_business_profiles."
        },
        "updated_at": {
          "type": "string",
          "format": "date-time",
          "description": "ISO8601 timestamp for last update of the business profile. Used for system audit/compliance.\n\nReference: updated_at in ai_ecommerce_seller_business_profiles."
        },
        "deleted_at": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "Null if active; ISO8601 timestamp if soft-deleted. Used for compliance, never hard deleted unless required by regulatory policy.\n\nReference: deleted_at in ai_ecommerce_seller_business_profiles."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "Null if active; ISO8601 timestamp if soft-deleted. Used for compliance, never hard deleted unless required by regulatory policy.\n\nReference: deleted_at in ai_ecommerce_seller_business_profiles."
            }
          ],
          "description": "Null if active; ISO8601 timestamp if soft-deleted. Used for compliance, never hard deleted unless required by regulatory policy.\n\nReference: deleted_at in ai_ecommerce_seller_business_profiles."
        }
      },
      "required": [
        "id",
        "seller_id",
        "business_name",
        "business_registration_number",
        "contact_name",
        "contact_phone",
        "contact_email",
        "address_line1",
        "city",
        "state",
        "postal_code",
        "country",
        "created_at",
        "updated_at"
      ],
      "description": "Complete business profile for an ai_ecommerce_seller. All non-nullable fields required by onboarding/compliance, all nullable fields treated per business logic. Properties rigorously match columns in ai_ecommerce_seller_business_profiles schema."
    },
    "IAiEcommerceSellerBusinessProfile.ICreate": {
      "type": "object",
      "properties": {
        "seller_id": {
          "type": "string",
          "format": "uuid",
          "description": "Seller UUID for whom the business profile is created. Must reference an existing seller record. Required.\n\nReference: seller_id in ai_ecommerce_seller_business_profiles."
        },
        "business_name": {
          "type": "string",
          "description": "Officially registered company name. Required for business onboarding. Must be unique for this seller.\n\nReference: business_name in ai_ecommerce_seller_business_profiles."
        },
        "business_registration_number": {
          "type": "string",
          "description": "Unique business registration/certification number issued by the government. Required. Must remain unique for business profile CRUD.\n\nReference: business_registration_number in ai_ecommerce_seller_business_profiles."
        },
        "tax_id": {
          "oneOf": [
            {
              "type": "string",
              "description": "Government-issued tax identification (nullable, depending on local/global compliance). Optional at onboarding; must match business certificates.\n\nReference: tax_id in ai_ecommerce_seller_business_profiles."
            },
            {
              "type": "null",
              "description": "Government-issued tax identification (nullable, depending on local/global compliance). Optional at onboarding; must match business certificates.\n\nReference: tax_id in ai_ecommerce_seller_business_profiles."
            }
          ],
          "description": "Government-issued tax identification (nullable, depending on local/global compliance). Optional at onboarding; must match business certificates.\n\nReference: tax_id in ai_ecommerce_seller_business_profiles."
        },
        "contact_name": {
          "type": "string",
          "description": "Point of contact for the business—typically a staff or owner name. Mandatory for onboarding/contact.\n\nReference: contact_name in ai_ecommerce_seller_business_profiles."
        },
        "contact_phone": {
          "type": "string",
          "description": "Phone number for business contact. Must be validated and normalized. Required for approval processes.\n\nReference: contact_phone in ai_ecommerce_seller_business_profiles."
        },
        "contact_email": {
          "type": "string",
          "description": "Business-specific contact email for onboarding communications. Not user private email; must pass business validation. Required.\n\nReference: contact_email in ai_ecommerce_seller_business_profiles."
        },
        "address_line1": {
          "type": "string",
          "description": "First/main address line for business office or headquarters. Required at registration. Used for location verification.\n\nReference: address_line1 in ai_ecommerce_seller_business_profiles."
        },
        "address_line2": {
          "oneOf": [
            {
              "type": "string",
              "description": "Second address line for business, unit/floor, optional at onboarding. Used for address completeness during compliance.\n\nReference: address_line2 in ai_ecommerce_seller_business_profiles."
            },
            {
              "type": "null",
              "description": "Second address line for business, unit/floor, optional at onboarding. Used for address completeness during compliance.\n\nReference: address_line2 in ai_ecommerce_seller_business_profiles."
            }
          ],
          "description": "Second address line for business, unit/floor, optional at onboarding. Used for address completeness during compliance.\n\nReference: address_line2 in ai_ecommerce_seller_business_profiles."
        },
        "city": {
          "type": "string",
          "description": "Business city/region. Required for registration/audit.\n\nReference: city in ai_ecommerce_seller_business_profiles."
        },
        "state": {
          "type": "string",
          "description": "State/province/region for legal certification, used in address normalization and regulatory filings. Required.\n\nReference: state in ai_ecommerce_seller_business_profiles."
        },
        "postal_code": {
          "type": "string",
          "description": "Postal or ZIP code for address validation, delivery, and onboarding. Required.\n\nReference: postal_code in ai_ecommerce_seller_business_profiles."
        },
        "country": {
          "type": "string",
          "description": "Country for compliance/registration. Use ISO code or country full name for onboarding. Required.\n\nReference: country in ai_ecommerce_seller_business_profiles."
        }
      },
      "required": [
        "seller_id",
        "business_name",
        "business_registration_number",
        "contact_name",
        "contact_phone",
        "contact_email",
        "address_line1",
        "city",
        "state",
        "postal_code",
        "country"
      ],
      "description": "Creation DTO for onboarding a seller's business profile. All non-nullable onboarding/compliance fields are required per ai_ecommerce_seller_business_profiles schema documentation. The structure must exactly match the onboarding form presented to the seller or admin."
    },
    "IAiEcommerceSellerBusinessProfile.IUpdate": {
      "type": "object",
      "properties": {
        "business_name": {
          "type": "string",
          "description": "Business/company name update for onboarding edits or compliance correction. Must not conflict with any other in-seller business name.\n\nReference: business_name in ai_ecommerce_seller_business_profiles."
        },
        "business_registration_number": {
          "type": "string",
          "description": "Business registration number update, used in compliance rectification. Must remain unique. Edits strictly limited by policy.\n\nReference: business_registration_number in ai_ecommerce_seller_business_profiles."
        },
        "tax_id": {
          "oneOf": [
            {
              "type": "string",
              "description": "Tax ID updating, supporting optional rectification during post-onboard compliance. Nullable.\n\nReference: tax_id in ai_ecommerce_seller_business_profiles."
            },
            {
              "type": "null",
              "description": "Tax ID updating, supporting optional rectification during post-onboard compliance. Nullable.\n\nReference: tax_id in ai_ecommerce_seller_business_profiles."
            }
          ],
          "description": "Tax ID updating, supporting optional rectification during post-onboard compliance. Nullable.\n\nReference: tax_id in ai_ecommerce_seller_business_profiles."
        },
        "contact_name": {
          "type": "string",
          "description": "Updated contact name for profile correction. Only allowed under regulated onboarding flows.\n\nReference: contact_name in ai_ecommerce_seller_business_profiles."
        },
        "contact_phone": {
          "type": "string",
          "description": "Updated business contact number for profile correction. May trigger revalidation. Must pass normalization checks.\n\nReference: contact_phone in ai_ecommerce_seller_business_profiles."
        },
        "contact_email": {
          "type": "string",
          "description": "Updated business email for regulatory correspondence or compliance fix. Must pass email validation.\n\nReference: contact_email in ai_ecommerce_seller_business_profiles."
        },
        "address_line1": {
          "type": "string",
          "description": "Updated primary address line for business. Used for compliance/physical audit.\n\nReference: address_line1 in ai_ecommerce_seller_business_profiles."
        },
        "address_line2": {
          "oneOf": [
            {
              "type": "string",
              "description": "Updated address second line for detailed location correction. Nullable as in onboarding.\n\nReference: address_line2 in ai_ecommerce_seller_business_profiles."
            },
            {
              "type": "null",
              "description": "Updated address second line for detailed location correction. Nullable as in onboarding.\n\nReference: address_line2 in ai_ecommerce_seller_business_profiles."
            }
          ],
          "description": "Updated address second line for detailed location correction. Nullable as in onboarding.\n\nReference: address_line2 in ai_ecommerce_seller_business_profiles."
        },
        "city": {
          "type": "string",
          "description": "Updated city field for compliance rectification.\n\nReference: city in ai_ecommerce_seller_business_profiles."
        },
        "state": {
          "type": "string",
          "description": "Updated state/province value for regulatory correspondence correction.\n\nReference: state in ai_ecommerce_seller_business_profiles."
        },
        "postal_code": {
          "type": "string",
          "description": "Updated postal code for onboarding compliance rectification.\n\nReference: postal_code in ai_ecommerce_seller_business_profiles."
        },
        "country": {
          "type": "string",
          "description": "Updated country value (ISO or name) for regulatory change/correction.\n\nReference: country in ai_ecommerce_seller_business_profiles."
        }
      },
      "required": [],
      "description": "DTO for updating seller business profile fields for compliance, onboarding rectification, or business data correction. All fields are optional and only those specified are changed. Only non-immutable profile fields are allowed to be modified based on ai_ecommerce_seller_business_profiles policy."
    },
    "IAiEcommerceSellerBusinessProfile.IDeleteResult": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "UUID of the deleted (soft) business profile for traceability. Always returned as confirmation.\n\nReference: id in ai_ecommerce_seller_business_profiles."
        },
        "deleted_at": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp (ISO8601) when the business profile was soft-deleted. Set by the compliance system. Returned for audit confirmation."
        }
      },
      "required": [
        "id",
        "deleted_at"
      ],
      "description": "Response DTO after a seller business profile is deleted (soft delete). Used for audit and compliance trace, notifies external handlers of actual row logical removal. Matched against deleted_at in ai_ecommerce_seller_business_profiles."
    },
    "Pageable.IAiEcommerceSellerOnboardingLogs.IRequest": {
      "type": "object",
      "properties": {
        "seller_id": {
          "type": "string",
          "format": "uuid",
          "description": "UUID of the seller whose onboarding logs are being requested. FK in ai_ecommerce_seller_onboarding_logs. Used for compliance and audit queries targeting a specific seller."
        },
        "business_profile_id": {
          "type": "string",
          "format": "uuid",
          "description": "UUID of the business profile associated with these onboarding logs. Used in onboarding compliance filtering and cross-referencing logs during seller onboarding review."
        },
        "administrator_id": {
          "type": "string",
          "format": "uuid",
          "description": "UUID of the administrator who performed the onboarding action, if set. Used to audit onboarding decisions and review admin activity."
        },
        "step": {
          "type": "string",
          "description": "Filter by workflow step (e.g., 'application_submitted', 'documents_received', 'manual_review', etc). Enables log searches by onboarding state."
        },
        "action": {
          "type": "string",
          "description": "Filter by nature of onboarding action (e.g., 'accepted', 'rejected', 'flagged', 'info_requested'). Used in compliance and workflow analysis."
        },
        "actor_type": {
          "type": "string",
          "description": "Actor type for onboarding log entries (e.g., 'system', 'administrator'). Useful for role-based filtering in onboarding pipelines."
        },
        "decision_state": {
          "type": "string",
          "description": "Status after onboarding action (e.g., 'pending', 'approved', 'rejected', 'escalated'). Used for retrieval of logs matching specific onboarding review outcomes."
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "Lower bound filter by created_at timestamp for log search. Used in compliance, timeline reviews, and onboarding analytics."
        },
        "page": {
          "type": "integer",
          "description": "Pagination: which page to retrieve.",
          "minimum": 1
        },
        "limit": {
          "type": "integer",
          "description": "Pagination: number of results per page.",
          "minimum": 1
        }
      },
      "required": [],
      "description": "Request DTO for paginated, filtered, and compliant queries of ai_ecommerce_seller_onboarding_logs. All fields are optional and correspond to columns in the onboarding log schema, supporting multi-condition audits, onboarding dashboard filters, and advanced admin review tools."
    },
    "Pageable.IAiEcommerceSellerOnboardingLogs": {
      "type": "object",
      "properties": {
        "pagination": {
          "$ref": "#/components/schemas/IPage.IPagination"
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/IAiEcommerceSellerOnboardingLog"
          },
          "description": "Paginated array of seller onboarding log detail records; each entry is an atomic event from ai_ecommerce_seller_onboarding_logs."
        }
      },
      "required": [
        "pagination",
        "data"
      ],
      "description": "Paginated container DTO for lists of ai_ecommerce_seller_onboarding_logs entries, containing audit-compliant timeline event records plus pagination information. Used for onboarding dashboard UIs, compliance event traceability, and operational reporting."
    },
    "IAiEcommerceSellerOnboardingLog": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "Primary key UUID for the seller onboarding log entry. Uniquely identifies onboarding workflow event for traceability and audit.\n\nReference: id in ai_ecommerce_seller_onboarding_logs."
        },
        "seller_id": {
          "type": "string",
          "format": "uuid",
          "description": "UUID linking the log event to the seller. FK to ai_ecommerce_sellers. Required for all onboarding action records.\n\nReference: seller_id in ai_ecommerce_seller_onboarding_logs."
        },
        "business_profile_id": {
          "type": "string",
          "format": "uuid",
          "description": "UUID linking this onboarding log to the seller's business profile. FK for compliance trace.\n\nReference: business_profile_id in ai_ecommerce_seller_onboarding_logs."
        },
        "administrator_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "UUID linking this log entry to the administrator who performed the onboarding action, if applicable. Nullable for system-generated entries.\n\nReference: administrator_id in ai_ecommerce_seller_onboarding_logs."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "UUID linking this log entry to the administrator who performed the onboarding action, if applicable. Nullable for system-generated entries.\n\nReference: administrator_id in ai_ecommerce_seller_onboarding_logs."
            }
          ],
          "description": "UUID linking this log entry to the administrator who performed the onboarding action, if applicable. Nullable for system-generated entries.\n\nReference: administrator_id in ai_ecommerce_seller_onboarding_logs."
        },
        "step": {
          "type": "string",
          "description": "Workflow step for onboarding (e.g., 'application_submitted', 'manual_review'). Must match onboarding policy enumeration.\n\nReference: step in ai_ecommerce_seller_onboarding_logs."
        },
        "action": {
          "type": "string",
          "description": "Nature of the onboarding action (e.g., 'accepted', 'rejected', 'flagged', 'info_requested'). Must match onboarding process logic.\n\nReference: action in ai_ecommerce_seller_onboarding_logs."
        },
        "actor_type": {
          "type": "string",
          "description": "Actor type for log entry ('system' or 'administrator'). Used for analytics/workflow audit.\n\nReference: actor_type in ai_ecommerce_seller_onboarding_logs."
        },
        "decision_state": {
          "type": "string",
          "description": "Status after onboarding action (e.g., 'pending', 'approved', 'rejected', 'escalated'). Enumerated in workflow policies.\n\nReference: decision_state in ai_ecommerce_seller_onboarding_logs."
        },
        "reason_detail": {
          "oneOf": [
            {
              "type": "string",
              "description": "Optional textual explanation for the onboarding action. Null if no further explanation.\n\nReference: reason_detail in ai_ecommerce_seller_onboarding_logs."
            },
            {
              "type": "null",
              "description": "Optional textual explanation for the onboarding action. Null if no further explanation.\n\nReference: reason_detail in ai_ecommerce_seller_onboarding_logs."
            }
          ],
          "description": "Optional textual explanation for the onboarding action. Null if no further explanation.\n\nReference: reason_detail in ai_ecommerce_seller_onboarding_logs."
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp (ISO8601) of the onboarding workflow/log event creation.\n\nReference: created_at in ai_ecommerce_seller_onboarding_logs."
        }
      },
      "required": [
        "id",
        "seller_id",
        "business_profile_id",
        "step",
        "action",
        "actor_type",
        "decision_state",
        "created_at"
      ],
      "description": "Detailed record of a single onboarding workflow event for a seller as defined in ai_ecommerce_seller_onboarding_logs, containing atomic workflow/audit information as required for onboarding, regulatory review, and compliance trace."
    },
    "IAiEcommerceSellerOnboardingLog.ICreate": {
      "type": "object",
      "properties": {
        "seller_id": {
          "type": "string",
          "format": "uuid",
          "description": "Seller UUID for which this onboarding log event is recorded. Must reference an existing seller. Required for linkage.\n\nReference: seller_id in ai_ecommerce_seller_onboarding_logs."
        },
        "business_profile_id": {
          "type": "string",
          "format": "uuid",
          "description": "Business profile UUID linked to this onboarding event. Ensures compliance trace to business onboarding docs. Required FK.\n\nReference: business_profile_id in ai_ecommerce_seller_onboarding_logs."
        },
        "administrator_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Administrator UUID performing this onboarding workflow step, if present. Null if generated by system/onboarding automation.\n\nReference: administrator_id in ai_ecommerce_seller_onboarding_logs."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Administrator UUID performing this onboarding workflow step, if present. Null if generated by system/onboarding automation.\n\nReference: administrator_id in ai_ecommerce_seller_onboarding_logs."
            }
          ],
          "description": "Administrator UUID performing this onboarding workflow step, if present. Null if generated by system/onboarding automation.\n\nReference: administrator_id in ai_ecommerce_seller_onboarding_logs."
        },
        "step": {
          "type": "string",
          "description": "Onboarding workflow step (e.g., 'documents_received','manual_review'). Enumeration as per process policy. Required.\n\nReference: step in ai_ecommerce_seller_onboarding_logs."
        },
        "action": {
          "type": "string",
          "description": "Onboarding action ('accepted','rejected','flagged','info_requested'). Required.\n\nReference: action in ai_ecommerce_seller_onboarding_logs."
        },
        "actor_type": {
          "type": "string",
          "description": "Actor type specifying if this log is due to 'system' or 'administrator' action. Required.\n\nReference: actor_type in ai_ecommerce_seller_onboarding_logs."
        },
        "decision_state": {
          "type": "string",
          "description": "Resulting onboarding status after this action (e.g., 'approved','rejected','pending'). Required.\n\nReference: decision_state in ai_ecommerce_seller_onboarding_logs."
        },
        "reason_detail": {
          "oneOf": [
            {
              "type": "string",
              "description": "Optional text for detailed rationale behind onboarding action. Null if not applicable.\n\nReference: reason_detail in ai_ecommerce_seller_onboarding_logs."
            },
            {
              "type": "null",
              "description": "Optional text for detailed rationale behind onboarding action. Null if not applicable.\n\nReference: reason_detail in ai_ecommerce_seller_onboarding_logs."
            }
          ],
          "description": "Optional text for detailed rationale behind onboarding action. Null if not applicable.\n\nReference: reason_detail in ai_ecommerce_seller_onboarding_logs."
        }
      },
      "required": [
        "seller_id",
        "business_profile_id",
        "step",
        "action",
        "actor_type",
        "decision_state"
      ],
      "description": "DTO for creation of a seller onboarding log event. Required fields align with ai_ecommerce_seller_onboarding_logs schema for traceability, workflow compliance, and audit. Only supplied fields are permitted; extra data is ignored by logic."
    },
    "IAiEcommerceSellerOnboardingLog.IUpdate": {
      "type": "object",
      "properties": {
        "step": {
          "type": "string",
          "description": "New onboarding workflow step (see process enumeration). Must match allowed values in ai_ecommerce_seller_onboarding_logs."
        },
        "action": {
          "type": "string",
          "description": "Updated onboarding action. Must follow business logic and compliance rules in ai_ecommerce_seller_onboarding_logs."
        },
        "actor_type": {
          "type": "string",
          "description": "Updated actor type, if changed by administrative process."
        },
        "decision_state": {
          "type": "string",
          "description": "Updated status after onboarding action (e.g., 'rejected','approved','escalated','pending'). Must match onboarding policy."
        },
        "reason_detail": {
          "oneOf": [
            {
              "type": "string",
              "description": "Optional new or updated rationale text. Null if not relevant."
            },
            {
              "type": "null",
              "description": "Optional new or updated rationale text. Null if not relevant."
            }
          ],
          "description": "Optional new or updated rationale text. Null if not relevant."
        }
      },
      "required": [],
      "description": "DTO for updating permissible non-immutable fields in an onboarding log workflow entry (ai_ecommerce_seller_onboarding_logs). All properties are optional—only updated fields need be supplied."
    },
    "IAiEcommerceSellerOnboardingLog.IDeleteResult": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "UUID of deleted (soft) onboarding log row for traceability. Confirmation field."
        },
        "deleted_at": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp (ISO8601) when onboarding log was deleted by system, returned for audit trail."
        }
      },
      "required": [
        "id",
        "deleted_at"
      ],
      "description": "Response DTO for confirming soft deletion of onboarding log events, providing traceable compliance information to audit systems."
    },
    "Pageable.IAiEcommerceSellerVerificationDocuments.IRequest": {
      "type": "object",
      "properties": {
        "page": {
          "type": "integer",
          "description": "The page number for pagination."
        },
        "limit": {
          "type": "integer",
          "description": "The number of results per page."
        },
        "seller_id": {
          "type": "string",
          "format": "uuid",
          "description": "Filter for seller's UUID."
        },
        "business_profile_id": {
          "type": "string",
          "format": "uuid",
          "description": "Filter for business profile UUID."
        },
        "document_type": {
          "type": "string",
          "description": "Filter for document type."
        },
        "verified_at_from": {
          "type": "string",
          "format": "date-time",
          "description": "Begin date for verified_at filtering."
        },
        "verified_at_to": {
          "type": "string",
          "format": "date-time",
          "description": "End date for verified_at filtering."
        }
      },
      "description": "Search and pagination request for seller verification documents.\n\nThis structure is used to request a page of seller verification document records, filtered by seller, business profile, document type, or verification status, and supports advanced queries on time ranges. Used by administrators and compliance officers for review and analytics.",
      "required": []
    },
    "Pageable.IAiEcommerceSellerVerificationDocuments": {
      "type": "object",
      "properties": {
        "total": {
          "type": "integer",
          "description": "Total number of matching records."
        },
        "page": {
          "type": "integer",
          "description": "Current page number."
        },
        "limit": {
          "type": "integer",
          "description": "Records per page."
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/IAiEcommerceSellerVerificationDocument"
          },
          "description": "Paged array of seller verification documents."
        }
      },
      "required": [
        "total",
        "page",
        "limit",
        "data"
      ],
      "description": "Paginated result for seller verification documents.\n\nReturned from endpoints delivering pages of verification document entries for sellers, filtered and sorted as needed."
    },
    "IAiEcommerceSellerVerificationDocument": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "Unique document ID."
        },
        "seller_id": {
          "type": "string",
          "format": "uuid",
          "description": "ID of the seller who submitted the document."
        },
        "business_profile_id": {
          "type": "string",
          "format": "uuid",
          "description": "Business profile linked to this document."
        },
        "document_type": {
          "type": "string",
          "description": "Document type (e.g. business_registration, tax_certificate, etc.)."
        },
        "document_file_url": {
          "type": "string",
          "description": "Full URI to the stored document file."
        },
        "issue_date": {
          "type": "string",
          "format": "date-time",
          "description": "Date the document was issued."
        },
        "expiry_date": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "Optional expiry date for the document."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "Optional expiry date for the document."
            }
          ],
          "description": "Optional expiry date for the document."
        },
        "verified_at": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "Timestamp when document was verified by admin."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "Timestamp when document was verified by admin."
            }
          ],
          "description": "Timestamp when document was verified by admin."
        },
        "deleted_at": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "If set, document is logically deleted."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "If set, document is logically deleted."
            }
          ],
          "description": "If set, document is logically deleted."
        }
      },
      "required": [
        "id",
        "seller_id",
        "business_profile_id",
        "document_type",
        "document_file_url",
        "issue_date"
      ],
      "description": "Represents an official seller verification or compliance document uploaded during onboarding or for compliance purposes.\n\nIncludes details such as document type, issuer, dates, file location, and verification status. Used in onboarding and compliance review workflows."
    },
    "IAiEcommerceSellerVerificationDocument.ICreate": {
      "type": "object",
      "properties": {
        "seller_id": {
          "type": "string",
          "format": "uuid",
          "description": "ID of the seller submitting the document."
        },
        "business_profile_id": {
          "type": "string",
          "format": "uuid",
          "description": "Linked business profile id."
        },
        "document_type": {
          "type": "string",
          "description": "Type of document being submitted (e.g., business_registration, tax_certificate)."
        },
        "document_file_url": {
          "type": "string",
          "description": "URI where the document file is stored."
        },
        "issue_date": {
          "type": "string",
          "format": "date-time",
          "description": "Document issue date."
        },
        "expiry_date": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "Optional document expiry date; null if not set."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "Optional document expiry date; null if not set."
            }
          ],
          "description": "Optional document expiry date; null if not set."
        }
      },
      "required": [
        "seller_id",
        "business_profile_id",
        "document_type",
        "document_file_url",
        "issue_date"
      ],
      "description": "Payload for creating a new seller verification document. Must specify all relevant identification and file details for onboarding or compliance."
    },
    "IAiEcommerceSellerVerificationDocument.IUpdate": {
      "type": "object",
      "properties": {
        "document_type": {
          "type": "string",
          "description": "Updated document type (optional)."
        },
        "document_file_url": {
          "type": "string",
          "description": "Updated document file URI."
        },
        "issue_date": {
          "type": "string",
          "format": "date-time",
          "description": "Updated issue date."
        },
        "expiry_date": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "Nullable updated expiry date."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "Nullable updated expiry date."
            }
          ],
          "description": "Nullable updated expiry date."
        },
        "verified_at": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "Timestamp when the document is verified by admin."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "Timestamp when the document is verified by admin."
            }
          ],
          "description": "Timestamp when the document is verified by admin."
        },
        "deleted_at": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "Soft delete timestamp, or null if active."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "Soft delete timestamp, or null if active."
            }
          ],
          "description": "Soft delete timestamp, or null if active."
        }
      },
      "description": "Request body for updating seller verification document metadata, used in onboarding or compliance workflows. Enables modification of properties such as document type, file URI, issue or expiry date, and verification status.",
      "required": []
    },
    "IAdminActionLog.IRequest": {
      "type": "object",
      "properties": {
        "page": {
          "type": "integer",
          "description": "Page number for log pagination."
        },
        "limit": {
          "type": "integer",
          "description": "Number of log records per page."
        },
        "administrator_id": {
          "type": "string",
          "format": "uuid",
          "description": "Filter logs by administrator UUID."
        },
        "role_id": {
          "type": "string",
          "format": "uuid",
          "description": "Filter logs by role UUID."
        },
        "seller_id": {
          "type": "string",
          "format": "uuid",
          "description": "Filter logs by related seller UUID."
        },
        "target_type": {
          "type": "string",
          "description": "Target type (e.g. user, seller, system_policy)."
        },
        "action_type": {
          "type": "string",
          "description": "Action type (e.g. role_grant, onboarding_approve, data_export, etc.)."
        },
        "status": {
          "type": "string",
          "description": "Optional status, may be used for custom status values or filtering."
        },
        "created_after": {
          "type": "string",
          "format": "date-time",
          "description": "Filter for logs created after this date."
        },
        "created_before": {
          "type": "string",
          "format": "date-time",
          "description": "Filter for logs created before this date."
        }
      },
      "description": "Search and paginate administrator action logs for compliance and incident investigation. Enables filtering and retrieving action log entries based on actor, target, event action, or timeframe.",
      "required": []
    },
    "IPageAdminActionLog": {
      "type": "object",
      "properties": {
        "total": {
          "type": "integer",
          "description": "Total log records matching criteria."
        },
        "page": {
          "type": "integer",
          "description": "Current page number."
        },
        "limit": {
          "type": "integer",
          "description": "Records per page."
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/IAdminActionLog"
          },
          "description": "Paged array of admin action log records."
        }
      },
      "required": [
        "total",
        "page",
        "limit",
        "data"
      ],
      "description": "Paged results for administrator action log searches. Used for compliance investigations and platform audits."
    },
    "IAdminActionLog": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "Unique log entry ID."
        },
        "administrator_id": {
          "type": "string",
          "format": "uuid",
          "description": "ID of the administrator who performed the action."
        },
        "role_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Role UUID for role actions."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Role UUID for role actions."
            }
          ],
          "description": "Role UUID for role actions."
        },
        "seller_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Related seller for the admin action (nullable)."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Related seller for the admin action (nullable)."
            }
          ],
          "description": "Related seller for the admin action (nullable)."
        },
        "target_type": {
          "type": "string",
          "description": "Subject of the admin action, e.g., user, seller, system_policy."
        },
        "target_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Target row/entity for the action if relevant."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Target row/entity for the action if relevant."
            }
          ],
          "description": "Target row/entity for the action if relevant."
        },
        "action_type": {
          "type": "string",
          "description": "Type of action taken, e.g., role_grant, data_export, onboarding_approve."
        },
        "action_detail": {
          "oneOf": [
            {
              "type": "string",
              "description": "Additional context or description for the action."
            },
            {
              "type": "null",
              "description": "Additional context or description for the action."
            }
          ],
          "description": "Additional context or description for the action."
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp of the action."
        }
      },
      "required": [
        "id",
        "administrator_id",
        "target_type",
        "action_type",
        "created_at"
      ],
      "description": "A record of a sensitive or configuration-changing administrator action performed on the system. Enables tracking and auditing of role, onboarding, privilege, or system/admin policy actions."
    },
    "IAdminActionLog.ICreate": {
      "type": "object",
      "properties": {
        "administrator_id": {
          "type": "string",
          "format": "uuid",
          "description": "Admin UUID performing the action."
        },
        "role_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Role affected by the action (nullable)."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Role affected by the action (nullable)."
            }
          ],
          "description": "Role affected by the action (nullable)."
        },
        "seller_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Seller affected by the action (optional)."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Seller affected by the action (optional)."
            }
          ],
          "description": "Seller affected by the action (optional)."
        },
        "target_type": {
          "type": "string",
          "description": "Target of the action, such as 'user', 'seller', 'system_policy'."
        },
        "target_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Entity acted on (nullable)."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Entity acted on (nullable)."
            }
          ],
          "description": "Entity acted on (nullable)."
        },
        "action_type": {
          "type": "string",
          "description": "Action performed, e.g., onboarding_approve, role_grant."
        },
        "action_detail": {
          "oneOf": [
            {
              "type": "string",
              "description": "Full explanation/context JSON or text."
            },
            {
              "type": "null",
              "description": "Full explanation/context JSON or text."
            }
          ],
          "description": "Full explanation/context JSON or text."
        }
      },
      "required": [
        "administrator_id",
        "target_type",
        "action_type"
      ],
      "description": "Payload to create a new administrator action log entry. Used in platform compliance and sensitive operations."
    },
    "IAdminActionLog.IUpdate": {
      "type": "object",
      "properties": {
        "action_detail": {
          "type": "string",
          "description": "Update the action detail/context."
        }
      },
      "description": "Update/patch request for admin action log, used for adding context or correction to an existing admin action record.",
      "required": []
    },
    "IRole.IRequest": {
      "type": "object",
      "properties": {
        "page": {
          "type": "integer",
          "description": "Page number for pagination."
        },
        "limit": {
          "type": "integer",
          "description": "Records per page."
        },
        "name": {
          "type": "string",
          "description": "Role name filter (supports partial match)."
        },
        "created_at_from": {
          "type": "string",
          "format": "date-time",
          "description": "Filter roles created after this date."
        },
        "created_at_to": {
          "type": "string",
          "format": "date-time",
          "description": "Filter roles created before this date."
        }
      },
      "description": "Filter, search, and paginate roles in the RBAC system. Used by admin role/privilege UI for audit, search, or configuration.",
      "required": []
    },
    "IPageRole": {
      "type": "object",
      "properties": {
        "total": {
          "type": "integer",
          "description": "Total number of matching roles."
        },
        "page": {
          "type": "integer",
          "description": "Current page number."
        },
        "limit": {
          "type": "integer",
          "description": "Records per page."
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/IRole"
          },
          "description": "Paged array of role records."
        }
      },
      "required": [
        "total",
        "page",
        "limit",
        "data"
      ],
      "description": "Paged results for role database table/entity. Used for admin views and privilege dashboards."
    },
    "IRole": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "고유 역할 식별자입니다. 시스템 내 RBAC 매핑 등에 사용됩니다.\n\nPrisma 스키마의 id 컬럼에 해당하며, 각 역할을 고유하게 구분합니다.\n"
        },
        "name": {
          "type": "string",
          "description": "역할 이름(예: 'administrator', 'seller' 등)입니다. RBAC 정책에 따라 고유하게 할당됩니다.\n\nPrisma 스키마에서 name 컬럼(고유값)입니다."
        },
        "description": {
          "oneOf": [
            {
              "type": "string",
              "description": "역할 설명입니다. 관리용, UI 등에서 표시되며, 비어있을 수 있습니다.\n\nPrisma의 description(옵션)에 해당합니다."
            },
            {
              "type": "null"
            }
          ],
          "description": "역할 설명입니다. 관리용, UI 등에서 표시되며, 비어있을 수 있습니다.\n\nPrisma의 description(옵션)에 해당합니다."
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "역할 생성 시각입니다. 시스템의 생성 시점 감사 및 변경 이력에 사용됩니다.\n\nPrisma 스키마의 created_at 컬럼(타임스탬프)입니다."
        },
        "updated_at": {
          "type": "string",
          "format": "date-time",
          "description": "마지막 역할 정보 수정 시각입니다. 변경 이력 감사, UI 최신화 등을 위함입니다.\n\nPrisma 스키마의 updated_at 컬럼(타임스탬프)입니다."
        }
      },
      "required": [
        "id",
        "name",
        "created_at",
        "updated_at"
      ],
      "description": "역할(RBAC) 엔터티를 정의합니다. 권한 관리를 위한 논리적 그룹(예: admin, seller 등)으로, 시스템 관리자에 의해 관리됩니다.\n\nPrisma schema의 ai_ecommerce_roles 및 그 description, 컬럼 정의에 기반합니다. 모든 속성은 역할의 관리, 감사, 정책 위임, UI 표시와 연관이 있습니다.\n"
    },
    "IRole.ICreate": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "생성할 역할 이름입니다. 시스템에서 고유해야 하며, RBAC 정책/관리 콘솔에서 사용됩니다."
        },
        "description": {
          "oneOf": [
            {
              "type": "string",
              "description": "역할의 설명입니다. 관리 측면, UI, 정책 안내에 표시될 수 있습니다."
            },
            {
              "type": "null"
            }
          ],
          "description": "역할의 설명입니다. 관리 측면, UI, 정책 안내에 표시될 수 있습니다."
        }
      },
      "required": [
        "name"
      ],
      "description": "역할 신규 등록(request body)용 DTO입니다.\n\nname은 고유값이어야 하며, description은 옵션입니다. Prisma의 ai_ecommerce_roles 생성규칙에 맞춰 설계됩니다.\n"
    },
    "IRole.IUpdate": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "수정할 역할 이름입니다. 중복 불가. 역할 명칭 변경시에 사용합니다."
        },
        "description": {
          "oneOf": [
            {
              "type": "string",
              "description": "설명 수정값. UI 및 정책에 따라 업데이트합니다."
            },
            {
              "type": "null"
            }
          ],
          "description": "설명 수정값. UI 및 정책에 따라 업데이트합니다."
        }
      },
      "required": [],
      "description": "역할 정보 수정(request body) DTO입니다. name, description만 변경 가능.\n\nPrisma의 ai_ecommerce_roles 컬럼 정책과 일치합니다."
    },
    "ai_ecommerce_permission.IRequest": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "권한 명칭(검색용). RBAC 권한 정책 조회/검색에 사용됩니다.\n\nPrisma의 name 컬럼 규칙과 같습니다."
        },
        "description": {
          "oneOf": [
            {
              "type": "string",
              "description": "권한 설명(검색/필터에 사용, 옵션).\n\nPrisma의 description 컬럼 정책과 부합합니다."
            },
            {
              "type": "null"
            }
          ],
          "description": "권한 설명(검색/필터에 사용, 옵션).\n\nPrisma의 description 컬럼 정책과 부합합니다."
        }
      },
      "required": [],
      "description": "권한(Permission) 리스트 조회용 필터/검색 요청 DTO입니다.\n\nai_ecommerce_permissions 테이블 구조와 RBAC 정책 검색 요구를 반영합니다."
    },
    "IPageai_ecommerce_permission": {
      "type": "object",
      "properties": {
        "pagination": {
          "$ref": "#/components/schemas/IPage.IPagination",
          "description": "페이지네이션 정보. 표준 IPage 구조(generic)와 동일.\n"
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/ai_ecommerce_permission"
          },
          "description": "현재 페이지에 포함된 권한(permission) 레코드들의 배열입니다.\n"
        }
      },
      "required": [
        "pagination",
        "data"
      ],
      "description": "권한(Permission) 목록의 페이지네이션 컨테이너입니다. 표준 IPage 규약을 따릅니다.\n"
    },
    "ai_ecommerce_permission": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "권한(Permission)의 고유 식별자(primary key). RBAC 정책 적용 및 관리, 참조에 사용.\n\nPrisma의 ai_ecommerce_permissions - id 컬럼 책임."
        },
        "name": {
          "type": "string",
          "description": "권한 이름. 고유하며 RBAC 정책의 행위를 구분합니다.\n\nPrisma 스키마의 name 컬럼(고유) 설명 참고."
        },
        "description": {
          "oneOf": [
            {
              "type": "string",
              "description": "권한에 대한 한글/설명/정책 설명 필드. UI, 감사지원, 정책 매핑 시 노출됨.\n\nPrisma의 description 컬럼 정책 반영."
            },
            {
              "type": "null"
            }
          ],
          "description": "권한에 대한 한글/설명/정책 설명 필드. UI, 감사지원, 정책 매핑 시 노출됨.\n\nPrisma의 description 컬럼 정책 반영."
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "권한(Permission) 생성 시각. RBAC 행위 권한의 이력 감사/관리 목적.\n\nPrisma 컬럼: created_at"
        }
      },
      "required": [
        "id",
        "name",
        "created_at"
      ],
      "description": "권한(Permission) 엔터티의 표준 정의입니다. RBAC 인증/인가/감사에서 사용하며, 모든 컬럼은 Prisma schema와 일치합니다.\n"
    },
    "ai_ecommerce_permission.ICreate": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "생성할 권한 이름입니다. RBAC 정책의 고유 key, 필수."
        },
        "description": {
          "oneOf": [
            {
              "type": "string",
              "description": "권한 설명(추가 정보용). 옵션."
            },
            {
              "type": "null"
            }
          ],
          "description": "권한 설명(추가 정보용). 옵션."
        }
      },
      "required": [
        "name"
      ],
      "description": "권한 신규 생성(request body) DTO. name 필수.\n\nPrisma ai_ecommerce_permissions 테이블 생성 business logic 반영."
    },
    "ai_ecommerce_permission.IUpdate": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "변경 대상 권한 name(고유값)."
        }
      },
      "description": "권한 정보 수정용 DTO. 변경 시 고유성을 유지하도록 정책 반영.",
      "required": []
    },
    "ai_ecommerce_permission.IDeleteResult": {
      "type": "object",
      "properties": {
        "success": {
          "type": "boolean",
          "description": "삭제 성공 여부.\n"
        },
        "message": {
          "type": "string",
          "description": "상세 결과 설명. 실패시 원인 또는 성공시 상태 메시지.\n"
        }
      },
      "required": [
        "success"
      ],
      "description": "권한 삭제/Delete API 응답 객체. 성공 여부, 상세 메시지를 제공합니다.\n"
    },
    "ai_ecommerce_product.IRequest": {
      "type": "object",
      "properties": {
        "title": {
          "type": "string",
          "description": "상품 제목(title) - 검색, 정렬 키. 부분 일치 검색 등에 사용\n\n(Prisma: title)"
        },
        "seller_id": {
          "type": "string",
          "format": "uuid",
          "description": "상품 등록자(판매자) id. 매장별, 셀러별 filtering 용\n\n(Prisma: seller_id)"
        },
        "status": {
          "type": "string",
          "description": "상품 상태('published','draft' 등). 필터/검색의 주요 조건.\n\n(Prisma: status 컬럼)"
        },
        "approval_state": {
          "type": "string",
          "description": "승인/심사 상태값. compliance 관리용. (예: 'approved','pending' 등)\n\nPrisma: approval_state"
        },
        "created_from": {
          "type": "string",
          "format": "date-time",
          "description": "등록일/범위 필터. 시작 일자\n"
        },
        "created_to": {
          "type": "string",
          "format": "date-time",
          "description": "등록일/범위 필터. 종료 일자\n"
        }
      },
      "required": [],
      "description": "상품 리스트/검색 요청(body) DTO. ai_ecommerce_products 내 atomic 정규화된 필드 기준 설계.\n"
    },
    "IPageai_ecommerce_product": {
      "type": "object",
      "properties": {
        "pagination": {
          "$ref": "#/components/schemas/IPage.IPagination",
          "description": "페이지네이션 정보. 표준 IPage 규약, 상품 페이지 결과용.\n"
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/ai_ecommerce_product"
          },
          "description": "페이지에 속한 상품 ai_ecommerce_product 레코드들의 배열"
        }
      },
      "required": [
        "pagination",
        "data"
      ],
      "description": "상품(ai_ecommerce_product) 목록 페이지네이션 컨테이너. 표준 IPage 패턴(structure) 적용.\n"
    },
    "ai_ecommerce_product": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "상품 고유 식별자(Prisma: id). cross-entity 참조, 상품 상세, 연동 등에 활용됨."
        },
        "seller_id": {
          "type": "string",
          "format": "uuid",
          "description": "상품 소유 셀러/등록자(외래키). 관리, RBAC, seller별 filtering 용.\n\nPrisma: seller_id"
        },
        "title": {
          "type": "string",
          "description": "상품 타이틀/이름. customer-facing. 필수.\n\nPrisma: title"
        },
        "description": {
          "type": "string",
          "description": "상품 설명(긴 텍스트, atomic, 다국어 옵션은 별도 참조). UI에도 사용됨.\n\nPrisma: description"
        },
        "status": {
          "type": "string",
          "description": "상품 상태. 상태별 워크플로우, 운영 리스팅 등에 활용.\n\nPrisma: status"
        },
        "approval_state": {
          "type": "string",
          "description": "상품 승인/심사 상태(프로세스). compliance/workflow에서 사용.\n\nPrisma: approval_state"
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "등록 시각. 감사 및 스냅샷, 정렬 기본값.\n\nPrisma: created_at"
        },
        "updated_at": {
          "type": "string",
          "format": "date-time",
          "description": "마지막 수정 시각. 변경이력, UI 표시에 활용.\n\nPrisma: updated_at"
        },
        "deleted_at": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "소프트 삭제 시각. null이면 사용가능, timestamp면 논리적 제거.\n\nPrisma: deleted_at"
            },
            {
              "type": "null"
            }
          ],
          "description": "소프트 삭제 시각. null이면 사용가능, timestamp면 논리적 제거.\n\nPrisma: deleted_at"
        }
      },
      "required": [
        "id",
        "seller_id",
        "title",
        "description",
        "status",
        "approval_state",
        "created_at",
        "updated_at"
      ],
      "description": "상품 개체 표준 DTO. 모든 필드/속성은 ai_ecommerce_products Prisma 테이블 컬럼 정의와 설명에 따른 실제 business/운영 표준 문서화.\n"
    },
    "ai_ecommerce_product.ICreate": {
      "type": "object",
      "properties": {
        "seller_id": {
          "type": "string",
          "format": "uuid",
          "description": "The UUID of the seller who owns this product. Implements strict foreign-key normalization and is required for all product creation as per the Prisma schema and business rules."
        },
        "title": {
          "type": "string",
          "description": "The product's display name. String value, required and unique per seller, must be human-friendly. Multilingual support is handled via related tables."
        },
        "description": {
          "type": "string",
          "description": "A detailed description providing information about the product. Long text, required. Multilingual variants handled externally."
        },
        "status": {
          "type": "string",
          "description": "Product lifecycle status (e.g., draft, pending, published, archived). Must be an atomic value, follows workflow state conventions enforced in application code."
        },
        "approval_state": {
          "type": "string",
          "description": "Compliance/approval state of the product, such as 'pending', 'approved', 'rejected'. Should match business workflow state machine."
        }
      },
      "required": [
        "seller_id",
        "title",
        "description",
        "status",
        "approval_state"
      ],
      "description": "Payload for creating a new product as per ai_ecommerce_product schema. Contains all required atomic fields for a new catalog item, strictly follows 3NF and business rules. For use by seller onboarding, admin dashboard, or programmatic product import."
    },
    "ai_ecommerce_product.IUpdate": {
      "type": "object",
      "properties": {
        "title": {
          "type": "string",
          "description": "(Optional) New title for the product. Subject to uniqueness per seller, must be human-friendly. Must follow multilingual conventions if application requires."
        },
        "description": {
          "type": "string",
          "description": "(Optional) Updated product description. Free-form, subject to length and business rules."
        },
        "status": {
          "type": "string",
          "description": "(Optional) New status for the product (draft, published, archived, etc). Value must align with allowed catalog workflow transitions."
        },
        "approval_state": {
          "type": "string",
          "description": "(Optional) Updated approval state. (pending, approved, rejected, etc)."
        }
      },
      "description": "Update structure for ai_ecommerce_product row. Permits optional modification of human-friendly fields and workflow lifecycles, following 3NF and product management best practices.",
      "required": []
    },
    "ai_ecommerce_product.IDeleteResult": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "UUID of the deleted product."
        },
        "deleted_at": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp when this product was marked as deleted (soft delete)."
        }
      },
      "required": [
        "id",
        "deleted_at"
      ],
      "description": "Standard confirmation/result payload for a deleted (soft) ai_ecommerce_product. Used for compliance, audit, and confirmation flows."
    },
    "ai_ecommerce_sku.IRequest": {
      "type": "object",
      "properties": {
        "product_id": {
          "type": "string",
          "format": "uuid",
          "description": "Optional filter. Return only SKUs for the specified product UUID."
        },
        "code": {
          "type": "string",
          "description": "Optional filter for SKU code (per product uniqueness is enforced in DB)."
        },
        "is_active": {
          "type": "boolean",
          "description": "Optional filter for active/inactive SKUs only."
        },
        "min_price": {
          "type": "number",
          "format": "double",
          "description": "Optional filter for SKUs at or above this price."
        },
        "max_price": {
          "type": "number",
          "format": "double",
          "description": "Optional filter for SKUs at or below this price."
        },
        "sort": {
          "type": "string",
          "description": "Field to sort SKUs by (e.g., 'price', 'created_at')."
        },
        "order": {
          "oneOf": [
            {
              "const": "asc",
              "description": "Sort order. Should be 'asc' or 'desc'."
            },
            {
              "const": "desc",
              "description": "Sort order. Should be 'asc' or 'desc'."
            }
          ],
          "description": "Sort order. Should be 'asc' or 'desc'."
        },
        "page": {
          "type": "integer",
          "description": "Page number for pagination. Default typically 1."
        },
        "limit": {
          "type": "integer",
          "description": "Records per page. Default typically 50-100."
        }
      },
      "description": "Filtering, sorting, and paginating request body for SKU listing/search endpoint, as per ai_ecommerce_sku PATCH operation.",
      "required": []
    },
    "IPageai_ecommerce_sku": {
      "type": "object",
      "properties": {
        "pagination": {
          "$ref": "#/components/schemas/IPage.IPagination"
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/ai_ecommerce_sku"
          }
        }
      },
      "required": [
        "pagination",
        "data"
      ],
      "description": "Paginated container result for lists of ai_ecommerce_sku records. Contains both pagination metadata and an array of SKU result objects."
    },
    "ai_ecommerce_sku": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "Primary key for SKU row. UUID for global uniqueness."
        },
        "product_id": {
          "type": "string",
          "format": "uuid",
          "description": "Product foreign key indicating to which product this SKU belongs."
        },
        "code": {
          "type": "string",
          "description": "SKU code, required, unique per product. For barcode/inventory reference."
        },
        "price": {
          "type": "number",
          "format": "double",
          "description": "Atomic price for this SKU, as double. No derived or aggregate values in schema."
        },
        "currency": {
          "type": "string",
          "description": "ISO 4217 currency code, e.g., 'USD', 'KRW', etc."
        },
        "is_active": {
          "type": "boolean",
          "description": "SKU active flag. True = orderable, false = unavailable for sale."
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "ISO 8601 timestamp for row creation."
        },
        "updated_at": {
          "type": "string",
          "format": "date-time",
          "description": "ISO 8601 timestamp for last update."
        }
      },
      "required": [
        "id",
        "product_id",
        "code",
        "price",
        "currency",
        "is_active",
        "created_at",
        "updated_at"
      ],
      "description": "Atomic sellable product variant (SKU) with all normalized fields, strictly as per ai_ecommerce_sku/schemas/DB model. Used throughout order, inventory, and catalog flows. For analytics/data transfer, use this as the main object reference. No embedded objects, only atomic references to other entities (e.g. product_id references ai_ecommerce_product)."
    },
    "ai_ecommerce_skus.ICreate": {
      "type": "object",
      "properties": {
        "product_id": {
          "type": "string",
          "format": "uuid",
          "description": "UUID reference to parent product for SKU. Required, validated on creation."
        },
        "code": {
          "type": "string",
          "description": "New SKU code (barcode or business code). Required, unique per product."
        },
        "price": {
          "type": "number",
          "format": "double",
          "description": "Set unit price for new SKU (atomic price only)."
        },
        "currency": {
          "type": "string",
          "description": "Currency code (e.g., 'KRW', 'USD'). Required."
        },
        "is_active": {
          "type": "boolean",
          "description": "Active flag for SKU (defaults true). Required."
        }
      },
      "required": [
        "product_id",
        "code",
        "price",
        "currency",
        "is_active"
      ],
      "description": "Payload for creating a new SKU entity for a catalog product. Ensures per-product uniqueness, referential integrity, and atomic business logic."
    },
    "ai_ecommerce_skus": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid"
        },
        "product_id": {
          "type": "string",
          "format": "uuid"
        },
        "code": {
          "type": "string"
        },
        "price": {
          "type": "number",
          "format": "double"
        },
        "currency": {
          "type": "string"
        },
        "is_active": {
          "type": "boolean"
        },
        "created_at": {
          "type": "string",
          "format": "date-time"
        },
        "updated_at": {
          "type": "string",
          "format": "date-time"
        }
      },
      "required": [
        "id",
        "product_id",
        "code",
        "price",
        "currency",
        "is_active",
        "created_at",
        "updated_at"
      ],
      "description": "Exact same as ai_ecommerce_sku; may be used as alternate schema for list or legacy API, included for compatibility."
    },
    "ai_ecommerce_skus.IUpdate": {
      "type": "object",
      "properties": {
        "code": {
          "type": "string",
          "description": "(Optional) New SKU code (must stay unique per product)."
        },
        "price": {
          "type": "number",
          "format": "double",
          "description": "(Optional) New price in currency units. If updating price, sets new atomic value."
        },
        "currency": {
          "type": "string",
          "description": "(Optional) New currency code (ISO 4217)."
        },
        "is_active": {
          "type": "boolean",
          "description": "(Optional) Set SKU as active/inactive for sale."
        }
      },
      "description": "Fields for updating an existing SKU. Must match atomic, normalized business structure. Only included fields are updated.",
      "required": []
    },
    "ai_ecommerce_categories.IRequest": {
      "type": "object",
      "properties": {
        "parent_id": {
          "type": "string",
          "format": "uuid",
          "description": "Optional filter to only fetch categories under this parent category (UUID)."
        },
        "name": {
          "type": "string",
          "description": "Optional fuzzy or exact filter for category name."
        },
        "created_before": {
          "type": "string",
          "format": "date-time",
          "description": "Optional filter: only return categories created before this ISO timestamp."
        },
        "created_after": {
          "type": "string",
          "format": "date-time",
          "description": "Optional filter: only return categories created after this ISO timestamp."
        },
        "sort": {
          "type": "string",
          "description": "Field to sort categories by (e.g., 'name', 'created_at')."
        },
        "order": {
          "oneOf": [
            {
              "const": "asc",
              "description": "Sort order ('asc' or 'desc')."
            },
            {
              "const": "desc",
              "description": "Sort order ('asc' or 'desc')."
            }
          ],
          "description": "Sort order ('asc' or 'desc')."
        },
        "page": {
          "type": "integer",
          "description": "Requested page number for pagination, starting from 1."
        },
        "limit": {
          "type": "integer",
          "description": "Number of records per page to return."
        }
      },
      "description": "Request body for PATCH search/filter endpoint for ai_ecommerce_categories (product category) entity. Supports hierarchical and attribute-based queries.",
      "required": []
    },
    "IPageai_ecommerce_categories": {
      "type": "object",
      "properties": {
        "pagination": {
          "$ref": "#/components/schemas/IPage.IPagination"
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/ai_ecommerce_categories"
          }
        }
      },
      "required": [
        "pagination",
        "data"
      ],
      "description": "Paginated response container for ai_ecommerce_categories entity, includes both pagination metadata and array of category records."
    },
    "ai_ecommerce_categories": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "Primary category key (UUID)."
        },
        "parent_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "UUID of parent category, null for root categories only."
            },
            {
              "type": "null"
            }
          ],
          "description": "UUID of parent category, null for root categories only."
        },
        "name": {
          "type": "string",
          "description": "Category name (unique under parent)."
        },
        "description": {
          "type": "string",
          "description": "Long description, used for context/help/navigation."
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp of category creation (ISO 8601)."
        },
        "updated_at": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp of category last update (ISO 8601)."
        }
      },
      "required": [
        "id",
        "name",
        "description",
        "created_at",
        "updated_at"
      ],
      "description": "Atomic product category node, supporting multi-level category taxonomies as defined in ai_ecommerce_categories, with normalized parent-child references."
    },
    "ai_ecommerce_categories.ICreate": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "The name of the category. Required. Must be unique for a given parent category. Example: 'AI-Enabled Devices'. [Prisma: Category Name] Defines the commercial label for this taxonomy node. Used for navigation, filtering, and product attribution.\n\nBusiness rules: Must be a concise, human-readable, and unique value within the scope of its parent category. Strictly an atomic field."
        },
        "description": {
          "type": "string",
          "description": "A human-readable description of the category's purpose or context. Example: 'Robotics/AI-powered hardware.' [Prisma: Description]\n\nUsed in admin UI, category help messages, and hierarchical display. Should give meaningful context to merchants and shoppers defining or choosing this category."
        },
        "parent_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Optional parent category id for organizing categories in a tree structure. May be null (for a root category node). [Prisma: Parent Category FK]\n\nAtomic FK. Supports nested categories (1:N tree). Must reference another category node if present."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Optional parent category id for organizing categories in a tree structure. May be null (for a root category node). [Prisma: Parent Category FK]\n\nAtomic FK. Supports nested categories (1:N tree). Must reference another category node if present."
            }
          ],
          "description": "Optional parent category id for organizing categories in a tree structure. May be null (for a root category node). [Prisma: Parent Category FK]\n\nAtomic FK. Supports nested categories (1:N tree). Must reference another category node if present."
        }
      },
      "required": [
        "name",
        "description"
      ],
      "description": "Request type for creating a product category entity (ai_ecommerce_categories table). Aligns with the product catalog taxonomy requirements. Properties must match the strict normalization in the DB schema: category name, description, and optional parent category FK.\n\nReferences: ai_ecommerce_categories Prisma model and ERD."
    },
    "ai_ecommerce_categories.IUpdate": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "The edited name for the category (see .ICreate for full description and constraints). Optional. If omitted, name remains unchanged."
        },
        "description": {
          "type": "string",
          "description": "Edited description for the category. Optional. If not provided, value is not updated."
        },
        "parent_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Updated parent id for this category (switch category node in tree). Null to set as root. Optional."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Updated parent id for this category (switch category node in tree). Null to set as root. Optional."
            }
          ],
          "description": "Updated parent id for this category (switch category node in tree). Null to set as root. Optional."
        }
      },
      "description": "Request type for updating a product category entity (ai_ecommerce_categories table). All properties are optional and only supplied fields are mutated. Strictly matches DB constraints: category name (unique under parent), description, parent_id tree logic.",
      "required": []
    },
    "ai_ecommerce_inventories.IRequest": {
      "type": "object",
      "properties": {
        "sku_id": {
          "type": "string",
          "format": "uuid",
          "description": "Search and filter by FK to SKU table (Inventory is per-SKU/location). Optional. If provided, filters inventory records for a specific SKU only. [Prisma: sku_id]"
        },
        "location": {
          "type": "string",
          "description": "Optional. Text filter for warehouse, fulfillment center, or storage location. [Prisma: location]"
        },
        "min_quantity_available": {
          "type": "integer",
          "description": "Min quantity filter for available stock (inclusive). Optional. Results limited to entries with at least this many in stock."
        },
        "max_quantity_available": {
          "type": "integer",
          "description": "Max quantity filter. Limits to inventories with available quantities up to this number."
        },
        "page": {
          "type": "integer",
          "description": "Page number for pagination, optional."
        },
        "limit": {
          "type": "integer",
          "description": "Number of records per page (max page size enforcement/optional)."
        }
      },
      "description": "Request type for searching/filtering inventory records. Used in admin/warehouse dashboards and fulfillment systems. Maps to ai_ecommerce_inventories. Supports advanced querying on SKU, location, available quantity, and pagination.\n\nReferences: ai_ecommerce_inventories Prisma model and ERD.",
      "required": []
    },
    "IPageai_ecommerce_inventories": {
      "type": "object",
      "properties": {
        "pagination": {
          "$ref": "#/components/schemas/IPage.IPagination",
          "description": "Page status/metadata for the result set, including current page, limit, total records, and total pages. Follows platform-wide pagination standards."
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/ai_ecommerce_inventories"
          },
          "description": "Array of inventory records (ai_ecommerce_inventories) on the current page. Each item is a normalized inventory entity row."
        }
      },
      "required": [
        "pagination",
        "data"
      ],
      "description": "Paginated result type for inventory search/list queries. Contains metadata about the page and array of results."
    },
    "ai_ecommerce_inventories": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "Primary unique identifier for the inventory record. [Prisma: id]\n\nRequired for targeting, mutation, or referencing this stock row."
        },
        "sku_id": {
          "type": "string",
          "format": "uuid",
          "description": "Foreign key to the corresponding SKU entity for which stock is tracked. (Product variant, atomic reference.) [Prisma: sku_id]"
        },
        "location": {
          "type": "string",
          "description": "Text label for physical warehouse, fulfillment center, bin, or locale. Must be atomic and unique per SKU. [Prisma: location]"
        },
        "quantity_available": {
          "type": "integer",
          "description": "Atomic count of in-stock, sellable quantity for this SKU/location. [Prisma: quantity_available]\n\nStrictly positive integer. No aggregate calculations (strict normalization)."
        },
        "quantity_reserved": {
          "type": "integer",
          "description": "Atomic count of units reserved (e.g., for pending orders, processing, or holds). [Prisma: quantity_reserved]"
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp for inventory row creation in UTC ISO8601 format. [Prisma: created_at]"
        },
        "updated_at": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp for most recent update of this inventory record. [Prisma: updated_at]"
        }
      },
      "required": [
        "id",
        "sku_id",
        "location",
        "quantity_available",
        "quantity_reserved",
        "created_at",
        "updated_at"
      ],
      "description": "Normalized inventory entity tracking per-SKU per-location stock. Strictly matches ai_ecommerce_inventories schema fields, supporting stock, warehouse, and fulfillment workflows. No aggregate logic, fully normalized. See ERD and DB documentation."
    },
    "ai_ecommerce_inventories.ICreate": {
      "type": "object",
      "properties": {
        "sku_id": {
          "type": "string",
          "format": "uuid",
          "description": "Foreign key to SKU entity to which this inventory count pertains. [Prisma: sku_id] Required."
        },
        "location": {
          "type": "string",
          "description": "Text label for warehouse, fulfillment center, or inventory location. [Prisma: location] Required."
        },
        "quantity_available": {
          "type": "integer",
          "description": "Initial count of sellable stock units in location (must be non-negative, business logic applies for zero/negative). [Prisma: quantity_available]"
        },
        "quantity_reserved": {
          "type": "integer",
          "description": "Atomic count of units held for reservation in this location. Optional, default 0 if not supplied. [Prisma: quantity_reserved]"
        }
      },
      "required": [
        "sku_id",
        "location",
        "quantity_available"
      ],
      "description": "Request type for creating a new inventory stock row (ai_ecommerce_inventories). Follows 3NF rules and business constraints, see Prisma model. Atomic for each SKU/location."
    },
    "ai_ecommerce_inventories.IUpdate": {
      "type": "object",
      "properties": {
        "location": {
          "type": "string",
          "description": "Optional. New location value to which this inventory record is reassigned (not always mutable in business logic)."
        },
        "quantity_available": {
          "type": "integer",
          "description": "Optional. Updated saleable stock count for the item/location."
        },
        "quantity_reserved": {
          "type": "integer",
          "description": "Optional. Updated reserved quantity. Null, not provided, or omitted means value is unchanged."
        }
      },
      "description": "Update type for ai_ecommerce_inventories. Allows update of mutable inventory attributes: location, available/reserved quantities. ID not included as it is the PK path param.",
      "required": []
    },
    "IAiEcommerceMedia.IRequest": {
      "type": "object",
      "properties": {
        "owner_id": {
          "type": "string",
          "format": "uuid",
          "description": "Optional UUID of the product/SKU/category owning this media asset. [Prisma: owner_id] Can be filtered for parent entity."
        },
        "owner_type": {
          "type": "string",
          "description": "Restricts media assets by associated entity type. E.g., 'product', 'sku', 'category'. [Prisma: owner_type]"
        },
        "media_type": {
          "type": "string",
          "description": "Optional. Filters by file/media MIME type (e.g., 'image/jpeg', 'video/mp4'). [Prisma: media_type]"
        },
        "language": {
          "type": "string",
          "description": "Optional language code (such as 'en', 'ko'), for filtering media by content localization [Prisma: language]"
        },
        "page": {
          "type": "integer",
          "description": "Pagination: which page number to retrieve."
        },
        "limit": {
          "type": "integer",
          "description": "Pagination control: maximum number of records per page."
        }
      },
      "description": "Request/search type for querying media assets. Supports entity linking, type filtering, MIME attributes, localization code, and pagination as per ai_ecommerce_media model.",
      "required": []
    },
    "IPageIAiEcommerceMedia": {
      "type": "object",
      "properties": {
        "pagination": {
          "$ref": "#/components/schemas/IPage.IPagination",
          "description": "Paging metadata for result navigation. Standard for all paginated system API returns."
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/IAiEcommerceMedia"
          },
          "description": "Array of ai_ecommerce_media objects contained on the returned page."
        }
      },
      "required": [
        "pagination",
        "data"
      ],
      "description": "Standard paginated wrapper for media asset query responses (array of records + pagination info)."
    },
    "IAiEcommerceMedia": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "Unique identifier for this media entry (PK, ai_ecommerce_media). [Prisma: id]"
        },
        "owner_id": {
          "type": "string",
          "format": "uuid",
          "description": "UUID reference to owning business object (product/SKU/category, determined by owner_type) [Prisma: owner_id]"
        },
        "owner_type": {
          "type": "string",
          "description": "Classification of owner entity (see product/SKU/category for enum, string enforced by business logic). [Prisma: owner_type]"
        },
        "uri": {
          "type": "string",
          "description": "URL or resource path to storage. Can be S3/GCS/CDN/HTTP. Enforced maximum length in DB. [Prisma: uri]"
        },
        "media_type": {
          "type": "string",
          "description": "RFC MIME type for file: image/png, video/mp4, etc. [Prisma: media_type]"
        },
        "language": {
          "oneOf": [
            {
              "type": "string",
              "description": "(Optional) ISO/language code for localization purposes, if media is localized. Null if not localized. [Prisma: language]"
            },
            {
              "type": "null",
              "description": "(Optional) ISO/language code for localization purposes, if media is localized. Null if not localized. [Prisma: language]"
            }
          ],
          "description": "(Optional) ISO/language code for localization purposes, if media is localized. Null if not localized. [Prisma: language]"
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp when the media entity was inserted (ISO 8601 format, UTC). [Prisma: created_at]"
        }
      },
      "required": [
        "id",
        "owner_id",
        "owner_type",
        "uri",
        "media_type",
        "created_at"
      ],
      "description": "Normalized media object for platform file/media attachment. Strictly matches ai_ecommerce_media DB fields for attachment, catalog, or UI. Use in all file- or asset-related APIs. No blobs or embedded content."
    },
    "IAiEcommerceMedia.ICreate": {
      "type": "object",
      "properties": {
        "owner_id": {
          "type": "string",
          "format": "uuid",
          "description": "UUID FK reference to associated business object (product/SKU/category). Mandatory. [Prisma: owner_id]"
        },
        "owner_type": {
          "type": "string",
          "description": "Type discriminator for owning entity (product, sku, category). String; constraints enforced in logic. [Prisma: owner_type]"
        },
        "uri": {
          "type": "string",
          "description": "Absolute/relative URL or file location, per media asset requirements. See [Prisma: uri]\n\nMust match CDN/GCS/S3 or localhost path conventions."
        },
        "media_type": {
          "type": "string",
          "description": "RFC-compliant MIME type specifying content encoding ('image/jpeg', etc). [Prisma: media_type]"
        },
        "language": {
          "oneOf": [
            {
              "type": "string",
              "description": "(Optional) Language code for localized media; null or omitted if not localized. [Prisma: language]"
            },
            {
              "type": "null",
              "description": "(Optional) Language code for localized media; null or omitted if not localized. [Prisma: language]"
            }
          ],
          "description": "(Optional) Language code for localized media; null or omitted if not localized. [Prisma: language]"
        }
      },
      "required": [
        "owner_id",
        "owner_type",
        "uri",
        "media_type"
      ],
      "description": "Input schema for registering/uploading new media asset. Strictly backend file/attachment asset registration (not file data itself). Required: owner_id/entity, type, URL, and media type per product/SKU/category."
    },
    "IAiEcommerceMedia.IUpdate": {
      "type": "object",
      "properties": {
        "owner_id": {
          "type": "string",
          "format": "uuid",
          "description": "Optional. If updating which entity owns this media file; rare in practice. [Prisma: owner_id]"
        },
        "owner_type": {
          "type": "string",
          "description": "Optional. If updating the owner type (rare). Must match entity types allowed. [Prisma: owner_type]"
        },
        "uri": {
          "type": "string",
          "description": "Optional. Update file location/path for this entity. [Prisma: uri]"
        },
        "media_type": {
          "type": "string",
          "description": "Optional. Update file type (MIME). Only allowed for migration; most business logic prohibits type update for compliance. [Prisma: media_type]"
        },
        "language": {
          "oneOf": [
            {
              "type": "string",
              "description": "Optional. Update language code or nullify for non-localized media. [Prisma: language]"
            },
            {
              "type": "null",
              "description": "Optional. Update language code or nullify for non-localized media. [Prisma: language]"
            }
          ],
          "description": "Optional. Update language code or nullify for non-localized media. [Prisma: language]"
        }
      },
      "description": "Input type for updating ai_ecommerce_media asset metadata. Only properties provided are updated; unchanged attributes are left as-is. Strict FK/compliance logic applies depending on asset/owner/usage.",
      "required": []
    },
    "IAiEcommerceProductOptions.IRequest": {
      "type": "object",
      "properties": {
        "product_id": {
          "type": "string",
          "format": "uuid",
          "description": "The UUID of the product to filter options for. If provided, only options belonging to this product will be included in search/filter results.\n\nReference: ai_ecommerce_product_options.product_id column."
        },
        "sku_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "(Optional) Filter by the SKU UUID. If included, only options specific to this SKU will be considered. Null means options that are not SKU-specific.\n\nReference: ai_ecommerce_product_options.sku_id column."
            },
            {
              "type": "null"
            }
          ],
          "description": "(Optional) Filter by the SKU UUID. If included, only options specific to this SKU will be considered. Null means options that are not SKU-specific.\n\nReference: ai_ecommerce_product_options.sku_id column."
        },
        "option_name": {
          "oneOf": [
            {
              "type": "string",
              "description": "(Optional) Filter for a specific product option name (e.g., 'Color', 'Size'). Null to include all option names.\n\nReference: ai_ecommerce_product_options.option_name field."
            },
            {
              "type": "null"
            }
          ],
          "description": "(Optional) Filter for a specific product option name (e.g., 'Color', 'Size'). Null to include all option names.\n\nReference: ai_ecommerce_product_options.option_name field."
        },
        "option_value": {
          "oneOf": [
            {
              "type": "string",
              "description": "(Optional) Filter for a specific value for the chosen option name. Null means include all values for matching name.\n\nReference: ai_ecommerce_product_options.option_value field."
            },
            {
              "type": "null"
            }
          ],
          "description": "(Optional) Filter for a specific value for the chosen option name. Null means include all values for matching name.\n\nReference: ai_ecommerce_product_options.option_value field."
        },
        "created_from": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "(Optional) Lower bound (RFC3339 date string) for option creation timestamp to filter options created on or after this date.\n\nReference: ai_ecommerce_product_options.created_at column."
            },
            {
              "type": "null"
            }
          ],
          "description": "(Optional) Lower bound (RFC3339 date string) for option creation timestamp to filter options created on or after this date.\n\nReference: ai_ecommerce_product_options.created_at column."
        },
        "created_to": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "(Optional) Upper bound (RFC3339 date string) for option creation timestamp to filter options created on or before this date.\n\nReference: ai_ecommerce_product_options.created_at column."
            },
            {
              "type": "null"
            }
          ],
          "description": "(Optional) Upper bound (RFC3339 date string) for option creation timestamp to filter options created on or before this date.\n\nReference: ai_ecommerce_product_options.created_at column."
        },
        "page": {
          "type": "integer",
          "format": "uint32",
          "minimum": 1,
          "description": "Page number for paginated results. Defaults to 1 if not provided.\n\nReference: Pagination information."
        },
        "limit": {
          "type": "integer",
          "format": "uint32",
          "minimum": 1,
          "maximum": 100,
          "description": "Result page size. Max 100 per page. Defaults to 20 if not supplied.\n\nReference: Typical limit for paged results."
        },
        "sort": {
          "oneOf": [
            {
              "type": "string",
              "description": "Optional sorting field, such as 'created_at', 'option_name', 'option_value'. Prefix with '-' for descending (e.g. '-created_at').\n\nReference: UI sorting choice for listing product options."
            },
            {
              "type": "null"
            }
          ],
          "description": "Optional sorting field, such as 'created_at', 'option_name', 'option_value'. Prefix with '-' for descending (e.g. '-created_at').\n\nReference: UI sorting choice for listing product options."
        }
      },
      "required": [
        "product_id"
      ],
      "description": "Request filter structure for listing/searching ai_ecommerce_product_options entries.\n\nReference: Used as request body in PATCH /ai_ecommerce/productOptions for filtering options by product, SKU, name, value, date, plus paging and sorting.\n\nAll field descriptions reference ai_ecommerce_product_options columns."
    },
    "IPageIAiEcommerceProductOptions": {
      "type": "object",
      "properties": {
        "pagination": {
          "$ref": "#/components/schemas/IPage.IPagination"
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/IAiEcommerceProductOptions"
          },
          "description": "Array of product option entity rows for this page."
        }
      },
      "required": [
        "pagination",
        "data"
      ],
      "description": "Paginated container structure for ai_ecommerce_product_options result sets.\n\nReferences: Used as the response body for PATCH /ai_ecommerce/productOptions.\n\nIncludes pagination info and an array of option objects."
    },
    "IAiEcommerceProductOptions": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "Primary key for the product option row.\n\nReference: ai_ecommerce_product_options.id"
        },
        "product_id": {
          "type": "string",
          "format": "uuid",
          "description": "Foreign key to the owning product.\n\nReference: ai_ecommerce_product_options.product_id"
        },
        "sku_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "(Optional) Foreign key to the associated SKU, if this option is scoped to a specific SKU.\n\nReference: ai_ecommerce_product_options.sku_id"
            },
            {
              "type": "null"
            }
          ],
          "description": "(Optional) Foreign key to the associated SKU, if this option is scoped to a specific SKU.\n\nReference: ai_ecommerce_product_options.sku_id"
        },
        "option_name": {
          "type": "string",
          "description": "Option name (e.g., color, size).\n\nReference: ai_ecommerce_product_options.option_name"
        },
        "option_value": {
          "type": "string",
          "description": "Option value (e.g., red, XL).\n\nReference: ai_ecommerce_product_options.option_value"
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp (RFC3339) when this option was created.\n\nReference: ai_ecommerce_product_options.created_at"
        }
      },
      "required": [
        "id",
        "product_id",
        "option_name",
        "option_value",
        "created_at"
      ],
      "description": "Atomic, normalized product option entity as defined in ai_ecommerce_product_options schema.\n\nAll fields reference ai_ecommerce_product_options columns."
    },
    "IAiEcommerceProductOptions.ICreate": {
      "type": "object",
      "properties": {
        "product_id": {
          "type": "string",
          "format": "uuid",
          "description": "Product for which to add the option (FK).\n\nReference: ai_ecommerce_product_options.product_id"
        },
        "sku_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "(Optional) Optionally link this row to a specific SKU if relevant.\n\nReference: ai_ecommerce_product_options.sku_id"
            },
            {
              "type": "null"
            }
          ],
          "description": "(Optional) Optionally link this row to a specific SKU if relevant.\n\nReference: ai_ecommerce_product_options.sku_id"
        },
        "option_name": {
          "type": "string",
          "description": "Name of the product option to add (required).\n\nReference: ai_ecommerce_product_options.option_name"
        },
        "option_value": {
          "type": "string",
          "description": "Atomic value of the option to insert (required).\n\nReference: ai_ecommerce_product_options.option_value"
        }
      },
      "required": [
        "product_id",
        "option_name",
        "option_value"
      ],
      "description": "Request payload to create a new product option row in ai_ecommerce_product_options.\n\nAll fields reference ai_ecommerce_product_options columns."
    },
    "IAiEcommerceProductOptions.IUpdate": {
      "type": "object",
      "properties": {
        "option_name": {
          "oneOf": [
            {
              "type": "string",
              "description": "(Optional) Update the option name."
            },
            {
              "type": "null"
            }
          ],
          "description": "(Optional) Update the option name."
        },
        "option_value": {
          "oneOf": [
            {
              "type": "string",
              "description": "(Optional) Update the option value."
            },
            {
              "type": "null"
            }
          ],
          "description": "(Optional) Update the option value."
        }
      },
      "required": [],
      "description": "Request payload to update a product option row in ai_ecommerce_product_options. Only option_name and option_value are permitted to change.\n\nReference: Used in PUT /ai_ecommerce/productOptions/{id}"
    },
    "IAiEcommerceProductComplianceRules.IRequest": {
      "type": "object",
      "properties": {
        "rule_name": {
          "oneOf": [
            {
              "type": "string",
              "description": "(Optional) Filter compliance rules by rule name.\n\nReference: ai_ecommerce_product_compliance_rules.rule_name"
            },
            {
              "type": "null"
            }
          ],
          "description": "(Optional) Filter compliance rules by rule name.\n\nReference: ai_ecommerce_product_compliance_rules.rule_name"
        },
        "description": {
          "oneOf": [
            {
              "type": "string",
              "description": "(Optional) Full-text filter/search for rule description.\n\nReference: ai_ecommerce_product_compliance_rules.description"
            },
            {
              "type": "null"
            }
          ],
          "description": "(Optional) Full-text filter/search for rule description.\n\nReference: ai_ecommerce_product_compliance_rules.description"
        },
        "created_from": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "(Optional) Created at lower bound for filtering by creation timestamp. RFC3339 format.\n\nReference: ai_ecommerce_product_compliance_rules.created_at"
            },
            {
              "type": "null"
            }
          ],
          "description": "(Optional) Created at lower bound for filtering by creation timestamp. RFC3339 format.\n\nReference: ai_ecommerce_product_compliance_rules.created_at"
        },
        "created_to": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "(Optional) Upper bound for filtering by creation timestamp. RFC3339 format.\n\nReference: ai_ecommerce_product_compliance_rules.created_at"
            },
            {
              "type": "null"
            }
          ],
          "description": "(Optional) Upper bound for filtering by creation timestamp. RFC3339 format.\n\nReference: ai_ecommerce_product_compliance_rules.created_at"
        },
        "page": {
          "type": "integer",
          "format": "uint32",
          "minimum": 1,
          "description": "Page number to retrieve. Defaults to 1."
        },
        "limit": {
          "type": "integer",
          "format": "uint32",
          "minimum": 1,
          "maximum": 100,
          "description": "Number of items per page. Max 100."
        },
        "sort": {
          "oneOf": [
            {
              "type": "string",
              "description": "Sort field: 'created_at', 'rule_name'. Descending with '-prefix'."
            },
            {
              "type": "null"
            }
          ],
          "description": "Sort field: 'created_at', 'rule_name'. Descending with '-prefix'."
        }
      },
      "required": [],
      "description": "Request object for searching/filtering/paginating ai_ecommerce_product_compliance_rules.\n\nReference: Used as PATCH /ai_ecommerce/productComplianceRules request body."
    },
    "IPageIAiEcommerceProductComplianceRules": {
      "type": "object",
      "properties": {
        "pagination": {
          "$ref": "#/components/schemas/IPage.IPagination"
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/ai_ecommerce_product_compliance_rules"
          },
          "description": "Array of compliance rule rows for this page."
        }
      },
      "required": [
        "pagination",
        "data"
      ],
      "description": "Paginated result set structure for ai_ecommerce_product_compliance_rules search/list endpoints.\n\nReference: Response for PATCH /ai_ecommerce/productComplianceRules."
    },
    "ai_ecommerce_product_compliance_rules": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "Primary key, unique id for the compliance rule row.\n\nReference: ai_ecommerce_product_compliance_rules.id"
        },
        "rule_name": {
          "type": "string",
          "description": "Canonical atomic name for the rule.\n\nReference: ai_ecommerce_product_compliance_rules.rule_name"
        },
        "description": {
          "type": "string",
          "description": "Detailed description of the rule, as stored in the table.\n\nReference: ai_ecommerce_product_compliance_rules.description"
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "Creation timestamp (RFC3339).\n\nReference: ai_ecommerce_product_compliance_rules.created_at"
        }
      },
      "required": [
        "id",
        "rule_name",
        "description",
        "created_at"
      ],
      "description": "Atomic, normalized compliance rule entity (ai_ecommerce_product_compliance_rules table).\n\nEvery property references a column in the ai_ecommerce_product_compliance_rules table."
    },
    "ai_ecommerce_product_compliance_rules.ICreate": {
      "type": "object",
      "properties": {
        "rule_name": {
          "type": "string",
          "description": "Canonical name for compliance rule to create. Must be unique.\n\nReference: ai_ecommerce_product_compliance_rules.rule_name"
        },
        "description": {
          "type": "string",
          "description": "Long-form explanation or description for this rule, as required for compliance teams and auditing workflows.\n\nReference: ai_ecommerce_product_compliance_rules.description"
        }
      },
      "required": [
        "rule_name",
        "description"
      ],
      "description": "Payload for creating a new compliance rule row in ai_ecommerce_product_compliance_rules.\n\nEach property references a normalized DB column."
    },
    "ai_ecommerce_product_compliance_rules.IUpdate": {
      "type": "object",
      "properties": {
        "rule_name": {
          "oneOf": [
            {
              "type": "string",
              "description": "Canonical name update (optional).\n\nReference: ai_ecommerce_product_compliance_rules.rule_name"
            },
            {
              "type": "null"
            }
          ],
          "description": "Canonical name update (optional).\n\nReference: ai_ecommerce_product_compliance_rules.rule_name"
        },
        "description": {
          "oneOf": [
            {
              "type": "string",
              "description": "Rule description update (optional).\n\nReference: ai_ecommerce_product_compliance_rules.description"
            },
            {
              "type": "null"
            }
          ],
          "description": "Rule description update (optional).\n\nReference: ai_ecommerce_product_compliance_rules.description"
        }
      },
      "required": [],
      "description": "Payload to update an existing compliance rule row in ai_ecommerce_product_compliance_rules.\n\nFields are optional; only include what should be changed."
    },
    "ai_ecommerce_product_compliance_rules.IDeleteResult": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "ID of the compliance rule that was deleted.\n\nReference: ai_ecommerce_product_compliance_rules.id"
        },
        "deleted": {
          "type": "boolean",
          "description": "True if deletion succeeded (soft or hard as dictated by business logic)."
        },
        "message": {
          "type": "string",
          "description": "Optional human-readable explanation or error message from the delete process."
        }
      },
      "required": [
        "id",
        "deleted"
      ],
      "description": "Standardized result object for delete confirmation for compliance rules.\n\nUsed in DELETE API response for /ai_ecommerce/productComplianceRules/{id}."
    },
    "ai_ecommerce_product_tags.IRequest": {
      "type": "object",
      "properties": {
        "name": {
          "oneOf": [
            {
              "type": "string",
              "description": "(Optional) Filter by tag name; performs exact or pattern search depending on implementation.\n\nReference: ai_ecommerce_product_tags.name."
            },
            {
              "type": "null"
            }
          ],
          "description": "(Optional) Filter by tag name; performs exact or pattern search depending on implementation.\n\nReference: ai_ecommerce_product_tags.name."
        },
        "created_from": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "(Optional) Lower bound for 'created_at' date. RFC3339 timestamp string.\n\nReference: ai_ecommerce_product_tags.created_at."
            },
            {
              "type": "null"
            }
          ],
          "description": "(Optional) Lower bound for 'created_at' date. RFC3339 timestamp string.\n\nReference: ai_ecommerce_product_tags.created_at."
        },
        "created_to": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "(Optional) Upper bound (before or on) for 'created_at'. RFC3339 timestamp string.\n\nReference: ai_ecommerce_product_tags.created_at."
            },
            {
              "type": "null"
            }
          ],
          "description": "(Optional) Upper bound (before or on) for 'created_at'. RFC3339 timestamp string.\n\nReference: ai_ecommerce_product_tags.created_at."
        },
        "sort": {
          "oneOf": [
            {
              "type": "string",
              "description": "Sort field: 'name', 'created_at'. Descending with '-' prefix."
            },
            {
              "type": "null"
            }
          ],
          "description": "Sort field: 'name', 'created_at'. Descending with '-' prefix."
        },
        "page": {
          "type": "integer",
          "format": "uint32",
          "minimum": 1,
          "description": "Request page number for pagination (default 1)."
        },
        "limit": {
          "type": "integer",
          "format": "uint32",
          "minimum": 1,
          "maximum": 100,
          "description": "Number of rows per page. Max 100 (default per implementation)."
        }
      },
      "required": [],
      "description": "Search/filter/pagination parameters for product tags (ai_ecommerce_product_tags) list endpoints.\n\nAll properties reference ai_ecommerce_product_tags columns."
    },
    "ai_ecommerce_product_tags.IPage": {
      "type": "object",
      "properties": {
        "total": {
          "type": "integer",
          "description": "총 레코드 수입니다.\n\n이 필드는 페이지네이션 시 전체 검색 결과의 행 개수를 명시적으로 제공합니다."
        },
        "page": {
          "type": "integer",
          "description": "현재 페이지 번호입니다.\n\n페이지네이션 요청에서 클라이언트가 지정한 page 값이 반영되어 있습니다. 0 또는 1부터 시작하며, 서버 정책에 따라 다를 수 있습니다."
        },
        "limit": {
          "type": "integer",
          "description": "한 페이지에 보여줄 최대 태그 레코드 수입니다.\n\n사용자가 리스트 요청 시 지정한 limit 파라미터의 값이 반영되어 있습니다. 기본값은 20 또는 50 등 정책에 따라 다릅니다."
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/ai_ecommerce_product_tags"
          },
          "description": "리스트 결과의 태그 엔터티 객체들의 배열입니다.\n\nai_ecommerce_product_tags 레코드들로 구성되어 있으며, 각 태그의 상세 정보가 담겨 있습니다."
        }
      },
      "required": [
        "total",
        "page",
        "limit",
        "data"
      ],
      "description": "상품 태그 리스트를 페이지네이션 형태로 제공합니다.\n\n이 타입은 ai_ecommerce_product_tags 엔터티 목록 및 페이지네이션 정보를 한 번에 제공합니다. 예를 들어 `/ai_ecommerce/productTags`의 결과로 사용되며, 페이지 숫자·리밋·전체 건수·실제 태그 데이터 배열을 모두 포함합니다. Prisma 스키마의 comments와 ERD의 태그 엔터티 구조를 그대로 반영하여, 태그 관리, 검색, 운영툴 등에서 활용됩니다.\n\n각 property의 정확한 역할과 데이터 타입, null 허용 여부 등은 Prisma 정의를 따릅니다."
    },
    "ai_ecommerce_product_tags": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "System-wide unique tag ID입니다.\n\n상품 태깅, 검색, 추천, 개인화 등에서 태그 식별자로 사용됩니다. Prisma ERD 주석에 따라 system 전체에서 PK/UK 성격을 가집니다."
        },
        "name": {
          "type": "string",
          "description": "비즈니스-캐노니컬 태그명입니다. 예: 'AI', 'Green', 'Gift Ideas'.\n\n제품/검색/분류/추천/분석 구간 모두에서 논리적으로 고유성이 보장됩니다. UK 인덱스가 걸려있으며, 유사·동일 태그 중복 등록이 불가하도록 관리됩니다."
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "태그 엔터티의 생성 시각을 ISO 8601 UTC 타임스탬프로 기록합니다.\n\n태그 라이프사이클 관리 및 분석, 신규 태그 발견 시점 추적 등에 사용됩니다."
        }
      },
      "required": [
        "id",
        "name",
        "created_at"
      ],
      "description": "상품 태그 엔터티를 나타내는 타입입니다.\n\nPrisma의 ai_ecommerce_product_tags 테이블 파생형으로, 각 태그별 PK, 비즈니스명, 생성 시각 필드 등을 포함합니다. 모든 속성은 개별적으로 설명 주석과 스키마 규약(예: UK, PK, null 불가 등)에 맞춰 모델링되어 있습니다.\n\n태그 기반 추천, 검색, 운영툴용 매핑 등 다양한 활용을 지원합니다."
    },
    "ai_ecommerce_product_tags.ICreate": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "신규 생성할 태그명입니다. 예: 'AI', 'Summer', 'Gift'.\n\nUK(고유값) 제약이 있어서, 이미 존재하는 태그와 동일한 값은 허용되지 않습니다.\n\nPrisma 스키마 명세에 따라, 생성 시 null 또는 공백은 허용되지 않으며 50자 이하 등 별도 제한이 있을 수 있습니다."
        }
      },
      "required": [
        "name"
      ],
      "description": "상품 태그 신규 생성용 요청 본문 타입입니다.\n\n클라이언트에서 태그 등록(POST) 시 보내는 데이터의 구조로, 반드시 name만 입력 가능하며, id/created_at 등은 응답에서 부여됩니다.\n\n중복 태그명 검증, 정책 기준에 맞는 name 값 보장 등 backend에서 제약을 구현해야 합니다."
    },
    "ai_ecommerce_product_tags.IUpdate": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "수정하고자 하는 태그명입니다.\n\n태그명이 변경될 경우 기존 name 인덱스(UK)에 맞춰 중복 체크가 이루어지며, 정책상 null/공백/기존태그와 동일값 등은 허용되지 않습니다."
        }
      },
      "required": [
        "name"
      ],
      "description": "기존 태그 레코드의 수정(이름변경) 요청에 사용되는 타입입니다.\n\nPUT/PATCH `/ai_ecommerce/productTags/{id}`의 body로 사용합니다.\n\nname 필드는 태그명 내 중복 금지(UK), 정책상 null/공백 불가 등 제약조건이 backend에서 관리되며, 입력값은 프론트엔드/운영툴에서 validation 처리 필요합니다."
    },
    "ai_ecommerce_product_tags.IDeleteResult": {
      "type": "object",
      "properties": {
        "success": {
          "type": "boolean",
          "description": "삭제 결과 성공 여부. true이면 정상 삭제, false는 실패/제약 미충족/존재하지 않음 등 의미입니다."
        },
        "deletedId": {
          "type": "string",
          "format": "uuid",
          "description": "실제 삭제된(soft/hard) 태그의 uuid입니다.\n\n삭제 대상이 없으면 null 반환(선택적)."
        }
      },
      "required": [
        "success"
      ],
      "description": "상품 태그 삭제 결과를 반환하는 타입입니다.\n\n삭제(soft/hard) 수행 결과, 정상 처리 여부와 실제 삭제된 태그 uuid(실패면 null 또는 undefined)를 제공합니다.\n\n일괄 삭제/복원 API 대비 단일 엔터티 삭제 결과 반환 시 활용합니다."
    },
    "ai_ecommerce_inquiry.IRequest": {
      "type": "object",
      "properties": {
        "customer_id": {
          "type": "string",
          "format": "uuid",
          "description": "검색할 문의 작성자(customer) UUID입니다. 특정 고객의 문의만 조회하는 경우 지정합니다."
        },
        "product_id": {
          "type": "string",
          "format": "uuid",
          "description": "조회할 상품의 UUID입니다. 상품별 문의 필터링에 사용합니다."
        },
        "order_id": {
          "type": "string",
          "format": "uuid",
          "description": "주문 관련 문의만 찾고 싶을 때 해당 order UUID 지정(선택적)."
        },
        "title": {
          "type": "string",
          "description": "문의 제목 키워드 검색 시 사용되는 필드입니다.\n\n부분 일치 검색·전문검색(예: '환불', '배송') 등에 활용됩니다."
        },
        "status": {
          "type": "string",
          "description": "문의의 상태(예: 'open', 'closed', 'pending', 등)를 필터링하기 위한 값입니다. 허용되는 상태는 운영 정책 또는 enum으로 제약합니다."
        },
        "created_from": {
          "type": "string",
          "format": "date-time",
          "description": "문의 등록일 범위(from) - ISO 8601 날짜\n\n특정 기간 내 문의 조회 조건을 제공할 때 사용됨."
        },
        "created_to": {
          "type": "string",
          "format": "date-time",
          "description": "문의 등록일 범위(to) - ISO 8601 날짜"
        },
        "is_private": {
          "type": "boolean",
          "description": "비공개 문의 필터링 여부(옵션). true로 설정하면 비공개만, false면 공개 문의만, undefined일 경우 모두."
        },
        "page": {
          "type": "integer",
          "description": "페이지 번호(0 or 1부터 시작, 요청 정책에 따름)"
        },
        "limit": {
          "type": "integer",
          "description": "페이지당 최대 항목 수, 정책에 따라 10/20/50 등 선택 가능"
        }
      },
      "required": [
        "page",
        "limit"
      ],
      "description": "상품/주문 문의 리스트 검색/필터/페이지 요청 파라미터 DTO입니다.\n\nPrisma의 ai_ecommerce_inquiry 테이블 기반으로 작성된 DTO로, 고객, 상품, 주문, 기간, 상태 등 다양한 조건 검색 시 이용됩니다. 페이지네이션 파라미터(page, limit)는 반드시 포함해야 하며, 나머지 필드는 선택적(필터링 목적)로 활용합니다."
    },
    "ai_ecommerce_inquiry.IPage": {
      "type": "object",
      "properties": {
        "total": {
          "type": "integer",
          "description": "전체 검색 결과 건수\n\n페이지네이션 처리를 위한 전체 카운트 반환용"
        },
        "page": {
          "type": "integer",
          "description": "현재 페이지 번호"
        },
        "limit": {
          "type": "integer",
          "description": "페이지당 최대 항목수"
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/ai_ecommerce_inquiry"
          },
          "description": "검색에 부합하는 ai_ecommerce_inquiry 엔티티 배열"
        }
      },
      "required": [
        "total",
        "page",
        "limit",
        "data"
      ],
      "description": "문의 검색/리스트 응답용 페이징 컨테이너.\n\nPrisma의 ai_ecommerce_inquiry 엔티티 및 페이지네이션 정보를 반환합니다."
    },
    "ai_ecommerce_inquiry": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "문의 엔트리의 고유 식별자 (PK, UUID)\n\n각 inquiry는 이 ID로 추적/조회됩니다."
        },
        "customer_id": {
          "type": "string",
          "format": "uuid",
          "description": "작성 고객 UUID (ai_ecommerce_customer PK 참조)\n\n문의의 소유자/작성자 식별에 주로 쓰입니다."
        },
        "product_id": {
          "type": "string",
          "format": "uuid",
          "description": "문의 대상 상품 UUID\n\n관련 상품 상세 및 문의필터링에 사용됩니다."
        },
        "order_id": {
          "type": "string",
          "format": "uuid",
          "description": "주문 관련 문의일 경우 주문 UUID 참조 (nullable)\n\n상품 문의만 있으면 null이 됨"
        },
        "title": {
          "type": "string",
          "description": "문의 제목\n\nUI 및 검색에서 중요한 키워드 필드입니다."
        },
        "body": {
          "type": "string",
          "description": "문의 본문/내용 (필수)\n\n실제 질문, 요청, 불만사항 상세 등이 이 필드에 담깁니다."
        },
        "status": {
          "type": "string",
          "description": "문의 상태 (예: 'open', 'closed', 'pending' 등 운영정책 기준)\n\n진행중/종료/미처리/답변완료 등 다양한 workflow 상태를 기록합니다."
        },
        "is_private": {
          "type": "boolean",
          "description": "비공개 문의 여부\n\ntrue면 비공개, false면 공개 문의임을 뜻합니다."
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "등록 시각(UTC, ISO 8601)\n\n문의 생성 일시를 기록합니다."
        },
        "updated_at": {
          "type": "string",
          "format": "date-time",
          "description": "마지막 변경 시각(ISO 8601)"
        },
        "deleted_at": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "소프트 삭제된 경우의 삭제 시각(ISO8601, null일 경우 활성 상태)"
            },
            {
              "type": "null"
            }
          ],
          "description": "소프트 삭제된 경우의 삭제 시각(ISO8601, null일 경우 활성 상태)"
        }
      },
      "required": [
        "id",
        "customer_id",
        "product_id",
        "title",
        "body",
        "status",
        "is_private",
        "created_at",
        "updated_at"
      ],
      "description": "상품/주문 문의 엔티티 레코드 스키마.\n\nai_ecommerce_inquiry 테이블의 단일 row를 나타냅니다. 문의의 주요 속성 및 상태 정보, 관련 FK, 타임스탬프 등을 전부 표현합니다. deleted_at은 소프트삭제 시 활용됩니다. 본문 body 등은 긴 텍스트를 허용합니다."
    },
    "ai_ecommerce_inquiry.ICreate": {
      "type": "object",
      "properties": {
        "customer_id": {
          "type": "string",
          "format": "uuid",
          "description": "작성 고객(로그인 세션 기준) UUID\n\n필수(문의는 반드시 고객이 로그인을 해야 하므로 반드시 입력됨)"
        },
        "product_id": {
          "type": "string",
          "format": "uuid",
          "description": "문의 대상 상품 UUID (필수)"
        },
        "order_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "주문 관련 추가문의의 경우 주문 UUID, 상품 문의만 있다면 null."
            },
            {
              "type": "null"
            }
          ],
          "description": "주문 관련 추가문의의 경우 주문 UUID, 상품 문의만 있다면 null."
        },
        "title": {
          "type": "string",
          "description": "문의 제목 (필수)\n\nUI상 핵심 텍스트, 상품 문의 포인트 서술에 활용됨"
        },
        "body": {
          "type": "string",
          "description": "실제 문의 본문 (필수)\n\n장문의 텍스트도 허용됨"
        },
        "is_private": {
          "type": "boolean",
          "description": "비공개 문의 여부. true면 1:1 문의, false면 전체공개(기본 false 권장)"
        }
      },
      "required": [
        "customer_id",
        "product_id",
        "title",
        "body"
      ],
      "description": "상품/주문 문의 등록 요청용 DTO로, 생성할 문의의 주요 속성만 입력받아 등록합니다.\n\n사용자는 반드시 customer 권한을 가진 세션으로 이 api를 호출해야 하며, order_id는 nullable, 나머지 필수기입입니다.\n\n운영툴 등에서 직접 등록하는 경우에도 동일 스키마를 이용합니다."
    },
    "IAiEcommerceInquiry.IUpdate": {
      "type": "object",
      "properties": {
        "title": {
          "type": "string",
          "description": "수정할 문의 제목 (옵션)\n\n미입력시 기존값을 유지함"
        },
        "body": {
          "type": "string",
          "description": "수정할 문의 본문 텍스트 (옵션)\n\n장문 허용"
        },
        "status": {
          "type": "string",
          "description": "문의 상태(진행,완료 등) 변경 (옵션)\n\n변경 가능한 enum만 허용(정책에 따름)"
        },
        "is_private": {
          "type": "boolean",
          "description": "비공개/공개 전환값 (옵션)"
        }
      },
      "description": "상품/주문 문의 수정 요청용 타입입니다.\n\nPUT/PATCH로 문의 엔티티의 특정 필드(제목,본문,상태,공개여부 등)만 일부 수정(Partial) 시 사용합니다. 들어오지 않은 값은 미수정 의미로 그대로 둡니다.\n\n정책상 일부 필드(작성자, 타겟 FK 등)는 업데이트 불가입니다.",
      "required": []
    },
    "IAiEcommerceInquiry": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "문의 엔트리의 고유 식별자 (PK, UUID)\n\n각 inquiry는 이 ID로 추적/조회됩니다."
        },
        "customer_id": {
          "type": "string",
          "format": "uuid",
          "description": "작성 고객 UUID (ai_ecommerce_customer PK 참조)\n\n문의의 소유자/작성자 식별에 주로 쓰입니다."
        },
        "product_id": {
          "type": "string",
          "format": "uuid",
          "description": "문의 대상 상품 UUID\n\n관련 상품 상세 및 문의필터링에 사용됩니다."
        },
        "order_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "주문 관련 문의일 경우 주문 UUID 참조 (nullable)\n\n상품 문의만 있으면 null이 됨"
            },
            {
              "type": "null"
            }
          ],
          "description": "주문 관련 문의일 경우 주문 UUID 참조 (nullable)\n\n상품 문의만 있으면 null이 됨"
        },
        "title": {
          "type": "string",
          "description": "문의 제목\n\nUI 및 검색에서 중요한 키워드 필드입니다."
        },
        "body": {
          "type": "string",
          "description": "문의 본문/내용 (필수)\n\n실제 질문, 요청, 불만사항 상세 등이 이 필드에 담깁니다."
        },
        "status": {
          "type": "string",
          "description": "문의 상태 (예: 'open', 'closed', 'pending' 등 운영정책 기준)\n\n진행중/종료/미처리/답변완료 등 다양한 workflow 상태를 기록합니다."
        },
        "is_private": {
          "type": "boolean",
          "description": "비공개 문의 여부\n\ntrue면 비공개, false면 공개 문의임을 뜻합니다."
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "등록 시각(UTC, ISO 8601)\n\n문의 생성 일시를 기록합니다."
        },
        "updated_at": {
          "type": "string",
          "format": "date-time",
          "description": "마지막 변경 시각(ISO 8601)"
        },
        "deleted_at": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "소프트 삭제된 경우의 삭제 시각(ISO8601, null일 경우 활성 상태)"
            },
            {
              "type": "null"
            }
          ],
          "description": "소프트 삭제된 경우의 삭제 시각(ISO8601, null일 경우 활성 상태)"
        }
      },
      "required": [
        "id",
        "customer_id",
        "product_id",
        "title",
        "body",
        "status",
        "is_private",
        "created_at",
        "updated_at"
      ],
      "description": "상품/주문 문의 엔티티 레코드 스키마 (별칭 버전 ISummary 등과 중복 정의됨).\n\nai_ecommerce_inquiry 테이블의 단일 row를 나타내며, deleted_at 등이 소프트삭제에 활용됩니다."
    },
    "IAiEcommerceReview.IRequest": {
      "type": "object",
      "properties": {
        "customer_id": {
          "type": "string",
          "format": "uuid",
          "description": "검색할 리뷰 작성자(고객) UUID(선택)"
        },
        "product_id": {
          "type": "string",
          "format": "uuid",
          "description": "검색할 상품 UUID(선택)"
        },
        "order_id": {
          "type": "string",
          "format": "uuid",
          "description": "구매/리뷰가 연결된 주문 UUID(선택)"
        },
        "status": {
          "type": "string",
          "description": "리뷰 상태 필터(예: 'active', 'deleted', 'private', 등. 정책별 enum 지정)"
        },
        "rating_min": {
          "type": "integer",
          "description": "최소 별점 필터"
        },
        "rating_max": {
          "type": "integer",
          "description": "최대 별점 필터"
        },
        "is_verified": {
          "type": "boolean",
          "description": "실구매자(verified) 여부로 필터"
        },
        "is_private": {
          "type": "boolean",
          "description": "비공개 리뷰만 조회 시 true, 일반 공개만 조회 시 false"
        },
        "created_from": {
          "type": "string",
          "format": "date-time",
          "description": "리뷰 등록일 범위(from) - ISO8601"
        },
        "created_to": {
          "type": "string",
          "format": "date-time",
          "description": "리뷰 등록일 범위(to) - ISO8601"
        },
        "page": {
          "type": "integer",
          "description": "페이지 번호"
        },
        "limit": {
          "type": "integer",
          "description": "페이지당 최대 항목수"
        }
      },
      "required": [
        "page",
        "limit"
      ],
      "description": "상품/주문 리뷰 검색 및 리스트 조회용 요청(DTO) 스키마입니다.\n\nPrisma ai_ecommerce_review 테이블을 기반으로, 리뷰 목록/검색/필터에 활용할 각종 필터·페이징 정보들을 포함합니다."
    },
    "IPageIAiEcommerceReview": {
      "type": "object",
      "properties": {
        "pagination": {
          "$ref": "#/components/schemas/IPage.IPagination",
          "description": "Pagination metadata describing the current page, limit, total records, and total pages for the result set. See IPage.IPagination, used for every paginated query throughout the system.\n\nAlways present, even for empty result sets. Follows the standard as described in the core documentation."
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/IAiEcommerceReview"
          },
          "description": "Array of IAiEcommerceReview objects representing each review returned by the paginated query.\n\nEach record corresponds to a single customer review with its own atomic fields as per the ai_ecommerce_review schema."
        }
      },
      "required": [
        "pagination",
        "data"
      ],
      "description": "Paginated result set of IAiEcommerceReview entities, conforming to platform standard for paging. Used to return multiple review records along with pagination metadata whenever a list of reviews is requested, as per the standard list/search API operations. All fields correspond to schema requirements and API conventions."
    },
    "IAiEcommerceReview": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "Primary key for the review row. Globally unique for each review instance; required for all update/delete/detail operations and all relational linkages (e.g., comments, moderation, etc).\n\nSee ai_ecommerce_review schema: 'id String @id @db.Uuid'"
        },
        "customer_id": {
          "type": "string",
          "format": "uuid",
          "description": "ID of the customer who authored the review. Foreign Key to ai_ecommerce_customer. Used for ownership, moderation display, and auditing. Must always reference a legit customer id."
        },
        "product_id": {
          "type": "string",
          "format": "uuid",
          "description": "ID of the product being reviewed; Foreign Key to ai_ecommerce_product. All reviews must reference a single specific product. Used for detail views, analytics, and aggregation."
        },
        "order_id": {
          "type": "string",
          "format": "uuid",
          "description": "Order verification link—Foreign Key to ai_ecommerce_order. Used to confirm verified purchase, required for business logic of reviews ('verified review')."
        },
        "rating": {
          "type": "integer",
          "description": "Atomic review rating (typically 1-5 or business-defined). Required for analytics and customer feedback logic. Positive integer, no decimals allowed."
        },
        "title": {
          "oneOf": [
            {
              "type": "string",
              "description": "Optional review title—nullable for cases where the review is text/body only.\n\nIncluded in the main table for compatibility with UI and platform expectations."
            },
            {
              "type": "null",
              "description": "Optional review title—nullable for cases where the review is text/body only.\n\nIncluded in the main table for compatibility with UI and platform expectations."
            }
          ],
          "description": "Optional review title—nullable for cases where the review is text/body only.\n\nIncluded in the main table for compatibility with UI and platform expectations."
        },
        "body": {
          "type": "string",
          "description": "Main text content of the review. Required. Stores normalized review message, free-text."
        },
        "is_verified": {
          "type": "boolean",
          "description": "Boolean—true if review is linked to a successful order (verified purchase). Enforced by business logic and analytics."
        },
        "is_private": {
          "type": "boolean",
          "description": "Privacy toggle. If true, the review is not visible to the public/product page but can be used for internal workflows (e.g., feedback only)."
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp when the review was originally written. Used for chronological ordering, reporting, and compliance."
        },
        "updated_at": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp for last edit to review."
        },
        "deleted_at": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "Soft deletion timestamp. If present—not visible in standard queries, retained for audit/compliance."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "Soft deletion timestamp. If present—not visible in standard queries, retained for audit/compliance."
            }
          ],
          "description": "Soft deletion timestamp. If present—not visible in standard queries, retained for audit/compliance."
        }
      },
      "required": [
        "id",
        "customer_id",
        "product_id",
        "order_id",
        "rating",
        "body",
        "is_verified",
        "is_private",
        "created_at",
        "updated_at"
      ],
      "description": "A customer review as represented in the ai_ecommerce_review schema. Implements all atomic properties required for analytics, public display, moderation, and relational linking to orders, customers, products, and community features. Derived strictly from the PRISMA and ERD schema—not denormalized. For full audit trail or rollback, related snapshot tables are consulted."
    },
    "IAiEcommerceReview.ICreate": {
      "type": "object",
      "properties": {
        "customer_id": {
          "type": "string",
          "format": "uuid",
          "description": "ID of the customer authoring the review. Foreign Key, required for ownership traceability."
        },
        "product_id": {
          "type": "string",
          "format": "uuid",
          "description": "ID of the product being reviewed."
        },
        "order_id": {
          "type": "string",
          "format": "uuid",
          "description": "Order ID verifying that the purchase was made by the customer-author. Required for 'verified' logic."
        },
        "rating": {
          "type": "integer",
          "description": "Review rating numeric value. Required; integer (typically 1–5 as enforced by business logic)."
        },
        "body": {
          "type": "string",
          "description": "Main text body of the review. Required, must have user-supplied free text."
        },
        "title": {
          "oneOf": [
            {
              "type": "string",
              "description": "Optional review title or summary. Nullable; present in schema for presentation flexibility."
            },
            {
              "type": "null",
              "description": "Optional review title or summary. Nullable; present in schema for presentation flexibility."
            }
          ],
          "description": "Optional review title or summary. Nullable; present in schema for presentation flexibility."
        },
        "is_private": {
          "type": "boolean",
          "description": "Boolean: If true, review is only internal/not shown on product page."
        }
      },
      "required": [
        "customer_id",
        "product_id",
        "order_id",
        "rating",
        "body",
        "is_private"
      ],
      "description": "Creation (POST) payload type for IAiEcommerceReview. Contains all fields required to create a new review given business constraints. All field constraints and relationships are enforced by the backend and described in the comments from the PRISMA schema."
    },
    "IAiEcommerceReview.IUpdate": {
      "type": "object",
      "properties": {
        "rating": {
          "type": "integer",
          "description": "Review rating numeric value. Optional for update (PATCH/PUT)."
        },
        "body": {
          "type": "string",
          "description": "Main text body of the review. Optional for update; present for PATCH."
        },
        "title": {
          "oneOf": [
            {
              "type": "string",
              "description": "Review title to update. Optional and nullable."
            },
            {
              "type": "null",
              "description": "Review title to update. Optional and nullable."
            }
          ],
          "description": "Review title to update. Optional and nullable."
        },
        "is_private": {
          "type": "boolean",
          "description": "Boolean: If true, review is hidden from public view. Optional for update."
        }
      },
      "required": [],
      "description": "Update payload for IAiEcommerceReview. All fields optional; only properties to be updated need be specified. The schema design matches business rules for PATCH/PUT to modify reviews post-creation. No layout-changing fields are permitted."
    },
    "IAiEcommerceForumThread.IRequest": {
      "type": "object",
      "properties": {
        "customer_id": {
          "type": "string",
          "format": "uuid",
          "description": "ID of the customer author who opened the thread, for searching by participant."
        },
        "product_id": {
          "type": "string",
          "format": "uuid",
          "description": "ID of the product discussed in the thread."
        },
        "category_id": {
          "type": "string",
          "format": "uuid",
          "description": "ID of the product category if the thread is category/QA oriented."
        },
        "status": {
          "type": "string",
          "description": "Status of the thread, such as 'open', 'closed', supporting search/filter for admins/moderators."
        },
        "title": {
          "type": "string",
          "description": "Full-text search by thread title."
        },
        "is_pinned": {
          "type": "boolean",
          "description": "Filter for 'pinned' thread status."
        },
        "is_private": {
          "type": "boolean",
          "description": "Search/show only private or public threads as needed."
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "Filter for threads created at (ISO 8601) or since a particular timestamp."
        },
        "updated_at": {
          "type": "string",
          "format": "date-time",
          "description": "For sorting/filtering by last update."
        }
      },
      "required": [],
      "description": "Request/search parameters for paginated forum thread search in ai_ecommerce_forum_thread. All fields are optional filters for searching, sorting, or filtering the thread list. Used by admin dashboards, moderation screens, and category navigation in the product catalog."
    },
    "IPageIAiEcommerceForumThread": {
      "type": "object",
      "properties": {
        "pagination": {
          "$ref": "#/components/schemas/IPage.IPagination"
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/IAiEcommerceForumThread"
          }
        }
      },
      "required": [
        "pagination",
        "data"
      ],
      "description": "Standard page-wrapped result set for listing IAiEcommerceForumThread entities, matching the platform-wide paging container convention. Data array contains each thread's atomic details; pagination duplicates IPage.IPagination used everywhere."
    },
    "IAiEcommerceForumThread": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "Primary key for the forum thread, globally unique. Matches ai_ecommerce_forum_thread.id."
        },
        "customer_id": {
          "type": "string",
          "format": "uuid",
          "description": "ID of the customer authoring the thread (FK to ai_ecommerce_customer)."
        },
        "product_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "FK—ID of related product if the thread is product-specific; null if not."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "FK—ID of related product if the thread is product-specific; null if not."
            }
          ],
          "description": "FK—ID of related product if the thread is product-specific; null if not."
        },
        "category_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Data: FK—ID of related category if the thread is category-specific; null if not."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Data: FK—ID of related category if the thread is category-specific; null if not."
            }
          ],
          "description": "Data: FK—ID of related category if the thread is category-specific; null if not."
        },
        "title": {
          "type": "string",
          "description": "Thread title, required in schema and for all creation."
        },
        "body": {
          "type": "string",
          "description": "Thread content/body, required, atomic."
        },
        "status": {
          "type": "string",
          "description": "Status of the thread—open, closed, etc. Controlled by backend."
        },
        "is_pinned": {
          "type": "boolean",
          "description": "Pinned status for customer support or admin featured display."
        },
        "is_private": {
          "type": "boolean",
          "description": "If true, thread is not shown to public but is visible internally/admin. Required."
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "Datetime when thread was created."
        },
        "updated_at": {
          "type": "string",
          "format": "date-time",
          "description": "Last update timestamp for the thread."
        },
        "deleted_at": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "Soft-deletion timestamp; null if not deleted."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "Soft-deletion timestamp; null if not deleted."
            }
          ],
          "description": "Soft-deletion timestamp; null if not deleted."
        }
      },
      "required": [
        "id",
        "customer_id",
        "title",
        "body",
        "status",
        "is_pinned",
        "is_private",
        "created_at",
        "updated_at"
      ],
      "description": "Forum discussion or Q&A thread, modeled from ai_ecommerce_forum_thread table. Contains all atomic fields (no aggregates or materialized content). All references/foreign keys strictly normalized to underlying schema for full compliance and audit-trail. Timestamps track created/updated/deleted lifecycle status."
    },
    "IAiEcommerceForumThread.ICreate": {
      "type": "object",
      "properties": {
        "customer_id": {
          "type": "string",
          "format": "uuid",
          "description": "ID of the customer author. FK to ai_ecommerce_customer."
        },
        "product_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Optional product ID if the thread is product-specific."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Optional product ID if the thread is product-specific."
            }
          ],
          "description": "Optional product ID if the thread is product-specific."
        },
        "category_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Optional category ID for category/QA thread. Null allowed."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Optional category ID for category/QA thread. Null allowed."
            }
          ],
          "description": "Optional category ID for category/QA thread. Null allowed."
        },
        "title": {
          "type": "string",
          "description": "Thread title. Required."
        },
        "body": {
          "type": "string",
          "description": "Thread content, required."
        },
        "is_pinned": {
          "type": "boolean",
          "description": "Set to true for admin-featured/sticky threads. Optional, defaults false."
        },
        "is_private": {
          "type": "boolean",
          "description": "If true, thread is private-only. Required for explicit thread creation."
        }
      },
      "required": [
        "customer_id",
        "title",
        "body",
        "is_private"
      ],
      "description": "Payload type for creating (POST) a new forum thread. All business-rule and audit-trail fields strictly enforced according to schema. Optional: product_id, category_id, is_pinned flag. Nulls allowed for product/category id."
    },
    "IAiEcommerceForumThread.IUpdate": {
      "type": "object",
      "properties": {
        "title": {
          "type": "string",
          "description": "Thread title, updatable."
        },
        "body": {
          "type": "string",
          "description": "Thread content updatable after creation."
        },
        "status": {
          "type": "string",
          "description": "Status updatable (e.g. closed, open, etc.)."
        },
        "is_pinned": {
          "type": "boolean",
          "description": "Pinned status updatable (admin/moderator only)."
        },
        "is_private": {
          "type": "boolean",
          "description": "Thread privacy flag; may be updated."
        }
      },
      "required": [],
      "description": "Payload for updating a thread's updatable fields (PUT or PATCH). All fields are optional; only properties to be updated need be provided."
    },
    "ai_ecommerceComment.IRequest": {
      "type": "object",
      "properties": {
        "customer_id": {
          "type": "string",
          "format": "uuid",
          "description": "Author id, for filtering comments by creator; Foreign Key to ai_ecommerce_customer."
        },
        "forum_thread_id": {
          "type": "string",
          "format": "uuid",
          "description": "FK to forum thread—filter for comments tied to specific thread. Optional."
        },
        "inquiry_id": {
          "type": "string",
          "format": "uuid",
          "description": "FK to inquiry if this is an inquiry comment; optional."
        },
        "review_id": {
          "type": "string",
          "format": "uuid",
          "description": "FK to review if applicable; for fetching review comments."
        },
        "parent_id": {
          "type": "string",
          "format": "uuid",
          "description": "Parent comment FK for nested queries."
        },
        "body": {
          "type": "string",
          "description": "Full-text search by comment body."
        },
        "depth": {
          "type": "integer",
          "description": "Tree depth, allows searching for root or reply comments."
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "Filter comments created after this time."
        },
        "updated_at": {
          "type": "string",
          "format": "date-time",
          "description": "Filter comments updated after this time."
        },
        "deleted_at": {
          "type": "string",
          "format": "date-time",
          "description": "Filter deleted comments for administration/tracing."
        }
      },
      "required": [],
      "description": "Search, filter, and pagination fields as permitted for comment listing, mapped directly to ai_ecommerce_comment fields. All fields are optional for max flexibility."
    },
    "ai_ecommerceComment.IPage": {
      "type": "object",
      "properties": {
        "pagination": {
          "$ref": "#/components/schemas/IPage.IPagination",
          "description": "Page information as per standard IPage.IPagination."
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/ai_ecommerceComment"
          },
          "description": "Comment data rows matching filter/page."
        }
      },
      "required": [
        "pagination",
        "data"
      ],
      "description": "Paginated response for comments as per business logic. Includes paging metadata and search result rows."
    },
    "ai_ecommerceComment": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "Primary key for the comment row, as per ai_ecommerce_comment.id"
        },
        "customer_id": {
          "type": "string",
          "format": "uuid",
          "description": "FK: comment author, always a customer."
        },
        "parent_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "FK to parent comment, supports threaded/nested replies. Null if root level."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "FK to parent comment, supports threaded/nested replies. Null if root level."
            }
          ],
          "description": "FK to parent comment, supports threaded/nested replies. Null if root level."
        },
        "forum_thread_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "FK reference to owning forum thread; null if not a thread comment."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "FK reference to owning forum thread; null if not a thread comment."
            }
          ],
          "description": "FK reference to owning forum thread; null if not a thread comment."
        },
        "inquiry_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "FK to inquiry if comment is on inquiry object; null otherwise."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "FK to inquiry if comment is on inquiry object; null otherwise."
            }
          ],
          "description": "FK to inquiry if comment is on inquiry object; null otherwise."
        },
        "review_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "FK: comment to review; null if not attached to review."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "FK: comment to review; null if not attached to review."
            }
          ],
          "description": "FK: comment to review; null if not attached to review."
        },
        "body": {
          "type": "string",
          "description": "Comment's body/content, plain text."
        },
        "depth": {
          "type": "integer",
          "description": "Tree-depth of this comment, integer representing nesting."
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "Date/time comment was written."
        },
        "updated_at": {
          "type": "string",
          "format": "date-time",
          "description": "Last update timestamp (nullable, reflects last edit or present)."
        },
        "deleted_at": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "Soft deletion timestamp; null if active."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "Soft deletion timestamp; null if active."
            }
          ],
          "description": "Soft deletion timestamp; null if active."
        }
      },
      "required": [
        "id",
        "customer_id",
        "body",
        "depth",
        "created_at",
        "updated_at"
      ],
      "description": "Entity for a forum/inquiry/review comment, atomic; follows ai_ecommerce_comment schema for required/optional props, including parent/target/relation FKs, and auditability. All reference fields are normalized/nullable as dictated by ERD and comments schema."
    },
    "ai_ecommerceComment.ICreate": {
      "type": "object",
      "properties": {
        "customer_id": {
          "type": "string",
          "format": "uuid",
          "description": "The unique identifier for the customer authoring the comment. Must be a valid UUID referencing ai_ecommerce_customer."
        },
        "parent_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "The comment's parent id if this is a reply to another comment. Null for top-level comments."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "The comment's parent id if this is a reply to another comment. Null for top-level comments."
            }
          ],
          "description": "The comment's parent id if this is a reply to another comment. Null for top-level comments."
        },
        "forum_thread_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "ID of the related forum thread if this comment is associated with a forum thread, else null."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "ID of the related forum thread if this comment is associated with a forum thread, else null."
            }
          ],
          "description": "ID of the related forum thread if this comment is associated with a forum thread, else null."
        },
        "inquiry_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "ID of the related inquiry if this comment is attached to an inquiry, else null."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "ID of the related inquiry if this comment is attached to an inquiry, else null."
            }
          ],
          "description": "ID of the related inquiry if this comment is attached to an inquiry, else null."
        },
        "review_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "ID of the related review if this comment is attached to a review, else null."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "ID of the related review if this comment is attached to a review, else null."
            }
          ],
          "description": "ID of the related review if this comment is attached to a review, else null."
        },
        "body": {
          "type": "string",
          "description": "The main content of the comment. Atomic text, not null, validated for business rules or prohibited content."
        }
      },
      "required": [
        "customer_id",
        "body"
      ],
      "description": "Creation payload for a new comment in the ai_ecommerce_comment table. Fields include author, target context (forum thread, inquiry, review, or parent comment), and main text body. Complies with 3NF—only a single parent, and only one target FK can be non-null for atomicity. Association and context validated by business logic."
    },
    "ai_ecommerceComment.IUpdate": {
      "type": "object",
      "properties": {
        "body": {
          "type": "string",
          "description": "Updated content/body of the comment. Only allowed to be changed by author or admin. Subject to moderation and validation rules."
        }
      },
      "required": [
        "body"
      ],
      "description": "Update payload for modifying an existing comment in ai_ecommerce_comment. Only business-allowed fields can be updated; parent/thread/inquiry/review associations are immutable after creation. Edits are audit-tracked."
    },
    "ai_ecommerceReply.IRequest": {
      "type": "object",
      "properties": {
        "seller_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "ID of the seller authoring the reply (nullable if admin-author)"
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "ID of the seller authoring the reply (nullable if admin-author)"
            }
          ],
          "description": "ID of the seller authoring the reply (nullable if admin-author)"
        },
        "administrator_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "ID of the admin authoring the reply (nullable if seller-author)"
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "ID of the admin authoring the reply (nullable if seller-author)"
            }
          ],
          "description": "ID of the admin authoring the reply (nullable if seller-author)"
        },
        "inquiry_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "The target inquiry being replied to (nullable)"
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "The target inquiry being replied to (nullable)"
            }
          ],
          "description": "The target inquiry being replied to (nullable)"
        },
        "review_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "The target review being replied to (nullable)"
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "The target review being replied to (nullable)"
            }
          ],
          "description": "The target review being replied to (nullable)"
        },
        "forum_thread_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "The forum thread being replied to (nullable)"
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "The forum thread being replied to (nullable)"
            }
          ],
          "description": "The forum thread being replied to (nullable)"
        },
        "comment_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "The comment being replied to (if applicable)"
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "The comment being replied to (if applicable)"
            }
          ],
          "description": "The comment being replied to (if applicable)"
        },
        "body": {
          "oneOf": [
            {
              "type": "string",
              "description": "Text search or filter on reply content"
            },
            {
              "type": "null",
              "description": "Text search or filter on reply content"
            }
          ],
          "description": "Text search or filter on reply content"
        },
        "created_after": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "Filter for replies created after this timestamp."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "Filter for replies created after this timestamp."
            }
          ],
          "description": "Filter for replies created after this timestamp."
        },
        "created_before": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "Filter for replies created before this timestamp."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "Filter for replies created before this timestamp."
            }
          ],
          "description": "Filter for replies created before this timestamp."
        },
        "limit": {
          "oneOf": [
            {
              "type": "integer",
              "description": "Pagination limit (number of records to return)"
            },
            {
              "type": "null",
              "description": "Pagination limit (number of records to return)"
            }
          ],
          "description": "Pagination limit (number of records to return)"
        },
        "offset": {
          "oneOf": [
            {
              "type": "integer",
              "description": "Pagination offset for fetching reply records"
            },
            {
              "type": "null",
              "description": "Pagination offset for fetching reply records"
            }
          ],
          "description": "Pagination offset for fetching reply records"
        }
      },
      "description": "Search/filter/request object for retrieving a list of reply records. Includes filters for author (seller/admin), target entity info, body text, and date range plus pagination controls.",
      "required": []
    },
    "ai_ecommerceReply.IPage": {
      "type": "object",
      "properties": {
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/ai_ecommerceReply"
          },
          "description": "Array of reply objects for current result set."
        },
        "total": {
          "type": "integer",
          "description": "Total number of replies matching the query"
        },
        "limit": {
          "type": "integer",
          "description": "Query limit (results per page)"
        },
        "offset": {
          "type": "integer",
          "description": "Query offset (records skipped)"
        }
      },
      "required": [
        "data",
        "total",
        "limit",
        "offset"
      ],
      "description": "Paginated results set of replies; includes reply data, page size limit, offset, and total result count. Typically returned from reply search/list operations."
    },
    "ai_ecommerceReply": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "Primary key for the reply record, globally unique."
        },
        "seller_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "UUID of seller who authored the reply (nullable if admin is author)"
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "UUID of seller who authored the reply (nullable if admin is author)"
            }
          ],
          "description": "UUID of seller who authored the reply (nullable if admin is author)"
        },
        "administrator_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "UUID of admin who authored the reply (nullable if seller is author)"
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "UUID of admin who authored the reply (nullable if seller is author)"
            }
          ],
          "description": "UUID of admin who authored the reply (nullable if seller is author)"
        },
        "inquiry_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "UUID of the inquiry being replied to (nullable)"
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "UUID of the inquiry being replied to (nullable)"
            }
          ],
          "description": "UUID of the inquiry being replied to (nullable)"
        },
        "review_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "UUID of the review being replied to (nullable)"
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "UUID of the review being replied to (nullable)"
            }
          ],
          "description": "UUID of the review being replied to (nullable)"
        },
        "forum_thread_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "UUID of the forum thread being replied to (nullable)"
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "UUID of the forum thread being replied to (nullable)"
            }
          ],
          "description": "UUID of the forum thread being replied to (nullable)"
        },
        "comment_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "UUID of the comment being replied to (nullable)"
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "UUID of the comment being replied to (nullable)"
            }
          ],
          "description": "UUID of the comment being replied to (nullable)"
        },
        "body": {
          "type": "string",
          "description": "Text content of the reply."
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp when reply was created."
        },
        "updated_at": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp when reply was last updated."
        },
        "deleted_at": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "Timestamp if the reply was soft-deleted; null if active."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "Timestamp if the reply was soft-deleted; null if active."
            }
          ],
          "description": "Timestamp if the reply was soft-deleted; null if active."
        }
      },
      "required": [
        "id",
        "body",
        "created_at",
        "updated_at"
      ],
      "description": "Main entity schema for a reply record in ai_ecommerce_reply. Contains all atomic fields related to moderation/admin/seller replies to comments, threads, inquiries, or reviews. Each reply references just one target."
    },
    "ai_ecommerceReply.ICreate": {
      "type": "object",
      "properties": {
        "seller_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "UUID of seller author if authoring reply (nullable if admin is author)"
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "UUID of seller author if authoring reply (nullable if admin is author)"
            }
          ],
          "description": "UUID of seller author if authoring reply (nullable if admin is author)"
        },
        "administrator_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "UUID of admin author if authoring reply (nullable if seller is author)"
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "UUID of admin author if authoring reply (nullable if seller is author)"
            }
          ],
          "description": "UUID of admin author if authoring reply (nullable if seller is author)"
        },
        "inquiry_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "UUID of inquiry being replied to (nullable if replying to another entity)"
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "UUID of inquiry being replied to (nullable if replying to another entity)"
            }
          ],
          "description": "UUID of inquiry being replied to (nullable if replying to another entity)"
        },
        "review_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "UUID of review being replied to (nullable)"
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "UUID of review being replied to (nullable)"
            }
          ],
          "description": "UUID of review being replied to (nullable)"
        },
        "forum_thread_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "UUID of forum thread being replied to (nullable)"
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "UUID of forum thread being replied to (nullable)"
            }
          ],
          "description": "UUID of forum thread being replied to (nullable)"
        },
        "comment_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "UUID of the comment being replied to (nullable)"
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "UUID of the comment being replied to (nullable)"
            }
          ],
          "description": "UUID of the comment being replied to (nullable)"
        },
        "body": {
          "type": "string",
          "description": "Content of the reply."
        }
      },
      "required": [
        "body"
      ],
      "description": "Creation object for a reply entry in ai_ecommerce_reply. Provides reference to author (seller/admin), target entity, and reply body. At least one of seller_id or administrator_id must be non-null; exactly one target FK must be non-null."
    },
    "ai_ecommerceReply.IUpdate": {
      "type": "object",
      "properties": {
        "body": {
          "type": "string",
          "description": "Updated reply body/content. Only allowed to author/moderator/admin as per permission. Content checked for compliance, validation."
        }
      },
      "required": [
        "body"
      ],
      "description": "Update payload for modifying an existing reply in ai_ecommerce_reply. Only mutable field is body text—target associations are immutable."
    },
    "ai_ecommerceReport.IRequest": {
      "type": "object",
      "properties": {
        "reporter_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "UUID of the customer who reported (filter)"
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "UUID of the customer who reported (filter)"
            }
          ],
          "description": "UUID of the customer who reported (filter)"
        },
        "target_comment_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "UUID of the reported comment, if this is a comment report"
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "UUID of the reported comment, if this is a comment report"
            }
          ],
          "description": "UUID of the reported comment, if this is a comment report"
        },
        "target_review_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "UUID of the reported review, if this is a review report"
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "UUID of the reported review, if this is a review report"
            }
          ],
          "description": "UUID of the reported review, if this is a review report"
        },
        "target_forum_thread_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "UUID of the reported thread, if this is a thread report"
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "UUID of the reported thread, if this is a thread report"
            }
          ],
          "description": "UUID of the reported thread, if this is a thread report"
        },
        "resolved_by_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "UUID of the administrator who resolved this report"
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "UUID of the administrator who resolved this report"
            }
          ],
          "description": "UUID of the administrator who resolved this report"
        },
        "reason": {
          "oneOf": [
            {
              "type": "string",
              "description": "Filter by report reason"
            },
            {
              "type": "null",
              "description": "Filter by report reason"
            }
          ],
          "description": "Filter by report reason"
        },
        "status": {
          "oneOf": [
            {
              "type": "string",
              "description": "Filter by report workflow/status"
            },
            {
              "type": "null",
              "description": "Filter by report workflow/status"
            }
          ],
          "description": "Filter by report workflow/status"
        },
        "created_after": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "Filter for reports created after this datetime"
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "Filter for reports created after this datetime"
            }
          ],
          "description": "Filter for reports created after this datetime"
        },
        "created_before": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "Filter for reports created before this datetime"
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "Filter for reports created before this datetime"
            }
          ],
          "description": "Filter for reports created before this datetime"
        },
        "limit": {
          "oneOf": [
            {
              "type": "integer",
              "description": "Pagination limit (number of records to return)"
            },
            {
              "type": "null",
              "description": "Pagination limit (number of records to return)"
            }
          ],
          "description": "Pagination limit (number of records to return)"
        },
        "offset": {
          "oneOf": [
            {
              "type": "integer",
              "description": "Pagination offset for result set"
            },
            {
              "type": "null",
              "description": "Pagination offset for result set"
            }
          ],
          "description": "Pagination offset for result set"
        }
      },
      "description": "Search/filter object for listing or querying abuse/report records in ai_ecommerce_report. Filtering possible by reporter, target, status, date, or reason, with full-text and pagination fields supported. Used by moderation/admin dashboards.",
      "required": []
    },
    "ai_ecommerceReport.IPage": {
      "type": "object",
      "properties": {
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/ai_ecommerceReport"
          },
          "description": "Array of report result objects for current page."
        },
        "total": {
          "type": "integer",
          "description": "Total number of reports matching query."
        },
        "limit": {
          "type": "integer",
          "description": "Limit used in query requests."
        },
        "offset": {
          "type": "integer",
          "description": "Offset used in query requests."
        }
      },
      "required": [
        "data",
        "total",
        "limit",
        "offset"
      ],
      "description": "Paginated object returned by abuse/violation report listing endpoints. Always includes data array, total count, page size, and offset for pagination."
    },
    "ai_ecommerceReport": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "System-unique identifier for a report row."
        },
        "reporter_id": {
          "type": "string",
          "format": "uuid",
          "description": "UUID of the customer who filed the report (report actor/subject)."
        },
        "target_comment_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "UUID of the comment being reported (if applicable)."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "UUID of the comment being reported (if applicable)."
            }
          ],
          "description": "UUID of the comment being reported (if applicable)."
        },
        "target_review_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "UUID of the review being reported (if applicable)."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "UUID of the review being reported (if applicable)."
            }
          ],
          "description": "UUID of the review being reported (if applicable)."
        },
        "target_forum_thread_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "UUID of the forum thread being reported (if applicable)."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "UUID of the forum thread being reported (if applicable)."
            }
          ],
          "description": "UUID of the forum thread being reported (if applicable)."
        },
        "resolved_by_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "UUID of the admin who resolved this report (if resolved)."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "UUID of the admin who resolved this report (if resolved)."
            }
          ],
          "description": "UUID of the admin who resolved this report (if resolved)."
        },
        "reason": {
          "type": "string",
          "description": "Short string that denotes the reason for reporting (e.g., abuse, spam, ToS violation)."
        },
        "status": {
          "type": "string",
          "description": "Workflow/status of the report (e.g., open, resolved, pending)."
        },
        "detailed_comment": {
          "oneOf": [
            {
              "type": "string",
              "description": "Optional extended reason comments provided by customer when filing."
            },
            {
              "type": "null",
              "description": "Optional extended reason comments provided by customer when filing."
            }
          ],
          "description": "Optional extended reason comments provided by customer when filing."
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "When the report was submitted."
        },
        "resolved_at": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "When the report was resolved."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "When the report was resolved."
            }
          ],
          "description": "When the report was resolved."
        },
        "deleted_at": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "When the report was soft-deleted, or null if active."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "When the report was soft-deleted, or null if active."
            }
          ],
          "description": "When the report was soft-deleted, or null if active."
        }
      },
      "required": [
        "id",
        "reporter_id",
        "reason",
        "status",
        "created_at"
      ],
      "description": "Entity schema for an abuse or violation report, in ai_ecommerce_report. Each record references exactly one kind of entity (comment/review/thread), with resolver (admin), reason, status, and time fields. Detailed comments and resolution are tracked for compliance."
    },
    "IAiEcommerceReport.ICreate": {
      "type": "object",
      "properties": {
        "reporter_id": {
          "type": "string",
          "format": "uuid",
          "description": "Customer UUID of the abuse reporter."
        },
        "target_comment_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "UUID of the target comment (if reporting a comment)."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "UUID of the target comment (if reporting a comment)."
            }
          ],
          "description": "UUID of the target comment (if reporting a comment)."
        },
        "target_review_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "UUID of the target review (if reporting a review)."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "UUID of the target review (if reporting a review)."
            }
          ],
          "description": "UUID of the target review (if reporting a review)."
        },
        "target_forum_thread_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "UUID of the target forum thread (if reporting a thread)."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "UUID of the target forum thread (if reporting a thread)."
            }
          ],
          "description": "UUID of the target forum thread (if reporting a thread)."
        },
        "reason": {
          "type": "string",
          "description": "Short, business-defined abuse/reason code describing why this content is being reported."
        },
        "status": {
          "type": "string",
          "description": "Initial workflow state of the report (e.g., pending, open, triage)."
        },
        "detailed_comment": {
          "oneOf": [
            {
              "type": "string",
              "description": "Optional extended description provided by customer at the time of filing."
            },
            {
              "type": "null",
              "description": "Optional extended description provided by customer at the time of filing."
            }
          ],
          "description": "Optional extended description provided by customer at the time of filing."
        }
      },
      "required": [
        "reporter_id",
        "reason",
        "status"
      ],
      "description": "Creation request object for a new abuse/violation report in ai_ecommerce_report. Target associations (comment/review/thread) are exclusive; only one can be non-null per record. The reason and status codes are business-defined enums."
    },
    "IAiEcommerceReport": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "System-unique identifier for a report, as returned on creation."
        },
        "reporter_id": {
          "type": "string",
          "format": "uuid",
          "description": "UUID of the customer who filed the report."
        },
        "target_comment_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "UUID of the comment being reported (if any)."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "UUID of the comment being reported (if any)."
            }
          ],
          "description": "UUID of the comment being reported (if any)."
        },
        "target_review_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "UUID of the review being reported (if any)."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "UUID of the review being reported (if any)."
            }
          ],
          "description": "UUID of the review being reported (if any)."
        },
        "target_forum_thread_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "UUID of the forum thread being reported (if any)."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "UUID of the forum thread being reported (if any)."
            }
          ],
          "description": "UUID of the forum thread being reported (if any)."
        },
        "reason": {
          "type": "string",
          "description": "Short business-defined string for the violation/abuse reason code."
        },
        "status": {
          "type": "string",
          "description": "Current workflow/status of the report."
        },
        "detailed_comment": {
          "oneOf": [
            {
              "type": "string",
              "description": "Optional extended comments provided by user."
            },
            {
              "type": "null",
              "description": "Optional extended comments provided by user."
            }
          ],
          "description": "Optional extended comments provided by user."
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "Creation time for the report."
        }
      },
      "required": [
        "id",
        "reporter_id",
        "reason",
        "status",
        "created_at"
      ],
      "description": "Response/result object for a newly created violation or abuse report, as returned by creation endpoints. Fields mirror the main entity but may not include resolved/deleted meta."
    },
    "IAiEcommerceReport.IUpdate": {
      "type": "object",
      "properties": {
        "reason": {
          "type": "string",
          "description": "신고 사유의 변경/갱신을 위한 텍스트 필드. 신고 유형 또는 상세 설명 등의 사유 정보를 포함합니다.\n\n문자열 데이터이며, 공격성 단어나 개인정보 노출 등을 포함하지 않도록 클라이언트·백엔드 검증이 필요합니다."
        },
        "status": {
          "type": "string",
          "description": "신고의 워크플로우 진행 상태. 예: 'pending', 'reviewed', 'resolved', 'rejected' 등 명확한 상태값을 명시해야 하며, 지원되는 enum 값은 시스템 정책에 따라 정의됩니다.\n\n상태 값 업데이트 시 관리자·혹은 자동화 로직에 의해 변경되며, 각 상태별 전이 조건 및 부가 설명은 고객센터/운영진 문서를 참고하십시오."
        },
        "resolved_by_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "신고 처리 담당자의 관리자 UUID. 처리/해결 단계에서 할당하는 PK.\n\n해당 필드는 처리완료/해결 시점에만 설정하며, null은 아직 담당자가 없는 경우입니다."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "신고 처리 담당자의 관리자 UUID. 처리/해결 단계에서 할당하는 PK.\n\n해당 필드는 처리완료/해결 시점에만 설정하며, null은 아직 담당자가 없는 경우입니다."
            }
          ],
          "description": "신고 처리 담당자의 관리자 UUID. 처리/해결 단계에서 할당하는 PK.\n\n해당 필드는 처리완료/해결 시점에만 설정하며, null은 아직 담당자가 없는 경우입니다."
        },
        "detailed_comment": {
          "oneOf": [
            {
              "type": "string",
              "description": "신고 처리 시 상세 사유/조치내역 혹은 추가 코멘트 기재란.\n\n고객센터, 관리자, 시스템 등이 자유롭게 입력할 수 있으며, 8000~12000자까지의 긴 텍스트 허용. null은 미입력."
            },
            {
              "type": "null",
              "description": "신고 처리 시 상세 사유/조치내역 혹은 추가 코멘트 기재란.\n\n고객센터, 관리자, 시스템 등이 자유롭게 입력할 수 있으며, 8000~12000자까지의 긴 텍스트 허용. null은 미입력."
            }
          ],
          "description": "신고 처리 시 상세 사유/조치내역 혹은 추가 코멘트 기재란.\n\n고객센터, 관리자, 시스템 등이 자유롭게 입력할 수 있으며, 8000~12000자까지의 긴 텍스트 허용. null은 미입력."
        },
        "resolved_at": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "신고 처리(완료) 시각. ISO 8601 UTC 타임스탬프 형식. 처리 완료·해결 시 반드시 입력하며, NULL은 미해결 상태.\n\n입력 예: '2025-07-16T06:57:51.232Z'"
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "신고 처리(완료) 시각. ISO 8601 UTC 타임스탬프 형식. 처리 완료·해결 시 반드시 입력하며, NULL은 미해결 상태.\n\n입력 예: '2025-07-16T06:57:51.232Z'"
            }
          ],
          "description": "신고 처리(완료) 시각. ISO 8601 UTC 타임스탬프 형식. 처리 완료·해결 시 반드시 입력하며, NULL은 미해결 상태.\n\n입력 예: '2025-07-16T06:57:51.232Z'"
        },
        "deleted_at": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "해당 신고가 논리적으로 삭제(소프트 딜리트) 혹은 정정/무효 처리된 경우 기록하는 시간.\n\nnull은 정상 노출 상태, timestamp가 있으면 삭제됨"
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "해당 신고가 논리적으로 삭제(소프트 딜리트) 혹은 정정/무효 처리된 경우 기록하는 시간.\n\nnull은 정상 노출 상태, timestamp가 있으면 삭제됨"
            }
          ],
          "description": "해당 신고가 논리적으로 삭제(소프트 딜리트) 혹은 정정/무효 처리된 경우 기록하는 시간.\n\nnull은 정상 노출 상태, timestamp가 있으면 삭제됨"
        },
        "target_comment_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "신고가 특정 댓글(comment_id)을 대상으로 한 경우의 대상 PK.\n\n보고 대상이 댓글일 때만 지정. 아니면 null."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "신고가 특정 댓글(comment_id)을 대상으로 한 경우의 대상 PK.\n\n보고 대상이 댓글일 때만 지정. 아니면 null."
            }
          ],
          "description": "신고가 특정 댓글(comment_id)을 대상으로 한 경우의 대상 PK.\n\n보고 대상이 댓글일 때만 지정. 아니면 null."
        },
        "target_review_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "신고가 리뷰(review_id)를 대상으로 한 경우의 대상 PK."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "신고가 리뷰(review_id)를 대상으로 한 경우의 대상 PK."
            }
          ],
          "description": "신고가 리뷰(review_id)를 대상으로 한 경우의 대상 PK."
        },
        "target_forum_thread_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "신고가 포럼 쓰레드(thread_id)를 대상으로 한 경우의 대상 PK."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "신고가 포럼 쓰레드(thread_id)를 대상으로 한 경우의 대상 PK."
            }
          ],
          "description": "신고가 포럼 쓰레드(thread_id)를 대상으로 한 경우의 대상 PK."
        }
      },
      "description": "ai_ecommerce_report 테이블의 신고 건 갱신 시 사용하는 갱신(PUT/UPDATE)용 타입.\n\n사유(reason), 상태(status), 처리 관리자 UUID(resolved_by_id), 상세코멘트/추가설명, 처리완료시각, 논리적 삭제 등 신고 처리 및 완료, 정정 등 워크플로우에 필요한 필드를 포함한다.\n\n필드별 null 허용 및 워크플로우 상태별 필수여부는 업무정책/컴플라이언스 요구사항에 따름.",
      "required": [
        "status"
      ]
    },
    "IModerationAction.IRequest": {
      "type": "object",
      "properties": {
        "administrator_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "조치 기록을 남긴 관리자(actor) UUID. 필터 조건으로 사용. null은 미지정/전체."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "조치 기록을 남긴 관리자(actor) UUID. 필터 조건으로 사용. null은 미지정/전체."
            }
          ],
          "description": "조치 기록을 남긴 관리자(actor) UUID. 필터 조건으로 사용. null은 미지정/전체."
        },
        "action_type": {
          "oneOf": [
            {
              "type": "string",
              "description": "필터링할 조치 유형. 예: 'delete', 'revert', 'warn', 'block'. 시스템이 정의한 enum 값만 허용. null은 전체."
            },
            {
              "type": "null",
              "description": "필터링할 조치 유형. 예: 'delete', 'revert', 'warn', 'block'. 시스템이 정의한 enum 값만 허용. null은 전체."
            }
          ],
          "description": "필터링할 조치 유형. 예: 'delete', 'revert', 'warn', 'block'. 시스템이 정의한 enum 값만 허용. null은 전체."
        },
        "target_comment_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "조치 대상이 된 댓글(comment) UUID. null이면 전체 혹은 미지정."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "조치 대상이 된 댓글(comment) UUID. null이면 전체 혹은 미지정."
            }
          ],
          "description": "조치 대상이 된 댓글(comment) UUID. null이면 전체 혹은 미지정."
        },
        "target_review_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "조치 대상이 된 리뷰(review) UUID. null이면 전체 혹은 미지정."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "조치 대상이 된 리뷰(review) UUID. null이면 전체 혹은 미지정."
            }
          ],
          "description": "조치 대상이 된 리뷰(review) UUID. null이면 전체 혹은 미지정."
        },
        "target_thread_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "조치 대상이 된 포럼/쓰레드(thread) UUID."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "조치 대상이 된 포럼/쓰레드(thread) UUID."
            }
          ],
          "description": "조치 대상이 된 포럼/쓰레드(thread) UUID."
        },
        "created_at_from": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "조치 발생일시(from). 필터링용 시작 시점. ISO 8601 date-time. null은 제한 없음."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "조치 발생일시(from). 필터링용 시작 시점. ISO 8601 date-time. null은 제한 없음."
            }
          ],
          "description": "조치 발생일시(from). 필터링용 시작 시점. ISO 8601 date-time. null은 제한 없음."
        },
        "created_at_to": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "조치 발생일시(to). 필터링용 종료 시점. ISO 8601 date-time. null은 제한 없음."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "조치 발생일시(to). 필터링용 종료 시점. ISO 8601 date-time. null은 제한 없음."
            }
          ],
          "description": "조치 발생일시(to). 필터링용 종료 시점. ISO 8601 date-time. null은 제한 없음."
        },
        "reversed": {
          "oneOf": [
            {
              "type": "boolean",
              "description": "조치의 반전(취소/재개) 여부. True: 취소됨, False/Null: 정상."
            },
            {
              "type": "null",
              "description": "조치의 반전(취소/재개) 여부. True: 취소됨, False/Null: 정상."
            }
          ],
          "description": "조치의 반전(취소/재개) 여부. True: 취소됨, False/Null: 정상."
        },
        "rationale": {
          "oneOf": [
            {
              "type": "string",
              "description": "조치의 사유(사유 키워드, 상세 설명 등)에서의 키워드·fulltext 검색 조건."
            },
            {
              "type": "null",
              "description": "조치의 사유(사유 키워드, 상세 설명 등)에서의 키워드·fulltext 검색 조건."
            }
          ],
          "description": "조치의 사유(사유 키워드, 상세 설명 등)에서의 키워드·fulltext 검색 조건."
        },
        "page": {
          "oneOf": [
            {
              "type": "integer",
              "format": "int32",
              "description": "페이지 번호(기본은 1, null 또는 1이 1페이지)."
            },
            {
              "type": "null",
              "format": "int32",
              "description": "페이지 번호(기본은 1, null 또는 1이 1페이지)."
            }
          ],
          "description": "페이지 번호(기본은 1, null 또는 1이 1페이지)."
        },
        "limit": {
          "oneOf": [
            {
              "type": "integer",
              "format": "int32",
              "description": "페이지 크기(기본 30~100)."
            },
            {
              "type": "null",
              "format": "int32",
              "description": "페이지 크기(기본 30~100)."
            }
          ],
          "description": "페이지 크기(기본 30~100)."
        },
        "sort": {
          "oneOf": [
            {
              "type": "string",
              "description": "정렬 컬럼명(예: 'created_at', 'action_type'). null이면 기본값."
            },
            {
              "type": "null",
              "description": "정렬 컬럼명(예: 'created_at', 'action_type'). null이면 기본값."
            }
          ],
          "description": "정렬 컬럼명(예: 'created_at', 'action_type'). null이면 기본값."
        }
      },
      "description": "ai_ecommerce_moderation_action 테이블(혹은 materialized view)의 검색/목록 요청 DTO.\n\n조치 대상 식별자, 관리자 식별자, 조치 유형, 작성 일자/기간, 반전여부, 조치사유 등의 필드를 조합해, 필터 및 페이징 가능한 요청 페이로드를 정의한다.",
      "required": []
    },
    "IModerationAction": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "ai_ecommerce_moderation_action PK, 고유 식별자."
        },
        "administrator_id": {
          "type": "string",
          "format": "uuid",
          "description": "조치한 관리자 UUID."
        },
        "comment_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "조치 대상 댓글(comment) UUID."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "조치 대상 댓글(comment) UUID."
            }
          ],
          "description": "조치 대상 댓글(comment) UUID."
        },
        "review_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "조치 대상 리뷰(review) UUID."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "조치 대상 리뷰(review) UUID."
            }
          ],
          "description": "조치 대상 리뷰(review) UUID."
        },
        "thread_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "조치 대상 포럼/쓰레드(thread) UUID."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "조치 대상 포럼/쓰레드(thread) UUID."
            }
          ],
          "description": "조치 대상 포럼/쓰레드(thread) UUID."
        },
        "action_type": {
          "type": "string",
          "description": "조치 유형. 시스템에서 지원하는 enum 값(예: delete, revert)"
        },
        "rationale": {
          "type": "string",
          "description": "조치 또는 반전 사유(조치 시행/취소 이유)."
        },
        "reversed": {
          "type": "boolean",
          "description": "조치 반전(해제) 여부. true: 조치 취소됨."
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "조치 생성(시행/기록) 시각 (UTC ISO8601)"
        },
        "reversed_at": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "조치 반전 시각(취소, 해제된 경우)."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "조치 반전 시각(취소, 해제된 경우)."
            }
          ],
          "description": "조치 반전 시각(취소, 해제된 경우)."
        },
        "deleted_at": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "조치 기록 논리삭제 일시(null=존재)."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "조치 기록 논리삭제 일시(null=존재)."
            }
          ],
          "description": "조치 기록 논리삭제 일시(null=존재)."
        }
      },
      "required": [
        "id",
        "administrator_id",
        "action_type",
        "rationale",
        "reversed",
        "created_at"
      ],
      "description": "모더레이션(community moderation) 액션의 상세 엔티티 타입.\n\n커뮤니티 콘텐츠(댓글/리뷰/포럼)에 대한 관리자 조치 결과를 모두 기록하며, 조치 사유(rationale), 조치유형, 반전여부, 생성일시, 반전일시 등이 포함된다."
    },
    "IModerationAction.ICreate": {
      "type": "object",
      "properties": {
        "administrator_id": {
          "type": "string",
          "format": "uuid",
          "description": "조치 집행 관리자(필수) UUID. 반드시 존재하는 관리자 레코드여야 함."
        },
        "comment_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "조치 대상 댓글 PK. 선택적."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "조치 대상 댓글 PK. 선택적."
            }
          ],
          "description": "조치 대상 댓글 PK. 선택적."
        },
        "review_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "조치 대상 리뷰 연구. 선택적."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "조치 대상 리뷰 연구. 선택적."
            }
          ],
          "description": "조치 대상 리뷰 연구. 선택적."
        },
        "thread_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "조치 대상 포럼/쓰레드 UUID. 선택적."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "조치 대상 포럼/쓰레드 UUID. 선택적."
            }
          ],
          "description": "조치 대상 포럼/쓰레드 UUID. 선택적."
        },
        "action_type": {
          "type": "string",
          "description": "조치 유형. 예: 'delete', 'block', 'warn', 'revert' 등 시스템 내 enum 집합 중 하나."
        },
        "rationale": {
          "type": "string",
          "description": "필수 - 관리자에 의한 조치/반전 사유 설명."
        }
      },
      "description": "커뮤니티 모더레이션(관리자 조치) 신규 생성용 DTO.\n\n조치 대상(comment/review/thread), 집행 관리자, 조치 유형, 사유 등 모두 필수. 대상은 1종만 선택.",
      "required": [
        "administrator_id",
        "action_type",
        "rationale"
      ]
    },
    "IModerationAction.IUpdate": {
      "type": "object",
      "properties": {
        "rationale": {
          "type": "string",
          "description": "관리자 조치/반전을 위한 변경 메시지."
        },
        "reversed": {
          "type": "boolean",
          "description": "조치 반전(취소) 여부를 true로 변경 시에만 True, 반전 기록시 필수 입력."
        }
      },
      "description": "모더레이션 액션(관리자 조치)의 갱신용 DTO(업데이트). 조치 반전, 사유 갱신 등. 반전시 reversed: true, 사유(rationale) 갱신. 둘 다 동시에 갱신 입력 가능.\n\n재조치(Undo, revert)·추가코멘트·사유노트 등의 목적.",
      "required": []
    },
    "IPageIModerationAction": {
      "type": "object",
      "properties": {
        "pagination": {
          "$ref": "#/components/schemas/IPage.IPagination"
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/IModerationAction"
          },
          "description": "해당 페이지의 조치 로그(액션) 리스트."
        }
      },
      "required": [
        "pagination",
        "data"
      ],
      "description": "커뮤니티 모더레이션 액션 결과의 페이지네이션 컨테이너. 페이징, 총합, 조치 로그 리스트가 포함됨.\n\nIPage 구조 준수."
    },
    "IInquirySnapshot.IRequest": {
      "type": "object",
      "properties": {
        "inquiry_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "스냅샷 대상 inquiry PK(UUID). null이면 전체."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "스냅샷 대상 inquiry PK(UUID). null이면 전체."
            }
          ],
          "description": "스냅샷 대상 inquiry PK(UUID). null이면 전체."
        },
        "captured_by_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "히스토리를 기록한 주체(고객/시스템) PK. null은 전체 or 미지정."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "히스토리를 기록한 주체(고객/시스템) PK. null은 전체 or 미지정."
            }
          ],
          "description": "히스토리를 기록한 주체(고객/시스템) PK. null은 전체 or 미지정."
        },
        "status": {
          "oneOf": [
            {
              "type": "string",
              "description": "스냅샷 상태 필터. 내부 워크플로우 enum 집합 따라 적용."
            },
            {
              "type": "null",
              "description": "스냅샷 상태 필터. 내부 워크플로우 enum 집합 따라 적용."
            }
          ],
          "description": "스냅샷 상태 필터. 내부 워크플로우 enum 집합 따라 적용."
        },
        "created_at_from": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "스냅샷 생성 시각(from). 필터용 기간 시작."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "스냅샷 생성 시각(from). 필터용 기간 시작."
            }
          ],
          "description": "스냅샷 생성 시각(from). 필터용 기간 시작."
        },
        "created_at_to": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "스냅샷 생성 시각(to). 기간 종료 필터."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "스냅샷 생성 시각(to). 기간 종료 필터."
            }
          ],
          "description": "스냅샷 생성 시각(to). 기간 종료 필터."
        },
        "snapshot_reason": {
          "oneOf": [
            {
              "type": "string",
              "description": "스냅샷 사유(키워드/풀텍스트) 검색."
            },
            {
              "type": "null",
              "description": "스냅샷 사유(키워드/풀텍스트) 검색."
            }
          ],
          "description": "스냅샷 사유(키워드/풀텍스트) 검색."
        },
        "page": {
          "oneOf": [
            {
              "type": "integer",
              "format": "int32",
              "description": "페이지 번호(1-base)"
            },
            {
              "type": "null",
              "format": "int32",
              "description": "페이지 번호(1-base)"
            }
          ],
          "description": "페이지 번호(1-base)"
        },
        "limit": {
          "oneOf": [
            {
              "type": "integer",
              "format": "int32",
              "description": "페이지 크기(기본 30~100)"
            },
            {
              "type": "null",
              "format": "int32",
              "description": "페이지 크기(기본 30~100)"
            }
          ],
          "description": "페이지 크기(기본 30~100)"
        },
        "sort": {
          "oneOf": [
            {
              "type": "string",
              "description": "정렬 필드명. null이면 기본값."
            },
            {
              "type": "null",
              "description": "정렬 필드명. null이면 기본값."
            }
          ],
          "description": "정렬 필드명. null이면 기본값."
        }
      },
      "description": "ai_ecommerce_inquiry_snapshot(문의 기록 이력) 조건형 검색/페이지네이션 요청 DTO. inquiry_id별, 날짜별, 작업자별 등 복합필터 제공. 페이징·정렬 지원.",
      "required": []
    },
    "IPageIInquirySnapshot": {
      "type": "object",
      "properties": {
        "pagination": {
          "$ref": "#/components/schemas/IPage.IPagination"
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/IInquirySnapshot"
          },
          "description": "문의 이력(스냅샷) 리스트"
        }
      },
      "description": "ai_ecommerce_inquiry_snapshot의 페이지네이션 결과 반환 컨테이너. 페이징과 inquiry 이력 리스트를 포함.\n\nIPage 구조 준수.",
      "required": [
        "pagination",
        "data"
      ]
    },
    "IInquirySnapshot": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "PK: inquiry 스냅샷 레코드 고유 식별자"
        },
        "inquiry_id": {
          "type": "string",
          "format": "uuid",
          "description": "스냅샷이 생성된 원본 inquiry PK(UUID)."
        },
        "captured_by_id": {
          "type": "string",
          "format": "uuid",
          "description": "이력을 캡처한 주체(고객 PK 또는 시스템 actor PK)."
        },
        "title": {
          "type": "string",
          "description": "기록 시점의 inquiry 제목"
        },
        "body": {
          "type": "string",
          "description": "스냅샷 시점의 inquiry 본문/내용"
        },
        "status": {
          "type": "string",
          "description": "변경 직후 inquiry의 상태(enum: open, closed 등)"
        },
        "snapshot_reason": {
          "type": "string",
          "description": "스냅샷 생성 사유, 예: 'edit', 'status change', 'rollback'"
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "스냅샷 캡처(생성) 일시(UTC ISO8601)"
        }
      },
      "required": [
        "id",
        "inquiry_id",
        "captured_by_id",
        "title",
        "body",
        "status",
        "snapshot_reason",
        "created_at"
      ],
      "description": "문의글(inquiry) 이력(스냅샷) 레코드 단일 엔티티 타입.\n\n각 inquiry별 편집, 상태변경 등 시점의 전체 정보 기록. 원본 inquiry PK, 캡처 주체, snapshot 적용 시점의 모든 필드 포함."
    },
    "IInquirySnapshot.ICreate": {
      "type": "object",
      "properties": {
        "inquiry_id": {
          "type": "string",
          "format": "uuid",
          "description": "이력 스냅샷을 저장할 실제 inquiry의 UUID(PK)"
        },
        "captured_by_id": {
          "type": "string",
          "format": "uuid",
          "description": "스냅샷 캡처를 Triger한 actor/custome PK"
        },
        "title": {
          "type": "string",
          "description": "기록 시 title"
        },
        "body": {
          "type": "string",
          "description": "기록 시 body"
        },
        "status": {
          "type": "string",
          "description": "스냅샷 시 workflow 상태(enum)"
        },
        "snapshot_reason": {
          "type": "string",
          "description": "스냅샷 생성 사유"
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "스냅샷 시각(UTC ISO8601)"
        }
      },
      "required": [
        "inquiry_id",
        "captured_by_id",
        "title",
        "body",
        "status",
        "snapshot_reason",
        "created_at"
      ],
      "description": "inquiry(문의) 이력 스냅샷 신규 생성용 DTO. PK 제외 inquiry_id, 캡처자, 당시 title/body/status/이유/일시 모두 필요"
    },
    "IInquirySnapshot.IUpdate": {
      "type": "object",
      "properties": {
        "snapshot_reason": {
          "type": "string",
          "description": "스냅샷의 현재 상태에 대한 추가 설명/사유를 변경할 경우."
        }
      },
      "description": "스냅샷 레코드의 snapshot_reason만(관리자에 의한 정정, 설명 추가 등) 갱신하는 패치 DTO.",
      "required": []
    },
    "Iai_ecommerceReviewSnapshot.IRequest": {
      "type": "object",
      "properties": {
        "review_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "스냅샷의 원본 review 고유 PK(UUID). null 입력 시 전체 대상."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "스냅샷의 원본 review 고유 PK(UUID). null 입력 시 전체 대상."
            }
          ],
          "description": "스냅샷의 원본 review 고유 PK(UUID). null 입력 시 전체 대상."
        },
        "captured_by_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "스냅샷 생성자 PK. null이면 미필터."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "스냅샷 생성자 PK. null이면 미필터."
            }
          ],
          "description": "스냅샷 생성자 PK. null이면 미필터."
        },
        "status": {
          "oneOf": [
            {
              "type": "string",
              "description": "해당 스냅샷의 상태(예: 'active', 'archived', 'deleted' 등)"
            },
            {
              "type": "null",
              "description": "해당 스냅샷의 상태(예: 'active', 'archived', 'deleted' 등)"
            }
          ],
          "description": "해당 스냅샷의 상태(예: 'active', 'archived', 'deleted' 등)"
        },
        "rating": {
          "oneOf": [
            {
              "type": "integer",
              "format": "int32",
              "description": "이 시점의 별점 점수(0~5 등), null이면 무관."
            },
            {
              "type": "null",
              "format": "int32",
              "description": "이 시점의 별점 점수(0~5 등), null이면 무관."
            }
          ],
          "description": "이 시점의 별점 점수(0~5 등), null이면 무관."
        },
        "created_at_from": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "스냅샷 생성 기준(from) 일시"
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "스냅샷 생성 기준(from) 일시"
            }
          ],
          "description": "스냅샷 생성 기준(from) 일시"
        },
        "created_at_to": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "생성 기간 끝(to) 일시"
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "생성 기간 끝(to) 일시"
            }
          ],
          "description": "생성 기간 끝(to) 일시"
        },
        "snapshot_reason": {
          "oneOf": [
            {
              "type": "string",
              "description": "스냅샷 생성/변경 사유 키워드"
            },
            {
              "type": "null",
              "description": "스냅샷 생성/변경 사유 키워드"
            }
          ],
          "description": "스냅샷 생성/변경 사유 키워드"
        },
        "page": {
          "oneOf": [
            {
              "type": "integer",
              "format": "int32",
              "description": "페이지 번호(1-base)"
            },
            {
              "type": "null",
              "format": "int32",
              "description": "페이지 번호(1-base)"
            }
          ],
          "description": "페이지 번호(1-base)"
        },
        "limit": {
          "oneOf": [
            {
              "type": "integer",
              "format": "int32",
              "description": "페이지 크기(서비스 기본값 30~100)"
            },
            {
              "type": "null",
              "format": "int32",
              "description": "페이지 크기(서비스 기본값 30~100)"
            }
          ],
          "description": "페이지 크기(서비스 기본값 30~100)"
        },
        "sort": {
          "oneOf": [
            {
              "type": "string",
              "description": "정렬 필드/기준"
            },
            {
              "type": "null",
              "description": "정렬 필드/기준"
            }
          ],
          "description": "정렬 필드/기준"
        }
      },
      "description": "ai_ecommerce_review_snapshot 테이블 검색/목록 요청 DTO. 원본 리뷰, 생성자, 상태, 평점, 기간 등 복합 필터와 페이징, 정렬 지원.",
      "required": []
    },
    "IPageIai_ecommerceReviewSnapshot": {
      "type": "object",
      "properties": {
        "pagination": {
          "$ref": "#/components/schemas/IPage.IPagination",
          "description": "Pagination information for the result set. Refer to standard IPage pagination contract.\n\nThis object contains the current page, limit, record count, and page count per IPage documentation."
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/Iai_ecommerceReviewSnapshot"
          },
          "description": "Array of ai_ecommerce_review_snapshot records for the current page of results.\n\nEach item represents a historical, append-only snapshot of a review from the audit/history table."
        }
      },
      "required": [
        "pagination",
        "data"
      ],
      "description": "Paginated list container for AI E-Commerce review snapshots (ai_ecommerce_review_snapshot).\n\nEach response represents a page of historical, immutable records for review state changes, suitable for rollback, audit, or compliance reporting. See Iai_ecommerceReviewSnapshot for individual item schema."
    },
    "Iai_ecommerceReviewSnapshot": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "The unique identifier for this review snapshot record.\n\nReferences the ai_ecommerce_review_snapshot table's primary key."
        },
        "review_id": {
          "type": "string",
          "format": "uuid",
          "description": "The id of the associated review entity being snapshotted.\n\nForeign key to ai_ecommerce_review."
        },
        "captured_by_id": {
          "type": "string",
          "format": "uuid",
          "description": "Who triggered the snapshot (customer's user id or system actor).\n\nReferences ai_ecommerce_customer."
        },
        "title": {
          "oneOf": [
            {
              "type": "string",
              "description": "The review title at the time of snapshot, or null if review at that point had no title."
            },
            {
              "type": "null",
              "description": "The review title at the time of snapshot, or null if review at that point had no title."
            }
          ],
          "description": "The review title at the time of snapshot, or null if review at that point had no title."
        },
        "body": {
          "type": "string",
          "description": "The full text body of the review at the historical snapshot point.\n\nReferencing ai_ecommerce_review_snapshot.body."
        },
        "rating": {
          "type": "integer",
          "description": "Historical rating value of the review (integer score at snapshot)."
        },
        "status": {
          "type": "string",
          "description": "State of the review at snapshot, e.g., 'active', 'deleted', or other values set at that point in history.\n\nField comes from ai_ecommerce_review_snapshot.status."
        },
        "snapshot_reason": {
          "type": "string",
          "description": "Text explanation why this snapshot was taken. E.g. 'edit', 'moderation', 'rollback'.\n\nReferencing ai_ecommerce_review_snapshot.snapshot_reason."
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp of when the snapshot was created (ISO 8601, UTC)."
        }
      },
      "required": [
        "id",
        "review_id",
        "captured_by_id",
        "body",
        "rating",
        "status",
        "snapshot_reason",
        "created_at"
      ],
      "description": "Immutable historical snapshot of a review entity for audit, rollback, and compliance in AI E-commerce.\n\nCaptures all mutable review state at a given time (title/body/rating/status) and attaches an actor/reason/timestamp for traceability."
    },
    "Iai_ecommerceReviewSnapshot.ICreate": {
      "type": "object",
      "properties": {
        "review_id": {
          "type": "string",
          "format": "uuid",
          "description": "Review entity this snapshot captures (FK to ai_ecommerce_review)."
        },
        "captured_by_id": {
          "type": "string",
          "format": "uuid",
          "description": "ID of the user who triggered this snapshot, or system actor (FK to ai_ecommerce_customer)."
        },
        "title": {
          "oneOf": [
            {
              "type": "string",
              "description": "Review title at this point (nullable for title-absent reviews)."
            },
            {
              "type": "null",
              "description": "Review title at this point (nullable for title-absent reviews)."
            }
          ],
          "description": "Review title at this point (nullable for title-absent reviews)."
        },
        "body": {
          "type": "string",
          "description": "Body text for the review at this snapshot."
        },
        "rating": {
          "type": "integer",
          "description": "Integer review rating at time of snapshot."
        },
        "status": {
          "type": "string",
          "description": "Review workflow/state at this snapshot point (e.g., 'active', 'deleted')."
        },
        "snapshot_reason": {
          "type": "string",
          "description": "Explanation for why the snapshot is taken ('edit', 'moderation', etc)."
        }
      },
      "required": [
        "review_id",
        "captured_by_id",
        "body",
        "rating",
        "status",
        "snapshot_reason"
      ],
      "description": "Request body for creating a new review snapshot in ai_ecommerce_review_snapshot.\n\nFields mirror main entity but with nullable title—see schema for role in audit/rollback."
    },
    "Iai_ecommerceReviewSnapshot.IUpdate": {
      "type": "object",
      "properties": {
        "title": {
          "oneOf": [
            {
              "type": "string",
              "description": "If supplied, updates the review's snapshot title (nullable for old no-title reviews)."
            },
            {
              "type": "null",
              "description": "If supplied, updates the review's snapshot title (nullable for old no-title reviews)."
            }
          ],
          "description": "If supplied, updates the review's snapshot title (nullable for old no-title reviews)."
        },
        "body": {
          "type": "string",
          "description": "Updates the snapshot body text, replaces previous content."
        },
        "rating": {
          "type": "integer",
          "description": "Historical review rating at this update."
        },
        "status": {
          "type": "string",
          "description": "Workflow status at snapshot after update."
        },
        "snapshot_reason": {
          "type": "string",
          "description": "Reason code for updating the snapshot record."
        }
      },
      "required": [],
      "description": "Update object for review snapshot entity.\n\nRarely used except for compliance or audit correction. Only mutable fields may be supplied. Immutable fields (ids, actor, created_at) cannot be changed."
    },
    "IPageIai_ecommerceCart": {
      "type": "object",
      "properties": {
        "pagination": {
          "$ref": "#/components/schemas/IPage.IPagination",
          "description": "Pagination metadata: page, limit, total records, etc. See IPage standard doc for detail."
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/Iai_ecommerceCart"
          },
          "description": "Array of cart records for this page."
        }
      },
      "required": [
        "pagination",
        "data"
      ],
      "description": "Paginated page result for shopping carts.\n\nEach response represents a slice of current cart records and pagination info."
    },
    "Iai_ecommerceCart": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "Cart unique identifier. Always required (PK of ai_ecommerce_cart)."
        },
        "customer_id": {
          "type": "string",
          "format": "uuid",
          "description": "FK to ai_ecommerce_customer who owns this cart."
        },
        "device_context": {
          "oneOf": [
            {
              "type": "string",
              "description": "Details about the device or session context for this cart (nullable).\n\nHelps support recovery and merge flows; can be device fingerprint or 'guest', etc."
            },
            {
              "type": "null",
              "description": "Details about the device or session context for this cart (nullable).\n\nHelps support recovery and merge flows; can be device fingerprint or 'guest', etc."
            }
          ],
          "description": "Details about the device or session context for this cart (nullable).\n\nHelps support recovery and merge flows; can be device fingerprint or 'guest', etc."
        },
        "cart_status": {
          "type": "string",
          "description": "Logical cart state: 'active', 'merged', 'expired', etc. Must align with business logic and API usage."
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp (ISO 8601, UTC) when cart was created."
        },
        "updated_at": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp when the cart was last updated."
        },
        "deleted_at": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "If set, the datetime (ISO 8601) when this cart was logically deleted. Null if still active."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "If set, the datetime (ISO 8601) when this cart was logically deleted. Null if still active."
            }
          ],
          "description": "If set, the datetime (ISO 8601) when this cart was logically deleted. Null if still active."
        }
      },
      "required": [
        "id",
        "customer_id",
        "cart_status",
        "created_at",
        "updated_at"
      ],
      "description": "Top-level cart entity for AI E-commerce shopping mall; represents a shoppable container session per customer/device, not including its content/items.\n\nThis record is used for device sync, recovered sessions, and is referenced in order creation."
    },
    "Iai_ecommerceCart.ICreate": {
      "type": "object",
      "properties": {
        "customer_id": {
          "type": "string",
          "format": "uuid",
          "description": "FK to ai_ecommerce_customer; must be active/valid for cart creation."
        },
        "device_context": {
          "oneOf": [
            {
              "type": "string",
              "description": "Device/session context or identifier (nullable)."
            },
            {
              "type": "null",
              "description": "Device/session context or identifier (nullable)."
            }
          ],
          "description": "Device/session context or identifier (nullable)."
        },
        "cart_status": {
          "type": "string",
          "description": "Initial state of the new cart ('active', etc.)."
        }
      },
      "required": [
        "customer_id",
        "cart_status"
      ],
      "description": "Cart creation request payload for initializing new shopping cart entity."
    },
    "Iai_ecommerceCart.IUpdate": {
      "type": "object",
      "properties": {
        "device_context": {
          "oneOf": [
            {
              "type": "string",
              "description": "If supplied, new device/session descriptor (null resets context)."
            },
            {
              "type": "null",
              "description": "If supplied, new device/session descriptor (null resets context)."
            }
          ],
          "description": "If supplied, new device/session descriptor (null resets context)."
        },
        "cart_status": {
          "type": "string",
          "description": "Change cart state (e.g., 'merged', 'expired', 'active')."
        }
      },
      "required": [],
      "description": "Update body for shopping cart mutations. Only mutable fields permitted."
    },
    "Iai_ecommerceCartItem.IRequest": {
      "type": "object",
      "properties": {
        "cart_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Filter: limit to a particular cart (FK). Null disables filter."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Filter: limit to a particular cart (FK). Null disables filter."
            }
          ],
          "description": "Filter: limit to a particular cart (FK). Null disables filter."
        },
        "sku_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Filter: only items matching this SKU (FK to sku)."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Filter: only items matching this SKU (FK to sku)."
            }
          ],
          "description": "Filter: only items matching this SKU (FK to sku)."
        },
        "added_after": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "Filter: Only items added after this datetime (for incremental sync/reporting).\n\nFormat: ISO 8601, UTC. Null disables filter."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "Filter: Only items added after this datetime (for incremental sync/reporting).\n\nFormat: ISO 8601, UTC. Null disables filter."
            }
          ],
          "description": "Filter: Only items added after this datetime (for incremental sync/reporting).\n\nFormat: ISO 8601, UTC. Null disables filter."
        }
      },
      "required": [],
      "description": "Search/filter parameters for retrieving cart items from ai_ecommerce_cart_item. All fields are optional."
    },
    "IPageIai_ecommerceCartItem": {
      "type": "object",
      "properties": {
        "pagination": {
          "$ref": "#/components/schemas/IPage.IPagination",
          "description": "Pagination, page, record count, etc."
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/IAiEcommerceCartItem"
          },
          "description": "Array of cart item records for this page."
        }
      },
      "required": [
        "pagination",
        "data"
      ],
      "description": "Paginated page of cart items (ai_ecommerce_cart_item entities)."
    },
    "IAiEcommerceCartItem": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "Cart item unique id (PK)."
        },
        "cart_id": {
          "type": "string",
          "format": "uuid",
          "description": "Parent cart FK."
        },
        "sku_id": {
          "type": "string",
          "format": "uuid",
          "description": "Referencing specific SKU product."
        },
        "quantity": {
          "type": "integer",
          "description": "How many of the SKU in the cart item; must be 1 or more."
        },
        "added_at": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp item added to cart (ISO 8601, UTC)."
        },
        "updated_at": {
          "type": "string",
          "format": "date-time",
          "description": "Last time this item's state was updated."
        }
      },
      "required": [
        "id",
        "cart_id",
        "sku_id",
        "quantity",
        "added_at",
        "updated_at"
      ],
      "description": "Atomic cart item row: one product (SKU) and quantity held in a particular cart, for session/purchase purposes. See ai_ecommerce_cart_item table for relationships."
    },
    "Iai_ecommerceCart.IRequest": {
      "type": "object",
      "properties": {
        "customer_id": {
          "type": "string",
          "format": "uuid",
          "description": "고객 식별자입니다.\n\nai_ecommerce_cart 테이블에서 cart와 연결된 고객의 UUID 문자열입니다. 고객별로 카트 상태를 필터링하거나 특정 고객의 카트만 조회할 때 사용합니다."
        },
        "device_context": {
          "oneOf": [
            {
              "type": "string",
              "description": "디바이스/세션 컨텍스트입니다.\n\n고객의 카트를 구분하는 데 활용되는 세션 또는 디바이스 식별용 문자열입니다. 예: 브라우저 지문, 장치 UUID 등. 입력하지 않으면 모든 디바이스의 카트를 조회합니다."
            },
            {
              "type": "null",
              "description": "디바이스/세션 컨텍스트입니다.\n\n고객의 카트를 구분하는 데 활용되는 세션 또는 디바이스 식별용 문자열입니다. 예: 브라우저 지문, 장치 UUID 등. 입력하지 않으면 모든 디바이스의 카트를 조회합니다."
            }
          ],
          "description": "디바이스/세션 컨텍스트입니다.\n\n고객의 카트를 구분하는 데 활용되는 세션 또는 디바이스 식별용 문자열입니다. 예: 브라우저 지문, 장치 UUID 등. 입력하지 않으면 모든 디바이스의 카트를 조회합니다."
        },
        "cart_status": {
          "oneOf": [
            {
              "type": "string",
              "description": "카트 상태값 필터링입니다.\n\n예: 'active', 'merged', 'expired' 등. ai_ecommerce_cart 모델 내 cart_status 컬럼 값 중 일부로 필터링할 때 사용합니다. 전달하지 않을 경우 전체 또는 기타 조건에 의한 카트들도 포함됩니다."
            },
            {
              "type": "null",
              "description": "카트 상태값 필터링입니다.\n\n예: 'active', 'merged', 'expired' 등. ai_ecommerce_cart 모델 내 cart_status 컬럼 값 중 일부로 필터링할 때 사용합니다. 전달하지 않을 경우 전체 또는 기타 조건에 의한 카트들도 포함됩니다."
            }
          ],
          "description": "카트 상태값 필터링입니다.\n\n예: 'active', 'merged', 'expired' 등. ai_ecommerce_cart 모델 내 cart_status 컬럼 값 중 일부로 필터링할 때 사용합니다. 전달하지 않을 경우 전체 또는 기타 조건에 의한 카트들도 포함됩니다."
        },
        "created_at_range": {
          "type": "object",
          "properties": {
            "from": {
              "oneOf": [
                {
                  "type": "string",
                  "format": "date-time",
                  "description": "조회 시작일 (ISO8601)"
                },
                {
                  "type": "null",
                  "format": "date-time",
                  "description": "조회 시작일 (ISO8601)"
                }
              ],
              "description": "조회 시작일 (ISO8601)"
            },
            "to": {
              "oneOf": [
                {
                  "type": "string",
                  "format": "date-time",
                  "description": "조회 종료일 (ISO8601)"
                },
                {
                  "type": "null",
                  "format": "date-time",
                  "description": "조회 종료일 (ISO8601)"
                }
              ],
              "description": "조회 종료일 (ISO8601)"
            }
          },
          "required": [],
          "description": "카트 생성일 범위 필터링 조건 객체\n\nfrom에는 검색 시작일, to에는 종료일을 ISO 8601로 입력합니다."
        },
        "updated_at_range": {
          "type": "object",
          "properties": {
            "from": {
              "oneOf": [
                {
                  "type": "string",
                  "format": "date-time",
                  "description": "수정일 필터 시작시각 (ISO8601)"
                },
                {
                  "type": "null",
                  "format": "date-time",
                  "description": "수정일 필터 시작시각 (ISO8601)"
                }
              ],
              "description": "수정일 필터 시작시각 (ISO8601)"
            },
            "to": {
              "oneOf": [
                {
                  "type": "string",
                  "format": "date-time",
                  "description": "수정일 필터 종료시각 (ISO8601)"
                },
                {
                  "type": "null",
                  "format": "date-time",
                  "description": "수정일 필터 종료시각 (ISO8601)"
                }
              ],
              "description": "수정일 필터 종료시각 (ISO8601)"
            }
          },
          "required": [],
          "description": "카트 최신 수정일 범위 필터링 객체\n\n수정일의 범위를 제한하여 조회할 때 from~to 값을 ISO 8601 형식으로 구성."
        },
        "deleted_at": {
          "oneOf": [
            {
              "type": "boolean",
              "description": "삭제 여부입니다.\n\n소프트 삭제된 카트를 조회할지 여부를 결정합니다. true면 deleted_at이 null이 아닌 행만, false면 null인 행만, null이면 전체를 봅니다."
            },
            {
              "type": "null",
              "description": "삭제 여부입니다.\n\n소프트 삭제된 카트를 조회할지 여부를 결정합니다. true면 deleted_at이 null이 아닌 행만, false면 null인 행만, null이면 전체를 봅니다."
            }
          ],
          "description": "삭제 여부입니다.\n\n소프트 삭제된 카트를 조회할지 여부를 결정합니다. true면 deleted_at이 null이 아닌 행만, false면 null인 행만, null이면 전체를 봅니다."
        },
        "pagination": {
          "$ref": "#/components/schemas/IPage.IRequest"
        },
        "sort": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "field": {
                "type": "string",
                "description": "정렬 필드명 (예: created_at, updated_at 등)"
              },
              "direction": {
                "oneOf": [
                  {
                    "const": "asc",
                    "description": "정렬 방향 (asc|desc)"
                  },
                  {
                    "const": "desc",
                    "description": "정렬 방향 (asc|desc)"
                  }
                ],
                "description": "정렬 방향 (asc|desc)"
              }
            },
            "required": [
              "field",
              "direction"
            ]
          },
          "description": "정렬 조건 지정. [{field, direction}] 구조의 복수 배열로 지정하여 다중 필드 정렬 지원. 예: created_at desc, updated_at asc 등."
        }
      },
      "required": [],
      "description": "ai_ecommerce_cart 테이블의 카트 리스트 조회, 검색, 필터, 페이징에 쓰이는 요청 객체\n\n고객별/디바이스별 카트 필터, 카트 상태 조건, 생성/수정 범위, 페이징(meta) 정보, 정렬 정보 등 다양한 쿼리 옵션을 지정할 수 있습니다.\n\n카트의 'id', 'customer_id', 'device_context', 'cart_status', 'created_at', 'updated_at', 'deleted_at' 등 컬럼 기준으로 상세한 조회 조건을 지원합니다.\n\ndeleted_at 필터로 소프트 삭제 여부 구분 가능하고, pagination/sort로 결과 페이징 및 정렬을 제어합니다."
    },
    "IAiEcommerceCartItem.ICreate": {
      "type": "object",
      "description": "데이터베이스 테이블 ai_ecommerce_cart_item의 행을 생성하는 데 사용되는 생성 요청 객체입니다.\n\n각 카트 아이템은 카트 내의 특정 SKU(제품 옵션 조합)를 나타내며 SKU와 카트에 대한 외래 키를 포함하고 있습니다. 수량 필드는 이 카트 아이템에 대한 구매 수량을 지정합니다. 추가/업데이트 타임스탬프는 생성 시 시스템에서 자동으로 기록됩니다.\n\n비즈니스 규칙상, 동일한 SKU를 여러 번 추가할 경우 별도의 행으로 추가하는 대신 수량을 증가시켜야 합니다. 각 요청은 필수적으로 cart_id, sku_id, quantity를 포함해야 하며, ID(기본 키)는 자동 생성됩니다.",
      "properties": {
        "cart_id": {
          "type": "string",
          "format": "uuid",
          "description": "카트(장바구니) PK(UUID). 이 아이템이 소속된 카트의 id. ai_ecommerce_cart.id를 참조합니다."
        },
        "sku_id": {
          "type": "string",
          "format": "uuid",
          "description": "SKU(제품 옵션)의 PK(UUID). 어떤 상품/옵션 조합이 추가되었는지 나타냅니다. ai_ecommerce_sku.id를 참조합니다."
        },
        "quantity": {
          "type": "integer",
          "description": "구매하려는 수량(0 이상).\n기본적으로 1 이상이어야 하며 재고/지정 옵션의 수량에 따라 제한될 수 있음.",
          "minimum": 1
        }
      },
      "required": [
        "cart_id",
        "sku_id",
        "quantity"
      ]
    },
    "IAiEcommerceCartItem.IUpdate": {
      "type": "object",
      "description": "ai_ecommerce_cart_item의 기존 행을 수정하는 요청 객체.\n\n일반적으로 quantity(수량)만 변경 가능하며, 기타 수정 가능한 필드는 도메인에 따라 결정됩니다. sku_id의 변경은 불가(별도 추가 및 삭제 절차 필요). updated_at은 본 API 호출 시 시스템에서 자동으로 변경됩니다.",
      "properties": {
        "quantity": {
          "type": "integer",
          "description": "수정하려는 카트 아이템의 수량. 1 이상이어야 하며, 재고/비즈니스 규칙에 따라 제한됨."
        }
      },
      "required": [
        "quantity"
      ]
    },
    "IDeleteResult": {
      "type": "object",
      "description": "삭제(또는 소프트 삭제) 연산 결과를 반환하는 표준 응답 타입입니다.\n\nid(대상 행 PK), deleted(성공 여부), deleted_at(삭제 시각) 등으로 구성되며, 실제 삭제 방식(논리삭제, 물리삭제)에 따라 속성은 달라질 수 있습니다.",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "삭제(소프트 또는 하드)된 대상 entity의 PK(UUID)."
        },
        "deleted": {
          "type": "boolean",
          "description": "실제 삭제(True), 삭제 실패(False), 이미 삭제됨(상태로 반환)등을 구분."
        },
        "deleted_at": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "삭제가 성공적으로 진행된 경우 실행/기록된 삭제 시각(ISO8601). 영구 삭제이거나 삭제가 되지 않은 경우 null."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "삭제가 성공적으로 진행된 경우 실행/기록된 삭제 시각(ISO8601). 영구 삭제이거나 삭제가 되지 않은 경우 null."
            }
          ],
          "description": "삭제가 성공적으로 진행된 경우 실행/기록된 삭제 시각(ISO8601). 영구 삭제이거나 삭제가 되지 않은 경우 null."
        }
      },
      "required": [
        "id",
        "deleted"
      ]
    },
    "IAiEcommerceOrder.IRequest": {
      "type": "object",
      "description": "주문(order) 리스트 조회, 필터링 및 페이징을 위한 요청 파라미터 객체입니다. ai_ecommerce_order 테이블의 여러 행을 다양한 조건으로 검색할 때 사용합니다.\n\n고객 및 관리자용 화면에서 본 API 타입을 활용해 주문/구매내역 리스트를 검색할 수 있습니다. 주요 필터 필드는 주문상태, 고객ID, 주문/생성일, 카트/배송지 등이 될 수 있습니다.",
      "properties": {
        "customer_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "조회하려는 주문의 소유자(고객) PK. 고객조회 화면 등에서 사용. null 허용시 전체 고객/관리자 검색."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "조회하려는 주문의 소유자(고객) PK. 고객조회 화면 등에서 사용. null 허용시 전체 고객/관리자 검색."
            }
          ],
          "description": "조회하려는 주문의 소유자(고객) PK. 고객조회 화면 등에서 사용. null 허용시 전체 고객/관리자 검색."
        },
        "order_status": {
          "oneOf": [
            {
              "type": "string",
              "description": "주문 상태로 필터링. 예: pending, paid, shipped, delivered, cancelled 등. null이면 모든 상태 검색."
            },
            {
              "type": "null",
              "description": "주문 상태로 필터링. 예: pending, paid, shipped, delivered, cancelled 등. null이면 모든 상태 검색."
            }
          ],
          "description": "주문 상태로 필터링. 예: pending, paid, shipped, delivered, cancelled 등. null이면 모든 상태 검색."
        },
        "placed_from": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "조회 시작일(==주문 생성일 범위 시작) ISO 8601."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "조회 시작일(==주문 생성일 범위 시작) ISO 8601."
            }
          ],
          "description": "조회 시작일(==주문 생성일 범위 시작) ISO 8601."
        },
        "placed_to": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "조회 종료일(==주문 생성일 범위 끝) ISO 8601."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "조회 종료일(==주문 생성일 범위 끝) ISO 8601."
            }
          ],
          "description": "조회 종료일(==주문 생성일 범위 끝) ISO 8601."
        },
        "cart_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "특정 장바구니(cart)로 생성된 주문만 검색할 때 사용."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "특정 장바구니(cart)로 생성된 주문만 검색할 때 사용."
            }
          ],
          "description": "특정 장바구니(cart)로 생성된 주문만 검색할 때 사용."
        },
        "shipping_address_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "특정 배송지 기준 주문만 필터링."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "특정 배송지 기준 주문만 필터링."
            }
          ],
          "description": "특정 배송지 기준 주문만 필터링."
        },
        "order_channel": {
          "oneOf": [
            {
              "type": "string",
              "description": "주문채널(앱, 웹 등)로 필터링. null 가능."
            },
            {
              "type": "null",
              "description": "주문채널(앱, 웹 등)로 필터링. null 가능."
            }
          ],
          "description": "주문채널(앱, 웹 등)로 필터링. null 가능."
        },
        "limit": {
          "type": "integer",
          "description": "페이지 네이션 시 페이지 크기(최대 레코드 수), 예: 20"
        },
        "offset": {
          "type": "integer",
          "description": "페이지 네이션 시작점(기록 시작 위치), 예: 0"
        },
        "sort_key": {
          "oneOf": [
            {
              "type": "string",
              "description": "정렬 기준 key(placed_at, order_status 등)"
            },
            {
              "type": "null",
              "description": "정렬 기준 key(placed_at, order_status 등)"
            }
          ],
          "description": "정렬 기준 key(placed_at, order_status 등)"
        },
        "sort_order": {
          "oneOf": [
            {
              "const": "asc",
              "description": "정렬 순: asc(오름차순), desc(내림차순) 중 하나 또는 null."
            },
            {
              "const": "desc",
              "description": "정렬 순: asc(오름차순), desc(내림차순) 중 하나 또는 null."
            },
            {
              "type": "null",
              "enum": [
                "asc",
                "desc",
                null
              ],
              "description": "정렬 순: asc(오름차순), desc(내림차순) 중 하나 또는 null."
            }
          ],
          "description": "정렬 순: asc(오름차순), desc(내림차순) 중 하나 또는 null."
        }
      },
      "required": [
        "limit",
        "offset"
      ]
    },
    "IPageIAiEcommerceOrder": {
      "type": "object",
      "description": "ai_ecommerce_order 목록 페이징 응답 표준 타입. 데이터 리스트 + 페이징 메타 정보를 포함합니다.\n\n실제로는 records(주문 배열), pagination, total_count 등 정보가 표준 구조로 반환됩니다.",
      "properties": {
        "records": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/IAiEcommerceOrder"
          },
          "description": "주문 레코드 배열"
        },
        "pagination": {
          "type": "object",
          "description": "페이징 정보(현 페이지, 페이지 크기, 전체 개수 등)",
          "properties": {
            "current": {
              "type": "integer",
              "description": "현재 페이지 번호"
            },
            "limit": {
              "type": "integer",
              "description": "페이지 당 최대 레코드 수"
            },
            "records": {
              "type": "integer",
              "description": "총 레코드 수"
            },
            "pages": {
              "type": "integer",
              "description": "총 페이지 수(ceil(records/limit))"
            }
          },
          "required": [
            "current",
            "limit",
            "records",
            "pages"
          ]
        },
        "total_count": {
          "type": "integer",
          "description": "전체 주문 레코드 수(검색조건 기준)"
        }
      },
      "required": [
        "records",
        "pagination",
        "total_count"
      ]
    },
    "IAiEcommerceOrder": {
      "type": "object",
      "description": "ai_ecommerce_order 단일 주문 객체 타입입니다. 모든 주문 상세 필드(기본키, 고객, 카트, 배송지, 상태, 타임스탬프 등)를 포함합니다.\n\n이 타입은 데이터베이스의 ai_ecommerce_order 행 전체의 JSON 직렬화 사양이기도 하며, 주문수정, 상세조회에서 활용됩니다.",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "주문(기본키, UUID)."
        },
        "customer_id": {
          "type": "string",
          "format": "uuid",
          "description": "주문한 고객 PK(ai_ecommerce_customer.id)."
        },
        "cart_id": {
          "type": "string",
          "format": "uuid",
          "description": "이 주문을 유도한 카트(PK, ai_ecommerce_cart.id)"
        },
        "shipping_address_id": {
          "type": "string",
          "format": "uuid",
          "description": "배송지 주소 PK(ai_ecommerce_user_address.id)"
        },
        "order_status": {
          "type": "string",
          "description": "주문 상태. 예: pending, paid, shipped, delivered, cancelled."
        },
        "order_channel": {
          "oneOf": [
            {
              "type": "string",
              "description": "주문 채널(웹, 앱 등). null 허용."
            },
            {
              "type": "null",
              "description": "주문 채널(웹, 앱 등). null 허용."
            }
          ],
          "description": "주문 채널(웹, 앱 등). null 허용."
        },
        "placed_at": {
          "type": "string",
          "format": "date-time",
          "description": "주문 생성 시각(결제/체크아웃 시점, ISO8601)."
        },
        "updated_at": {
          "type": "string",
          "format": "date-time",
          "description": "수정/상태변경 등 마지막 편집 시각."
        },
        "deleted_at": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "논리삭제 시각(null=미삭제)"
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "논리삭제 시각(null=미삭제)"
            }
          ],
          "description": "논리삭제 시각(null=미삭제)"
        },
        "items": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/IAiEcommerceOrderItem"
          },
          "description": "주문에 포함된 각각의 아이템(다수, SKU 단위)"
        },
        "payment_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "결제 정보(테이블 미정), 실제 DB/링크 구현에 따라 nullable"
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "결제 정보(테이블 미정), 실제 DB/링크 구현에 따라 nullable"
            }
          ],
          "description": "결제 정보(테이블 미정), 실제 DB/링크 구현에 따라 nullable"
        },
        "shipment_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "배송 정보(테이블 미정), 실제 DB/링크 구현에 따라 nullable"
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "배송 정보(테이블 미정), 실제 DB/링크 구현에 따라 nullable"
            }
          ],
          "description": "배송 정보(테이블 미정), 실제 DB/링크 구현에 따라 nullable"
        }
      },
      "required": [
        "id",
        "customer_id",
        "cart_id",
        "shipping_address_id",
        "order_status",
        "placed_at",
        "updated_at",
        "items"
      ]
    },
    "IAiEcommerceOrder.ICreate": {
      "type": "object",
      "description": "ai_ecommerce_order 주문 신규 생성시 사용되는 요청 타입입니다.\n\n필수 입력값: 구매자/카트/배송지/주문채널, 아이템 리스트 등. 생성 후 주문 PK와 상태 등이 반환됩니다. 여러 연관 테이블(ai_ecommerce_cart, ... 등) FK 및 주문 필수 항목은 서버 상에서 관계 무결성 체크, 생성시점 자동타임스탬프 부여됨.",
      "properties": {
        "customer_id": {
          "type": "string",
          "format": "uuid",
          "description": "구매자 PK"
        },
        "cart_id": {
          "type": "string",
          "format": "uuid",
          "description": "주문 소스 카트 PK"
        },
        "shipping_address_id": {
          "type": "string",
          "format": "uuid",
          "description": "배송지 주소 PK"
        },
        "order_status": {
          "type": "string",
          "description": "최초 주문 상태. 예: pending(대기), paid(결제완료) 등"
        },
        "order_channel": {
          "oneOf": [
            {
              "type": "string",
              "description": "주문 채널(예: app, web, ...)."
            },
            {
              "type": "null",
              "description": "주문 채널(예: app, web, ...)."
            }
          ],
          "description": "주문 채널(예: app, web, ...)."
        },
        "items": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/IAiEcommerceOrderItem.ICreate"
          },
          "description": "주문에 포함될 SKU 목록 및 수량."
        }
      },
      "required": [
        "customer_id",
        "cart_id",
        "shipping_address_id",
        "order_status",
        "items"
      ]
    },
    "IAiEcommerceOrder.IUpdate": {
      "type": "object",
      "description": "ai_ecommerce_order의 기존 주문을 수정할 때 사용하는 요청 타입입니다. 수정 가능한 필드는 상태(order_status), 배송지, 채널 등. 불변 값(id, customer, cart)는 수정 불가. 상태/주소 등만 선택적으로 변경할 수 있습니다.",
      "properties": {
        "order_status": {
          "type": "string",
          "description": "주문 상태 수정(예: pending, paid, shipped, delivered, cancelled)"
        },
        "shipping_address_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "배송지 주소 변경 가능"
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "배송지 주소 변경 가능"
            }
          ],
          "description": "배송지 주소 변경 가능"
        },
        "order_channel": {
          "oneOf": [
            {
              "type": "string",
              "description": "주문 채널 변경"
            },
            {
              "type": "null",
              "description": "주문 채널 변경"
            }
          ],
          "description": "주문 채널 변경"
        }
      },
      "required": [
        "order_status"
      ]
    },
    "IAiEcommerceOrderItem.IRequest": {
      "type": "object",
      "description": "주문 아이템(행) 단위 페이징/검색용 요청 타입. 주로 order_id, sku_id에 따라 검색하는데 사용합니다.\n\nlimit/offset 등 표준 페이징 필드와 함께 order_id, sku_id, 기간 범위 등 필드 추가 가능.",
      "properties": {
        "order_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "특정 주문 행의 PK"
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "특정 주문 행의 PK"
            }
          ],
          "description": "특정 주문 행의 PK"
        },
        "sku_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "특정 주문의 SKU(PK)"
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "특정 주문의 SKU(PK)"
            }
          ],
          "description": "특정 주문의 SKU(PK)"
        },
        "from": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "포함 아이템 생성일 범위(시작일, ISO8601 datetime)"
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "포함 아이템 생성일 범위(시작일, ISO8601 datetime)"
            }
          ],
          "description": "포함 아이템 생성일 범위(시작일, ISO8601 datetime)"
        },
        "to": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "포함 아이템 생성일 범위(종료일)"
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "포함 아이템 생성일 범위(종료일)"
            }
          ],
          "description": "포함 아이템 생성일 범위(종료일)"
        },
        "limit": {
          "type": "integer",
          "description": "페이지 최대 추출 행"
        },
        "offset": {
          "type": "integer",
          "description": "페이징 시작 행"
        }
      },
      "required": [
        "limit",
        "offset"
      ]
    },
    "IPageIAiEcommerceOrderItem": {
      "type": "object",
      "description": "주문 아이템(행) 목록/페이징 표준 응답 타입. 전체 카운트, 오프셋, 페이지, 각 레코드 목록 포함.",
      "properties": {
        "records": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/IAiEcommerceOrderItem"
          },
          "description": "주문아이템 레코드 배열"
        },
        "pagination": {
          "type": "object",
          "description": "페이징 메타데이터 (현재 페이지, 페이지당 크기 등)",
          "properties": {
            "current": {
              "type": "integer"
            },
            "limit": {
              "type": "integer"
            },
            "records": {
              "type": "integer"
            },
            "pages": {
              "type": "integer"
            }
          },
          "required": [
            "current",
            "limit",
            "records",
            "pages"
          ]
        },
        "total_count": {
          "type": "integer",
          "description": "검색 기준 전체 행 수"
        }
      },
      "required": [
        "records",
        "pagination",
        "total_count"
      ]
    },
    "IAiEcommerceOrderItem": {
      "type": "object",
      "description": "ai_ecommerce_order_item DB 테이블의 단일 행(주문 내 SKU 단위 상품 행).\n\n주문 PK, SKU PK, 수량, 주문 시점, 생성/변경 타임스탬프 등 포함. 주문 상세/이력/장바구니 복원 분석 등에 사용.",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "아이템 PK/UUID(행별 고유식별자)"
        },
        "order_id": {
          "type": "string",
          "format": "uuid",
          "description": "이 아이템이 소속된 주문 PK(uuid)"
        },
        "sku_id": {
          "type": "string",
          "format": "uuid",
          "description": "이 아이템의 SKU(제품옵션) PK(uuid)"
        },
        "quantity": {
          "type": "integer",
          "description": "주문한 수량(1 이상)"
        },
        "ordered_at": {
          "type": "string",
          "format": "date-time",
          "description": "이 아이템이 주문에 포함된 시점(placing) ISO8601"
        }
      },
      "required": [
        "id",
        "order_id",
        "sku_id",
        "quantity",
        "ordered_at"
      ]
    },
    "IAiEcommerceOrderItem.ICreate": {
      "type": "object",
      "description": "주문시 주문 아이템(SKU 및 수량) 삽입용 요청 타입.\n\nSKU PK 및 수량 필드 필요. 여러 개의 SKU를 주문하는 경우 배열로 여러 번 호출할 수 있음. order_id는 ai_ecommerce_order 생성시 자동 연결되므로 입력에는 불필요(부모 order 참조)",
      "properties": {
        "sku_id": {
          "type": "string",
          "format": "uuid",
          "description": "주문하려는 SKU의 PK(uuid)"
        },
        "quantity": {
          "type": "integer",
          "description": "구매/주문하려는 수량(1 이상)",
          "minimum": 1
        }
      },
      "required": [
        "sku_id",
        "quantity"
      ]
    },
    "IAiEcommerceOrderItem.IUpdate": {
      "type": "object",
      "properties": {
        "sku_id": {
          "type": "string",
          "format": "uuid",
          "description": "SKU ID를 변경할 수 있습니다. 주문 항목의 SKU를 새로운 SKU로 교체할 때 사용하며, ai_ecommerce_order_item의 sku_id입니다. 반드시 관련 SKU가 존재해야 하며, 제품 옵션 변경/재고 오류 수정 시 활용됩니다. 변경 시 중복 및 재고 유효성을 검사하며, 관계 무결성이 중요합니다.\n\nai_ecommerce_order_item Prisma 컬럼인 'sku_id'에 대응합니다. 수정이 필요한 SKU 교체 상황에서 사용될 수 있습니다."
        },
        "quantity": {
          "type": "integer",
          "description": "주문 항목의 구매 수량을 수정할 때 사용됩니다. ai_ecommerce_order_item의 quantity 컬럼에 해당하며, 필수 값은 아니나 주문 내역의 오타/고객 요청/수량 조정 등에 필요합니다. 0보다 커야 하며, 재고 및 환불 정책 등 비즈니스 규칙을 준수해야 합니다.\n\nPrisma DB의 quantity 컬럼 설명을 따라 사용합니다."
        }
      },
      "required": [
        "sku_id"
      ],
      "description": "주문 항목(ai_ecommerce_order_item)의 수정(업데이트) 요청 타입입니다. 이 타입은 SKU 또는 수량 등 필드를 변경할 때 사용되며, ai_ecommerce_order_item 모델의 필드와 대응됩니다.\n\nSKU 교체, 수량 수정 등이 주 목적이며, 각 필드는 Prisma DB 컬럼 설명을 충실히 따릅니다. 일부 필드는 상황에 따라 선택적으로 입력할 수 있습니다."
    },
    "IAiEcommerceOrderItem.IDeleteResult": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "삭제된 주문 항목(ai_ecommerce_order_item)의 PK(ID) 값입니다. 삭제 작업이 정상적으로 진행된 항목의 식별자이며, 결과 확인 및 후속 트랜잭션 진행에 참고됩니다. Prisma 스키마의 id 컬럼을 참조합니다."
        },
        "deleted": {
          "type": "boolean",
          "description": "삭제 성공 여부를 표시합니다. true이면 정상적으로 삭제(혹은 소프트삭제)된 상태임을 나타내며, 실제로 영구 삭제/논리 삭제 정책에 맞게 처리된 결과입니다. 시스템의 실제 삭제/소프트삭제 정책을 반영해 안내문구/후처리에 활용될 수 있습니다."
        },
        "message": {
          "type": "string",
          "description": "(옵션) 삭제 처리에 대한 상세 설명 또는 결과 메시지입니다. 에러/특이사항이 있거나, 추가 처리 권고, 이미 삭제된 항목 안내 등 다양한 삭제 상태와 연관된 설명이 제공됩니다. 정책 및 서비스 플로우별 메시지가 동적으로 제공될 수 있습니다. Prisma 스키마에는 없지만 반환 객체 실무 활용상 포함합니다."
        }
      },
      "required": [
        "id",
        "deleted"
      ],
      "description": "주문 항목(ai_ecommerce_order_item) 삭제 작업의 반환 결과 타입. 요청한 주문 항목이 정상적으로 삭제(논리/실제) 및 후처리 되었음을 식별합니다.\n\nid, 삭제여부, 추가 메시지 등을 포함하여 반환합니다. 실제 DB 스키마에는 없지만, API/서비스 응답 패턴에서 활용할 수 있도록 구성합니다."
    },
    "IAiEcommercePayment.IRequest": {
      "type": "object",
      "properties": {
        "status": {
          "type": "string",
          "description": "결제 상태(status) 필터링에 사용합니다. 예: 'pending', 'completed', 'cancelled' 등. 결제 상태별 목록 조회 시 사용합니다. Prisma의 status 컬럼 설명 및 상태 값과 일치해야 합니다.\n\n필터 조건이 선택적으로 포함될 수 있습니다."
        },
        "provider": {
          "type": "string",
          "description": "결제 제공자(provider) 필터링용 속성입니다. 'stripe', 'paypal', '토스' 등 결제 공급자별 결제 내역을 조회할 때 유용합니다. Prisma의 provider 컬럼 의미를 따릅니다.\n\n선택값이며, 관리/운영/회계 조사 시 많이 사용됨."
        },
        "order_id": {
          "type": "string",
          "format": "uuid",
          "description": "결제와 연관된 주문(order)의 UUID입니다. 결제 목록을 특정 주문별로 필터할 때 사용합니다. ai_ecommerce_payment에는 직접 FK가 없는 경우도 있으나, 연관 API에서 order_id를 키로 활용할 수 있어 포함합니다."
        },
        "page": {
          "type": "integer",
          "description": "페이지네이션 요청 시 사용되는 페이지 번호(Field: page). 기본값 및 최댓값 정책은 서비스 구현에 맞춰 조정할 수 있습니다. 기본값: 1."
        },
        "limit": {
          "type": "integer",
          "description": "페이지네이션 요청 시 한 페이지에 포함될 항목 수(Field: limit). 과도한 조회 쿼리 방지, 프론트엔드 리밋 설정 등 제어 용도. 기본값: 20~100(서비스 정책 적용)."
        }
      },
      "required": [],
      "description": "결제 목록 조회/검색/필터링 시 사용되는 요청 타입입니다. ai_ecommerce_payment 스키마의 status, provider 등 컬럼 기준과 일치하며, 검색(필터), 페이지네이션, 연관 주문번호 조회 등 다양한 조회 조건을 지원합니다.\n\n각 필드는 옵션이며, 검색 조건이 없는 경우 전체 결제 목록을 반환할 수 있습니다."
    },
    "IPageIAiEcommercePayment": {
      "type": "object",
      "properties": {
        "pagination": {
          "$ref": "#/components/schemas/IPage.IPagination"
        },
        "data": {
          "type": "array",
          "description": "실제 결제 데이터의 배열입니다. 각 항목은 결제 레코드에 해당하며, IAiEcommercePayment 타입이 기본 단위입니다.",
          "items": {
            "$ref": "#/components/schemas/IAiEcommercePayment"
          }
        }
      },
      "required": [
        "pagination",
        "data"
      ],
      "description": "결제 목록 페이징 컨테이너. IPage 표준 구조에 따라, 페이지네이션 메타정보(pagination)와 결제 데이터 배열(data; 결제 단건 레코드 IAiEcommercePayment 객체들)로 구성됩니다.\n\nPrisma DB에서 page 쿼리 결과를 래핑하거나, 목록형 응답/API 표준화에 필수적입니다."
    },
    "IAiEcommercePayment": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "결제 메인 테이블(ai_ecommerce_payment)의 PK(ID)입니다. 결제 트랜잭션별 고유 식별자이며, 생성시 자동 할당됩니다. 타 엔티티의 FK타입으로도 사용됩니다. Prisma의 id 컬럼을 참조합니다."
        },
        "amount": {
          "type": "number",
          "description": "결제(또는 환불/충전 등)된 금액을 더블형 숫자로 표기합니다. 원화 등 통화별로 해석됩니다. 결제 금액 단위별 사업 정책을 따르며, 소수점 이하 허용 등 결제 특성에 부합해야 합니다.\n\nPrisma amount(DoublePrecision) 컬럼 설명과 일치합니다."
        },
        "provider": {
          "type": "string",
          "description": "결제 서비스 공급자를 나타냅니다. 'stripe', 'paypal', '카카오페이', '네이버페이' 등 다양한 결제사/공급자명을 영문 소문자로 기입합니다.\n\nPrisma provider 컬럼 정의와 동일하게 입력 및 쿼리, 매출 분석 등에 활용합니다."
        },
        "method": {
          "type": "string",
          "description": "결제수단 구분자입니다. 'card', 'bank_transfer', 'virtual_account', '휴대폰결제' 등 결제수단 영문 이름 또는 키가 저장됩니다. 사업 정책별로 주요 결제수단을 미리 정의할 수 있습니다.\n\nPrisma method 컬럼 값."
        },
        "payment_reference": {
          "oneOf": [
            {
              "type": "string",
              "description": "외부 PG(결제사) 트랜잭션 고유 참고코드(reference)입니다. PG 연동 결과의 KEY를 저장하거나, 외부 결제 승인번호/토큰 등으로 활용합니다. Prisma의 payment_reference 컬럼 nullable 특성에 부합합니다."
            },
            {
              "type": "null",
              "description": "외부 PG(결제사) 트랜잭션 고유 참고코드(reference)입니다. PG 연동 결과의 KEY를 저장하거나, 외부 결제 승인번호/토큰 등으로 활용합니다. Prisma의 payment_reference 컬럼 nullable 특성에 부합합니다."
            }
          ],
          "description": "외부 PG(결제사) 트랜잭션 고유 참고코드(reference)입니다. PG 연동 결과의 KEY를 저장하거나, 외부 결제 승인번호/토큰 등으로 활용합니다. Prisma의 payment_reference 컬럼 nullable 특성에 부합합니다."
        },
        "status": {
          "type": "string",
          "description": "결제 상태값. 'pending', 'completed', 'failed', 'cancelled' 등 서비스 내 상태/이력관리용으로 사용합니다. Prisma status 컬럼 정의를 따라, 워크플로우/분류/집계 등에 적용됩니다."
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "결제 엔티티 레코드가 생성된 시점을 ISO8601(YYYY-MM-DDTHH:mm:SSZ)로 기록합니다. ai_ecommerce_payment의 created_at DaTimestamptz 필드와 동일. 결제 생성일, 환불 상태 연동일 등 분석, 감사, UI 렌더링에 사용합니다."
        },
        "updated_at": {
          "type": "string",
          "format": "date-time",
          "description": "결제 레코드가 마지막으로 수정된 일시입니다. 결제 취소/환불/상태 변경 시마다 갱신됩니다. ai_ecommerce_payment의 updated_at DaTimestamptz 필드와 동일합니다."
        }
      },
      "required": [
        "id",
        "amount",
        "provider",
        "method",
        "status",
        "created_at",
        "updated_at"
      ],
      "description": "플랫폼 결제 정보 단건 상세 타입(ai_ecommerce_payment 엔티티 전체). 금액, 결제사, 승인참고키, 결제 상태, 생성/수정일 등 모든 요구 필드를 포함.\n\nPrisma 스키마 ai_ecommerce_payment 모델 설명에 준수하며, 결제 내역 상세, 페이징 목록, 관리운영 등에 공통 사용됩니다."
    },
    "IAiEcommercePayment.ICreate": {
      "type": "object",
      "properties": {
        "amount": {
          "type": "number",
          "description": "결제 요청 금액. 결제 생성시 반드시 입력되어야 하는 필수 필드. DoublePrecision 타입이며, 통화 별 금액 단위 규칙(소수/정수 등)을 준수해야 합니다.\n\nPrisma의 amount(DoublePrecision) 컬럼 설명 참고."
        },
        "provider": {
          "type": "string",
          "description": "결제 서비스/공급자 코드 또는 영문명. 'stripe', 'paypal', '카카오페이' 등 결제사 구분에 사용되며, 결제 연동 정책에 따라 정의된 키를 사용해야 합니다.\n\n필수 컬럼으로, Prisma provider 컬럼 규칙을 준수합니다."
        },
        "method": {
          "type": "string",
          "description": "결제수단 식별자. 'card', 'bank_transfer', 'virtual_account', '휴대폰결제' 등 구체적 결제수단 구분명입니다. 프론트엔드 선택값/버튼명과 연관되기도 합니다.\n\nPrisma의 method 컬럼 정의를 그대로 따릅니다."
        },
        "payment_reference": {
          "oneOf": [
            {
              "type": "string",
              "description": "(옵션) 결제 연동 PG사 승인/참고번호, 제3자 결제 생성 시 외부 결제요청 key로 사용됩니다. 중복 불가이며 없으면 null로 세팅합니다. ai_ecommerce_payment의 payment_reference(nullable) 컬럼 설명에 부합합니다."
            },
            {
              "type": "null",
              "description": "(옵션) 결제 연동 PG사 승인/참고번호, 제3자 결제 생성 시 외부 결제요청 key로 사용됩니다. 중복 불가이며 없으면 null로 세팅합니다. ai_ecommerce_payment의 payment_reference(nullable) 컬럼 설명에 부합합니다."
            }
          ],
          "description": "(옵션) 결제 연동 PG사 승인/참고번호, 제3자 결제 생성 시 외부 결제요청 key로 사용됩니다. 중복 불가이며 없으면 null로 세팅합니다. ai_ecommerce_payment의 payment_reference(nullable) 컬럼 설명에 부합합니다."
        },
        "status": {
          "type": "string",
          "description": "결제 생성시 초기 상태를 명시합니다. 일반적으로 'pending', 'requested' 등이 사용될 수 있습니다. 사업 정책에 맞게 미리 정의된 상태를 전달하고, 입력값은 Prisma DB status 컬럼 값과 맞추는 것이 원칙입니다. 기본값이 있을 수 있으나 명시적으로 입력 권장."
        }
      },
      "required": [
        "amount",
        "provider",
        "method",
        "status"
      ],
      "description": "신규 결제 생성 요청시 사용하는 타입입니다. 결제 금액, 공급자, 수단, 상태는 필수이며, 결제 승인번호 등은 최초에는 null이거나, 외부 연동시 지정 가능합니다.\n\nPrisma schema(ai_ecommerce_payment) 컬럼 설명 및 결제사업 구조에 충실하게 설계됩니다."
    },
    "IAiEcommercePayment.IUpdate": {
      "type": "object",
      "properties": {
        "status": {
          "type": "string",
          "description": "결제 상태(status) 값을 업데이트할 때 필수적으로 입력되는 값입니다. 결제처리 상태 변경(결제완료->환불/실패, 등)에 사용합니다. Prisma의 status 컬럼 값과 정합성을 유지해야 하며, 예시: 'completed', 'cancelled', 'refunded' 등."
        },
        "payment_reference": {
          "oneOf": [
            {
              "type": "string",
              "description": "(옵션) 결제 레퍼런스(예: PG사 승인/결제번호) 수정이 필요할 때 사용합니다. 결제 성공 후 PG콜백 등으로 결제 key를 업데이트하는 워크플로우에서 사용합니다. Prisma payment_reference(nullable) 컬럼 설명 참조."
            },
            {
              "type": "null",
              "description": "(옵션) 결제 레퍼런스(예: PG사 승인/결제번호) 수정이 필요할 때 사용합니다. 결제 성공 후 PG콜백 등으로 결제 key를 업데이트하는 워크플로우에서 사용합니다. Prisma payment_reference(nullable) 컬럼 설명 참조."
            }
          ],
          "description": "(옵션) 결제 레퍼런스(예: PG사 승인/결제번호) 수정이 필요할 때 사용합니다. 결제 성공 후 PG콜백 등으로 결제 key를 업데이트하는 워크플로우에서 사용합니다. Prisma payment_reference(nullable) 컬럼 설명 참조."
        }
      },
      "required": [
        "status"
      ],
      "description": "결제 단건(혹은 상태) 업데이트 요청에 사용하는 타입입니다. status(상태)는 결제 승인/완료/환불 등 필요에 따라 필수로 전달, payment_reference는 연동/외부결제에서 값 수정이 필요할 때만 전달 가능합니다.\n\nPrisma ai_ecommerce_payment 스키마의 컬럼 정의와 완전하게 동기화됩니다."
    },
    "IAiEcommercePayment.IDeleteResult": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "삭제(또는 삭제 시도)된 결제(ID) PK입니다. 해당 결제 내역의 고유 식별자에 해당하며, 이후 로깅, 이력관리 등에 사용됩니다. Prisma id 컬럼을 참조합니다."
        },
        "deleted": {
          "type": "boolean",
          "description": "삭제 작업 결과를 표기합니다. true면 결제가 정상적으로 삭제(혹은 소프트삭제)되었음을 의미합니다.\n\n실제 결제 데이터의 삭제 정책(실, 논리 삭제)에 따라 다를 수 있습니다."
        },
        "message": {
          "type": "string",
          "description": "삭제 결과 설명 또는 안내 메시지입니다. 삭제 대상 결제가 이미 삭제된 경우, 외부 장애 발생 등 예외 상황시 사용자 안내/에러 메시지를 포함할 수 있습니다. 실제 스키마 컬럼에는 없지만, API 객체로는 반환될 수 있습니다."
        }
      },
      "required": [
        "id",
        "deleted"
      ],
      "description": "결제 삭제 요청에 따른 API 응답 반환 타입. 삭제 ID, 삭제여부, 상세 메시지 등을 포함합니다. ai_ecommerce_payment 스키마의 영구/논리 삭제 정책을 따릅니다.\n\nid(식별자), deleted(삭제 성공/실패), message(결과/설명)가 주요 속성입니다."
    },
    "IAiEcommerceOrderStatusLog.IRequest": {
      "type": "object",
      "properties": {
        "order_id": {
          "type": "string",
          "format": "uuid",
          "description": "상태 로그를 조회하려는 주문(order)의 고유 ID. ai_ecommerce_order_status_log의 order_id FK 컬럼에 해당합니다. 필터 조건으로 사용됩니다."
        },
        "actor_id": {
          "type": "string",
          "format": "uuid",
          "description": "상태 변경 행위자(고객/판매자/관리자 등)의 UUID. ai_ecommerce_order_status_log의 actor_id 컬럼과 연결."
        },
        "actor_type": {
          "type": "string",
          "description": "상태 변경 행위자의 타입. 'customer', 'seller', 'administrator' 중 하나가 될 수 있습니다. Prisma order_status_log의 actor_type 컬럼. (enum 사용가능)."
        },
        "old_status": {
          "type": "string",
          "description": "변경 전(order_status_log의 old_status) 상태를 필터링할 때 사용."
        },
        "new_status": {
          "type": "string",
          "description": "변경 후(order_status_log의 new_status) 상태를 필터링할 때 사용."
        },
        "from": {
          "type": "string",
          "format": "date-time",
          "description": "이벤트 필터를 위한 시작 시점(이상), ISO 8601 포맷. ai_ecommerce_order_status_log의 changed_at 하한 필터."
        },
        "to": {
          "type": "string",
          "format": "date-time",
          "description": "이벤트 필터를 위한 종료 시점(이하), ISO 8601 포맷. ai_ecommerce_order_status_log의 changed_at 상한."
        },
        "page": {
          "type": "integer",
          "description": "페이지네이션 요청 시 페이지 번호. API 표준 기본: 1."
        },
        "limit": {
          "type": "integer",
          "description": "페이지네이션 요청 시 한 페이지에 포함할 로그 개수. 기본값 및 최댓값은 서비스 정책에 따라 다를 수 있음."
        }
      },
      "required": [],
      "description": "주문 상태 변경 로그(ai_ecommerce_order_status_log) 검색/검색 요청 타입. 주문 ID, 행위자 및 타입, 상태 변경 전후/날짜 등 복수 조건을 복합적으로 사용할 수 있습니다.\n\nPrisma 스키마의 컬럼 설명과 필드명 일치, 페이지네이션 필드 포함."
    },
    "IPageIAiEcommerceOrderStatusLog": {
      "type": "object",
      "properties": {
        "pagination": {
          "$ref": "#/components/schemas/IPage.IPagination"
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/IAiEcommerceOrderStatusLog"
          },
          "description": "페이지 내 반환되는 주문 상태 로그 객체 배열. 각 요소는 ai_ecommerce_order_status_log 단건 레코드로 IOrderStatusLog 타입을 참조합니다."
        }
      },
      "required": [
        "pagination",
        "data"
      ],
      "description": "주문 상태 변동 이력(ai_ecommerce_order_status_log) 페이징/목록 반환 컨테이너. pagination(페이지네이션 정보)과 data(단건 로그 배열)로 구성됩니다. 표준 IPage 구조와 일치.\n\nPrisma DB에서 페이지 단위로 추출된 로그의 리스트 형태 응답을 위해 사용됩니다."
    },
    "IAiEcommerceOrderStatusLog": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "주문 상태 이력(ai_ecommerce_order_status_log)의 PK(ID). 각 상태 로그 단건식별자로, 전체 변경 이력 조회 및 상세 row 조회에 쓰입니다."
        },
        "order_id": {
          "type": "string",
          "format": "uuid",
          "description": "상태 변동 대상 주문(order) FK. ai_ecommerce_order_status_log의 order_id 컬럼(ID)입니다. 해당 변경 이력이 추적하는 주문."
        },
        "old_status": {
          "type": "string",
          "description": "이전 주문 상태값. 예: 'pending' 등. ai_ecommerce_order_status_log의 old_status 컬럼 설명."
        },
        "new_status": {
          "type": "string",
          "description": "변경 후 주문 상태값. 예: 'paid', 'shipped', 'cancelled' 등. ai_ecommerce_order_status_log의 new_status 컬럼과 일치."
        },
        "actor_id": {
          "type": "string",
          "format": "uuid",
          "description": "상태 변동의 주체(고객/판매자/관리자) UUID. ai_ecommerce_order_status_log의 actor_id 컬럼과 일치. 권한 보증 및 이력 관리를 위해 활용."
        },
        "actor_type": {
          "type": "string",
          "description": "행위자 타입. 'customer', 'seller', 'administrator' 중 하나. Prisma order_status_log의 actor_type 컬럼(enum)."
        },
        "changed_at": {
          "type": "string",
          "format": "date-time",
          "description": "해당 상태 변경이 발생한 시점을 ISO8601 문자열로 저장. ai_ecommerce_order_status_log의 changed_at(Timestamptz) 컬럼과 일치. 변경 이력 상세 및 리스트, 감사/분석 등에 사용."
        }
      },
      "required": [
        "id",
        "order_id",
        "old_status",
        "new_status",
        "actor_id",
        "actor_type",
        "changed_at"
      ],
      "description": "주문 상태 변경 기록(ai_ecommerce_order_status_log) 단건 상세 타입. 주문, 상태 변화(전후), 행위자 정보, 이력 시점 등 모든 요구 필드를 포함.\n\nPrisma 스키마의 컬럼/주석 설명을 따르고, 감사/분석/이력관리 등에 필수로 제공되어야 합니다."
    },
    "IAiEcommerceOrderStatusLog.ICreate": {
      "type": "object",
      "properties": {
        "order_id": {
          "type": "string",
          "format": "uuid",
          "description": "상태 변경을 기록할 주문(order)의 고유 PK(FK). ai_ecommerce_order_status_log의 order_id 컬럼. 상태변동 대상 주문을 지정합니다. 필수."
        },
        "old_status": {
          "type": "string",
          "description": "상태 변동 전 주문(order)의 상태 코드. ai_ecommerce_order_status_log old_status 컬럼. 워크플로우 관리, 변경 대상 추적에 필요. 필수."
        },
        "new_status": {
          "type": "string",
          "description": "상태 변동 후 주문 상태 코드. ai_ecommerce_order_status_log new_status 컬럼. 필수."
        },
        "actor_id": {
          "type": "string",
          "format": "uuid",
          "description": "상태 변동 행위자(고객/셀러/관리자) UUID. ai_ecommerce_order_status_log actor_id 컬럼. 감사/기록/워크플로우 트래킹에 필수. 필수."
        },
        "actor_type": {
          "type": "string",
          "description": "행위자 타입 ('customer', 'seller', 'administrator’ 중 하나). ai_ecommerce_order_status_log의 actor_type 컬럼(enum). 필수."
        },
        "changed_at": {
          "type": "string",
          "format": "date-time",
          "description": "변동 시점의 타임스탬프(ISO8601). ai_ecommerce_order_status_log의 changed_at. 주문 상태 변경의 실제 시계열 저장용. 필수."
        }
      },
      "required": [
        "order_id",
        "old_status",
        "new_status",
        "actor_id",
        "actor_type",
        "changed_at"
      ],
      "description": "주문 상태 로그(ai_ecommerce_order_status_log) 생성 요청 타입. 주문, 상태변경 (전/후), 행위자 정보, 변경 시점 필드 전부 필수.\n\nPrisma 스키마 정의 및 컬럼 상세 주석에 따라 완벽히 일치하도록 설계. 신규 이력 추가, 감사/분석 대비 신뢰성 보장."
    },
    "IAiEcommerceOrderStatusLog.IUpdate": {
      "type": "object",
      "description": "This schema defines the structure for updating an order status log entry in the ai_ecommerce_order_status_log table. \n\nTypically used by administrators or privileged fulfillment logic when correcting or annotating order status transitions for compliance, audit, or business process reasons. All fields are atomic and strictly controlled, and only specific fields are allowed to change in typical 3NF design. Most fields, including actor, order linkage, and created_at, are immutable after log creation.\n\nBusiness rule: Only mutable fields permitted by policy (typically correction reason, possibly new status, or special admin-correction notes) should be present here. Attempted patching of immutable fields is forbidden at API/business level.",
      "properties": {
        "new_status": {
          "type": "string",
          "description": "The new order status applied for audit correction or compliance update. Example values might include 'paid', 'shipped', 'delivered', or custom business states. Must adhere to the allowed order status enum or list in the system logic."
        },
        "correction_reason": {
          "type": "string",
          "description": "Free-text or pre-canned explanation for updating/amending this status log, for audit trail clarity. Required for compliance or legal reasons. E.g., 'manual override', 'system correction', 'fraud reversal', etc."
        }
      },
      "required": [
        "new_status"
      ]
    },
    "IAiEcommerceOrderStatusLog.IDeleteResult": {
      "type": "object",
      "description": "Result/confirmation object returned after attempting to delete (or soft-delete) an order status log entry in ai_ecommerce_order_status_log.\n\nUsed by admin, compliance, or automated reconciliation processes to know the outcome of the API attempt. Typical fields include: confirmation boolean or message, the affected log id, and possibly additional status/report fields (such as whether the deletion was soft or hard, timestamp, audit id, etc).",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "The unique identifier (UUID) of the order status log entry that was deleted."
        },
        "success": {
          "type": "boolean",
          "description": "Whether the deletion (soft/hard) was successful."
        },
        "deleted_at": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp at which the deletion occurred. If soft-delete policy, it reflects the deleted_at column value. If hard delete, may be identical to actual DB operation time."
        },
        "message": {
          "type": "string",
          "description": "Additional message or confirmation text regarding the delete operation. Usually human-readable, may specify reason or report compliance rules applied."
        }
      },
      "required": [
        "id",
        "success"
      ]
    },
    "ai_ecommerce_shipment.IRequest": {
      "type": "object",
      "description": "Schema for querying/searching ai_ecommerce_shipment records (fulfillment/shipping units) in a paginated/filterable way.\n\nUsed by warehouse ops, admin dashboards, seller fulfillment, or support tools for querying shipments by status, carrier, shipment date, tracking number, etc. Fields are all atomic and may be combined for compound queries.",
      "properties": {
        "order_id": {
          "type": "string",
          "format": "uuid",
          "description": "Order id for which this shipment was created. Results can be filtered for a specific order."
        },
        "shipping_status": {
          "type": "string",
          "description": "Filters results by shipping status: allowed values are business-specific, e.g., 'pending', 'shipped', 'delivered', 'returned', etc."
        },
        "carrier": {
          "type": "string",
          "description": "Restricts search to a specific carrier (e.g., 'KoreaPost', 'CJ Logistics')."
        },
        "tracking_number": {
          "type": "string",
          "description": "Filter for a specific carrier-provided shipment tracking code."
        },
        "created_at_from": {
          "type": "string",
          "format": "date-time",
          "description": "Start datetime for shipment record creation (inclusive). Useful for date window searches."
        },
        "created_at_to": {
          "type": "string",
          "format": "date-time",
          "description": "End datetime for shipment record creation (inclusive)."
        },
        "limit": {
          "type": "integer",
          "description": "How many records to return per page. Default according to platform standard, e.g., 50."
        },
        "offset": {
          "type": "integer",
          "description": "Offset into full result set for paging."
        }
      },
      "required": []
    },
    "ai_ecommerce_shipment.IPage": {
      "type": "object",
      "description": "Paged result container for shipment search/listing queries. Contains result array, pagination info, and optionally, count metadata.",
      "properties": {
        "data": {
          "type": "array",
          "description": "Array of shipment (ai_ecommerce_shipment) result items for this page.",
          "items": {
            "$ref": "#/components/schemas/ai_ecommerce_shipment"
          }
        },
        "total": {
          "type": "integer",
          "description": "Total number of shipment records matching query (across all pages)."
        },
        "limit": {
          "type": "integer",
          "description": "Count per page used in this response."
        },
        "offset": {
          "type": "integer",
          "description": "Paging offset used to fetch these results."
        }
      },
      "required": [
        "data",
        "total"
      ]
    },
    "ai_ecommerce_shipment": {
      "type": "object",
      "description": "Atomic structure for ai_ecommerce_shipment (fulfillment unit of an order). Represents a single outbound shipment record (tracking, status, carrier) tied to an order. Strict 3NF: no aggregates, all fields required by shipment auditance and business process.\n\nPrimary use cases are order fulfillment, delivery tracking, platform analytics, or support tools.\n\nAlways associated 1:1 with an order. May be referenced by tracking dashboards or logistics partners.",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "Primary key of the shipment record (immutable UUID for compliance referencing)."
        },
        "order_id": {
          "type": "string",
          "format": "uuid",
          "description": "The order this shipment fulfills (FK to ai_ecommerce_order)."
        },
        "carrier": {
          "type": "string",
          "description": "Name of the delivery carrier/vendor. Nullable if unassigned at creation."
        },
        "tracking_number": {
          "type": "string",
          "description": "Carrier's tracking number for shipment. Nullable if not yet assigned/registered."
        },
        "shipping_status": {
          "type": "string",
          "description": "Current status of shipment: e.g., 'pending', 'shipped', 'delivered', 'returned', etc."
        },
        "shipped_at": {
          "type": "string",
          "format": "date-time",
          "description": "Datetime when package was shipped out (nullable until shipped)."
        },
        "delivered_at": {
          "type": "string",
          "format": "date-time",
          "description": "Datetime when shipment confirmed delivered (nullable until delivered)."
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "Time the shipment record was created."
        },
        "updated_at": {
          "type": "string",
          "format": "date-time",
          "description": "Last update timestamp for shipping record/state."
        }
      },
      "required": [
        "id",
        "order_id",
        "shipping_status",
        "created_at",
        "updated_at"
      ]
    },
    "ai_ecommerce_shipment.ICreate": {
      "type": "object",
      "description": "Request body schema for creating a new ai_ecommerce_shipment record. Used by logistics systems, admin/order management back office to register an outbound shipment linked to an order. All required properties ensure 3NF normalization and compliance traceability.",
      "properties": {
        "order_id": {
          "type": "string",
          "format": "uuid",
          "description": "FK to the order being shipped."
        },
        "carrier": {
          "type": "string",
          "description": "Name of carrier/delivery vendor (nullable on creation, but recommended)."
        },
        "tracking_number": {
          "type": "string",
          "description": "Parcel tracking number with carrier (nullable on creation)."
        },
        "shipping_status": {
          "type": "string",
          "description": "Initial shipment status: typically 'pending', 'shipped', etc."
        },
        "shipped_at": {
          "type": "string",
          "format": "date-time",
          "description": "Datetime shipment was shipped (nullable, usually present if status >= 'shipped')."
        },
        "delivered_at": {
          "type": "string",
          "format": "date-time",
          "description": "Datetime shipment was delivered (nullable, only upon delivery confirmation)."
        }
      },
      "required": [
        "order_id",
        "shipping_status"
      ]
    },
    "ai_ecommerce_shipment.IUpdate": {
      "type": "object",
      "description": "Request/patch schema for updating ai_ecommerce_shipment record fields by id. Supports updating mutable shipment fields (status, carrier, tracking info, timestamps). Subject to permissions, audit, and business validation.",
      "properties": {
        "carrier": {
          "type": "string",
          "description": "Delivery carrier/vendor to update (nullable, optional)."
        },
        "tracking_number": {
          "type": "string",
          "description": "Carrier-provided shipment tracking code (nullable, optional)."
        },
        "shipping_status": {
          "type": "string",
          "description": "Status to update: e.g., 'pending', 'shipped', 'delivered', etc. Required when updating status/timestamps."
        },
        "shipped_at": {
          "type": "string",
          "format": "date-time",
          "description": "When the package was shipped (set if updating to >= 'shipped')."
        },
        "delivered_at": {
          "type": "string",
          "format": "date-time",
          "description": "When the package was delivered (set if marking as delivered)."
        }
      },
      "required": [
        "shipping_status"
      ]
    },
    "ai_ecommerce_shipment.IDeleteResult": {
      "type": "object",
      "description": "Confirmation/result object after deleting a shipment. Indicates outcome and effective timestamp (if soft-deleted). Used by admin, fulfillment, or compliance APIs to track successful deletion.",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "Shipment id of the removed record."
        },
        "success": {
          "type": "boolean",
          "description": "True if deletion (soft/hard) was successful."
        },
        "deleted_at": {
          "type": "string",
          "format": "date-time",
          "description": "Deletion timestamp if soft-delete is in effect. May be null for hard deletes or immediate removals."
        },
        "message": {
          "type": "string",
          "description": "Human-readable confirmation or reason for outcome."
        }
      },
      "required": [
        "id",
        "success"
      ]
    },
    "ai_ecommerce_return_request.IRequest": {
      "type": "object",
      "description": "Flexible search/list/filter schema for querying ai_ecommerce_return_request (return/cancellation requests). Filters include status, type, customer/order linkage, reason, and date ranges.",
      "properties": {
        "order_id": {
          "type": "string",
          "format": "uuid",
          "description": "Order to which the return/cancel is attached."
        },
        "customer_id": {
          "type": "string",
          "format": "uuid",
          "description": "Requesting customer id for querying only their requests."
        },
        "status": {
          "type": "string",
          "description": "Return/cancel request status: e.g., 'pending', 'processing', 'completed', 'denied', etc."
        },
        "request_type": {
          "type": "string",
          "description": "Kind of return: e.g., 'return', 'cancellation', etc."
        },
        "reason": {
          "type": "string",
          "description": "Reason code/detail for return/cancellation."
        },
        "created_at_from": {
          "type": "string",
          "format": "date-time",
          "description": "Earliest datetime (inclusive) for request creation."
        },
        "created_at_to": {
          "type": "string",
          "format": "date-time",
          "description": "Latest datetime (inclusive) for request creation."
        },
        "limit": {
          "type": "integer",
          "description": "How many records per page (pagination)."
        },
        "offset": {
          "type": "integer",
          "description": "Offset into result set (pagination)."
        }
      },
      "required": []
    },
    "ai_ecommerce_return_request.IPage": {
      "type": "object",
      "description": "Paged result container for return/cancellation requests. Includes array of result, count, and pagination window info.",
      "properties": {
        "data": {
          "type": "array",
          "description": "Array of return/cancel request objects (ai_ecommerce_return_request) for this page.",
          "items": {
            "$ref": "#/components/schemas/ai_ecommerce_return_request"
          }
        },
        "total": {
          "type": "integer",
          "description": "Total number of matching return/cancel requests, across all pages."
        },
        "limit": {
          "type": "integer",
          "description": "Count per page for this result set."
        },
        "offset": {
          "type": "integer",
          "description": "Offset used for this page."
        }
      },
      "required": [
        "data",
        "total"
      ]
    },
    "ai_ecommerce_return_request": {
      "type": "object",
      "description": "Core entity schema for ai_ecommerce_return_request (return/cancellation workflow). Records all key properties and strict 3NF compliance for auditability, support, and analytics. Fields are atomic; no aggregates or computed totals per DB design.\n\nEach return/cancellation must have an order, customer, type, status, reason (nullable), and status date fields for audit trail. System uses these records for compliance reporting, return/cancel UX, and analytics.",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "Unique per-return/cancellation request. Primary key for referencing this event in downstream workflows."
        },
        "order_id": {
          "type": "string",
          "format": "uuid",
          "description": "Order subject to return/cancellation."
        },
        "customer_id": {
          "type": "string",
          "format": "uuid",
          "description": "Customer submitting this request."
        },
        "status": {
          "type": "string",
          "description": "Workflow status for return/cancel: e.g., 'pending', 'completed', 'processing', etc."
        },
        "request_type": {
          "type": "string",
          "description": "Request variant: 'return', 'cancellation', or business-defined label."
        },
        "reason": {
          "type": "string",
          "description": "Customer or business-provided explanation for return/cancel. May be null."
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "Request creation timestamp."
        },
        "updated_at": {
          "type": "string",
          "format": "date-time",
          "description": "Last update timestamp for this request."
        }
      },
      "required": [
        "id",
        "order_id",
        "customer_id",
        "status",
        "request_type",
        "created_at",
        "updated_at"
      ]
    },
    "ai_ecommerce_return_request.ICreate": {
      "type": "object",
      "description": "Creation schema for new return/cancel request in ai_ecommerce_return_request. Used by end user, admin, or platform logic to initiate a new return/cancel/correction/exception. Strict 3NF: atomic fields only, audit and compliance friendly.\n\nRequired fields: order, customer, type, status. Reason is optional for some business flows.",
      "properties": {
        "order_id": {
          "type": "string",
          "format": "uuid",
          "description": "Order for which return/cancellation is being requested."
        },
        "customer_id": {
          "type": "string",
          "format": "uuid",
          "description": "The customer submitting this request."
        },
        "status": {
          "type": "string",
          "description": "Initial status—typically 'pending' at request creation."
        },
        "request_type": {
          "type": "string",
          "description": "Type of request—e.g., 'return', 'cancellation', etc."
        },
        "reason": {
          "type": "string",
          "description": "Reason for request—optional/nullable."
        }
      },
      "required": [
        "order_id",
        "customer_id",
        "status",
        "request_type"
      ]
    },
    "ai_ecommerce_return_request.IUpdate": {
      "type": "object",
      "description": "Representation of data required to update an existing return or cancellation request within the next-generation, AI-ready shopping mall backend system.\n\nThis type corresponds to fields in the ai_ecommerce_return_request Prisma model. Updates modify request fields such as status, request_type, or reason. Only mutable, business-logic-compliant fields are included; immutable fields such as id, customer_id, and order_id must not be changed. The update operation enforces that only the fields permitted by business rules (e.g., status change, correction of reason) are allowed to update, supporting customer, admin, and support workflows.",
      "properties": {
        "status": {
          "type": "string",
          "description": "The new status for the return or cancellation request. Used to advance the request lifecycle (e.g., pending, approved, denied, completed). Must adhere to allowed business states and transition logic.\n\nDirectly maps to the status column in the ai_ecommerce_return_request Prisma schema."
        },
        "reason": {
          "oneOf": [
            {
              "type": "string",
              "description": "Optional updated explanation or note for why the return/cancellation is being requested. If null, the reason is cleared. Maps to the nullable reason property in the schema and supports various business/AUX scenarios (customer support, dispute resolution, etc.)."
            },
            {
              "type": "null",
              "description": "Optional updated explanation or note for why the return/cancellation is being requested. If null, the reason is cleared. Maps to the nullable reason property in the schema and supports various business/AUX scenarios (customer support, dispute resolution, etc.)."
            }
          ],
          "description": "Optional updated explanation or note for why the return/cancellation is being requested. If null, the reason is cleared. Maps to the nullable reason property in the schema and supports various business/AUX scenarios (customer support, dispute resolution, etc.)."
        }
      },
      "required": [
        "status"
      ]
    },
    "ai_ecommerce_return_request.IDeleteResult": {
      "type": "object",
      "description": "Result or confirmation object returned after deleting (soft-delete or full delete) a return/cancellation request entry in the ai_ecommerce_return_request table. Used to indicate whether the delete operation succeeded, and if so, provide the resulting (soft-deleted) object or status description.\n\nUseful for clients to check that a delete operation was applied and the new logical state of the record.",
      "properties": {
        "success": {
          "type": "boolean",
          "description": "Indicates if the delete/soft-delete operation was successful. True if the request is now deleted, false otherwise."
        },
        "deletedAt": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "Timestamp when the return/cancellation request was marked as deleted (soft-deleted). Null if the operation failed or record not yet deleted."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "Timestamp when the return/cancellation request was marked as deleted (soft-deleted). Null if the operation failed or record not yet deleted."
            }
          ],
          "description": "Timestamp when the return/cancellation request was marked as deleted (soft-deleted). Null if the operation failed or record not yet deleted."
        },
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "UUID of the deleted return/cancellation request."
        }
      },
      "required": [
        "success",
        "id"
      ]
    },
    "ai_ecommerce_coupon.IRequest": {
      "type": "object",
      "description": "Request/query type for searching, filtering, or paginating ai_ecommerce_coupon records (platform or seller-issued coupons) in the shopping mall backend.\n\nThis supports Dashboards, Wallets, and Administrative coupon management, following business rules in the Prisma schema. Used with PATCH endpoints to allow strongly-typed, structured queries, such as filtering by status, code, date ranges, customer_id, seller_id, active state, expiration date, and discount_rule_id.",
      "properties": {
        "customer_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Reference to the coupon's owner customer. Optional; if supplied, filter results to coupons owned by this customer ID."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Reference to the coupon's owner customer. Optional; if supplied, filter results to coupons owned by this customer ID."
            }
          ],
          "description": "Reference to the coupon's owner customer. Optional; if supplied, filter results to coupons owned by this customer ID."
        },
        "seller_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Reference to the issuing seller if the coupon is seller-issued. Optional; filter coupons to this seller if present."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Reference to the issuing seller if the coupon is seller-issued. Optional; filter coupons to this seller if present."
            }
          ],
          "description": "Reference to the issuing seller if the coupon is seller-issued. Optional; filter coupons to this seller if present."
        },
        "discount_rule_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Reference to the discount rule definition that this coupon uses. Optional; filter by coupon's rule type."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Reference to the discount rule definition that this coupon uses. Optional; filter by coupon's rule type."
            }
          ],
          "description": "Reference to the discount rule definition that this coupon uses. Optional; filter by coupon's rule type."
        },
        "code": {
          "oneOf": [
            {
              "type": "string",
              "description": "Coupon code string. Optional; filter for coupons matching or similar to this code."
            },
            {
              "type": "null",
              "description": "Coupon code string. Optional; filter for coupons matching or similar to this code."
            }
          ],
          "description": "Coupon code string. Optional; filter for coupons matching or similar to this code."
        },
        "is_active": {
          "oneOf": [
            {
              "type": "boolean",
              "description": "Whether only active (available for redemption) coupons should be included. Null means do not filter by active state."
            },
            {
              "type": "null",
              "description": "Whether only active (available for redemption) coupons should be included. Null means do not filter by active state."
            }
          ],
          "description": "Whether only active (available for redemption) coupons should be included. Null means do not filter by active state."
        },
        "expired": {
          "oneOf": [
            {
              "type": "boolean",
              "description": "Filter for expired coupons only (true), unexpired only (false), or all (null)."
            },
            {
              "type": "null",
              "description": "Filter for expired coupons only (true), unexpired only (false), or all (null)."
            }
          ],
          "description": "Filter for expired coupons only (true), unexpired only (false), or all (null)."
        },
        "limit": {
          "oneOf": [
            {
              "type": "integer",
              "description": "Maximum number of records to return for this request (pagination). If null, use default/system max.",
              "minimum": 1
            },
            {
              "type": "null",
              "description": "Maximum number of records to return for this request (pagination). If null, use default/system max.",
              "minimum": 1
            }
          ],
          "description": "Maximum number of records to return for this request (pagination). If null, use default/system max."
        },
        "offset": {
          "oneOf": [
            {
              "type": "integer",
              "description": "Number of records to skip before selecting results (pagination). If null, treats as zero.",
              "minimum": 0
            },
            {
              "type": "null",
              "description": "Number of records to skip before selecting results (pagination). If null, treats as zero.",
              "minimum": 0
            }
          ],
          "description": "Number of records to skip before selecting results (pagination). If null, treats as zero."
        }
      },
      "required": []
    },
    "ai_ecommerce_coupon.IPage": {
      "type": "object",
      "description": "Paginated result set for queries/searches of ai_ecommerce_coupon entities. Contains both data and pagination metadata for client consumption.\n\nThis object is returned by endpoints that retrieve filtered, paged collections of coupons for admin dashboards, customer wallets, and seller promo tools.\n\nCombines a data array of coupon objects together with metadata about current page, page size, total count, and page count.",
      "properties": {
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/ai_ecommerce_coupon"
          },
          "description": "Array of coupon records returned for the current page; each item conforms to the ai_ecommerce_coupon schema."
        },
        "pagination": {
          "type": "object",
          "description": "Metadata describing the current page and pagination state, following platform-standard IPage.IPagination (for offset/limit, total records, pages, etc.).",
          "properties": {
            "current": {
              "type": "integer",
              "description": "Current page number (1-based)."
            },
            "limit": {
              "type": "integer",
              "description": "Records per page on this result."
            },
            "records": {
              "type": "integer",
              "description": "Total number of records matching the current filter"
            },
            "pages": {
              "type": "integer",
              "description": "Total number of result pages."
            }
          },
          "required": [
            "current",
            "limit",
            "records",
            "pages"
          ]
        }
      },
      "required": [
        "data",
        "pagination"
      ]
    },
    "ai_ecommerce_coupon": {
      "type": "object",
      "description": "Normalized coupon entity for the next-generation e-commerce backend, representing a single platform- or seller-issued coupon available for redemption by customers. Fields correspond 1:1 with the ai_ecommerce_coupon Prisma model, used for discount systems, coupon redemption, wallet display, and admin promo tools.\n\nHolds unique, atomic coupon property values including owner, issuer, rule linkage, code, usage/expiration constraints, status, and compliance metadata.",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "Primary key UUID uniquely identifying the coupon."
        },
        "customer_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Customer that owns this coupon. Nullable for system-wide or bulk coupons."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Customer that owns this coupon. Nullable for system-wide or bulk coupons."
            }
          ],
          "description": "Customer that owns this coupon. Nullable for system-wide or bulk coupons."
        },
        "seller_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Seller that issued this coupon, if any. Null for platform/global coupons."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Seller that issued this coupon, if any. Null for platform/global coupons."
            }
          ],
          "description": "Seller that issued this coupon, if any. Null for platform/global coupons."
        },
        "discount_rule_id": {
          "type": "string",
          "format": "uuid",
          "description": "Discount rule this coupon references; required for application/eligibility logic."
        },
        "code": {
          "type": "string",
          "description": "Coupon code string; unique per owner/scope where required (e.g., SAVE10)."
        },
        "issued_at": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp coupon was issued."
        },
        "expires_at": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "Timestamp when coupon expires. Null for non-expiring/promotional coupons."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "Timestamp when coupon expires. Null for non-expiring/promotional coupons."
            }
          ],
          "description": "Timestamp when coupon expires. Null for non-expiring/promotional coupons."
        },
        "is_active": {
          "type": "boolean",
          "description": "Whether coupon is currently available for redemption/application."
        },
        "usage_limit": {
          "type": "integer",
          "description": "Max total redemptions permitted for this coupon, across all users."
        },
        "usage_per_customer_limit": {
          "type": "integer",
          "description": "Maximum number of redemptions permitted for single customer."
        }
      },
      "required": [
        "id",
        "discount_rule_id",
        "code",
        "issued_at",
        "is_active",
        "usage_limit",
        "usage_per_customer_limit"
      ]
    },
    "IAiEcommerceCoupon.ICreate": {
      "type": "object",
      "description": "Payload for creating a new coupon entity matching the ai_ecommerce_coupon schema in the backend system. Used by admin/seller promo tools and system integrations to insert a new redemption code into the platform coupon registry.\n\nFollows the validations and constraints described in the DB schema (e.g., uniqueness, required fields, correct associations with customer/seller/rule).",
      "properties": {
        "customer_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Target customer for personalized coupon (nullable for public/platform coupons)."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Target customer for personalized coupon (nullable for public/platform coupons)."
            }
          ],
          "description": "Target customer for personalized coupon (nullable for public/platform coupons)."
        },
        "seller_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Issuing seller for seller-specific coupons; null for platform-issued."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Issuing seller for seller-specific coupons; null for platform-issued."
            }
          ],
          "description": "Issuing seller for seller-specific coupons; null for platform-issued."
        },
        "discount_rule_id": {
          "type": "string",
          "format": "uuid",
          "description": "Reference to discount_rule applied by this coupon (required)."
        },
        "code": {
          "type": "string",
          "description": "Unique coupon code string for redemption (required, unique per business rule)."
        },
        "issued_at": {
          "type": "string",
          "format": "date-time",
          "description": "Coupon issuance timestamp (required)."
        },
        "expires_at": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "Expiration timestamp; null if no expiry."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "Expiration timestamp; null if no expiry."
            }
          ],
          "description": "Expiration timestamp; null if no expiry."
        },
        "is_active": {
          "type": "boolean",
          "description": "Whether coupon is initially enabled when created."
        },
        "usage_limit": {
          "type": "integer",
          "description": "Total redemption limit for the coupon."
        },
        "usage_per_customer_limit": {
          "type": "integer",
          "description": "How many times a single customer may use the coupon."
        }
      },
      "required": [
        "discount_rule_id",
        "code",
        "issued_at",
        "is_active",
        "usage_limit",
        "usage_per_customer_limit"
      ]
    },
    "IAiEcommerceCoupon": {
      "$ref": "#/components/schemas/ai_ecommerce_coupon",
      "description": "Alias for the ai_ecommerce_coupon entity type; follows the same structure, used for response typing and unifying request/response objects in the OpenAPI component schema."
    },
    "IAiEcommerceCoupon.IUpdate": {
      "type": "object",
      "description": "Object for updating an existing coupon entry (ai_ecommerce_coupon table). Includes only fields allowed to update per business logic (cannot change immutable id, code, or owner after creation). Used to modify expiration, usage limits, status, or deactivate coupon.\n\nFields populated must be business-rule-allowed mutable fields.",
      "properties": {
        "expires_at": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "New expiration timestamp for the coupon; null for no expiry."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "New expiration timestamp for the coupon; null for no expiry."
            }
          ],
          "description": "New expiration timestamp for the coupon; null for no expiry."
        },
        "is_active": {
          "type": "boolean",
          "description": "Override active state of the coupon."
        },
        "usage_limit": {
          "type": "integer",
          "description": "Update max permitted total redemptions."
        },
        "usage_per_customer_limit": {
          "type": "integer",
          "description": "Update max permitted per-customer redemptions."
        }
      },
      "required": []
    },
    "IDeleteConfirmation": {
      "type": "object",
      "description": "Generic confirmation type indicating logical/physical delete status for a resource within the system. Used to confirm successful completion of delete endpoints.\n\nPrimary use cases include resource APIs that must show completion of a delete action (coupon, order, loyalty point, return request, etc.) and return a status/optional effective field.",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "Unique identifier of the deleted entity."
        },
        "success": {
          "type": "boolean",
          "description": "True if deletion was performed successfully."
        },
        "deleted_at": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "If soft-deleted, the timestamp the resource was marked deleted. Null if not applicable or not recorded."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "If soft-deleted, the timestamp the resource was marked deleted. Null if not applicable or not recorded."
            }
          ],
          "description": "If soft-deleted, the timestamp the resource was marked deleted. Null if not applicable or not recorded."
        }
      },
      "required": [
        "id",
        "success"
      ]
    },
    "IAiEcommerceLoyaltyPoint.IListRequest": {
      "type": "object",
      "description": "Request object for listing, filtering, or searching loyalty point events for customer accounts as per ai_ecommerce_loyalty_point. Supports admin dashboards, account history review, and loyalty program management.\n\nAllows paginated, filtered fetching of loyalty point records by customer, order, loyalty tier, date range, and reason.",
      "properties": {
        "customer_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "ID of the customer whose loyalty points to query. Null for system-wide/admin queries."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "ID of the customer whose loyalty points to query. Null for system-wide/admin queries."
            }
          ],
          "description": "ID of the customer whose loyalty points to query. Null for system-wide/admin queries."
        },
        "order_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Order associated with loyalty point event. Filters by order if provided."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Order associated with loyalty point event. Filters by order if provided."
            }
          ],
          "description": "Order associated with loyalty point event. Filters by order if provided."
        },
        "loyalty_tier_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Tier associated at time of point accrual/spending, for filtering summary/historic listings."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Tier associated at time of point accrual/spending, for filtering summary/historic listings."
            }
          ],
          "description": "Tier associated at time of point accrual/spending, for filtering summary/historic listings."
        },
        "reason": {
          "oneOf": [
            {
              "type": "string",
              "description": "Filter by business/action reason for this loyalty point event, such as 'purchase', 'campaign', or manual credit."
            },
            {
              "type": "null",
              "description": "Filter by business/action reason for this loyalty point event, such as 'purchase', 'campaign', or manual credit."
            }
          ],
          "description": "Filter by business/action reason for this loyalty point event, such as 'purchase', 'campaign', or manual credit."
        },
        "from_date": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "Filter for only events created after this timestamp (inclusive)."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "Filter for only events created after this timestamp (inclusive)."
            }
          ],
          "description": "Filter for only events created after this timestamp (inclusive)."
        },
        "to_date": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "Filter for only events created before this timestamp (inclusive)."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "Filter for only events created before this timestamp (inclusive)."
            }
          ],
          "description": "Filter for only events created before this timestamp (inclusive)."
        },
        "limit": {
          "oneOf": [
            {
              "type": "integer",
              "minimum": 1,
              "description": "Maximum number of records to retrieve (pagination). Null for default value."
            },
            {
              "type": "null",
              "minimum": 1,
              "description": "Maximum number of records to retrieve (pagination). Null for default value."
            }
          ],
          "description": "Maximum number of records to retrieve (pagination). Null for default value."
        },
        "offset": {
          "oneOf": [
            {
              "type": "integer",
              "minimum": 0,
              "description": "Number of records to skip (pagination). Null for zero/automatic."
            },
            {
              "type": "null",
              "minimum": 0,
              "description": "Number of records to skip (pagination). Null for zero/automatic."
            }
          ],
          "description": "Number of records to skip (pagination). Null for zero/automatic."
        }
      },
      "required": []
    },
    "IPageIAiEcommerceLoyaltyPoint": {
      "type": "object",
      "description": "Paginated result set for API queries of ai_ecommerce_loyalty_point records. This structure is used in endpoints returning a list of loyalty point transactions for a given filter/set of customers or orders. Includes the loyalty point event data and standard pagination metadata.",
      "properties": {
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/IAiEcommerceLoyaltyPoint"
          },
          "description": "Loyalty point event array corresponding to pagination window."
        },
        "pagination": {
          "type": "object",
          "description": "Pagination meta, using standard fields: current page, limit, total records, pages.",
          "properties": {
            "current": {
              "type": "integer",
              "description": "Current page number of results."
            },
            "limit": {
              "type": "integer",
              "description": "Number of rows per page."
            },
            "records": {
              "type": "integer",
              "description": "Total record count for the current filter query."
            },
            "pages": {
              "type": "integer",
              "description": "Page count for the query window."
            }
          },
          "required": [
            "current",
            "limit",
            "records",
            "pages"
          ]
        }
      },
      "required": [
        "data",
        "pagination"
      ]
    },
    "IAiEcommerceLoyaltyPoint": {
      "type": "object",
      "description": "Atomic loyalty point record as defined by the ai_ecommerce_loyalty_point Prisma model. Used to track reward, redemption, accrual, and audit for loyalty programs. Immutable except for business/compliance correction flows.\n\nIncludes references to customer, order, loyalty tier, change amount (int), reason (string), and created_at timestamp. This structure is used in all loyalty point API read and write contexts.",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "Unique ID for this loyalty point transaction."
        },
        "customer_id": {
          "type": "string",
          "format": "uuid",
          "description": "Reference to customer who earned/spent this loyalty point entry."
        },
        "order_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Optional: order associated with loyalty point accrual/spending/invalidation event."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Optional: order associated with loyalty point accrual/spending/invalidation event."
            }
          ],
          "description": "Optional: order associated with loyalty point accrual/spending/invalidation event."
        },
        "loyalty_tier_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Optional: tier for this event; traceable for reporting/history."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Optional: tier for this event; traceable for reporting/history."
            }
          ],
          "description": "Optional: tier for this event; traceable for reporting/history."
        },
        "change_amount": {
          "type": "integer",
          "description": "Signed integer showing points added (positive) or subtracted (negative) for this transaction."
        },
        "reason": {
          "type": "string",
          "description": "String reason code (e.g., 'purchase', 'cancel', 'manual_adjust')."
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp the event occurred."
        }
      },
      "required": [
        "id",
        "customer_id",
        "change_amount",
        "reason",
        "created_at"
      ]
    },
    "IAiEcommerceLoyaltyPoint.ICreate": {
      "type": "object",
      "properties": {
        "customer_id": {
          "type": "string",
          "format": "uuid",
          "description": "Unique identifier (UUID) for the customer to whom this loyalty point event applies. References ai_ecommerce_customer in the database. Required for the transaction."
        },
        "order_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Optional UUID of the related order. Used when the loyalty event (earn or spend) is tied to a specific order. Nullable."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Optional UUID of the related order. Used when the loyalty event (earn or spend) is tied to a specific order. Nullable."
            }
          ],
          "description": "Optional UUID of the related order. Used when the loyalty event (earn or spend) is tied to a specific order. Nullable."
        },
        "loyalty_tier_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Optional UUID referencing the loyalty tier associated with this point event (e.g., Gold, Silver). Used to capture the tier at the time of event. Nullable."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Optional UUID referencing the loyalty tier associated with this point event (e.g., Gold, Silver). Used to capture the tier at the time of event. Nullable."
            }
          ],
          "description": "Optional UUID referencing the loyalty tier associated with this point event (e.g., Gold, Silver). Used to capture the tier at the time of event. Nullable."
        },
        "change_amount": {
          "type": "integer",
          "description": "The integer change in points this event represents. Positive for accrual, negative for redemption. Strictly atomic—no aggregate or running balance. Required."
        },
        "reason": {
          "type": "string",
          "description": "Short string describing why the points are credited or debited (e.g., 'purchase', 'adjustment'). Must be provided for audit and trace."
        }
      },
      "required": [
        "customer_id",
        "change_amount",
        "reason"
      ],
      "description": "Input object for creating a new loyalty point event. Implements ai_ecommerce_loyalty_point event creation for accrual, redemption, or correction as per 08_ai_ecommerce_discount_loyalty_payment.md. The event is always atomic, with all references to customer, optional order, optional tier, and the integer point change."
    },
    "IAiEcommerceLoyaltyPoint.IUpdate": {
      "type": "object",
      "properties": {
        "change_amount": {
          "type": "integer",
          "description": "New value for the integer point change. Only permitted for corrections; must match business logic for allowed range."
        },
        "reason": {
          "type": "string",
          "description": "Updated or new reason for the point transaction. Used for correction or audit annotation."
        },
        "loyalty_tier_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Updated UUID referencing the loyalty tier at event time. Nullable. Used if correcting tier assignment."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Updated UUID referencing the loyalty tier at event time. Nullable. Used if correcting tier assignment."
            }
          ],
          "description": "Updated UUID referencing the loyalty tier at event time. Nullable. Used if correcting tier assignment."
        }
      },
      "required": [
        "change_amount"
      ],
      "description": "Object for updating a loyalty point event. Only permitted for corrections/adjustments. Fields updatable are: change_amount, reason, loyalty_tier_id. Business logic may limit which fields may be updated after finalization."
    },
    "IAiEcommerceLoyaltyTier.IListRequest": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "Filter by loyalty tier name. Optional."
        },
        "min_points_required": {
          "type": "integer",
          "description": "Filter for minimum points required to achieve the tier. Optional."
        },
        "sort_order": {
          "type": "integer",
          "description": "Filter by display or business sort order. Optional."
        },
        "page": {
          "type": "integer",
          "description": "Page number for pagination; defaults to 1. Optional."
        },
        "limit": {
          "type": "integer",
          "description": "Page size for pagination; defaults to a reasonable limit (e.g., 100). Optional."
        }
      },
      "required": [],
      "description": "Paginated and filterable request for listing loyalty tiers. Supports flexible search on name, min_points_required, and sort_order."
    },
    "IPageIAiEcommerceLoyaltyTier": {
      "type": "object",
      "properties": {
        "pagination": {
          "$ref": "#/components/schemas/IPage.IPagination",
          "description": "Pagination metadata (current page, limit, total records, total pages)."
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/IAiEcommerceLoyaltyTier"
          },
          "description": "Array of loyalty tier records matching the request query."
        }
      },
      "required": [
        "pagination",
        "data"
      ],
      "description": "Paginated response structure for loyalty tier listing. Contains meta and actual result set of loyalty tiers."
    },
    "IAiEcommerceLoyaltyTier": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "Unique identifier (UUID) for the loyalty tier. Primary key."
        },
        "name": {
          "type": "string",
          "description": "Display/business name for the loyalty tier (e.g., 'Silver', 'Gold', 'Diamond')."
        },
        "min_points_required": {
          "type": "integer",
          "description": "Minimum point balance required to achieve or maintain this tier."
        },
        "multiplier": {
          "type": "number",
          "format": "double",
          "description": "Earning or redemption rate multiplier for this tier (e.g., 1.0 for basic, >1.0 for premium)."
        },
        "sort_order": {
          "type": "integer",
          "description": "Display or business sort order; enables ordered tier listings."
        }
      },
      "required": [
        "id",
        "name",
        "min_points_required",
        "multiplier",
        "sort_order"
      ],
      "description": "Schema representing a single loyalty tier definition, normalized as per 08_ai_ecommerce_discount_loyalty_payment.md. Used for point assignment/qualification and user reward context."
    },
    "IAiEcommerceLoyaltyTier.ICreate": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "Name for the new loyalty tier; must be unique across all tiers (case-insensitive)."
        },
        "min_points_required": {
          "type": "integer",
          "description": "Integer points required for users to reach this tier."
        },
        "multiplier": {
          "type": "number",
          "format": "double",
          "description": "Multiplier rate for point accrual or redemption. Must be positive and reflect business rules."
        },
        "sort_order": {
          "type": "integer",
          "description": "Sort order integer for tier display; lower value = higher priority on sorted lists."
        }
      },
      "required": [
        "name",
        "min_points_required",
        "multiplier",
        "sort_order"
      ],
      "description": "Schema for creating a new loyalty tier in the platform, as described in 08_ai_ecommerce_discount_loyalty_payment.md. All fields are atomic and required for tier onboarding."
    },
    "IAiEcommerceLoyaltyTier.IUpdate": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "Updated name for the loyalty tier."
        },
        "min_points_required": {
          "type": "integer",
          "description": "Updated minimum points required for this tier."
        },
        "multiplier": {
          "type": "number",
          "format": "double",
          "description": "Updated earning/redemption multiplier for the tier."
        },
        "sort_order": {
          "type": "integer",
          "description": "Updated sort order integer; affects business and UI positioning."
        }
      },
      "required": [],
      "description": "Object for updating the definition of a loyalty tier. Only mutable tier attributes are updatable; updates are fully audit-traced."
    },
    "ai_ecommerce_wallet.IRequest": {
      "type": "object",
      "properties": {
        "customer_id": {
          "type": "string",
          "format": "uuid",
          "description": "Filter wallets by customer UUID. Optional."
        },
        "currency_code": {
          "type": "string",
          "description": "Filter for wallets by ISO currency code (e.g., 'KRW', 'USD'). Optional."
        },
        "is_active": {
          "type": "boolean",
          "description": "Filter by active status of the wallet."
        },
        "page": {
          "type": "integer",
          "description": "Page number for pagination. Optional."
        },
        "limit": {
          "type": "integer",
          "description": "Page size for pagination. Optional."
        }
      },
      "required": [],
      "description": "Request object for searching/paginating ai_ecommerce_wallets. Supports filters on customer, currency, and status."
    },
    "IPageai_ecommerce_wallet": {
      "type": "object",
      "properties": {
        "pagination": {
          "$ref": "#/components/schemas/IPage.IPagination"
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/ai_ecommerce_wallet"
          }
        }
      },
      "required": [
        "pagination",
        "data"
      ],
      "description": "Paginated result structure for wallet search/list in ai_ecommerce_wallet."
    },
    "ai_ecommerce_wallet": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "Unique UUID for the wallet. Primary key."
        },
        "customer_id": {
          "type": "string",
          "format": "uuid",
          "description": "Customer UUID; owner of the wallet."
        },
        "currency_code": {
          "type": "string",
          "description": "ISO-4217 currency code ('KRW', 'USD', etc)."
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp the wallet was created. ISO 8601 format."
        },
        "is_active": {
          "type": "boolean",
          "description": "Wallet active status (true = usable, false = inactive/frozen)."
        }
      },
      "required": [
        "id",
        "customer_id",
        "currency_code",
        "created_at",
        "is_active"
      ],
      "description": "Entity for customer wallet as per ai_ecommerce_wallet table in DiscountLoyaltyPayment domain. Represents a wallet unit for platform credits, multi-currency handled by unique key."
    },
    "ai_ecommerce_wallet.ICreate": {
      "type": "object",
      "properties": {
        "customer_id": {
          "type": "string",
          "format": "uuid",
          "description": "UUID for the customer to whom this wallet belongs."
        },
        "currency_code": {
          "type": "string",
          "description": "ISO-4217 currency code for the wallet (e.g., 'KRW', 'USD')."
        },
        "is_active": {
          "type": "boolean",
          "description": "Wallet status (active/inactive). Optional; may be set to true by default."
        }
      },
      "required": [
        "customer_id",
        "currency_code"
      ],
      "description": "Object for creating a new ai_ecommerce_wallet record. Includes customer association and currency code. is_active is optional at creation."
    },
    "ai_ecommerce_wallet.IUpdate": {
      "type": "object",
      "properties": {
        "currency_code": {
          "type": "string",
          "description": "ISO-4217 code for wallet currency; changing currency is rare, may be disabled by business logic."
        },
        "is_active": {
          "type": "boolean",
          "description": "Updated status of the wallet (active/inactive)."
        }
      },
      "required": [],
      "description": "Schema for updating wallet status/details. Field changes are audit-logged for compliance; status and currency_code may be updated per business logic."
    },
    "ai_ecommerce_wallet_transaction.IRequest": {
      "type": "object",
      "properties": {
        "wallet_id": {
          "type": "string",
          "format": "uuid",
          "description": "지갑 거래를 소유하는 지갑의 UUID입니다. 이 필드는 트랜잭션 검색, 감사 및 분석 목적으로 사용됩니다.\n\nPrisma schema column 설명 참조: 'wallet_wallet_transaction ai_ecommerce_wallet @relation(fields: [wallet_id], references: [id], onDelete: Cascade)'"
        },
        "order_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "관련 주문의 UUID입니다. 주문 관련 트랜잭션 필터링, 감사 또는 분리 분석에 사용됩니다.\n\nPrisma schema column 설명 참조: 'order_wallet_transaction ai_ecommerce_order? @relation(fields: [order_id], references: [id], onDelete: Cascade)'"
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "관련 주문의 UUID입니다. 주문 관련 트랜잭션 필터링, 감사 또는 분리 분석에 사용됩니다.\n\nPrisma schema column 설명 참조: 'order_wallet_transaction ai_ecommerce_order? @relation(fields: [order_id], references: [id], onDelete: Cascade)'"
            }
          ],
          "description": "관련 주문의 UUID입니다. 주문 관련 트랜잭션 필터링, 감사 또는 분리 분석에 사용됩니다.\n\nPrisma schema column 설명 참조: 'order_wallet_transaction ai_ecommerce_order? @relation(fields: [order_id], references: [id], onDelete: Cascade)'"
        },
        "payment_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "이 트랜잭션과 연결된 결제의 UUID입니다. 결제 필터, 분석 및 정산에 유용합니다.\n\nPrisma schema column 설명 참조: 'payment_wallet_transaction ai_ecommerce_payment? @relation(fields: [payment_id], references: [id], onDelete: Cascade)'"
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "이 트랜잭션과 연결된 결제의 UUID입니다. 결제 필터, 분석 및 정산에 유용합니다.\n\nPrisma schema column 설명 참조: 'payment_wallet_transaction ai_ecommerce_payment? @relation(fields: [payment_id], references: [id], onDelete: Cascade)'"
            }
          ],
          "description": "이 트랜잭션과 연결된 결제의 UUID입니다. 결제 필터, 분석 및 정산에 유용합니다.\n\nPrisma schema column 설명 참조: 'payment_wallet_transaction ai_ecommerce_payment? @relation(fields: [payment_id], references: [id], onDelete: Cascade)'"
        },
        "transaction_type": {
          "type": "string",
          "description": "트랜잭션 유형(예: 'deposit', 'payment', 'refund' 등)입니다. 이 필드는 트랜잭션의 성격을 지정하며, 감사, 필터링, 보고에 사용됩니다. 가능하면 enum 문서와 설명을 참조하십시오.\n\nPrisma schema column 설명 참조: 'type - e.g., deposit, payment, refund, etc.'"
        },
        "date_range": {
          "type": "object",
          "properties": {
            "from": {
              "type": "string",
              "format": "date-time",
              "description": "시작 날짜/시간(ISO 8601). 이 날짜 이후의 트랜잭션만 포함."
            },
            "to": {
              "type": "string",
              "format": "date-time",
              "description": "종료 날짜/시간(ISO 8601). 이 날짜 이전의 트랜잭션만 포함."
            }
          },
          "description": "트랜잭션 발생 기간을 지정하는 날짜 범위(검색/필터). 분석 및 보고 용도로 사용됩니다.",
          "required": []
        },
        "page": {
          "type": "integer",
          "minimum": 1,
          "description": "페이지 번호(1-based). 페이지네이션을 위해 사용됩니다."
        },
        "limit": {
          "type": "integer",
          "minimum": 1,
          "maximum": 500,
          "description": "페이지 당 최대 결과 수. 시스템 성능과 쿼리 효율을 위해 사용합니다(최대값 제한됨)."
        }
      },
      "description": "지갑 트랜잭션의 고급 검색·필터 요청 객체.\n\n각 속성은 ai_ecommerce_wallet_transaction(지갑 거래)의 필터, 검색, 페이징을 지원합니다. Prisma 스키마 컬럼 주석을 기반으로 하며, 파라미터별 요구사항을 상세히 설명합니다.\n\n각 필드는 감사, 분석, 세부 거래 데이터 조회에 필수적입니다.",
      "required": [
        "wallet_id"
      ]
    },
    "IPageai_ecommerce_wallet_transaction": {
      "type": "object",
      "properties": {
        "pagination": {
          "$ref": "#/components/schemas/IPage.IPagination"
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/ai_ecommerce_wallet_transaction"
          }
        }
      },
      "required": [
        "pagination",
        "data"
      ],
      "description": "지갑 트랜잭션 목록과 페이징 정보를 포함하는 표준 페이지 결과 구조입니다.\n\nPrisma DB 스키마 댓글 및 페이징 컴포넌트 표준에 따름."
    },
    "ai_ecommerce_wallet_transaction": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "각 지갑 거래에 부여되는 고유 식별자(UUID). 결제, 충전, 환불 등 모든 거래 흐름에서 필수입니다.\n\nPrisma schema column 설명 참조: 'id String @id @db.Uuid'"
        },
        "wallet_id": {
          "type": "string",
          "format": "uuid",
          "description": "소유 지갑 UUID. 고객 지갑과의 관계를 나타냅니다.\n\nPrisma schema column 설명 참조: 'wallet_id String @db.Uuid'"
        },
        "order_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "관련 주문의 UUID. 결제, 환불 등 특정 주문 연결 가능.\n\nPrisma schema column 설명 참조: 'order_id String? @db.Uuid'"
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "관련 주문의 UUID. 결제, 환불 등 특정 주문 연결 가능.\n\nPrisma schema column 설명 참조: 'order_id String? @db.Uuid'"
            }
          ],
          "description": "관련 주문의 UUID. 결제, 환불 등 특정 주문 연결 가능.\n\nPrisma schema column 설명 참조: 'order_id String? @db.Uuid'"
        },
        "payment_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "관련 결제의 UUID. 결제 및 환불 트랜잭션에 사용.\n\nPrisma schema column 설명 참조: 'payment_id String? @db.Uuid'"
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "관련 결제의 UUID. 결제 및 환불 트랜잭션에 사용.\n\nPrisma schema column 설명 참조: 'payment_id String? @db.Uuid'"
            }
          ],
          "description": "관련 결제의 UUID. 결제 및 환불 트랜잭션에 사용.\n\nPrisma schema column 설명 참조: 'payment_id String? @db.Uuid'"
        },
        "change_amount": {
          "type": "number",
          "description": "거래 금액(+, -) 값. 입금(positive), 결제/환불(negative 또는 positive)등을 명확히 기록함.\n\nPrisma schema column 설명 참조: 'change_amount Float @db.DoublePrecision'"
        },
        "currency_code": {
          "type": "string",
          "description": "ISO 4217 통화 코드(예: 'KRW', 'USD'). 거래 화폐를 명확히 지정합니다.\n\nPrisma schema column 설명 참조: 'currency_code String'"
        },
        "transaction_type": {
          "type": "string",
          "description": "트랜잭션 유형(예: 'deposit', 'payment', 'refund' 등). 트랜잭션 업무/분류 목적으로 필수.\n\nPrisma schema column 설명 참조: 'type String'"
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "트랜잭션 발생(기록) 시각(UTC, ISO 8601). 거래 순서 및 감사 추적에 중요.\n\nPrisma schema column 설명 참조: 'created_at DateTime @db.Timestamptz'"
        }
      },
      "required": [
        "id",
        "wallet_id",
        "change_amount",
        "currency_code",
        "transaction_type",
        "created_at"
      ],
      "description": "단일 지갑 트랜잭션 레코드 구조.\n\n각 속성은 Prisma 스키마 주석 기반으로, 고유 식별자와 트랜잭션 분석을 상세 기술합니다. 모든 필드는 DB 정규화 원칙 및 감사 추적 요구 사항에 정확히 맞춥니다."
    },
    "ai_ecommerce_wallet_transaction.ICreate": {
      "type": "object",
      "properties": {
        "wallet_id": {
          "type": "string",
          "format": "uuid",
          "description": "트랜잭션이 추가될 고객의 지갑 UUID(필수). 지갑 계정과의 관계에 필요함.\n\nPrisma schema column 설명 참조: 'wallet_id String @db.Uuid'"
        },
        "order_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "연결 주문 UUID(선택). 주문 결제, 환불 관련 트랜잭션 시에만 사용.\n\nPrisma schema column 설명 참조: 'order_id String? @db.Uuid'"
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "연결 주문 UUID(선택). 주문 결제, 환불 관련 트랜잭션 시에만 사용.\n\nPrisma schema column 설명 참조: 'order_id String? @db.Uuid'"
            }
          ],
          "description": "연결 주문 UUID(선택). 주문 결제, 환불 관련 트랜잭션 시에만 사용.\n\nPrisma schema column 설명 참조: 'order_id String? @db.Uuid'"
        },
        "payment_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "연결 결제 UUID(선택). 결제, 환불, 되돌리기 등 특정 트랜잭션에 사용.\n\nPrisma schema column 설명 참조: 'payment_id String? @db.Uuid'"
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "연결 결제 UUID(선택). 결제, 환불, 되돌리기 등 특정 트랜잭션에 사용.\n\nPrisma schema column 설명 참조: 'payment_id String? @db.Uuid'"
            }
          ],
          "description": "연결 결제 UUID(선택). 결제, 환불, 되돌리기 등 특정 트랜잭션에 사용.\n\nPrisma schema column 설명 참조: 'payment_id String? @db.Uuid'"
        },
        "change_amount": {
          "type": "number",
          "description": "거래 금액(+, -). 금액은 입금/결제/환불 등 트랜잭션 목적에 따라 올바른 값이어야 하며, 필드 설명 참조.\n\nPrisma schema column 설명 참조: 'change_amount Float @db.DoublePrecision'"
        },
        "currency_code": {
          "type": "string",
          "description": "ISO 4217 통화 코드(예: 'KRW', 'USD'). 올바른 국제/지역 통화코드를 사용해야 함.\n\nPrisma schema column 설명 참조: 'currency_code String'"
        },
        "transaction_type": {
          "type": "string",
          "description": "트랜잭션 유형(예: 'deposit', 'payment', 'refund' 등, 비즈니스 로직 enum 참고). 업무별 필수 분류.\n\nPrisma schema column 설명 참조: 'type String'"
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "트랜잭션 발생 시각(UTC 기반 ISO 8601). 거래 오더 및 감사 근거로 중요.\n\nPrisma schema column 설명 참조: 'created_at DateTime @db.Timestamptz'"
        }
      },
      "required": [
        "wallet_id",
        "change_amount",
        "currency_code",
        "transaction_type",
        "created_at"
      ],
      "description": "새 지갑 트랜잭션 생성 요청 페이로드.\n\n각 입력 필드는 Prisma DB 스키마 요구와 실무 트랜잭션 관리 요구(정확한 기록 및 감사)를 나타냅니다."
    },
    "ai_ecommerce_wallet_transaction.IUpdate": {
      "type": "object",
      "properties": {
        "order_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "연결 주문 UUID(수정 또는 null 지정 가능).\n\nPrisma schema column 설명 참조: 'order_id String? @db.Uuid'"
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "연결 주문 UUID(수정 또는 null 지정 가능).\n\nPrisma schema column 설명 참조: 'order_id String? @db.Uuid'"
            }
          ],
          "description": "연결 주문 UUID(수정 또는 null 지정 가능).\n\nPrisma schema column 설명 참조: 'order_id String? @db.Uuid'"
        },
        "payment_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "연결 결제 UUID(수정 또는 null 지정 가능).\n\nPrisma schema column 설명 참조: 'payment_id String? @db.Uuid'"
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "연결 결제 UUID(수정 또는 null 지정 가능).\n\nPrisma schema column 설명 참조: 'payment_id String? @db.Uuid'"
            }
          ],
          "description": "연결 결제 UUID(수정 또는 null 지정 가능).\n\nPrisma schema column 설명 참조: 'payment_id String? @db.Uuid'"
        },
        "change_amount": {
          "type": "number",
          "description": "변경할 거래 금액(+, -). 단, 입금/결제 정책 및 트랜잭션 특성상 검증 필요.\n\nPrisma schema column 설명 참조: 'change_amount Float @db.DoublePrecision'"
        },
        "transaction_type": {
          "type": "string",
          "description": "변경할 트랜잭션 유형. 업무 enum 및 회계 규칙 참고(필요할 때만 변경).\n\nPrisma schema column 설명 참조: 'type String'"
        },
        "currency_code": {
          "type": "string",
          "description": "변경할 ISO 통화 코드. 예시: 'KRW', 'USD'.\n\nPrisma schema column 설명 참조: 'currency_code String'"
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "트랜잭션 수정 시 새로운 발생 시각 지정(선택). 수정 내역/IDTT 용도.\n\nPrisma schema column 설명 참조: 'created_at DateTime @db.Timestamptz'"
        }
      },
      "description": "지갑 트랜잭션 정보 수정 요청(부분 또는 전부). 입력 필드는 Prisma DB 컬럼 및 회계 요구 즉시 반영 구조입니다.",
      "required": []
    },
    "ai_ecommerce_payment_integration.IRequest": {
      "type": "object",
      "properties": {
        "provider_name": {
          "type": "string",
          "description": "결제 서비스 제공자명(예: 'Stripe', 'KCP', 'KakaoPay'). 정확한 이름으로 필터/검색."
        },
        "is_active": {
          "type": "boolean",
          "description": "활성화 여부로 필터링(활성 상태/비활성 제거 등)."
        },
        "page": {
          "type": "integer",
          "minimum": 1,
          "description": "페이지 번호(1-based)."
        },
        "limit": {
          "type": "integer",
          "minimum": 1,
          "maximum": 200,
          "description": "페이지 당 최대 리턴 수."
        }
      },
      "description": "결제 인터그레이션(provider) 검색/필터링 요청 객체. 각 속성은 ai_ecommerce_payment_integration의 컬럼 설명 및 검색/관리 기능을 구현합니다.",
      "required": []
    },
    "IPageai_ecommerce_payment_integration": {
      "type": "object",
      "properties": {
        "pagination": {
          "$ref": "#/components/schemas/IPage.IPagination"
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/IAiEcommercePaymentIntegration"
          }
        }
      },
      "required": [
        "pagination",
        "data"
      ],
      "description": "결제 인터그레이션 목록과 페이징 정보를 담는 표준 페이지 결과 구조.\n\n페이징/검색 API 목록 대응 및 Prisma DB 규격 설명 반드시 참고."
    },
    "IAiEcommercePaymentIntegration": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "고유 결제연동 식별자(UUID). 모든 관리 및 분석 흐름의 기본 키.\n\nPrisma schema column 설명 참조: 'id String @id @db.Uuid'"
        },
        "provider_name": {
          "type": "string",
          "description": "결제 서비스 제공자명. (예: 'Stripe', 'KCP', 'KakaoPay') 각 제공자별 구분 및 설정 정책에 필수.\n\nPrisma schema column 설명 참조: 'provider_name String'"
        },
        "configuration_json": {
          "type": "string",
          "description": "제공자별 인증/설정 정보를 포함한 JSON 문자열(암호화 저장 권장). API Key 등 민감정보 포함 가능. 관리 시 개인정보/보안 준수 필요.\n\nPrisma schema column 설명 참조: 'configuration_json String'"
        },
        "is_active": {
          "type": "boolean",
          "description": "설정 활성 상태. true면 결제/인증 이용 가능\n\nPrisma schema column 설명 참조: 'is_active Boolean'"
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "설정/연동 등록 시각(UTC, ISO 8601). 연동 관리, 모니터링, 감사에 필요.\n\nPrisma schema column 설명 참조: 'created_at DateTime @db.Timestamptz'"
        }
      },
      "required": [
        "id",
        "provider_name",
        "configuration_json",
        "is_active",
        "created_at"
      ],
      "description": "단일 결제 인터그레이션(결제 서비스 연동 설정) 레코드 구조.\n\n모든 속성은 Prisma 스키마 설명과 결제 연동 보안/관리 정책을 기반으로 기재됩니다."
    },
    "IAiEcommercePaymentIntegration.ICreate": {
      "type": "object",
      "properties": {
        "provider_name": {
          "type": "string",
          "description": "결제 서비스 제공자명(필수, 예: 'Stripe', 'KCP', 'KakaoPay').\n\nPrisma schema column 설명 참조: 'provider_name String'"
        },
        "configuration_json": {
          "type": "string",
          "description": "결제 구성 정보(JSON, 암호화된 API 키/설정 포함). 보안 및 정책 상 반드시 요구.\n\nPrisma schema column 설명 참조: 'configuration_json String'"
        },
        "is_active": {
          "type": "boolean",
          "description": "설정 생성 시 활성 상태 여부. 기본값 true권장(결제 가능해야 함).\n\nPrisma schema column 설명 참조: 'is_active Boolean'"
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "연동 등록일시(UTC ISO 8601). 시스템 자동기록 또는 필요 시 직접 입력.\n\nPrisma schema column 설명 참조: 'created_at DateTime @db.Timestamptz'"
        }
      },
      "required": [
        "provider_name",
        "configuration_json",
        "is_active",
        "created_at"
      ],
      "description": "새 결제 서비스 연동 등록(설정) 요청 페이로드. AI-커머스 DB 스키마 정책 및 결제 API 연동 요구 사항 기초로 하며, 보안 준수 및 통합관리 정책 강조."
    },
    "IAiEcommercePaymentIntegration.IUpdate": {
      "type": "object",
      "properties": {
        "provider_name": {
          "type": "string",
          "description": "결제 서비스 제공자명(수정 시).\n\nPrisma schema column 설명 참조: 'provider_name String'"
        },
        "configuration_json": {
          "type": "string",
          "description": "새 결제 구성 정보(JSON) 또는 새 보안키 지정 등 업데이트 시 사용.\n\nPrisma schema column 설명 참조: 'configuration_json String'"
        },
        "is_active": {
          "type": "boolean",
          "description": "활성/비활성 상태 업데이트.\n\nPrisma schema column 설명 참조: 'is_active Boolean'"
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "등록일시(필요 시 인증키 업데이트 등 용도, 수정 시 업데이트된 날짜 기록)."
        }
      },
      "description": "결제 인터그레이션(설정) 정보 일부 또는 전체 수정 요청 페이로드.",
      "required": []
    },
    "IAiEcommerceDiscountRule.IRequest": {
      "type": "object",
      "properties": {
        "rule_type": {
          "type": "string",
          "description": "할인 규칙 유형(예: 'fixed_amount', 'percentage', 'stacking' 등. 정책과 일치해야 함).\n\nPrisma schema column 설명 참조: 'rule_type String'"
        },
        "description": {
          "type": "string",
          "description": "할인 규칙 설명 내용/키워드로 검색."
        },
        "created_date_range": {
          "type": "object",
          "properties": {
            "from": {
              "type": "string",
              "format": "date-time"
            },
            "to": {
              "type": "string",
              "format": "date-time"
            }
          },
          "description": "규칙 생성(등록)일 범위 - 기간별 필터링.",
          "required": []
        },
        "page": {
          "type": "integer",
          "minimum": 1,
          "description": "1기반 페이지 번호로 results 페이징."
        },
        "limit": {
          "type": "integer",
          "minimum": 1,
          "maximum": 200,
          "description": "페이지 당 최대 검색/리턴 수 지정."
        }
      },
      "description": "할인 규칙(쿠폰/프로모션/적립 등 정책)에 대한 검색, 필터, 페이징 요청 구조. AI-커머스 DB 스키마의 할인 정책/엔진을 통합적으로 조회할 수 있음.",
      "required": []
    },
    "IAiEcommercePageIAiEcommerceDiscountRule": {
      "type": "object",
      "properties": {
        "pagination": {
          "$ref": "#/components/schemas/IPage.IPagination"
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/IAiEcommerceDiscountRule"
          }
        }
      },
      "required": [
        "pagination",
        "data"
      ],
      "description": "할인 규칙 목록 및 페이징 정보를 담는 표준 응답 구조. 모든 할인 정책의 상세 및 요약 조회 지원."
    },
    "IAiEcommerceDiscountRule": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "고유한 할인 규칙 식별자입니다.\n\n등록된 프로모션, 쿠폰, 또는 로열티 프로그램의 각 할인 규칙에 UUID로 부여됩니다. 데이터베이스의 primary key이며, 수정 불가입니다. 값은 실제 PostgreSQL UUID 형식이어야 하며, 입력/수정 불가, 오직 응답에만 표시됨을 명시합니다."
        },
        "rule_type": {
          "type": "string",
          "description": "할인/프로모션/쿠폰 등에서 유형을 나타내는 값입니다.\n\n예시: 'fixed_amount', 'percentage', 'stacking'. 사업별로 기타 확장 가능합니다. 광고, 프로모션, 쿠폰, 로열티 등 어떤 경로로든 부여되는 모든 type값은 명확히 일치해야 하며, 값은 시스템/DB에 사전에 정의된 것만 허용됩니다."
        },
        "description": {
          "type": "string",
          "description": "해당 할인 규칙의 업무적 설명 텍스트입니다.\n\n비즈니스, 어드민, UI 등에 제시되는 설명이며, 설계 문서와 동일하게 상세히 작성해야 합니다. 정책, 사용처, 주의사항 등 용도와 범위별 설명을 포함합니다."
        },
        "predicate_json": {
          "type": "string",
          "description": "할인 규칙의 유효성 판단을 위한 JSON 구조의 조건 열입니다.\n\nex) 특정 카테고리, 금액, 날짜, 신규고객 여부 등 다양한 비즈니스 조건을 포함하며, 클라이언트/서버/백오피스 모두 해석 가능한 JSON이어야 합니다.\n\n예: {\"min_purchase\": 10000, \"applicable_category\": [\"Electronics\"]}"
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "해당 규칙이 시스템에 등록된 시각입니다.\n\nISO8601 format의 datetime 문자열로 관리되며, 서버/DB에서 insert 시점에 자동 기록됩니다. 사용일/시, 변경일/시 감사 로깅에도 활용됩니다."
        }
      },
      "required": [
        "id",
        "rule_type",
        "description",
        "predicate_json",
        "created_at"
      ],
      "description": "할인 및 프로모션/쿠폰/로열티 룰 정의 엔티티.\n\n할인 or 프로모션에서 적용되는 규칙의 메타 정보 및 비즈니스 조건(JSON 필드 포함)을 담습니다. 쿠폰, 포인트, 프로모션 정책의 룰셋 구성시 활용되며 반복 불가/고유 규칙 이름 및 생성일이 반드시 포함되어야 합니다.\n\n원본: Prisma 테이블 ai_ecommerce_discount_rule - 주요 정책, 할인 조건, 검증식 일체를 등록 및 관리하는 테이블의 파생 엔티티.\n\n모든 rule_type, description, 조건은 표준화·인증 용도로 사용되며, 시스템 확장에 맞게 정책 명확성을 확보하도록 설계되어 있습니다. 모든 연관 객체(쿠폰, 캠페인 등)는 반드시 여기를 참조합니다."
    },
    "IAiEcommerceDiscountRule.ICreate": {
      "type": "object",
      "properties": {
        "rule_type": {
          "type": "string",
          "description": "신규로 생성하는 할인 룰의 형식명입니다.\n\n예시: 'percentage'/'fixed_amount'/'stacking' 등 시스템상 허용된 문자열만 입력 가능하며, 비즈니스팀/설계서/DB 엔티티/비즈니스 메서드와 반드시 일치해야 합니다."
        },
        "description": {
          "type": "string",
          "description": "해당 룰에 대한 업무/기술/시스템 설명 텍스트입니다. 정책, 제한사항, 사용처, 예외 등 포함하며, 사용자/시스템/어드민 문서화에 반드시 참고되어야 합니다."
        },
        "predicate_json": {
          "type": "string",
          "description": "해당 할인 룰이 어떤 조건에 부합하는지, 평가를 위한 비즈니스 로직 표현 문자열(JSON)\n\n예시: '{\"min_amount\":10000, \"category\":[\"Food\",\"Electronics\"]}'\n\n서버/클라이언트/어드민 모두 공통 해석 가능한 순수 JSON이어야 하며, Optional 정보 불가(빈 {} 혹은 null 허용 금지)"
        }
      },
      "required": [
        "rule_type",
        "description",
        "predicate_json"
      ],
      "description": "할인 규칙 등록/생성 시 사용되는 DTO. 필수 필드로 type, description, 조건 JSON을 포함합니다.\n\n모든 신규 할인 정책/쿠폰/프로모션 등록/생성에서 반드시 이 타입을 맞춰야 하며, DB/업무 로직 및 표준 정책과의 일치성을 보장합니다.\n\n원본: Prisma schema의 ai_ecommerce_discount_rule, 생성시 반드시 정책·조건·설명이 적절히 부여됩니다."
    },
    "IAiEcommerceDiscountRule.IUpdate": {
      "type": "object",
      "properties": {
        "rule_type": {
          "type": "string",
          "description": "수정 대상 할인 정책의 type. 변경 시 정책 충돌 여부를 반드시 확인해야 하며, type별 독립적 유효성 검사 필수입니다."
        },
        "description": {
          "type": "string",
          "description": "수정할 룰 설명. 모든 정책·제약사항·확장성(Memo) 기록 필수."
        },
        "predicate_json": {
          "type": "string",
          "description": "수정할 조건 (JSON 문서 기반, 모든 변경 내역은 따로 감사 기록 필요함)."
        }
      },
      "required": [
        "rule_type",
        "description",
        "predicate_json"
      ],
      "description": "할인 정책의 상세정보 및 조건 변경용 DTO. 정책 종류/설명/판별식 모두 변경 가능하며, 각 필드 값은 정책·비즈니스팀 표준과 상호 일치해야 함.\n\n모든 수정 요청시 서버/어드민/사용자에 따라 로그 및 감사 정책이 분리되어야 하며, 비즈니스 규칙 위반/충돌 검증이 반드시 이루어져야 함.\n\n원본: ai_ecommerce_discount_rule, 수정 전/후 변경 항목 기록 필요."
    },
    "IAiEcommerceFavorite.IRequest": {
      "type": "object",
      "properties": {
        "customer_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "검색 대상 고객 UUID입니다.\n\n특정 고객(사용자)의 즐겨찾기만 조회할 때 조건으로 사용합니다. null일 경우 전체 또는 로그인된 본인만 필터링 가능합니다."
            },
            {
              "type": "null"
            }
          ],
          "description": "검색 대상 고객 UUID입니다.\n\n특정 고객(사용자)의 즐겨찾기만 조회할 때 조건으로 사용합니다. null일 경우 전체 또는 로그인된 본인만 필터링 가능합니다."
        },
        "product_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "검색 대상 상품의 UUID입니다.\n\n특정 상품의 좋아요(북마크)를 전체 고객 범위에서 조회시 사용됩니다. null 시 조건 미사용."
            },
            {
              "type": "null"
            }
          ],
          "description": "검색 대상 상품의 UUID입니다.\n\n특정 상품의 좋아요(북마크)를 전체 고객 범위에서 조회시 사용됩니다. null 시 조건 미사용."
        },
        "favorite_tag_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "즐겨찾기 태그(폴더) 기준으로 필터링시 지정하는 UUID입니다. 미사용 시 null."
            },
            {
              "type": "null"
            }
          ],
          "description": "즐겨찾기 태그(폴더) 기준으로 필터링시 지정하는 UUID입니다. 미사용 시 null."
        },
        "page": {
          "type": "integer",
          "minimum": 1,
          "default": 1,
          "description": "검색 결과 페이징 번호 (1부터 시작)."
        },
        "limit": {
          "type": "integer",
          "minimum": 1,
          "default": 20,
          "description": "한 번에 가져올 결과 개수(최대 100)."
        },
        "sort_key": {
          "oneOf": [
            {
              "type": "string",
              "description": "정렬 기준 컬럼명 (예: created_at, name 등). null 시 기본 정렬 사용."
            },
            {
              "type": "null"
            }
          ],
          "description": "정렬 기준 컬럼명 (예: created_at, name 등). null 시 기본 정렬 사용."
        },
        "sort_order": {
          "oneOf": [
            {
              "const": "asc",
              "description": "정렬 방향. 오름차순: asc, 내림차순: desc. 기본값 desc(최근순)."
            },
            {
              "const": "desc",
              "description": "정렬 방향. 오름차순: asc, 내림차순: desc. 기본값 desc(최근순)."
            }
          ],
          "description": "정렬 방향. 오름차순: asc, 내림차순: desc. 기본값 desc(최근순)."
        }
      },
      "required": [
        "page",
        "limit"
      ],
      "description": "즐겨찾기(좋아요) 리스트 검색 조건 DTO.\n\n고객, 상품, 태그 등 조건별 페이징 기반 조회에 사용하며, 기본 페이지/개수는 필수. 추가 검색·정렬 옵션은 null 허용(없으면 기본)."
    },
    "IAiEcommercePageIAiEcommerceFavorite": {
      "type": "object",
      "properties": {
        "pagination": {
          "$ref": "#/components/schemas/IPage.IPagination"
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/IAiEcommerceFavorite"
          },
          "description": "즐겨찾기(좋아요) 한 페이지의 데이터(목록 배열).\n\n각 row는 IAiEcommerceFavorite 타입, 실제 고객-상품-태그 매핑 데이터."
        }
      },
      "required": [
        "pagination",
        "data"
      ],
      "description": "페이징+메타데이터 기반 즐겨찾기(좋아요/favorite) 목록 반환 객체.\n\n검색 조건별 결과와 전체 pagination/메타 정보를 함께 제공합니다. (기반: IPage 구조 표준 적용)\n\n원본: 프론트·백엔드 API의 표준 결과 Wrapper."
    },
    "IAiEcommerceFavorite": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "즐겨찾기 row 유니크 식별자 (PK/UUID).\n\n실제 DB의 PK, 각 즐겨찾기 설정시 무조건 고유/중복 불가."
        },
        "customer_id": {
          "type": "string",
          "format": "uuid",
          "description": "즐겨찾기 생성자(고객) UUID.\n\n즐겨찾기(좋아요) 추가할 때 반드시 지정하며, 고객정보 직접 노출이 필요한 경우엔 별도 profile 엔티티 참조를 사용합니다."
        },
        "product_id": {
          "type": "string",
          "format": "uuid",
          "description": "즐겨찾기 설정 상품 UUID.\n\n즐겨찾기(좋아요) 혹은 북마크 타겟이 되는 실제 상품에 대한 ID입니다."
        },
        "favorite_tag_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "폴더/태그 등 grouping 용도의 connection key (nullable)\n\n고객이 favorites를 그룹핑할 때 지정(없을 시 null)"
            },
            {
              "type": "null"
            }
          ],
          "description": "폴더/태그 등 grouping 용도의 connection key (nullable)\n\n고객이 favorites를 그룹핑할 때 지정(없을 시 null)"
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "이 즐겨찾기 기록이 생성된 시점 (iso8601)."
        }
      },
      "required": [
        "id",
        "customer_id",
        "product_id",
        "created_at"
      ],
      "description": "즐겨찾기(좋아요) 단일 row DTO.\n\n고객, 상품, 태그(폴더) 연결 정보, 생성 timestamp 포함. (원본: ai_ecommerce_favorite)\n\n모든 CRUD 응답, 페이징 데이터 등에서 사용."
    },
    "IAiEcommerceFavorite.ICreate": {
      "type": "object",
      "properties": {
        "customer_id": {
          "type": "string",
          "format": "uuid",
          "description": "즐겨찾기(좋아요) 추가를 요청하는 고객 UUID입니다.\n\n반드시 본인이거나 권한 있는 어드민/시스템 계정이어야 하며, 없는 경우 에러 반환."
        },
        "product_id": {
          "type": "string",
          "format": "uuid",
          "description": "추가하려는 상품 UUID입니다.\n\n존재하는 상품이어야 하며, 중복 fav 허용 안함."
        },
        "favorite_tag_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "(옵션) 즐겨찾기 그룹핑/분류를 위한 태그 UUID입니다. null 지정 시 폴더 미분류."
            },
            {
              "type": "null"
            }
          ],
          "description": "(옵션) 즐겨찾기 그룹핑/분류를 위한 태그 UUID입니다. null 지정 시 폴더 미분류."
        }
      },
      "required": [
        "customer_id",
        "product_id"
      ],
      "description": "새 즐겨찾기 row 생성 입력 DTO.\n\n고객-상품-폴더/태그 조합으로 고유 row 생성합니다."
    },
    "IAiEcommerceFavorite.IUpdate": {
      "type": "object",
      "properties": {
        "favorite_tag_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "수정하려는 태그(folder/grouping)의 UUID입니다.\n\n기존 즐겨찾기를 다른 태그(폴더)로 이동 시 지정하며, null일 경우 미분류로 변경합니다."
            },
            {
              "type": "null"
            }
          ],
          "description": "수정하려는 태그(folder/grouping)의 UUID입니다.\n\n기존 즐겨찾기를 다른 태그(폴더)로 이동 시 지정하며, null일 경우 미분류로 변경합니다."
        }
      },
      "required": [
        "favorite_tag_id"
      ],
      "description": "즐겨찾기 태그 폴더 변경, 분류 이동 등에서 사용하는 즐겨찾기 수정 입력 DTO.\n\n태그 관련 정보가 변동될 때 사용. (실제 favorites row의 product/customer는 변경 불가)"
    },
    "IAiEcommerceFavoriteTag.IRequest": {
      "type": "object",
      "properties": {
        "customer_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "조회 대상 고객의 UUID. null 시 전체(Tag Owner 본인) 기준."
            },
            {
              "type": "null"
            }
          ],
          "description": "조회 대상 고객의 UUID. null 시 전체(Tag Owner 본인) 기준."
        },
        "name": {
          "oneOf": [
            {
              "type": "string",
              "description": "태그명(키워드) 검색 필터. 대소문자 무관, 부분일치 허용. 미사용시 null."
            },
            {
              "type": "null"
            }
          ],
          "description": "태그명(키워드) 검색 필터. 대소문자 무관, 부분일치 허용. 미사용시 null."
        },
        "page": {
          "type": "integer",
          "minimum": 1,
          "default": 1,
          "description": "페이지 번호(1부터 시작)."
        },
        "limit": {
          "type": "integer",
          "minimum": 1,
          "default": 20,
          "description": "페이지당 row 개수(기본 20, 최대 100)."
        }
      },
      "required": [
        "page",
        "limit"
      ],
      "description": "즐겨찾기 태그(favorite group/tag/folder) 리스트 검색조건 DTO.\n\n고객별, 키워드별, 페이징, 즉시 조회에 복수 지원."
    },
    "IPageIAiEcommerceFavoriteTag": {
      "type": "object",
      "properties": {
        "pagination": {
          "$ref": "#/components/schemas/IPage.IPagination"
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/IAiEcommerceFavoriteTag"
          },
          "description": "고객별 즐겨찾기 태그(폴더) 목록"
        }
      },
      "required": [
        "pagination",
        "data"
      ],
      "description": "고객 favorite tag 페이징/메타데이터 포함 응답 DTO.\n\n태그 리스트와 페이징 정보 일괄 제공(표준 IPage 구조 활용)."
    },
    "IAiEcommerceFavoriteTag": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "태그 row UUID(PK).\n\n고객별로 고유하며, DB의 고유값입니다."
        },
        "customer_id": {
          "type": "string",
          "format": "uuid",
          "description": "해당 태그의 소유자(고객) UUID입니다."
        },
        "name": {
          "type": "string",
          "description": "즐겨찾기 태그 이름(고객별 유니크)\n\n태그/폴더명으로 즐겨찾기 분류 UI에서 사용합니다."
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "태그 생성 시각(ISO8601). 신규 태그 생성 또는 최초 기록시 자동 기록됩니다."
        }
      },
      "required": [
        "id",
        "customer_id",
        "name",
        "created_at"
      ],
      "description": "즐겨찾기 태그(favorite group/folder) 단일 row DTO.\n\n태그/폴더명, 소유고객, UUID, 생성일시 포함. 태그별로 즐겨찾기 아이템 또는 폴더 구조로 활용합니다."
    },
    "IAiEcommerceFavoriteTag.ICreate": {
      "type": "object",
      "properties": {
        "customer_id": {
          "type": "string",
          "format": "uuid",
          "description": "태그를 소유할 고객 UID.\n\n한 사람이 여러 개의 태그/폴더 생성 가능하나, 동일명 불가(고객별 name 유니크)."
        },
        "name": {
          "type": "string",
          "description": "생성할 태그명(고객별로 고유).\n\n자동 태그명 충돌 방지 및 키워드 중복 검증 필수. 길이/유효성/검색최적화 등 시스템 정책 반영 필요."
        }
      },
      "required": [
        "customer_id",
        "name"
      ],
      "description": "새 즐겨찾기 태그(폴더) 등록 입력 DTO. 고객별 유니크 필수. 태그명 규칙 반드시 준수."
    },
    "IAiEcommerceFavoriteTag.IUpdate": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "The new name for the favorite tag.\n\nRepresents the updated label for this favorite grouping (e.g., 'Gift Ideas', 'To Buy'). Must be unique per customer. Refer to the 'name' column in the ai_ecommerce_favorite_tag table."
        }
      },
      "required": [
        "name"
      ],
      "description": "Request object for updating a favorite tag in ai_ecommerce_favorite_tag. Used to change a tag's name. Only allowed for the owner of the tag. Fully normalized; only properties allowed by business logic are present."
    },
    "IAiEcommerceRecommendation.IRequest": {
      "type": "object",
      "properties": {
        "customer_id": {
          "type": "string",
          "format": "uuid",
          "description": "The unique identifier for the customer to retrieve recommendations for.\n\nCorresponds to the 'customer_id' column in ai_ecommerce_recommendation. Only recommendations for this customer will be retrieved."
        },
        "product_id": {
          "type": "string",
          "format": "uuid",
          "description": "The unique identifier for a specific product to filter recommendations by.\n\nAllows querying recommendations for a particular product within the set of recommendations. Corresponds to the 'product_id' column."
        },
        "snapshot_id": {
          "type": "string",
          "format": "uuid",
          "description": "If supplied, filters recommendations tied to this personalization snapshot. Used for context restoration or targeted analytics. Null or omitted for global search."
        },
        "reason_code": {
          "type": "string",
          "description": "The reason code filter, for retrieving recommendations connected to specific AI-driven reasons (e.g., 'similar_items', 'trending').\n\nMatches 'reason_code' column in ai_ecommerce_recommendation."
        },
        "recommended_after": {
          "type": "string",
          "format": "date-time",
          "description": "Show recommendations created after this timestamp. ISO8601 format; corresponds to filtering on 'recommended_at' (greater than).\n\nOptional for paged/batched export."
        },
        "recommended_before": {
          "type": "string",
          "format": "date-time",
          "description": "Show recommendations created before this timestamp. ISO8601 format; used for paged export or rolling analytics windows."
        },
        "limit": {
          "type": "integer",
          "description": "Maximum number of records to fetch in this page/batch. For pagination control. Default and range governed by system/service."
        },
        "offset": {
          "type": "integer",
          "description": "Offset into the result set for pagination purposes. Used for skipping previous pages of results."
        },
        "sort_by": {
          "type": "string",
          "description": "Sort key for results (e.g., 'recommended_at', 'reason_code').\n\nSpecifies which column to sort the results by."
        },
        "sort_order": {
          "oneOf": [
            {
              "const": "asc",
              "description": "Order of sorting: 'asc' for ascending, 'desc' for descending. Default may be 'desc' on 'recommended_at'."
            },
            {
              "const": "desc",
              "description": "Order of sorting: 'asc' for ascending, 'desc' for descending. Default may be 'desc' on 'recommended_at'."
            }
          ],
          "description": "Order of sorting: 'asc' for ascending, 'desc' for descending. Default may be 'desc' on 'recommended_at'."
        }
      },
      "description": "Request type for retrieving/paginating/searching ai_ecommerce_recommendation records. Allows search, filter, and pagination by customer, product, snapshot, reason, and recommended_at. Used in PATCH list endpoints for recommendations.",
      "required": []
    },
    "IPageIAiEcommerceRecommendation": {
      "type": "object",
      "properties": {
        "page": {
          "type": "integer",
          "description": "Current page number."
        },
        "limit": {
          "type": "integer",
          "description": "Number of items per page."
        },
        "total": {
          "type": "integer",
          "description": "Total number of available matching recommendations."
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/IAiEcommerceRecommendation"
          },
          "description": "Array of recommendation records for this page."
        }
      },
      "required": [
        "page",
        "limit",
        "total",
        "data"
      ],
      "description": "Paginated result structure for arrays of IAiEcommerceRecommendation entities. Used on PATCH list endpoints and similar query interfaces. Includes pagination metadata and the result array."
    },
    "IAiEcommerceRecommendation": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "Unique identifier for the recommendation record (UUID).\n\nMatches 'id' in ai_ecommerce_recommendation."
        },
        "customer_id": {
          "type": "string",
          "format": "uuid",
          "description": "ID of the customer receiving this recommendation.\n\nMatches 'customer_id' in ai_ecommerce_recommendation."
        },
        "product_id": {
          "type": "string",
          "format": "uuid",
          "description": "ID of the product being recommended, refers to ai_ecommerce_product.id."
        },
        "snapshot_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Optional ID of the personalization snapshot that contextually informed this recommendation; nullable."
            },
            {
              "type": "null"
            }
          ],
          "description": "Optional ID of the personalization snapshot that contextually informed this recommendation; nullable."
        },
        "recommended_at": {
          "type": "string",
          "format": "date-time",
          "description": "Datetime (ISO 8601) when this recommendation was logged/generated. Column: 'recommended_at'."
        },
        "reason_code": {
          "oneOf": [
            {
              "type": "string",
              "description": "Optional reason code for why this recommendation was made (e.g., 'trending', 'similar_items'). Null for baseline system recommendations."
            },
            {
              "type": "null"
            }
          ],
          "description": "Optional reason code for why this recommendation was made (e.g., 'trending', 'similar_items'). Null for baseline system recommendations."
        }
      },
      "required": [
        "id",
        "customer_id",
        "product_id",
        "recommended_at"
      ],
      "description": "Detailed schema for an ai_ecommerce_recommendation record. Each entry provides a product recommendation for a specific customer, possibly linked to system snapshots and annotated with a reason_code. Used to drive personalized catalogs, analytics, and auditing. Columns mapped directly from ai_ecommerce_recommendation table."
    },
    "IAiEcommerceRecommendation.ICreate": {
      "type": "object",
      "properties": {
        "customer_id": {
          "type": "string",
          "format": "uuid",
          "description": "UUID for the customer receiving this recommendation. Must reference an existing ai_ecommerce_customer row."
        },
        "product_id": {
          "type": "string",
          "format": "uuid",
          "description": "UUID of the product to recommend. References ai_ecommerce_product."
        },
        "snapshot_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Optional personalization snapshot that led to this recommendation (nullable, references ai_ecommerce_snapshot)."
            },
            {
              "type": "null"
            }
          ],
          "description": "Optional personalization snapshot that led to this recommendation (nullable, references ai_ecommerce_snapshot)."
        },
        "reason_code": {
          "oneOf": [
            {
              "type": "string",
              "description": "Optional code describing the AI/business reason for recommendation, such as 'trending','similar_items', etc."
            },
            {
              "type": "null"
            }
          ],
          "description": "Optional code describing the AI/business reason for recommendation, such as 'trending','similar_items', etc."
        }
      },
      "required": [
        "customer_id",
        "product_id"
      ],
      "description": "Input schema for creating a new recommendation entry in ai_ecommerce_recommendation. Used by admin tools, system automation, or personalization engines to record a new recommendation. All IDs must reference existing entities and reason_code is optional."
    },
    "IAiEcommerceRecommendation.IUpdate": {
      "type": "object",
      "properties": {
        "snapshot_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Set or change the personalization snapshot related to this recommendation; nullable for removal."
            },
            {
              "type": "null"
            }
          ],
          "description": "Set or change the personalization snapshot related to this recommendation; nullable for removal."
        },
        "reason_code": {
          "oneOf": [
            {
              "type": "string",
              "description": "Update the AI/business reason for this recommendation. Null to clear reason."
            },
            {
              "type": "null"
            }
          ],
          "description": "Update the AI/business reason for this recommendation. Null to clear reason."
        }
      },
      "description": "Schema for partial update of an ai_ecommerce_recommendation row. Only snapshot_id and reason_code are mutable fields. Used for corrections or admin-side annotation. Other fields (IDs, main references) are never updatable.",
      "required": []
    },
    "IAiEcommerceSnapshot.IRequest": {
      "type": "object",
      "properties": {
        "customer_id": {
          "type": "string",
          "format": "uuid",
          "description": "UUID of the customer whose snapshots to search."
        },
        "snapshot_type": {
          "type": "string",
          "description": "Filter snapshots by this type (e.g., 'favorites', 'settings'). Corresponds to ai_ecommerce_snapshot.snapshot_type."
        },
        "taken_after": {
          "type": "string",
          "format": "date-time",
          "description": "Search for snapshots taken after this timestamp."
        },
        "taken_before": {
          "type": "string",
          "format": "date-time",
          "description": "Limit results to snapshots taken before this timestamp."
        },
        "limit": {
          "type": "integer",
          "description": "Maximum results per page."
        },
        "offset": {
          "type": "integer",
          "description": "Offset of results (for pagination)."
        }
      },
      "description": "Request type for PATCH/list operation on ai_ecommerce_snapshots. Allows filtering and paginating user snapshots for personalization, sync, analytics.",
      "required": []
    },
    "IPageIAiEcommerceSnapshot": {
      "type": "object",
      "properties": {
        "page": {
          "type": "integer",
          "description": "Current page number."
        },
        "limit": {
          "type": "integer",
          "description": "Items per page."
        },
        "total": {
          "type": "integer",
          "description": "Total available matching snapshots."
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/IAiEcommerceSnapshot"
          },
          "description": "Array of snapshot records for current page."
        }
      },
      "required": [
        "page",
        "limit",
        "total",
        "data"
      ],
      "description": "Paginated result type for arrays of IAiEcommerceSnapshot, as used in PATCH/lists. Includes result set, metadata, and count info."
    },
    "IAiEcommerceSnapshot": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "Unique identifier for the personalization snapshot (UUID)."
        },
        "customer_id": {
          "type": "string",
          "format": "uuid",
          "description": "UUID for the owning customer (cross-reference ai_ecommerce_customer)."
        },
        "snapshot_type": {
          "type": "string",
          "description": "Type string describing what this snapshot captures: e.g., 'favorites', 'settings', etc."
        },
        "taken_at": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp when the snapshot was taken (ISO 8601)."
        },
        "blob_uri": {
          "type": "string",
          "description": "URI (typically to S3/blob storage) where the snapshot's binary data is held."
        }
      },
      "required": [
        "id",
        "customer_id",
        "snapshot_type",
        "taken_at",
        "blob_uri"
      ],
      "description": "Detailed schema for a personalization snapshot (ai_ecommerce_snapshot). Snapshots capture user state for sync, backup, or analytics. Key columns directly map to ai_ecommerce_snapshot fields."
    },
    "IAiEcommerceSnapshot.ICreate": {
      "type": "object",
      "properties": {
        "customer_id": {
          "type": "string",
          "format": "uuid",
          "description": "UUID of the target customer for this snapshot (must exist)."
        },
        "snapshot_type": {
          "type": "string",
          "description": "String describing the business/type for the snapshot (e.g., 'favorites','settings')."
        },
        "taken_at": {
          "type": "string",
          "format": "date-time",
          "description": "Exact ISO datetime when snapshot was created."
        },
        "blob_uri": {
          "type": "string",
          "description": "Blob/CSP URI for the binary snapshot data."
        }
      },
      "required": [
        "customer_id",
        "snapshot_type",
        "taken_at",
        "blob_uri"
      ],
      "description": "Request type for new snapshot creation. Used when a new snapshot must be stored, e.g., during sync, analytics, or config backup. All required fields must be provided."
    },
    "IAiEcommerceSnapshot.IUpdate": {
      "type": "object",
      "properties": {
        "blob_uri": {
          "type": "string",
          "description": "Update the URI where the snapshot's data is stored.\n\nUsed for rehosting/migration or stripping down corrupted URIs during admin repair flows. Only mutable field per schema."
        }
      },
      "description": "Schema for updating a snapshot record, typically just the blob_uri (cannot alter id/customer/snapshot_type/taken_at). Used for admin-side repair or migration.",
      "required": []
    },
    "IAiEcommercePersonalizationConfig.IRequest": {
      "type": "object",
      "properties": {
        "admin_id": {
          "type": "string",
          "format": "uuid",
          "description": "Filter for configs created/set by this admin actor."
        },
        "customer_id": {
          "type": "string",
          "format": "uuid",
          "description": "Show configs scoped to this customer."
        },
        "config_key": {
          "type": "string",
          "description": "Search for only configs with this key name (targeted/toggle search)."
        },
        "applied_after": {
          "type": "string",
          "format": "date-time",
          "description": "Only configs applied after this timestamp."
        },
        "applied_before": {
          "type": "string",
          "format": "date-time",
          "description": "Filter to configs with applied_at date on or before this value."
        },
        "limit": {
          "type": "integer",
          "description": "Max records per page (paging)."
        },
        "offset": {
          "type": "integer",
          "description": "Skip this number of records (for pagination)."
        }
      },
      "description": "Search/filter request structure for listing/paging ai_ecommerce_personalization_config records. Used by admin or advanced UX for config listing feature. All paging/filtering fields map to columns on ai_ecommerce_personalization_config.",
      "required": []
    },
    "IPageIAiEcommercePersonalizationConfig": {
      "type": "object",
      "properties": {
        "pagination": {
          "$ref": "#/components/schemas/IPage.IPagination"
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/IAiEcommercePersonalizationConfig"
          }
        }
      },
      "required": [
        "pagination",
        "data"
      ],
      "description": "Pageable container for ai_ecommerce_personalization_config records.\n\nThis schema represents a paginated result set of personalization config entities as defined in ai_ecommerce_personalization_config. The `pagination` object provides metadata about the current page, total records, limits, and pages (using the standard IPage.IPagination), while `data` contains an array of personalization config entities. Referenced from paginated search and list endpoints for personalization configs."
    },
    "IAiEcommercePersonalizationConfig": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "Unique system-generated id for this config row. Serves as the primary key for ai_ecommerce_personalization_config."
        },
        "admin_id": {
          "type": "string",
          "format": "uuid",
          "description": "ID of the administrator who set/applied this config. References ai_ecommerce_administrator."
        },
        "customer_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Optional ID of the customer if this config is per-user. Null for global/system configs."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Optional ID of the customer if this config is per-user. Null for global/system configs."
            }
          ],
          "description": "Optional ID of the customer if this config is per-user. Null for global/system configs."
        },
        "config_key": {
          "type": "string",
          "description": "Name specifying which setting is being applied, such as AI model version, feature flag, or UI parameter. Must be unique for given customer/timestamp."
        },
        "config_value": {
          "type": "string",
          "description": "Value associated with config key, usually a string or URI. The actual content is interpreted by system logic (model version, personalization rule, etc)."
        },
        "applied_at": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp when config went into effect. Used for audit, versioning, and compliance tracking."
        }
      },
      "required": [
        "id",
        "admin_id",
        "config_key",
        "config_value",
        "applied_at"
      ],
      "description": "ai_ecommerce_personalization_config entity definition.\n\nImplements per-user or global personalization configuration options for the AI-ready shopping mall backend. Used to store key/value parameter settings—such as personalization model version, feature flags, tuning parameters—together with administrative and customer context. Referenced from analytics, UI, and audit modules. See Prisma table for full compliance and data normalization guidance."
    },
    "IAiEcommercePersonalizationConfig.ICreate": {
      "type": "object",
      "properties": {
        "admin_id": {
          "type": "string",
          "format": "uuid",
          "description": "Administrator who creates/applies this config."
        },
        "customer_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Optional customer id for per-user config, null if system/global config."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Optional customer id for per-user config, null if system/global config."
            }
          ],
          "description": "Optional customer id for per-user config, null if system/global config."
        },
        "config_key": {
          "type": "string",
          "description": "Configuration key, must be unique per customer/time."
        },
        "config_value": {
          "type": "string",
          "description": "Value for the configuration key."
        },
        "applied_at": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp when the config is applied/created."
        }
      },
      "required": [
        "admin_id",
        "config_key",
        "config_value",
        "applied_at"
      ],
      "description": "Payload for creating a new ai_ecommerce_personalization_config entry—records configuration key, value, and assignment context. Fields must enforce uniqueness and business rules as required by the schema comments."
    },
    "IAiEcommercePersonalizationConfig.IUpdate": {
      "type": "object",
      "properties": {
        "admin_id": {
          "type": "string",
          "format": "uuid",
          "description": "(Optional) Administrator making the update. If supplied, must reference a valid admin."
        },
        "customer_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "(Optional) Target customer for specific config. Null for global config."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "(Optional) Target customer for specific config. Null for global config."
            }
          ],
          "description": "(Optional) Target customer for specific config. Null for global config."
        },
        "config_key": {
          "type": "string",
          "description": "(Optional) The key to update or set."
        },
        "config_value": {
          "type": "string",
          "description": "(Optional) The new value for the key."
        },
        "applied_at": {
          "type": "string",
          "format": "date-time",
          "description": "(Optional) Timestamp when this new config is effective."
        }
      },
      "required": [],
      "description": "Payload to update existing ai_ecommerce_personalization_config rows. Allows partial update of one or more fields (except immutable id). Used for adjusting settings, toggling feature flags, and rolling out new personalization features. At least one of the properties should be present in a valid update payload."
    },
    "IAiEcommercePersonalizationAnalytics.IRequest": {
      "type": "object",
      "properties": {
        "customer_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Optionally filter by actor/customer. If set, fetch records only for this customer."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Optionally filter by actor/customer. If set, fetch records only for this customer."
            }
          ],
          "description": "Optionally filter by actor/customer. If set, fetch records only for this customer."
        },
        "admin_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Optionally filter by admin actor. Null for no admin filter."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Optionally filter by admin actor. Null for no admin filter."
            }
          ],
          "description": "Optionally filter by admin actor. Null for no admin filter."
        },
        "product_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Optionally filter by product involved in analytics event."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Optionally filter by product involved in analytics event."
            }
          ],
          "description": "Optionally filter by product involved in analytics event."
        },
        "event_type": {
          "oneOf": [
            {
              "type": "string",
              "description": "Optionally filter by type of analytics event: e.g., 'favorite_add', 'rec_click'."
            },
            {
              "type": "null",
              "description": "Optionally filter by type of analytics event: e.g., 'favorite_add', 'rec_click'."
            }
          ],
          "description": "Optionally filter by type of analytics event: e.g., 'favorite_add', 'rec_click'."
        },
        "event_from": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "Earliest event timestamp to return (inclusive), supports time window filtering."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "Earliest event timestamp to return (inclusive), supports time window filtering."
            }
          ],
          "description": "Earliest event timestamp to return (inclusive), supports time window filtering."
        },
        "event_to": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "Latest event timestamp to return (inclusive)."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "Latest event timestamp to return (inclusive)."
            }
          ],
          "description": "Latest event timestamp to return (inclusive)."
        },
        "details_search": {
          "oneOf": [
            {
              "type": "string",
              "description": "Text search within arbitrary details JSON for matching analytics event context."
            },
            {
              "type": "null",
              "description": "Text search within arbitrary details JSON for matching analytics event context."
            }
          ],
          "description": "Text search within arbitrary details JSON for matching analytics event context."
        },
        "page": {
          "oneOf": [
            {
              "type": "integer",
              "format": "uint32",
              "description": "Target page of results, for paging. Defaults to 1 if not specified."
            },
            {
              "type": "null",
              "format": "uint32",
              "description": "Target page of results, for paging. Defaults to 1 if not specified."
            }
          ],
          "description": "Target page of results, for paging. Defaults to 1 if not specified."
        },
        "limit": {
          "oneOf": [
            {
              "type": "integer",
              "format": "uint32",
              "description": "Limit of results per page. Default and maximum governed by system policy."
            },
            {
              "type": "null",
              "format": "uint32",
              "description": "Limit of results per page. Default and maximum governed by system policy."
            }
          ],
          "description": "Limit of results per page. Default and maximum governed by system policy."
        }
      },
      "required": [],
      "description": "Request schema for listing or searching personalization analytics records (ai_ecommerce_personalization_analytics). All fields optional—together support advanced filtering, search, and paging on analytics events."
    },
    "IPageIAiEcommercePersonalizationAnalytics": {
      "type": "object",
      "properties": {
        "pagination": {
          "$ref": "#/components/schemas/IPage.IPagination"
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/IAiEcommercePersonalizationAnalytics"
          }
        }
      },
      "required": [
        "pagination",
        "data"
      ],
      "description": "Paginated container for ai_ecommerce_personalization_analytics records, as returned by search/list APIs.\n\nIncludes metadata for paging and the analytics event data array."
    },
    "IAiEcommercePersonalizationAnalytics": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "Primary key: unique analytics event id (UUID)."
        },
        "customer_id": {
          "type": "string",
          "format": "uuid",
          "description": "Customer/user who triggered the event."
        },
        "admin_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Admin involved, if any, in analytics event."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Admin involved, if any, in analytics event."
            }
          ],
          "description": "Admin involved, if any, in analytics event."
        },
        "product_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Product associated with the analytics event, if relevant."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Product associated with the analytics event, if relevant."
            }
          ],
          "description": "Product associated with the analytics event, if relevant."
        },
        "event_type": {
          "type": "string",
          "description": "Event classification string: e.g., 'favorite_add', 'rec_click'. Defines business logic for event."
        },
        "event_at": {
          "type": "string",
          "format": "date-time",
          "description": "When analytics event occurred (creation timestamp)."
        },
        "details_json": {
          "oneOf": [
            {
              "type": "string",
              "description": "Optional JSON-encoded details about the analytics event, extensible for additional context."
            },
            {
              "type": "null",
              "description": "Optional JSON-encoded details about the analytics event, extensible for additional context."
            }
          ],
          "description": "Optional JSON-encoded details about the analytics event, extensible for additional context."
        }
      },
      "required": [
        "id",
        "customer_id",
        "event_type",
        "event_at"
      ],
      "description": "Analytics event row for ai_ecommerce_personalization_analytics. Represents one atomic user or admin engagement event—append-only, strictly 3NF. The entity records core context, event, actor, and time without aggregation. Used in reporting, dashboards, and compliance modules."
    },
    "IAiEcommercePersonalizationAnalytics.ICreate": {
      "type": "object",
      "properties": {
        "customer_id": {
          "type": "string",
          "format": "uuid",
          "description": "Customer/user who triggers this event."
        },
        "admin_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Admin related to this event, if applicable."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Admin related to this event, if applicable."
            }
          ],
          "description": "Admin related to this event, if applicable."
        },
        "product_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Product associated with the analytics event, if applicable."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Product associated with the analytics event, if applicable."
            }
          ],
          "description": "Product associated with the analytics event, if applicable."
        },
        "event_type": {
          "type": "string",
          "description": "Type/classification of event: 'favorite_add', 'rec_click', etc."
        },
        "event_at": {
          "type": "string",
          "format": "date-time",
          "description": "Creation timestamp of the event."
        },
        "details_json": {
          "oneOf": [
            {
              "type": "string",
              "description": "Arbitrary JSON, serialized, for additional event metadata/context."
            },
            {
              "type": "null",
              "description": "Arbitrary JSON, serialized, for additional event metadata/context."
            }
          ],
          "description": "Arbitrary JSON, serialized, for additional event metadata/context."
        }
      },
      "required": [
        "customer_id",
        "event_type",
        "event_at"
      ],
      "description": "Payload to create a new personalization analytics event, as logged in ai_ecommerce_personalization_analytics. All non-required properties are optional; see domain for further business validation."
    },
    "IAiEcommercePersonalizationAnalytics.IUpdate": {
      "type": "object",
      "properties": {
        "admin_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Optional: update admin context on event."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Optional: update admin context on event."
            }
          ],
          "description": "Optional: update admin context on event."
        },
        "product_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Optional: update product context on event."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Optional: update product context on event."
            }
          ],
          "description": "Optional: update product context on event."
        },
        "event_type": {
          "type": "string",
          "description": "(Optional) New event type/classification."
        },
        "event_at": {
          "type": "string",
          "format": "date-time",
          "description": "(Optional) Change timestamp of event."
        },
        "details_json": {
          "oneOf": [
            {
              "type": "string",
              "description": "(Optional) New or updated event metadata."
            },
            {
              "type": "null",
              "description": "(Optional) New or updated event metadata."
            }
          ],
          "description": "(Optional) New or updated event metadata."
        }
      },
      "required": [],
      "description": "Partial update (patch) schema for ai_ecommerce_personalization_analytics events. Allows selectively updating mutable fields for an analytics record. All fields optional."
    },
    "IAiEcommerceAuditLogs.IRequest": {
      "type": "object",
      "properties": {
        "actor_customer_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Filter logs by acting customer. Null for no filter."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Filter logs by acting customer. Null for no filter."
            }
          ],
          "description": "Filter logs by acting customer. Null for no filter."
        },
        "actor_seller_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Filter logs by acting seller. Null for no filter."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Filter logs by acting seller. Null for no filter."
            }
          ],
          "description": "Filter logs by acting seller. Null for no filter."
        },
        "actor_admin_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Filter logs by acting admin. Null for no filter."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Filter logs by acting admin. Null for no filter."
            }
          ],
          "description": "Filter logs by acting admin. Null for no filter."
        },
        "action_type": {
          "oneOf": [
            {
              "type": "string",
              "description": "Filter logs by event/action type."
            },
            {
              "type": "null",
              "description": "Filter logs by event/action type."
            }
          ],
          "description": "Filter logs by event/action type."
        },
        "target_table": {
          "oneOf": [
            {
              "type": "string",
              "description": "Filter logs by affected target business table/entity."
            },
            {
              "type": "null",
              "description": "Filter logs by affected target business table/entity."
            }
          ],
          "description": "Filter logs by affected target business table/entity."
        },
        "target_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Filter logs by affected business object/entity id."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Filter logs by affected business object/entity id."
            }
          ],
          "description": "Filter logs by affected business object/entity id."
        },
        "created_from": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "Earliest timestamp for log creation (inclusive) filter."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "Earliest timestamp for log creation (inclusive) filter."
            }
          ],
          "description": "Earliest timestamp for log creation (inclusive) filter."
        },
        "created_to": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "Latest timestamp for log creation (inclusive) filter."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "Latest timestamp for log creation (inclusive) filter."
            }
          ],
          "description": "Latest timestamp for log creation (inclusive) filter."
        },
        "page": {
          "oneOf": [
            {
              "type": "integer",
              "format": "uint32",
              "description": "Results page number for pagination."
            },
            {
              "type": "null",
              "format": "uint32",
              "description": "Results page number for pagination."
            }
          ],
          "description": "Results page number for pagination."
        },
        "limit": {
          "oneOf": [
            {
              "type": "integer",
              "format": "uint32",
              "description": "Page size/limit for pagination."
            },
            {
              "type": "null",
              "format": "uint32",
              "description": "Page size/limit for pagination."
            }
          ],
          "description": "Page size/limit for pagination."
        }
      },
      "required": [],
      "description": "Request schema for searching/filtering ai_ecommerce_audit_logs events. All fields optional, serve as filters for various audit analyses. Used for paged/complex audit log queries for compliance, investigation, or business analytics."
    },
    "IPageAiEcommerceAuditLogs": {
      "type": "object",
      "properties": {
        "pagination": {
          "$ref": "#/components/schemas/IPage.IPagination"
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/IAiEcommerceAuditLogs"
          }
        }
      },
      "required": [
        "pagination",
        "data"
      ],
      "description": "Paginated result structure for ai_ecommerce_audit_logs events.\n\nEncapsulates both paging metadata and the audit log records in the result set for compliance, analytics, and platform investigation endpoints."
    },
    "IAiEcommerceAuditLogs": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "Unique identifier for the audit record (UUID, PK)."
        },
        "actor_customer_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Customer who acted (if this event was triggered by customer logic, else null)."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Customer who acted (if this event was triggered by customer logic, else null)."
            }
          ],
          "description": "Customer who acted (if this event was triggered by customer logic, else null)."
        },
        "actor_seller_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Seller who acted (if this log is about a seller activity, else null)."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Seller who acted (if this log is about a seller activity, else null)."
            }
          ],
          "description": "Seller who acted (if this log is about a seller activity, else null)."
        },
        "actor_admin_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Admin who acted (if this log is for administrative action, else null)."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Admin who acted (if this log is for administrative action, else null)."
            }
          ],
          "description": "Admin who acted (if this log is for administrative action, else null)."
        },
        "action_type": {
          "type": "string",
          "description": "String code describing the event (e.g., login, update_order, change_role)."
        },
        "target_table": {
          "type": "string",
          "description": "String representing the business entity/table affected by this event."
        },
        "target_id": {
          "type": "string",
          "format": "uuid",
          "description": "Foreign key to the primary object involved in the audit (the entity being affected)."
        },
        "description": {
          "type": "string",
          "description": "Brief text description explaining event context/reason for audit entry."
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp when this audit log entry was created."
        },
        "deleted_at": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "Soft-delete timestamp if audit record was logically deleted (null if active)."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "Soft-delete timestamp if audit record was logically deleted (null if active)."
            }
          ],
          "description": "Soft-delete timestamp if audit record was logically deleted (null if active)."
        }
      },
      "required": [
        "id",
        "action_type",
        "target_table",
        "target_id",
        "description",
        "created_at"
      ],
      "description": "ai_ecommerce_audit_logs event entity.\n\nImplements the platform-wide audit logging system for the AI e-commerce backend. Each entry records a specific user/system/admin action, the affected business table/row, and the context and timestamp for forensics, compliance, and investigation."
    },
    "IAiEcommerceAuditLogs.ICreate": {
      "type": "object",
      "properties": {},
      "description": "계획된 타입입니다. ai_ecommerce_audit_logs 테이블에 새로운 시스템/플랫폼 감사(log) 엔트리를 추가할 때 사용합니다.\n\n모든 필수 필드(예: actor_customer_id, actor_seller_id, actor_admin_id, action_type, target_table, target_id, description, created_at 등)에 대한 정보를 제공합니다. 실제 구현에서는 각 필드에 대해 Prisma 모델 주석을 참조하여 세부 구조와 필요 속성 정의가 필요합니다.\n\n기본적으로 이 타입은 감사 로그 생성을 위한 입력 값의 구조(필수/옵션 속성 포함)에 대한 명확한 명세 역할을 하며, 플랫폼 행동 추적 및 내부/법적 감사 요건 충족을 지원합니다.",
      "required": []
    },
    "IAiEcommerceAuditLogs.IUpdate": {
      "type": "object",
      "properties": {},
      "description": "계획된 타입입니다. ai_ecommerce_audit_logs의 기존 감사 이벤트를 수정할 때 사용합니다.\n\n수정 가능한 필드(예: description, action_type 등)에 대한 값을 포함하며, 수정 불가 속성(예: 생성 시점/타임스탬프, actor 필드 등)은 포함하지 않습니다. 실제 속성 구조는 Prisma 모델 설명을 엄격히 따르며, 감사 로그의 정정/추가 메타정보 보완, 오류 수정 등 매우 제한적인 사용에 적용됩니다.\n\n이 타입은 엄격한 규정 준수/행동 이력 수정 목적에만 사용되고, 모든 변경 내역은 이차 감사로 로그되어야 합니다.",
      "required": []
    },
    "IAiEcommerceSystemEvents.IRequest": {
      "type": "object",
      "properties": {},
      "description": "계획된 타입입니다. ai_ecommerce_system_events 테이블에 대한 고급 필터링/검색/페이징 요청을 위한 구조입니다.\n\nevent_type, target_table, 시간 범위 지정 등 다양한 검색 조건 및 페이징 파라미터를 포함합니다. \n\n사용자는 필드 조합을 활용해 원하는 시스템 이벤트 로그 수집이 가능하며, 실제 속성 및 허용 필드는 Prisma 모델 주석(비즈니스 요구 사항)에 따라 구성해야 합니다.\n\n플랫폼 관리자 또는 통합 분석 서비스가 시스템 이벤트 로그 분석, 진단, 규정 준수 및 디버그 목적으로 활용하는 고급 RESTful 쿼리 DTO입니다.",
      "required": []
    },
    "IPageAiEcommerceSystemEvents": {
      "type": "object",
      "properties": {},
      "description": "계획된 타입입니다. ai_ecommerce_system_events 엔터티에 대한 페이지네이션 컨테이너로, 한 페이지 내 복수의 시스템 이벤트 로그 레코드와 페이징 메타 정보(총 개수, 현재 페이지, 페이지당 건수 등)를 포함합니다.\n\n데이터 페이로드(배열), 페이지 정보, 총 레코드/총 페이지수가 반드시 명시적으로 포함되어야 하며, 표준 IPage 구조를 기반으로 실제 ai_ecommerce_system_events 레코드 모델과 결합되어 반환됩니다.\n\nUI 및 백오피스, 엔터프라이즈 통합/통계 엔진이 대량 데이터 조회 전망에서도 일관성 있는 응답 형식 제공을 보장합니다.",
      "required": []
    },
    "IAiEcommerceSystemEvents": {
      "type": "object",
      "properties": {},
      "description": "계획된 타입입니다. ai_ecommerce_system_events 테이블의 시스템 이벤트 로그의 메인 엔터티 타입에 해당합니다.\n\n각 레코드는 단일 원자적 시스템/통합 이벤트 (event_type, target_table, target_id, payload_json, created_at 등) 정보 필드를 포함해야 합니다. 실제 속성은 Prisma 스키마 주석과 ERD를 바탕으로 명확하게 기술되어야 하며, 불필요한 중복/비정규 필드는 포함하지 않습니다.\n\n정확한 타입은 시스템 도메인 이벤트, 플랫폼 통합, 감사 목적의 로그 분석 및 리포트 용으로 사용됩니다.",
      "required": []
    },
    "IAiEcommerceSystemEvents.ICreate": {
      "type": "object",
      "properties": {},
      "description": "계획된 타입입니다. ai_ecommerce_system_events 테이블에 새로운 시스템/통합/도메인 이벤트 로그를 삽입할 때 사용되는 입력 구조입니다.\n\n필수로 event_type, target_table, target_id, payload_json, created_at 등이 명세되어야 하며, 실제 구현에서는 Prisma 스키마에 근거한 엄격한 필수/옵션 구조가 필요합니다.\n\n사용 시점은 오케스트레이션/백엔드 서비스가 시스템 이벤트를 기록할 때, 외부 통합 호출, 도메인 이벤트 생성 등 데이터 무결성과 규정 준수 목적에 활용됩니다.",
      "required": []
    },
    "IAiEcommerceSystemEvents.IUpdate": {
      "type": "object",
      "properties": {},
      "description": "계획된 타입입니다. ai_ecommerce_system_events에서 특정 시스템 이벤트 엔트리(immutable)를 예외적으로 보정/정정/수정할 때 사용되는 입력 DTO입니다.\n\n수정 가능한 필드(예: payload_json, description 등), 불가한 필드(예: event_type, created_at, target_table 등)는 반드시 속성 구조에따라 명확히 분류되어야 합니다.\n\n이 타입은 컴플라이언스/오류 교정, 진단 시나리오 하에서만 매우 제한적으로 사용하며, 변경 내역 또한 별도 감사 로그에 반드시 저장되어야 합니다.",
      "required": []
    },
    "IComplianceAudit.IRequest": {
      "type": "object",
      "properties": {},
      "description": "계획된 타입입니다. ai_ecommerce_compliance_audits 테이블의 감사 기록을 조회/필터/페이지네이션 방식으로 리스트 검색하는 요청형 DTO입니다.\n\n필터 가능 속성(예: audit_type, subject_table, admin_id, status, created_at 범위 등)과 페이지/정렬 정보가 실질적 속성 구조로 추가 정의되어야 합니다.\n\n주요 사용자는 관리자/법무 담당자로, 규정 준수, 개인정보보호, 법적 감사 등에서 사용됩니다.",
      "required": []
    },
    "IPageIComplianceAudit": {
      "type": "object",
      "properties": {},
      "description": "계획된 타입입니다. ai_ecommerce_compliance_audits 엔터티의 페이지네이션 결과 컨테이너로, 일정 페이지 내 복수의 감사 레코드와 페이징 메타(현재/전체 페이지, 총 건수 등) 정보가 구조에 포함됩니다.\n\n구성은 표준 IPage<T> 패턴을 따르며, 데이터 필드(배열), 페이지 정보, 부가 메타가 명확히 명세되어야 합니다.",
      "required": []
    },
    "IComplianceAudit": {
      "type": "object",
      "properties": {},
      "description": "계획된 타입입니다. ai_ecommerce_compliance_audits 테이블의 컴플라이언스 감사 단일 레코드/엔터티 타입입니다.\n\n각 감사 행의 필수 속성(audit_type, subject_table, subject_id, status, admin_id, created_at 등) 및 부가 정보(메모 등) 구조가 필요하며, 관련 DB 필드 및 업무 규정에 근거한 세부 구조를 반드시 반영해야 합니다.\n\n용도: 규정 준수(법/보안/개인정보) 감사 추적 및 감사/리포팅에 사용됩니다.",
      "required": []
    },
    "IComplianceAudit.ICreate": {
      "type": "object",
      "properties": {},
      "description": "계획된 타입입니다. ai_ecommerce_compliance_audits 테이블에 새로운 규정준수 감사 기록을 생성/삽입할 때 사용하는 입력 DTO.\n\naudit_type, subject_table, subject_id, status, notes, admin_id 등 필수 항목을 포함하며, Prisma 모델 표기와 업무규정 기반의 세부 속성 구조가 반드시 구현되어야 합니다.\n\n이 타입은 신규 컴플라이언스 사건/감사의 원본 게시, 규정 준수 정책적 조치 및 법정 대응에 중요하게 사용됩니다.",
      "required": []
    },
    "IComplianceAudit.IUpdate": {
      "type": "object",
      "properties": {},
      "description": "계획된 타입입니다. ai_ecommerce_compliance_audits 개별 감사 레코드의 업데이트(수정, 상태/메모 등)에 활용하는 DTO로, 수정 가능 속성만 포함.\n\n불변키(audit_type, subject_id, created_at 등)는 제외되며, 상태(status), notes, admin_id 등만 갱신 대상으로 포함되어야 합니다.\n\n사용 시점은 감사 현황 조정, 결과 상태 변경, 추가 메모 입력 등이며, 실제 구조는 Prisma 모델 명확 명세에 의존합니다.",
      "required": []
    },
    "IAuditLog.IRequest": {
      "type": "object",
      "properties": {},
      "description": "검색 또는 필터링 조건으로 사용되는 감사 로그 요청 객체입니다.\n\n이 스키마는 감사 로그 조회 쿼리에서 필요한 페이징, 정렬 및 필터 조건을 담습니다.\n\n실제로는 호출 측에서 page, limit, sort, 조건부 검색 파라미터 등을 가질 수 있습니다. 모든 값은 Prisma DB 감사 로그 ERD 및 테이블 코멘트를 기반으로 설계되어야 합니다.\n",
      "required": []
    },
    "IPageIAuditLog": {
      "type": "object",
      "properties": {
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/IAuditLog"
          },
          "description": "해당 페이지에 존재하는 감사 로그 객체들의 배열입니다."
        },
        "pagination": {
          "$ref": "#/components/schemas/IPage.IPagination",
          "description": "페이지네이션(페이징) 정보를 담고 있는 객체입니다. 현재 페이지, 한 페이지 최대 개수, 전체 개수, 전체 페이지 수를 포함합니다."
        }
      },
      "required": [
        "data",
        "pagination"
      ],
      "description": "감사 로그 목록 조회 결과의 컨테이너로 사용되며, 페이지네이션 정보와 함께 여러 로그 엔트리의 리스트를 제공합니다.\n\nDB에서 페이징 조회 또는 필터 검색, 정렬 쿼리시 반환되는 표준 페이지 객체입니다."
    },
    "IAuditLog": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "감사 로그 고유 식별자입니다. ai_ecommerce_audit_log 테이블의 PK(UUID)로, 로그의 완전한 유일성과 추적성을 제공합니다.\n\n주로 시스템 이벤트, 행위 내역, 감사 이력을 식별/참조할 때 사용합니다."
        },
        "actor_customer_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "로그 행위 주체가 고객(CUSTOMER)인 경우 해당 고객의 UUID. null이면 비고객 사건."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "로그 행위 주체가 고객(CUSTOMER)인 경우 해당 고객의 UUID. null이면 비고객 사건."
            }
          ],
          "description": "로그 행위 주체가 고객(CUSTOMER)인 경우 해당 고객의 UUID. null이면 비고객 사건."
        },
        "actor_seller_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "행위 주체가 판매자인 경우 연결되는 판매자 ai_ecommerce_seller 테이블의 UUID 식별자. null이면 비판매자/비적용 사건."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "행위 주체가 판매자인 경우 연결되는 판매자 ai_ecommerce_seller 테이블의 UUID 식별자. null이면 비판매자/비적용 사건."
            }
          ],
          "description": "행위 주체가 판매자인 경우 연결되는 판매자 ai_ecommerce_seller 테이블의 UUID 식별자. null이면 비판매자/비적용 사건."
        },
        "actor_admin_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "로그 행위 주체가 플랫폼 관리자(ADMIN)인 경우 해당 관리자의 UUID. null이면 비관리자 사건."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "로그 행위 주체가 플랫폼 관리자(ADMIN)인 경우 해당 관리자의 UUID. null이면 비관리자 사건."
            }
          ],
          "description": "로그 행위 주체가 플랫폼 관리자(ADMIN)인 경우 해당 관리자의 UUID. null이면 비관리자 사건."
        },
        "action_type": {
          "type": "string",
          "description": "이 감사 이벤트(로그)가 기술하는 액션, 이벤트, 행위의 종류입니다.\n예: 로그인, 데이터 수정, 주문 취소, 권한 부여/회수 등. 카테고리나 행위타입 식별용."
        },
        "target_table": {
          "type": "string",
          "description": "감사 대상으로 식별되는 비즈니스 테이블명입니다.\n예: ai_ecommerce_order, ai_ecommerce_customer 등 시스템 내부 논리적/물리적 테이블 표기."
        },
        "target_id": {
          "type": "string",
          "format": "uuid",
          "description": "감사 로그가 추적하는 표적(타깃) 엔터티의 UUID. 주로 업데이트/삭제/조회 대상이 되는 실제 데이터의 UUID PK."
        },
        "description": {
          "type": "string",
          "description": "감사 로그에 기록되는 구체적 행위 또는 사건 설명입니다. 주요 행위 및 상태, 부연 설명 등도 포함됩니다."
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "감사 로그 기록 생성 시점의 타임스탬프입니다. 내부 시스템 타임소스를 기반으로 자동기록."
        },
        "deleted_at": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "감사 로그 logical 삭제 시점. 그대로 두면 null이고, 삭제(감춤)가 되었다면 실제 삭제 시각이 기입됩니다(soft delete)."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "감사 로그 logical 삭제 시점. 그대로 두면 null이고, 삭제(감춤)가 되었다면 실제 삭제 시각이 기입됩니다(soft delete)."
            }
          ],
          "description": "감사 로그 logical 삭제 시점. 그대로 두면 null이고, 삭제(감춤)가 되었다면 실제 삭제 시각이 기입됩니다(soft delete)."
        }
      },
      "required": [
        "id",
        "action_type",
        "target_table",
        "target_id",
        "description",
        "created_at"
      ],
      "description": "플랫폼 전체의 모든 주요 행위/이벤트에 대해 불변적(append only)으로 기록되는 시스템 감사 로그 엔터티입니다.\n\nPrisma 스키마의 ai_ecommerce_audit_log(또는 ai_ecommerce_audit_logs) 테이블에 매핑되며, 여러 종류의 플랫폼 행위를 기술적으로/법적/운영상 추적하기 위한 객체입니다.\n\n각 property의 목적, 관계, 사용 의도는 Prisma 테이블 코멘트와 ERD의 컬럼 집합을 다층적으로 반영합니다.\n"
    },
    "IAuditLog.ICreate": {
      "type": "object",
      "properties": {
        "actor_customer_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "감사 로깅 행위 주체(고객) UUID. null 가능."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "감사 로깅 행위 주체(고객) UUID. null 가능."
            }
          ],
          "description": "감사 로깅 행위 주체(고객) UUID. null 가능."
        },
        "actor_seller_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "감사로깅 행위 주체(판매자) UUID. null 가능."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "감사로깅 행위 주체(판매자) UUID. null 가능."
            }
          ],
          "description": "감사로깅 행위 주체(판매자) UUID. null 가능."
        },
        "actor_admin_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "행위 주체가 플랫폼 관리자라면 해당 admin UUID, null 가능."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "행위 주체가 플랫폼 관리자라면 해당 admin UUID, null 가능."
            }
          ],
          "description": "행위 주체가 플랫폼 관리자라면 해당 admin UUID, null 가능."
        },
        "action_type": {
          "type": "string",
          "description": "실제 이벤트 분류 및 감사로그의 행위 목적 타입 문자열(카테고리/aktion 키워드 등)."
        },
        "target_table": {
          "type": "string",
          "description": "목표 비즈니스 테이블명(엔터티 타입 문자열)."
        },
        "target_id": {
          "type": "string",
          "format": "uuid",
          "description": "행위 대상이 되는 DB 객체의 실제 UUID(PK) 값."
        },
        "description": {
          "type": "string",
          "description": "구체적/부가 설명 및 사건 내역 서술."
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "감사로그 생성시각(타임스탬프). 보통 서버, DB 시각, 또는 기록 전송 측이 제공하는 절대시각."
        }
      },
      "required": [
        "action_type",
        "target_table",
        "target_id",
        "description",
        "created_at"
      ],
      "description": "새 감사 로그(audit row)를 시스템에 삽입(Post)할 때 사용하는 생성용 DTO입니다.\nPrisma DB ai_ecommerce_audit_log 테이블의 스키마와 1:1 매칭되며, 모든 인자에 대한 사업적 목적 및 제약은 테이블 코멘트에 기반합니다.\n"
    },
    "IAuditLog.IUpdate": {
      "type": "object",
      "properties": {
        "description": {
          "type": "string",
          "description": "감사 로그의 설명(내용) 수정 시에만 사용."
        },
        "deleted_at": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "감사 로그의 soft delete 처리. 논리적 삭제 요청 시 타임스탬프 입력."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "감사 로그의 soft delete 처리. 논리적 삭제 요청 시 타임스탬프 입력."
            }
          ],
          "description": "감사 로그의 soft delete 처리. 논리적 삭제 요청 시 타임스탬프 입력."
        }
      },
      "required": [
        "description"
      ],
      "description": "감사 로그(row) 일부 속성(설명/삭제시각 등) 수정을 위한 PATCH/PUT용 DTO.\nPrisma 테이블의 일부분만 갱신하거나 상태 값을 바꿀 때 사용합니다.\n"
    },
    "ISystemEvent.IRequest": {
      "type": "object",
      "properties": {},
      "description": "시스템/통합 이벤트 로그 advanced 필터링/검색 요청용 입력 DTO입니다.\n\nREST API에서 PATCH body로 전달될 수 있으며, event_type, target_table, 기간, 페이징 등 다양한 필드로 검색조건 지정이 가능합니다.\n",
      "required": []
    },
    "IPageISystemEvent": {
      "type": "object",
      "properties": {
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/IAiEcommerceSystemEvent"
          },
          "description": "해당 페이지의 시스템 이벤트 엔터티 리스트."
        },
        "pagination": {
          "$ref": "#/components/schemas/IPage.IPagination",
          "description": "페이지네이션 정보(현재, 제한, 전체 수 등)."
        }
      },
      "required": [
        "data",
        "pagination"
      ],
      "description": "시스템 이벤트 로그에 대한 다수 레코드의 페이지네이션 래퍼.\n\nPrisma ai_ecommerce_system_events 테이블에서 페이징 형태로 결과를 반환하며, 페이지 정보와 데이터 배열을 함께 제공합니다.\n"
    },
    "IAiEcommerceSystemEvent": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "이벤트 로그의 고유 식별자(PK). ai_ecommerce_system_events 표의 PK(UUID)."
        },
        "event_type": {
          "type": "string",
          "description": "이벤트 유형(예: order_created, payment_callback, integration 등)."
        },
        "target_table": {
          "type": "string",
          "description": "이벤트가 영향을 준 비즈니스/도메인 테이블명(ID 참조)."
        },
        "target_id": {
          "type": "string",
          "format": "uuid",
          "description": "이벤트 로그가 연결되는 구체적 비즈니스 데이터의 UUID."
        },
        "payload_json": {
          "type": "string",
          "description": "JSON-직렬화된 이벤트 페이로드. 실제 비즈니스 이벤트의 주요 원본/서브 정보를 구조화된 JSON 문자열로 보관합니다."
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "이 이벤트 로그가 기록된 생성 시각. 로그 추가 이벤트 발생/DB 발생 시 시각(ISO8601)."
        }
      },
      "required": [
        "id",
        "event_type",
        "target_table",
        "target_id",
        "payload_json",
        "created_at"
      ],
      "description": "플랫폼 및 시스템 차원의 도메인 이벤트, 통합 로그, 비즈니스 이벤트를 아우르는 시스템 이벤트 엔터티입니다.\n\nPrisma 스키마 ai_ecommerce_system_events(또는 ai_ecommerce_system_event) 테이블에 1:1 매핑되며, 실시간/비동기 처리를 위한 이벤트 풀, 감사, 통합 디버깅, AI 전처리 등에 활용됩니다."
    },
    "IAiEcommerceSystemEvent.ICreate": {
      "type": "object",
      "properties": {
        "event_type": {
          "type": "string",
          "description": "이벤트 타입(Event/Kind) 문자열. 예: order_created, payment_callback, webhook, integration 등."
        },
        "target_table": {
          "type": "string",
          "description": "이 이벤트와 연결되는(영향 받는) 도메인 테이블명."
        },
        "target_id": {
          "type": "string",
          "format": "uuid",
          "description": "이벤트 대상 비즈니스 엔터티의 UUID."
        },
        "payload_json": {
          "type": "string",
          "description": "이벤트와 연관된 데이터를 담은 JSON 직렬화 문자열. 필요한 각종 context, 추가 정보, 이벤트 내부 구조 전체가 담길 수 있습니다."
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "이벤트 발생 시각. ISO 8601 타임스탬프 준수."
        }
      },
      "required": [
        "event_type",
        "target_table",
        "target_id",
        "payload_json",
        "created_at"
      ],
      "description": "시스템 이벤트(통합 로그) 생성 요청 DTO입니다. Prisma ai_ecommerce_system_events 테이블의 컬럼 구조와 1:1 매칭.\n"
    },
    "IAiEcommerceSystemEvent.IUpdate": {
      "type": "object",
      "properties": {
        "payload_json": {
          "type": "string",
          "description": "수정/보완 후 이벤트 페이로드(구조체) JSON 문자열."
        }
      },
      "required": [
        "payload_json"
      ],
      "description": "시스템 이벤트 로그의 페이로드(이벤트 데이터)를 보정하거나 일부 상태를 수정할 때 사용하는 PATCH/PUT DTO입니다. 대부분의 컬럼은 불변이며, 보조 정보만 교정 목적이나 규제/컴플라이언스 상황에서 수정 가능하도록 설계됩니다."
    },
    "IListAiEcommerceComplianceAudit.Request": {
      "type": "object",
      "properties": {},
      "description": "ai_ecommerce_compliance_audit 테이블(컴플라이언스/규제 감사 로그) 조회 요청의 advanced 검색/필터링 입력 DTO입니다.\n\n보통 audit_type, status, subject_table, admin_id, 기간, 페이징 조건 등이 검색 파라미터로 추가될 수 있습니다.",
      "required": []
    },
    "IPageIAiEcommerceComplianceAudit": {
      "type": "object",
      "properties": {
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/IAiEcommerceComplianceAudit"
          },
          "description": "해당 페이지에 속하는 컴플라이언스 감사 로그 배열입니다."
        },
        "pagination": {
          "$ref": "#/components/schemas/IPage.IPagination",
          "description": "페이지네이션 정보(현재 페이지, 전체 레코드 수 등 제공)."
        }
      },
      "required": [
        "data",
        "pagination"
      ],
      "description": "컴플라이언스 감사 로그(ai_ecommerce_compliance_audit) 목록 페이지네이션 컨테이너 타입입니다.\n\n여러 감사 로그 레코드와 페이징 정보를 함께 반환하여, 관리자 및 감사관의 목록/검색/분석 기능에 최적화되어 있습니다."
    },
    "IAiEcommerceComplianceAudit": {
      "type": "object",
      "description": "Represents a detailed compliance audit log record for the AI-ready shopping mall backend. This entity is used to record legal, regulatory, or privacy-related platform events, as described in the compliance sections of the requirements. Reflects the structure of the ai_ecommerce_compliance_audit table.\n\nA compliance audit row captures critical regulatory events (e.g., GDPR erasure requests, PCI reviews, policy changes), records actor (administrator), event type, audit subject, status and notes, and ensures full 3NF normalization—no denormalized aggregates, and every event is atomic.\n\nAll updates, creations, and deletions are tracked for traceability and legal defensibility. Key for regulator review, legal reporting, and integrated audit/export pipelines.",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "Globally unique identifier for compliance audit record.\n\nReferenced in all future lookups, update, delete, and legal/export logic."
        },
        "admin_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Foreign key to platform administrator who triggered this compliance event.\n\nNull if the action was system-initiated, not directly linked to an admin."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Foreign key to platform administrator who triggered this compliance event.\n\nNull if the action was system-initiated, not directly linked to an admin."
            }
          ],
          "description": "Foreign key to platform administrator who triggered this compliance event.\n\nNull if the action was system-initiated, not directly linked to an admin."
        },
        "audit_type": {
          "type": "string",
          "description": "Type/category of the audit event. Examples: 'GDPR_DELETE', 'PCI_REVIEW', 'POLICY_CHANGE'.\n\nBusiness logic and reporting filter on this property."
        },
        "subject_table": {
          "type": "string",
          "description": "Name of the business table/entity being audited (typically a table name, e.g., 'ai_ecommerce_customer').\n\nAtomic string: not a denormalized object."
        },
        "subject_id": {
          "type": "string",
          "format": "uuid",
          "description": "UUID of the entity (row) under audit; cross-entity for flexible reporting/traceability."
        },
        "status": {
          "type": "string",
          "description": "Outcome/status of the audit event. Examples: 'pending', 'approved', 'rejected', 'processed', etc."
        },
        "notes": {
          "type": "string",
          "description": "Arbitrary context or explanatory notes for the compliance event; atomic, may include rationale, POI, or evidence details."
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "ISO8601 timestamp; when the audit event was created in the DB for immutable timeline analysis."
        }
      },
      "required": [
        "id",
        "audit_type",
        "subject_table",
        "subject_id",
        "status",
        "notes",
        "created_at"
      ]
    },
    "IAiEcommerceComplianceAudit.ICreate": {
      "type": "object",
      "description": "Request payload for creating a new compliance audit record. Used by operator, admin, or automation to insert a new compliance event per audit rules.\n\nRequired on POST /ai_ecommerce/complianceAudit. All fields except admin_id are required; admin_id may be null for system-level events (automation or workflow triggers).",
      "properties": {
        "admin_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Admin (actor) responsible for the compliance event, if applicable."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Admin (actor) responsible for the compliance event, if applicable."
            }
          ],
          "description": "Admin (actor) responsible for the compliance event, if applicable."
        },
        "audit_type": {
          "type": "string",
          "description": "Audit type; required business logic taxonomy (e.g., 'GDPR_DELETE')."
        },
        "subject_table": {
          "type": "string",
          "description": "Target table/entity under compliance review."
        },
        "subject_id": {
          "type": "string",
          "format": "uuid",
          "description": "ID for subject under audit (row/entity)."
        },
        "status": {
          "type": "string",
          "description": "Initial event status: typically 'pending', 'initiated', or business-defined."
        },
        "notes": {
          "type": "string",
          "description": "Context, rationale, or documentation for compliance event."
        }
      },
      "required": [
        "audit_type",
        "subject_table",
        "subject_id",
        "status",
        "notes"
      ]
    },
    "IAiEcommerceComplianceAudit.IUpdate": {
      "type": "object",
      "description": "Payload for updating mutable fields of a compliance audit log entry. Used on PUT for update (e.g., status change, appending legal notes).\n\nImmutable fields on main record (ID, audit_type, subject_table, subject_id, created_at) cannot be altered. Updatable fields include status and notes (e.g., after review, compliance update, external audit, or legal outcome).\n\nBusiness logic prohibits update to non-permitted fields—schema-compliant request yields only legal changes per audit model.",
      "properties": {
        "status": {
          "type": "string",
          "description": "Updated status for audit event (e.g., 'approved', 'rejected', 'processed')."
        },
        "notes": {
          "type": "string",
          "description": "Additional or corrected notes/context for the audit event."
        }
      },
      "required": [
        "status",
        "notes"
      ]
    },
    "IMvCommunityLastActivity.IRequest": {
      "type": "object",
      "description": "Payload for searching or filtering community last-activity records from the materialized view mv_community_last_activity. Used as the request body in PATCH list or search endpoints.\n\nFields enable flexible dashboard, reporting, or analytics queries on activity type, customer id, entity id, activity intervals, with pagination and sort. Supports integration with advanced analytics or AI workflows to fetch cohort-specific or date-range community activity slices.\n\nMay include any filterable, indexed columns from the ERD/Prisma definition of mv_community_last_activity, and pagination controls for result management.",
      "properties": {
        "customer_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Unique identifier for the customer whose community activity is being queried. Null for all users."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Unique identifier for the customer whose community activity is being queried. Null for all users."
            }
          ],
          "description": "Unique identifier for the customer whose community activity is being queried. Null for all users."
        },
        "thread_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Thread context for activity filtering, if any."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Thread context for activity filtering, if any."
            }
          ],
          "description": "Thread context for activity filtering, if any."
        },
        "inquiry_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Inquiry context for filtering."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Inquiry context for filtering."
            }
          ],
          "description": "Inquiry context for filtering."
        },
        "review_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Review context for filtering."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Review context for filtering."
            }
          ],
          "description": "Review context for filtering."
        },
        "comment_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Comment context for filtering."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Comment context for filtering."
            }
          ],
          "description": "Comment context for filtering."
        },
        "last_activity_type": {
          "oneOf": [
            {
              "type": "string",
              "description": "Activity type string enum—'comment', 'review', 'thread', 'inquiry', etc. Allows filtering for specific event/activity slices. Null for all types."
            },
            {
              "type": "null",
              "description": "Activity type string enum—'comment', 'review', 'thread', 'inquiry', etc. Allows filtering for specific event/activity slices. Null for all types."
            }
          ],
          "description": "Activity type string enum—'comment', 'review', 'thread', 'inquiry', etc. Allows filtering for specific event/activity slices. Null for all types."
        },
        "last_activity_at_gte": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "ISO8601 datetime string: filter for activities on or after this timestamp."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "ISO8601 datetime string: filter for activities on or after this timestamp."
            }
          ],
          "description": "ISO8601 datetime string: filter for activities on or after this timestamp."
        },
        "last_activity_at_lte": {
          "oneOf": [
            {
              "type": "string",
              "format": "date-time",
              "description": "ISO8601 datetime string: filter for activities up to and including this timestamp."
            },
            {
              "type": "null",
              "format": "date-time",
              "description": "ISO8601 datetime string: filter for activities up to and including this timestamp."
            }
          ],
          "description": "ISO8601 datetime string: filter for activities up to and including this timestamp."
        },
        "sort_by": {
          "oneOf": [
            {
              "type": "string",
              "description": "Sort field if required (e.g., 'last_activity_at', 'activity_type')."
            },
            {
              "type": "null",
              "description": "Sort field if required (e.g., 'last_activity_at', 'activity_type')."
            }
          ],
          "description": "Sort field if required (e.g., 'last_activity_at', 'activity_type')."
        },
        "sort_order": {
          "oneOf": [
            {
              "const": "asc",
              "description": "Sort order: enum 'asc', 'desc', or null (default)."
            },
            {
              "const": "desc",
              "description": "Sort order: enum 'asc', 'desc', or null (default)."
            },
            {
              "type": "null",
              "enum": [
                "asc",
                "desc",
                null
              ],
              "description": "Sort order: enum 'asc', 'desc', or null (default)."
            }
          ],
          "description": "Sort order: enum 'asc', 'desc', or null (default)."
        },
        "page": {
          "oneOf": [
            {
              "type": "integer",
              "description": "Page number for paginated query."
            },
            {
              "type": "null",
              "description": "Page number for paginated query."
            }
          ],
          "description": "Page number for paginated query."
        },
        "limit": {
          "oneOf": [
            {
              "type": "integer",
              "description": "Results per page for pagination (default and/or max limits apply)."
            },
            {
              "type": "null",
              "description": "Results per page for pagination (default and/or max limits apply)."
            }
          ],
          "description": "Results per page for pagination (default and/or max limits apply)."
        }
      },
      "required": []
    },
    "IPageIMvCommunityLastActivity": {
      "type": "object",
      "description": "Paginated result wrapper for mv_community_last_activity records, supporting efficient dashboard, analytics, or bulk reporting access. Used as the standard response container for PATCH list/search endpoints. \n\nContains a 'data' array of mv_community_last_activity objects (atomically-typed per entity model), and a 'pagination' metadata object outlining paging info such as limit, current page, total records, and total pages. Strictly normalized: all aggregates must be computed externally/elsewhere except for count metadata.\n\nUsed to return a scrollable/browseable result set to UIs or reporting tools.",
      "properties": {
        "pagination": {
          "$ref": "#/components/schemas/IPage.IPagination",
          "description": "Paging metadata (current, limit, total records, total pages) for analytics result context."
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/IMvCommunityLastActivity"
          },
          "description": "Array of mv_community_last_activity result objects for this page."
        }
      },
      "required": [
        "pagination",
        "data"
      ]
    },
    "IMvCommunityLastActivity": {
      "type": "object",
      "description": "Atomic read-only record of last community activity snapshot, per the mv_community_last_activity materialized view. Used to display cross-entity, cross-domain activity in dashboards, AI cohort analytics, or customer engagement reports.\n\nEach row represents one user's/entity's most recent activity for a given context (thread, inquiry, review, comment, etc), supporting fast lookup without denormalized data. All entity lookups are by foreign key, atomic per 3NF, with strict typing on activity_type and datetime values.\n\nCannot be mutated except via refresh process (MV update), not via business logic. Direct POST/PUT/DELETE only in exceptional admin/analytics loops.",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "Stable unique identifier for this last activity entry. Keys all dashboard/report joins and analytics drilldowns."
        },
        "customer_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Customer/user context for this activity. Null for record not tied to a specific user."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Customer/user context for this activity. Null for record not tied to a specific user."
            }
          ],
          "description": "Customer/user context for this activity. Null for record not tied to a specific user."
        },
        "thread_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Thread context entity, if any."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Thread context entity, if any."
            }
          ],
          "description": "Thread context entity, if any."
        },
        "comment_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Comment entity id, if any."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Comment entity id, if any."
            }
          ],
          "description": "Comment entity id, if any."
        },
        "inquiry_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Inquiry entity id, if any."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Inquiry entity id, if any."
            }
          ],
          "description": "Inquiry entity id, if any."
        },
        "review_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Review entity id, if any."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Review entity id, if any."
            }
          ],
          "description": "Review entity id, if any."
        },
        "last_activity_type": {
          "type": "string",
          "description": "Type/enum string describing the activity: 'comment', 'review', 'thread', etc."
        },
        "last_activity_at": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp when last activity was recorded for this context scope (UTC/ISO8601)."
        }
      },
      "required": [
        "id",
        "last_activity_type",
        "last_activity_at"
      ]
    },
    "IMvCommunityLastActivity.ICreate": {
      "type": "object",
      "description": "Payload for inserting a new row into mv_community_last_activity (when supported by writable view or during admin repair). Used to seed the view with known state or for advanced analytics. All fields mirror the core entity definition.",
      "properties": {
        "customer_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "FK for user/customer context—null for entity-level activity."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "FK for user/customer context—null for entity-level activity."
            }
          ],
          "description": "FK for user/customer context—null for entity-level activity."
        },
        "thread_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "FK for thread context."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "FK for thread context."
            }
          ],
          "description": "FK for thread context."
        },
        "comment_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "FK for comment context."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "FK for comment context."
            }
          ],
          "description": "FK for comment context."
        },
        "inquiry_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "FK for inquiry context."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "FK for inquiry context."
            }
          ],
          "description": "FK for inquiry context."
        },
        "review_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "FK for review context."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "FK for review context."
            }
          ],
          "description": "FK for review context."
        },
        "last_activity_type": {
          "type": "string",
          "description": "Activity type, as enumerated per dashboard context ('comment', 'review', 'thread', etc)."
        },
        "last_activity_at": {
          "type": "string",
          "format": "date-time",
          "description": "ISO8601 UTC time for last activity (activity timestamp)."
        }
      },
      "required": [
        "last_activity_type",
        "last_activity_at"
      ]
    },
    "mvCommunityLastActivity.IUpdate": {
      "type": "object",
      "description": "Payload for updating (full replace/PUT) of a mvCommunityLastActivity entity in the materialized view (when admin/analytics endpoint allows direct mutation). Used only in advanced, privileged analytics repair flows, not normal business logic. Fields must match the main entity structure by schema.",
      "properties": {
        "customer_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "FK for user/customer scope."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "FK for user/customer scope."
            }
          ],
          "description": "FK for user/customer scope."
        },
        "thread_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Thread FK."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Thread FK."
            }
          ],
          "description": "Thread FK."
        },
        "comment_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Comment FK."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Comment FK."
            }
          ],
          "description": "Comment FK."
        },
        "inquiry_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Inquiry FK."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Inquiry FK."
            }
          ],
          "description": "Inquiry FK."
        },
        "review_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Review FK."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Review FK."
            }
          ],
          "description": "Review FK."
        },
        "last_activity_type": {
          "type": "string",
          "description": "Type of activity."
        },
        "last_activity_at": {
          "type": "string",
          "format": "date-time",
          "description": "ISO8601 timestamp when last activity occurred (update/PUT replaces this value)."
        }
      },
      "required": [
        "last_activity_type",
        "last_activity_at"
      ]
    },
    "mvCommunityLastActivity": {
      "type": "object",
      "description": "Entity definition for mvCommunityLastActivity—a materialized view row recording the last community activity for a user or entity. Used by dashboards, analytics, and AI pipelines for rapid access to engagement signals.\n\nFields mirror the base table/view: all FKs are atomic, activity type is a string enum, and activity time is an ISO date. Any modification (PUT/POST) only in advanced admin/analytics flows.\n\nThis schema is used for full entity representation in GET, listing, and mutation endpoints.",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "Unique primary key of the last activity record; immutable, UUIDv4."
        },
        "customer_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Foreign key to the customer associated with this activity. Null for entity-level activity."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Foreign key to the customer associated with this activity. Null for entity-level activity."
            }
          ],
          "description": "Foreign key to the customer associated with this activity. Null for entity-level activity."
        },
        "thread_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Thread context identifier (nullable)."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Thread context identifier (nullable)."
            }
          ],
          "description": "Thread context identifier (nullable)."
        },
        "comment_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Comment entity context/fk (nullable)."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Comment entity context/fk (nullable)."
            }
          ],
          "description": "Comment entity context/fk (nullable)."
        },
        "inquiry_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Inquiry reference if present."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Inquiry reference if present."
            }
          ],
          "description": "Inquiry reference if present."
        },
        "review_id": {
          "oneOf": [
            {
              "type": "string",
              "format": "uuid",
              "description": "Review reference if present."
            },
            {
              "type": "null",
              "format": "uuid",
              "description": "Review reference if present."
            }
          ],
          "description": "Review reference if present."
        },
        "last_activity_type": {
          "type": "string",
          "description": "Atomic string describing the activity type; used by analytics and dashboards for faceting/reporting."
        },
        "last_activity_at": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp marking the last activity event; ISO-8601 UTC."
        }
      },
      "required": [
        "id",
        "last_activity_type",
        "last_activity_at"
      ]
    },
    "mvDailyStats.IRequest": {
      "type": "object",
      "description": "Request object for searching or filtering records in the mv_daily_stats materialized analytics view. Used in PATCH endpoints to filter daily statistics for platform analytics, dashboards, or reporting.\n\nSupports flexible filtering for date, order_count, revenue_amount, or login/signups/review count intervals, with pagination and sort options for custom analytics consumption.",
      "properties": {
        "stat_date_gte": {
          "oneOf": [
            {
              "type": "string",
              "description": "Start date boundary for search (YYYY-MM-DD string, null for open range)."
            },
            {
              "type": "null",
              "description": "Start date boundary for search (YYYY-MM-DD string, null for open range)."
            }
          ],
          "description": "Start date boundary for search (YYYY-MM-DD string, null for open range)."
        },
        "stat_date_lte": {
          "oneOf": [
            {
              "type": "string",
              "description": "End date boundary for search (YYYY-MM-DD string, null for open range)."
            },
            {
              "type": "null",
              "description": "End date boundary for search (YYYY-MM-DD string, null for open range)."
            }
          ],
          "description": "End date boundary for search (YYYY-MM-DD string, null for open range)."
        },
        "min_order_count": {
          "oneOf": [
            {
              "type": "integer",
              "description": "Minimum order count for analytic filtering (null for none)."
            },
            {
              "type": "null",
              "description": "Minimum order count for analytic filtering (null for none)."
            }
          ],
          "description": "Minimum order count for analytic filtering (null for none)."
        },
        "max_order_count": {
          "oneOf": [
            {
              "type": "integer",
              "description": "Maximum order count for analytic filtering (null for none)."
            },
            {
              "type": "null",
              "description": "Maximum order count for analytic filtering (null for none)."
            }
          ],
          "description": "Maximum order count for analytic filtering (null for none)."
        },
        "min_revenue_amount": {
          "oneOf": [
            {
              "type": "number",
              "description": "Minimum revenue amount filter."
            },
            {
              "type": "null",
              "description": "Minimum revenue amount filter."
            }
          ],
          "description": "Minimum revenue amount filter."
        },
        "max_revenue_amount": {
          "oneOf": [
            {
              "type": "number",
              "description": "Maximum revenue amount filter."
            },
            {
              "type": "null",
              "description": "Maximum revenue amount filter."
            }
          ],
          "description": "Maximum revenue amount filter."
        },
        "min_login_count": {
          "oneOf": [
            {
              "type": "integer",
              "description": "Filter by minimum login count."
            },
            {
              "type": "null",
              "description": "Filter by minimum login count."
            }
          ],
          "description": "Filter by minimum login count."
        },
        "max_login_count": {
          "oneOf": [
            {
              "type": "integer",
              "description": "Filter by maximum login count."
            },
            {
              "type": "null",
              "description": "Filter by maximum login count."
            }
          ],
          "description": "Filter by maximum login count."
        },
        "min_signups_count": {
          "oneOf": [
            {
              "type": "integer",
              "description": "Filter by minimum signups count."
            },
            {
              "type": "null",
              "description": "Filter by minimum signups count."
            }
          ],
          "description": "Filter by minimum signups count."
        },
        "max_signups_count": {
          "oneOf": [
            {
              "type": "integer",
              "description": "Filter by maximum signups count."
            },
            {
              "type": "null",
              "description": "Filter by maximum signups count."
            }
          ],
          "description": "Filter by maximum signups count."
        },
        "min_review_count": {
          "oneOf": [
            {
              "type": "integer",
              "description": "Filter by minimum review count."
            },
            {
              "type": "null",
              "description": "Filter by minimum review count."
            }
          ],
          "description": "Filter by minimum review count."
        },
        "max_review_count": {
          "oneOf": [
            {
              "type": "integer",
              "description": "Filter by maximum review count."
            },
            {
              "type": "null",
              "description": "Filter by maximum review count."
            }
          ],
          "description": "Filter by maximum review count."
        },
        "sort_by": {
          "oneOf": [
            {
              "type": "string",
              "description": "Sort field ('stat_date', 'order_count', etc.; null for default)."
            },
            {
              "type": "null",
              "description": "Sort field ('stat_date', 'order_count', etc.; null for default)."
            }
          ],
          "description": "Sort field ('stat_date', 'order_count', etc.; null for default)."
        },
        "sort_order": {
          "oneOf": [
            {
              "const": "asc",
              "description": "Sort order (asc/desc/null)."
            },
            {
              "const": "desc",
              "description": "Sort order (asc/desc/null)."
            },
            {
              "type": "null",
              "enum": [
                "asc",
                "desc",
                null
              ],
              "description": "Sort order (asc/desc/null)."
            }
          ],
          "description": "Sort order (asc/desc/null)."
        },
        "page": {
          "oneOf": [
            {
              "type": "integer",
              "description": "Page number for pagination (null for default)."
            },
            {
              "type": "null",
              "description": "Page number for pagination (null for default)."
            }
          ],
          "description": "Page number for pagination (null for default)."
        },
        "limit": {
          "oneOf": [
            {
              "type": "integer",
              "description": "Page limit."
            },
            {
              "type": "null",
              "description": "Page limit."
            }
          ],
          "description": "Page limit."
        }
      },
      "required": []
    },
    "IPageMvDailyStats": {
      "type": "object",
      "description": "Paginated result set for mvDailyStats analytics view records. Used in API responses as the standard structure for listing query results in PATCH/list endpoints for the analytics dashboard or reporting interfaces.\n\nAggregation or business intelligence tools consume this page structure, which includes both data (array of mvDailyStats) and pagination/count metadata—total new records, current page, page size, total count, etc.",
      "properties": {
        "pagination": {
          "$ref": "#/components/schemas/IPage.IPagination",
          "description": "Metadata for requested pagination (current, limit, total records/pages)."
        },
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/mvDailyStats"
          },
          "description": "Array of mvDailyStats records returned for this page."
        }
      },
      "required": [
        "pagination",
        "data"
      ]
    },
    "mvDailyStats": {
      "type": "object",
      "description": "Single row from ai_ecommerce.mv_daily_stats materialized analytics view. Represents platform-wide aggregation of daily sales, orders, logins, signups, and reviews for a single calendar day. Used as the atomic entity in analytics dashboards, statistical charting, reporting/reconciliation, and AI/ML input sets.\n\nDenormalization is permitted here for performance (each field is an aggregate snapshot for the day).",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "Unique ID for stats row; UUID of the analytics view entry."
        },
        "stat_date": {
          "type": "string",
          "description": "Date for this record, format 'YYYY-MM-DD' (ISO) as string—key for daily analytics."
        },
        "order_count": {
          "type": "integer",
          "description": "Total number of orders on this date."
        },
        "revenue_amount": {
          "type": "number",
          "description": "Summed order/revenue amount (platform currency/exchange base)."
        },
        "login_count": {
          "type": "integer",
          "description": "Number of distinct logins (unique users) on this day."
        },
        "signups_count": {
          "type": "integer",
          "description": "Aggregate users registered on this date."
        },
        "review_count": {
          "type": "integer",
          "description": "Number of reviews written on this date."
        }
      },
      "required": [
        "id",
        "stat_date",
        "order_count",
        "revenue_amount",
        "login_count",
        "signups_count",
        "review_count"
      ]
    },
    "mvDailyStats.ICreate": {
      "type": "object",
      "properties": {
        "stat_date": {
          "type": "string",
          "description": "The ISO date (YYYY-MM-DD) representing the day for which the statistics are recorded. Used as the primary reference date for daily aggregation in analytics dashboards and reporting tools.\n\nShould follow the ISO 8601 standard and match business regional settings. Examples: '2025-07-01', '2024-12-31'."
        },
        "order_count": {
          "type": "integer",
          "description": "The number of orders placed on the given stat_date. Aggregated from order data for reporting, KPI dashboards, and trend analytics.\n\nMust be a non-negative integer. For example: 100."
        },
        "revenue_amount": {
          "type": "number",
          "format": "double",
          "description": "The total revenue (sum of order amounts) for the day. Used in financial reporting, analytics, and trend monitoring.\n\nRepresents the sum in the platform's base currency (usually KRW, USD, etc.). Should match double-precision floating-point format. Examples: 1250000.75."
        },
        "login_count": {
          "type": "integer",
          "description": "Total unique user logins registered on the specific stat_date. Supports platform engagement and analytics use cases.\n\nMust be non-negative. Example: 250."
        },
        "signups_count": {
          "type": "integer",
          "description": "The number of new account registrations that occurred on the stat_date. Supports growth, onboarding, and user acquisition metrics for analytics and admin dashboards.\n\nShould be a non-negative integer (e.g., 20)."
        },
        "review_count": {
          "type": "integer",
          "description": "Number of new product reviews posted on the stat_date. Used for engagement analytics and platform health reporting.\n\nShould be non-negative. For example: 10."
        }
      },
      "required": [
        "stat_date",
        "order_count",
        "revenue_amount",
        "login_count",
        "signups_count",
        "review_count"
      ],
      "description": "Creation structure for mvDailyStats, representing a day's aggregated analytics. Must include all fields for atomic, non-aggregated reporting. Derived from Prisma schema mv_daily_stats table and described for compliance/audit in analytics reporting. All fields are atomic and required."
    },
    "mvDailyStats.IUpdate": {
      "type": "object",
      "properties": {
        "stat_date": {
          "type": "string",
          "description": "ISO date (YYYY-MM-DD) for the stats row. See mvDailyStats.ICreate for description."
        },
        "order_count": {
          "type": "integer",
          "description": "Updated order count for this day. See mvDailyStats.ICreate for description."
        },
        "revenue_amount": {
          "type": "number",
          "format": "double",
          "description": "Updated revenue for this day. See mvDailyStats.ICreate for description."
        },
        "login_count": {
          "type": "integer",
          "description": "Updated login count for this day. See mvDailyStats.ICreate for description."
        },
        "signups_count": {
          "type": "integer",
          "description": "Updated signups count for this day. See mvDailyStats.ICreate for description."
        },
        "review_count": {
          "type": "integer",
          "description": "Updated review count for this day. See mvDailyStats.ICreate for description."
        }
      },
      "required": [
        "stat_date",
        "order_count",
        "revenue_amount",
        "login_count",
        "signups_count",
        "review_count"
      ],
      "description": "Update structure for mvDailyStats. Used for entire row replacement as described in PUT endpoint documentation. All fields are required to ensure the materialized view row is completely replaced. Descriptions are as in mvDailyStats.ICreate."
    },
    "mvTrendingProducts.IRequest": {
      "type": "object",
      "properties": {
        "stat_period": {
          "type": "string",
          "description": "The time period granularity for the trending analysis. Typically values: 'daily', 'weekly', 'monthly'. Enables filtering/searching by aggregation level in dashboards or analytics UIs.\n\nBusiness logic expects strict enumeration in implementations."
        },
        "stat_date": {
          "type": "string",
          "description": "The ISO date (YYYY-MM-DD) for the trending statistic group. Enables filtering and analytics queries by date window. Follows ISO 8601.\n\nExamples: '2025-07-16', '2025-07-01'."
        },
        "trend_rank": {
          "type": "integer",
          "description": "The minimum or exact rank value for trend filtering (e.g., top 5, 10, etc). Used in analytics to order/filter trending product results.\n\nShould be positive integer if used."
        },
        "product_id": {
          "type": "string",
          "description": "Unique product identifier (UUID format) to filter trending stats for a specific product. Enables focused analytics on a single product's trending performance."
        }
      },
      "description": "Request/filtering parameters for listing/searching mvTrendingProducts analytics records. Used by PATCH endpoint for dashboard analytics, top-product feeds, or AI-powered recommendation systems. Properties correspond to analytics filtering use cases as described in the ERD and endpoint specs.",
      "required": []
    },
    "IPageMvTrendingProducts": {
      "type": "object",
      "properties": {
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/mvTrendingProducts"
          },
          "description": "Array of mvTrendingProducts analytic records matching the query/filter criteria.\n\nEach item contains all atomic analytics information for a product/stat period/stat date combination."
        },
        "pagination": {
          "type": "object",
          "properties": {
            "current": {
              "type": "integer",
              "description": "Current page number for paginated result. Used in conjunction with limit and total counts for UI and API navigation.\n\nZero or one-based depending on API design."
            },
            "limit": {
              "type": "integer",
              "description": "Number of records per page (page size). Default can be 100; should match request or system policy.\n\nUsed by UI and scripts for batch processing."
            },
            "records": {
              "type": "integer",
              "description": "Total records found for query. Used for pagination controls in APIs and UIs.\n\nAlways non-negative integer."
            },
            "pages": {
              "type": "integer",
              "description": "Total pages of results available for current query and pagination size. Calculated by records and limit."
            }
          },
          "required": [
            "current",
            "limit",
            "records",
            "pages"
          ],
          "description": "Pagination metadata following IPage.IPagination structure: current, limit, records, pages."
        }
      },
      "required": [
        "data",
        "pagination"
      ],
      "description": "Paginated result set for mvTrendingProducts listing/search operations. Includes both array of analytics records and pagination metadata following IPage<I> interface as described in the AI E-Commerce documentation."
    },
    "mvTrendingProducts": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uuid",
          "description": "Unique identifier for the trending product analytics record. Used as PK for the materialized view row as per ERD."
        },
        "product_id": {
          "type": "string",
          "format": "uuid",
          "description": "Reference to the ai_ecommerce_product row for which the trending analytics data is recorded. Required for joining and analytics reporting.\n\nMust match product PK in product catalog."
        },
        "stat_period": {
          "type": "string",
          "description": "Denotes time aggregation period for trending analytics (e.g., 'daily', 'weekly', 'monthly'). Value is typically used as an enum for period grouping.\n\nUsed for dashboard, recommendation, and analytics granularity."
        },
        "stat_date": {
          "type": "string",
          "description": "The ISO date (YYYY-MM-DD) for the trending product analytics interval. Used for grouping and time-based reporting.\n\nFollows ISO 8601 business conventions."
        },
        "trend_rank": {
          "type": "integer",
          "description": "Trending rank for this product in the specified period/date. Lower values indicate higher rank (e.g., 1 = top trend, 2, ...)."
        },
        "sales_count": {
          "type": "integer",
          "description": "Total count of sales for this product in the analytical window (stat_period/stat_date). Used for trending calculation and analytics dashboards."
        },
        "views_count": {
          "type": "integer",
          "description": "Total views of the product in the given stat_period/stat_date. Used for popularity scoring and AI recommendation algorithms."
        },
        "composite_score": {
          "type": "number",
          "format": "double",
          "description": "Business-configured composite score for trending products, calculated using sales, views, reviews, and additional analytics fields. Used to order/rank trending products/analytics.\n\nShould reflect normalized or weighted algorithm scoring."
        }
      },
      "required": [
        "id",
        "product_id",
        "stat_period",
        "stat_date",
        "trend_rank",
        "sales_count",
        "views_count",
        "composite_score"
      ],
      "description": "Materialized view record for trending products analytics. Contains all atomic, normalized analytics properties including rank, sales, views, and business composite score. Derived directly from Prisma schema ai_ecommerce_mv_trending_products and ERD specifications."
    },
    "mvTrendingProducts.ICreate": {
      "type": "object",
      "properties": {
        "product_id": {
          "type": "string",
          "format": "uuid",
          "description": "UUID reference to the product being ranked in this trending analytics window. Must correspond to PK in ai_ecommerce_product."
        },
        "stat_period": {
          "type": "string",
          "description": "Period aggregation for trending analytics (enum: 'daily', 'weekly', 'monthly'). Required for analytics aggregation/grouping.\n\nBusiness rules expect system-enforced content."
        },
        "stat_date": {
          "type": "string",
          "description": "Date string (ISO 8601, YYYY-MM-DD) representing the window for trending analytics. Used for filtering, UI display, and analytics grouping."
        },
        "trend_rank": {
          "type": "integer",
          "description": "Rank of this product for this period/date combination. Lower means higher trending position (1 = top trending).\n\nMust be a positive integer."
        },
        "sales_count": {
          "type": "integer",
          "description": "Total number of times the product was sold in this stat period/date. Used in analytics for trend scoring.\n\nNon-negative integer; required for full analytics row."
        },
        "views_count": {
          "type": "integer",
          "description": "Total number of times this product was viewed in the stat window. Used in composite scoring, analytics dashboards, and AI ranking.\n\nMust be non-negative integer."
        },
        "composite_score": {
          "type": "number",
          "format": "double",
          "description": "Composite (algorithmic) score used in trend ranking and AI/ML models. Calculated from sales, views, and engagement stats as per business rule.\n\nShould match normalized or weighted scoring as described in algorithm documentation."
        }
      },
      "required": [
        "product_id",
        "stat_period",
        "stat_date",
        "trend_rank",
        "sales_count",
        "views_count",
        "composite_score"
      ],
      "description": "Create structure for new analytics record in mvTrendingProducts (materialized view). All properties are required for atomic reporting, derived from ERD Prisma schema commented explanations."
    },
    "mvTrendingProducts.IUpdate": {
      "type": "object",
      "properties": {
        "product_id": {
          "type": "string",
          "format": "uuid",
          "description": "UUID reference for the product to update trending stats for."
        },
        "stat_period": {
          "type": "string",
          "description": "Period aggregation value ('daily', 'weekly', 'monthly')."
        },
        "stat_date": {
          "type": "string",
          "description": "ISO 8601 date string for stats window."
        },
        "trend_rank": {
          "type": "integer",
          "description": "Updated trending rank for product/stat period/stat date."
        },
        "sales_count": {
          "type": "integer",
          "description": "Updated total sales for trending row."
        },
        "views_count": {
          "type": "integer",
          "description": "Updated total view count for the product window."
        },
        "composite_score": {
          "type": "number",
          "format": "double",
          "description": "Updated composite score for AI/analytics ranking/scoring."
        }
      },
      "required": [
        "product_id",
        "stat_period",
        "stat_date",
        "trend_rank",
        "sales_count",
        "views_count",
        "composite_score"
      ],
      "description": "Update structure for mvTrendingProducts: full replacement of analytics row for a trending product, stat period, and window. All atomic fields required. Used with PUT endpoint, descriptions as in ICreate."
    }
  },
  "authorization": [
    {
      "name": "customer",
      "description": "Individual users who can browse products, place orders, manage favorites, write reviews/inquiries, and access personalized features after authenticating via API. Customers may be members, guests, or external platform users."
    },
    {
      "name": "seller",
      "description": "Authenticated business users who can list, manage, and fulfill products, view analytics, issue coupons, and respond to inquiries or reviews. Sellers manage their product catalogs and order workflow via API."
    },
    {
      "name": "administrator",
      "description": "Platform-wide managers with permissions for system configuration, seller onboarding, channel management, marketing tools, and regulatory/audit modules. Administrators can access all system APIs for operational and analytic purposes."
    }
  ]
}